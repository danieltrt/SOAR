file_path,api_count,code
setup/install_anaconda_environments.py,0,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nThis script installs the Anaconda virtual environment required to run calipy.\r\n""""""\r\n\r\n# System packages\r\nimport os\r\nimport sys\r\nimport shutil\r\nfrom six.moves import input\r\n\r\ndef main():\r\n    # Initialize variables\r\n    base_path = None\r\n\r\n    # Check that Anaconda is installed and we can run the command \'conda\' from shell.\r\n    command_string = \'conda --version\'\r\n    print(command_string)\r\n    exit_code = os.system(command_string)\r\n    if exit_code != 0:\r\n        return  # Stop execution. The error message is printed in the console\r\n\r\n    # Get the absolute path of this file\r\n    code_dir = os.path.dirname(os.path.realpath(__file__))\r\n\r\n    # Check that .yml files exist\r\n    environment_files = list()\r\n    environment_files.append(os.path.join(code_dir, \'calipy.yml\'))\r\n    for yml_file in environment_files:\r\n        if not os.path.exists(yml_file):\r\n            raise OSError(\'%s does not exist.\' % yml_file)\r\n\r\n    # If we got here, all files exist and conda is installed.\r\n\r\n\r\n    ############################################################################\r\n    # Update Anaconda\'s conda\r\n    ############################################################################\r\n    question = \'Update conda? (y/[n])\'\r\n    while True:\r\n        # Ask user for instructions\r\n        answer = input(question)\r\n        # Change Enter into the default option (\'no\')\r\n        if answer == \'\':\r\n            answer = \'n\'\r\n        # Keep only first letter\r\n        answer = answer.lower()[0]\r\n        # Stop if got a \'yes\' or \'no\'\r\n        if answer in [\'y\', \'n\']:\r\n            break\r\n        else:\r\n            print(\'Please try again\')\r\n            continue\r\n\r\n    if answer == \'y\':\r\n        # Make a string containing the command to pass to shell\r\n        command_string = \'conda update --yes conda\'\r\n        # Run the command\r\n        print(command_string)\r\n        exit_code = os.system(command_string)\r\n        if exit_code != 0:\r\n            return  # Stop execution. The error message is printed in the console\r\n\r\n    else:\r\n        print(\'Will not update conda\')\r\n\r\n    ############################################################################\r\n    # Current environment\r\n    ############################################################################\r\n    # Get the path from where python is executing\r\n    python_exe_path = sys.executable\r\n\r\n    ############################################################################\r\n    # Install environments\r\n    ############################################################################\r\n    for yml_file in environment_files:\r\n        # Read name of environment\r\n        with open(yml_file, \'r\') as f:\r\n            txt = f.readlines()\r\n        # Find line to read\r\n        line = [i for i in txt if i.startswith(\'name:\')][0].strip()\r\n        # Remove \'name: \' and keep environment name\r\n        environment_name = line[6:]\r\n\r\n        # Check whether environment exists\r\n        env_exists = does_environment_exist(environment_name)\r\n        # If the environment to reinstall is the current one\r\n        if environment_name in python_exe_path:\r\n            print(\'Cannot re-install the environment from which python is currently running.\')\r\n            continue\r\n\r\n        # Ask the user what to do\r\n        if env_exists:\r\n            question = \'Would you like to delete and re-install the environment \\\'%s\\\'? (y/n)\' % environment_name\r\n            while True:\r\n                # Ask user for instructions\r\n                answer = input(question)\r\n                # There is no default option. We need an answer\r\n                if answer == \'\':\r\n                    print(\'Please pick one\')\r\n                    continue\r\n                # Keep only first letter\r\n                answer = answer.lower()[0]\r\n                # Stop if got a \'yes\' or \'no\'\r\n                if answer in [\'y\', \'n\']:\r\n                    break\r\n                else:\r\n                    print(\'Please try again\')\r\n\r\n        else:  # Otherwise install the environment automatically\r\n            answer = \'y\'\r\n\r\n        # Process user instructions\r\n        if answer == \'n\':\r\n            print(\'Skipping \\\'%s\\\'\' % environment_name)\r\n            continue\r\n\r\n        if env_exists:\r\n            # Make a string containing the command to pass to Windows\' shell\r\n            command_string = \'conda remove -n %s --yes --all\' % environment_name\r\n            # Run command\r\n            print(command_string)\r\n            exit_code = os.system(command_string)\r\n            if exit_code != 0:\r\n                return  # Stop execution. The error message is printed in the console\r\n\r\n            # Check that folder doesn\'t exist anymore\r\n            # Get list of environments installed\r\n            list_of_envs = os.popen(\'conda info --envs\').read()\r\n            # Split into lines\r\n            list_of_envs = list_of_envs.split(\'\\n\')\r\n            for row in list_of_envs:\r\n                if \' * \' in row:\r\n                    base_path = row.split(\'*\')[1].strip()\r\n                    break\r\n            # If the end path is not \'envs\', go down one level\r\n            path_items = base_path.split(os.sep)\r\n            if path_items[-1] != \'envs\':\r\n                base_path = os.path.join(base_path, \'envs\')\r\n            # Check whether environment folder still exists\r\n            env_dir = os.path.join(base_path, environment_name)\r\n            if os.path.exists(env_dir):  # If so, delete it\r\n                shutil.rmtree(env_dir)\r\n\r\n        # Create the environment using the .yml file\r\n        # Make a string containing the command to pass to Windows\' shell\r\n        command_string = \'conda env create -n %s -f ""%s""\' % (environment_name, yml_file)\r\n        # Run command\r\n        print(command_string)\r\n        exit_code = os.system(command_string)\r\n        if exit_code != 0:\r\n            return  # Stop execution. The error message is printed in the console\r\n\r\n        # Test installation\r\n        env_exists = does_environment_exist(environment_name)\r\n        if not env_exists:\r\n            raise Exception(\'Problem in getting access to the environment \\\'%s\\\' after creating it. Try reinstalling it\' % environment_name)\r\n\r\n    print(\'\\nSuccess!!!\\n\')\r\n\r\n\r\n################################################################################\r\n# Helper functions\r\n################################################################################\r\ndef does_environment_exist(env_name):\r\n    """"""Check whether the environment exists already.\r\n\r\n    :param env_name: [str] The name of the environment to check\r\n    """"""\r\n    # Make a string containing the command to pass to the shell\r\n    if os.name == \'nt\':  # on Windows\r\n        base_command = \'conda activate\'\r\n    else:  # on Mac and Linux\r\n        base_command = \'source activate\'\r\n    # Append environment name to command\r\n    command_string = \'%s %s\' % (base_command, env_name)\r\n    # Silence output on Windows\r\n    if os.name == \'nt\':\r\n        command_string += \' > NUL 2>&1\'\r\n\r\n    # Run command\r\n    print(command_string)\r\n    exit_code = os.system(command_string)\r\n\r\n    # If shell quit normally the environment exists\r\n    if exit_code == 0:\r\n        return True\r\n    else:  # Otherwise, it doesn\'t\r\n        return False\r\n\r\n\r\n################################################################################\r\n# Direct call to function\r\n################################################################################\r\nif __name__ == \'__main__\':\r\n    main()\r\n'"
src/calipy/__init__.py,0,"b""import sys\n\n# ------------------------------------------------------------------------------\n# Print error messages from Qt\n# Back up the reference to the exceptionhook\n# Back up the reference to the exception hook\nsys._excepthook = sys.excepthook\n\ndef my_exception_hook(exctype, value, traceback):\n    # Print the error and traceback\n    print(exctype, value, traceback)\n    sys.stdout.write(exctype, value, traceback)\n    sys.stdout.write('\\n')\n    sys.stdout.flush()\n    # Call the normal Exception hook after\n    sys._excepthook(exctype, value, traceback)\n    sys.exit(1)\n"""
src/calipy/_run.py,0,"b""# System\nimport sys\nimport os\nfrom glob import glob\nimport json\nfrom PyQt5.QtWidgets import QFileDialog\n\n# Local repository\nfrom calipy.calipy_GUI import CalIpy\nfrom calipy.utils.IO_operations import prepare_data_for_GUI, log\nfrom calipy.utils.Qt import Qt5_QtApp\n\n\nif __name__ == '__main__':\n    # Get user inputs\n    if len(sys.argv) <= 1:\n        app = Qt5_QtApp()\n        # Set default folder to user's home folder\n        home = os.path.expanduser('~')\n        tiff_folder = QFileDialog.getExistingDirectory(None, 'Choose folder containing TIFF files', home, QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)\n        # Return if user canceled\n        if tiff_folder == '':\n            log('User canceled')\n            exit(code=0)\n\n        # Ask for output folder\n        output_folder = QFileDialog.getExistingDirectory(None, 'Choose folder where to store data', tiff_folder, QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)\n        # Return if user canceled\n        if output_folder == '':\n            log('User canceled')\n            exit(code=0)\n\n        # Simple shortcut for debugging\n        # tiff_folder = 'E:/'\n        # output_folder = 'E:/'\n\n        # Set default options for overwriting transformed files\n        overwrite_frame_first = False\n        overwrite_time_first = False\n\n    else:  # User called this module from command line with arguments\n        tiff_folder = sys.argv[1]\n        output_folder = sys.argv[2]\n        overwrite_frame_first = sys.argv[3]\n        overwrite_time_first = sys.argv[4]\n\n    # Get names of all subfolders\n    tiff_files = glob(tiff_folder + '/**/*.tif*', recursive=True)\n    n_tiff_files = len(tiff_files)\n    if n_tiff_files == 0:\n        raise OSError('No TIFF files in \\'%s\\'' % tiff_folder)\n    # Sort files alphabetically\n    log('Found %i TIF files' % n_tiff_files)\n\n    # Check that files with concatenated data exist\n    filename_frame_first = os.path.join(output_folder, 'stack_frame_first.dat')\n    filename_time_first = os.path.join(output_folder, 'stack_time_first.dat')\n\n    if not os.path.exists(filename_frame_first) or not os.path.exists(filename_time_first) or overwrite_frame_first or overwrite_time_first:\n        parameters_filename = prepare_data_for_GUI(tiff_folder, output_folder, overwrite_frame_first=overwrite_frame_first, overwrite_time_first=overwrite_time_first)\n    else:\n        log('Concatenated files are present')\n        parameters_filename = os.path.join(output_folder, 'parameters.json.txt')\n\n    # Load parameters from file stored on disk\n    PARAMETERS = json.load(open(parameters_filename, 'r'))\n\n    # Launch GUI\n    GUI = CalIpy(PARAMETERS)\n"""
src/calipy/calipy_GUI.py,139,"b""# System packages\r\nimport os\r\nimport sys\r\nfrom shutil import copyfile\r\nimport warnings\r\nwith warnings.catch_warnings():\r\n    warnings.simplefilter('ignore')\r\n    import h5py\r\nfrom functools import partial\r\n\r\n# Graphical packages\r\nimport cv2\r\nfrom skimage import filters\r\nfrom skimage.morphology import flood, convex_hull_image\r\nfrom matplotlib import cm as mpl_colormaps\r\nfrom PyQt5 import QtCore, QtGui, QtWidgets\r\nfrom third_party import pyqtgraph as pg\r\n# Set global settings\r\npg.setConfigOption('imageAxisOrder', 'row-major')\r\npg.setConfigOption('antialias', False)\r\n\r\n# Numerical packages\r\nimport numpy as np\r\nimport pandas as pd\r\nfrom scipy.io import savemat\r\n\r\n# Local repository\r\nfrom calipy.general_configs import default as GUI_default\r\nfrom calipy.utils.IO_operations import log\r\nfrom calipy.utils.misc import initialize_field, default_colors, make_new_ROI_id, cmapToColormap\r\nfrom calipy.utils.Qt import Qt5_QtApp, Qt_window, ImageView, make_toolbar_button, make_toolbar_action, make_QSplitter, CustomViewBox, ProgressDialog, MessageBox, Slider, MultiColumn_QTable, TimeAxis\r\nfrom calipy.utils.Array_operations import idx2range, expand_indices, transform_image_from_parameters, transform_image_from_matrices, natural_sort\r\nfrom calipy.utils.ROIs import ROI, PolyLineROI\r\nfrom calipy.utils import matlab_file\r\n\r\n\r\nclass CalIpy(object):\r\n    def __init__(self, PARAMETERS):\r\n        # Initialize Qt-event loop\r\n        QtApp = Qt5_QtApp(appID=u'CalIpy')\r\n        QtApp.app.setQuitOnLastWindowClosed(False)\r\n\r\n        log('Loading GUI')\r\n        # Make numpy ignore RuntimeWarnings\r\n        warnings.simplefilter('ignore', category=RuntimeWarning)\r\n\r\n        # Make sure that some inputs have the correct data type and shape\r\n        PARAMETERS['condition_names'] = np.array(PARAMETERS['condition_names'])\r\n        PARAMETERS['sessions_last_frame'] = np.array([PARAMETERS['sessions_last_frame']], dtype=np.int64).ravel()\r\n        PARAMETERS['frames_idx'] = np.vstack(PARAMETERS['frames_idx']).astype(np.int64)\r\n\r\n        # Store user inputs\r\n        self.PARAMETERS = PARAMETERS\r\n        self.app = QtApp\r\n\r\n        # Check whether signals are evoked by stimuli\r\n        self.is_stimulus_evoked = 'stimulus_evoked' in list(self.PARAMETERS.keys()) and bool(self.PARAMETERS['stimulus_evoked'])\r\n        self.n_conditions = len(self.PARAMETERS['condition_names'])\r\n        # Open files for reading\r\n        self.data_frame_first = np.memmap(self.PARAMETERS['filename_frame_first'], dtype=PARAMETERS['dtype'], mode='r', offset=0, shape=(self.PARAMETERS['n_frames'], self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width']))\r\n        self.data_time_first = np.memmap(self.PARAMETERS['filename_time_first'], dtype=PARAMETERS['dtype'], mode='r', offset=0).reshape((self.PARAMETERS['n_pixels'], self.PARAMETERS['n_frames']))\r\n        self.time = np.linspace(0, self.PARAMETERS['n_frames'] / GUI_default['frame_rate'], self.PARAMETERS['n_frames'])\r\n        self.time_range = [self.time.min(), self.time.max()]\r\n\r\n        # Initialize data and attributes\r\n        self.stimulus_profile = None\r\n        data_average_types = ['mean', 'median', 'max', 'standard_deviation', 'correlation']\r\n        self.data_average = {key: list() for key in data_average_types}\r\n        with h5py.File(self.PARAMETERS['filename_projections'], 'r', libver='latest') as file_in:\r\n            self.session_names = natural_sort(list(file_in.keys()))\r\n            for session_name in self.session_names:\r\n                average_types = list(file_in[session_name].keys())\r\n                for avg_typ in average_types:\r\n                    self.data_average[avg_typ].append(file_in[session_name][avg_typ][:])\r\n        # Concatenate projection images and transpose them to have [frame number x height x width]\r\n        for avg_typ in data_average_types:\r\n            self.data_average[avg_typ] = np.dstack(self.data_average[avg_typ]).transpose((2, 0, 1))\r\n        # Convert index of frames from string to numerical\r\n        self.frames_idx = self.PARAMETERS['frames_idx'].astype(np.int64)\r\n        # Sort frames and trials\r\n        order = np.argsort(self.frames_idx, axis=0)[:, 0]\r\n        self.frames_idx = self.frames_idx[order, :]\r\n        # Create array of indices\r\n        self.frames_idx_array = np.zeros((np.max(self.frames_idx), ), dtype=np.int64)\r\n        for itrial in range(self.frames_idx.shape[0]):\r\n            self.frames_idx_array[self.frames_idx[itrial, 0]-1:self.frames_idx[itrial, 1]] = itrial\r\n        # Get info on sessions\r\n        sessions_last_frame = np.sort(np.atleast_2d(self.PARAMETERS['sessions_last_frame']).transpose(), axis=0)\r\n        sessions_last_frame = np.hstack((np.vstack(([0], sessions_last_frame[:-1]+1)), sessions_last_frame))\r\n        self.sessions_idx = np.zeros((self.n_conditions, ), dtype=int)\r\n        for idx in range(sessions_last_frame.shape[0]):\r\n            self.sessions_idx[np.unique(self.frames_idx_array[sessions_last_frame[idx, 0]:sessions_last_frame[idx, 1]])] = idx\r\n        self.n_sessions = np.unique(self.sessions_idx).shape[0]\r\n\r\n        # Initialize values and flags used by GUI\r\n        self.menu = None\r\n        initialize_field(self, 'menu')\r\n        self.image_views_title = None\r\n        initialize_field(self, 'image_views_title', 'list', shape=2)\r\n        self.region_selection = list()\r\n        self.buttons = None\r\n        initialize_field(self, 'buttons')\r\n        self.keyboard = None\r\n        initialize_field(self, 'keyboard')\r\n        self.selected_ROI_type = GUI_default['ROI_type']\r\n        self.current_action = ''\r\n        self.selected_ROI = None\r\n        self.last_ROI_coordinates = list()\r\n        self.last_ROI_coordinates_handle = None\r\n        self.last_ROI_coordinates_brushes = list()\r\n        self.translation_ROI = None\r\n        self.translation_image = None\r\n        self.translation_image_levels = None\r\n        self.crosshair = list()\r\n        self.FOV_borders = list()\r\n        initialize_field(self, 'FOV_borders', 'list', shape=2)\r\n        self.next_ROI_color = None\r\n        self.colormap = None\r\n        initialize_field(self, 'colormap', 'list', shape=2)\r\n        self.current_colormap = GUI_default['colormap_index']\r\n        self.histograms_linked = False\r\n        self.updating_histograms = False\r\n        self.auto_adjust_histograms = True\r\n        self.updating_timeline_position = False\r\n        self.toggling_ROI_visibility = False\r\n        self.views_linked = False\r\n        self.trace_anchored = False\r\n        self.projection_types = sorted(GUI_default['all_projection_types'])\r\n        self.current_projection_type = GUI_default['projection_type']\r\n        self.average_types = sorted(self.data_average.keys())\r\n        self.operation_types = sorted(['mean', 'max'])\r\n        if GUI_default['average_type'] in self.average_types:\r\n            self.current_average_type = GUI_default['average_type']\r\n        else:\r\n            self.current_average_type = self.average_types[0]\r\n        self.current_operation_type = 'mean'\r\n        self.current_average_frame = [0]\r\n        self.flood_tolerance = GUI_default['flood_tolerance']\r\n\r\n        # Initialize the generator of colors\r\n        self.COLORS = default_colors(normalize_01=False)\r\n        # Initialize table to keep all info on ROIs\r\n        self.ROI_TABLE = pd.DataFrame(columns=['id','handle_ROI','handle_ROI_contour','handle_trace','type','reference_pixel','flood_tolerance','region','color','show_trace'])\r\n        # Initialize table to contain all info on how to translate single frames\r\n        self.TRANSFORMATION_MATRICES = pd.DataFrame(columns=['scale','rotation','translation'])\r\n        # Initialize lookup table to find where info of each condition is stored in the table\r\n        self.TRANSFORMATION_IDX = np.array([])\r\n        initialize_field(self, 'TRANSFORMATION_IDX', 'array', initial_value='list', shape=(self.n_conditions, 3))\r\n        self.TRANSFORMATION_IDX[:, 0] = np.arange(self.n_conditions, dtype=int)\r\n        self.TRANSFORMATION_IDX[:, 2] = self.PARAMETERS['condition_names']\r\n        # Initialize lookup table of pixels in which each value is stored\r\n        pixel_list = np.arange(self.PARAMETERS['n_pixels'], dtype=int)\r\n        pixel_list = pixel_list.reshape(self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width']).transpose().ravel()\r\n        self.MAPPING_TABLE = np.tile(np.atleast_2d(pixel_list), (self.n_conditions, 1)).astype(np.float32)  # Float32 conversion to hold NaNs\r\n        self.modified_MAPPING = np.zeros(shape=self.n_conditions, dtype=bool)\r\n        self.temporary_MAPPING_TABLE = np.array([])\r\n\r\n        # Create window\r\n        self.window = Qt_window()\r\n        # Set title\r\n        self.window.setWindowTitle('CalIpy - %s' % self.PARAMETERS['dataset_ID'])\r\n        self.window.resized.connect(self.callback_fix_colormap)\r\n        self.window.about_to_close.connect(self.callback_close_window)\r\n\r\n        # Make menubar\r\n        self.menu.menubar = self.window.menuBar()\r\n        self.menu.file = self.menu.menubar.addMenu('File')\r\n        self.menu.view = self.menu.menubar.addMenu('View')\r\n        self.menu.average = self.menu.menubar.addMenu('Average')\r\n        self.menu.projections = self.menu.menubar.addMenu('Projection')\r\n        self.menu.ROI_operation = self.menu.menubar.addMenu('ROI operation')\r\n        # Make menu actions for the File menu\r\n        self.menu.save = self.menu.file.addAction('Save ROIs to disk')\r\n        self.menu.file.addSeparator()\r\n        self.menu.load = self.menu.file.addAction('Load ROIs from disk')\r\n        self.menu.file.addSeparator()\r\n        self.menu.delete_ROIs = self.menu.file.addAction('Delete ROIs in memory (no change to file on disk)')\r\n        self.menu.file.addSeparator()\r\n        self.menu.reload = self.menu.file.addAction('Reset transformations to field-of-view')\r\n        # Make menu actions for the View menu\r\n        self.menu.auto_adjust_histograms = self.menu.view.addAction('Automatically adjust histograms')\r\n        self.menu.auto_adjust_histograms.setCheckable(True)\r\n        self.menu.auto_adjust_histograms.setChecked(self.auto_adjust_histograms)\r\n\r\n        # Make menu actions to choose average type\r\n        self.menu.average_actions = [self.menu.average.addAction(i) for i in self.average_types]\r\n        [i.setCheckable(True) for i in self.menu.average_actions]\r\n        self.menu.average_type = QtWidgets.QActionGroup(self.window)\r\n        [self.menu.average_type.addAction(i) for i in self.menu.average_actions]\r\n        # Make menu actions to choose projection type\r\n        self.menu.projection_actions = [self.menu.projections.addAction(i) for i in self.projection_types]\r\n        [i.setCheckable(True) for i in self.menu.projection_actions]\r\n        self.menu.projection_type = QtWidgets.QActionGroup(self.window)\r\n        [self.menu.projection_type.addAction(i) for i in self.menu.projection_actions]\r\n        # Make menu to choose what operation to perform on pixels in an ROI\r\n        self.menu.ROI_operation_actions = [self.menu.ROI_operation.addAction(i) for i in self.operation_types]\r\n        [i.setCheckable(True) for i in self.menu.ROI_operation_actions]\r\n        self.menu.ROI_operation_type = QtWidgets.QActionGroup(self.window)\r\n        [self.menu.ROI_operation_type.addAction(i) for i in self.menu.ROI_operation_actions]\r\n\r\n        # Make toolbar buttons\r\n        self.buttons.toggle_colormap = make_toolbar_button(self.window, GUI_default['icons']['toggle_colormap'], kind=GUI_default['icons_kind']['toggle_colormap'])\r\n        self.buttons.link_views = make_toolbar_button(self.window, GUI_default['icons']['link_views'], kind=GUI_default['icons_kind']['link_views'], checkable=True)\r\n        self.buttons.visibility_ROI = make_toolbar_button(self.window, GUI_default['icons']['visibility_ROI'], kind=GUI_default['icons_kind']['visibility_ROI'])\r\n        self.buttons.zoom = make_toolbar_button(self.window, GUI_default['icons']['zoom'], kind=GUI_default['icons_kind']['zoom'])\r\n        self.buttons.translation_ROI = make_toolbar_button(self.window, GUI_default['icons']['translation_ROI'], kind=GUI_default['icons_kind']['translation_ROI'], checkable=True)\r\n        self.buttons.link_histograms = make_toolbar_button(self.window, GUI_default['icons']['link_histograms'], kind=GUI_default['icons_kind']['link_histograms'], checkable=True)\r\n        # The button to make an ROI has a customized context menu to choose the type of ROI to make\r\n        self.buttons.draw_ROI = make_toolbar_button(self.window, GUI_default['icons']['ROI_polygon'], kind=GUI_default['icons_kind']['ROI_polygon'])\r\n        self.buttons.draw_ROI.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)\r\n        self.buttons.draw_ROI.customContextMenuRequested.connect(self.callback_choose_ROI_type)\r\n        self.buttons.draw_ROI.setStyleSheet('background-color: None')\r\n        # Make other actions to pass to the contextual menu\r\n        self.buttons.ROI_fill = make_toolbar_action(self.window, icon=GUI_default['icons']['ROI_fill'], text='fill')\r\n        self.buttons.ROI_polygon = make_toolbar_action(self.window, icon=GUI_default['icons']['ROI_polygon'], text='polygon')\r\n        # Make button to plot traces of selected ROIs\r\n        self.buttons.anchor_trace = make_toolbar_button(self.window, GUI_default['icons']['anchor_trace'], kind=GUI_default['icons_kind']['anchor_trace'], checkable=True)\r\n\r\n        # Add buttons to toolbar\r\n        self.toolBar = QtWidgets.QToolBar('Tools')\r\n        self.toolBar.setStyleSheet('QToolBar {background: white}')\r\n        self.window.addToolBar(QtCore.Qt.LeftToolBarArea, self.toolBar)\r\n        self.toolBar.setFloatable(False)\r\n        self.toolBar.setMovable(False)\r\n        self.toolBar.addWidget(self.buttons.link_views)\r\n        self.toolBar.addWidget(self.buttons.anchor_trace)\r\n        self.toolBar.addSeparator()\r\n        self.toolBar.addWidget(self.buttons.toggle_colormap)\r\n        self.toolBar.addWidget(self.buttons.visibility_ROI)\r\n        self.toolBar.addWidget(self.buttons.zoom)\r\n        self.toolBar.addWidget(self.buttons.link_histograms)\r\n        self.toolBar.addSeparator()\r\n        self.toolBar.addWidget(self.buttons.draw_ROI)\r\n        self.toolBar.addWidget(self.buttons.translation_ROI)\r\n\r\n        # Make list-box to contain list of conditions\r\n        self.table_conditions = MultiColumn_QTable(self.PARAMETERS['condition_names'], title='conditions')\r\n        self.table_conditions.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)\r\n        self.table_sessions = MultiColumn_QTable(['session %i' % ii for ii in range(1, self.n_sessions+1)], title='sessions')\r\n        self.table_sessions.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        table_size = QtCore.QSize(self.table_conditions.width(), self.table_sessions.height())\r\n        self.table_sessions.setMinimumSize(table_size)\r\n        self.table_sessions.setMaximumSize(table_size)\r\n        self.table_sessions.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)\r\n        # Place tables in layout\r\n        table_layout = QtWidgets.QVBoxLayout()\r\n        table_layout.addWidget(self.table_sessions)\r\n        table_layout.addWidget(self.table_conditions)\r\n\r\n        # Make layout on the top to see fields of view\r\n        top_layout = make_QSplitter('hor')\r\n        top_left_layout = QtWidgets.QVBoxLayout()\r\n        top_left_layout_bottom = QtWidgets.QHBoxLayout()\r\n        # Make ImageItem for average image\r\n        self.average_image_viewbox, self.average_image_view, self.average_image_scene = self.make_image_box(name='projection')\r\n        self.average_image_view.setImage(self.data_average[self.current_average_type][self.current_average_frame[0], :, :].copy(), autoRange=True, axes={'x': 1, 'y': 2}, autoLevels=True)\r\n        self.average_image_viewbox.setMenuEnabled(False)\r\n        # Add label to identify condition shown\r\n        self.image_views_title[0] = pg.TextItem(self.PARAMETERS['condition_names'][0], color=GUI_default['text_color_dark'], anchor=(0, 0))\r\n        self.image_views_title[0].setFont(GUI_default['font_titles'])\r\n        self.average_image_scene.addItem(self.image_views_title[0])\r\n        top_left_layout_bottom.addWidget(self.average_image_scene)\r\n        top_left_layout_bottom.setStretch(0, 10)\r\n        self.average_histogram = pg.HistogramLUTWidget(image=self.average_image_view, rgbHistogram=False, levelMode='mono')\r\n        self.average_histogram.item.gradient.allowAdd = False\r\n        self.average_histogram.item.vb.setMenuEnabled(False)\r\n        self.average_histogram.item.vb.setMouseEnabled(x=False, y=False)\r\n        # Delete ticks from histogram\r\n        [ii.setStyle(tickLength=0, showValues=False) for ii in self.average_histogram.items() if isinstance(ii, pg.AxisItem)]\r\n        top_left_layout_bottom.addWidget(self.average_histogram)\r\n        top_left_layout_bottom.setStretch(1, 1)\r\n        # Add slider at the top\r\n        self.slider_label = QtWidgets.QLabel('%.1f' % self.flood_tolerance)\r\n        self.slider_label.setFont(GUI_default['font'])\r\n        self.slider = Slider(minimum=0, maximum=1000)\r\n        self.slider.setOrientation(QtCore.Qt.Horizontal)\r\n        self.slider.setValue(self.flood_tolerance * 10)\r\n        self.slider_update_GUI = True\r\n        # Initialize as inactive\r\n        self.toggle_slider_flood_tolerance(False)\r\n        # Add elements to layout\r\n        hbox = QtWidgets.QHBoxLayout()\r\n        hbox.addWidget(self.slider_label)\r\n        hbox.addWidget(self.slider)\r\n        top_left_layout.addLayout(hbox)\r\n        top_left_layout.addLayout(top_left_layout_bottom)\r\n        w = QtWidgets.QWidget()\r\n        w.setLayout(top_left_layout)\r\n        top_layout.addWidget(w)\r\n        # Draw crosshair and turn it off\r\n        self.crosshair.append(pg.InfiniteLine(angle=90, movable=False))\r\n        self.crosshair.append(pg.InfiniteLine(angle=0, movable=False))\r\n        [self.average_image_viewbox.addItem(c, ignoreBounds=True) for c in self.crosshair]\r\n        [c.setVisible(False) for c in self.crosshair]\r\n        # Draw border of the field ov view\r\n        pen = pg.mkPen(width=2)\r\n        self.FOV_borders[0] = list()\r\n        self.FOV_borders[0].append(pg.PlotCurveItem([0, 0], [0, self.PARAMETERS['frame_height']], clickable=False, pen=pen))  # bottom border\r\n        self.FOV_borders[0].append(pg.PlotCurveItem([self.PARAMETERS['frame_width']] * 2, [0, self.PARAMETERS['frame_height']], clickable=False, pen=pen))  # top border\r\n        self.FOV_borders[0].append(pg.PlotCurveItem([0, self.PARAMETERS['frame_width']], [0, 0], clickable=False, pen=pen))  # left border\r\n        self.FOV_borders[0].append(pg.PlotCurveItem([0, self.PARAMETERS['frame_width']], [self.PARAMETERS['frame_height']] * 2, clickable=False, pen=pen))  # right border\r\n        [self.average_image_viewbox.addItem(self.FOV_borders[0][ii]) for ii in range(4)]\r\n        [self.FOV_borders[0][ii].setZValue(1000) for ii in range(4)]\r\n\r\n        # Make view box for frame selection\r\n        self.frame_image_view = ImageView(name='frame')\r\n        self.frame_image_view.view.setMenuEnabled(False)\r\n        self.frame_image_view.ui.roiBtn.hide()\r\n        self.frame_image_view.ui.menuBtn.hide()\r\n        self.frame_image_view.getHistogramWidget().item.vb.setMenuEnabled(False)\r\n        # Delete ticks from histogram and timeline\r\n        [ii.setStyle(tickLength=0, showValues=False) for ii in self.frame_image_view.getHistogramWidget().items() if isinstance(ii, pg.AxisItem)]\r\n        self.frame_image_view.ui.roiPlot.hideAxis('bottom')\r\n        # Set image\r\n        self.frame_image_view.setImage(self.data_frame_first, autoRange=True, axes={'t': 0, 'x': 2, 'y': 1}, autoLevels=True)\r\n        # Hide unused elements\r\n        self.frame_image_view.ui.roiPlot.getPlotItem().hideButtons()  # Hide 'autoscale' button\r\n        [ii.setVisible(False) for ii in self.frame_image_view.timeLine.getViewBox().allChildItems() if isinstance(ii, pg.VTickGroup)]  # Vertical ticks\r\n        # Add boundaries of each session\r\n        self.frame_image_view.timeLine.setZValue(1)\r\n        for ii in range(self.PARAMETERS['sessions_last_frame'].shape[0] - 1):  # -1 because we ignore the last idx\r\n            pos = self.PARAMETERS['sessions_last_frame'][ii]\r\n            l = pg.InfiniteLine(pos=pos, angle=90, pen=pg.mkPen(color=(77, 77, 77)))\r\n            l.setZValue(1)\r\n            self.frame_image_view.ui.roiPlot.addItem(l)\r\n        # Add label to identify condition shown\r\n        self.image_views_title[1] = pg.TextItem(self.PARAMETERS['condition_names'][0], color=GUI_default['text_color_dark'], anchor=(0, 0))\r\n        self.image_views_title[1].setFont(GUI_default['font_titles'])\r\n        self.frame_image_view.scene.addItem(self.image_views_title[1])\r\n        # Draw border of the field ov view\r\n        pen = pg.mkPen(width=2)\r\n        self.FOV_borders[1] = list()\r\n        self.FOV_borders[1].append(pg.PlotCurveItem([0, 0], [0, self.PARAMETERS['frame_height']], clickable=False, pen=pen))  # bottom border\r\n        self.FOV_borders[1].append(pg.PlotCurveItem([self.PARAMETERS['frame_width']] * 2, [0, self.PARAMETERS['frame_height']], clickable=False, pen=pen))  # top border\r\n        self.FOV_borders[1].append(pg.PlotCurveItem([0, self.PARAMETERS['frame_width']], [0, 0], clickable=False, pen=pen))  # left border\r\n        self.FOV_borders[1].append(pg.PlotCurveItem([0, self.PARAMETERS['frame_width']], [self.PARAMETERS['frame_height']] * 2, clickable=False, pen=pen))  # right border\r\n        [self.frame_image_view.view.addItem(self.FOV_borders[1][ii]) for ii in range(4)]\r\n        [self.FOV_borders[1][ii].setZValue(1000) for ii in range(4)]\r\n        # Add plot to layout\r\n        top_layout.addWidget(self.frame_image_view)\r\n\r\n        # Make layout on the bottom to inspect ROIs and traces\r\n        bottom_layout = make_QSplitter('hor')\r\n        # Add on the bottom a graph to see latest ROI maximized\r\n        self.ROI_viewbox, self.ROI_view, self.ROI_border = self.make_image_box(name='ROI_inspector')\r\n        self.ROI_viewbox.setMenuEnabled(False)\r\n        self.color_ROI_view_border(color=list())\r\n        bottom_layout.addWidget(self.ROI_border)\r\n        bottom_layout.setStretchFactor(0, 1)\r\n        # Add on the bottom a graph to see Calcium traces\r\n        self.trace_time_mark = pg.InfiniteLine(angle=90, bounds=self.time_range, pen=pg.mkPen(color='r', width=3), movable=True)\r\n        self.trace_time_mark.setZValue(3)\r\n        self.trace_viewbox = pg.PlotWidget(axisItems={'bottom': TimeAxis('bottom', showValues=True, maxTickLength=-5)})\r\n        self.trace_viewbox.plotItem.hideButtons()\r\n        self.trace_viewbox.setMenuEnabled(False)\r\n        # Set limits of viewbox and enable auto-fit\r\n        self.trace_viewbox.setLimits(xMin=self.time_range[0], xMax=self.time_range[1])\r\n        self.trace_viewbox.setMouseEnabled(x=True, y=False)\r\n        self.trace_viewbox.addItem(self.trace_time_mark)\r\n        # Add boundaries of each session\r\n        for ii in range(self.PARAMETERS['sessions_last_frame'].shape[0] - 1):  # -1 because we ignore the last idx\r\n            pos = self.PARAMETERS['sessions_last_frame'][ii] / GUI_default['frame_rate']\r\n            l = pg.InfiniteLine(pos=pos, angle=90, pen=pg.mkPen(color=(77, 77, 77)))\r\n            l.setZValue(1)\r\n            self.trace_viewbox.addItem(l)\r\n        self.trace_viewbox.setRange(xRange=self.time_range, disableAutoRange=False)\r\n        bottom_layout.addWidget(self.trace_viewbox)\r\n        bottom_layout.setStretchFactor(1, 3)\r\n\r\n        # Make final layout\r\n        graph_layout = make_QSplitter('ver')\r\n        graph_layout.addWidget(top_layout)\r\n        graph_layout.addWidget(bottom_layout)\r\n        graph_layout.setStretchFactor(0, 4)\r\n        graph_layout.setStretchFactor(1, 1)\r\n        layout = QtWidgets.QHBoxLayout()\r\n        layout.addLayout(table_layout)\r\n        layout.addWidget(graph_layout)\r\n        # Put layout in the center\r\n        qFrame = QtWidgets.QWidget()\r\n        self.window.setCentralWidget(qFrame)\r\n        qFrame.setLayout(layout)\r\n        qFrame.setFocus()\r\n\r\n        # Connect callbacks to buttons\r\n        self.buttons.draw_ROI.clicked.connect(self.callback_draft_ROI)\r\n        self.buttons.toggle_colormap.clicked.connect(partial(self.callback_toggle_colormap, force=None))\r\n        self.buttons.zoom.clicked.connect(partial(self.callback_reset_zoom, where='all'))\r\n        self.buttons.translation_ROI.toggled.connect(self.callback_activate_translation_FOV)\r\n        self.buttons.link_views.toggled.connect(self.callback_link_views)\r\n        self.buttons.link_histograms.toggled.connect(self.callback_link_histograms)\r\n        self.buttons.anchor_trace.toggled.connect(self.callback_anchor_trace)\r\n        self.buttons.visibility_ROI.clicked.connect(partial(self.callback_update_visibility_traces, from_button=True))\r\n\r\n        # Connect callbacks for mouse interaction\r\n        self.average_image_viewbox.scene().sigMouseMoved.connect(self.callback_mouse_moved)\r\n        self.average_image_viewbox.scene().sigMouseClicked.connect(self.callback_mouse_clicked)\r\n        self.table_conditions.itemSelectionChanged.connect(partial(self.callback_table_selection, what='condition'))\r\n        self.table_sessions.itemSelectionChanged.connect(partial(self.callback_table_selection, what='session'))\r\n        self.slider.valueChanged.connect(self.callback_flood_tolerance_value_changed)\r\n        # Connect callbacks to timeline slider\r\n        self.frame_image_view.timeLine.sigPositionChanged.disconnect()\r\n        self.frame_image_view.timeLine.sigPositionChanged.connect(partial(self.callback_timeline_frames, from_plot='frame'))\r\n        self.trace_time_mark.sigPositionChanged.connect(partial(self.callback_timeline_frames, from_plot='trace'))\r\n        # Connect callbacks to menu actions\r\n        self.menu.save.triggered.connect(partial(self.callback_save, compute_traces=False))\r\n        self.menu.save.setShortcut(QtGui.QKeySequence('Ctrl+S'))\r\n        self.menu.load.triggered.connect(self.callback_load)\r\n        self.menu.load.setShortcut(QtGui.QKeySequence('Ctrl+L'))\r\n        self.menu.reload.triggered.connect(partial(self.callback_reload, what='frames'))\r\n        self.menu.reload.setShortcut(QtGui.QKeySequence('Ctrl+R'))\r\n        self.menu.delete_ROIs.triggered.connect(partial(self.callback_reload, what='ROIs'))\r\n        self.menu.auto_adjust_histograms.triggered.connect(self.callback_auto_adjust_histograms)\r\n        [ii.triggered.connect(partial(self.callback_menu_projection_type, name=jj)) for ii, jj in zip(self.menu.projection_actions, self.projection_types)]\r\n        [ii.triggered.connect(partial(self.callback_menu_average_type, name=jj)) for ii, jj in zip(self.menu.average_actions, self.average_types)]\r\n        [ii.triggered.connect(partial(self.callback_menu_operation_type, name=jj)) for ii, jj in zip(self.menu.ROI_operation_actions, self.operation_types)]\r\n\r\n        # Make keyboard shortcuts\r\n        self.keyboard.Key_Enter = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Enter), self.window)\r\n        self.keyboard.Key_Enter.setAutoRepeat(False)\r\n        self.keyboard.Key_Return = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Return), self.window)\r\n        self.keyboard.Key_Return.setAutoRepeat(False)\r\n        self.keyboard.Key_Escape = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Escape), self.window)\r\n        self.keyboard.Key_Escape.setAutoRepeat(False)\r\n        self.keyboard.Key_Up = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Up), self.window)\r\n        self.keyboard.Key_Up.setAutoRepeat(True)\r\n        self.keyboard.Key_Down = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Down), self.window)\r\n        self.keyboard.Key_Down.setAutoRepeat(True)\r\n        self.keyboard.Key_Left = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Left), self.window)\r\n        self.keyboard.Key_Left.setAutoRepeat(True)\r\n        self.keyboard.Key_Right = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Right), self.window)\r\n        self.keyboard.Key_Right.setAutoRepeat(True)\r\n        self.keyboard.Key_Z = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Z), self.window)\r\n        self.keyboard.Key_Z.setAutoRepeat(True)\r\n        self.keyboard.Key_Space = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Space), self.window)\r\n        self.keyboard.Key_Space.setAutoRepeat(False)\r\n        # Connect callbacks for keyboard interaction\r\n        self.keyboard.Key_Enter.activated.connect(self.callback_continue_last_action)\r\n        self.keyboard.Key_Return.activated.connect(self.callback_continue_last_action)\r\n        self.keyboard.Key_Escape.activated.connect(self.callback_cancel_last_action)\r\n        self.keyboard.Key_Up.activated.connect(partial(self.callback_scroll_average_frame, where='up'))\r\n        self.keyboard.Key_Down.activated.connect(partial(self.callback_scroll_average_frame, where='down'))\r\n        self.keyboard.Key_Left.activated.connect(partial(self.callback_transform_current_frame, direction=-1))\r\n        self.keyboard.Key_Right.activated.connect(partial(self.callback_transform_current_frame, direction=+1))\r\n        self.keyboard.Key_Z.activated.connect(partial(self.callback_reset_zoom, where='all'))\r\n        self.keyboard.Key_Space.activated.connect(self.callback_draft_ROI)\r\n\r\n        # Make colormaps\r\n        pos, rgba_colors = zip(*cmapToColormap(mpl_colormaps.gray))\r\n        self.colormap[0] = pg.ColorMap(pos, rgba_colors)\r\n        pos, rgba_colors = zip(*cmapToColormap(mpl_colormaps.gray_r))\r\n        self.colormap[1] = pg.ColorMap(pos, rgba_colors)\r\n\r\n        # Initialize button state\r\n        self.buttons.link_views.setChecked(self.views_linked)\r\n        self.buttons.anchor_trace.setChecked(self.trace_anchored)\r\n        self.buttons.link_histograms.setChecked(False)\r\n        self.buttons.translation_ROI.setChecked(False)\r\n        [i.setChecked(True) for i in self.menu.average_actions if i.text()==self.current_average_type]\r\n        [i.setChecked(True) for i in self.menu.projection_actions if i.text() == self.current_projection_type]\r\n        [i.setChecked(True) for i in self.menu.ROI_operation_actions if i.text() == self.current_operation_type]\r\n\r\n        # If there are ROIs present, enable the tool that allows to translate the field of view\r\n        button_state = self.ROI_TABLE.shape[0] > 0\r\n        self.buttons.translation_ROI.setEnabled(button_state)\r\n\r\n        # Activate GUI\r\n        self.window.showMaximized()\r\n        self.window.show()\r\n        # Automatically load last save\r\n        self.callback_load()\r\n        # Update table\r\n        self.update_table_condition_names()\r\n        # Reset range everywhere\r\n        self.callback_reset_zoom(where='all')\r\n        self.callback_link_histograms(False)\r\n        self.callback_toggle_colormap(force=self.current_colormap)\r\n        # Bring to front\r\n        self.window.raise_()\r\n        log('GUI is ready')\r\n        # Start Qt-event loop\r\n        sys.exit(QtApp.app.exec_())\r\n\r\n\r\n    ############################################################################\r\n    # File-related\r\n    ############################################################################\r\n    def callback_close_window(self):\r\n        answer = MessageBox('Close GUI?', title='GUI ROI segmentation', parent=self.window)\r\n        if answer.lower() == 'no':\r\n            # Make sure window won't be closed\r\n            self.window.allowed_to_close = False\r\n        else:\r\n            answer = MessageBox('Save current ROIs to disk?', title='GUI ROI segmentation', parent=self.window, button_No='Discard')\r\n            if answer.lower() == 'yes':\r\n                self.callback_save(compute_traces=True)\r\n            # Allow window to be closed\r\n            self.window.allowed_to_close = True\r\n            # Allow app to be closed when the window will close\r\n            self.app.app.setQuitOnLastWindowClosed(True)\r\n            log('Quitting GUI')\r\n\r\n\r\n    def callback_save(self, compute_traces=False):\r\n        if not self.menu.menubar.isEnabled():\r\n            return\r\n        # Count ROIs\r\n        n_ROIs = self.ROI_TABLE.shape[0]\r\n        if n_ROIs < 1:\r\n            log('No ROIs to save')\r\n            return\r\n        # Check whether a previous file exists\r\n        file_present = os.path.exists(self.PARAMETERS['filename_ROIs'])\r\n        # Ask user whether to overwrite the previous file\r\n        if file_present:\r\n            answer = MessageBox('Overwrite previous file?', title='GUI ROI segmentation', parent=self.window, button_Yes='Overwrite', button_No='Cancel', additional_buttons='Backup and make new', default_answer='Backup and make new')\r\n            if answer == 'Cancel':\r\n                return\r\n            elif answer == 'Backup and make new':\r\n                # Get name for backup\r\n                backup_filename, backup_ext = os.path.splitext(self.PARAMETERS['filename_ROIs'])\r\n                backup_filename += '_backup'\r\n                backup_filename += backup_ext\r\n                # Do backup copy of file\r\n                log('Backing-up file to \\'%s\\'' % backup_filename)\r\n                copyfile(self.PARAMETERS['filename_ROIs'], backup_filename)\r\n\r\n        # Log action\r\n        log('Storing segmentation to disk')\r\n        # Initialize variables\r\n        F = None\r\n\r\n        # Disable window\r\n        self.window.setEnabled(False)\r\n        # Allocate variables used in following for-loop\r\n        ROI_masks = np.zeros((self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width'], n_ROIs), dtype=np.int8)\r\n        msg = 'Computing ROI info'\r\n        if compute_traces:\r\n            F = np.zeros((self.PARAMETERS['n_frames'], n_ROIs), dtype=np.float32)\r\n            msg += ' and fluorescence traces'\r\n        # Create a progress dialog without Cancel button\r\n        dlg = ProgressDialog(msg, minimum=0, maximum=n_ROIs, parent=self.window)\r\n\r\n        # Get frames\r\n        frames = self.data_average['mean'].copy()\r\n        # Apply transformations\r\n        n_frames = len(self.current_average_frame)\r\n        for iframe in range(n_frames):\r\n            T = self.TRANSFORMATION_IDX[self.TRANSFORMATION_IDX[:, 0] == self.current_average_frame[iframe], 1][0]\r\n            if len(T) > 0:\r\n                # Apply transformations to current frame one after the other\r\n                for t_idx in T:\r\n                    # Get matrices\r\n                    scale = self.TRANSFORMATION_MATRICES.loc[t_idx, 'scale']\r\n                    rotation = self.TRANSFORMATION_MATRICES.loc[t_idx, 'rotation']\r\n                    translation = self.TRANSFORMATION_MATRICES.loc[t_idx, 'translation']\r\n                    # Apply them\r\n                    frames[iframe, :, :] = transform_image_from_matrices(frames[iframe, :, :], scale, rotation, translation)\r\n        # Get average frame as template\r\n        image_to_analyze = np.nanmean(frames, axis=0)\r\n        # Loop through ROIs\r\n        rows = self.ROI_TABLE.index.values\r\n        for idx, row in enumerate(rows):\r\n            roi = self.ROI_TABLE.loc[row, 'handle_ROI']\r\n            area, coords = roi.getArrayRegion(image_to_analyze, self.average_image_view, axes=(0, 1), returnMappedCoords=True)\r\n            # Extract pixels enclosed by ROI\r\n            area_mask = roi.renderShapeMask(area.shape[1], area.shape[0]).T\r\n            # Get indices of ROI pixels\r\n            # area_idx = np.where(area > 0)\r\n            area_idx = np.where(area_mask != 0)\r\n            ROI_idx = np.vstack((coords[0, area_idx[0], area_idx[1]], coords[1, area_idx[0], area_idx[1]]))\r\n            ROI_pixels = np.unique(np.ravel_multi_index(np.round(ROI_idx, decimals=0).astype(int), [self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width']], mode='raise', order='C'))\r\n            # Store mask\r\n            mask_indices = np.unravel_index(ROI_pixels, (self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width']))\r\n            ROI_masks[mask_indices[0], mask_indices[1], idx] = 1\r\n\r\n            if compute_traces:\r\n                # Compute mean fluorescence in the ROI\r\n                L = np.mean(self.data_time_first[ROI_pixels, :], axis=0)\r\n                # Check whether some segments have been translated\r\n                if np.any(self.modified_MAPPING):\r\n                    # Get index of frames that are modified\r\n                    modified_conditions_idx = np.where(self.modified_MAPPING == True)[0]\r\n                    # Get segments that have been translated\r\n                    if modified_conditions_idx.size > 0:\r\n                        L_modified, modified_frames_idx = self.get_translated_trace_segments(modified_conditions_idx, ROI_pixels, from_temporary=False)\r\n                        # Replace values in original array\r\n                        L[modified_frames_idx] = L_modified\r\n                # Store in main variable\r\n                F[:, idx] = L\r\n\r\n            # Advance progress dialog\r\n            dlg += 1\r\n        # Close progress dialog\r\n        dlg.close()\r\n\r\n        # Keep all information on ROIs (don't keep pointers to handles)\r\n        ROI_info = self.ROI_TABLE[[c for c in self.ROI_TABLE.columns if 'handle' not in c]].values\r\n        # Get index of column corresponding to ROI ID\r\n        col_idx = list(self.ROI_TABLE.columns).index('id')\r\n        ROI_info[:, col_idx] = np.arange(0, n_ROIs, dtype=int)\r\n\r\n        # Make dictionary for Matlab\r\n        mdict = dict({'ROIs'                   : ROI_masks,\r\n                      'ROI_info'               : ROI_info,\r\n                      'TRANSFORMATION_MATRICES': self.TRANSFORMATION_MATRICES.values,\r\n                      'TRANSFORMATION_IDX'     : self.TRANSFORMATION_IDX,\r\n                      'MAPPING_TABLE'          : self.MAPPING_TABLE,\r\n                      'modified_MAPPING'       : self.modified_MAPPING})\r\n        # Add traces, if requested\r\n        if compute_traces:\r\n            mdict['ROI_fluorescence'] = F\r\n        # Store info on disk\r\n        dlg = ProgressDialog('Saving ROI info to disk', minimum=0, maximum=0, parent=self.window)\r\n        savemat(self.PARAMETERS['filename_ROIs'], mdict, oned_as='column')\r\n        dlg.close()\r\n        # Enable window\r\n        self.window.setEnabled(True)\r\n        # Log end of action\r\n        log('... done')\r\n\r\n\r\n    def callback_load(self):\r\n        if not self.menu.menubar.isEnabled():\r\n            log('Operation not allowed now')\r\n            return\r\n        # Check that file exists\r\n        if not os.path.exists(self.PARAMETERS['filename_ROIs']):\r\n            log('File \\'%s\\' does not exist' % self.PARAMETERS['filename_ROIs'])\r\n            return\r\n        # Count ROIs\r\n        n_ROIs = self.ROI_TABLE.shape[0]\r\n        if n_ROIs != 0:\r\n            # Ask user whether to overwrite info in memory with info from the file\r\n            answer = MessageBox('CAREFUL: Current ROI segmentation will be lost and replaced with that from disk.\\nAre you sure to continue?', box_type='warning', title='GUI ROI segmentation', parent=self.window)\r\n            if answer.lower() == 'no':\r\n                return\r\n        # elif n_ROIs == 0:\r\n        #     return\r\n\r\n        # Log action\r\n        log('Loading previous segmentation')\r\n\r\n        # Check whether window is open (e.g., during __init__())\r\n        has_window = hasattr(self, 'window') and self.window.isVisible()\r\n\r\n        if has_window:\r\n            # Disable window\r\n            self.window.setEnabled(False)\r\n            # Create progress dialog\r\n            dlg = ProgressDialog('Loading ROIs from disk', minimum=0, maximum=1, parent=self.window)\r\n            # Delete all previous ROIs\r\n            all_ROIs = self.ROI_TABLE['handle_ROI'].values\r\n            for roi in all_ROIs:\r\n                if not isinstance(roi, np.ndarray):\r\n                    self.callback_remove_ROI(roi, log_outcome=False)\r\n        else:\r\n            # Initialize variable as integer\r\n            dlg = 0\r\n\r\n        # Reset tables\r\n        self.ROI_TABLE.drop(self.ROI_TABLE.index, inplace=True)\r\n        self.ROI_TABLE.reset_index(drop=True, inplace=True)\r\n        self.TRANSFORMATION_MATRICES.drop(self.TRANSFORMATION_MATRICES.index, inplace=True)\r\n        self.TRANSFORMATION_MATRICES.reset_index(drop=True, inplace=True)\r\n\r\n        # Load file\r\n        file_content = matlab_file.load(self.PARAMETERS['filename_ROIs'])\r\n        # Unpack variables\r\n        ROI_info = np.atleast_2d(file_content['ROI_info'])\r\n        # Last column contains boolean values\r\n        ROI_info[:, -1] = ROI_info[:, -1].astype(bool)\r\n        n_ROIs = ROI_info.shape[0]\r\n        if has_window:\r\n            dlg.setMaximum(n_ROIs + 1)  # +1 is the step when loading the file\r\n        # Allocate empty values\r\n        for row in range(n_ROIs):\r\n            self.ROI_TABLE.loc[row, :] = None\r\n        # Fill values\r\n        self.ROI_TABLE.loc[:, [c for c in self.ROI_TABLE.columns if 'handle' not in c]] = ROI_info\r\n        # Make sure colors are tuples of integers\r\n        for row in range(n_ROIs):\r\n            self.ROI_TABLE.loc[row, 'color'] = tuple(self.ROI_TABLE.loc[row, 'color'].astype(int))\r\n        # Copy transformation matrices\r\n        self.TRANSFORMATION_IDX = np.atleast_2d(file_content['TRANSFORMATION_IDX'].copy())\r\n        for idx, v in enumerate(self.TRANSFORMATION_IDX[:, 1]):\r\n            if isinstance(v, np.ndarray):\r\n                v = list(v)\r\n            else:\r\n                v = list([v])\r\n            self.TRANSFORMATION_IDX[idx, 1] = v\r\n\t    # Check whether to add new empty arrays for sessions that were added since\r\n        # the last segmentation\r\n        all_condition_idx = np.arange(self.PARAMETERS['condition_names'].shape[0])\r\n        has_condition_idx = np.where(np.isin(self.PARAMETERS['condition_names'], self.TRANSFORMATION_IDX[:, 2]))[0]\r\n        if not np.array_equal(all_condition_idx, has_condition_idx):\r\n            # Make empty arrays\r\n            TRANSFORMATION_IDX = np.empty((all_condition_idx.shape[0], 3), dtype=object)\r\n            TRANSFORMATION_IDX[:, 0] = all_condition_idx\r\n            TRANSFORMATION_IDX[:, 1] = [list() for _ in range(all_condition_idx.shape[0])]\r\n            TRANSFORMATION_IDX[:, 2] = self.PARAMETERS['condition_names']\r\n            # Add previous transformations\r\n            TRANSFORMATION_IDX[has_condition_idx, :] = self.TRANSFORMATION_IDX.copy()\r\n            self.TRANSFORMATION_IDX = TRANSFORMATION_IDX.copy()\r\n        # Reset index to match table index\r\n        all_transformations, all_transformations_idx = np.unique(self.TRANSFORMATION_IDX[:, 1], return_inverse=True)\r\n        all_transformations = np.hstack(all_transformations).astype(int)\r\n        all_transformations = np.column_stack((all_transformations, np.arange(len(all_transformations))))\r\n        for idx, v in enumerate(self.TRANSFORMATION_IDX[:, 1]):\r\n            if len(v) > 0:\r\n                self.TRANSFORMATION_IDX[idx, 1] = all_transformations[all_transformations[:,0] == v, 1].tolist()\r\n        if file_content['TRANSFORMATION_MATRICES'].size > 0:\r\n            self.TRANSFORMATION_MATRICES = pd.DataFrame(np.atleast_2d(file_content['TRANSFORMATION_MATRICES']), columns=self.TRANSFORMATION_MATRICES.columns)\r\n\r\n        # Copy pixel mapping information\r\n        self.MAPPING_TABLE = np.atleast_2d(file_content['MAPPING_TABLE'])\r\n        self.modified_MAPPING = np.array(file_content['modified_MAPPING']).astype(bool)\r\n        # Increase progress counter\r\n        dlg += 1\r\n\r\n        # Re-draw ROIs\r\n        for ii in range(n_ROIs):\r\n            # Get color of this ROI\r\n            pen = pg.mkPen(color=self.ROI_TABLE.loc[ii, 'color'], width=GUI_default['ROI_linewidth_thick'])\r\n            # Get ROI type and its contour / region\r\n            points = self.ROI_TABLE.loc[ii, 'region']\r\n            # Draw ROI\r\n            roi = PolyLineROI(points, pen=pen, closed=True, movable=True, removable=True)\r\n\r\n            # Connect callbacks\r\n            self.ROI_add_context_menu(roi)\r\n            roi.sigRegionChanged.connect(partial(self.callback_update_zoom_ROI, update_trace=True, update_ROI_contour=True))\r\n            roi.sigRemoveRequested.connect(partial(self.callback_remove_ROI, log_outcome=False))\r\n            roi.sigClicked.connect(self.callback_click_ROI)\r\n            roi.setAcceptedMouseButtons(QtCore.Qt.LeftButton)\r\n\r\n            # Store id of this ROI it in the handle so we can always come back to the table without checking object identity\r\n            roi.ROI_id = self.ROI_TABLE.loc[ii, 'id']\r\n            # Add ROI to plot\r\n            self.average_image_viewbox.addItem(roi)\r\n\r\n            # Transform ROI to a static polygon\r\n            points = np.array(roi.getState()['points'])\r\n            points = np.vstack((points, points[0, :]))\r\n            # Make PlotItem\r\n            pi_right = pg.PlotCurveItem(clickable=False)\r\n            pi_right.setData(x=points[:, 0], y=points[:, 1])\r\n            self.frame_image_view.view.addItem(pi_right)\r\n            pi_right.setPen(pen)\r\n\r\n            # Store handles in memory\r\n            self.ROI_TABLE.loc[ii, 'handle_ROI'] = roi\r\n            self.ROI_TABLE.loc[ii, 'handle_ROI_contour'] = pi_right\r\n\r\n            # Make ROI inactive unless it is the last one\r\n            self.toggle_ROI_visibility(roi, force=ii==n_ROIs-1)\r\n\r\n            # Increase progress counter\r\n            dlg += 1\r\n\r\n        # If there are ROIs present, enable the tool that allows to translate the field of view\r\n        self.buttons.translation_ROI.setEnabled(n_ROIs > 0)\r\n\r\n        # Find next least common color in drawn ROIs\r\n        all_colors = self.COLORS\r\n        ROI_colors = np.array(np.vstack(self.ROI_TABLE['color'].values), dtype=np.int16)\r\n        ROI_colors = [tuple(c) for c in ROI_colors]\r\n        color_frequency = np.zeros((len(all_colors), ), dtype=int)\r\n        for c in ROI_colors:\r\n            color_frequency[all_colors.index(c)] += 1\r\n        self.next_ROI_color = all_colors[color_frequency.argmin()]\r\n\r\n        if has_window:\r\n            # Close progress dialog\r\n            dlg.close()\r\n            # Enable window\r\n            self.window.setEnabled(True)\r\n        # Log end of action\r\n        log('... done')\r\n\r\n\r\n    def callback_reload(self, what):\r\n        if not self.menu.menubar.isEnabled():\r\n            return\r\n        # Check whether window is open (e.g., during __init__())\r\n        has_window = hasattr(self, 'window')\r\n\r\n        if what == 'frames':\r\n            if has_window:\r\n                answer = MessageBox('Reset all transformations to the field of view?', title='GUI ROI segmentation', parent=self.window, button_Yes='Yes, of all frames', button_No='Cancel', additional_buttons='Yes, only of selected frames')\r\n                if answer == 'Cancel':\r\n                    return\r\n                # Disable window\r\n                self.window.setEnabled(False)\r\n                # Check which frames to reset\r\n                reset_all = answer == 'Yes, of all frames'\r\n            else:\r\n                reset_all = True\r\n\r\n            if reset_all:\r\n                # Initialize table to contain all info on how to translate single frames\r\n                self.TRANSFORMATION_MATRICES = pd.DataFrame(columns=['scale', 'rotation', 'translation'])\r\n                # Initialize lookup table to find where info of each condition is stored in the table\r\n                self.TRANSFORMATION_IDX = np.array([])\r\n                initialize_field(self, 'TRANSFORMATION_IDX', 'array', initial_value='list', shape=(self.n_conditions, 2))\r\n                self.TRANSFORMATION_IDX[:, 0] = np.arange(self.n_conditions, dtype=int)\r\n                # Initialize lookup table of pixels in which each value is stored\r\n                pixel_list = np.arange(self.PARAMETERS['n_pixels'], dtype=int)\r\n                pixel_list = pixel_list.reshape(self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width']).transpose().ravel()\r\n                self.MAPPING_TABLE = np.tile(np.atleast_2d(pixel_list), (self.n_conditions, 1)).astype(np.float32)  # Float32 conversion to hold NaNs\r\n                self.modified_MAPPING = np.zeros(shape=self.n_conditions, dtype=bool)\r\n            else:\r\n                # Get indices of trials to reset\r\n                trials_to_reset = self.current_average_frame\r\n                # Find transformations applied to these frames\r\n                transformations = self.TRANSFORMATION_IDX[np.in1d(self.TRANSFORMATION_IDX[:, 0], trials_to_reset), 1]\r\n                transformation_indices = np.unique(np.hstack(transformations))\r\n                if transformation_indices.size != 0:  # These frames have not been transformed\r\n                    # Find out whether these transformations are also applied to other frames\r\n                    if not np.any(np.in1d(self.TRANSFORMATION_IDX[:, 1], transformation_indices)):\r\n                        # Delete transformations from table\r\n                        self.TRANSFORMATION_MATRICES.drop(transformation_indices, inplace=True)\r\n                        self.TRANSFORMATION_MATRICES.reset_index(drop=True, inplace=True)\r\n                    # Reset transformations for these frames\r\n                    for trial in trials_to_reset:\r\n                        self.TRANSFORMATION_IDX[trial, 1] = list()\r\n                    # Initialize lookup table of pixels in which each value is stored\r\n                    pixel_list = np.arange(self.PARAMETERS['n_pixels'], dtype=int)\r\n                    pixel_list = pixel_list.reshape(self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width']).transpose().ravel()\r\n                    # Restore pixel mapping in these frames\r\n                    self.MAPPING_TABLE[trials_to_reset, :] = pixel_list\r\n                    self.modified_MAPPING[trials_to_reset] = False\r\n\r\n            # Reset temporary variable\r\n            self.temporary_MAPPING_TABLE = np.array([])\r\n            # Update table\r\n            self.update_table_condition_names()\r\n            # Update image\r\n            if has_window:\r\n                self.compute_frames_projection()\r\n\r\n        elif what == 'ROIs':\r\n            if has_window:\r\n                answer = MessageBox('Are you sure to delete all ROIs from memory?\\n(copy on disk will not be affected)', title='GUI ROI segmentation', parent=self.window)\r\n                if answer.lower() == 'no':\r\n                    return\r\n                # Disable window\r\n                self.window.setEnabled(False)\r\n                # Create progress dialog\r\n                n_ROIs = self.ROI_TABLE['handle_ROI'].shape[0]\r\n                dlg = ProgressDialog('Loading ROIs from disk', minimum=0, maximum=n_ROIs, parent=self.window)\r\n            else:\r\n                dlg = 0\r\n            # Delete all previous ROIs\r\n            all_ROIs = self.ROI_TABLE['handle_ROI'].values\r\n            for roi in all_ROIs:\r\n                if not isinstance(roi, np.ndarray):\r\n                    # Delete ROI\r\n                    self.callback_remove_ROI(roi, log_outcome=False)\r\n                    # Increase counter\r\n                    dlg += 1\r\n\r\n        if has_window:\r\n            # Enable window\r\n            self.window.setEnabled(True)\r\n\r\n\r\n    ############################################################################\r\n    # GUI-related\r\n    ############################################################################\r\n    @staticmethod\r\n    def make_image_box(lock_aspect_ratio=True, aspect_ratio=1, invert_y_axis=True, name=''):\r\n        viewbox = CustomViewBox(name=name)\r\n        image = pg.ImageItem()\r\n        graphics = pg.GraphicsView()\r\n        if lock_aspect_ratio:\r\n            viewbox.setAspectLocked(True, ratio=aspect_ratio)\r\n        viewbox.invertY(invert_y_axis)\r\n        graphics.setCentralItem(viewbox)\r\n        viewbox.addItem(image)\r\n\r\n        return viewbox, image, graphics\r\n\r\n\r\n    def toggle_crosshair(self, state):\r\n        # Bring to top\r\n        [c.setVisible(state=='on') for c in self.crosshair]\r\n        [c.setZValue(1000) for c in self.crosshair]\r\n\r\n\r\n    def toggle_toolbar(self, state, because):\r\n        state_bool = state == 'on'\r\n\r\n        if because == 'ROI_drawing':\r\n            self.buttons.draw_ROI.setEnabled(state_bool)\r\n            self.buttons.translation_ROI.setEnabled(state_bool)\r\n            self.buttons.visibility_ROI.setEnabled(state_bool)\r\n            self.buttons.link_views.setEnabled(state_bool)\r\n            self.buttons.link_histograms.setEnabled(state_bool)\r\n            self.buttons.anchor_trace.setEnabled(state_bool)\r\n\r\n        elif because == 'translating_field_of_view':\r\n            self.buttons.draw_ROI.setEnabled(state_bool)\r\n            self.buttons.visibility_ROI.setEnabled(state_bool)\r\n            self.buttons.link_views.setEnabled(state_bool)\r\n            self.buttons.link_histograms.setEnabled(state_bool)\r\n            self.buttons.anchor_trace.setEnabled(state_bool)\r\n\r\n        elif because == 'changing_visibility_traces':\r\n            self.buttons.draw_ROI.setEnabled(state_bool)\r\n            self.buttons.translation_ROI.setEnabled(state_bool)\r\n            self.buttons.visibility_ROI.setEnabled(state_bool)\r\n            self.buttons.link_views.setEnabled(state_bool)\r\n            self.buttons.link_histograms.setEnabled(state_bool)\r\n            self.buttons.anchor_trace.setEnabled(state_bool)\r\n\r\n\r\n    def toggle_slider_flood_tolerance(self, new_state):\r\n        self.slider.setEnabled(new_state)\r\n        self.slider_label.setEnabled(new_state)\r\n        if new_state:\r\n            self.slider.setStyleSheet('')\r\n        else:\r\n            self.slider.setStyleSheet('QSlider::sub-page:horizontal:disabled {background: #eee; border-color: #999;}')\r\n\r\n\r\n    def make_region(self, regions):\r\n        # Make sure input is a 2D array\r\n        if not isinstance(regions, np.ndarray):\r\n            regions = np.array(regions, dtype=int)\r\n        if regions.ndim == 1:\r\n            regions = np.atleast_2d(regions)\r\n\r\n        # If other regions are present, delete them first\r\n        if len(self.region_selection) > 0:\r\n            self.delete_regions()\r\n\r\n        # Add new regions\r\n        for ireg in range(regions.shape[0]):\r\n            # Crete region\r\n            reg1 = pg.LinearRegionItem(movable=False, bounds=[0, self.PARAMETERS['n_frames']], brush=GUI_default['region_colors_dark'], pen=pg.mkPen(None))\r\n            # Set region\r\n            reg1.setRegion(regions[ireg, :])\r\n            reg1.setZValue(0)\r\n            self.frame_image_view.timeLine.getViewBox().addItem(reg1, ignoreBounds=True)\r\n\r\n            # Crete region\r\n            if len(self.current_average_frame) == 1 and self.trace_anchored:\r\n                brush = pg.mkBrush(None)\r\n            else:\r\n                brush = GUI_default['region_colors_light']\r\n            reg2 = pg.LinearRegionItem(movable=False, bounds=self.time_range, brush=brush, pen=pg.mkPen(None))\r\n            # Set region (in time)\r\n            reg2.setRegion(regions[ireg, :] / GUI_default['frame_rate'])\r\n            reg2.setZValue(0)\r\n            self.trace_viewbox.addItem(reg2, ignoreBounds=True)\r\n\r\n            # Keep values in memory\r\n            self.region_selection.append([reg1, reg2])\r\n\r\n\r\n    def delete_regions(self):\r\n        if len(self.region_selection) > 0:\r\n            [self.frame_image_view.timeLine.getViewBox().removeItem(ii[0]) for ii in self.region_selection]\r\n            [self.trace_viewbox.removeItem(ii[1]) for ii in self.region_selection]\r\n            self.region_selection = list()\r\n\r\n\r\n    def compute_frames_projection(self, return_image=False, force_update_histogram=False):\r\n        # Get frames\r\n        frames = self.data_average[self.current_average_type][self.current_average_frame, :, :].copy()\r\n\r\n        # Apply transformations\r\n        n_frames = len(self.current_average_frame)\r\n        for iframe in range(n_frames):\r\n            T = self.TRANSFORMATION_IDX[self.TRANSFORMATION_IDX[:, 0] == self.current_average_frame[iframe], 1][0]\r\n            if len(T) > 0:\r\n                # Apply transformations to current frame one after the other\r\n                for t_idx in T:\r\n                    # Get matrices\r\n                    scale = self.TRANSFORMATION_MATRICES.loc[t_idx, 'scale']\r\n                    rotation = self.TRANSFORMATION_MATRICES.loc[t_idx, 'rotation']\r\n                    translation = self.TRANSFORMATION_MATRICES.loc[t_idx, 'translation']\r\n                    # Apply them\r\n                    frames[iframe, :, :] = transform_image_from_matrices(frames[iframe, :, :], scale, rotation, translation)\r\n\r\n        # Initialize output variable\r\n        projection = None\r\n        # Apply function to compute projection\r\n        if self.current_projection_type == 'max':\r\n            projection = np.nanmax(frames, axis=0)\r\n        elif self.current_projection_type == 'mean':\r\n            projection = np.nanmean(frames, axis=0)\r\n        elif self.current_projection_type == 'median':\r\n            projection = np.nanmedian(frames, axis=0)\r\n        elif self.current_projection_type == 'standard deviation':\r\n            projection = np.nanstd(frames, axis=0)\r\n\r\n        if self.current_average_type == 'correlation':\r\n            pos, rgba_colors = zip(*cmapToColormap(mpl_colormaps.RdBu_r))\r\n            colormap = pg.ColorMap(pos, rgba_colors)\r\n            self.average_histogram.item.gradient.setColorMap(colormap)\r\n            self.average_histogram.item.region.setBounds([-1, 1])\r\n            self.average_histogram.item.setHistogramRange(-1, 1)\r\n            self.average_histogram.item.vb.setRange(yRange=[-1, 1], disableAutoRange=True)\r\n        else:\r\n            self.callback_toggle_colormap(force=self.current_colormap)\r\n            self.average_histogram.item.region.setBounds([None, None])\r\n            self.average_histogram.vb.enableAutoRange(self.average_histogram.vb.YAxis, True)\r\n            self.average_histogram.item.vb.enableAutoRange(y=True)\r\n\r\n        if return_image:\r\n            # Apply levels\r\n            levels = self.average_histogram.item.getLevels()\r\n            projection = np.clip(projection, a_min=levels[0], a_max=levels[1])\r\n\r\n            return projection\r\n\r\n        else:\r\n            # Update image\r\n            self.average_image_view.setImage(projection, autoLevels=False)\r\n            # Update histogram\r\n            if self.auto_adjust_histograms or force_update_histogram:\r\n                projection = projection.ravel()\r\n                levels = np.percentile(projection[~np.isnan(projection)], q=[1, 99])\r\n                self.average_histogram.item.setLevels(levels[0], levels[1])\r\n                self.average_histogram.item.autoHistogramRange()\r\n\r\n\r\n    def callback_toggle_colormap(self, force=None):\r\n        # Force a colormap to be equal to what the user wants\r\n        if force is not None:\r\n            self.current_colormap = force\r\n        else:\r\n            if self.current_colormap == 0:\r\n                self.current_colormap = 1\r\n            else:\r\n                self.current_colormap = 0\r\n\r\n        # Set colors\r\n        if self.current_colormap == 1:\r\n            background_color = 'w'\r\n            foreground_color = 'k'\r\n            timeline_pen = (0, 0, 0, 200)\r\n            border_pen = (0, 0, 0)\r\n        else:\r\n            background_color = 'k'\r\n            foreground_color = 'w'\r\n            timeline_pen = (255, 255, 0, 200)\r\n            border_pen = (255, 255, 255)\r\n        # Top left plot\r\n        if self.current_average_type == 'correlation':\r\n            pos, rgba_colors = zip(*cmapToColormap(mpl_colormaps.RdBu_r))\r\n            colormap = pg.ColorMap(pos, rgba_colors)\r\n            self.average_histogram.item.gradient.setColorMap(colormap)\r\n            self.average_histogram.item.region.setBounds([-1, 1])\r\n            self.average_histogram.item.setHistogramRange(-1, 1)\r\n            self.average_histogram.item.vb.setRange(yRange=[-1, 1], disableAutoRange=True)\r\n        else:\r\n            self.average_histogram.item.gradient.setColorMap(self.colormap[self.current_colormap])\r\n            self.average_histogram.item.region.setBounds([None, None])\r\n            self.average_histogram.vb.enableAutoRange(self.average_histogram.vb.YAxis, True)\r\n            self.average_histogram.item.vb.enableAutoRange(y=True)\r\n        self.average_image_viewbox.setBackgroundColor(background_color)\r\n        self.image_views_title[0].setColor(foreground_color)\r\n        self.average_histogram.setBackground(background_color)\r\n        [self.FOV_borders[0][ii].setPen(border_pen) for ii in range(4)]\r\n\r\n        # Top right plot\r\n        self.frame_image_view.setColorMap(self.colormap[self.current_colormap])\r\n        self.frame_image_view.view.setBackgroundColor(background_color)\r\n        self.image_views_title[1].setColor(foreground_color)\r\n        self.frame_image_view.ui.histogram.setBackground(background_color)\r\n        self.frame_image_view.timeLine.getViewWidget().setBackground(background_color)\r\n        self.frame_image_view.timeLine.setPen(timeline_pen)\r\n        [self.FOV_borders[1][ii].setPen(border_pen) for ii in range(4)]\r\n        # Change tick color in timeline\r\n        items = self.frame_image_view.timeLine.scene().items()\r\n        item = [ii for ii in items if ii.__class__.__name__ == 'PlotItem'][0]\r\n        item.axes['bottom']['item'].setPen(foreground_color)\r\n\r\n        # Bottom panels\r\n        self.trace_viewbox.setBackground(background_color)\r\n        items = self.trace_viewbox.scene().items()\r\n        items = [ii for ii in items if ii.__class__.__name__ == 'PlotItem']\r\n        [item.axes['left']['item'].setPen(foreground_color) for item in items]\r\n        [item.axes['bottom']['item'].setPen(foreground_color) for item in items]\r\n\r\n        if self.stimulus_profile is not None:\r\n            self.stimulus_profile.setPen(GUI_default['stimulus_profile_pen'][self.current_colormap])\r\n        lut = self.colormap[self.current_colormap].getLookupTable(0.0, 1.0, 256)\r\n        self.ROI_view.setLookupTable(lut)\r\n        self.ROI_viewbox.setBackgroundColor(background_color)\r\n        if self.selected_ROI is None:\r\n            if self.current_colormap == 1:\r\n                color = (255, 255, 255)\r\n            else:\r\n                color = (0, 0, 0)\r\n            self.color_ROI_view_border(color)\r\n\r\n\r\n    def color_ROI_view_border(self, color):\r\n        if self.current_colormap == 1:\r\n            if len(color) == 0:\r\n                color = (255, 255, 255)\r\n            thickness = 5\r\n        else:\r\n            if len(color) == 0:\r\n                color = (0, 0, 0)\r\n            thickness = 6\r\n        # Apply color\r\n        self.ROI_border.setStyleSheet('border:%ipx solid rgb(%i, %i, %i);' % (thickness, color[0], color[1], color[2]))\r\n\r\n\r\n    def callback_menu_projection_type(self, name):\r\n        if not self.menu.menubar.isEnabled():\r\n            return\r\n        # Set new name\r\n        self.current_projection_type = name\r\n        # Update plot\r\n        self.compute_frames_projection(force_update_histogram=True)\r\n\r\n\r\n    def callback_menu_average_type(self, name):\r\n        if not self.menu.menubar.isEnabled():\r\n            return\r\n        # Set new name\r\n        self.current_average_type = name\r\n        # Update plot\r\n        self.compute_frames_projection(force_update_histogram=True)\r\n\r\n\r\n    def callback_menu_operation_type(self, name):\r\n        if not self.menu.menubar.isEnabled():\r\n            return\r\n        # Set new name\r\n        self.current_operation_type = name\r\n        # Update visible traces\r\n        table_rows = self.ROI_TABLE['show_trace'].index.values\r\n        for roi in self.ROI_TABLE.loc[table_rows, 'handle_ROI'].tolist():\r\n            self.callback_update_zoom_ROI(roi, update_trace=True, update_ROI_contour=False)\r\n        self.average_histogram.item.autoHistogramRange()\r\n\r\n\r\n    def callback_update_histogram(self, source_histogram, update_average, update_ROI, update_frame):\r\n        if not self.updating_histograms:\r\n            # Initialize variables\r\n            levels = None\r\n            # Set flag\r\n            self.updating_histograms = True\r\n            # Get levels and update levels on other histogram\r\n            if source_histogram == 'average':\r\n                levels = self.average_histogram.item.getLevels()\r\n                self.frame_image_view.getHistogramWidget().item.setLevels(levels[0], levels[1])\r\n            elif source_histogram == 'frame':\r\n                levels = self.frame_image_view.getHistogramWidget().item.getLevels()\r\n                self.average_histogram.item.setLevels(levels[0], levels[1])\r\n\r\n            # Apply them\r\n            if update_average:\r\n                self.average_image_view.setLevels(levels)\r\n            if update_ROI:\r\n                self.ROI_view.setLevels(levels)\r\n            if update_frame:\r\n                self.frame_image_view.imageItem.setLevels(levels)\r\n            # Reset flag\r\n            self.updating_histograms = False\r\n\r\n\r\n    def callback_link_histograms(self, new_state):\r\n        self.histograms_linked = new_state\r\n        frame_hist = self.frame_image_view.getHistogramWidget().item\r\n        # Disconnect previous callbacks\r\n        try:\r\n            self.average_histogram.item.sigLevelsChanged.disconnect()\r\n            frame_hist.sigLevelsChanged.disconnect()\r\n        except TypeError as e:\r\n            # An error occurs when no callback was previously connected. The error message contains 'disconnect() failed'\r\n            if 'disconnect() failed' not in str(e):\r\n                raise  # Re-raise error\r\n\r\n        # Connect new callbacks\r\n        if new_state:\r\n            self.average_histogram.item.sigLevelsChanged.connect(partial(self.callback_update_histogram, source_histogram='average', update_average=False, update_ROI=True, update_frame=True))\r\n            frame_hist.sigLevelsChanged.connect(partial(self.callback_update_histogram, source_histogram='frame', update_average=True, update_ROI=True, update_frame=False))\r\n            # Force histograms to automatically adjust range\r\n            self.callback_auto_adjust_histograms(new_state=True)\r\n        else:  # Restore original signals\r\n            self.average_histogram.item.sigLevelsChanged.connect(self.average_histogram.item.regionChanged)\r\n            frame_hist.sigLevelsChanged.connect(frame_hist.regionChanged)\r\n\r\n        # Update icon\r\n        if new_state:\r\n            icon = QtGui.QIcon(QtGui.QPixmap(GUI_default['icons']['link_histograms'][1]))\r\n        else:\r\n            icon = QtGui.QIcon(QtGui.QPixmap(GUI_default['icons']['link_histograms'][0]))\r\n        self.buttons.link_histograms.setIcon(icon)\r\n\r\n\r\n    def callback_auto_adjust_histograms(self, new_state):\r\n        if not self.menu.menubar.isEnabled():\r\n            return\r\n        self.auto_adjust_histograms = new_state\r\n\r\n\r\n    def callback_link_views(self, new_state):\r\n        self.views_linked = new_state\r\n        # If other regions are present, delete them first\r\n        if len(self.region_selection) > 0:\r\n            self.delete_regions()\r\n        self.callback_timeline_frames(from_plot='frame')\r\n\r\n        # Update icon\r\n        if new_state:\r\n            icon = QtGui.QIcon(QtGui.QPixmap(GUI_default['icons']['link_views'][1]))\r\n        else:\r\n            icon = QtGui.QIcon(QtGui.QPixmap(GUI_default['icons']['link_views'][0]))\r\n        self.buttons.link_views.setIcon(icon)\r\n\r\n\r\n    def callback_anchor_trace(self, new_state):\r\n        self.trace_anchored = new_state\r\n        # If other regions are present, delete them first\r\n        if len(self.region_selection) > 0:\r\n            self.delete_regions()\r\n        self.callback_timeline_frames(from_plot='frame')\r\n\r\n        # Update icon\r\n        if new_state:\r\n            icon = QtGui.QIcon(QtGui.QPixmap(GUI_default['icons']['anchor_trace'][1]))\r\n        else:\r\n            icon = QtGui.QIcon(QtGui.QPixmap(GUI_default['icons']['anchor_trace'][0]))\r\n        self.buttons.anchor_trace.setIcon(icon)\r\n\r\n\r\n    def callback_continue_last_action(self):\r\n        if self.current_action == 'drawing_ROI':\r\n            self.callback_draw_ROI()\r\n        elif self.current_action == 'translating_FOV':\r\n            self.callback_accept_translation_FOV()\r\n\r\n        elif self.current_action == '':\r\n            roi = self.selected_ROI\r\n            table_row = self.ROI_TABLE[self.ROI_TABLE['id'] == roi.ROI_id].index.values[0]\r\n            ROI_type = self.ROI_TABLE.loc[table_row, 'type']\r\n            if ROI_type == 'fill':\r\n                self.callback_update_zoom_ROI(roi, update_trace=True, update_ROI_contour=True)\r\n\r\n\r\n    def callback_cancel_last_action(self):\r\n        # Make sure no other action is invoked from these operations\r\n        last_action = self.current_action\r\n        self.current_action = ''\r\n\r\n        if last_action == 'drawing_ROI':\r\n            if self.last_ROI_coordinates_handle is not None:\r\n                self.average_image_viewbox.removeItem(self.last_ROI_coordinates_handle)\r\n            self.last_ROI_coordinates_handle = None\r\n            self.last_ROI_coordinates = list()\r\n            # Inactivate crosshair\r\n            self.toggle_crosshair('off')\r\n            # Drawing this ROI is finished, so re-enable menus\r\n            self.menu.menubar.setEnabled(True)\r\n            self.toggle_toolbar('on', because='ROI_drawing')\r\n            # Reset button style\r\n            self.buttons.draw_ROI.setStyleSheet('background-color: None')\r\n\r\n        elif last_action == 'translating_FOV':\r\n            # Clear image and reset data into it\r\n            self.average_image_viewbox.removeItem(self.average_image_view)\r\n            self.average_image_viewbox.removeItem(self.translation_ROI)\r\n            self.average_image_view = pg.ImageItem(self.translation_image)\r\n            self.average_image_view.setZValue(0)\r\n            self.average_image_viewbox.addItem(self.average_image_view)\r\n            # Reassign image to histogram widget and set levels to what they were before\r\n            self.average_histogram.item.setImageItem(self.average_image_view)\r\n            self.average_image_view.setLevels(self.translation_image_levels)\r\n            # Disconnect callback\r\n            self.translation_ROI.sigRegionChanged.disconnect()\r\n            # Toggle internal flags\r\n            self.translation_ROI = None\r\n            self.translation_image = None\r\n            self.translation_image_levels = None\r\n            self.temporary_MAPPING_TABLE = np.array([])\r\n            # Toggle GUI button\r\n            self.buttons.translation_ROI.setChecked(False)\r\n            # Make sure colormap is correct\r\n            self.callback_toggle_colormap(force=self.current_colormap)\r\n            self.toggle_toolbar('on', because='translating_field_of_view')\r\n\r\n        elif self.toggling_ROI_visibility:\r\n            # Inactivate crosshair\r\n            self.toggle_crosshair('off')\r\n            self.toggling_ROI_visibility = False\r\n            self.toggle_toolbar('on', because='changing_visibility_traces')\r\n\r\n\r\n    def callback_fix_colormap(self):\r\n        self.callback_toggle_colormap(force=self.current_colormap)\r\n\r\n\r\n    ############################################################################\r\n    # ROI-related\r\n    ############################################################################\r\n    def get_next_ROI_color(self):\r\n        if self.next_ROI_color is None:\r\n            color_idx = 0\r\n        else:\r\n            n_colors = len(self.COLORS)\r\n            last_color_idx = self.COLORS.index(self.next_ROI_color)\r\n            # Wrap index\r\n            color_idx = (last_color_idx + 1) % n_colors\r\n        self.next_ROI_color = self.COLORS[color_idx]\r\n\r\n\r\n    def callback_choose_ROI_type(self, position):\r\n        # Make menu\r\n        menu = QtWidgets.QMenu(self.window)\r\n        # List all ROI types allowed\r\n        menu.addAction(self.buttons.ROI_fill)\r\n        menu.addAction(self.buttons.ROI_polygon)\r\n        # Show menu and let user choose an action\r\n        chosen_action = menu.exec_(self.buttons.draw_ROI.mapToGlobal(position))\r\n\r\n        # Set flag\r\n        if chosen_action == self.buttons.ROI_fill:\r\n            self.selected_ROI_type = 'fill'\r\n        elif chosen_action == self.buttons.ROI_polygon:\r\n            self.selected_ROI_type = 'polygon'\r\n        else:\r\n            return\r\n        # Set icon\r\n        if GUI_default['icons_kind']['ROI_' + self.selected_ROI_type] == 'text':\r\n            self.buttons.draw_ROI.setToolButtonStyle(QtCore.Qt.ToolButtonTextOnly)\r\n            self.buttons.draw_ROI.setText(GUI_default['icons']['ROI_' + self.selected_ROI_type])\r\n        elif GUI_default['icons_kind']['ROI_' + self.selected_ROI_type] == 'icon':\r\n            self.buttons.draw_ROI.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)\r\n            self.buttons.draw_ROI.setIcon(QtGui.QIcon(QtGui.QPixmap(GUI_default['icons']['ROI_' + self.selected_ROI_type])))\r\n        # Toggle flood tolerance slider\r\n        self.toggle_slider_flood_tolerance(self.selected_ROI_type == 'fill')\r\n\r\n\r\n    def callback_draft_ROI(self):\r\n        if self.current_action == '':  # If not doing anything else already\r\n            # Disable toolbars\r\n            self.menu.menubar.setEnabled(False)\r\n            self.toggle_toolbar('off', because='ROI_drawing')\r\n            # Activate crosshair\r\n            self.toggle_crosshair('on')\r\n            # Toggle internal flag\r\n            self.current_action = 'drawing_ROI'\r\n            # Change background color of button\r\n            self.buttons.draw_ROI.setStyleSheet(str('background-color: rgb%s' % str(tuple(np.array(GUI_default['icon_background']['no_go'], dtype=float) * 255))))\r\n            # Set color to assign to next ROI\r\n            self.get_next_ROI_color()\r\n            # Toggle flood tolerance slider\r\n            self.toggle_slider_flood_tolerance(self.selected_ROI_type == 'fill')\r\n\r\n\r\n    def callback_draw_ROI(self):\r\n        # Check that user is drawing an ROI\r\n        if self.current_action == 'drawing_ROI':\r\n            # Initialize local variables\r\n            last_row = None\r\n            shown_traces = None\r\n            roi = None\r\n\r\n            # Toggle internal flag\r\n            self.current_action = ''\r\n\r\n            # Get user inputs to make ROI\r\n            points = self.last_ROI_coordinates\r\n\r\n            # Delete markers\r\n            if self.last_ROI_coordinates_handle is not None:\r\n                self.average_image_viewbox.removeItem(self.last_ROI_coordinates_handle)\r\n            self.last_ROI_coordinates_handle = None\r\n            self.last_ROI_coordinates = list()\r\n\r\n            # Get color of this ROI\r\n            pen = pg.mkPen(color=self.next_ROI_color, width=GUI_default['ROI_linewidth_thick'])\r\n            # Compute points\r\n            if self.selected_ROI_type == 'fill':\r\n                reference_pixel = points[0].copy()\r\n                points = self.make_ROI_from_point(reference_pixel)\r\n                flood_tolerance = self.flood_tolerance\r\n            else:\r\n                reference_pixel = 0\r\n                flood_tolerance = 0\r\n\r\n            draw_ROI = len(points) > 2  # Cannot close an area with less than 3 points\r\n            if draw_ROI:\r\n                # Make ROI\r\n                roi = PolyLineROI(points, pen=pen, closed=True, movable=True, removable=True)\r\n                # Automatically select this ROI\r\n                self.selected_ROI = roi\r\n                # Add contextual menu to change color of the ROI\r\n                self.ROI_add_context_menu(roi)\r\n                # Add ROI to plot\r\n                self.average_image_viewbox.addItem(roi)\r\n\r\n                # Connect callbacks\r\n                roi.sigRegionChanged.connect(partial(self.callback_update_zoom_ROI, update_trace=True, update_ROI_contour=True))\r\n                roi.sigRemoveRequested.connect(partial(self.callback_remove_ROI, log_outcome=True))\r\n                roi.sigClicked.connect(self.callback_click_ROI)\r\n                roi.setAcceptedMouseButtons(QtCore.Qt.LeftButton)\r\n\r\n                # Store info on this ROI\r\n                ROI_id = make_new_ROI_id(self.ROI_TABLE['id'])\r\n                roi.ROI_id = ROI_id  # Write it in the handle so we can always come back to the table without checking where the handle was\r\n                # Get number of traces shown before adding the new one\r\n                shown_traces = np.where(self.ROI_TABLE['show_trace'])[0].shape[0]\r\n                last_row = self.ROI_TABLE.shape[0]\r\n                self.ROI_TABLE.at[last_row, 'id'] = ROI_id\r\n                self.ROI_TABLE.at[last_row, 'handle_ROI'] = roi\r\n                self.ROI_TABLE.at[last_row, 'handle_ROI_contour'] = None\r\n                self.ROI_TABLE.at[last_row, 'handle_trace'] = None\r\n                self.ROI_TABLE.at[last_row, 'type'] = self.selected_ROI_type\r\n                self.ROI_TABLE.at[last_row, 'reference_pixel'] = reference_pixel\r\n                self.ROI_TABLE.at[last_row, 'flood_tolerance'] = flood_tolerance\r\n                self.ROI_TABLE.at[last_row, 'region'] = points\r\n                self.ROI_TABLE.at[last_row, 'color'] = self.next_ROI_color\r\n                self.ROI_TABLE.at[last_row, 'show_trace'] = True\r\n\r\n            else:\r\n                self.selected_ROI = None\r\n\r\n            # Deactivate crosshair\r\n            self.toggle_crosshair('off')\r\n            # Reset button style\r\n            self.buttons.draw_ROI.setStyleSheet('background-color: None')\r\n            # Toggle flood tolerance slider\r\n            self.toggle_slider_flood_tolerance(self.selected_ROI_type == 'fill')\r\n\r\n            if draw_ROI:\r\n                # Transform ROI to a static polygon\r\n                points = np.array(roi.getState()['points'])\r\n                points = np.vstack((points, points[0, :]))\r\n                # Make PlotItem\r\n                pi_right = pg.PlotCurveItem(pen='r', clickable=False)\r\n                pi_right.setData(x=points[:, 0], y=points[:, 1])\r\n                self.frame_image_view.view.addItem(pi_right)\r\n                pi_right.setPen(pen)\r\n                self.ROI_TABLE.at[last_row, 'handle_ROI_contour'] = pi_right\r\n                # Update plot range\r\n                self.frame_image_view.view.autoRange()\r\n\r\n                # Change color around ROI viewbox\r\n                self.color_ROI_view_border(color=self.next_ROI_color)\r\n\r\n                # Drawing this ROI is finished, so re-enable menus\r\n                self.menu.menubar.setEnabled(True)\r\n                self.toggle_toolbar('on', because='ROI_drawing')\r\n                # If there are ROIs present, enable the tool that allows to translate the field of view\r\n                n_ROIs = self.ROI_TABLE.shape[0]\r\n                self.buttons.translation_ROI.setEnabled(n_ROIs > 0)\r\n                # Trigger update immediately\r\n                if self.selected_ROI_type != 'fill':\r\n                    roi.sigRegionChanged.emit(roi)\r\n                # Update trace range\r\n                if shown_traces == 0:\r\n                    self.callback_reset_zoom(where='trace')\r\n                # Set which traces can be shown\r\n                self.callback_update_visibility_traces(from_button=False)\r\n                self.update_trace_zvalue()\r\n\r\n                # Set value of slider to tolerance value used to compute this ROI\r\n                if self.selected_ROI_type == 'fill':\r\n                    self.slider.blockSignals(True)\r\n                    self.slider.setValue(self.flood_tolerance * 10)\r\n                    self.slider_label.setText('%.1f' % self.flood_tolerance)\r\n                    self.slider.blockSignals(False)\r\n\r\n                # Log outcome\r\n                log('Added ROI #%i' % roi.ROI_id)\r\n\r\n            # Re-start tool for drawing ROIs\r\n            self.callback_draft_ROI()\r\n\r\n\r\n    def callback_update_zoom_ROI(self, roi, update_trace=True, update_ROI_contour=True):\r\n        # If user clicked on a child ROI, get the handle of the parent\r\n        if not hasattr(roi, 'ROI_id'):\r\n            roi = roi.parent\r\n\r\n        # Get contour of this ROI\r\n        points = np.array(roi.getState()['points'])\r\n        # Return immediately if ROI is empty\r\n        if points.size == 0:\r\n            return\r\n\r\n        # Automatically select this ROI if any of its parts is moving or no ROI was previously selected\r\n        if self.selected_ROI is None or roi.isMoving or any([h.isMoving for h in roi.getHandles()]):\r\n            self.selected_ROI = roi\r\n\r\n        # Get array region from projection selection graph\r\n        image_to_analyze = self.compute_frames_projection(return_image=True)\r\n        area, coords = roi.getArrayRegion(image_to_analyze, self.average_image_view, axes=(0, 1), returnMappedCoords=True)\r\n\r\n        if area.size == 0:\r\n            return\r\n\r\n        # Show ROI in lower left panel, if this ROI is selected\r\n        if roi is self.selected_ROI:\r\n            self.ROI_view.setImage(area, autoLevels=True)\r\n            self.ROI_viewbox.autoRange()\r\n            # Change color around ROI viewbox\r\n            color = self.ROI_TABLE.loc[self.ROI_TABLE['id'] == roi.ROI_id, 'color'].values[0]\r\n            self.color_ROI_view_border(color=color)\r\n\r\n        # Get row with info on this ROI\r\n        table_row = self.ROI_TABLE[self.ROI_TABLE['id'] == roi.ROI_id].index.values[0]\r\n        # Update corners of ROI\r\n        self.ROI_TABLE.at[table_row, 'region'] = points\r\n\r\n        # Get ROI type\r\n        ROI_type = self.ROI_TABLE.loc[table_row, 'type']\r\n        if ROI_type == 'fill' and not self.slider_update_GUI:\r\n            return\r\n\r\n        # Update trace, if allowed\r\n        if self.ROI_TABLE.loc[table_row, 'show_trace'] and update_trace:\r\n            # Initialize variables\r\n            temp_modified_conditions_idx = None\r\n            L = None\r\n            # Get indices of ROI pixels\r\n            area_idx = np.where(area > 0)\r\n            ROI_idx = np.vstack((coords[0, area_idx[0], area_idx[1]], coords[1, area_idx[0], area_idx[1]]))\r\n            ROI_pixels = np.unique(np.ravel_multi_index(np.round(ROI_idx, decimals=0).astype(int), [self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width']], mode='clip', order='C'))\r\n            # Luminance values\r\n            if self.current_operation_type == 'mean':\r\n                L = np.mean(self.data_time_first[ROI_pixels, :], axis=0)\r\n            elif self.current_operation_type == 'max':\r\n                L = np.max(self.data_time_first[ROI_pixels, :], axis=0)\r\n\r\n            # Check whether some segments have been translated\r\n            if self.current_action == 'translating_FOV' or np.any(self.modified_MAPPING):\r\n                # Get index of frames that are modified\r\n                modified_conditions_idx = np.where(self.modified_MAPPING == True)[0]\r\n                if self.current_action == 'translating_FOV':\r\n                    # Get index of currently selected frames\r\n                    temp_modified_conditions_idx = np.array(self.current_average_frame, dtype=int)\r\n                    # Remove frames that will be replaced\r\n                    modified_conditions_idx = np.setdiff1d(modified_conditions_idx, temp_modified_conditions_idx).ravel()\r\n                # Get segments that have been translated\r\n                if modified_conditions_idx.size > 0:\r\n                    L_modified, modified_frames_idx = self.get_translated_trace_segments(modified_conditions_idx, ROI_pixels, from_temporary=False)\r\n                    # Replace values in original array\r\n                    L[modified_frames_idx] = L_modified\r\n                # Get segments from frames that are currently being translated\r\n                if self.current_action == 'translating_FOV':\r\n                    try:\r\n                        L_modified, modified_frames_idx = self.get_translated_trace_segments(temp_modified_conditions_idx, ROI_pixels, from_temporary=True)\r\n                        # Replace values in original array\r\n                        L[modified_frames_idx] = L_modified\r\n                    except TypeError:\r\n                        pass\r\n\r\n            # Check whether we have to create a new trace\r\n            if self.ROI_TABLE.loc[table_row, 'handle_trace'] is None:\r\n                # Make new PlotCurveItem\r\n                pi = pg.PlotCurveItem(clickable=False)\r\n                self.trace_viewbox.addItem(pi)\r\n                # Store handle\r\n                self.ROI_TABLE.loc[table_row, 'handle_trace'] = pi\r\n                # Make pen\r\n                ROI_color = self.ROI_TABLE.loc[table_row, 'color']\r\n                pen = pg.mkPen(color=ROI_color)\r\n                pi.setPen(pen)\r\n            else:  # Take curve handle\r\n                pi = self.ROI_TABLE.loc[table_row, 'handle_trace']\r\n\r\n            # Update data\r\n            pi.setData(self.time, L, connect='finite')\r\n            # Update z-values\r\n            self.update_trace_zvalue()\r\n\r\n        if update_ROI_contour:\r\n            # Update ROI overlay\r\n            points = np.array(roi.getState()['points'])\r\n            points = np.vstack((points, points[0, :]))\r\n            # Add offset from original position\r\n            points += np.array(roi.state['pos'])\r\n            # Update data\r\n            self.ROI_TABLE.loc[table_row, 'handle_ROI_contour'].setData(x=points[:, 0], y=points[:, 1])\r\n\r\n\r\n    def update_trace_zvalue(self):\r\n        # Reset z-value of all traces to 2\r\n        for row in self.ROI_TABLE.index.values:\r\n            handle_trace = self.ROI_TABLE.loc[row, 'handle_trace']\r\n            if handle_trace is not None:\r\n                handle_trace.setZValue(2)\r\n        # Set z-value of current ROI's trace to 3\r\n        table_row = self.ROI_TABLE[self.ROI_TABLE['id'] == self.selected_ROI.ROI_id].index.values[0]\r\n        self.ROI_TABLE.loc[table_row, 'show_trace'] = True\r\n        handle_trace = self.ROI_TABLE.loc[table_row, 'handle_trace']\r\n        if handle_trace is None:\r\n            self.callback_update_zoom_ROI(self.selected_ROI, update_trace=True, update_ROI_contour=True)\r\n            handle_trace = self.ROI_TABLE.loc[table_row, 'handle_trace']\r\n        handle_trace.setZValue(3)\r\n\r\n\r\n    def callback_update_visibility_traces(self, from_button):\r\n        if from_button:\r\n            self.toggling_ROI_visibility = True\r\n            self.toggle_crosshair('on')\r\n            self.toggle_toolbar('off', because='changing_visibility_traces')\r\n        else:\r\n            max_n = GUI_default['max_n_visible_ROI_traces']\r\n            # Get all unselected ROIs\r\n            all_ROIs = self.ROI_TABLE.loc[self.ROI_TABLE['show_trace'], 'handle_ROI'].values\r\n            unselected_ROIs = np.array([roi for roi in all_ROIs if roi is not self.selected_ROI], dtype=object)\r\n            # Discard last max_n - 1 unselected ROIs\r\n            if max_n == 0:\r\n                unselected_ROIs_to_hide = unselected_ROIs\r\n                unselected_ROIs_to_show = list()\r\n            else:\r\n                unselected_ROIs_to_hide = unselected_ROIs[:-max_n]\r\n                # Make sure that selected ROI is visible and also other unselected ROIs\r\n                if len(unselected_ROIs) > 0:\r\n                    unselected_ROIs_to_show = list([unselected_ROIs[-1]])\r\n                else:\r\n                    unselected_ROIs_to_show = list()\r\n            unselected_ROIs_to_show.append(self.selected_ROI)\r\n            # Toggle visibility\r\n            for roi in unselected_ROIs_to_hide:\r\n                self.toggle_ROI_visibility(roi, force=False)\r\n            for roi in unselected_ROIs_to_show:\r\n                self.toggle_ROI_visibility(roi, force=True)\r\n\r\n\r\n    def toggle_ROI_visibility(self, roi, force):\r\n        if force is None:\r\n            new_state = roi.pen.style() == QtCore.Qt.CustomDashLine\r\n        else:\r\n            new_state = force\r\n\r\n        table_row = self.ROI_TABLE[self.ROI_TABLE['id'] == roi.ROI_id].index.values[0]\r\n        if new_state:\r\n            # Show traces\r\n            self.ROI_TABLE.loc[table_row, 'show_trace'] = True\r\n            self.callback_update_zoom_ROI(roi, update_trace=True, update_ROI_contour=True)\r\n            # Change style of ROI in overlays\r\n            pen = roi.pen\r\n            pen.setStyle(QtCore.Qt.SolidLine)\r\n            pen.setColor(pg.mkColor(self.ROI_TABLE.loc[table_row, 'color']))\r\n            roi.setPen(pen)\r\n            self.ROI_TABLE.loc[table_row, 'handle_ROI_contour'].setPen(pen)\r\n            # Disable interaction with ROI\r\n            roi.allowed_interaction = True\r\n            roi.translatable = True\r\n\r\n        else:\r\n            # If trace was shown\r\n            if self.ROI_TABLE.loc[table_row, 'show_trace']:\r\n                # Hide trace\r\n                handle_trace = self.ROI_TABLE.loc[table_row, 'handle_trace']\r\n                self.trace_viewbox.removeItem(handle_trace)\r\n                self.ROI_TABLE.loc[table_row, 'handle_trace'] = None\r\n                self.ROI_TABLE.loc[table_row, 'show_trace'] = False\r\n            # Change style of ROI in overlays\r\n            pen = roi.pen\r\n            pen.setStyle(QtCore.Qt.CustomDashLine)\r\n            pen.setDashPattern([1, 3])\r\n            pen.setColor(pg.mkColor(255, 255, 0))\r\n            roi.setPen(pen)\r\n            self.ROI_TABLE.loc[table_row, 'handle_ROI_contour'].setPen(pen)\r\n            # Disable interaction with ROI\r\n            roi.allowed_interaction = False\r\n            roi.translatable = False\r\n\r\n\r\n    def callback_remove_ROI(self, roi, log_outcome=True):\r\n        # Disconnect callbacks\r\n        roi.sigRegionChanged.disconnect()\r\n        roi.sigRemoveRequested.disconnect()\r\n        roi.sigClicked.disconnect()\r\n\r\n        # Get row in table where this ROI is stored\r\n        table_row = list(self.ROI_TABLE[self.ROI_TABLE['id'] == roi.ROI_id].index.values)\r\n        if len(table_row) > 0:\r\n            table_row = table_row[0]\r\n        else:\r\n            return\r\n\r\n        # If this one was the selected ROI, remove it from the inspection view\r\n        if roi is self.selected_ROI:\r\n            self.ROI_view.clear()\r\n            self.color_ROI_view_border(color=list())\r\n            self.selected_ROI = None\r\n        # Delete contour from frame plot\r\n        self.frame_image_view.removeItem(self.ROI_TABLE.at[table_row, 'handle_ROI_contour'])\r\n        # Delete trace\r\n        self.trace_viewbox.removeItem(self.ROI_TABLE.loc[table_row, 'handle_trace'])\r\n\r\n        # Delete handle from average view\r\n        self.average_image_viewbox.removeItem(roi)\r\n        # Remove row from table\r\n        self.ROI_TABLE.drop(table_row, inplace=True)\r\n        self.ROI_TABLE.reset_index(drop=True, inplace=True)\r\n        # Toggle the button that allows the user to translate the entire field of view\r\n        n_ROIs = self.ROI_TABLE.shape[0]\r\n        self.buttons.translation_ROI.setEnabled(n_ROIs > 0)\r\n        # Log outcome\r\n        if log_outcome:\r\n            log('Deleted ROI #%i' % roi.ROI_id)\r\n\r\n\r\n    def callback_click_ROI(self, roi):\r\n        # Toggle ROI visibility\r\n        if self.toggling_ROI_visibility:\r\n            self.toggle_ROI_visibility(roi, force=None)\r\n            return\r\n        # Store this ROI in memory to be used later\r\n        self.selected_ROI = roi\r\n        # If this ROI is of type 'fill', toggle the slider tool\r\n        table_row = self.ROI_TABLE[self.ROI_TABLE['id'] == self.selected_ROI.ROI_id].index.values[0]\r\n        ROI_type = self.ROI_TABLE.loc[table_row, 'type']\r\n        # Toggle flood tolerance slider\r\n        if ROI_type == 'fill':\r\n            self.slider.blockSignals(True)\r\n            # Restore last value of flood tolerance\r\n            flood_tolerance = self.ROI_TABLE.loc[table_row, 'flood_tolerance']\r\n            self.slider.setValue(flood_tolerance * 10)\r\n            self.slider_label.setText('%.1f' % flood_tolerance)\r\n            self.slider.blockSignals(False)\r\n        self.toggle_slider_flood_tolerance(ROI_type == 'fill')\r\n\r\n        # Update visibility trace\r\n        self.callback_update_visibility_traces(from_button=False)\r\n        # Update GUI\r\n        self.update_trace_zvalue()\r\n\r\n\r\n    def ROI_add_context_menu(self, roi):\r\n        # Create submenu\r\n        roi.submenu = QtWidgets.QMenu('Change color')\r\n        roi.menu.addMenu(roi.submenu)\r\n        # Add actions\r\n        for idx, color in enumerate(self.COLORS):\r\n            # Create action and set its color\r\n            action = QtWidgets.QWidgetAction(roi.submenu)\r\n            label = QtWidgets.QLabel(' ' * 20)\r\n            label.setFixedHeight(30)\r\n            # Set background color\r\n            stylesheet = 'background-color: rgb(%i, %i, %i); ' % color\r\n            if idx != 0:\r\n                stylesheet += 'border-top: 2px solid white; '\r\n            if idx != len(self.COLORS)-1:\r\n                stylesheet += 'border-bottom: 2px solid white; '\r\n            label.setStyleSheet(stylesheet)\r\n            action.setDefaultWidget(label)\r\n            action.triggered.connect(partial(self.ROI_change_color, roi, idx))\r\n            roi.submenu.addAction(action)\r\n\r\n\r\n    def ROI_change_color(self, roi, color_idx):\r\n        # Update ROI color only if it is different\r\n        current_ROI_color = self.ROI_TABLE.loc[self.ROI_TABLE['id'] == roi.ROI_id, 'color'].values[0]\r\n        selected_color = self.COLORS[color_idx]\r\n        if not current_ROI_color == selected_color:\r\n            # Update color in memory\r\n            self.ROI_TABLE.loc[self.ROI_TABLE['id'] == roi.ROI_id, 'color'] = [selected_color]\r\n            # Make pen\r\n            pen = pg.mkPen(selected_color, width=GUI_default['ROI_linewidth_thick'])\r\n            # Update color of ROIs\r\n            roi.setPen(pen)\r\n            self.ROI_TABLE.loc[self.ROI_TABLE['id'] == roi.ROI_id, 'handle_ROI_contour'].values[0].setPen(pen)\r\n            # Update color of trace\r\n            handle_trace = self.ROI_TABLE.loc[self.ROI_TABLE['id'] == roi.ROI_id, 'handle_trace'].values[0]\r\n            if handle_trace is not None:\r\n                pen = pg.mkPen(color=selected_color)\r\n                handle_trace.setPen(pen)\r\n            # Select this ROI\r\n            self.selected_ROI = roi\r\n            # Update ROI inspection view\r\n            self.callback_update_zoom_ROI(roi, update_trace=True, update_ROI_contour=False)\r\n\r\n\r\n    def make_ROI_from_point(self, xy_point):\r\n        # Initialize local variables\r\n        image_hull = None\r\n\r\n        # Round points\r\n        xy_coords = np.round(np.array(xy_point)).astype(int).ravel()\r\n        # Get currently shown image\r\n        img = self.compute_frames_projection(return_image=True)\r\n        img[np.isnan(img)] = 0\r\n        # Normalize image to [0-100] range\r\n        image = img / np.nanmax(img) * 100.\r\n        # Filter image and fill it in up to a certain tolerance to create a mask.\r\n        # Use the clicked point as seed point\r\n        x, y = np.indices(image.shape)\r\n        radius = int(np.ceil(GUI_default['max_n_diameter'] / 2))\r\n        sobel_mask = np.array((x - xy_coords[1]) ** 2 + (y - xy_coords[0]) ** 2 < radius ** 2)\r\n        image_sobel = filters.sobel(image, sobel_mask)\r\n\r\n        # Check how many pixels get marked and iteratively lower the tolerance\r\n        tolerance_value = self.flood_tolerance\r\n        did_succeed = False\r\n        while tolerance_value >= 0:\r\n            image_seg = flood(image_sobel, (xy_coords[1], xy_coords[0]), tolerance=tolerance_value)\r\n            # Use convex hull approximation to smooth contour\r\n            image_hull = convex_hull_image(image_seg).astype(np.uint8)\r\n            image_hull[~sobel_mask] = 0\r\n            # If the ROI occupies more than a certain area, it means that the tolerance\r\n            # is too high. In that case, lower it\r\n            if image_hull.sum() / sobel_mask.astype(np.uint8).sum() * 100 > GUI_default['max_area_percent']:\r\n                tolerance_value = tolerance_value - 1\r\n            else:\r\n                did_succeed = True\r\n                break\r\n        # Return if did not succeed\r\n        if not did_succeed:\r\n            log('Cannot identify region around the selected reference pixel. Either try another pixel, increase the contrast or increase the tolerance')\r\n            return list()\r\n\r\n        # Align value of GUI slider to whatever we have actually used for this ROI\r\n        else:\r\n            self.slider_update_GUI = False\r\n            self.flood_tolerance = tolerance_value\r\n            self.slider_update_GUI = True\r\n\r\n        # Detect contours in the mask\r\n        points = cv2.findContours(image_hull, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_TC89_L1)[1]\r\n        points = np.squeeze(points[0])\r\n\r\n        # Approximate curve\r\n        n_points = points.shape[0]\r\n        max_n_points = GUI_default['max_n_points']\r\n        epsilon = 0\r\n        new_points = points.copy()\r\n        while n_points >= max_n_points:\r\n            new_points = cv2.approxPolyDP(points, epsilon=epsilon, closed=True)\r\n            n_points = new_points.shape[0]\r\n            epsilon += .1\r\n        # Make 2D\r\n        points = np.squeeze(new_points)\r\n\r\n        return points\r\n\r\n\r\n    def callback_flood_tolerance_value_changed(self, new_value):\r\n        if self.current_action == '':\r\n            # Update slider's label\r\n            self.flood_tolerance = new_value / 10.\r\n            self.slider_label.setText('%.1f' % self.flood_tolerance)\r\n\r\n            # If no ROI is currently selected, return immediately\r\n            if self.selected_ROI is None:\r\n                return\r\n\r\n            # Get type of currently selected ROI\r\n            try:\r\n                table_row = self.ROI_TABLE[self.ROI_TABLE['id'] == self.selected_ROI.ROI_id].index.values[0]\r\n            except AttributeError:\r\n                return\r\n            ROI_type = self.ROI_TABLE.loc[table_row, 'type']\r\n            if ROI_type == 'fill':\r\n                points = self.make_ROI_from_point(self.ROI_TABLE.loc[table_row, 'reference_pixel'])\r\n                if len(points) < 3:  # Cannot close an area with less than 3 points\r\n                    return\r\n                # Temporarily stop updating trace on slider change\r\n                self.slider_update_GUI = False\r\n                # Update points\r\n                self.selected_ROI.setPoints(points, closed=True)\r\n                # Store new points\r\n                self.ROI_TABLE.loc[table_row, 'region'] = points\r\n                # Store current value of flood tolerance used to calculate these points\r\n                self.ROI_TABLE.loc[table_row, 'flood_tolerance'] = self.flood_tolerance\r\n                # Restore update of the GUI\r\n                self.slider_update_GUI = True\r\n\r\n\r\n    def callback_activate_translation_FOV(self, new_state):\r\n        # Enabling the tool\r\n        if new_state:\r\n            self.toggle_toolbar('off', because='translating_field_of_view')\r\n            # Make ROI that is as big as field of view\r\n            self.translation_ROI = ROI([0, 0], [self.PARAMETERS['frame_width'], self.PARAMETERS['frame_height']], removable=False, invisible=False)\r\n            self.translation_ROI.setZValue(0)\r\n            # Add rotation and scaling handles\r\n            self.translation_ROI.addRotateHandle([1, 1], center=[0.5, 0.5])\r\n            self.translation_ROI.addScaleHandle([0.5, 0], center=[0.5, 1])\r\n            self.translation_ROI.addScaleHandle([0.5, 1], center=[0.5, 0])\r\n            self.translation_ROI.addScaleHandle([0, 0.5], center=[1, 0.5])\r\n            self.translation_ROI.addScaleHandle([1, 0.5], center=[0, 0.5])\r\n            # Get last image and delete ImageItem\r\n            self.translation_image_levels = self.average_image_view.levels\r\n            self.translation_image = self.average_image_view.image.copy()\r\n            self.average_image_viewbox.removeItem(self.average_image_view)\r\n            # Assign current image to ROI\r\n            self.average_image_view = pg.ImageItem(self.translation_image)\r\n            self.average_image_viewbox.addItem(self.translation_ROI)\r\n            self.translation_ROI.setPos(0, 0, update=True, finish=True)\r\n            self.average_image_view.setParentItem(self.translation_ROI)\r\n            # Reassign image to histogram widget and set levels to what they were before\r\n            self.average_histogram.item.setImageItem(self.average_image_view)\r\n            self.average_image_view.setLevels(self.translation_image_levels)\r\n            self.callback_toggle_colormap(force=self.current_colormap)\r\n            # Connect callback\r\n            self.translation_ROI.sigRegionChanged.connect(self.callback_update_image_while_translating_FOV)\r\n            self.translation_ROI.sigRegionChanged.emit(self.translation_ROI)\r\n\r\n            # Clear other graphs\r\n            self.ROI_view.clear()\r\n            # Toggle internal flag\r\n            self.current_action = 'translating_FOV'\r\n\r\n        # Accepting translation\r\n        else:\r\n            self.callback_accept_translation_FOV()\r\n\r\n\r\n    def callback_accept_translation_FOV(self):\r\n        if self.current_action == 'translating_FOV' and not self.translation_ROI.isMoving:\r\n            # Toggle internal flag to forbid entering this section again before its end\r\n            self.current_action = ''\r\n            self.toggle_toolbar('on', because='translating_field_of_view')\r\n            # Disconnect callback\r\n            self.translation_ROI.sigRegionChanged.disconnect()\r\n            # Read translation_ROI state\r\n            scale, angle, offset = self.get_FOV_translation_state()\r\n\r\n            # Transform shown image\r\n            new_image, scaling_matrix, rotation_matrix, translation_matrix = transform_image_from_parameters(self.translation_image.copy(), scale, angle, offset, return_matrices=True)\r\n            # Get index where to save the transformation matrices\r\n            table_idx = self.TRANSFORMATION_MATRICES.shape[0]\r\n            # Store this index in the lookup table\r\n            [i.append(table_idx) for i in self.TRANSFORMATION_IDX[self.current_average_frame, 1]]\r\n            # Store parameters in memory\r\n            self.TRANSFORMATION_MATRICES.at[table_idx, 'scale'] = scaling_matrix\r\n            self.TRANSFORMATION_MATRICES.at[table_idx, 'rotation'] = rotation_matrix\r\n            self.TRANSFORMATION_MATRICES.at[table_idx, 'translation'] = translation_matrix\r\n\r\n            # Clear image and reset data into it\r\n            self.average_image_viewbox.removeItem(self.average_image_view)\r\n            self.average_image_viewbox.removeItem(self.translation_ROI)\r\n            self.average_image_view = pg.ImageItem(new_image)\r\n            self.average_image_view.setZValue(0)\r\n            self.average_image_viewbox.addItem(self.average_image_view)\r\n            # Reassign image to histogram widget and set levels to what they were before\r\n            self.average_histogram.item.setImageItem(self.average_image_view)\r\n            self.average_image_view.setLevels(self.translation_image_levels)\r\n\r\n            # Apply transformation to current frame, if it falls in current condition\r\n            ind, _ = self.frame_image_view.timeIndex(self.frame_image_view.timeLine)\r\n            condition_idx = self.frames_idx_array[ind]\r\n            if condition_idx in self.current_average_frame:\r\n                self.callback_transform_current_frame()\r\n\r\n            # Initialize position of each pixel and transform this grid\r\n            pixel_list = np.arange(self.PARAMETERS['n_pixels'], dtype=int)\r\n            pixel_list = pixel_list.reshape(self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width']).transpose().ravel()\r\n            pixel_grid = np.reshape(pixel_list, (self.PARAMETERS['frame_width'], self.PARAMETERS['frame_height']))\r\n            pixel_grid = transform_image_from_parameters(pixel_grid, scale, -angle, offset[::-1])\r\n            # Round pixel value to nearest integer\r\n            pixel_grid = np.round(pixel_grid)\r\n            # Replace original pixel positions with these ones\r\n            self.MAPPING_TABLE[self.current_average_frame, :] = pixel_grid.transpose().ravel()\r\n            self.modified_MAPPING[self.current_average_frame] = True\r\n            # Update shown traces\r\n            table_rows = self.ROI_TABLE['show_trace'].index.values\r\n            for roi in self.ROI_TABLE.loc[table_rows, 'handle_ROI'].tolist():\r\n                self.callback_update_zoom_ROI(roi, update_trace=True, update_ROI_contour=False)\r\n\r\n            # Toggle internal flags\r\n            self.translation_ROI = None\r\n            self.translation_image = None\r\n            self.temporary_MAPPING_TABLE = np.array([])\r\n            self.translation_image_levels = None\r\n            # Toggle GUI button\r\n            self.buttons.translation_ROI.setChecked(False)\r\n            # Make sure colormap is correct\r\n            self.callback_toggle_colormap(force=self.current_colormap)\r\n            # Update table\r\n            self.update_table_condition_names()\r\n\r\n\r\n    def callback_transform_current_frame(self, direction=None):\r\n        if direction is not None:\r\n            self.frame_image_view.setCurrentIndex(self.frame_image_view.currentIndex + direction*2)\r\n        # Get index of condition shown\r\n        condition_idx = self.frames_idx_array[self.frame_image_view.currentIndex]\r\n        # Check whether this condition need to be transformed\r\n        T = self.TRANSFORMATION_IDX[self.TRANSFORMATION_IDX[:, 0] == condition_idx, 1][0]\r\n        if len(T) > 0:\r\n            # Get image currently shown\r\n            frame = self.frame_image_view.image[self.frame_image_view.currentIndex, :, :]\r\n\r\n            # Apply transformations one after the other\r\n            for t_idx in T:\r\n                # Get matrices\r\n                scale = self.TRANSFORMATION_MATRICES.loc[t_idx, 'scale']\r\n                rotation = self.TRANSFORMATION_MATRICES.loc[t_idx, 'rotation']\r\n                translation = self.TRANSFORMATION_MATRICES.loc[t_idx, 'translation']\r\n                # Apply them\r\n                frame = transform_image_from_matrices(frame, scale, rotation, translation)\r\n\r\n            # Update image\r\n            self.frame_image_view.imageItem.updateImage(frame.T, autoHistogramRange=self.auto_adjust_histograms)\r\n\r\n\r\n    def get_FOV_translation_state(self):\r\n        roi = self.translation_ROI\r\n        # Read ROI state (scale and rotation)\r\n        state = roi.state\r\n        scale = np.array([state['size'].x() / self.PARAMETERS['frame_width'], state['size'].y() / self.PARAMETERS['frame_height']])\r\n        angle = state['angle']\r\n        # Calculate the offset from relative position of handles\r\n        handles = roi.getHandles()[1:]  # exclude the first one because it is the rotation handle\r\n        x = np.array([h.viewPos().x() for h in handles])\r\n        y = np.array([h.viewPos().y() for h in handles])\r\n        center_ROI = [x.mean(), y.mean()]\r\n        offset = np.array([center_ROI[0] - self.PARAMETERS['frame_width'] / 2., center_ROI[1] - self.PARAMETERS['frame_height'] / 2.])\r\n\t\t# Invert offset coordinates because images are row-major\r\n        offset = np.array([offset[1], offset[0]])\r\n        return scale, angle, offset\r\n\r\n\r\n    def get_translated_trace_segments(self, conditions_idx, ROI_pixels, from_temporary):\r\n        # Expand indices of conditions\r\n        condition_duration = self.frames_idx[conditions_idx, 1] - (self.frames_idx[conditions_idx, 0] - 1)\r\n        modified_frames_idx = expand_indices(self.frames_idx[conditions_idx, 0] - 1, self.frames_idx[conditions_idx, 1])\r\n        # Allocate variable to keep new luminescence values\r\n        L_modified = np.nan * np.zeros(shape=(ROI_pixels.shape[0], modified_frames_idx.shape[0]))\r\n        # Get new values for each pixel\r\n        for idx, pixel in enumerate(ROI_pixels):\r\n            if from_temporary:\r\n                new_pixel = self.temporary_MAPPING_TABLE[pixel]\r\n            else:\r\n                new_pixel = self.MAPPING_TABLE[conditions_idx, pixel]\r\n            # Mark which pixels cannot be tracked along all frames\r\n            bad_pixels = np.isnan(new_pixel)\r\n            # If all pixels are bad, skip this pixel\r\n            if np.all(bad_pixels):\r\n                continue\r\n            # Temporarily mark bad pixels with -1\r\n            if isinstance(new_pixel, np.ndarray):\r\n                new_pixel[bad_pixels] = -1\r\n            # Convert to integer\r\n            new_pixel = new_pixel.astype(int)\r\n            # Unfold pixel value in time\r\n            if from_temporary:\r\n                pixel_time = np.ones_like(modified_frames_idx) * new_pixel\r\n            else:\r\n                pixel_time = np.hstack([np.ones(condition_duration[ii], dtype=int) * new_pixel[ii] for ii in range(len(new_pixel))])\r\n            # Get luminescence values\r\n            L = self.data_time_first[pixel_time, modified_frames_idx]\r\n            if not from_temporary:\r\n                # Restore NaNs in signal\r\n                L = L.copy()\r\n                L[pixel_time == -1] = np.nan\r\n            L_modified[idx, :] = L\r\n\r\n        # Compute the mean across pixels\r\n        if self.current_operation_type == 'mean':\r\n            L_modified = np.nanmean(L_modified, axis=0)\r\n        elif self.current_operation_type == 'max':\r\n            L_modified = np.nanmax(L_modified, axis=0)\r\n\r\n        return L_modified, modified_frames_idx\r\n\r\n\r\n    def update_table_condition_names(self):\r\n        # Get indices of modified frames\r\n        for frame_idx in range(self.n_conditions):\r\n            # Get name of condition\r\n            cond_name = self.PARAMETERS['condition_names'][frame_idx]\r\n            # Get number of modifications on this frame\r\n            n_changes = len(self.TRANSFORMATION_IDX[frame_idx, 1])\r\n            # Make suffix to condition name\r\n            if n_changes > 0:\r\n                cond_name += ' ' + '*' * n_changes\r\n            # Update name of condition on table\r\n            self.table_conditions.item(frame_idx, 0).setText(cond_name)\r\n\r\n\r\n    ############################################################################\r\n    # Mouse and keyboard interaction\r\n    ############################################################################\r\n    def callback_mouse_moved(self, event):\r\n        if self.current_action == 'drawing_ROI' or self.toggling_ROI_visibility:\r\n            pos = QtCore.QPoint(event.x(), event.y())\r\n            if self.average_image_viewbox.rect().contains(pos):\r\n                mousePoint = self.average_image_viewbox.mapSceneToView(pos)\r\n                self.crosshair[0].setPos(mousePoint.x())\r\n                self.crosshair[1].setPos(mousePoint.y())\r\n\r\n\r\n    def callback_mouse_clicked(self, event):\r\n        # Check whether user is drawing an ROI\r\n        if self.current_action == 'drawing_ROI':\r\n            # Get click position and store it in memory\r\n            pos = event.pos()\r\n            mousePoint = self.average_image_viewbox.mapSceneToView(pos)\r\n            mousePoint = np.array([mousePoint.x(), mousePoint.y()])\r\n            # Ignore click if out of bounds\r\n            if np.any(mousePoint<0) or mousePoint[0]>self.PARAMETERS['frame_width'] or mousePoint[1]>self.PARAMETERS['frame_height']:\r\n                event.ignore()\r\n                return\r\n            else:\r\n                event.accept()\r\n\r\n            # If user pressed the left mouse button\r\n            if event.buttons() == QtCore.Qt.LeftButton:\r\n                # Store data in memory\r\n                self.last_ROI_coordinates.append(mousePoint)\r\n\r\n                # Initialize plot item if not present\r\n                if self.last_ROI_coordinates_handle is None:\r\n                    brush = pg.mkBrush(self.next_ROI_color)\r\n                    self.last_ROI_coordinates_brushes.append(brush)\r\n                    self.last_ROI_coordinates_handle = pg.PlotDataItem(x=[mousePoint[0]], y=[mousePoint[1]], symbol='o', symbolBrush=brush, symbolSize=10, pxMode=True)\r\n                    self.average_image_viewbox.addItem(self.last_ROI_coordinates_handle)\r\n\r\n                else:  # Add point\r\n                    # Set whether new point should have a different color\r\n                    if self.selected_ROI_type == 'fill':\r\n                        self.get_next_ROI_color()\r\n                        brush = pg.mkBrush(self.next_ROI_color)\r\n                        self.last_ROI_coordinates_brushes.append(brush)\r\n                        self.last_ROI_coordinates_handle.opts['symbolBrush'] = self.last_ROI_coordinates_brushes\r\n\r\n                    # Update data\r\n                    self.last_ROI_coordinates_handle.setData(np.array(self.last_ROI_coordinates))\r\n\r\n                    # Set whether line connecting points should be visible\r\n                    if self.selected_ROI_type == 'fill':\r\n                        self.last_ROI_coordinates_handle.curve.hide()\r\n                    else:\r\n                        self.last_ROI_coordinates_handle.curve.show()\r\n\r\n                # Check whether it's possible to activate the button to make the ROI\r\n                n_points = len(self.last_ROI_coordinates)\r\n                if (self.selected_ROI_type == 'polygon' and n_points >= 3) or (self.selected_ROI_type == 'fill' and n_points >= 1):\r\n                    self.buttons.draw_ROI.setStyleSheet(str('background-color: rgb%s' % str(tuple(np.array(GUI_default['icon_background']['go'], dtype=float)*255))))\r\n                else:\r\n                    self.buttons.draw_ROI.setStyleSheet(str('background-color: rgb%s' % str(tuple(np.array(GUI_default['icon_background']['no_go'], dtype=float) * 255))))\r\n\r\n                # Automatically accept drawing the ROI\r\n                if self.selected_ROI_type == 'fill' and n_points >= 1:\r\n                    self.callback_draw_ROI()\r\n\r\n\r\n    def callback_timeline_frames(self, from_plot):\r\n        if not self.updating_timeline_position:\r\n            # Initialize variables\r\n            time = None\r\n            ind = None\r\n            # Set internal flag\r\n            self.updating_timeline_position = True\r\n            # Get position of timeline\r\n            if from_plot == 'frame':\r\n                ind, time = self.frame_image_view.timeIndex(self.frame_image_view.timeLine)\r\n                time = time / GUI_default['frame_rate']\r\n            elif from_plot == 'trace':\r\n                time = self.trace_time_mark.getXPos()\r\n                ind = np.argmin(np.abs(self.time - time))\r\n            # Abort if timeline has been pulled outside range\r\n            if time < self.time[0] or time >= self.time_range[1]:\r\n                self.updating_timeline_position = False\r\n                return\r\n\r\n            # Set position of other timeline\r\n            if from_plot == 'frame':\r\n                self.trace_time_mark.setValue(time)\r\n            elif from_plot == 'trace':\r\n                self.frame_image_view.timeLine.setValue(ind)\r\n            # Update image\r\n            self.frame_image_view.currentIndex = ind\r\n            self.frame_image_view.updateImage()\r\n            self.callback_transform_current_frame()\r\n            # Update title\r\n            self.image_views_title[1].setPlainText(self.PARAMETERS['condition_names'][self.frames_idx_array[ind]])\r\n            # Update visible range\r\n            if not self.histograms_linked and self.auto_adjust_histograms:\r\n                frame = self.frame_image_view.image[self.frame_image_view.currentIndex, :, :].ravel()\r\n                levels = np.percentile(frame[~np.isnan(frame)], q=[1, 99])\r\n                self.frame_image_view.getHistogramWidget().item.setLevels(levels[0], levels[1])\r\n                self.frame_image_view.getHistogramWidget().item.autoHistogramRange()\r\n\r\n            # Update other view\r\n            if self.views_linked:\r\n                condition = self.frames_idx_array[ind]\r\n                # Check whether we have to update the image\r\n                if len(self.current_average_frame) == 1 and self.current_average_frame[0] == condition:\r\n                    self.updating_timeline_position = False\r\n                    return\r\n                self.current_average_frame = [condition]\r\n                self.image_views_title[0].setPlainText(self.PARAMETERS['condition_names'][self.frames_idx_array[self.frames_idx[self.current_average_frame[0], 0]]])\r\n                # Update image\r\n                self.compute_frames_projection()\r\n                # Update image of ROI\r\n                if self.selected_ROI is not None:\r\n                    self.callback_update_zoom_ROI(self.selected_ROI, update_trace=False, update_ROI_contour=False)\r\n                # Update selection in table\r\n                self.table_conditions.selectRow(condition)\r\n                # Highlight frames in this condition\r\n                self.make_region(self.frames_idx[self.current_average_frame, :])\r\n\r\n            # Limit range in trace viewbox\r\n            if self.trace_anchored and from_plot == 'frame':\r\n                # Get selected frames\r\n                selected_frames = self.frames_idx[self.current_average_frame, :].ravel()\r\n                selected_frames_range = [selected_frames.min(), selected_frames.max()]\r\n                self.trace_viewbox.setRange(xRange=selected_frames_range, padding=0, disableAutoRange=False)\r\n\r\n            # Reset internal flag\r\n            self.updating_timeline_position = False\r\n\r\n\r\n    def callback_reset_zoom(self, where):\r\n        if isinstance(where, str):\r\n            where = [where]\r\n        if len(where) == 1 and where[0] == 'all':\r\n            where = ['average','frame','histograms','ROI','trace']\r\n\r\n        # Condition selection\r\n        if 'average' in where:\r\n            self.average_image_viewbox.autoRange()\r\n        # Frame selection\r\n        if 'frame' in where:\r\n            self.frame_image_view.view.autoRange()\r\n        # Histograms\r\n        if 'histograms' in where and self.auto_adjust_histograms:\r\n            # Average image\r\n            image = self.average_image_view.image\r\n            image = image[~np.isnan(image)]\r\n            levels = np.percentile(image.ravel(), q=[1, 99])\r\n            self.average_histogram.item.setLevels(levels[0], levels[1])\r\n            self.average_histogram.item.autoHistogramRange()\r\n            # Single-frame\r\n            timeline = self.frame_image_view.timeLine\r\n            ind, _ = self.frame_image_view.timeIndex(timeline)\r\n            image = self.frame_image_view.image[ind, :, :]\r\n            image = image[~np.isnan(image)]\r\n            levels = np.percentile(image.ravel(), q=[1, 99])\r\n            self.frame_image_view.getHistogramWidget().item.setLevels(levels[0], levels[1])\r\n            self.frame_image_view.getHistogramWidget().item.autoHistogramRange()\r\n        # ROI inspection\r\n        if 'ROI' in where:\r\n            self.ROI_viewbox.autoRange()\r\n        # Trace\r\n        if 'trace' in where:\r\n            self.trace_viewbox.autoRange()\r\n            self.trace_viewbox.enableAutoRange(x=False, y=True)\r\n            self.trace_viewbox.setAutoVisible(x=False, y=True)\r\n\r\n\r\n    def callback_table_selection(self, what):\r\n        if self.table_conditions.allowed_interaction and not self.updating_timeline_position:\r\n            # Initialize variables\r\n            items = None\r\n            selected_sessions = None\r\n\r\n            # This function should not get triggered recursively\r\n            self.table_sessions.allowed_interaction = False\r\n            self.table_conditions.allowed_interaction = False\r\n\r\n            # Get selected items\r\n            if what == 'session':\r\n                items = self.table_sessions.selectedItems()\r\n            elif what == 'condition':\r\n                items = self.table_conditions.selectedItems()\r\n            # Get index of this elements\r\n            conditions = [ii.row() for ii in items]\r\n            if len(conditions) < 1:\r\n                return\r\n\r\n            # If user selected an entire session, find condition frames corresponding to it\r\n            if what == 'session':\r\n                selected_sessions = list(conditions)\r\n                conditions = np.where(np.in1d(self.sessions_idx, conditions))[0]\r\n\r\n            # Adapt other table\r\n            if what == 'session':  # Select all conditions in this session\r\n                self.table_conditions.clearSelection()\r\n                previous_selection_mode = self.table_conditions.selectionMode()\r\n                self.table_conditions.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)\r\n                [self.table_conditions.selectRow(cond) for cond in conditions]\r\n                self.table_conditions.setSelectionMode(previous_selection_mode)\r\n            elif what == 'condition':  # Deselect all sessions for clarity\r\n                self.table_sessions.clearSelection()\r\n\r\n            # Store range in memory\r\n            self.current_average_frame = sorted(conditions)\r\n\r\n            # Highlight frames\r\n            if len(conditions) == 1:\r\n                self.make_region(self.frames_idx[self.current_average_frame, :])\r\n            else:\r\n                # Highlight frames in timeline\r\n                frames_idx = np.hstack([np.arange(start=self.frames_idx[cond, 0], stop=self.frames_idx[cond, 1]+1) for cond in conditions])\r\n                regions = idx2range(frames_idx)[:, :2]\r\n                self.make_region(regions)\r\n\r\n            # Update title\r\n            title = ''\r\n            if what == 'session':\r\n                if len(selected_sessions) == 1:\r\n                    title = 'session %i' % (selected_sessions[0] + 1)\r\n            elif what == 'condition':\r\n                if len(conditions) == 1:\r\n                    title = self.PARAMETERS['condition_names'][self.frames_idx_array[self.frames_idx[self.current_average_frame[0], 0]]]\r\n            self.image_views_title[0].setPlainText(title)\r\n\r\n            # Update image\r\n            self.compute_frames_projection()\r\n\r\n            # Update image of ROI\r\n            if self.selected_ROI is not None:\r\n                self.callback_update_zoom_ROI(self.selected_ROI, update_trace=False, update_ROI_contour=False)\r\n\r\n            # Get selected frames\r\n            selected_frames = self.frames_idx[self.current_average_frame, :].ravel()\r\n            selected_frames_range = [selected_frames.min(), selected_frames.max()]\r\n            # Limit range in trace viewbox\r\n            # if self.trace_anchored:\r\n            #     self.trace_viewbox.setRange(xRange=selected_frames_range, padding=0, disableAutoRange=False)\r\n                # Show stimulus profile, if any\r\n                # if self.is_stimulus_evoked:\r\n                #     # Delete previous stimulus profiles\r\n                #     if self.stimulus_profile is not None:\r\n                #         self.trace_viewbox.removeItem(self.stimulus_profile)\r\n                #     # Get number of traces currently shown\r\n                #     n_shown_traces = np.where(self.ROI_TABLE['show_trace'] == True)[0].shape[0]\r\n                #     # Show stimulus only if one trial selected and at least one trace shown\r\n                #     if len(self.current_average_frame) == 1 and n_shown_traces >= 1:\r\n                #         # Get index of stimulus presented (and respect python's 0-indexing)\r\n                #         stimulus_idx = self.PARAMETERS['condition_has_stimulus'][self.current_average_frame[0]] - 1\r\n                #         stimulus_profile = self.PARAMETERS['stimuli'][stimulus_idx, 1]\r\n                #         # Make sure visible range starts from 0\r\n                #         visible_range = list()\r\n                #         visible_traces = self.ROI_TABLE.loc[self.ROI_TABLE['show_trace'] == True, 'handle_trace'].values\r\n                #         for t in visible_traces:\r\n                #             visible_range.append(t.yData[selected_frames_range[0]:selected_frames_range[1]].max())\r\n                #         # Make sure bottom is 0\r\n                #         visible_range = [0, max(visible_range)]\r\n                #         self.trace_viewbox.setRange(yRange=visible_range, disableAutoRange=False)\r\n                #         # Scale stimulus profile to span entire visible range\r\n                #         stimulus_profile = stimulus_profile * visible_range[1]\r\n                #         # Draw new stimulus profile\r\n                #         self.stimulus_profile = pg.PlotCurveItem(clickable=False)\r\n                #         self.stimulus_profile.setData(x=np.arange(selected_frames_range[0], selected_frames_range[1]+1), y=stimulus_profile)\r\n                #         self.trace_viewbox.addItem(self.stimulus_profile)\r\n                #         self.stimulus_profile.setPen(GUI_default['stimulus_profile_pen'][self.current_colormap])\r\n                #         self.stimulus_profile.setZValue(0)\r\n\r\n            # Update timelines\r\n            if self.views_linked:\r\n                # Toggle internal flag\r\n                self.updating_timeline_position = True\r\n                # Update trace view\r\n                self.trace_time_mark.setValue(selected_frames_range[0])\r\n                self.frame_image_view.timeLine.setValue(selected_frames_range[0])\r\n                # Update image and title\r\n                self.callback_transform_current_frame()\r\n                self.image_views_title[1].setPlainText(self.PARAMETERS['condition_names'][self.frames_idx_array[selected_frames_range[0]]])\r\n                # Update visible range\r\n                if self.auto_adjust_histograms:\r\n                    frame = self.frame_image_view.image[self.frame_image_view.currentIndex, :, :].ravel()\r\n                    levels = np.percentile(frame[~np.isnan(frame)], q=[1, 99])\r\n                    self.frame_image_view.getHistogramWidget().item.setLevels(levels[0], levels[1])\r\n                    self.frame_image_view.getHistogramWidget().item.autoHistogramRange()\r\n                # Toggle internal flag\r\n                self.updating_timeline_position = False\r\n\r\n            # Re-enable interaction\r\n            self.table_sessions.allowed_interaction = True\r\n            self.table_conditions.allowed_interaction = True\r\n\r\n\r\n    def callback_scroll_average_frame(self, where):\r\n        new_frame = 0\r\n        # Get index of last selected frame\r\n        old_frame = self.current_average_frame[-1]\r\n        # Update index\r\n        if where == 'up':\r\n            new_frame = max(0, old_frame - 1)\r\n        elif where == 'down':\r\n            new_frame = min(self.n_conditions, old_frame + 1)\r\n        # Update selection in table\r\n        self.table_conditions.selectRow(new_frame)\r\n\r\n\r\n    def callback_update_image_while_translating_FOV(self, roi):\r\n        # Get scaling factor\r\n        state = roi.state\r\n        scale = np.array([state['size'].x() / self.PARAMETERS['frame_width'], state['size'].y() / self.PARAMETERS['frame_height']])\r\n        # Get image and scale it\r\n        if np.any(scale != 1):\r\n            rect = roi.boundingRect()\r\n            self.average_image_view.setRect(rect)\r\n        # Read translation_ROI state\r\n        scale, angle, offset = self.get_FOV_translation_state()\r\n        # Initialize position of each pixel and transform this grid\r\n        pixel_list = np.arange(self.PARAMETERS['n_pixels'], dtype=int)\r\n        pixel_list = pixel_list.reshape(self.PARAMETERS['frame_height'], self.PARAMETERS['frame_width']).transpose().ravel()\r\n        pixel_grid = np.reshape(pixel_list, (self.PARAMETERS['frame_width'], self.PARAMETERS['frame_height']))\r\n        pixel_grid = transform_image_from_parameters(pixel_grid, scale, -angle, offset[::-1])\r\n        # Round pixel value to nearest integer\r\n        pixel_grid = np.round(pixel_grid)\r\n        # Replace original pixel positions with these ones\r\n        self.temporary_MAPPING_TABLE = pixel_grid.transpose().ravel()\r\n\r\n        # Update GUI data\r\n        table_rows = self.ROI_TABLE['show_trace'].index.values\r\n        for roi in self.ROI_TABLE.loc[table_rows, 'handle_ROI'].tolist():\r\n            self.callback_update_zoom_ROI(roi, update_trace=True, update_ROI_contour=False)\r\n\r\n"""
src/calipy/general_configs.py,0,"b""# Graphical packages\nfrom PyQt5 import QtGui\nfrom third_party import pyqtgraph as pg\n\n# Local repository\nfrom calipy.utils.icons import histogram_locked, histogram_unlocked, trace_locked, trace_unlocked, colormap, view_unlocked, view_locked, magnifying_glass, bucket, move, polygon\n\n\n################################################################################\n# This dictionary contains the default values for graphical elements.\ndefault = dict()\n\n# Pre-processing options\ndefault['frame_rate'] = 30\ndefault['correlation_time_smoothing_window'] = 1\n\n# GUI options\ndefault['colormap_index'] = 1  # 0 = black on white, 1 = white on black\ndefault['all_projection_types'] = ['max', 'mean', 'median', 'standard deviation']\ndefault['projection_type'] = 'max'\ndefault['average_type'] = 'correlation'\ndefault['max_n_visible_ROI_traces'] = 0\n\ndefault['ROI_linewidth_thick'] = 2\ndefault['text_color_dark'] = 'w'\n\n# Font\ndefault['font'] = QtGui.QFont()\ndefault['font'].setFamily('Lucida')\ndefault['font'].setPointSize(12)\ndefault['font'].setBold(False)\n\ndefault['font_buttons'] = QtGui.QFont()\ndefault['font_buttons'].setFamily('Lucida')\ndefault['font_buttons'].setPointSize(14)\ndefault['font_buttons'].setBold(False)\n\ndefault['font_editors'] = QtGui.QFont()\ndefault['font_editors'].setFamily('Lucida')\ndefault['font_editors'].setPointSize(14)\ndefault['font_editors'].setBold(False)\n\ndefault['font_titles'] = QtGui.QFont()\ndefault['font_titles'].setFamily('Lucida')\ndefault['font_titles'].setPointSize(16)\ndefault['font_titles'].setBold(True)\n\ndefault['font_actions'] = QtGui.QFont()\ndefault['font_actions'].setFamily('Lucida')\ndefault['font_actions'].setPointSize(14)\ndefault['font_actions'].setBold(False)\n\ndefault['min_button_height'] = 50\ndefault['max_button_width'] = 500\n\n\ndefault['ROI_type'] = 'polygon'\ndefault['flood_tolerance'] = 10\ndefault['max_n_points'] = 15\ndefault['max_n_diameter'] = 50\ndefault['max_area_percent'] = 50\ndefault['icons'] = dict()\ndefault['icons']['toggle_colormap'] = colormap\ndefault['icons']['link_views'] = (view_unlocked, view_locked)\ndefault['icons']['visibility_ROI'] = u'\\U0001F441'\ndefault['icons']['zoom'] = magnifying_glass\ndefault['icons']['ROI_fill'] = bucket\ndefault['icons']['ROI_polygon'] = polygon\ndefault['icons']['link_histograms'] = (histogram_unlocked, histogram_locked)\ndefault['icons']['translation_ROI'] = (move, move)\ndefault['icons']['anchor_trace'] = (trace_unlocked, trace_locked)\n\ndefault['icons_kind'] = dict()\ndefault['icons_kind']['toggle_colormap'] = 'icon'\ndefault['icons_kind']['visibility_ROI'] = 'text'\ndefault['icons_kind']['zoom'] = 'icon'\ndefault['icons_kind']['ROI_fill'] = 'icon'\ndefault['icons_kind']['ROI_polygon'] = 'icon'\ndefault['icons_kind']['link_histograms'] = 'icon'\ndefault['icons_kind']['translation_ROI'] = 'icon'\ndefault['icons_kind']['link_views'] = 'icon'\ndefault['icons_kind']['anchor_trace'] = 'icon'\n\ndefault['icon_background'] = dict()\ndefault['icon_background']['go'] = (.5, 1., 0.)\ndefault['icon_background']['no_go'] = (1., .39, .28)\n\n\n# Make brush for selection regions\ndefault['region_colors_dark'] = pg.mkBrush(color=(255, 99, 71))\ndefault['region_colors_light'] = pg.mkBrush(color=tuple([int(255 * .9)] * 3))\n# Make pen for stimulus profile, if any\ndefault['stimulus_profile_pen'] = [pg.mkPen((255, 255, 255)), pg.mkPen((0, 0, 0))]\n\ndefault['ROI_handle_pen'] = pg.mkPen(None)\ndefault['ROI_highlighted_segment_pen'] = pg.mkPen((255, 0, 0), width=4)\ndefault['ROI_handle_size'] = 7\n"""
src/third_party/__init__.py,0,b''
src/calipy/utils/Array_operations.py,61,"b'# Numerical packages\nimport re\n\nimport cv2\nimport numpy as np\n\n\ndef temporal_smooth(stack_in, window_size, add_last_frame=True):\n    """"""\n\n    :param stack_in:\n    :param window_size:\n    :param add_last_frame:\n    :return:\n    """"""\n    # Get shape of data\n    frame_height, frame_width, n_frames = stack_in.shape\n\n    # Check inputs\n    if window_size > n_frames:\n        window_size = n_frames\n\n    # Pre-allocate output variable\n    stack_out = np.zeros((frame_height, frame_width, n_frames), dtype=np.find_common_type((np.float32, stack_in.dtype), []))\n    # Loop until the frame before the last\n    for i_frame in range(n_frames - 1):\n        # Get index of first and last frame\n        start_frame = i_frame\n        end_frame = min([start_frame + window_size, n_frames]) + 1\n        # Compute mean\n        stack_out[:, :, i_frame] = np.nanmean(stack_in[:, :, start_frame:end_frame].astype(np.float32), axis=-1)\n\n    # Add last frame\n    if add_last_frame:\n        stack_out[:, :, -1] = stack_in[:, :, -1].copy()\n    else:\n        stack_out = stack_out[:, :, :-1]\n\n    return stack_out\n\n\ndef cross_correlate_image(data, window_size=1, n_frames_per_image=None, squeeze=True):\n    """"""\n\n    :param data:\n    :param window_size:\n    :param n_frames_per_image:\n    :param squeeze:\n    :return:\n    """"""\n    # Get shape of data\n    frame_height, frame_width, n_frames = data.shape\n\n    # Adjust user input\n    if n_frames_per_image is None:\n        n_frames_per_image = n_frames\n\n    # Get number of chunks\n    n_chunks = int(np.ceil(n_frames / n_frames_per_image))\n\n    # Allocate output array\n    CCimage = np.zeros((frame_height, frame_width, n_chunks), dtype=np.find_common_type((np.float32, data.dtype), []))\n    # Loop through chunks\n    for i_chunk in range(n_chunks):\n        # Get edges of chunk (and account for last chunk)\n        start_sample = i_chunk * n_frames_per_image\n        end_sample = min([start_sample + n_frames_per_image, n_frames])\n        # Slice data\n        this_data = data[:, :, start_sample:end_sample].copy()\n        n_frames_in_chunk = this_data.shape[-1]\n\n        # Allocate matrix for computation\n        ccimage = np.zeros((frame_height, frame_width), dtype=this_data.dtype)\n        # Compute cross-correlation\n        # converted to python from MATLAB (https://labrigger.com/blog/2013/06/13/local-cross-corr-images/)\n        for y in range(window_size, frame_height - window_size):\n            for x in range(window_size, frame_width - window_size):\n                # Center pixel\n                a = this_data[y, x, :]  # Extract center pixel\'s time course and subtract its mean\n                center_pixel = (a - np.mean(a, axis=-1)).reshape(1, 1, n_frames_in_chunk)\n                # Autocorrelation, for normalization later\n                ac_center_pixel = np.sum(center_pixel ** 2, axis=-1)\n\n                # Neighborhood\n                a = this_data[y-window_size:y+window_size+1, x-window_size:x+window_size+1, :]  # Extract the neighborhood\n                neighboring_pixels = a - np.expand_dims(np.mean(a, axis=-1), axis=2)\n                ac_neighboring_pixels = np.sum(neighboring_pixels ** 2, axis=-1)  # Autocorrelation, for normalization later\n\n                # Cross-correlation\n                product_pixels = center_pixel * neighboring_pixels\n                ac_product = ac_center_pixel * ac_neighboring_pixels\n                # Cross-correlation with normalization\n                ccs = divide0(np.sum(product_pixels, axis=-1), np.sqrt(ac_product), replace_with=0)\n                # Delete the middle point\n                all_idx = list(range(ccs.size))\n                all_idx.remove(int((ccs.size + 1) / 2) - 1)\n                ccs = ccs.transpose().ravel()[all_idx]\n\n                # Get the mean cross-correlation with the local neighborhood\n                ccimage[y, x] = ccs.mean()\n\n        # Store this matrix\n        CCimage[:, :, i_chunk] = ccimage\n\n    # Remove extra dimension, if not necessary\n    if squeeze:\n        CCimage = CCimage.squeeze()\n\n    return CCimage\n\n\ndef divide0(a, b, replace_with):\n    """"""Divide two numbers but replace its result if division is not possible,\n    e.g., when dividing a number by 0. No type-checking or agreement between\n    dimensions is performed. Be careful!\n\n    :param a: Numerator.\n    :param b: Denominator.\n    :param replace_with: If a/b is not defined return this number instead.\n    """"""\n    with np.errstate(divide=\'ignore\', invalid=\'ignore\'):\n        c = np.true_divide(a, b)\n        if isinstance(c, np.ndarray):\n            c[np.logical_not(np.isfinite(c))] = replace_with\n        else:\n            if not np.isfinite(c):\n                c = replace_with\n\n    return c\n\n\ndef idx2range(idx):\n    # Convert to numpy array\n    if not type(idx) is np.ndarray:\n        idx = np.array([idx], dtype=int).ravel()\n\n    # Make sure input is sorted\n    idx = np.sort(idx)\n\n    if idx.shape[0] > 1:\n        # Find discontinuities in index\n        dataIDX = np.atleast_2d(np.unique(np.hstack((0, np.where(np.diff(idx) > 1)[0]+1)))).transpose()\n        dataIDX = np.hstack((dataIDX, np.atleast_2d(np.hstack((dataIDX[1:,0]-1, idx.shape[0]-1))).transpose()))\n        # Get original values\n        dataIDX = idx[dataIDX]\n\n        # Add column for duration\n        dataIDX = np.hstack((dataIDX, np.atleast_2d(dataIDX[:,1] - dataIDX[:,0] + 1).transpose()))\n\n    else:\n        dataIDX = np.atleast_2d(np.array([idx, idx, 1]))\n\n    return dataIDX\n\n\ndef expand_indices(start, end):\n    if not isinstance(start, np.ndarray):\n        start = np.array([start], dtype=int)\n    if not isinstance(end, np.ndarray):\n        end = np.array([end], dtype=int)\n    lens = end - start\n    np.cumsum(lens, out=lens)\n    i = np.ones(lens[-1], dtype=int)\n    i[0] = start[0]\n    i[lens[:-1]] += start[1:]\n    i[lens[:-1]] -= end[:-1]\n    np.cumsum(i, out=i)\n    return i\n\n\ndef transform_image_from_parameters(image, scale, angle, offset, return_matrices=False):\n    # Make sure image is a numpy array\n    if not isinstance(image, np.ndarray):\n        image = np.array(image)\n    # Convert to float32 to work with opencv\n    input_needs_conversion = image.dtype != np.float32\n\n    # Get size of image before being transformed\n    frame_size_width = image.shape[1]\n    frame_size_height = image.shape[0]\n    original_canvas_size = [frame_size_height, frame_size_width]\n    # Find out whether the canvas size is an odd number\n    odd_number_of_pixels = [c/2. > np.floor(c/2.) for c in original_canvas_size]\n\n    # Scaling\n    if np.any(scale != 1):\n        # Convert image if necessary\n        if input_needs_conversion:\n            image = image.astype(np.float32)\n            input_needs_conversion = False\n\n        # Get more appropriate interpolation method\n        if scale.mean() > 1:\n            interpolation = cv2.INTER_CUBIC\n        else:\n            interpolation = cv2.INTER_AREA\n        # Apply scaling\n        image = cv2.resize(image, None, fx=scale[1], fy=scale[0], interpolation=interpolation)\n        # Store parameters in memory\n        scaling_matrix = [scale[1], scale[0], interpolation]\n    else:\n        scaling_matrix = np.array([1, 1], dtype=int)\n\n    # Determine a good canvas size to allow both rotation and translation\n    frame_size_width = image.shape[1]\n    frame_size_height = image.shape[0]\n    new_canvas_size = [frame_size_height, frame_size_width]\n    canvas_size = np.ceil(max(new_canvas_size))\n    if angle != 0:  # Add space for complete rotation (e.g., 45 degrees)\n        canvas_size *= np.sqrt(2)\n    if np.any(offset != 0):\n        canvas_size += (np.abs(offset).max() * 2)  # Add double the max offset to allow offsets in any direction\n    # Make it an integer multiple of 2\n    canvas_size = np.ceil(canvas_size)\n    canvas_size = int(np.floor(canvas_size / 2.) * 2.)\n    # The same size is used for width and height, for simplicity\n    canvas_size = [canvas_size, canvas_size]\n    # If original canvas size was an odd number make this one an odd number, too,\n    # so the original image can be perfectly centered in the canvas\n    if odd_number_of_pixels[0]:\n        canvas_size[0] += 1\n    if odd_number_of_pixels[1]:\n        canvas_size[1] += 1\n    # Add padding to account for any residual aliasing (4 pixels should suffice)\n    canvas_size = [c + 4 for c in canvas_size]\n    # Compute margins around the image\n    canvas_margin = (int((canvas_size[0] - image.shape[0]) / 2.), int((canvas_size[1] - image.shape[1]) / 2.))\n    # Allocate canvas\n    canvas = np.nan * np.zeros((canvas_size[0], canvas_size[1]), dtype=np.float32)\n    # Place image in the center\n    canvas[canvas_margin[0]:canvas_margin[0] + image.shape[0], canvas_margin[1]:canvas_margin[1] + image.shape[1]] = image\n    # Re-calculate position of center\n    center = np.floor([canvas_size[0] / 2., canvas_size[1] / 2.]).astype(int)\n\n    # Rotation\n    rotation_matrix = angle\n    if angle != 0:\n        # Convert image if necessary\n        if input_needs_conversion:\n            image = image.astype(np.float32)\n        # For simple cases, do not use opencv\n        if angle % 90 == 0:\n            if angle == 90:\n                image = cv2.transpose(canvas)\n                image = cv2.flip(image, 0)\n            elif angle == -90 or angle == 270:\n                image = cv2.transpose(canvas)\n                image = cv2.flip(image, 1)\n            elif angle == 180 or angle == -180:\n                image = cv2.flip(canvas, -1)\n        else:\n            # Get transformation matrix and apply it to the image\n            rotation_matrix = cv2.getRotationMatrix2D(tuple(center), angle, 1)\n            image = cv2.warpAffine(canvas, rotation_matrix, tuple(canvas_size), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_CONSTANT, borderValue=np.nan)\n    else:\n        image = canvas.copy()\n\n    # Translation / Cut-out of the visible portion only\n    # Get position of new center\n    new_center = center - np.round(offset).astype(int)  # Offset is positive because we move the viewport in the opposite direction to obtain the desired offset in the image\n    # Cut image from canvas around the new center\n    half_height = int(np.floor(original_canvas_size[0] / 2.))\n    half_width = int(np.floor(original_canvas_size[1] / 2.))\n    top = new_center[0]-half_height\n    left = new_center[1]-half_width\n    # Make slice object and use it\n    section = np.s_[top:top+original_canvas_size[0], left:left+original_canvas_size[1]]\n    image = image[section]\n    # Store parameters\n    translation_matrix = [[top, top+original_canvas_size[0], left, left+original_canvas_size[1]], canvas_size]\n\n    # Return outputs\n    if return_matrices:\n        return image, scaling_matrix, rotation_matrix, translation_matrix\n    else:\n        return image\n\n\ndef transform_image_from_matrices(image, scaling_matrix, rotation_matrix, translation_matrix):\n    # Make sure image is a numpy array\n    if not isinstance(image, np.ndarray):\n        image = np.array(image)\n\n    # Convert to float32 to work with opencv\n    input_needs_conversion = not image.dtype is np.float32\n\n    # Convert translation matrix to slice object\n    canvas_size = tuple(translation_matrix[1])\n    translation_matrix = np.s_[translation_matrix[0][0]:translation_matrix[0][1], translation_matrix[0][2]:translation_matrix[0][3]]\n\n    # Scaling\n    if len(scaling_matrix) == 3 and np.any(scaling_matrix[:2] != 1):\n        # Convert image if necessary\n        if input_needs_conversion:\n            image = image.astype(np.float32)\n            input_needs_conversion = False\n        # Apply transformation\n        image = cv2.resize(image, None, fx=scaling_matrix[0], fy=scaling_matrix[1], interpolation=int(scaling_matrix[2]))\n\n    # Make new canvas to allow both rotation and translation\n    canvas = np.nan * np.zeros((canvas_size[0], canvas_size[1]), dtype=np.float32)\n    canvas_margin = (int((canvas_size[0]-image.shape[0])/2), int((canvas_size[1]-image.shape[1])/2))\n    canvas[canvas_margin[0]:canvas_margin[0]+image.shape[0], canvas_margin[1]:canvas_margin[1]+image.shape[1]] = image\n\n    # Rotation\n    if not isinstance(rotation_matrix, np.ndarray) and rotation_matrix == 0:\n        image = canvas.copy()\n    else:\n        # Convert image if necessary\n        if input_needs_conversion:\n            image = image.astype(np.float32)\n        # Apply transformation\n        if not isinstance(rotation_matrix, np.ndarray):\n            angle = rotation_matrix\n            if angle % 90 == 0:\n                if angle == 90:\n                    image = cv2.transpose(canvas)\n                    image = cv2.flip(image, 0)\n                elif angle == -90 or angle == 270:\n                    image = cv2.transpose(canvas)\n                    image = cv2.flip(image, 1)\n                elif angle == 180 or angle == -180:\n                    image = cv2.flip(canvas, -1)\n        else:\n            image = cv2.warpAffine(canvas, rotation_matrix, None, flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_CONSTANT, borderValue=np.nan)\n\n    # Translation\n    image = image[translation_matrix].copy()\n\n    return image\n\n\n###############################################################################\n# https://nedbatchelder.com/blog/200712/human_sorting.html\n###############################################################################\ndef natural_sort(s):\n    """""" Sort the given list in the way that humans expect.""""""\n    def alphanum_key(s):\n        return [int(c) if c.isdigit() else c for c in re.split(\'([0-9]+)\', s)]\n    s.sort(key=alphanum_key)\n    return s\n'"
src/calipy/utils/IO_operations.py,34,"b'# System packages\nimport sys\nimport os\nfrom glob import glob\nimport h5py\nimport psutil\nimport json\nimport gc as memory_garbage_collector\n\n# Numerical packages\nimport numpy as np\nimport pandas as pd\nfrom skimage.external.tifffile import tifffile as tiff\n\n# Local repository\nfrom calipy.general_configs import default as GC\nfrom calipy.utils.Array_operations import temporal_smooth, cross_correlate_image\n\n\nPROJECTIONS_TYPES = [\'mean\', \'median\', \'max\', \'standard_deviation\', \'correlation\']\n\n\ndef prepare_data_for_GUI(tiff_folder, output_folder, overwrite_frame_first=False, overwrite_time_first=False):\n    """"""\n\n    :param tiff_folder:\n    :param output_folder:\n    :param overwrite_frame_first:\n    :param overwrite_time_first:\n    :return:\n    """"""\n    # Get list of files\n    tiff_files = glob(tiff_folder + \'/**/*.tif*\', recursive=True)\n    n_tiff_files = len(tiff_files)\n\n    # Initialize output dictionary\n    PARAMETERS = dict()\n    PARAMETERS[\'dataset_ID\'] = os.path.split(os.path.commonprefix(tiff_files))[-1].strip()\n    # Initialize conversion flags\n    do_convert_frame_first = False\n    do_convert_time_first = False\n\n    # Iterate through tiff files to find width and height of each field of view (FOV)\n    log(\'Reading info on files\')\n    FOV_size = np.zeros((n_tiff_files, 2), dtype=int)\n    n_frames_per_file = np.zeros((n_tiff_files, ), dtype=int)\n    TIFF_dtype = np.zeros((n_tiff_files, ), dtype=object)\n    for i_file in range(n_tiff_files):\n        # Read file and get its shape\n        TIFF = tiff.imread(tiff_files[i_file])\n        TIFF_shape = TIFF.shape\n        if len(TIFF_shape) == 4:\n            TIFF_shape = TIFF_shape[:3]\n        # Store shape\n        n_frames_per_file[i_file] = TIFF_shape[0]\n        FOV_size[i_file, :] = TIFF_shape[1:]\n        TIFF_dtype[i_file] = TIFF.dtype\n\n    # Check consistency of FOV size\n    if not np.all(FOV_size[:, 0] == FOV_size[0, 0]) or not np.all(FOV_size[:, 1] == FOV_size[0, 1]):\n        raise ValueError(\'Imaged fields of view are not all of the same size\')\n    # Get largest data type to accommodate all images\n    TIFF_data_type = np.find_common_type(TIFF_dtype, [])\n    # Store information\n    PARAMETERS[\'n_frames\'] = n_frames_per_file.sum()\n    PARAMETERS[\'frame_height\'] = FOV_size[0, 0]\n    PARAMETERS[\'frame_width\'] = FOV_size[0, 1]\n    PARAMETERS[\'n_pixels\'] = PARAMETERS[\'frame_height\'] * PARAMETERS[\'frame_width\']\n    PARAMETERS[\'dtype\'] = TIFF_data_type\n    # Make indices of beginning and end of each tiff file\n    end_condition = n_frames_per_file.cumsum().reshape(-1, 1)\n    start_condition = np.vstack(([0], end_condition[:-1] + 1))\n    frames_idx = np.hstack((start_condition, end_condition))\n    PARAMETERS[\'frames_idx\'] = frames_idx.tolist()\n\n    # Get name of subfolders\n    folders = [os.path.split(i)[-2] for i in tiff_files]\n    folders = [i.replace(os.path.commonprefix(tiff_files), \'\') for i in folders]\n    PARAMETERS[\'condition_names\'] = [os.path.splitext(os.path.split(i)[-1])[0] for i in tiff_files]\n    # Get beginning and end frame of each session (i.e., a subfolder)\n    condition_names, idx_condition_names = np.unique(folders, return_inverse=True)\n    sessions_last_frame = np.zeros_like(condition_names, dtype=int)\n    for cond_idx, name in enumerate(pd.unique(folders)):\n        idx_this_condition = np.where(idx_condition_names == np.where(np.in1d(condition_names, name))[0][0])[0]\n        sessions_last_frame[cond_idx] = np.sum(n_frames_per_file[idx_this_condition])\n    PARAMETERS[\'sessions_last_frame\'] = np.cumsum(sessions_last_frame).tolist()\n\n    # Calculate the number of frames that can be held in memory while reading / writing final file\n    temp = np.empty(shape=(1, 1), dtype=TIFF_data_type)\n    n_frames_per_chunk = max_chunk_size(n_bytes=temp.itemsize, memory_cap=0.90)\n\n    # Make filenames of data files\n    PARAMETERS[\'filename_frame_first\'] = os.path.join(output_folder, \'stack_frame_first.dat\')\n    PARAMETERS[\'filename_time_first\'] = os.path.join(output_folder, \'stack_time_first.dat\')\n    PARAMETERS[\'filename_projections\'] = os.path.join(output_folder, \'projections.hdf5\')\n    # Make filename of output file\n    PARAMETERS[\'filename_ROIs\'] = os.path.join(output_folder, \'ROIs_info.mat\')\n\n    # Create frame-first file, if it doesn\'t exist\n    if not os.path.exists(PARAMETERS[\'filename_frame_first\']) or not os.path.exists(PARAMETERS[\'filename_projections\']) or overwrite_frame_first:\n        do_convert_frame_first = True\n        log(\'Creating frame-first file in \\\'%s\\\'\' % PARAMETERS[\'filename_frame_first\'])\n        # Make file for data\n        destination_shape = (PARAMETERS[\'n_frames\'], PARAMETERS[\'frame_height\'], PARAMETERS[\'frame_width\'])\n        frame_first_file = np.memmap(PARAMETERS[\'filename_frame_first\'], dtype=PARAMETERS[\'dtype\'], mode=""w+"", shape=destination_shape)\n\n        for i_file in range(n_tiff_files):\n            # Read tiff file\n            filename = tiff_files[i_file]\n            log(\'Copying file %i/%i: %s\' % (i_file + 1, n_tiff_files, filename))\n            TIFF = tiff.imread(filename).astype(TIFF_data_type)\n            TIFF_shape = TIFF.shape\n            # Average across color channels\n            if len(TIFF_shape) == 4:\n                TIFF = np.nanmean(TIFF, axis=3)\n            # Replace NaNs with 0s\n            TIFF[np.isnan(TIFF)] = 0\n\n            # Get edges of chunk\n            start_frame = int(np.clip(PARAMETERS[\'frames_idx\'][i_file][0] - 1, a_min=0, a_max=PARAMETERS[\'n_frames\']))\n            end_frame = int(np.clip(PARAMETERS[\'frames_idx\'][i_file][1], a_min=start_frame, a_max=PARAMETERS[\'n_frames\']))\n            # Make destination slice\n            destination_slice = (slice(start_frame, end_frame), slice(None), slice(None))\n            # Copy frames\n            frame_first_file[destination_slice] = TIFF.transpose((0, 2, 1))\n            # Flush data to disk\n            frame_first_file.flush()\n\n        # Complete writing to disk\n        log(\'Finishing file to disk\')\n        # Close files (flush data to disk)\n        del frame_first_file\n\n        # Compute projections for each condition\n        log(\'Creating projections file in \\\'%s\\\'\' % PARAMETERS[\'filename_projections\'])\n        # first_frame_file\n        frame_first_file = np.memmap(PARAMETERS[\'filename_frame_first\'], dtype=PARAMETERS[\'dtype\'], mode=""r"", shape=destination_shape)\n        # Make file for projections\n        with h5py.File(PARAMETERS[\'filename_projections\'], \'w+\', libver=\'latest\') as projections_file:\n            analyzed_datasets = list(projections_file.keys())\n            for i_file in range(n_tiff_files):\n                log(\'Processing file %i/%i: %s\' % (i_file + 1, n_tiff_files, PARAMETERS[\'condition_names\'][i_file]))\n                # Get frames of interest\n                start_frame = int(np.clip(PARAMETERS[\'frames_idx\'][i_file][0] - 1, a_min=0, a_max=PARAMETERS[\'n_frames\']))\n                end_frame = int(np.clip(PARAMETERS[\'frames_idx\'][i_file][1], a_min=start_frame, a_max=PARAMETERS[\'n_frames\']))\n                frames = frame_first_file[start_frame:end_frame, :, :]\n                # Make group and get list of analyzed datasets\n                if PARAMETERS[\'condition_names\'][i_file] in analyzed_datasets:\n                    hdf5_group = projections_file[PARAMETERS[\'condition_names\'][i_file]]\n                else:\n                    hdf5_group = projections_file.create_group(\'%s\' % PARAMETERS[\'condition_names\'][i_file])\n                computed_projections = list(hdf5_group.keys())\n\n                # Compute projection frame\n                for projection_type in PROJECTIONS_TYPES:\n                    # Remove spaces in name so it can be used as h5 dataset name\n                    projection_type = projection_type.replace(\' \', \'_\')\n                    # Compute projection\n                    if projection_type == \'mean\':\n                        values = np.mean(frames, axis=0)\n\n                    elif projection_type == \'median\':\n                        values = np.median(frames, axis=0)\n\n                    elif projection_type == \'max\':\n                        values = np.max(frames, axis=0)\n\n                    elif projection_type == \'standard_deviation\':\n                        values = np.std(frames, axis=0)\n\n                    elif projection_type == \'correlation\':\n                        # Compute cross-correlation after smoothing video in time(no NaNs allowed)\n                        time_window = int(np.ceil(GC[\'correlation_time_smoothing_window\'] * GC[\'frame_rate\']))\n                        frames_smoothed = temporal_smooth(frames.transpose((1, 2, 0)), time_window)\n                        frames_smoothed[np.isnan(frames_smoothed)] = 0\n                        values = cross_correlate_image(frames_smoothed)\n\n                    else:\n                        raise ValueError(\'Unknown projection type: \\\'%s\\\'\' % projection_type)\n\n                    # Store data\n                    if projection_type in computed_projections:\n                        del hdf5_group[projection_type]\n                    hdf5_group.create_dataset(projection_type, data=values)\n\n        # Make sure memory-mapped file is unlinked\n        del projections_file\n        memory_garbage_collector.collect()\n\n    if not os.path.exists(PARAMETERS[\'filename_time_first\']) or overwrite_time_first:\n        do_convert_time_first = True\n        log(\'Creating time-first file in \\\'%s\\\'\' % PARAMETERS[\'filename_time_first\'])\n        time_first_file = np.memmap(PARAMETERS[\'filename_time_first\'], dtype=PARAMETERS[\'dtype\'], mode=""w+"", shape=(PARAMETERS[\'n_pixels\'], PARAMETERS[\'n_frames\']))\n\n        # Memory-map frame-first file for reading\n        frame_first_file = np.memmap(PARAMETERS[\'filename_frame_first\'], dtype=PARAMETERS[\'dtype\'], mode=""r"", shape=(PARAMETERS[\'n_frames\'], PARAMETERS[\'frame_height\'], PARAMETERS[\'frame_width\']))\n\n        # Calculate number of chunks\n        n_chunks = int(np.ceil(np.float64(PARAMETERS[\'n_frames\']) / n_frames_per_chunk))\n        if n_chunks == 1:\n            n_frames_per_chunk = PARAMETERS[\'n_frames\']\n        # Loop through chunks\n        for i_chunk in range(n_chunks):\n            if n_chunks > 1:\n                log(\'\\tReshaping chunk %i/%i\' % (i_chunk + 1, n_chunks))\n            # Get edges of chunk\n            start_frame = i_chunk * n_frames_per_chunk\n            end_frame = np.clip(start_frame + n_frames_per_chunk, a_min=start_frame + 1, a_max=PARAMETERS[\'n_frames\'])\n            # Get frames\n            frames = frame_first_file[start_frame:end_frame, :, :].copy()\n            # Replace NaNs with 0s\n            frames[np.isnan(frames)] = 0\n            # Copy data collapsing all pixels in a row\n            n_frames_read = frames.shape[0]\n            time_first_file[:, start_frame:end_frame] = frames.reshape((n_frames_read, -1)).transpose()\n            # Flush data to disk\n            time_first_file.flush()\n\n        # Complete writing\n        log(\'Finishing file to disk\')\n        # Close files (flush data to disk)\n        time_first_file.flush()\n        del time_first_file\n        # Make sure all memory-mapped files are unlinked\n        memory_garbage_collector.collect()\n\n    if do_convert_frame_first or do_convert_time_first:\n        log(\'Finished file conversion\')\n\n    # Make sure all memory-mapped files are unlinked\n    memory_garbage_collector.collect()\n\n    # Store parameters to disk\n    parameters_filename = os.path.join(output_folder, \'parameters.json.txt\')\n    # Convert data types of some fields\n    fields_from_num_to_str = [\'n_frames\', \'frame_height\', \'frame_width\', \'n_pixels\']\n    for i in fields_from_num_to_str:\n        PARAMETERS[i] = int(PARAMETERS[i])\n    PARAMETERS[\'dtype\'] = str(PARAMETERS[\'dtype\'])\n    # Write to file\n    json.dump(PARAMETERS, open(parameters_filename, \'w+\'))\n    # Log outcome\n    log(\'Parameters file stored in \\\'%s\\\'\' % parameters_filename)\n\n    return parameters_filename\n\n\n################################################################################\n# Memory\n################################################################################\ndef available_memory_GB(memory_cap=0.90):\n    # Get the amount of available memory in GB\n    memory = psutil.virtual_memory()\n    total_memory_GB = memory[0] / 1024. / 1024. / 1024.\n\n    # Use only up to 90% of the available memory\n    memory_cap_GB = total_memory_GB * memory_cap\n    memory_used_GB = memory[3] / 1024. / 1024. / 1024.\n    memory_usable_GB = memory_cap_GB - memory_used_GB\n\n    return memory_usable_GB\n\ndef max_chunk_size(n_bytes=4, memory_cap=0.90):\n    memory_usable_GB = available_memory_GB(memory_cap=memory_cap)\n\n    # Re-convert to bits and divide by the bit_size of the array to load in memory\n    memory_usable = np.floor(memory_usable_GB * 1024. * 1024. * 1024.).astype(np.int64)\n    n_elements = np.floor(memory_usable / float(n_bytes)).astype(np.int64)\n\n    # Make sure the number of elements is positive\n    if n_elements < 1:\n        n_elements = 1\n\n    return n_elements\n\n\n################################################################################\n# Console\n################################################################################\ndef log(message):\n    sys.stdout.write(message + \'\\n\')\n    sys.stdout.flush()\n'"
src/calipy/utils/Qt.py,11,"b'import ctypes\nimport os\n\nfrom PyQt5 import QtWidgets, QtCore, QtGui\nimport numpy as np\n\nfrom calipy.general_configs import default as GUI_default\nfrom third_party import pyqtgraph as pg\n\n\n################################################################################\n# Qt\n################################################################################\nclass Qt5_QtApp(object):\n    def __init__(self, appID=None, icon=None):\n        """"""Make Qt app and set its icon.""""""\n        self.app = QtWidgets.QApplication.instance()\n        # If not already running, instantiate a new app\n        if self.app is None:  # Quit existing instance\n            self.app = QtWidgets.QApplication([])\n        # Set app ID\n        if appID is not None and os.name == \'nt\':\n            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(appID)\n        # Set app icon\n        if icon is not None:\n            app_icon = QtGui.QIcon(icon)\n            self.app.setWindowIcon(app_icon)\n        # Set \'fusion\' style\n        self.app.setStyle(QtWidgets.QStyleFactory.create(\'Fusion\'))\n\n\nclass Qt_window(QtWidgets.QMainWindow):\n    resized = QtCore.pyqtSignal()\n    about_to_close = QtCore.pyqtSignal()\n\n    def __init__(self):\n        super(Qt_window, self).__init__()\n        self.allowed_to_close = False\n\n    def contextMenuEvent(self, event):\n        pass\n\n    def resizeEvent(self, event):\n        """"""Called whenever the window is resized.""""""\n        self.resized.emit()\n        return super(Qt_window, self).resizeEvent(event)\n\n    def closeEvent(self, event):\n        """"""Called whenever the window receives the close command. We only proceed\n        if we are allowed to do so.""""""\n        self.about_to_close.emit()\n        if self.allowed_to_close:\n            event.accept()\n            super(Qt_window, self).closeEvent(event)\n        else:\n            event.ignore()\n\n\nclass Slider(QtWidgets.QSlider):\n    def __init__(self, minimum, maximum):\n        super(Slider, self).__init__()\n        self.setMinimum(minimum)\n        self.setMaximum(maximum)\n        self._range = maximum - minimum\n\n    def mousePressEvent (self, event):\n        mouse_click_position = event.x()\n        new_value = self.minimum() + (self._range * mouse_click_position) / self.width()\n        self.setValue(new_value)\n\n\nclass MultiColumn_QTable(QtWidgets.QTableWidget):\n    def __init__(self, data, title, minimum_height=500):\n        super(MultiColumn_QTable, self).__init__()\n\n        # Store the maximum height allowed for long tables\n        self.minimum_height = minimum_height\n\n        # Make a stylesheet that creates consistent colors between selection states\n        self.setStyleSheet(""""""QTableWidget:item:selected:active {background:#3399FF; color:white}\n                            QTableWidget:item:selected:!active {background:gray; color:white}\n                            QTableWidget:item:selected:disabled {background:gray; color:white}\n                            QTableWidget:item:selected:!disabled {background:#3399FF; color:white}"""""")\n\n        # Initialize field names\n        self.allowed_interaction = None\n        self._columns = [title]\n\n        # Hide row numbers\n        self.verticalHeader().setVisible(False)\n\n        # Assign data to the table\n        if not isinstance(data, np.ndarray):\n            data = np.array(data)\n        self.data = data\n        self.n_rows = self.data.shape[0]\n        self.setRowCount(self.n_rows)\n        self.setColumnCount(1)\n\n        # Make table\n        for irow in range(self.n_rows):\n            item = self.data[irow]\n            new_item = QtWidgets.QTableWidgetItem(item)\n            new_item.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)\n            new_item.setFont(GUI_default[\'font\'])\n            self.setItem(irow, 0, new_item)\n\n        # Set the header labels\n        self.setHorizontalHeaderLabels(self._columns)\n        # Resize cell size to content\n        self.resizeColumnsToContents()\n        self.resizeRowsToContents()\n\n        # Only entire rows can be selected\n        self.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)\n        # Rows can be selected with Ctrl and Shift like one would expect in Windows\n        self.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\n        # Set vertical scrollbars as always visible, but hide horizontal ones\n        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        # Disable drag-and-drop\n        self.setDragDropMode(QtWidgets.QAbstractItemView.NoDragDrop)\n\n        # Resize table\n        self._adjust_table_size()\n\n        # Get default properties\n        self._EditTriggers = self.editTriggers()\n        self._FocusPolicy = self.focusPolicy()\n        self._SelectionMode = self.selectionMode()\n        # Start with interaction enabled\n        self.enable_interaction()\n\n    def _adjust_table_size(self):\n        """"""Adapt table size to current content""""""\n        self._getQTableWidgetSize()\n        val = np.min((self.minimum_height, self.table_size.height()))\n        tableSize = QtCore.QSize(self.table_size.width(), val)\n        self.setMinimumSize(tableSize)\n        self.setMaximumSize(self.table_size)\n\n    def _getQTableWidgetSize(self):\n        """"""Calculate the right table size for the current content""""""\n        w = self.verticalHeader().width() + 4 +20 # +4 seems to be needed\n        for i in range(self.columnCount()):\n            w += self.columnWidth(i) # seems to include gridline\n        h = self.horizontalHeader().height() + 4\n        for i in range(self.rowCount()):\n            h += self.rowHeight(i)\n        self.table_size = QtCore.QSize(w, h)\n\n    def disable_interaction(self):\n        """"""Make table not interactive.""""""\n        self.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)\n        self.setFocusPolicy(QtCore.Qt.NoFocus)\n        self.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)\n        self.setEnabled(False)\n        self.allowed_interaction = False\n\n    def enable_interaction(self):\n        """"""Make table interactive.""""""\n        self.setEditTriggers(self._EditTriggers)\n        self.setFocusPolicy(self._FocusPolicy)\n        self.setSelectionMode(self._SelectionMode)\n        self.setEnabled(True)\n        self.allowed_interaction = True\n\n    @staticmethod\n    def get_row_number(items):\n        """"""Return the row index of each item in <items>.""""""\n        return np.array([i.row() for i in items])\n\n\ndef MessageBox(message, title=\'\', parent=None, box_type=\'question\', button_Yes=\'Yes\', button_No=\'No\', default_answer=\'Yes\', additional_buttons=None):\n    # Create empty MessageBox\n    msgBox = QtWidgets.QMessageBox(parent)\n\n    # Make buttons\n    QButton_Yes = msgBox.addButton(button_Yes, QtWidgets.QMessageBox.YesRole)\n    QButton_No = msgBox.addButton(button_No, QtWidgets.QMessageBox.NoRole)\n    # Add other buttons\n    additional_QButtons = list()\n    if additional_buttons is not None:\n        if isinstance(additional_buttons, str):\n            additional_buttons = [additional_buttons]\n        for btn in additional_buttons:\n            additional_QButtons.append(msgBox.addButton(btn, QtWidgets.QMessageBox.YesRole))\n\n    # Set default action\n    if default_answer.lower() == \'yes\':\n        msgBox.setDefaultButton(QButton_Yes)\n    elif default_answer.lower() == \'no\':\n        msgBox.setDefaultButton(QButton_No)\n    else:\n        btn_idx = additional_buttons.index(default_answer)\n        msgBox.setDefaultButton(additional_QButtons[btn_idx])\n    # Set action associated t oEscape button\n    msgBox.setEscapeButton(QButton_No)\n\n    # Replace \\n with <br>\n    message = \'<br />\'.join(message.split(\'\\n\'))\n    # Include message in HTML tags to change font size\n    message_to_show = ""<font size = %i> %s </font>"" % (GUI_default[\'font\'].pointSize()/2.5, message)\n    # Add title and text\n    if title != \'\':\n        msgBox.setWindowTitle(title)\n    msgBox.setText(message_to_show)\n    # Add icon\n    if box_type == \'question\':\n        msgBox.setIcon(QtWidgets.QMessageBox.Question)\n    elif box_type == \'warning\':\n        msgBox.setIcon(QtWidgets.QMessageBox.Warning)\n    # Execute widget\n    msgBox.exec_()\n\n    # Collect answer\n    answer = msgBox.clickedButton()\n    if answer == QButton_Yes:\n        return button_Yes\n    elif answer == QButton_No:\n        return button_No\n    else:\n        # Get index of clicked button\n        answer_idx = [answer == ii for ii in additional_QButtons].index(True)\n        return additional_buttons[answer_idx]\n\n\n################################################################################\n# pyqtgraph\n################################################################################\nclass ImageView(pg.ImageView):\n    def evalKeyState(self):\n        if len(self.keysPressed) == 1:\n            key = list(self.keysPressed.keys())[0]\n            if key == QtCore.Qt.Key_Right:\n                self.key_pressed.emit(key)\n            elif key == QtCore.Qt.Key_Left:\n                self.key_pressed.emit(key)\n            elif key == QtCore.Qt.Key_PageUp:\n                self.play(-1000)\n            elif key == QtCore.Qt.Key_PageDown:\n                self.play(1000)\n        else:\n            self.play(0)\n\n\nclass CustomViewBox(pg.ViewBox):\n    def __init__(self, *args, **kwds):\n        pg.ViewBox.__init__(self, *args, **kwds)\n        self.menu = QtWidgets.QMenu()\n\n    def mouseDragEvent(self, ev, axis=None):\n        if ev.button() == QtCore.Qt.RightButton:\n            # Swap button identity\n            ev._button = QtCore.Qt.LeftButton\n            pg.ViewBox.mouseDragEvent(self, ev, axis)\n        elif ev.button() == QtCore.Qt.LeftButton:\n            ev.ignore()\n\n    def getMenu(self, ev):\n        return QtWidgets.QMenu()\n\n    def updateViewLists(self): pass\n    @staticmethod\n    def updateAllViewLists(): pass\n\n\nclass TimeAxis(pg.AxisItem):\n    def generateDrawSpecs(self, p):\n        """"""\n        Calls tickValues() and tickStrings() to determine where and how ticks should\n        be drawn, then generates from this a set of drawing commands to be\n        interpreted by drawPicture().\n        """"""\n        # Initialize local variables\n\n\n        bounds = self.mapRectFromParent(self.geometry())\n\n        linkedView = self.linkedView()\n        if linkedView is None or self.grid is False:\n            tickBounds = bounds\n        else:\n            tickBounds = linkedView.mapRectToItem(self, linkedView.boundingRect())\n\n        span = (bounds.topLeft(), bounds.topRight())\n        tickStart = tickBounds.top()\n        tickStop = bounds.top()\n        tickDir = 1\n        axis = 1\n\n        ## Determine size of this item in pixels\n        points = list(map(self.mapToDevice, span))\n        if None in points:\n            return\n        lengthInPixels = pg.Point(points[1] - points[0]).length()\n        if lengthInPixels == 0:\n            return\n\n        # Determine major / minor / subminor axis ticks\n        if self._tickLevels is None:\n            tickLevels = self.tickValues(self.range[0], self.range[1], lengthInPixels)\n            tickStrings = None\n        else:\n            # Parse self.tickLevels into the formats returned by tickLevels() and tickStrings()\n            tickLevels = []\n            tickStrings = []\n            for level in self._tickLevels:\n                values = []\n                strings = []\n                tickLevels.append((None, values))\n                tickStrings.append(strings)\n                for val, strn in level:\n                    values.append(val)\n                    strings.append(strn)\n\n        # Determine mapping between tick values and local coordinates\n        dif = self.range[1] - self.range[0]\n        if dif == 0:\n            xScale = 1\n            offset = 0\n        else:\n            if axis == 0:\n                xScale = -bounds.height() / dif\n                offset = self.range[0] * xScale - bounds.height()\n            else:\n                xScale = bounds.width() / dif\n                offset = self.range[0] * xScale\n\n        xRange = [x * xScale - offset for x in self.range]\n        xMin = min(xRange)\n        xMax = max(xRange)\n\n        tickPositions = []  # remembers positions of previously drawn ticks\n\n        # Compute coordinates to draw ticks\n        # Draw three different intervals, long ticks first\n        tickSpecs = []\n        for i_level in range(len(tickLevels)):\n            tickPositions.append([])\n            ticks = tickLevels[i_level][1]\n\n            ## length of tick\n            tickLength = self.style[\'tickLength\'] / ((i_level * 0.5) + 1.0)\n\n            lineAlpha = 255 / (i_level + 1)\n            if self.grid is not False:\n                lineAlpha *= self.grid / 255. * np.clip((0.05 * lengthInPixels / (len(ticks) + 1)), 0., 1.)\n\n            for v in ticks:\n                # Determine actual position to draw this tick\n                x = (v * xScale) - offset\n                if x < xMin or x > xMax:  # Last check to make sure no out-of-bounds ticks are drawn\n                    tickPositions[i_level].append(None)\n                    continue\n                tickPositions[i_level].append(x)\n\n                p1 = [x, x]\n                p2 = [x, x]\n                p1[axis] = tickStart\n                p2[axis] = tickStop\n                if self.grid is False:\n                    p2[axis] += tickLength * tickDir\n                tickPen = self.pen()\n                color = tickPen.color()\n                color.setAlpha(lineAlpha)\n                tickPen.setColor(color)\n                tickSpecs.append((tickPen, pg.Point(p1), pg.Point(p2)))\n\n        if self.style[\'stopAxisAtTick\'][0] is True:\n            stop = max(span[0].y(), min(map(min, tickPositions)))\n            if axis == 0:\n                span[0].setY(stop)\n            else:\n                span[0].setX(stop)\n        if self.style[\'stopAxisAtTick\'][1] is True:\n            stop = min(span[1].y(), max(map(max, tickPositions)))\n            if axis == 0:\n                span[1].setY(stop)\n            else:\n                span[1].setX(stop)\n        axisSpec = (self.pen(), span[0], span[1])\n\n        textOffset = self.style[\'tickTextOffset\'][axis]  # Spacing between axis and text\n        textSize2 = 0\n        textRects = []\n        textSpecs = []\n\n        # If values are hidden, return early\n        if not self.style[\'showValues\']:\n            return axisSpec, tickSpecs, textSpecs\n\n        # Get all strings\n        # all_strings = list()\n        # for i_level in range(min(len(tickLevels), self.style[\'maxTextLevel\'] + 1)):\n        #     ## Get the list of strings to display for this level\n        #     if tickStrings is None:\n        #         spacing, values = tickLevels[i_level]\n        #         strings = self.tickStrings(values, self.autoSIPrefixScale * self.scale, spacing)\n        #     else:\n        #         strings = tickStrings[i_level]\n        #\n        #     if len(strings) == 0:\n        #         continue\n        #\n        #     # Ignore strings belonging to ticks that were previously ignored\n        #     for j in range(len(strings)):\n        #         if tickPositions[i_level][j] is None:\n        #             strings[j] = None\n\n\n\n\n\n        for i_level in range(min(len(tickLevels), self.style[\'maxTextLevel\'] + 1)):\n            ## Get the list of strings to display for this level\n            if tickStrings is None:\n                spacing, values = tickLevels[i_level]\n                strings = self.tickStrings(values, self.autoSIPrefixScale * self.scale, spacing)\n            else:\n                strings = tickStrings[i_level]\n\n            if len(strings) == 0:\n                continue\n\n            # Ignore strings belonging to ticks that were previously ignored\n            for j in range(len(strings)):\n                if tickPositions[i_level][j] is None:\n                    strings[j] = None\n\n            # Measure density of text; decide whether to draw this level\n            rects = []\n            for s in strings:\n                if s is None:\n                    rects.append(None)\n                else:\n                    br = p.boundingRect(QtCore.QRectF(0, 0, 100, 100),\n                                        QtCore.Qt.AlignCenter, pg.python2_3.asUnicode(s))\n                    ## boundingRect is usually just a bit too large\n                    ## (but this probably depends on per-font metrics?)\n                    br.setHeight(br.height() * 0.8)\n\n                    rects.append(br)\n                    textRects.append(rects[-1])\n\n            if len(textRects) > 0:\n                ## measure all text, make sure there\'s enough room\n                if axis == 0:\n                    textSize = np.sum([r.height() for r in textRects])\n                    textSize2 = np.max([r.width() for r in textRects])\n                else:\n                    textSize = np.sum([r.width() for r in textRects])\n                    textSize2 = np.max([r.height() for r in textRects])\n            else:\n                textSize = 0\n                textSize2 = 0\n\n            if i_level > 0:  ## always draw top level\n                ## If the strings are too crowded, stop drawing text now.\n                ## We use three different crowding limits based on the number\n                ## of texts drawn so far.\n                textFillRatio = float(textSize) / lengthInPixels\n                finished = False\n                for nTexts, limit in self.style[\'textFillLimits\']:\n                    if len(textSpecs) >= nTexts and textFillRatio >= limit:\n                        finished = True\n                        break\n                if finished:\n                    break\n\n            # spacing, values = tickLevels[best]\n            # strings = self.tickStrings(values, self.scale, spacing)\n            # Determine exactly where tick text should be drawn\n            for j in range(len(strings)):\n                vstr = strings[j]\n                if vstr is None:  ## this tick was ignored because it is out of bounds\n                    continue\n                vstr = pg.python2_3.asUnicode(vstr)\n                x = tickPositions[i_level][j]\n                # textRect = p.boundingRect(QtCore.QRectF(0, 0, 100, 100), QtCore.Qt.AlignCenter, vstr)\n                textRect = rects[j]\n                height = textRect.height()\n                width = textRect.width()\n                # self.textHeight = height\n                offset = max(0, self.style[\'tickLength\']) + textOffset\n                if self.orientation == \'left\':\n                    textFlags = QtCore.Qt.TextDontClip | QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter\n                    rect = QtCore.QRectF(tickStop - offset - width,\n                                         x - (height / 2), width, height)\n                elif self.orientation == \'right\':\n                    textFlags = QtCore.Qt.TextDontClip | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter\n                    rect = QtCore.QRectF(tickStop + offset, x - (height / 2),\n                                         width, height)\n                elif self.orientation == \'top\':\n                    textFlags = QtCore.Qt.TextDontClip | QtCore.Qt.AlignCenter | QtCore.Qt.AlignBottom\n                    rect = QtCore.QRectF(x - width / 2.,\n                                         tickStop - offset - height, width,\n                                         height)\n                elif self.orientation == \'bottom\':\n                    textFlags = QtCore.Qt.TextDontClip | QtCore.Qt.AlignCenter | QtCore.Qt.AlignTop\n                    rect = QtCore.QRectF(x - width / 2., tickStop + offset,\n                                         width, height)\n\n                # p.setPen(self.pen())\n                # p.drawText(rect, textFlags, vstr)\n                textSpecs.append((rect, textFlags, vstr))\n\n        ## update max text size if needed.\n        self._updateMaxTextSize(textSize2)\n\n        return (axisSpec, tickSpecs, textSpecs)\n\n\n\n    # def tickStrings(self, values, scale, spacing):\n    #     time_values = np.array(values) * scale / GUI_default[\'frame_rate\']\n    #     time_values_str = [\'\']\n    #     # Set range for precision\n    #     precision = 0\n    #     max_precision = 3\n    #     while precision <= max_precision:\n    #         # Make format for numbers\n    #         str_format = \'%%.%if\' % precision\n    #         # Convert numbers to str\n    #         time_values_str = [str_format % i for i in time_values.astype(float)]\n    #\n    #         # Use label if only one\n    #         if len(time_values_str) == 1:\n    #             break\n    #         else:\n    #             # Increase precision if some labels have the same numbers\n    #             if np.unique(time_values_str).shape[0] != len(time_values_str):\n    #                 precision += 1\n    #             else:\n    #                 break\n    #\n    #     return time_values_str\n\n\ndef ProgressDialog(*args, **kwargs):\n    # Create progress dialog\n    dlg = pg.ProgressDialog(busyCursor=True, wait=0, *args, **kwargs)\n    # Adjust labels size\n    label = [ch for ch in dlg.children() if isinstance(ch, QtWidgets.QLabel)][0]\n    label.setFont(GUI_default[\'font_buttons\'])\n    bar = [ch for ch in dlg.children() if isinstance(ch, QtWidgets.QProgressBar)][0]\n    bar.setFont(GUI_default[\'font\'])\n    # The window is modal to the application and blocks input to all windows\n    dlg.setWindowModality(QtCore.Qt.ApplicationModal)\n    # Hide cancel button\n    dlg.setCancelButton(None)\n    dlg.adjustSize()\n    # Disable window\'s close button\n    dlg.setWindowFlags(dlg.windowFlags() & ~QtCore.Qt.WindowCloseButtonHint)\n    # Make sure to show the dialog and return it\n    dlg.show()\n\n    return dlg\n\n\n################################################################################\n# Create elements\n################################################################################\ndef make_toolbar_button(window, text_or_icon_data, kind=\'text\', fixed_size=(32, 32), **kwargs):\n    # Create button\n    btn = QtWidgets.QToolButton(window)\n    # Set checkable state\n    checkable = kwargs.get(\'checkable\', False)\n    btn.setCheckable(checkable)\n\n    # Set default properties according to type\n    if kind == \'text\':\n        # Add text and set font\n        btn.setText(text_or_icon_data)\n        btn.setFont(GUI_default[\'font_buttons\'])\n        # Make only text visible\n        btn.setToolButtonStyle(QtCore.Qt.ToolButtonTextOnly)\n\n    elif kind == \'icon\':\n        # Set only icon to be visible\n        btn.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)\n        # If button is checkable, it will contain two icons (for the 2 states: unchecked and checked)\n        if checkable:\n            btn.setIcon(QtGui.QIcon(QtGui.QPixmap(text_or_icon_data[0])))  # Initialize as unchecked\n        else:\n            btn.setIcon(QtGui.QIcon(QtGui.QPixmap(text_or_icon_data)))\n\n    # Set size policy\n    if fixed_size is not None:\n        btn.setFixedSize(QtCore.QSize(fixed_size[0], fixed_size[1]))\n\n    return btn\n\n\ndef make_toolbar_action(window, text=None, icon=None, fixed_size=(48, 48)):\n    # Create button\n    btn = QtWidgets.QAction(window)\n\n    # Set text\n    if text is not None:\n        btn.setIconText(\' \' + text)\n        btn.setFont(GUI_default[\'font_actions\'])\n    # Set icon\n    if icon is not None:\n        btn.setIcon(QtGui.QIcon(QtGui.QPixmap(icon)))\n\n    return btn\n\n\ndef make_QSplitter(orientation):\n    """"""Make a QSplitter object with default properties.""""""\n    if orientation == ""hor"":\n        ori = QtCore.Qt.Horizontal\n    else:\n        ori = QtCore.Qt.Vertical\n    s = QtWidgets.QSplitter()\n    s.setOrientation(ori)\n    s.setChildrenCollapsible(False)\n    s.setHandleWidth(7)\n    s.setOpaqueResize(True)\n    s.setStyleSheet(""QSplitter::handle {border: 1px dashed #76797C;}""\n                    ""QSplitter::handle:pressed {background-color: #787876; border: 1px solid #76797C;}"")\n    return s\n\n'"
src/calipy/utils/ROIs.py,11,"b'# System packages\nfrom functools import partial\n\n# Numerical packages\nfrom math import cos, sin\nimport numpy as np\n\n# pyqtgraph and graphical packages\nfrom PyQt5 import QtCore, QtGui, QtWidgets\nfrom third_party import pyqtgraph as pg\nfrom third_party.pyqtgraph import GraphicsObject, Point, SRTTransform, UIGraphicsItem\nfrom third_party.pyqtgraph import functions as fn\n\n# Local repository\nfrom calipy.general_configs import default as GUI_default\n\n\nclass ROI(GraphicsObject):\n    """"""\n    Generic region-of-interest widget.\n\n    Can be used for implementing many types of selection box with\n    rotate/translate/scale handles.\n    ROIs can be customized to have a variety of shapes (by subclassing or using\n    any of the built-in subclasses) and any combination of draggable handles\n    that allow the user to manipulate the ROI.\n\n    Default mouse interaction:\n\n    * Left drag moves the ROI\n    * Left drag + Ctrl moves the ROI with position snapping\n    * Left drag + Alt rotates the ROI\n    * Left drag + Alt + Ctrl rotates the ROI with angle snapping\n    * Left drag + Shift scales the ROI\n    * Left drag + Shift + Ctrl scales the ROI with size snapping\n\n    In addition to the above interaction modes, it is possible to attach any\n    number of handles to the ROI that can be dragged to change the ROI in\n    various ways (see the ROI.add____Handle methods).\n\n\n    ================ ===========================================================\n    **Arguments**\n    pos              (length-2 sequence) Indicates the position of the ROI\'s\n                     origin. For most ROIs, this is the lower-left corner of\n                     its bounding rectangle.\n    size             (length-2 sequence) Indicates the width and height of the\n                     ROI.\n    angle            (float) The rotation of the ROI in degrees. Default is 0.\n    invertible       (bool) If True, the user may resize the ROI to have\n                     negative width or height (assuming the ROI has scale\n                     handles). Default is False.\n    maxBounds        (QRect, QRectF, or None) Specifies boundaries that the ROI\n                     cannot be dragged outside of by the user. Default is None.\n    snapSize         (float) The spacing of snap positions used when *scaleSnap*\n                     or *translateSnap* are enabled. Default is 1.0.\n    scaleSnap        (bool) If True, the width and height of the ROI are forced\n                     to be integer multiples of *snapSize* when being resized\n                     by the user. Default is False.\n    translateSnap    (bool) If True, the x and y positions of the ROI are forced\n                     to be integer multiples of *snapSize* when being resized\n                     by the user. Default is False.\n    rotateSnap       (bool) If True, the ROI angle is forced to a multiple of\n                     the ROI\'s snap angle (default is 15 degrees) when rotated\n                     by the user. Default is False.\n    parent           (QGraphicsItem) The graphics item parent of this ROI. It\n                     is generally not necessary to specify the parent.\n    pen              (QPen or argument to pg.mkPen) The pen to use when drawing\n                     the shape of the ROI.\n    movable          (bool) If True, the ROI can be moved by dragging anywhere\n                     inside the ROI. Default is True.\n    rotatable        (bool) If True, the ROI can be rotated by mouse drag + ALT\n    resizable        (bool) If True, the ROI can be resized by mouse drag +\n                     SHIFT\n    removable        (bool) If True, the ROI will be given a context menu with\n                     an option to remove the ROI. The ROI emits\n                     sigRemoveRequested when this menu action is selected.\n                     Default is False.\n    ================ ===========================================================\n\n\n\n    ======================= ====================================================\n    **Signals**\n    sigRegionChangeFinished Emitted when the user stops dragging the ROI (or\n                            one of its handles) or if the ROI is changed\n                            programatically.\n    sigRegionChangeStarted  Emitted when the user starts dragging the ROI (or\n                            one of its handles).\n    sigRegionChanged        Emitted any time the position of the ROI changes,\n                            including while it is being dragged by the user.\n    sigHoverEvent           Emitted when the mouse hovers over the ROI.\n    sigClicked              Emitted when the user clicks on the ROI.\n                            Note that clicking is disabled by default to prevent\n                            stealing clicks from objects behind the ROI. To\n                            enable clicking, call\n                            roi.setAcceptedMouseButtons(QtCore.Qt.LeftButton).\n                            See QtGui.QGraphicsItem documentation for more\n                            details.\n    sigRemoveRequested      Emitted when the user selects \'remove\' from the\n                            ROI\'s context menu (if available).\n    ======================= ====================================================\n    """"""\n\n    sigRegionChangeFinished = QtCore.pyqtSignal(object)\n    sigRegionChangeStarted = QtCore.pyqtSignal(object)\n    sigRegionChanged = QtCore.pyqtSignal(object)\n    sigHoverEvent = QtCore.pyqtSignal(object)\n    sigClicked = QtCore.pyqtSignal(object, object)\n    sigRemoveRequested = QtCore.pyqtSignal(object)\n\n    def __init__(self, pos, size=Point(1, 1), angle=0.0, invertible=False, maxBounds=None, snapSize=1.0, scaleSnap=False, translateSnap=False, rotateSnap=False, parent=None, pen=None, movable=True, rotatable=True, resizable=True, removable=False, handlePen=None, invisible=True):\n        GraphicsObject.__init__(self, parent)\n        self.setAcceptedMouseButtons(QtCore.Qt.NoButton)\n        pos = Point(pos)\n        size = Point(size)\n        self.aspectLocked = False\n        self.translatable = movable\n        self.rotatable = rotatable\n        self.resizable = resizable\n        self.removable = removable\n        self.menu = None\n        self.invisible = invisible\n        self.allowed_interaction = True\n        if not self.invisible and pen is None:\n            pen = GUI_default[\'ROI_highlighted_segment_pen\']\n\n        self.freeHandleMoved = False  ## keep track of whether free handles have moved since last change signal was emitted.\n        self.mouseHovering = False\n        self.setPen(pen)\n\n        if handlePen is None:\n            handlePen = GUI_default[\'ROI_handle_pen\']\n        self.handlePen = handlePen\n        self.handles = []\n        self.state = {\'pos\'  : Point(0, 0), \'size\': Point(1, 1), \'angle\': 0}  ## angle is in degrees for ease of Qt integration\n        self.lastState = None\n        self.setPos(pos)\n        self.setAngle(angle)\n        self.setSize(size)\n        self.setZValue(10)\n        self.isMoving = False\n\n        self.handleSize = GUI_default[\'ROI_handle_size\']\n        self.invertible = invertible\n        self.maxBounds = maxBounds\n\n        self.snapSize = snapSize\n        self.translateSnap = translateSnap\n        self.rotateSnap = rotateSnap\n        self.rotateSnapAngle = 15.0\n        self.scaleSnap = scaleSnap\n        self.scaleSnapSize = snapSize\n\n        # Implement mouse handling in a separate class to allow easier customization\n        self.mouseDragHandler = MouseDragHandler(self)\n\n    def getState(self):\n        return self.stateCopy()\n\n    def stateCopy(self):\n        sc = {}\n        sc[\'pos\'] = Point(self.state[\'pos\'])\n        sc[\'size\'] = Point(self.state[\'size\'])\n        sc[\'angle\'] = self.state[\'angle\']\n        return sc\n\n    def saveState(self):\n        """"""Return the state of the widget in a format suitable for storing to\n        disk. (Points are converted to tuple)\n\n        Combined with setState(), this allows ROIs to be easily saved and\n        restored.""""""\n        state = {}\n        state[\'pos\'] = tuple(self.state[\'pos\'])\n        state[\'size\'] = tuple(self.state[\'size\'])\n        state[\'angle\'] = self.state[\'angle\']\n        return state\n\n    def setState(self, state, update=True):\n        """"""\n        Set the state of the ROI from a structure generated by saveState() or\n        getState().\n        """"""\n        self.setPos(state[\'pos\'], update=False)\n        self.setSize(state[\'size\'], update=False)\n        self.setAngle(state[\'angle\'], update=update)\n\n    def setZValue(self, z):\n        QtGui.QGraphicsItem.setZValue(self, z)\n        for h in self.handles:\n            h[\'item\'].setZValue(z + 1)\n\n    def parentBounds(self):\n        """"""\n        Return the bounding rectangle of this ROI in the coordinate system\n        of its parent.\n        """"""\n        return self.mapToParent(self.boundingRect()).boundingRect()\n\n    def setPen(self, *args, **kwargs):\n        """"""\n        Set the pen to use when drawing the ROI shape.\n        For arguments, see :func:`mkPen <pyqtgraph.mkPen>`.\n        """"""\n        self.pen = fn.mkPen(*args, **kwargs)\n        self.currentPen = self.pen\n        self.update()\n\n    def size(self):\n        """"""Return the size (w,h) of the ROI.""""""\n        return self.getState()[\'size\']\n\n    def pos(self):\n        """"""Return the position (x,y) of the ROI\'s origin.\n        For most ROIs, this will be the lower-left corner.""""""\n        return self.getState()[\'pos\']\n\n    def angle(self):\n        """"""Return the angle of the ROI in degrees.""""""\n        return self.getState()[\'angle\']\n\n    def setPos(self, pos, y=None, update=True, finish=True):\n        """"""Set the position of the ROI (in the parent\'s coordinate system).\n\n        Accepts either separate (x, y) arguments or a single :class:`Point` or\n        ``QPointF`` argument.\n\n        By default, this method causes both ``sigRegionChanged`` and\n        ``sigRegionChangeFinished`` to be emitted. If *finish* is False, then\n        ``sigRegionChangeFinished`` will not be emitted. You can then use\n        stateChangeFinished() to cause the signal to be emitted after a series\n        of state changes.\n\n        If *update* is False, the state change will be remembered but not processed and no signals\n        will be emitted. You can then use stateChanged() to complete the state change. This allows\n        multiple change functions to be called sequentially while minimizing processing overhead\n        and repeated signals. Setting ``update=False`` also forces ``finish=False``.\n        """"""\n        if update not in (True, False):\n            raise TypeError(""update argument must be bool"")\n\n        if y is None:\n            pos = Point(pos)\n        else:\n            # avoid ambiguity where update is provided as a positional argument\n            if isinstance(y, bool):\n                raise TypeError(""Positional arguments to setPos() must be numerical."")\n            pos = Point(pos, y)\n\n        self.state[\'pos\'] = pos\n        QtGui.QGraphicsItem.setPos(self, pos)\n        if update:\n            self.stateChanged(finish=finish)\n\n    def setSize(self, size, center=None, centerLocal=None, snap=False,\n                update=True, finish=True):\n        """"""\n        Set the ROI\'s size.\n\n        =============== ==========================================================================\n        **Arguments**\n        size            (Point | QPointF | sequence) The final size of the ROI\n        center          (None | Point) Optional center point around which the ROI is scaled,\n                        expressed as [0-1, 0-1] over the size of the ROI.\n        centerLocal     (None | Point) Same as *center*, but the position is expressed in the\n                        local coordinate system of the ROI\n        snap            (bool) If True, the final size is snapped to the nearest increment (see\n                        ROI.scaleSnapSize)\n        update          (bool) See setPos()\n        finish          (bool) See setPos()\n        =============== ==========================================================================\n        """"""\n        if update not in (True, False):\n            raise TypeError(""update argument must be bool"")\n        size = Point(size)\n        if snap:\n            size[0] = round(size[0] / self.scaleSnapSize) * self.scaleSnapSize\n            size[1] = round(size[1] / self.scaleSnapSize) * self.scaleSnapSize\n\n        if centerLocal is not None:\n            oldSize = Point(self.state[\'size\'])\n            oldSize[0] = 1 if oldSize[0] == 0 else oldSize[0]\n            oldSize[1] = 1 if oldSize[1] == 0 else oldSize[1]\n            center = Point(centerLocal) / oldSize\n\n        if center is not None:\n            center = Point(center)\n            c = self.mapToParent(Point(center) * self.state[\'size\'])\n            c1 = self.mapToParent(Point(center) * size)\n            newPos = self.state[\'pos\'] + c - c1\n            self.setPos(newPos, update=False, finish=False)\n\n        self.prepareGeometryChange()\n        self.state[\'size\'] = size\n        if update:\n            self.stateChanged(finish=finish)\n\n    def setAngle(self, angle, center=None, centerLocal=None, snap=False,\n                 update=True, finish=True):\n        """"""\n        Set the ROI\'s rotation angle.\n\n        =============== ==========================================================================\n        **Arguments**\n        angle           (float) The final ROI angle in degrees\n        center          (None | Point) Optional center point around which the ROI is rotated,\n                        expressed as [0-1, 0-1] over the size of the ROI.\n        centerLocal     (None | Point) Same as *center*, but the position is expressed in the\n                        local coordinate system of the ROI\n        snap            (bool) If True, the final ROI angle is snapped to the nearest increment\n                        (default is 15 degrees; see ROI.rotateSnapAngle)\n        update          (bool) See setPos()\n        finish          (bool) See setPos()\n        =============== ==========================================================================\n        """"""\n        if update not in (True, False):\n            raise TypeError(""update argument must be bool"")\n\n        if snap is True:\n            angle = round(angle / self.rotateSnapAngle) * self.rotateSnapAngle\n\n        self.state[\'angle\'] = angle\n        tr = QtGui.QTransform()  # note: only rotation is contained in the transform\n        tr.rotate(angle)\n        if center is not None:\n            centerLocal = Point(center) * self.state[\'size\']\n        if centerLocal is not None:\n            centerLocal = Point(centerLocal)\n            # rotate to new angle, keeping a specific point anchored as the center of rotation\n            cc = self.mapToParent(centerLocal) - (\n                        tr.map(centerLocal) + self.state[\'pos\'])\n            self.translate(cc, update=False)\n\n        self.setTransform(tr)\n        if update:\n            self.stateChanged(finish=finish)\n\n    def scale(self, s, center=None, centerLocal=None, snap=False, update=True,\n              finish=True):\n        """"""\n        Resize the ROI by scaling relative to *center*.\n        See setPos() for an explanation of the *update* and *finish* arguments.\n        """"""\n        newSize = self.state[\'size\'] * s\n        self.setSize(newSize, center=center, centerLocal=centerLocal, snap=snap,\n                     update=update, finish=finish)\n\n    def translate(self, *args, **kargs):\n        """"""\n        Move the ROI to a new position.\n        Accepts either (x, y, snap) or ([x,y], snap) as arguments\n        If the ROI is bounded and the move would exceed boundaries, then the ROI\n        is moved to the nearest acceptable position instead.\n\n        *snap* can be:\n\n        =============== ==========================================================================\n        None (default)  use self.translateSnap and self.snapSize to determine whether/how to snap\n        False           do not snap\n        Point(w,h)      snap to rectangular grid with spacing (w,h)\n        True            snap using self.snapSize (and ignoring self.translateSnap)\n        =============== ==========================================================================\n\n        Also accepts *update* and *finish* arguments (see setPos() for a description of these).\n        """"""\n\n        if len(args) == 1:\n            pt = args[0]\n        else:\n            pt = args\n\n        newState = self.stateCopy()\n        newState[\'pos\'] = newState[\'pos\'] + pt\n\n        snap = kargs.get(\'snap\', None)\n        if snap is None:\n            snap = self.translateSnap\n        if snap is not False:\n            newState[\'pos\'] = self.getSnapPosition(newState[\'pos\'], snap=snap)\n\n        if self.maxBounds is not None:\n            r = self.stateRect(newState)\n            d = Point(0, 0)\n            if self.maxBounds.left() > r.left():\n                d[0] = self.maxBounds.left() - r.left()\n            elif self.maxBounds.right() < r.right():\n                d[0] = self.maxBounds.right() - r.right()\n            if self.maxBounds.top() > r.top():\n                d[1] = self.maxBounds.top() - r.top()\n            elif self.maxBounds.bottom() < r.bottom():\n                d[1] = self.maxBounds.bottom() - r.bottom()\n            newState[\'pos\'] += d\n\n        update = kargs.get(\'update\', True)\n        finish = kargs.get(\'finish\', True)\n        self.setPos(newState[\'pos\'], update=update, finish=finish)\n\n    def rotate(self, angle, center=None, snap=False, update=True, finish=True):\n        """"""\n        Rotate the ROI by *angle* degrees.\n\n        =============== ==========================================================================\n        **Arguments**\n        angle           (float) The angle in degrees to rotate\n        center          (None | Point) Optional center point around which the ROI is rotated, in\n                        the local coordinate system of the ROI\n        snap            (bool) If True, the final ROI angle is snapped to the nearest increment\n                        (default is 15 degrees; see ROI.rotateSnapAngle)\n        update          (bool) See setPos()\n        finish          (bool) See setPos()\n        =============== ==========================================================================\n        """"""\n        self.setAngle(self.angle() + angle, center=center, snap=snap,\n                      update=update, finish=finish)\n\n    def handleMoveStarted(self):\n        self.preMoveState = self.getState()\n\n    def addTranslateHandle(self, pos, axes=None, item=None, name=None,\n                           index=None):\n        """"""\n        Add a new translation handle to the ROI. Dragging the handle will move\n        the entire ROI without changing its angle or shape.\n\n        Note that, by default, ROIs may be moved by dragging anywhere inside the\n        ROI. However, for larger ROIs it may be desirable to disable this and\n        instead provide one or more translation handles.\n\n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle\n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are\n                            identified by name when calling\n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        return self.addHandle({\'name\': name, \'type\': \'t\', \'pos\': pos, \'item\': item}, index=index)\n\n    def addFreeHandle(self, pos=None, axes=None, item=None, name=None,\n                      index=None):\n        """"""\n        Add a new free handle to the ROI. Dragging free handles has no effect\n        on the position or shape of the ROI.\n\n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle\n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are\n                            identified by name when calling\n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        if pos is not None:\n            pos = Point(pos)\n        return self.addHandle({\'name\': name, \'type\': \'f\', \'pos\': pos, \'item\': item}, index=index)\n\n    def addScaleHandle(self, pos, center, axes=None, item=None, name=None,\n                       lockAspect=False, index=None):\n        """"""\n        Add a new scale handle to the ROI. Dragging a scale handle allows the\n        user to change the height and/or width of the ROI.\n\n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle\n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        center              (length-2 sequence) The center point around which\n                            scaling takes place. If the center point has the\n                            same x or y value as the handle position, then\n                            scaling will be disabled for that axis.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are\n                            identified by name when calling\n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        center = Point(center)\n        info = {\'name\': name, \'type\': \'s\', \'center\': center, \'pos\': pos,\n                \'item\': item, \'lockAspect\': lockAspect}\n        if pos.x() == center.x():\n            info[\'xoff\'] = True\n        if pos.y() == center.y():\n            info[\'yoff\'] = True\n        return self.addHandle(info, index=index)\n\n    def addRotateHandle(self, pos, center, item=None, name=None, index=None):\n        """"""\n        Add a new rotation handle to the ROI. Dragging a rotation handle allows\n        the user to change the angle of the ROI.\n\n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle\n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        center              (length-2 sequence) The center point around which\n                            rotation takes place.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are\n                            identified by name when calling\n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        center = Point(center)\n        return self.addHandle({\'name\': name, \'type\': \'r\', \'center\': center, \'pos\': pos, \'item\': item}, index=index)\n\n    def addScaleRotateHandle(self, pos, center, item=None, name=None,\n                             index=None):\n        """"""\n        Add a new scale+rotation handle to the ROI. When dragging a handle of\n        this type, the user can simultaneously rotate the ROI around an\n        arbitrary center point as well as scale the ROI by dragging the handle\n        toward or away from the center point.\n\n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle\n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        center              (length-2 sequence) The center point around which\n                            scaling and rotation take place.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are\n                            identified by name when calling\n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        center = Point(center)\n        if pos[0] != center[0] and pos[1] != center[1]:\n            raise Exception(\n                ""Scale/rotate handles must have either the same x or y coordinate as their center point."")\n        return self.addHandle({\'name\': name, \'type\': \'sr\', \'center\': center, \'pos\': pos, \'item\': item}, index=index)\n\n    def addRotateFreeHandle(self, pos, center, axes=None, item=None, name=None,\n                            index=None):\n        """"""\n        Add a new rotation+free handle to the ROI. When dragging a handle of\n        this type, the user can rotate the ROI around an\n        arbitrary center point, while moving toward or away from the center\n        point has no effect on the shape of the ROI.\n\n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle\n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        center              (length-2 sequence) The center point around which\n                            rotation takes place.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are\n                            identified by name when calling\n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        center = Point(center)\n        return self.addHandle({\'name\': name, \'type\': \'rf\', \'center\': center, \'pos\': pos, \'item\': item}, index=index)\n\n    def addHandle(self, info, index=None):\n        ## If a Handle was not supplied, create it now\n        if \'item\' not in info or info[\'item\'] is None:\n            h = Handle(self.handleSize, typ=info[\'type\'], pen=self.handlePen, parent=self, invisible=self.invisible)\n            h.setPos(info[\'pos\'] * self.state[\'size\'])\n            info[\'item\'] = h\n        else:\n            h = info[\'item\']\n            if info[\'pos\'] is None:\n                info[\'pos\'] = h.pos()\n\n        ## connect the handle to this ROI\n        # iid = len(self.handles)\n        h.connectROI(self)\n        if index is None:\n            self.handles.append(info)\n        else:\n            self.handles.insert(index, info)\n\n        h.setZValue(self.zValue() + 1)\n        self.stateChanged()\n        return h\n\n    def indexOfHandle(self, handle):\n        """"""\n        Return the index of *handle* in the list of this ROI\'s handles.\n        """"""\n        if isinstance(handle, Handle):\n            index = [i for i, info in enumerate(self.handles) if\n                     info[\'item\'] is handle]\n            if len(index) == 0:\n                raise Exception(\n                    ""Cannot return handle index; not attached to this ROI"")\n            return index[0]\n        else:\n            return handle\n\n    def removeHandle(self, handle):\n        """"""Remove a handle from this ROI. Argument may be either a Handle\n        instance or the integer index of the handle.""""""\n        index = self.indexOfHandle(handle)\n\n        handle = self.handles[index][\'item\']\n        self.handles.pop(index)\n        handle.disconnectROI(self)\n        if len(handle.rois) == 0:\n            self.scene().removeItem(handle)\n        self.stateChanged()\n\n    def replaceHandle(self, oldHandle, newHandle):\n        """"""Replace one handle in the ROI for another. This is useful when\n        connecting multiple ROIs together.\n\n        *oldHandle* may be a Handle instance or the index of a handle to be\n        replaced.""""""\n        index = self.indexOfHandle(oldHandle)\n        info = self.handles[index]\n        self.removeHandle(index)\n        info[\'item\'] = newHandle\n        info[\'pos\'] = newHandle.pos()\n        self.addHandle(info, index=index)\n\n    def checkRemoveHandle(self, handle):\n        ## This is used when displaying a Handle\'s context menu to determine\n        ## whether removing is allowed.\n        ## Subclasses may wish to override this to disable the menu entry.\n        ## Note: by default, handles are not user-removable even if this method returns True.\n        return True\n\n    def getLocalHandlePositions(self, index=None):\n        """"""Returns the position of handles in the ROI\'s coordinate system.\n\n        The format returned is a list of (name, pos) tuples.\n        """"""\n        if index == None:\n            positions = []\n            for h in self.handles:\n                positions.append((h[\'name\'], h[\'pos\']))\n            return positions\n        else:\n            return (self.handles[index][\'name\'], self.handles[index][\'pos\'])\n\n    def getSceneHandlePositions(self, index=None):\n        """"""Returns the position of handles in the scene coordinate system.\n\n        The format returned is a list of (name, pos) tuples.\n        """"""\n        if index == None:\n            positions = []\n            for h in self.handles:\n                positions.append((h[\'name\'], h[\'item\'].scenePos()))\n            return positions\n        else:\n            return (\n            self.handles[index][\'name\'], self.handles[index][\'item\'].scenePos())\n\n    def getHandles(self):\n        """"""\n        Return a list of this ROI\'s Handles.\n        """"""\n        return [h[\'item\'] for h in self.handles]\n\n    def mapSceneToParent(self, pt):\n        return self.mapToParent(self.mapFromScene(pt))\n\n    def setSelected(self, s):\n        QtGui.QGraphicsItem.setSelected(self, s)\n        # print ""select"", self, s\n        if s:\n            for h in self.handles:\n                h[\'item\'].show()\n        else:\n            for h in self.handles:\n                h[\'item\'].hide()\n\n    def hoverEvent(self, ev):\n        if not self.allowed_interaction:\n            return\n        hover = False\n        if not ev.isExit():\n            if self.translatable and ev.acceptDrags(QtCore.Qt.LeftButton):\n                hover = True\n\n            for btn in [QtCore.Qt.LeftButton, QtCore.Qt.RightButton, QtCore.Qt.MidButton]:\n                if int(self.acceptedMouseButtons() & btn) > 0 and ev.acceptClicks(btn):\n                    hover = True\n            if self.contextMenuEnabled():\n                ev.acceptClicks(QtCore.Qt.RightButton)\n\n        if hover:\n            self.setMouseHover(True)\n            self.sigHoverEvent.emit(self)\n            ev.acceptClicks(QtCore.Qt.LeftButton)  ## If the ROI is highlighted, we should accept all clicks to avoid confusion.\n            ev.acceptClicks(QtCore.Qt.RightButton)\n            ev.acceptClicks(QtCore.Qt.MidButton)\n        else:\n            self.setMouseHover(False)\n\n    def setMouseHover(self, hover):\n        ## Inform the ROI that the mouse is(not) hovering over it\n        if self.mouseHovering == hover:\n            return\n        self.mouseHovering = hover\n        self._updateHoverColor()\n\n    def _updateHoverColor(self):\n        if self.allowed_interaction:\n            pen = self._makePen()\n            if self.currentPen != pen:\n                self.currentPen = pen\n                self.update()\n\n    def _makePen(self):\n        # Generate the pen color for this ROI based on its current state.\n        if self.mouseHovering:\n            return GUI_default[\'ROI_highlighted_segment_pen\']\n        else:\n            return self.pen\n\n    def contextMenuEnabled(self):\n        return self.removable\n\n    def raiseContextMenu(self, ev):\n        if not self.contextMenuEnabled():\n            return\n        menu = self.getMenu()\n        # menu = self.scene().addParentContextMenus(self, menu, ev)\n        pos = ev.screenPos()\n        menu.popup(QtCore.QPoint(pos.x(), pos.y()))\n\n    def getMenu(self):\n        if self.menu is None:\n            self.menu = QtWidgets.QMenu()\n            self.menu.setTitle(""ROI"")\n            remAct = QtWidgets.QAction(""Remove ROI"", self.menu)\n            remAct.triggered.connect(self.removeClicked)\n            self.menu.addAction(remAct)\n            self.menu.remAct = remAct\n        return self.menu\n\n    def removeClicked(self):\n        ## Send remove event only after we have exited the menu event handler\n        QtCore.QTimer.singleShot(0, lambda: self.sigRemoveRequested.emit(self))\n\n    def mouseDragEvent(self, ev):\n        self.mouseDragHandler.mouseDragEvent(ev)\n\n    def mouseClickEvent(self, ev):\n        if ev.button() == QtCore.Qt.RightButton and self.isMoving:\n            ev.accept()\n            self.cancelMove()\n        if ev.button() == QtCore.Qt.RightButton and self.contextMenuEnabled():\n            self.raiseContextMenu(ev)\n            ev.accept()\n        elif int(ev.button() & self.acceptedMouseButtons()) > 0:\n            ev.accept()\n            self.sigClicked.emit(self, ev)\n        else:\n            ev.ignore()\n\n    def _moveStarted(self):\n        self.isMoving = True\n        self.preMoveState = self.getState()\n        self.sigRegionChangeStarted.emit(self)\n\n    def _moveFinished(self):\n        if self.isMoving:\n            self.stateChangeFinished()\n        self.isMoving = False\n\n    def cancelMove(self):\n        self.isMoving = False\n        self.setState(self.preMoveState)\n\n    def checkPointMove(self, handle, pos, modifiers):\n        """"""When handles move, they must ask the ROI if the move is acceptable.\n        By default, this always returns True. Subclasses may wish override.\n        """"""\n        return True\n\n    def movePoint(self, handle, pos, modifiers=QtCore.Qt.KeyboardModifier(),\n                  finish=True, coords=\'parent\'):\n        ## called by Handles when they are moved.\n        ## pos is the new position of the handle in scene coords, as requested by the handle.\n\n        newState = self.stateCopy()\n        index = self.indexOfHandle(handle)\n        h = self.handles[index]\n        p0 = self.mapToParent(h[\'pos\'] * self.state[\'size\'])\n        p1 = Point(pos)\n\n        if coords == \'parent\':\n            pass\n        elif coords == \'scene\':\n            p1 = self.mapSceneToParent(p1)\n        else:\n            raise Exception(\n                ""New point location must be given in either \'parent\' or \'scene\' coordinates."")\n\n        ## Handles with a \'center\' need to know their local position relative to the center point (lp0, lp1)\n        if \'center\' in h:\n            c = h[\'center\']\n            cs = c * self.state[\'size\']\n            lp0 = self.mapFromParent(p0) - cs\n            lp1 = self.mapFromParent(p1) - cs\n\n        if h[\'type\'] == \'t\':\n            snap = True if (modifiers & QtCore.Qt.ControlModifier) else None\n            self.translate(p1 - p0, snap=snap, update=False)\n\n        elif h[\'type\'] == \'f\':\n            newPos = self.mapFromParent(p1)\n            h[\'item\'].setPos(newPos)\n            h[\'pos\'] = newPos\n            self.freeHandleMoved = True\n\n        elif h[\'type\'] == \'s\':\n            ## If a handle and its center have the same x or y value, we can\'t scale across that axis.\n            if h[\'center\'][0] == h[\'pos\'][0]:\n                lp1[0] = 0\n            if h[\'center\'][1] == h[\'pos\'][1]:\n                lp1[1] = 0\n\n            ## snap\n            if self.scaleSnap or (modifiers & QtCore.Qt.ControlModifier):\n                lp1[0] = round(lp1[0] / self.scaleSnapSize) * self.scaleSnapSize\n                lp1[1] = round(lp1[1] / self.scaleSnapSize) * self.scaleSnapSize\n\n            ## preserve aspect ratio (this can override snapping)\n            if h[\'lockAspect\'] or (modifiers & QtCore.Qt.AltModifier):\n                # arv = Point(self.preMoveState[\'size\']) -\n                lp1 = lp1.proj(lp0)\n\n            ## determine scale factors and new size of ROI\n            hs = h[\'pos\'] - c\n            if hs[0] == 0:\n                hs[0] = 1\n            if hs[1] == 0:\n                hs[1] = 1\n            newSize = lp1 / hs\n\n            ## Perform some corrections and limit checks\n            if newSize[0] == 0:\n                newSize[0] = newState[\'size\'][0]\n            if newSize[1] == 0:\n                newSize[1] = newState[\'size\'][1]\n            if not self.invertible:\n                if newSize[0] < 0:\n                    newSize[0] = newState[\'size\'][0]\n                if newSize[1] < 0:\n                    newSize[1] = newState[\'size\'][1]\n            if self.aspectLocked:\n                newSize[0] = newSize[1]\n\n            ## Move ROI so the center point occupies the same scene location after the scale\n            s0 = c * self.state[\'size\']\n            s1 = c * newSize\n            cc = self.mapToParent(s0 - s1) - self.mapToParent(Point(0, 0))\n\n            ## update state, do more boundary checks\n            newState[\'size\'] = newSize\n            newState[\'pos\'] = newState[\'pos\'] + cc\n            if self.maxBounds is not None:\n                r = self.stateRect(newState)\n                if not self.maxBounds.contains(r):\n                    return\n\n            self.setPos(newState[\'pos\'], update=False)\n            self.setSize(newState[\'size\'], update=False)\n\n        elif h[\'type\'] in [\'r\', \'rf\']:\n            if h[\'type\'] == \'rf\':\n                self.freeHandleMoved = True\n\n            if not self.rotatable:\n                return\n            ## If the handle is directly over its center point, we can\'t compute an angle.\n            try:\n                if lp1.length() == 0 or lp0.length() == 0:\n                    return\n            except OverflowError:\n                return\n\n            ## determine new rotation angle, constrained if necessary\n            ang = newState[\'angle\'] - lp0.angle(lp1)\n            if ang is None:  ## this should never happen..\n                return\n            if self.rotateSnap or (modifiers & QtCore.Qt.ControlModifier):\n                ang = round(ang / self.rotateSnapAngle) * self.rotateSnapAngle\n\n            ## create rotation transform\n            tr = QtGui.QTransform()\n            tr.rotate(ang)\n\n            ## move ROI so that center point remains stationary after rotate\n            cc = self.mapToParent(cs) - (tr.map(cs) + self.state[\'pos\'])\n            newState[\'angle\'] = ang\n            newState[\'pos\'] = newState[\'pos\'] + cc\n\n            ## check boundaries, update\n            if self.maxBounds is not None:\n                r = self.stateRect(newState)\n                if not self.maxBounds.contains(r):\n                    return\n            self.setPos(newState[\'pos\'], update=False)\n            self.setAngle(ang, update=False)\n\n            ## If this is a free-rotate handle, its distance from the center may change.\n\n            if h[\'type\'] == \'rf\':\n                h[\'item\'].setPos(\n                    self.mapFromScene(p1))  ## changes ROI coordinates of handle\n\n        elif h[\'type\'] == \'sr\':\n            if h[\'center\'][0] == h[\'pos\'][0]:\n                scaleAxis = 1\n                nonScaleAxis = 0\n            else:\n                scaleAxis = 0\n                nonScaleAxis = 1\n\n            try:\n                if lp1.length() == 0 or lp0.length() == 0:\n                    return\n            except OverflowError:\n                return\n\n            ang = newState[\'angle\'] - lp0.angle(lp1)\n            if ang is None:\n                return\n            if self.rotateSnap or (modifiers & QtCore.Qt.ControlModifier):\n                ang = round(ang / self.rotateSnapAngle) * self.rotateSnapAngle\n\n            hs = abs(h[\'pos\'][scaleAxis] - c[scaleAxis])\n            newState[\'size\'][scaleAxis] = lp1.length() / hs\n            # if self.scaleSnap or (modifiers & QtCore.Qt.ControlModifier):\n            if self.scaleSnap:  ## use CTRL only for angular snap here.\n                newState[\'size\'][scaleAxis] = round(\n                    newState[\'size\'][scaleAxis] / self.snapSize) * self.snapSize\n            if newState[\'size\'][scaleAxis] == 0:\n                newState[\'size\'][scaleAxis] = 1\n            if self.aspectLocked:\n                newState[\'size\'][nonScaleAxis] = newState[\'size\'][scaleAxis]\n\n            c1 = c * newState[\'size\']\n            tr = QtGui.QTransform()\n            tr.rotate(ang)\n\n            cc = self.mapToParent(cs) - (tr.map(c1) + self.state[\'pos\'])\n            newState[\'angle\'] = ang\n            newState[\'pos\'] = newState[\'pos\'] + cc\n            if self.maxBounds is not None:\n                r = self.stateRect(newState)\n                if not self.maxBounds.contains(r):\n                    return\n\n            self.setState(newState, update=False)\n\n        self.stateChanged(finish=finish)\n\n    def stateChanged(self, finish=True):\n        """"""Process changes to the state of the ROI.\n        If there are any changes, then the positions of handles are updated accordingly\n        and sigRegionChanged is emitted. If finish is True, then\n        sigRegionChangeFinished will also be emitted.""""""\n\n        changed = False\n        if self.lastState is None:\n            changed = True\n        else:\n            state = self.getState()\n            for k in list(state.keys()):\n                if state[k] != self.lastState[k]:\n                    changed = True\n\n        self.prepareGeometryChange()\n        if changed:\n            ## Move all handles to match the current configuration of the ROI\n            for h in self.handles:\n                if h[\'item\'] in self.childItems():\n                    p = h[\'pos\']\n                    h[\'item\'].setPos(h[\'pos\'] * self.state[\'size\'])\n\n            self.update()\n            self.sigRegionChanged.emit(self)\n        elif self.freeHandleMoved:\n            self.sigRegionChanged.emit(self)\n\n        self.freeHandleMoved = False\n        self.lastState = self.getState()\n\n        if finish:\n            self.stateChangeFinished()\n            self.informViewBoundsChanged()\n\n    def stateChangeFinished(self):\n        self.sigRegionChangeFinished.emit(self)\n\n    def stateRect(self, state):\n        r = QtCore.QRectF(0, 0, state[\'size\'][0], state[\'size\'][1])\n        tr = QtGui.QTransform()\n        tr.rotate(-state[\'angle\'])\n        r = tr.mapRect(r)\n        return r.adjusted(state[\'pos\'][0], state[\'pos\'][1], state[\'pos\'][0],\n                          state[\'pos\'][1])\n\n    def getSnapPosition(self, pos, snap=None):\n        ## Given that pos has been requested, return the nearest snap-to position\n        ## optionally, snap may be passed in to specify a rectangular snap grid.\n        ## override this function for more interesting snap functionality..\n\n        if snap is None or snap is True:\n            if self.snapSize is None:\n                return pos\n            snap = Point(self.snapSize, self.snapSize)\n\n        return Point(round(pos[0] / snap[0]) * snap[0],\n                     round(pos[1] / snap[1]) * snap[1])\n\n    def boundingRect(self):\n        return QtCore.QRectF(0, 0, self.state[\'size\'][0],\n                             self.state[\'size\'][1]).normalized()\n\n    def paint(self, p, opt, widget):\n        # Note: don\'t use self.boundingRect here, because subclasses may need to redefine it.\n        r = QtCore.QRectF(0, 0, self.state[\'size\'][0],\n                          self.state[\'size\'][1]).normalized()\n\n        p.setRenderHint(QtGui.QPainter.Antialiasing)\n        p.setPen(self.currentPen)\n        p.translate(r.left(), r.top())\n        p.scale(r.width(), r.height())\n        p.drawRect(0, 0, 1, 1)\n\n    def getArraySlice(self, data, img, axes=(0, 1), returnSlice=True):\n        """"""Return a tuple of slice objects that can be used to slice the region\n        from *data* that is covered by the bounding rectangle of this ROI.\n        Also returns the transform that maps the ROI into data coordinates.\n\n        If returnSlice is set to False, the function returns a pair of tuples with the values that would have\n        been used to generate the slice objects. ((ax0Start, ax0Stop), (ax1Start, ax1Stop))\n\n        If the slice cannot be computed (usually because the scene/transforms are not properly\n        constructed yet), then the method returns None.\n        """"""\n        ## Determine shape of array along ROI axes\n        dShape = (data.shape[axes[0]], data.shape[axes[1]])\n\n        ## Determine transform that maps ROI bounding box to image coordinates\n        try:\n            tr = self.sceneTransform() * fn.invertQTransform(\n                img.sceneTransform())\n        except np.linalg.linalg.LinAlgError:\n            return None\n\n        ## Modify transform to scale from image coords to data coords\n        axisOrder = img.axisOrder\n        if axisOrder == \'row-major\':\n            tr.scale(float(dShape[1]) / img.width(),\n                     float(dShape[0]) / img.height())\n        else:\n            tr.scale(float(dShape[0]) / img.width(),\n                     float(dShape[1]) / img.height())\n\n        ## Transform ROI bounds into data bounds\n        dataBounds = tr.mapRect(self.boundingRect())\n\n        ## Intersect transformed ROI bounds with data bounds\n        if axisOrder == \'row-major\':\n            intBounds = dataBounds.intersected(\n                QtCore.QRectF(0, 0, dShape[1], dShape[0]))\n        else:\n            intBounds = dataBounds.intersected(\n                QtCore.QRectF(0, 0, dShape[0], dShape[1]))\n\n        ## Determine index values to use when referencing the array.\n        bounds = ((int(min(intBounds.left(), intBounds.right())),\n                   int(1 + max(intBounds.left(), intBounds.right()))), (\n                  int(min(intBounds.bottom(), intBounds.top())),\n                  int(1 + max(intBounds.bottom(), intBounds.top()))))\n        if axisOrder == \'row-major\':\n            bounds = bounds[::-1]\n\n        if returnSlice:\n            ## Create slice objects\n            sl = [slice(None)] * data.ndim\n            sl[axes[0]] = slice(*bounds[0])\n            sl[axes[1]] = slice(*bounds[1])\n            return tuple(sl), tr\n        else:\n            return bounds, tr\n\n    def getArrayRegion(self, data, img, axes=(0, 1), returnMappedCoords=False,\n                       **kwds):\n        """"""Use the position and orientation of this ROI relative to an imageItem\n        to pull a slice from an array.\n\n        =================== ====================================================\n        **Arguments**\n        data                The array to slice from. Note that this array does\n                            *not* have to be the same data that is represented\n                            in *img*.\n        img                 (ImageItem or other suitable QGraphicsItem)\n                            Used to determine the relationship between the\n                            ROI and the boundaries of *data*.\n        axes                (length-2 tuple) Specifies the axes in *data* that\n                            correspond to the (x, y) axes of *img*. If the\n                            image\'s axis order is set to\n                            \'row-major\', then the axes are instead specified in\n                            (y, x) order.\n        returnMappedCoords  (bool) If True, the array slice is returned along\n                            with a corresponding array of coordinates that were\n                            used to extract data from the original array.\n        \\**kwds             All keyword arguments are passed to\n                            :func:`affineSlice <pyqtgraph.affineSlice>`.\n        =================== ====================================================\n\n        This method uses :func:`affineSlice <pyqtgraph.affineSlice>` to generate\n        the slice from *data* and uses :func:`getAffineSliceParams <pyqtgraph.ROI.getAffineSliceParams>`\n        to determine the parameters to pass to :func:`affineSlice <pyqtgraph.affineSlice>`.\n\n        If *returnMappedCoords* is True, then the method returns a tuple (result, coords)\n        such that coords is the set of coordinates used to interpolate values from the original\n        data, mapped into the parent coordinate system of the image. This is useful, when slicing\n        data from images that have been transformed, for determining the location of each value\n        in the sliced data.\n\n        All extra keyword arguments are passed to :func:`affineSlice <pyqtgraph.affineSlice>`.\n        """"""\n        # this is a hidden argument for internal use\n        fromBR = kwds.pop(\'fromBoundingRect\', False)\n\n        shape, vectors, origin = self.getAffineSliceParams(data, img, axes, fromBoundingRect=fromBR)\n        if not returnMappedCoords:\n            rgn = fn.affineSlice(data, shape=shape, vectors=vectors, origin=origin, axes=axes, **kwds)\n            return rgn\n        else:\n            kwds[\'returnCoords\'] = True\n            result, coords = fn.affineSlice(data, shape=shape, vectors=vectors, origin=origin, axes=axes, **kwds)\n\n            ### map coordinates and return\n            mapped = fn.transformCoordinates(img.transform(), coords)\n            return result, mapped\n\n    def getAffineSliceParams(self, data, img, axes=(0, 1),\n                             fromBoundingRect=False):\n        """"""\n        Returns the parameters needed to use :func:`affineSlice <pyqtgraph.affineSlice>`\n        (shape, vectors, origin) to extract a subset of *data* using this ROI\n        and *img* to specify the subset.\n\n        If *fromBoundingRect* is True, then the ROI\'s bounding rectangle is used\n        rather than the shape of the ROI.\n\n        See :func:`getArrayRegion <pyqtgraph.ROI.getArrayRegion>` for more information.\n        """"""\n        if self.scene() is not img.scene():\n            raise Exception(""ROI and target item must be members of the same scene."")\n\n        origin = img.mapToData(self.mapToItem(img, QtCore.QPointF(0, 0)))\n\n        ## vx and vy point in the directions of the slice axes, but must be scaled properly\n        vx = img.mapToData(self.mapToItem(img, QtCore.QPointF(1, 0))) - origin\n        vy = img.mapToData(self.mapToItem(img, QtCore.QPointF(0, 1))) - origin\n\n        lvx = np.sqrt(vx.x() ** 2 + vx.y() ** 2)\n        lvy = np.sqrt(vy.x() ** 2 + vy.y() ** 2)\n        ##img.width is number of pixels, not width of item.\n        ##need pxWidth and pxHeight instead of pxLen ?\n        sx = 1.0 / lvx\n        sy = 1.0 / lvy\n\n        vectors = ((vx.x() * sx, vx.y() * sx), (vy.x() * sy, vy.y() * sy))\n        if fromBoundingRect is True:\n            shape = self.boundingRect().width(), self.boundingRect().height()\n            origin = img.mapToData(self.mapToItem(img, self.boundingRect().topLeft()))\n            origin = (origin.x(), origin.y())\n        else:\n            shape = self.state[\'size\']\n            origin = (origin.x(), origin.y())\n\n        shape = [abs(shape[0] / sx), abs(shape[1] / sy)]\n\n        if img.axisOrder == \'row-major\':\n            # transpose output\n            vectors = vectors[::-1]\n            shape = shape[::-1]\n\n        return shape, vectors, origin\n\n    def renderShapeMask(self, width, height):\n        """"""Return an array of 0.0-1.0 into which the shape of the item has been drawn.\n\n        This can be used to mask array selections.\n        """"""\n        if width == 0 or height == 0:\n            return np.empty((width, height), dtype=float)\n\n        im = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32)\n        im.fill(0x0)\n        p = QtGui.QPainter(im)\n        p.setPen(fn.mkPen(None))\n        p.setBrush(fn.mkBrush(\'w\'))\n        shape = self.shape()\n        bounds = shape.boundingRect()\n        p.scale(im.width() / bounds.width(), im.height() / bounds.height())\n        p.translate(-bounds.topLeft())\n        p.drawPath(shape)\n        p.end()\n        mask = fn.imageToArray(im, transpose=True)[:, :, 0].astype(float) / 255.\n        return mask\n\n    def getGlobalTransform(self, relativeTo=None):\n        """"""Return global transformation (rotation angle+translation) required to move\n        from relative state to current state. If relative state isn\'t specified,\n        then we use the state of the ROI when mouse is pressed.""""""\n        if relativeTo == None:\n            relativeTo = self.preMoveState\n        st = self.getState()\n\n        ## this is only allowed because we will be comparing the two\n        relativeTo[\'scale\'] = relativeTo[\'size\']\n        st[\'scale\'] = st[\'size\']\n\n        t1 = SRTTransform(relativeTo)\n        t2 = SRTTransform(st)\n        return t2 / t1\n\n    def applyGlobalTransform(self, tr):\n        st = self.getState()\n\n        st[\'scale\'] = st[\'size\']\n        st = SRTTransform(st)\n        st = (st * tr).saveState()\n        st[\'size\'] = st[\'scale\']\n        self.setState(st)\n\n\nclass Handle(UIGraphicsItem):\n    """"""\n    Handle represents a single user-interactable point attached to an ROI. They\n    are usually created by a call to one of the ROI.add___Handle() methods.\n\n    Handles are represented as a square, diamond, or circle, and are drawn with\n    fixed pixel size regardless of the scaling of the view they are displayed in.\n\n    Handles may be dragged to change the position, size, orientation, or other\n    properties of the ROI they are attached to.\n    """"""\n    types = {  ## defines number of sides, start angle for each handle type\n        \'t\' : (4, np.pi / 4), \'f\': (4, np.pi / 4), \'s\': (4, 0), \'r\': (12, 0),\n        \'sr\': (12, 0), \'rf\': (12, 0), }\n\n    sigClicked = QtCore.Signal(object, object)  # self, event\n    sigRemoveRequested = QtCore.Signal(object)  # self\n\n    def __init__(self, radius, typ=None, pen=None, parent=None, deletable=False, invisible=True):\n        self.rois = []\n        self.radius = radius\n        self.typ = typ\n        self.pen = pen\n        self.isMoving = False\n        self.sides, self.startAng = self.types[typ]\n        self.buildPath()\n        self._shape = None\n        self.menu = self.buildMenu()\n        self.invisible = invisible\n        if not self.invisible:\n            self.pen = GUI_default[\'ROI_highlighted_segment_pen\']\n            self.inactivePen = GUI_default[\'ROI_highlighted_segment_pen\']\n        else:\n            self.pen.setWidth(0)\n            self.inactivePen = pg.mkPen(None)\n        self.currentPen = self.pen\n\n        UIGraphicsItem.__init__(self, parent=parent)\n        self.setAcceptedMouseButtons(QtCore.Qt.NoButton)\n        self.deletable = deletable\n        if deletable:\n            self.setAcceptedMouseButtons(QtCore.Qt.RightButton)\n        self.setZValue(11)\n\n    def connectROI(self, roi):\n        ### roi is the ""parent"" roi, i is the index of the handle in roi.handles\n        self.rois.append(roi)\n\n    def disconnectROI(self, roi):\n        self.rois.remove(roi)\n\n    def setDeletable(self, b):\n        self.deletable = b\n        if b:\n            self.setAcceptedMouseButtons(self.acceptedMouseButtons() | QtCore.Qt.RightButton)\n        else:\n            self.setAcceptedMouseButtons(self.acceptedMouseButtons() & ~QtCore.Qt.RightButton)\n\n    def removeClicked(self):\n        self.sigRemoveRequested.emit(self)\n\n    def hoverEvent(self, ev):\n        can_hover = [roi.allowed_interaction for roi in self.rois]\n        if not all(can_hover):\n            return\n        hover = False\n        if not ev.isExit():\n            if ev.acceptDrags(QtCore.Qt.LeftButton):\n                hover = True\n            for btn in [QtCore.Qt.LeftButton, QtCore.Qt.RightButton, QtCore.Qt.MidButton]:\n                if int(self.acceptedMouseButtons() & btn) > 0 and ev.acceptClicks(btn):\n                    hover = True\n        if hover:\n            self.currentPen = GUI_default[\'ROI_highlighted_segment_pen\']\n        else:\n            self.currentPen = self.inactivePen\n        self.update()\n\n    def mouseClickEvent(self, ev):\n        ## right-click cancels drag\n        if ev.button() == QtCore.Qt.RightButton and self.isMoving:\n            self.isMoving = False  ## prevents any further motion\n            self.movePoint(self.startPos, finish=True)\n            ev.accept()\n        elif int(ev.button() & self.acceptedMouseButtons()) > 0:\n            ev.accept()\n            if ev.button() == QtCore.Qt.RightButton and self.deletable:\n                self.raiseContextMenu(ev)\n            self.sigClicked.emit(self, ev)\n        else:\n            ev.ignore()\n\n    def buildMenu(self):\n        menu = QtGui.QMenu()\n        menu.setTitle(""Handle"")\n        self.removeAction = menu.addAction(""Remove handle"", self.removeClicked)\n        return menu\n\n    def getMenu(self):\n        return self.menu\n\n    def raiseContextMenu(self, ev):\n        menu = self.scene().addParentContextMenus(self, self.getMenu(), ev)\n\n        ## Make sure it is still ok to remove this handle\n        removeAllowed = all([r.checkRemoveHandle(self) for r in self.rois])\n        self.removeAction.setEnabled(removeAllowed)\n        pos = ev.screenPos()\n        menu.popup(QtCore.QPoint(pos.x(), pos.y()))\n\n    def mouseDragEvent(self, ev):\n        if ev.button() != QtCore.Qt.LeftButton:\n            return\n        ev.accept()\n\n        ## Inform ROIs that a drag is happening\n        ##  note: the ROI is informed that the handle has moved using ROI.movePoint\n        ##  this is for other (more nefarious) purposes.\n        # for r in self.roi:\n        # r[0].pointDragEvent(r[1], ev)\n\n        if ev.isFinish():\n            if self.isMoving:\n                for r in self.rois:\n                    r.stateChangeFinished()\n            self.isMoving = False\n        elif ev.isStart():\n            for r in self.rois:\n                r.handleMoveStarted()\n            self.isMoving = True\n            self.startPos = self.scenePos()\n            self.cursorOffset = self.scenePos() - ev.buttonDownScenePos()\n\n        if self.isMoving:  ## note: isMoving may become False in mid-drag due to right-click.\n            pos = ev.scenePos() + self.cursorOffset\n            self.movePoint(pos, ev.modifiers(), finish=False)\n\n    def movePoint(self, pos, modifiers=QtCore.Qt.KeyboardModifier(),\n                  finish=True):\n        for r in self.rois:\n            if not r.checkPointMove(self, pos, modifiers):\n                return\n        # print ""point moved; inform %d ROIs"" % len(self.roi)\n        # A handle can be used by multiple ROIs; tell each to update its handle position\n        for r in self.rois:\n            r.movePoint(self, pos, modifiers, finish=finish, coords=\'scene\')\n\n    def buildPath(self):\n        size = self.radius\n        self.path = QtGui.QPainterPath()\n        ang = self.startAng\n        dt = 2 * np.pi / self.sides\n        for i in range(0, self.sides + 1):\n            x = size * cos(ang)\n            y = size * sin(ang)\n            ang += dt\n            if i == 0:\n                self.path.moveTo(x, y)\n            else:\n                self.path.lineTo(x, y)\n\n    def paint(self, p, opt, widget):\n        p.setRenderHints(p.Antialiasing, True)\n        p.setPen(self.currentPen)\n\n        p.drawPath(self.shape())\n\n    def shape(self):\n        if self._shape is None:\n            s = self.generateShape()\n            if s is None:\n                return self.path\n            self._shape = s\n            self.prepareGeometryChange()  ## beware--this can cause the view to adjust, which would immediately invalidate the shape.\n        return self._shape\n\n    def boundingRect(self):\n        s1 = self.shape()\n        return self.shape().boundingRect()\n\n    def generateShape(self):\n        dt = self.deviceTransform()\n\n        if dt is None:\n            self._shape = self.path\n            return None\n\n        v = dt.map(QtCore.QPointF(1, 0)) - dt.map(QtCore.QPointF(0, 0))\n        va = np.arctan2(v.y(), v.x())\n\n        dti = fn.invertQTransform(dt)\n        devPos = dt.map(QtCore.QPointF(0, 0))\n        tr = QtGui.QTransform()\n        tr.translate(devPos.x(), devPos.y())\n        tr.rotate(va * 180. / 3.1415926)\n\n        return dti.map(tr.map(self.path))\n\n    def viewTransformChanged(self):\n        GraphicsObject.viewTransformChanged(self)\n        self._shape = None  ## invalidate shape, recompute later if requested.\n        self.update()\n\n\nclass MouseDragHandler(object):\n    """"""Implements default mouse drag behavior for ROI (not for ROI handles).\n    """"""\n\n    def __init__(self, roi):\n        self.roi = roi\n        self.dragMode = None\n        self.startState = None\n        self.snapModifier = QtCore.Qt.ControlModifier\n        self.translateModifier = QtCore.Qt.NoModifier\n        self.rotateModifier = QtCore.Qt.AltModifier\n        self.scaleModifier = QtCore.Qt.ShiftModifier\n        self.rotateSpeed = 0.5\n        self.scaleSpeed = 1.01\n\n    def mouseDragEvent(self, ev):\n        roi = self.roi\n\n        if ev.isStart():\n            if ev.button() == QtCore.Qt.LeftButton:\n                roi.setSelected(True)\n                mods = ev.modifiers() & ~self.snapModifier\n                if roi.translatable and mods == self.translateModifier:\n                    self.dragMode = \'translate\'\n                elif roi.rotatable and mods == self.rotateModifier:\n                    self.dragMode = \'rotate\'\n                elif roi.resizable and mods == self.scaleModifier:\n                    self.dragMode = \'scale\'\n                else:\n                    self.dragMode = None\n\n                if self.dragMode is not None:\n                    roi._moveStarted()\n                    self.startPos = roi.mapToParent(ev.buttonDownPos())\n                    self.startState = roi.saveState()\n                    self.cursorOffset = roi.pos() - self.startPos\n                    ev.accept()\n                else:\n                    ev.ignore()\n            else:\n                self.dragMode = None\n                ev.ignore()\n\n        if ev.isFinish() and self.dragMode is not None:\n            roi._moveFinished()\n            return\n\n        # roi.isMoving becomes False if the move was cancelled by right-click\n        if not roi.isMoving or self.dragMode is None:\n            return\n\n        snap = True if (ev.modifiers() & self.snapModifier) else None\n        pos = roi.mapToParent(ev.pos())\n        if self.dragMode == \'translate\':\n            newPos = pos + self.cursorOffset\n            roi.translate(newPos - roi.pos(), snap=snap, finish=False)\n        elif self.dragMode == \'rotate\':\n            diff = self.rotateSpeed * (\n                        ev.scenePos() - ev.buttonDownScenePos()).x()\n            angle = self.startState[\'angle\'] - diff\n            roi.setAngle(angle, centerLocal=ev.buttonDownPos(), snap=snap,\n                         finish=False)\n        elif self.dragMode == \'scale\':\n            diff = self.scaleSpeed ** -(\n                        ev.scenePos() - ev.buttonDownScenePos()).y()\n            roi.setSize(Point(self.startState[\'size\']) * diff,\n                        centerLocal=ev.buttonDownPos(), snap=snap, finish=False)\n\n\nclass PolyLineROI(ROI):\n    """"""\n    Container class for multiple connected LineSegmentROIs.\n\n    This class allows the user to draw paths of multiple line segments.\n\n    ============== =============================================================\n    **Arguments**\n    positions      (list of length-2 sequences) The list of points in the path.\n                   Note that, unlike the handle positions specified in other\n                   ROIs, these positions must be expressed in the normal\n                   coordinate system of the ROI, rather than (0 to 1) relative\n                   to the size of the ROI.\n    closed         (bool) if True, an extra LineSegmentROI is added connecting\n                   the beginning and end points.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n\n    """"""\n\n    def __init__(self, positions, closed=False, pos=None, **args):\n\n        if pos is None:\n            pos = [0, 0]\n        # Store positions\n        self.points = positions\n\n        self.closed = closed\n        self.segments = []\n        ROI.__init__(self, pos, size=[1, 1], **args)\n\n        self.setPoints(positions)\n        self.menu = self.buildMenu()\n        # Initialize attributes used by GUI\n        self.submenu = None\n        self.ROI_id = None\n\n    def buildMenu(self):\n        menu = self.getMenu()\n        return menu\n\n    def setPoints(self, points, closed=None):\n        """"""\n        Set the complete sequence of points displayed by this ROI.\n\n        ============= =========================================================\n        **Arguments**\n        points        List of (x,y) tuples specifying handle locations to set.\n        closed        If bool, then this will set whether the ROI is closed\n                      (the last point is connected to the first point). If\n                      None, then the closed mode is left unchanged.\n        ============= =========================================================\n\n        """"""\n        if closed is not None:\n            self.closed = closed\n\n        self.clearPoints()\n\n        for p in points:\n            self.addFreeHandle(p)\n\n        self.saveState()\n\n        start = -1 if self.closed else 0\n        for i in range(start, len(self.handles) - 1):\n            self.addSegment(self.handles[i][\'item\'], self.handles[i + 1][\'item\'])\n\n    def clearPoints(self):\n        """"""\n        Remove all handles and segments.\n        """"""\n        while len(self.handles) > 0:\n            self.removeHandle(self.handles[0][\'item\'])\n\n    def getState(self):\n        state = ROI.getState(self)\n        state[\'closed\'] = self.closed\n        state[\'points\'] = [Point(h.pos()) for h in self.getHandles()]\n        return state\n\n    def saveState(self):\n        state = ROI.saveState(self)\n        state[\'closed\'] = self.closed\n        state[\'points\'] = [tuple(h.pos()) for h in self.getHandles()]\n        return state\n\n    def setState(self, state):\n        ROI.setState(self, state)\n        self.setPoints(state[\'points\'], closed=state[\'closed\'])\n\n    def addSegment(self, h1, h2, index=None):\n        seg = _PolyLineSegment(handles=(h1, h2), pen=self.pen, parent=self, movable=False)\n        if index is None:\n            self.segments.append(seg)\n        else:\n            self.segments.insert(index, seg)\n        seg.sigClicked.connect(self.segmentClicked)\n        seg.setAcceptedMouseButtons(QtCore.Qt.LeftButton)\n        seg.setZValue(self.zValue()+1)\n        for h in seg.handles:\n            h[\'item\'].setDeletable(True)\n            h[\'item\'].setAcceptedMouseButtons(h[\'item\'].acceptedMouseButtons() | QtCore.Qt.LeftButton) ## have these handles take left clicks too, so that handles cannot be added on top of other handles\n\n    def setMouseHover(self, hover):\n        ## Inform all the ROI\'s segments that the mouse is(not) hovering over it\n        ROI.setMouseHover(self, hover)\n        for s in self.segments:\n            s.setParentHover(hover)\n\n    def addHandle(self, info, index=None):\n        # Make the handle pen invisible\n        h = ROI.addHandle(self, info, index=index)\n        h.radius = GUI_default[\'ROI_handle_size\']\n        h.pen = self.pen\n        h.buildPath()\n        h.sigRemoveRequested.connect(self.removeHandle)\n        self.stateChanged(finish=True)\n        return h\n\n    def segmentClicked(self, segment, ev=None, pos=None):  ## pos should be in this item\'s coordinate system\n        if ev != None:\n            pos = segment.mapToParent(ev.pos())\n        elif pos != None:\n            pos = pos\n        else:\n            raise Exception(""Either an event or a position must be given."")\n        h1 = segment.handles[0][\'item\']\n        h2 = segment.handles[1][\'item\']\n\n        i = self.segments.index(segment)\n        h3 = self.addFreeHandle(pos, index=self.indexOfHandle(h2))\n        self.addSegment(h3, h2, index=i + 1)\n        segment.replaceHandle(h2, h3)\n\n    def removeHandle(self, handle, updateSegments=True):\n        ROI.removeHandle(self, handle)\n        handle.sigRemoveRequested.disconnect(self.removeHandle)\n\n        if not updateSegments:\n            return\n        segments = handle.rois[:]\n\n        if len(segments) == 1:\n            self.removeSegment(segments[0])\n        elif len(segments) > 1:\n            handles = [h[\'item\'] for h in segments[1].handles]\n            handles.remove(handle)\n            segments[0].replaceHandle(handle, handles[0])\n            self.removeSegment(segments[1])\n        self.stateChanged(finish=True)\n\n    def removeSegment(self, seg):\n        for handle in seg.handles[:]:\n            seg.removeHandle(handle[\'item\'])\n        self.segments.remove(seg)\n        seg.sigClicked.disconnect(self.segmentClicked)\n        self.scene().removeItem(seg)\n\n    def checkRemoveHandle(self, h):\n        ## called when a handle is about to display its context menu\n        if self.closed:\n            return len(self.handles) > 3\n        else:\n            return len(self.handles) > 2\n\n    def paint(self, p, *args):\n        pass\n\n    def boundingRect(self):\n        return self.shape().boundingRect()\n\n    def shape(self):\n        p = QtGui.QPainterPath()\n        if len(self.handles) == 0:\n            return p\n        p.moveTo(self.handles[0][\'item\'].pos())\n        for i in range(len(self.handles)):\n            p.lineTo(self.handles[i][\'item\'].pos())\n        p.lineTo(self.handles[0][\'item\'].pos())\n        return p\n\n    def getArrayRegion(self, data, img, axes=(0,1), **kwds):\n        """"""\n        Return the result of ROI.getArrayRegion(), masked by the shape of the\n        ROI. Values outside the ROI shape are set to 0.\n        """"""\n        br = self.boundingRect()\n        if br.width() > 1000:\n            raise Exception()\n\n        sliced = ROI.getArrayRegion(self, data, img, axes=axes, fromBoundingRect=True, **kwds)\n\n        # Get user input\n        returnMappedCoords = kwds.get(\'returnMappedCoords\', False)\n        if returnMappedCoords:\n            mapped = sliced[1]\n            sliced = sliced[0]\n        else:\n            mapped = None\n\n        if img.axisOrder == \'col-major\':\n            mask = self.renderShapeMask(sliced.shape[axes[0]], sliced.shape[axes[1]])\n        else:\n            mask = self.renderShapeMask(sliced.shape[axes[1]], sliced.shape[axes[0]])\n            mask = mask.T\n\n        # reshape mask to ensure it is applied to the correct data axes\n        shape = [1] * data.ndim\n        shape[axes[0]] = sliced.shape[axes[0]]\n        shape[axes[1]] = sliced.shape[axes[1]]\n        mask = mask.reshape(shape)\n\n        sliced *= mask\n\n        if returnMappedCoords:\n            return sliced, mapped\n        else:\n            return sliced\n\n    def setPen(self, *args, **kwds):\n        ROI.setPen(self, *args, **kwds)\n        for seg in self.segments:\n            seg.setPen(*args, **kwds)\n\n\nclass LineSegmentROI(ROI):\n    """"""\n    ROI subclass with two freely-moving handles defining a line.\n\n    ============== =============================================================\n    **Arguments**\n    positions      (list of two length-2 sequences) The endpoints of the line\n                   segment. Note that, unlike the handle positions specified in\n                   other ROIs, these positions must be expressed in the normal\n                   coordinate system of the ROI, rather than (0 to 1) relative\n                   to the size of the ROI.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n    """"""\n\n    def __init__(self, positions=(None, None), pos=None, handles=(None, None), **args):\n        if pos is None:\n            pos = [0, 0]\n\n        ROI.__init__(self, pos, [1, 1], **args)\n        if len(positions) > 2:\n            raise Exception(""LineSegmentROI must be defined by exactly 2 positions. For more points, use PolyLineROI."")\n\n        for i, p in enumerate(positions):\n            self.addFreeHandle(p, item=handles[i])\n\n    @property\n    def endpoints(self):\n        # must not be cached because self.handles may change.\n        return [h[\'item\'] for h in self.handles]\n\n    def listPoints(self):\n        return [p[\'item\'].pos() for p in self.handles]\n\n    def paint(self, p, *args):\n        p.setRenderHint(QtGui.QPainter.Antialiasing)\n        p.setPen(self.currentPen)\n        h1 = self.endpoints[0].pos()\n        h2 = self.endpoints[1].pos()\n        p.drawLine(h1, h2)\n\n    def boundingRect(self):\n        return self.shape().boundingRect()\n\n    def shape(self):\n        p = QtGui.QPainterPath()\n\n        h1 = self.endpoints[0].pos()\n        h2 = self.endpoints[1].pos()\n        dh = h2 - h1\n        if dh.length() == 0:\n            return p\n        pxv = self.pixelVectors(dh)[1]\n        if pxv is None:\n            return p\n\n        pxv *= 4\n\n        p.moveTo(h1 + pxv)\n        p.lineTo(h2 + pxv)\n        p.lineTo(h2 - pxv)\n        p.lineTo(h1 - pxv)\n        p.lineTo(h1 + pxv)\n\n        return p\n\n    def getArrayRegion(self, data, img, axes=(0, 1), order=1,\n                       returnMappedCoords=False, **kwds):\n        """"""\n        Use the position of this ROI relative to an imageItem to pull a slice\n        from an array.\n\n        Since this pulls 1D data from a 2D coordinate system, the return value\n        will have ndim = data.ndim-1\n\n        See ROI.getArrayRegion() for a description of the arguments.\n        """"""\n        imgPts = [self.mapToItem(img, h.pos()) for h in self.endpoints]\n\n        d = Point(imgPts[1] - imgPts[0])\n        o = Point(imgPts[0])\n        rgn = fn.affineSlice(data, shape=(int(d.length()),), vectors=[Point(d.norm())], origin=o, axes=axes, order=order, returnCoords=returnMappedCoords, **kwds)\n\n        return rgn\n\n\nclass _PolyLineSegment(LineSegmentROI):\n    # Used internally by PolyLineROI\n    def __init__(self, *args, **kwds):\n        self._parentHovering = False\n        LineSegmentROI.__init__(self, *args, **kwds)\n\n    def setParentHover(self, hover):\n        # set independently of own hover state\n        if self._parentHovering != hover:\n            self._parentHovering = hover\n            self._updateHoverColor()\n\n    def _makePen(self):\n        if self.mouseHovering or self._parentHovering:\n            return GUI_default[\'ROI_highlighted_segment_pen\']\n        else:\n            return self.pen\n\n    def hoverEvent(self, ev):\n        # accept drags even though we discard them to prevent competition with parent ROI\n        # (unless parent ROI is not movable)\n        if self.parentItem().allowed_interaction:\n            if self.parentItem().translatable:\n                ev.acceptDrags(QtCore.Qt.LeftButton)\n            return LineSegmentROI.hoverEvent(self, ev)\n\n\nclass ConnectedROIs(GraphicsObject):\n    """"""\n    Chain of rectangular ROIs connected by handles.\n\n    This is generally used to mark a curved path through\n    an image similarly to PolyLineROI. It differs in that each segment\n    of the chain is rectangular instead of linear and thus has width.\n\n    ============== =============================================================\n    **Arguments**\n    points         (list of length-2 sequences) The list of points in the path.\n    width          (float) The width of the ROIs orthogonal to the path.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n    """"""\n    sigRegionChangeFinished = QtCore.Signal(object)\n    sigRegionChangeStarted = QtCore.Signal(object)\n    sigRegionChanged = QtCore.Signal(object)\n    sigHoverEvent = QtCore.Signal(object)\n    sigClicked = QtCore.Signal(object, object)\n    sigRemoveRequested = QtCore.Signal(object)\n\n    def __init__(self, points, width, pen=None, parent=None, **args):\n        GraphicsObject.__init__(self, parent)\n        self.setAcceptedMouseButtons(QtCore.Qt.RightButton)\n        self.pen = pen\n        self.roiArgs = args\n        self.lines = []\n        if len(points) < 2:\n            raise Exception(""Must start with at least 2 points"")\n\n        ## create first segment\n        self.addSegment(points[1], connectTo=points[0], scaleHandle=True)\n        ## create remaining segments\n        for p in points[2:]:\n            self.addSegment(p)\n\n        # Store position of all parts of this ROI\n        self.pos = [l.state[\'pos\'] for l in self.lines]\n        self.points = points\n\n        # Initialize attributes\n        self.removeAction = None\n        self.menu = self.buildMenu()\n\n    def raiseContextMenu(self, ev):\n        menu = self.scene().addParentContextMenus(self, self.getMenu(), ev)\n\n        ## Make sure it is still ok to remove this handle\n        removeAllowed = all([r.checkRemoveHandle(self) for r in self.rois])\n        self.removeAction.setEnabled(removeAllowed)\n        pos = ev.screenPos()\n        menu.popup(QtCore.QPoint(pos.x(), pos.y()))\n\n    def buildMenu(self):\n        menu = QtWidgets.QMenu()\n        self.removeAction = menu.addAction(""Remove all segments"", self.removeClicked)\n        return menu\n\n    def removeClicked(self):\n        self.sigRemoveRequested.emit(self)\n\n    def getMenu(self):\n        return self.removeAction\n\n    def paint(self, *args):\n        pass\n\n    def boundingRect(self):\n        return QtCore.QRectF()\n\n    @QtCore.pyqtSlot()\n    def roiChangedEvent(self):\n        # Check whether ROI is moving or scaling\n        isMoving = [l.isMoving for l in self.lines]\n        if any(isMoving):\n            # Find which ROI is moving\n            moving_ROI_idx = np.where(np.array(isMoving) == True)[0][0]\n\n            # Turn off \'moving\' flag\n            for l in self.lines:\n                l.isMoving = False\n\n            # Get actual position of moving part\n            p = self.lines[moving_ROI_idx].state[\'pos\']\n            # Get number of pixels of the movement\n            moved = p - self.pos[moving_ROI_idx]\n\n            # Get all other non-dragged parts\n            other_ROIs = list(set(range(len(self.lines))).difference({moving_ROI_idx}))\n            # Apply offset to them\n            [self.lines[other_ROIs[l_idx]].translate(moved, update=True, finish=False) for l_idx in range(len(other_ROIs))]\n\n            # Turn on \'moving\' flag\n            self.lines[moving_ROI_idx].isMoving = True\n\n        # Apply scaling\n        w = self.lines[0].state[\'size\'][1]\n        for l in self.lines[1:]:\n            w0 = l.state[\'size\'][1]\n            if w == w0:\n                continue\n            l.scale([1.0, w/w0], center=[0.5,0.5])\n        self.sigRegionChanged.emit(self)\n\n        # Update position of all ROI parts in memory\n        self.pos = [l.state[\'pos\'] for l in self.lines]\n\n    @QtCore.pyqtSlot()\n    def roiChangeStartedEvent(self):\n        self.sigRegionChangeStarted.emit(self)\n\n    @QtCore.pyqtSlot()\n    def roiChangeFinishedEvent(self):\n        self.sigRegionChangeFinished.emit(self)\n\n    def getHandlePositions(self):\n        """"""Return the positions of all handles in local coordinates.""""""\n        pos = [self.mapFromScene(self.lines[0].getHandles()[0].scenePos())]\n        for l in self.lines:\n            pos.append(self.mapFromScene(l.getHandles()[1].scenePos()))\n        return pos\n\n    def getArrayRegion(self, arr, img=None, axes=(0, 1), **kwds):\n        returnMappedCoords = kwds.get(\'returnMappedCoords\', False)\n        kwds.pop(\'returnMappedCoords\')\n        regions = []\n        coords = []\n        for l in self.lines:\n            rgn = l.getArrayRegion(arr, img, axes=axes, returnMappedCoords=returnMappedCoords, **kwds)\n            if rgn is None:\n                continue  # return None\n            if returnMappedCoords:\n                coords.append(rgn[1])\n                regions.append(rgn[0])\n            else:\n                regions.append(rgn)\n\n        # Make sure that all regions have the same width\n        scale = int(np.floor(np.min([i.state[\'size\'][1] for i in self.lines])))\n        regions = [reg[:, :scale] for reg in regions]\n        if returnMappedCoords:\n            coords = [reg[:, :, :scale] for reg in coords]\n\n        # Make sure orthogonal axis is the same size\n        if img.axisOrder == \'row-major\':\n            axes = axes[::-1]\n        ms = min([r.shape[axes[1]] for r in regions])\n        sl = [slice(None)] * regions[0].ndim\n        sl[axes[1]] = slice(0, ms)\n        regions = [r[sl] for r in regions]\n\n        # Concatenate and return\n        regions = np.concatenate(regions, axis=axes[0])\n        if returnMappedCoords:\n            coords = np.concatenate(coords, axis=axes[0]+1)\n            return regions, coords\n        else:\n            return regions\n\n    def addSegment(self, pos=(0, 0), scaleHandle=False, connectTo=None):\n        """"""\n        Add a new segment to the ROI connecting from the previous endpoint to *pos*.\n        (pos is specified in the parent coordinate system of the MultiRectROI)\n        """"""\n\n        ## by default, connect to the previous endpoint\n        if connectTo is None:\n            connectTo = self.lines[-1].getHandles()[1]\n\n        ## create new ROI\n        newRoi = ROI((0, 0), [1, 5], parent=self, pen=self.pen, **self.roiArgs)\n        newRoi.parent = self\n        self.lines.append(newRoi)\n\n        ## Add first SR handle\n        if isinstance(connectTo, Handle):\n            self.lines[-1].addScaleRotateHandle([0, 0.5], [1, 0.5], item=connectTo)\n            newRoi.movePoint(connectTo, connectTo.scenePos(), coords=\'scene\')\n        else:\n            h = self.lines[-1].addScaleRotateHandle([0, 0.5], [1, 0.5])\n            newRoi.movePoint(h, connectTo, coords=\'scene\')\n        ## add second SR handle\n        h = self.lines[-1].addScaleRotateHandle([1, 0.5], [0, 0.5])\n        newRoi.movePoint(h, pos)\n        ## optionally add scale handle (this MUST come after the two SR handles)\n        if scaleHandle:\n            newRoi.addScaleHandle([0.5, 1], [0.5, 0.5])\n        newRoi.translatable = True\n        newRoi.sigRegionChanged.connect(self.roiChangedEvent)\n        newRoi.sigRegionChangeStarted.connect(self.roiChangeStartedEvent)\n        newRoi.sigRegionChangeFinished.connect(self.roiChangeFinishedEvent)\n        newRoi.sigRemoveRequested.connect(partial(self.removeSegment, index=len(self.lines)-1))\n        self.sigRegionChanged.emit(self)\n\n    @QtCore.pyqtSlot()\n    def removeSegment(self, index=-1):\n        """"""Remove a segment from the ROI.""""""\n        roi = self.lines[index]\n        self.lines.pop(index)\n        self.scene().removeItem(roi)\n        roi.sigRegionChanged.disconnect(self.roiChangedEvent)\n        roi.sigRegionChangeStarted.disconnect(self.roiChangeStartedEvent)\n        roi.sigRegionChangeFinished.disconnect(self.roiChangeFinishedEvent)\n        self.sigRegionChanged.emit(self)\n\n    def removeClicked(self):\n        ## Send remove event only after we have exited the menu event handler\n        QtCore.QTimer.singleShot(0, lambda: self.sigRemoveRequested.emit(self))\n'"
src/calipy/utils/__init__.py,0,b''
src/calipy/utils/icons.py,0,"b'""""""\nThis file contains the XPM representation of the icons used by the GUI.\n""""""\n\nhistogram_unlocked = [""128 128 92 1 "",\n""  c #040605"",\n"". c #060807"",\n""X c #070908"",\n""o c #0A0C0B"",\n""O c #0E100F"",\n""+ c #0F1110"",\n""@ c #111212"",\n""# c #161817"",\n""$ c #171918"",\n""% c #1A1C1B"",\n""& c #1E201E"",\n""* c #1E2020"",\n""= c #222423"",\n""- c #262827"",\n""; c #272928"",\n"": c #2C2E2D"",\n""> c #2E312F"",\n"", c #2F3130"",\n""< c #333434"",\n""1 c #373937"",\n""2 c #373939"",\n""3 c #3A3B3B"",\n""4 c #3F413F"",\n""5 c #3F4140"",\n""6 c #414242"",\n""7 c #454847"",\n""8 c #464948"",\n""9 c #4D4E4D"",\n""0 c #4F514F"",\n""q c #4F5251"",\n""w c #525453"",\n""e c #575957"",\n""r c #5B5D5B"",\n""t c #5E605E"",\n""y c #5E6260"",\n""u c #636463"",\n""i c #666967"",\n""p c #696A6A"",\n""a c #6F7171"",\n""s c #00FF27"",\n""d c #03FE2A"",\n""f c #09FD2E"",\n""g c #0EFC32"",\n""h c #13F736"",\n""j c #13F936"",\n""k c #17F639"",\n""l c #1CF53C"",\n""z c #14FC38"",\n""x c #1BFC3D"",\n""c c #1DFF40"",\n""v c #25F143"",\n""b c #22F843"",\n""n c #29F748"",\n""m c #29F949"",\n""M c #43ED5B"",\n""N c #63DA74"",\n""B c #6AD979"",\n""V c #70D67D"",\n""C c #48E360"",\n""Z c #54E66A"",\n""A c #49F463"",\n""S c #5DEE72"",\n""D c #5BFC73"",\n""F c #64FD7B"",\n""G c #75D582"",\n""H c #7AD386"",\n""J c #7CD388"",\n""K c #72FA86"",\n""L c #7AF38C"",\n""P c #75FD89"",\n""I c #7DFD8F"",\n""U c #9BFEAA"",\n""Y c #A0FCAC"",\n""T c #A3FCB1"",\n""R c #C3F3CA"",\n""E c #C2FBC9"",\n""W c #CEF2D3"",\n""Q c #CBFDD1"",\n""! c #D2FCD7"",\n""~ c #D6F2D8"",\n""^ c #DDF7DF"",\n""/ c #D3FCD8"",\n""( c #DFFAE1"",\n"") c #E6EBE7"",\n""_ c #E6FDE9"",\n""` c #E8FEE9"",\n""\' c #EEFCF0"",\n""] c #F6F6F4"",\n""[ c #F5FAF5"",\n""{ c #FAF9F7"",\n""} c #FDFDFD"",\n""| c None"",\n""|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||sssss||||||||||||||||"",\n""|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||lssssssssssssf|||||||||||"",\n""||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssssssssssssd|||||||||"",\n""||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||dsssssssssssssssssss||||||||"",\n""|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssssssssssssssssss|||||||"",\n""||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssssssssssssssssssss||||||"",\n""|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||sssssssssssssssssssssssssd|||||"",\n""||||||||||||||||||||||||||||:.$= >||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssssssssssssssssssssssss||||"",\n""||||||||||||||||||||||||||||:X$= >||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||sssssssssssgdvCsfsssssssssssh|||"",\n""||||||||||||||||||||||||||||: $* >|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssssssd||||||||fsssssssssf|||"",\n""||||||||||||||||||||||||||o|:.%*.>|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssssdz||||||||||zhsssssssss||"",\n""||||||||||||||||||||||||| .@:.%* >||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssssdZ|||||||||||||hssssssss||"",\n""||||||||||||||||||||||||| .+:.%&.>||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssssg|||||||||||||||ssssssss||"",\n""||||||||||||||||||||||||| o+:.%&.>||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||sssssssf||||||||||||||||bssssssss|"",\n""||||||||||||||||||||||||| .+:.%&.:|6|||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssssn|||||||||||||||||ssssssss|"",\n""||||||||||||||||||||||||| .+: %& >|. ||||||||||||||||||||||||||||||||||||||||||||||||||||||||sssssssd||||||||||||||||||gsssssss|"",\n""||||||||||||||||||||||||| .@:.%%X,|  ||||||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssss||||||||||||||||||gsssssss|"",\n""||||||||||||||||||||||||| .+:.$= >|. ||||||||||||||||||||||||||||||||||||||||||||||||||||||||sssssssz||||||||||||||||||Msssssss|"",\n""||||||||||||||||||||||||| .+:.%*.:|. ||||||||||||||||||||||||||||||||||||||||||||||||||||||||sssssssb|||||||||||||||||||sssssss|"",\n""||||||||||||||||||||||||| .+:.$&X:|X ||||||||||||||||||||||||||||||||||||||||||||||||||||||||sssssssf|||||||||||||||||||sssssss|"",\n""||||||||||||||||||||||3<|  @>.%& >|X |  |||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssss|||||||||||||||||||ssssssss"",\n""||||||||||||||||||||||@X| .+:.$&X:|  | o|||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssss|||||||||||||||||||ssssssss"",\n""||||||||||||||||||||||%X| .+:.%&X>|X |Xo|||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssss|||||||||||||||||||ssssssss"",\n""||||||||||||||||||||||=#| .+:.%* >|  |Xo|||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssss|||||||||||||||||||ssssssss"",\n""||||||||||||||||||||||@%| .@:.$*X:|  |.o|||||||||||||||||||||||||||||||||||||||||||||||||||||ssssssss|||||||||||||||||||ssssssss"",\n""||||||||||||||||||||||+X|O @:.%*X:|X | o|||||||||||||||||||||||||||||||||||||||||||||||||||||hhvvvvvd|||||||||||||||||||ffhklvll"",\n""||||||||||||||||||||||OX|%#O:X%&.:|. |XX||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||||||||+o| %->X$*.:|. | O|||||||||||||||||||||||||NVVGGGHHHHJHHJJJJJJJJJJJJJJHHJJJJJJJHJH||||||||||||||||||||||||"",\n""||||||||||||||||||||||OX| X*<X%*X:|. |.o||||||||||||||||||||sssssssssssssssssssssssssssssssssssssssssssss|||||||||||||||||||||||"",\n""||||||||||||||||||||||OX| X@5@%*X:|X |.o|@@|||||||||||||||||sssssssssssssssssssssssssssssssssssssssssssssz||||||||||||||||||||||"",\n""||||||||||||||||||||||Oo| X+,%;* :|X |XX|. |||||||||||||||||sssssssssssssssssssssssssssssssssssssssssssssd||||||||||||||||||||||"",\n""||||||||||||||||||||||OX| X+>X:=X:|  |XX|  |||||||||||||||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||||||||OX| X+:.%<O:|. |.o|  |||||||||||||||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||||||||OX| X+:.$=&3|. |.o|. |||||||||||||||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||||||||OX| X+:.$*X4|. |.o|. |||||||||||||||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||||||||OX|..+:.%&.>|+ |.o|. |||||||||||||||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||||||||Oo| X+:.$=.:|*O|XX|. |||||||||||||||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||||| O|OX| X+:.$*X:|X%|XX|  1.$||||||||||||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||X@|OX| XO:.$*X:|XX|OX|. 1 %||||||||||||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|OX| XO:.$=.:|X |%#|. 1X%||||||||||||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|OX| XO:.%& >|. |X=|. <.%||||||||||||||sssssssssssssssssssssgbdssssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|Oo| X@:.%&X:|. |.O|O 2.$||||||||||||||sssssssssssssssssssgDR)Tcsssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.O|OX| X+: %&X:|X | o|=X1 %||||||||||||||sssssssssssssssssssK{}}}Qkssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|oX| .O:.%&X:|  |Xo|o&1X%||||||||||||||ssssssssssssssssssz^}{}{{Kssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|oo| XO:.%& :|X |.o|X 9o%| %|||||||||||ssssssssssssssssssM]{}}}}Pssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.+|OX| XO:.$&X>|  |.X|  4**|X*|||||||||||ssssssssssssssssssh(}}}{{Kssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|oo| X@:.%* :|X |.o|X 1o<|.%|||||||||||sssssssssssssssssssD\'}}}Ezssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||||| @|OX| .O:.%*X>|. |.X|. 3 %|O%|||||||||||ssssssssssssssssssssP}}\'xsssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|OX| XO: $*X:|X |.X|X 1X%|**|||||||||||ssssssssssssssssssssF}}\'gsssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.+|OX| X+:X%* >|X |.o|. 1.%|o<|||||||||||sssssssssssssssssssdW}}}Ssssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|oX| X+:.$*X:|  |.o|..3.%|.=|||||||||||sssssssssssssssssssf`}}}Psssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.O|Oo| XO:.%*X:|X |XX|. 3.%|X$|||||||||||sssssssssssssssssssm\'}}}Isssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.+|OX| X+:.%* >|. |.X|X 3X%|X%|O%||||||||sssssssssssssssssssD}}}}~dssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.+|OX| X+:.%* >|. |.o|..1.$|X%|XX||||||||sssssssssssssssssssD}}}}`dssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|oX| .+:.$&X>|X |.o|..3.$|X%|X ||||||||sssssssssssssssssssF}}}}`dssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||||| +|OX| .O:.%* >|  |.o|..1.%|X%|X ||||||||sssssssssssssssssssA{}}}Tdssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.+|oX| X+:.%& :|X |.o|. 3X$|X%|XX|==|||||ssssssssssssssssssssL//Umsssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.@|OX| X+:.%&X>|  |.o|. 3X$|X&|X |.X|||||ssssssssssssssssssssddddssssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||||||.+|oo| X+:.$* :|X |.o|. 3X$|.%|  |XX|||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||1<| +|OX| X+:X$*X>|X |.o|. 3X$|.%|XX|XX|||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""|||||||||||||||| X|.@|oo| X+:.$= >|. |@$| .1X$|.%|. |X%|||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||XX|.@|oo| X+:.$= >|X |-*|X.3X$|.%|. |;<|||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|oX| XO:X$%X:|  |=X|X.3X$|X%|X.|$=|||||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|oo| XO: %=X>|X |=X1 X3X%|X*|X.|O=|80||ssssssssssssssssssssssssssssssssssssssssssssss||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|oX| .+:.%*.<|=%|=ow=*4.:|+%|%$|O=|=%||dssssssssssssdsssssssssssssssssssssssssssssss|||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|oo| .+:.%&o8|@$|-Ow@@e+3|&%|$;|Xo|OO||||||||||||ssssssssssssssssssssssssssss||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|oX| .+:.%&=<|o.|-@i+X3=1|&%| -| X|XX||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X| @|oo| .O:.%*==|--|=oa-::-2|&&| -|O%|:%||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.O|XX| X+:.%*=-|@O|=owX&:&3|*%|X=|O=|O%||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|OX| .@:.%&-=|--|*o6X+>=3|&%| =|O&|O%||w|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| .+:.%%%3|XO|=o3X+>=3|&%|.=|O&|@%|#o|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||XX|.@|oX| X+:.%*o4|=o|:X,X+:*3|&%|.&|O=|O%|#O|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|oX| XO: $&@<|%&|<X|.@:*3|=&|X*|@$|o%|-O|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|oo| X+:X%*;9|-$|<X|.@:&3|-<|X%|$o|-=|-,|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| X+:.$-=-|+.|;X|.+:&>|X-| =|-.|--|o=|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|Xo| X+:.%;:<|O%|=$|.+3-=|$%|--|%;|-@|=:|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|oX| XO:.$*#6|=%|@=|.o9%%|=<|#X|X@|# |%%w*,||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|oo| X+:.%=X,|X |Xo|.X1X$|X%|. |.X|  |@o8 O||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| .+:.%&.:|. |Xo|XX3X%|X%|. |XX|.o|oX8 @||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X| +|oX| .+:.$&.>|. |Xo|XX1.%|X%|. |XX| .|oo8 O||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|oX| X@:.%&.:|. | o|X 3X$|X&|X |.X| .|@X8 @||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| X+:.%&.:|. |.X|. 3.%| %|X |.X| .|oo8 @||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|oo| X+:.$*X:|. |.o|. 3X$|X%|. |.X| .|Oo8 O|%:|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|XX| .+:.%*X:|. |.o|. 3 %|X%|X |.X|  |OX8 O|.X|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| X+:.$=.:|X |.X|. 3X$|X%|o@|XX| .|OX8 O|.o|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| X+:.$*X:|  |.o|..3X$|X%|#$| X| .|oo8 O|Xo|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|oX| XO:.$* :|X | o|X.1.%|X%|% |.X| .|oX8.O|Xo|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X| @|Xo| XO:.$=X:|X |XX|..1.$|X-|X |.X| .|@o8.@|Xo|OO||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|oX| .+:.%&X:|. |.o|X.3.%|@<|. |.X| .|oX7 O|XO|oX||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| X+>.$&.:|. |.o|..3.$|%*|. |.X| .|Oo7 @|Xo|OX||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|XX| .+:.%&.:|. |.X|X 1 =|X*|. |.X| .|OX8 O|Xo|O ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|Xo| .+:.%*X:|  |.o|X 2@,|X%|. |.X| .|Oo8 O|Xo|oX|<-|||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| XO:.%* >|X | o|X 8%%|X%|. |XX| .|Oo8 @|Xo|O.|# 7||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| XO:.$*X:|  |.X| O7X%|X*|. | X| .|Oo8 +|oo|O.|#.6||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|Xo| X+:.$*X:|X |Xo|@%3X$|X%|. |.X| .|OX8 @|Xo|oX|#.7||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X| @|XX| X+:X$= :|X |XX|%X1X$|.%|. |.X| .|oX7 O|oo|o.|$.9#.||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.+|XX| .+: $=.:|. | @|X 1.$|X%|X |.X| .|OX8 O|oo|o.|@ 9#.||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||.X|.@|Xo| X+:X$*X:|X |O=|X.1X%|X%|X |.X| .|OX8 O|oo|oo|# 9#.||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||@.||.X|.@|Xo| X+:.$=.:|. |%O|. 2X$|.%|X |XX| .|Oo8 @|Xo|@ |$ 9#.,o@|||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||X ||.X|.@|XX| X+:.$*.:| o|XO|. 2X$|.%|X.| X| .|oo8 +|oo|oo|@.9#.<.O|||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||oX||.o|.@|oX| X+:.$=.>|@*|.X|X 2 $|X%|. |.X| .|OX8 O|XO|oo|# 9#o<XOpXO||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o || .|.@|XX| X+:.$&.>|*.|.o|X 2X%|.%|. |XX| .|Oo7 O|oo|o.|#.9# <.op O||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||..|.+|Xo| X+:.%* >|o |.o|. 2.%|.*|. |XX| .|OX8 @|oo|oo|# 9# <.op.o7o$|||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.o|.+|oX| .@:.%*O7|  |XX|X 2.$|X%|. | X|  |Oo8 O|Xo|oo|# 9#X3.Op o6 #|||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.X|.@|Xo| X+:.%;*<|X |.o|. 2X%|.%|X.|.o| .|@X8 O|oo|O.|# 9#X3.ou.o4 #|||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||oX||.X|.@|Xo| X+:.%<o:|. |.o|. 2.$|.%|. |. | .|oo8.@|Xo|o.|# 9#.3Xou o6.@|||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.X|.+|XX|  +:O<=.:|. | X|. <.$|X*|. |XX| .|@o8 O|oo|O.|# 0#X3Xou.o4X@|||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.X| @|Xo| XO<%**X:|. |.o|. 2.%|.%|. | X|  |oX8 O|oo|X.|# 0@X3.ou.o4 #=o<||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.X|.+|XX| .@6o%*X:|. |.X|. 1.%|.%|. |.X| .|@.8 O|Xo|OX|# 0#X3.ot o5X@%X,||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o.||.X|.@|XX| o-,X%&X:|. |.o|. 1.%|X%|. |.X| .|oo8 O|oo|o.|# 9#.3XOr o5X#%.,||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.X|.O|Xo|o*%:.$*.:|. |.o|. 1X$|.*|. |.X| .|oX8.@|oo|O.|# 0#X3oOr o4 #*.,90||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.X|.@|XX|&O@:.%*.:|  |XX|  1X$|.%|. |.X| .|@o8 +|oo|X.|# 0@X3XOr o4 #%., .||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.X|.@| X|X.+:X$= >|  |.o|. 1.$|X%|. |XX| X|OX8 O|oo|O.|# 9# 3XOe o6o@& : .|@@|||||||||||||||||||||||||||||||||||"",\n""||||||||||||oX||.X|X@|O=|  @: %%X:|X |.o|. 1X%|X%|. | X|  |Oo8 O|Xo|o.|# 9#X3.Oe o6 @& : .; .|||||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.X|X@|*@| .O:.%*.:|. | X|X <X$|.%|. |XX| .|Oo8 O|oo|O.|# 9#.3Xow o6.#& : ., .|%*||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||.X|X@|@o| X@:.%*X:|. |Xo|  1X$|.%|. |.X| .|OX8 O|oo|o.|# 0# 3 Ow o4.@&o: .1..6 @||||||||||||||||||||||||||||||||"",\n""||||||||||||o ||..|o-|XX| XO:.%&X>|. |.X|X <.$|X&|X.|.X| .|OO7 O|Xo|O.|# 0#o3XO0.o6.#* :  3.o6.#X.X|||||||||||||||||||||||||||||"",\n""||||||||||||o ||..|*$|Xo| X@:.$& :|. |.o|. 2.%|.%|X |.X| .|OX8 @|oo|oX|# 0@ 3oO0 o6 @*.> .3..6.@XXO|||||||||||||||||||||||||||||"",\n""||||||||||||XX||..|+@|XX| X+:.%&.>|. |.o|. 2.%|.%|. |XX| .|Oo8 O|Xo|O.|# 0# 3Xo0 o4 @*.: .3 o6.@X.@OXu||||||||||||||||||||||||||"",\n""||||||||||||o.||o*|.+|Xo| .O:.%*.:|  |XX|. <.%|.%|. | X|  |OX8 O|oo|o.|# 0#X3 @| o4 #&.:  3.o6.@X @OX0 #||||||||||||||||||||||||"",\n""||||||||||||o.||&@| @|XX| X+:X$=.:|. |.o|. 2X%|.%|. |.X| .|OX7 @|oo|OX|# 0# 3X@|.o4.#%.: X3.X5.@o.++X9 #..   |||||||||||||||||||"",\n""||||||||||||X.||@.|X@|Xo| X+: $*X:|X |XX|. 1.$| &|. |.X| .|OX8 O|Xo|XX|% 9# 3XO| o6 #&.: X3 o6.#X.OOX9 #    .%%%,%#,$$||||||||||"",\n""||||||||||||o ||..| @|.X|  +: $* :|X |Xo|X.1X$|O*|oX|Xo|Xo|++9X@|OO|@o|$o0$O3oO|.O6O#=X>.X4XO6X$Oo@#O0X$XOXXo*.@:Xo,X@||||||||||"",\n""||||||||||||%:||$$|O#||0|O+|<@|-O1||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"",\n""||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||""]\n\nhistogram_locked = [""128 128 91 1 "",\n""  c #040605"",\n"". c #060807"",\n""X c #070908"",\n""o c #0A0C0B"",\n""O c #0E100F"",\n""+ c #0F1110"",\n""@ c #111212"",\n""# c #161817"",\n""$ c #171918"",\n""% c #1A1C1B"",\n""& c #1E201E"",\n""* c #1E2020"",\n""= c #222423"",\n""- c #262827"",\n""; c #272928"",\n"": c #2C2E2D"",\n""> c #2E312F"",\n"", c #2F3130"",\n""< c #333434"",\n""1 c #373937"",\n""2 c #373939"",\n""3 c #3A3B3B"",\n""4 c #3F413F"",\n""5 c #3F4140"",\n""6 c #414242"",\n""7 c #454847"",\n""8 c #464948"",\n""9 c #4D4E4D"",\n""0 c #4F514F"",\n""q c #4F5251"",\n""w c #525453"",\n""e c #575957"",\n""r c #5B5D5B"",\n""t c #5E605E"",\n""y c #5E6260"",\n""u c #636463"",\n""i c #666967"",\n""p c #696A6A"",\n""a c #6F7171"",\n""s c #FF0000"",\n""d c #FC0B0B"",\n""f c #F61515"",\n""g c #FC1111"",\n""h c #F51A1A"",\n""j c #FD1919"",\n""k c #EF2423"",\n""l c #ED2D2C"",\n""z c #F12525"",\n""x c #FC2524"",\n""c c #F32D2D"",\n""v c #FD2B2B"",\n""b c #EE302E"",\n""n c #EB3433"",\n""m c #E63D3C"",\n""M c #EA3B3B"",\n""N c #FF3333"",\n""B c #E9403F"",\n""V c #DD5352"",\n""C c #E54545"",\n""Z c #E84343"",\n""A c #E54847"",\n""S c #E44949"",\n""D c #EA4C4B"",\n""F c #F44747"",\n""G c #F14B4B"",\n""H c #FC5151"",\n""J c #FA5B5B"",\n""K c #F86262"",\n""L c #FC6868"",\n""P c #ED7473"",\n""I c #F98887"",\n""U c #FE8C8B"",\n""Y c #EE9292"",\n""T c #F29393"",\n""R c #FB9C9B"",\n""E c #C5B2B0"",\n""W c #ECA8A8"",\n""Q c #F4A4A3"",\n""! c #F8ACAB"",\n""~ c #FEB2B1"",\n""^ c #FCBBBB"",\n""/ c #FAC6C6"",\n""( c #F2CDCC"",\n"") c #FACDCC"",\n""_ c #FBD7D7"",\n""` c #F0E2E2"",\n""\' c #F6ECEC"",\n""] c #F9ECEC"",\n""[ c #F9F4F4"",\n""{ c #FCFCFC"",\n""} c None"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssss}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssss}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}gsssssssssssssssssss}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssssss}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssssssss}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssssssssss}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}:.$= >}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssssssssssss}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}:X$= >}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssssssssssgsssssssssssssss}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}: $* >}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssssssssxjcEcxcssssssssssss}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}o}:.%*.>}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssssss}}}}}}}}}}gsssssssssss}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}} .@:.%* >}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssssf}}}}}}}}}}}}}ssssssssss}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}} .+:.%&.>}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssssf}}}}}}}}}}}}}}}ssssssssss}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}} o+:.%& >}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssss}}}}}}}}}}}}}}}}}gssssssss}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}} .+:.%&.>}6}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}dssssssss}}}}}}}}}}}}}}}}}}csssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}} .+: %& >}. }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssd}}}}}}}}}}}}}}}}}}}dssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}} .@:.%%X,}  }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}}}}zssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}} .+:.$= :}. }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}} .+:.%*.>}X }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}} .+:.$&.:}X }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}3<}  @>.%& >}  }  }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}@X} .+:.$&X:}X } o}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssss}}}}}}}}}}}}}}}}}}}}}sssssssss}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}%X} .+:.%&X>}X }Xo}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssss}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}=#} .+:.%* >}  }Xo}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssss}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}@%} .@:.$*X:}. }Xo}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssss}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}+X}O @:.%*X:}. } X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssss}}}}}}}}}}}}}}}}}}}}}ssssssss}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}OX}%#O:X%&.:}. }.O}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}hVzkBnbz}}}}}}}}}}}}}}}}}}}}}}nVSCmnfh}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}+o} %->X$*.:}. }.X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}OX} X*<X%*X:}. }.o}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}sgzbnMBZZAAAAAASSSSDSAAAAAAAZZZZmMMnblzhgds}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}OX} X@5@%*X:}X }.o}@@}}}}}}}}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}Oo} X+,%;* :}X }XX}X }}}}}}}}}}}}}}}}}}}}}}}}}}hsssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}OX} X+>X:=X:}  }XX}  }}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}OX} X+:.%<O:}. }.o}  }}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}OX} X+:.$=&3}. }.o}. }}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}OX} X+:.$*X4}. }.o}. }}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}OX}..+:.%&.>}+ }.o}. }}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}Oo} X+:.$=.:}*O}XX}. }}}}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}} O}OX} X+:.$*X:}X%}XX}  1.$}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}X@}OX} XO:.$*X:}XX}OX}. 1 %}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}OX} XO:.$=.:}X }%#}. 1X%}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}OX} XO:.%& >}. }X=}. <.%}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}Oo} X@:.%&X:}. }.O}O 2.$}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssdgGxdsssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.O}OX} X+: %&X:}X } o}=X1 %}}}}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssK\'[[)xssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}oX} .O:.%&X:}  }Xo}o&1X%}}}}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssx[{{{{~ssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}oo} XO:.%& :}X }.o}X 9o%} *}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssT{{{{{{vsssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.+}OX} XO:.$&X>}  }.X}  4**}X%}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssR{{{{{{vsssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}oo} X@:.%* :}X }.o}X 1o<}.%}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssF[{{{{)gsssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}} @}OX} .O:.%*X>}. }.X}. 3 %}O%}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssdT]{{]Hssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}OX} XO: $*X:}X }.X}X 1X%}**}}}}}}}}}}}}}}}}}}}}sssssssssssssssssssss/{{Wsssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.+}OX} X+:X%* >}X }.o}. 1.%}o<}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssv[{{^sssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}oX} X+:.$*X:}  }.o}..3.%}.=}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssv{{{/dssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.O}Oo} XO:.%*X:}X }XX}. 3.%}X$}}}}}}}}}}}}}}}}}}}}ssssssssssssssssssssP{{{[Nssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.+}OX} X+:.%* >}. }.X}X 3X%}X%}O%}}}}}}}}}}}}}}}}}ssssssssssssssssssssR{{{{Nssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.+}OX} X+:.%* >}. }.o}..1.$}X%}XX}}}}}}}}}}}}}}}}}ssssssssssssssssssssR{{{{Jssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}oX} .+:.$&X>}X }.o}..3.$}X%}X }}}}}}}}}}}}}}}}}sssssssssssssssssssj`{{{{!ssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}} +}OX} .O:.%* >}  }.o}..1.%}X%}X }}}}}}}}}}}}}}}}}sssssssssssssssssssg({{{{Qssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.+}oX} X+:.%& :}X }.o}. 3X$}X%}XX}==}}}}}}}}}}}}}}ssssssssssssssssssssL[{{_xssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.@}OX} X+:.%&X>}  }.o}. 3X$}X&}X }.X}}}}}}}}}}}}}}sssssssssssssssssssssKIUvsssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}.+}oo} X+:.$* :}X }.o}. 3X$}.%}  }XX}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}1<} +}OX} X+:X$*X>}X }.o}. 3X$}.%}XX}XX}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}} X}.@}oo} X+:.$= >}. }@$} .1X$}.%}. }X%}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}XX}.@}oo} X+:.$= >}X }-*}X.3X$}.%}. };<}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}oX} XO:X$%X:}  }=X}X.3X$}X%}X.}$=}}}}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}oo} XO: %=X>}X }=X1 X3X%}X*}X.}O=}80}}}}}}}}}}}ssssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}oX} .+:.%*.<}=%}=ow=*4.:}+%}%$}O=}=%}}}}}}}}}}}}sssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}oo} .+:.%&o8}@$}-Ow@@e+3}&%}$;}Xo}+O}}}}}}}}}}}}fssssssssssssssssssssssssssssssssssssssssssss}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}oX} .+:.%&=<}o.}-@i+X3=1}&%} -} X}X.}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X} @}oo} .O:.%*==}--}=oa-::-2}&&} -}O%}:%}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.O}XX} X+:.%*=-}@O}=owX&:&3}*%}X=}O=}O%}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}OX} .@:.%&-=}--}*o6X+>=3}&%} =}O&}O%}}w}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} .+:.%%%3}XO}=o3X+>=3}&%}.=}O*}O%}#o}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}XX}.@}oX} X+:.%*o4}=o}:X,X+:*3}&%}.&}O=}O%}$O}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}oX} XO: $&@<}%&}<X}.@:*3}=&}X*}@$}O%}-O}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}oo} X+:X%*;9}-$}<X}.@:&3}-<}X%}$o}-=}-,}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} X+:.$-=-}+.};X}.+:&>}X-} =}-.}--}o=}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}Xo} X+:.%;:<}O%}=$}.+3-=}$%}--}%;}-@}=:}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}oX} XO:.$*#6}=%}@=}.o9%%}=<}#X}X@}# }%%w*,}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}oo} X+:.%=X,}X }Xo}.X1X$}X%}. }.X}..}Oo8 O}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} .+:.%&.:}. }Xo}XX3X%}X%}. }XX} X}oX8 @}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X} +}oX} .+:.$&.>}. }Xo}XX1.%}X%}. }XX}. }Oo8 O}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}oX} X@:.%&.:}. } o}X 3X$}X&}X }.X} .}@X8 @}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} X+:.%&.:}. }.X}. 3.%} %}X }.X} .}oo8 @}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}oo} X+:.$*X:}. }.o}. 3X$}X%}. }.X} .}Oo8 O}%:}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}XX} .+:.%*X:}. }.o}. 3 %}X%}X }.X}  }OX8 O}.X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} X+:.$=.:}X }.X}. 3X$}X%}o@}XX} .}OX8 O}.o}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} X+:.$*X:}  }.o}..3X$}X%}#$} X} .}oo8 O}Xo}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}oX} XO:.$* :}X } o}X.1.%}X%}% }.X} .}oX8.O}Xo}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X} @}Xo} XO:.$=X:}X }XX}..1.$}X-}X }.X} .}@o8.@}Xo}OO}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}oX} .+:.%&X:}. }.o}X.3.%}@<}. }.X} .}oX7 O}XO}oX}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} X+>.$&.:}. }.o}..3.$}%*}. }.X} .}Oo7 @}Xo}OX}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}XX} .+:.%&.:}. }.X}X 1 =}X*}. }.X} .}OX8 O}Xo}O }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}Xo} .+:.%*X:}  }.o}X 2@,}X%}. }.X} .}Oo8 O}Xo}oX}<-}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} XO:.%* >}X } o}X 8%%}X%}. }XX} .}Oo8 @}Xo}O.}# 7}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} XO:.$*X:}  }.X} O7X%}X*}. } X} .}Oo8 +}oo}O.}#.6}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}Xo} X+:.$*X:}X }Xo}@%3X$}X%}. }.X} .}OX8 @}Xo}oX}#.7}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X} @}XX} X+:X$= :}X }XX}%X1X$}.%}. }.X} .}oX7 O}oo}o.}$.9#.}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.+}XX} .+: $=.:}. } @}X 1.$}X%}X }.X} .}OX8 O}oo}OX}@ 9#o}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}.X}.@}Xo} X+:X$*X:}X }O=}X.1X%}X%}X }.X} .}OX8 O}Xo}oX}# 9@ }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}@.}}.X}.@}Xo} X+:.$=.:}. }%O}. 2X$}.%}X }XX} .}Oo8 @}oo}o.}# 0@o,o@}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}X }}.X}.@}XX} X+:.$*.:} o}XO}. 2X$}.%}X.} X} .}oo8 +}Xo}OX}# 9#o< @}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}oX}}.o}.@}oX} X+:.$=.>}@*}.X}X 2 $}X%}. }.X} .}OX8 O}oo}o.}#.0# 1XopXO}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }} .}.@}XX} X+:.$&.>}*.}.o}X 2X%}.%}. }XX} .}Oo7 O}oo}O.}# 0#o<Xop O}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}..}.+}Xo} X+:.%* >}o }.o}. 2.%}.*}. }XX} .}OX8 @}Xo}o.}# 9@o<.op.o7o$}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.o}.+}oX} .@:.%*O7}  }XX}X 2.$}X%}. } X}  }Oo8 O}oo}O.}# 9# 3.Op o6 #}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.X}.@}Xo} X+:.%;*<}X }.o}. 2X%}.%}X.}.o} .}@X8 O}oo}OX}# 9#.3.ou.o4 #}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}oX}}.X}.@}Xo} X+:.%<o:}. }.o}. 2.$}.%}. }. } .}oo8.@}oo}o.}# 0#.3.ou o6.@}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.X}.+}XX}  +:O<=.:}. } X}. <.$}X*}. }XX} .}@o8 O}oo}O.}# 9#X3Xou.o4X@}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.X} @}Xo} XO<%**X:}. }.o}. 2.%}.%}. } X}  }oX8 O}Xo}X.}#.0@X3.ou.o4 #=O,}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.X}.+}XX} .@6o%*X:}. }.X}. 1.%}.%}. }.X} .}@.8 O}Xo}OX}#.9#X3XOt o4X@%X,}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o.}}.X}.@}XX} o-,X%&X:}. }.o}. 1.%}X%}. }.X} .}oo8 O}oo}o.}# 9#.3Xor o5X#%.,}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.X}.O}Xo}o*%:.$*.:}. }.o}. 1X$}.*}. }.X} .}oX8.@}oo}O.}# 9#X3oOr.o4X#=X,99}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.X}.@}XX}&O@:.%*.:}  }XX}  1X$}.%}. }.X} .}@o8 +}oo}X.}# 9#X3Xor o4 @%X: .}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.X}.@} X}X.+:X$= >}  }.o}. 1.$}X%}. }XX} X}OX8 O}oo}O.}# 9# 3XOe o6.#&.>  }@@}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}oX}}.X}X@}O=}  @: %%X:}X }.o}. 1X%}X%}. } X}  }Oo8 O}Xo}o.}# 9#X3.Oe o6 @& :  ; o}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.X}X@}*@} .O:.%*.:}. } X}X <X$}.%}. }XX} .}Oo8 O}oo}O.}# 9#.3Xow o6.@& >  , .}%=}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}.X}X@}@o} X@:.%*X:}. }Xo}  1X$}.%}. }.X} .}OX8 O}oo}o.}# 0# 3 Ow o4.#& > o1 .4 +}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}..}o-}XX} XO:.%&X>}. }.X}X <.$}X&}X.}.X} .}OO7 O}Xo}O.}# 0#o3XO0.o6.#& >  3.o6.#X.X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}..}*$}Xo} X@:.$& :}. }.o}. 2.%}.%}X }.X} .}OX8 @}oo}oX}# 0@ 3oO0 o6 @*.: .3..6.@XXO}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}XX}}..}+@}XX} X+:.%&.>}. }.o}. 2.%}.%}. }XX} .}Oo8 O}Xo}O.}# 0# 3Xo0 o4 @*.: .3 o6.@X.@OXu}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o.}}o*}.+}Xo} .O:.%*.:}  }XX}. <.%}.%}. } X}  }OX8 O}oo}o.}# 0#X3 @} o4 #*.:  3.o6.@X.++X0 #}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}o.}}&@} @}XX} X+:X$=.:}. }.o}. 2X%}.%}. }.X} .}OX7 @}oo}OX}# 0# 3X@} o6X#%.: X3.X5.#XX++X9 # .   }}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}X.}}@.}X@}Xo} X+: $*X:}X }XX}. 1.$} &}. }.X} .}OX8 O}Xo}XX}% 9# 3XO} o4 #&.: X3 o6.@XX+@X9 #     *%*,$#,$%}}}}}}}}}}"",\n""}}}}}}}}}}}}o }}..} @}.X}  +: $* :}X }Xo}X.1X$}O*}oX}Xo}Xo}++9X@}OO}@o}$o0$O3oO}.O6O#=X>XX4XO6X$@o@@O0X$oOXXo%X+:Xo,XO}}}}}}}}}}"",\n""}}}}}}}}}}}}%:}}$$}O#}}0}O+}<@}-O1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}"",\n""}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}""]\n\ntrace_unlocked = [""128 128 199 2 "",\n""   c black"",\n"".  c #010101"",\n""X  c #000200"",\n""o  c #000A02"",\n""O  c #000C02"",\n""+  c #011003"",\n""@  c #041306"",\n""#  c #071609"",\n""$  c #09180C"",\n""%  c #0B1A0D"",\n""&  c #0D1C0F"",\n""*  c #0E1D10"",\n""=  c #0F1E11"",\n""-  c #101F12"",\n"";  c #102013"",\n"":  c #112013"",\n"">  c #122113"",\n"",  c #142415"",\n""<  c #182C19"",\n""1  c #1E3B22"",\n""2  c #00410A"",\n""3  c #00430A"",\n""4  c #05490F"",\n""5  c #00500C"",\n""6  c #005A0E"",\n""7  c #005B0E"",\n""8  c #00690F"",\n""9  c #006D11"",\n""0  c #007E13"",\n""q  c #008614"",\n""w  c #02C720"",\n""e  c #00D320"",\n""r  c #00DF22"",\n""t  c #00F125"",\n""y  c #00F326"",\n""u  c #01F326"",\n""i  c #01F426"",\n""p  c #02F427"",\n""a  c #02F527"",\n""s  c #00F825"",\n""d  c #00FB26"",\n""f  c #02FA27"",\n""g  c #00FD26"",\n""h  c #01FD27"",\n""j  c #00FE26"",\n""k  c #00FF26"",\n""l  c #00FE27"",\n""z  c #01FE27"",\n""x  c #00FF27"",\n""c  c #02FD28"",\n""v  c #02FD29"",\n""b  c #03FD29"",\n""n  c #01FE28"",\n""m  c #01FF28"",\n""M  c #02FE28"",\n""N  c #03FE28"",\n""B  c #02FF28"",\n""V  c #03FE29"",\n""C  c #03FF29"",\n""Z  c #03FD2A"",\n""A  c #03FE2A"",\n""S  c #04FD2A"",\n""D  c #06FD2B"",\n""F  c #05FF2B"",\n""G  c #05FC2C"",\n""H  c #06FD2C"",\n""J  c #07FD2C"",\n""K  c #06FC2D"",\n""L  c #0AFB2F"",\n""P  c #0CFB2F"",\n""I  c #09FC2E"",\n""U  c #08FD2E"",\n""Y  c #09FD2E"",\n""T  c #0AFC2E"",\n""R  c #0AFC2F"",\n""E  c #09FF2F"",\n""W  c #0AFE2F"",\n""Q  c #0AF930"",\n""!  c #0CFB30"",\n""~  c #0FF932"",\n""^  c #0FFA32"",\n""/  c #0FFB33"",\n""(  c #0CFC30"",\n"")  c #0DFD31"",\n""_  c #0DFC32"",\n""`  c #0DFD32"",\n""\'  c #0EFE33"",\n""]  c #15F637"",\n""[  c #11FB35"",\n""{  c #12FA35"",\n""}  c #13FA36"",\n""|  c #14F837"",\n"" . c #14FB37"",\n"".. c #10FF34"",\n""X. c #12FC36"",\n""o. c #13FD37"",\n""O. c #1CF43D"",\n""+. c #15FD39"",\n""@. c #1DF83F"",\n""#. c #1BFE3E"",\n""$. c #1CFF3E"",\n""%. c #1CFE3F"",\n""&. c #1FFA40"",\n""*. c #2EEB4A"",\n""=. c #23F142"",\n""-. c #24F043"",\n"";. c #25F244"",\n"":. c #25FE46"",\n"">. c #29F348"",\n"",. c #2BF14A"",\n""<. c #30F24D"",\n""1. c #31F14E"",\n""2. c #3EE556"",\n""3. c #36E951"",\n""4. c #35EC50"",\n""5. c #39F155"",\n""6. c #32F951"",\n""7. c #33FB52"",\n""8. c #39FA56"",\n""9. c #3DFF5A"",\n""0. c #41E458"",\n""q. c #47E25D"",\n""w. c #47E55E"",\n""e. c #48E15E"",\n""r. c #48E15F"",\n""t. c #40E859"",\n""y. c #44E85D"",\n""u. c #59DC6C"",\n""i. c #5ADD6D"",\n""p. c #5BDD6D"",\n""a. c #58DE6C"",\n""s. c #58DF6C"",\n""d. c #5ADE6C"",\n""f. c #5BDE6D"",\n""g. c #5BDF6E"",\n""h. c #5CDE6E"",\n""j. c #5CDF6E"",\n""k. c #5CDF6F"",\n""l. c #4CE362"",\n""z. c #4AE561"",\n""x. c #4DEA65"",\n""c. c #50E165"",\n""v. c #53E168"",\n""b. c #55E069"",\n""n. c #57E06B"",\n""m. c #44FF60"",\n""M. c #51F96B"",\n""N. c #53FD6C"",\n""B. c #5DE070"",\n""V. c #6CFA80"",\n""C. c #75F387"",\n""Z. c #76FE8B"",\n""A. c #84CF8D"",\n""S. c #80FE93"",\n""D. c #8FF59E"",\n""F. c #8FF79F"",\n""G. c #8AFD9A"",\n""H. c #96FEA6"",\n""J. c #99FDA7"",\n""K. c #B3EEBB"",\n""L. c #A7F8B1"",\n""P. c #AFFBBA"",\n""I. c #B8F1BE"",\n""U. c #B6FBBF"",\n""Y. c #B8FDC1"",\n""T. c #C5EECB"",\n""R. c #C0F8C7"",\n""E. c #C2FCC9"",\n""W. c #C8FACE"",\n""Q. c #D9EBD9"",\n""!. c #CEFBD4"",\n""~. c #D6F2D9"",\n""^. c #E3FAE7"",\n""/. c #EBFBED"",\n""(. c #F5F6F4"",\n""). c gray97"",\n""_. c #F6FBF5"",\n""`. c #F6FBF7"",\n""\'. c #F7FBF7"",\n""]. c #F9F9F7"",\n""[. c #F8FAF6"",\n""{. c #F9F9F9"",\n""}. c #F9FBF9"",\n""|. c #FAFAF8"",\n"" X c #FBFAF9"",\n"".X c gray98"",\n""XX c #FBFBFB"",\n""oX c #FBFCFB"",\n""OX c #FCFDFA"",\n""+X c #FCFCFB"",\n""@X c #FCFEFA"",\n""#X c #FCFEFB"",\n""$X c gray99"",\n""%X c #FDFDFC"",\n""&X c #FDFDFD"",\n""*X c #FCFEFD"",\n""=X c #FEFEFE"",\n""-X c gray100"",\n"";X c None"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;XJ J j j j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X^ m m j m j m j m j m j j m Q ;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj m m j m j m j m j m j m j m j m ;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;XJ j m j m m j m j m j m j m j m j m j m m ;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj j m j m j j m j m j m j m j m j m j m j m m ;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm j m j m j m m j m j m j m j m j m j m j m j m j ;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm j m j m j m j j m j m j m j m j m j m j m j m j m N ;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj m j m j m j m j m j m j J m m j m j m j m j m m j j ;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj m j m j m j m j m j o.o.P A.m \' ) j m j m j m j j m m m ;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm m j m j m j m m j W ;X;X;X;X;X;X;X;X;XW m j m j m m j m j W ;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj m m j m j m m m 1.;X;X;X;X;X;X;X;X;X;X;X1.m j m j j m j m j ;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;XJ m j j m j m j m z.;X;X;X;X;X;X;X;X;X;X;X;X;Xy.j j m m j m j j ;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj j m m j m j j ) ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;XW m j j m j m m j ;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj j m j m j m m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm j m j m j m j ;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj m j m j m j ) ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;XW m j m j m j j ;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj j m m j m m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X6.j m j m j m j ;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj m m j j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm j m j m j m m ;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm m j m m j j ) ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X| m j m j m j m ;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj j m j j m j W ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X[ j m j m j m m ;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm j m j m j m m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X^ j m j m m j j ;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj m j m j m j m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;XJ m j m j j m m ;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj m m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;XJ j m j m j m j ;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm j j m j m j m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm m j m j m j j ;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X  ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xm j m j m j m j ;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj j j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;Xj m j m j m j j ;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X,.-.r.r.r.r.r.O.;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;XQ ] =.*.3.2.0.,.;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                  ;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                  ;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X^ ;.4.t.w.l.c.v.b.b.s.s.s.s.s.h.h.s.h.k.k.s.h.k.k.s.h.k.k.s.s.p.B.s.B.B.h.h.s.s.s.h.5.;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                  ;X;X          ;X;X;X;X;X;X;X;X;X;Xm m j m j m j m j m j m j m m m j m j m j m j m j m j m j m j m j m m m j j m m m m m j j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                  ;X;X          ;X;X;X;X;X;X;X;X;X;Xm j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m m j m j m j m j m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                  ;X              ;X;X;X;X;X;X;X;X;Xm m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j j m j m j m j m m N ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X                        ;X;X;X;X;X;X;X;X;XN j m j m j m j m j m j m j m j m j m j m m j m j m j m j m j m j m j m j m j m j m j m j j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X                        ;X;X;X;X;X;X;X;X;Xm m j m j m j m j m j m j m j m j m j m j j m j m j m j m j m j m j m j m j m j m j m j m m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X                      ;X;X;X;X;X;X;X;X;XN j m j m j m j m j m j m j m j m j m j m m j m j m j m j m j m j m j m j m j m j m j m j j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X                      ;X;X;X;X;X;X;X;X;Xm m j m j m j m j m j m j m j m j m j m j j m j m j m j m j m j m j m j m j m j m j m j m m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X                        ;X;X;X;X;X;X;X;Xm j m j m j m j m j m j m j m j m j m j m m j m j m j m j m j m j m j m j m j m j m j m j j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X                        ;X;X;X;X;X;X;X;XN m j m j m j m j m j m j m j m j m j m j j m j m j m j m j m j m j m j m j m j m j m j m m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X                        ;X;X;X;X;X;X;X;Xm j m j m j m j m j m j m j m j m j m j m m j m j m j m j m j m j m j m j m j m j m j m j j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X              ;X        ;X;X;X;X;X;X;X;XN m j m j m j m j m j m j m j m j m j m j j m j m j m j m j m j m j m j m j m j m j m j m m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X    ;X;X;X        ;X;X;X            ;X        ;X;X;X;X;X;X;X;Xm j m j m j m j m j m j m j m j m j m j m m j m j m j m j m j m j m j m j m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X        ;X;X;X            ;X        ;X;X;X;X;X;X;X;Xm m j m j m j m j m j m j m j m j m j j j +.x.&.m j m j m j m j m j m j m j m j m j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X          ;X;X;X          ;X;X          ;X;X;X    ;X;Xm j m j m j m j m j m j m j m j m j m W C.^.)./.Z.m j m j m j m j m j m j m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X          ;X;X;X          ;X;X          ;X;X        ;Xm m j m j m j m j m j m j m j m j m j N.).|.XX*X_.V.m j m j m j m j m j m j m j m j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X          ;X;X;X        ;X;X        ;XN j m j m j m j m j m j m j m j m j L I.|.|.*X|.|.Y.j m j m j m j m j m j m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                  ;X;X;X;X          ;X;X;X        ;X;X        ;Xm m j m j m j m j m j m j m j m j m [ Q.*X*XXX*X|.Y.j j m j m j m j m j m j m j m j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                  ;X;X;X;X          ;X;X;X        ;X;X        1 N j m j m j m j m j m j m j m j m j m G.*X=XXX|.|.L.j m j m j m j m j m j m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X      ;X;X;X;X                    < m m j m j m j m j m j m j m j m j m j o.P.XX*X*XW.&.m j m j m j m j m j m j m j m j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X                    , N j m j m j m j m j m j m j m j m j m j :._.=X|.m.m j m j m j m j m j m j j m j m j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X                  > f m j m j m j m j m j m j m j m j m j m 7.).=X=XM.j m j m j m j m j m j m m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X                  ; a j m j m j m j m j m j m j m j m j m j F.=X=X*XK.m j m j m j m j m j m j j m j m j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X                  > a m j m j m j m j m j m j m j m j m j m H.=X*X*XE.j m j m j m j m j m j m m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X                  ; a m j m j j m j m j m j m j m j m j m [ ~.*X*X*X!.) j m j m j m j m j m j j m j m j m j m j m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X                  ; a j m j m m j m j m j m j m j m j m j #.|.*X*X*X|.8.m j m j m j m j m j m m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X                  ; a m j m j j m j m j m j m j m j m j m #.*X*X*X*XOX9.j m j m j m j m j m j j m j m j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X                ; a j m j m m j m j m j m j m j m j m j #.OX*X*X*XOX9.m j m j m j m j m j m m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X                = a m j m j j m j m j m j m j m j m j m ^ T.*X*X*XR.W m m j j m j m j m j m j m j m j m j m j m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X                = a j m j m m j m j m j m j m j m j m j m &.D.J.S.+.j m j m m j m j m j m j m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X                & u m j m j j m j m j m j m j m j m j m j m j m j m m j m j j m j m j m j m j m j m j m j m j m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X      ;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                % u j m j m m j m j m j m j m j m j m j m j m j m j j m j m m j m j m j m j m j m j m j m j m j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X          ;X;X;X;X;X;X          ;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X  $ u j j m j j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X          ;X;X;X;X;X;X          ;X;X        ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X  # u j m j m m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X        ;X;X;X;X;X;X          ;X;X        ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X  @ u m j m j j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X          ;X;X;X;X;X          ;X          ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X  + u j m j m m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j m j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X          ;X;X;X;X;X                      ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X  o w j m j m j j m j m j m j m j j m j m j m j m j m j m j m j m j m j m j m j m m j m m j m m ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X        ;X;X;X;X;X                      ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X    ;X;X;X;X  4 e r j j j m j s j m j j j m m j m j m j m j m j m j m j m j m j m j j j j j j j j j j j ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X        ;X;X;X;X;X                    ;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X      O ;X;X;X;X3 3 5 ;X;X;X;X;X;X;X8 7 7 7 0 ;X;Xq 7 7 7 7 7 9 ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X          ;X;X;X;X                    ;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X      ;X;X;X;X;X;X;X          ;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X        ;X;X;X;X                    ;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X          ;X;X;X;X;X;X          ;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X        ;X;X;X                      ;X;X;X      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X          ;X;X;X;X;X;X            ;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X          ;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X          ;X;X;X;X;X              ;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X        ;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X          ;X;X;X;X;X                                ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X        ;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X            ;X;X;X;X;X                                ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X        ;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X              ;X;X;X;X                                ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X        ;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                        ;X;X;X                                  ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X          ;X        ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                        ;X;X;X                        ;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X          ;X        ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X        ;X;X            ;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X        ;X        ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X        ;X;X            ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X        ;X        ;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X          ;X;X            ;X          ;X;X;X    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X                  ;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                        ;X          ;X;X;X          ;X;X        ;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X                  ;X;X      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                        ;X        ;X;X;X;X        ;X;X;X        ;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X                  ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X        ;X        ;X;X;X;X;X      ;X;X;X        ;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X                ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X                  ;X;X;X;X;X    ;X;X;X;X        ;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X                ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X                  ;X;X;X;X;X;X;X;X;X;X;X        ;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X                ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X                ;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X                ;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X      ;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X      ;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X                        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X              ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X                        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X            ;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X        ;X;X;X;X    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X          ;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X          ;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X        ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X      ;X;X;X;X        ;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X                    ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X      ;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X    ;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X          ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X        ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X      ;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X"",\n"";X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X;X""]\n\ntrace_locked = [""128 128 167 2 "",\n""   c black"",\n"".  c #460000"",\n""X  c #550000"",\n""o  c #570000"",\n""O  c #680000"",\n""+  c #6E0000"",\n""@  c #FD0000"",\n""#  c #FD0101"",\n""$  c #FE0000"",\n""%  c red"",\n""&  c #FE0101"",\n""*  c #FD0202"",\n""=  c #FD0303"",\n""-  c #FE0202"",\n"";  c #FF0202"",\n"":  c #FE0303"",\n"">  c #FF0303"",\n"",  c #FD0404"",\n""<  c #FD0505"",\n""1  c #FE0404"",\n""2  c #FF0404"",\n""3  c #FD0606"",\n""4  c #FB0A0A"",\n""5  c #FB0B0A"",\n""6  c #FD0808"",\n""7  c #FD0909"",\n""8  c #FD0A0A"",\n""9  c #FD0B0B"",\n""0  c #FB0D0D"",\n""q  c #FA0F0F"",\n""w  c #FE0C0C"",\n""e  c #F51515"",\n""r  c #F61515"",\n""t  c #F71515"",\n""y  c #F81010"",\n""u  c #FC1111"",\n""i  c #FF1010"",\n""p  c #FE1111"",\n""a  c #FA1414"",\n""s  c #F61919"",\n""d  c #F51A1A"",\n""f  c #F41B1B"",\n""g  c #F41C1C"",\n""h  c #FB1818"",\n""j  c #FE1A1A"",\n""k  c #EF2423"",\n""l  c #EF2B2B"",\n""z  c #EB2F2D"",\n""x  c #F12424"",\n""c  c #F22525"",\n""v  c #F02626"",\n""b  c #FD2321"",\n""n  c #FF2222"",\n""m  c #F82624"",\n""M  c #FB2626"",\n""N  c #FA2727"",\n""B  c #FB2727"",\n""V  c #FE2424"",\n""C  c #F32D2D"",\n""Z  c #F02E2E"",\n""A  c #F42C2C"",\n""S  c #F42D2D"",\n""D  c #FB2929"",\n""F  c #FF2928"",\n""G  c #FE2A2A"",\n""H  c #FE2B2A"",\n""J  c #FB2F2F"",\n""K  c #FE2E2D"",\n""L  c #EE302E"",\n""P  c #EA3333"",\n""I  c #ED3030"",\n""U  c #EA3434"",\n""Y  c #EA3634"",\n""T  c #E93636"",\n""R  c #EC3534"",\n""E  c #E73B3B"",\n""W  c #E53F3D"",\n""Q  c #EA3838"",\n""!  c #EA3C3B"",\n""~  c #E83D3D"",\n""^  c #EA3C3C"",\n""/  c #FF3333"",\n""(  c #E8403F"",\n"")  c #E9403F"",\n""_  c #DE5251"",\n""`  c #DC5453"",\n""\'  c #E64241"",\n""]  c #E74241"",\n""[  c #E34442"",\n""{  c #E64443"",\n""}  c #E74443"",\n""|  c #E34746"",\n"" . c #E64544"",\n"".. c #E44645"",\n""X. c #E74645"",\n""o. c #E54646"",\n""O. c #E44746"",\n""+. c #E54746"",\n""@. c #E44747"",\n""#. c #E64646"",\n""$. c #E64746"",\n""%. c #E84343"",\n""&. c #E54847"",\n""*. c #E04B4A"",\n""=. c #E54848"",\n""-. c #E44948"",\n"";. c #E54948"",\n"":. c #E64A49"",\n"">. c #EA4C4B"",\n"",. c #F44747"",\n""<. c #F14B4B"",\n""1. c #FC5151"",\n""2. c #FA5B5B"",\n""3. c #F86160"",\n""4. c #F86464"",\n""5. c #FC6868"",\n""6. c #ED7473"",\n""7. c #F98887"",\n""8. c #FE8C8B"",\n""9. c #EE9292"",\n""0. c #F29393"",\n""q. c #F89B9B"",\n""w. c #FB9B9A"",\n""e. c #FD9D9D"",\n""r. c #C5B2B0"",\n""t. c #ECA8A8"",\n""y. c #F4A4A3"",\n""u. c #F8ACAB"",\n""i. c #FEB2B1"",\n""p. c #FCB8B8"",\n""a. c #FBBEBE"",\n""s. c #FAC6C6"",\n""d. c #F2CDCC"",\n""f. c #FCCCCA"",\n""g. c #F8CECE"",\n""h. c #FBD7D7"",\n""j. c #F0E2E2"",\n""k. c #F6ECEC"",\n""l. c #F9ECEC"",\n""z. c #F8F2F2"",\n""x. c #FDF0F0"",\n""c. c #F9F4F3"",\n""v. c #F8F4F4"",\n""b. c #FBF4F4"",\n""n. c #F8F6F6"",\n""m. c #F8F8F8"",\n""M. c #FBFAF8"",\n""N. c gray98"",\n""B. c #FBFAFA"",\n""V. c #FBFBFA"",\n""C. c #FAFAFB"",\n""Z. c #FBFBFB"",\n""A. c #FEFAF9"",\n""S. c #FCFBFA"",\n""D. c #FCFBFB"",\n""F. c #FDFBFB"",\n""G. c #FCFCFB"",\n""H. c #FBFCFC"",\n""J. c gray99"",\n""K. c #FCFCFD"",\n""L. c #FCFDFD"",\n""P. c #FDFDFD"",\n""I. c #FDFEFD"",\n""U. c #FDFDFE"",\n""Y. c #FDFEFE"",\n""T. c #FEFEFE"",\n""R. c None"",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ 1 $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.q $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 1 R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ 1 q $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.1 $ $ $ $ $ $ $ $ $ $ $ $ b j S r.Z V S $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ 1 R.R.R.R.R.R.R.R.R.R.q 1 $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ r R.R.R.R.R.R.R.R.R.R.R.R.R.1 $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ a R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.1 $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.9 $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.1 $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.S $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ q R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.5 $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.N $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.  R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.d ` v k ( Y z v R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.Y _ *.[ E U r g R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                  R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                  R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ y v L Y ! ) ] %.$.&.&.#.#.;.;.;.;.;.>.;.&.&.#.&.&.#.%.[ %.] ] ~ ~ ! R I v v d q 9 $ R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                  R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                  R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.d $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                  R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.                        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.                        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.                        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.                        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.                        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.              R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.    R.R.R.        R.R.R.            R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.        R.R.R.            R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 1 i <.V q $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.          R.R.R.          R.R.          R.R.R.    R.R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 4.k.n.b.g.b $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.          R.R.R.          R.R.          R.R.        R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ M c.D.H.Z.Z.i.2 $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.          R.R.R.        R.R.        R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 0.Z.Z.A.L.Z.Z.H $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                  R.R.R.R.          R.R.R.        R.R.        R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ q.Z.L.L.A.Z.A.H $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                  R.R.R.R.          R.R.R.        R.R.        R.R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ ,.n.L.Z.H.H.f.i $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.      R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 9 9.x.L.L.l.1.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 9 a.Z.L.t.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ H v.H.L.p.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ K A.H.L.s.9 $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 6.D.L.L.n.K $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ w.L.L.L.D./ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ e.D.L.L.A.2.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ j j.Z.L.L.L.u.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ y d.L.D.L.D.y.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 5.c.Z.L.h.V $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 3.7.8.H $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.      R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.          R.R.R.R.R.R.          R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.        R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.          R.R.R.R.R.R.          R.R.        R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.        R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.        R.R.R.R.R.R.          R.R.        R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.        R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.          R.R.R.R.R.          R.          R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.          R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.          R.R.R.R.R.                      R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.          R.R.R.R.R.R.R.R.$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.        R.R.R.R.R.                      R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.    R.R.R.R.        R.R.R.R.R.R.R.R.a $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 1 R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.        R.R.R.R.R.                    R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.      R.R.R.R.R.R.R.o . . . O R.R.+ . . . . . o R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.          R.R.R.R.                    R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.      R.R.R.R.R.R.R.          R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.        R.R.R.R.                    R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.          R.R.R.R.R.R.          R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.        R.R.R.                      R.R.R.      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.          R.R.R.R.R.R.            R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.          R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.          R.R.R.R.R.              R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.        R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.          R.R.R.R.R.                                R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.        R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.            R.R.R.R.R.                                R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.        R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.              R.R.R.R.                                R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.        R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                        R.R.R.                                  R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.          R.        R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                        R.R.R.                        R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.          R.        R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.        R.R.            R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.        R.        R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.        R.R.            R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.        R.        R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.          R.R.            R.          R.R.R.    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.                  R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                        R.          R.R.R.          R.R.        R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.                  R.R.      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                        R.        R.R.R.R.        R.R.R.        R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.                  R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.        R.        R.R.R.R.R.      R.R.R.        R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.                R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.                  R.R.R.R.R.    R.R.R.R.        R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.                R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.                  R.R.R.R.R.R.R.R.R.R.R.        R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.                R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.                R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.                R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.      R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.      R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.                        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.              R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.                        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.            R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.        R.R.R.R.    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.          R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.          R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.        R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.      R.R.R.R.        R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.                    R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.      R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.    R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.          R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.        R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.      R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R."",\n""R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.R.""]\n\ncolormap = [""128 128 2 1 "",\n""  c black"",\n"". c None"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""..........................................................             ........................................................."",\n"".....................................................                        ..................................................."",\n"".................................................                                ..............................................."",\n""..............................................                                     ............................................."",\n""...........................................                                           .........................................."",\n"".........................................                                               ........................................"",\n"".......................................                                                   ......................................"",\n"".....................................                                                       ...................................."",\n""....................................                    .....                                 .................................."",\n""..................................                 ..........                                  ................................."",\n"".................................               .............                                    ..............................."",\n""...............................               ...............                                     .............................."",\n""..............................             ..................                                      ............................."",\n"".............................             ...................                                        ..........................."",\n""............................            .....................                                         .........................."",\n""...........................           .......................                                          ........................."",\n"".........................            ........................                                           ........................"",\n"".........................          ..........................                                            ......................."",\n""........................          ...........................                                             ......................"",\n"".......................          ............................                                              ....................."",\n""......................          .............................                                              ....................."",\n"".....................          ..............................                                               ...................."",\n""....................          ...............................                                                ..................."",\n""....................         ................................                                                 .................."",\n""...................         .................................                                                 .................."",\n""..................         ..................................                                                  ................."",\n""..................         ..................................                                                   ................"",\n"".................         ...................................                                                   ................"",\n""................         ....................................                                                    ..............."",\n""................        .....................................                                                    ..............."",\n""...............         .....................................                                                     .............."",\n""...............        ......................................                                                     .............."",\n""..............         ......................................                                                      ............."",\n""..............        .......................................                                                      ............."",\n""..............        .......................................                                                       ............"",\n"".............        ........................................                                                       ............"",\n"".............        ........................................                                                       ............"",\n""............        .........................................                                                        ..........."",\n""............        .........................................                                                        ..........."",\n""............        .........................................                                                         .........."",\n""............       ..........................................                                                         .........."",\n""...........        ..........................................                                                         .........."",\n""...........        ..........................................                                                         .........."",\n""...........       ...........................................                                                          ........."",\n""...........       ...........................................                                                          ........."",\n""..........        ...........................................                                                          ........."",\n""..........        ...........................................                                                          ........."",\n""..........        ...........................................                                                          ........."",\n""..........       ............................................                                                          ........."",\n""..........       ............................................                                                           ........"",\n""..........       ............................................                                                           ........"",\n""..........       ............................................                                                           ........"",\n""..........       ............................................                                                           ........"",\n""..........       ............................................                                                           ........"",\n"".........        ............................................                                                           ........"",\n"".........        ............................................                                                           ........"",\n"".........        ............................................                                                           ........"",\n""..........       ............................................                                                           ........"",\n""..........       ............................................                                                           ........"",\n""..........       ............................................                                                           ........"",\n""..........       ............................................                                                           ........"",\n""..........       ............................................                                                           ........"",\n""..........       ............................................                                                          ........."",\n""..........        ...........................................                                                          ........."",\n""..........        ...........................................                                                          ........."",\n""..........        ...........................................                                                          ........."",\n""...........       ...........................................                                                          ........."",\n""...........        ..........................................                                                         .........."",\n""...........        ..........................................                                                         .........."",\n""...........        ..........................................                                                         .........."",\n""............       ..........................................                                                         .........."",\n""............        .........................................                                                        ..........."",\n""............        .........................................                                                        ..........."",\n"".............       .........................................                                                        ..........."",\n"".............        ........................................                                                       ............"",\n"".............        ........................................                                                       ............"",\n""..............        .......................................                                                       ............"",\n""..............        .......................................                                                      ............."",\n""...............        ......................................                                                      ............."",\n""...............        ......................................                                                     .............."",\n""................        .....................................                                                     .............."",\n""................         ....................................                                                    ..............."",\n"".................        ....................................                                                    ..............."",\n"".................         ...................................                                                   ................"",\n""..................         ..................................                                                  ................."",\n""..................          .................................                                                  ................."",\n""...................         .................................                                                 .................."",\n""....................         ................................                                                ..................."",\n"".....................         ...............................                                                ..................."",\n"".....................          ..............................                                               ...................."",\n""......................          .............................                                              ....................."",\n"".......................           ...........................                                             ......................"",\n""........................           ..........................                                            ......................."",\n"".........................           .........................                                           ........................"",\n""..........................           ........................                                           ........................"",\n""...........................            ......................                                         .........................."",\n""............................             ....................                                        ..........................."",\n"".............................             ...................                                       ............................"",\n""..............................              .................                                      ............................."",\n""................................               ..............                                     .............................."",\n"".................................                ............                                   ................................"",\n""..................................                  .........                                  ................................."",\n""....................................                      ...                                ..................................."",\n""......................................                                                      ...................................."",\n""........................................                                                  ......................................"",\n""..........................................                                              ........................................"",\n""............................................                                         ..........................................."",\n""...............................................                                    ............................................."",\n""..................................................                             ................................................."",\n""......................................................                     ....................................................."",\n""...............................................................   .............................................................."",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n""................................................................................................................................""]\n\nview_unlocked = [""128 128 217 2 "",\n""   c black"",\n"".  c #010101"",\n""X  c #000200"",\n""o  c #000A02"",\n""O  c #011103"",\n""+  c #001303"",\n""@  c #001C04"",\n""#  c #011E05"",\n""$  c #121211"",\n""%  c gray7"",\n""&  c #1B1B19"",\n""*  c #002305"",\n""=  c #002906"",\n""-  c #002F07"",\n"";  c #042208"",\n"":  c #07250B"",\n"">  c #0A280E"",\n"",  c #003308"",\n""<  c #003708"",\n""1  c #003A09"",\n""2  c #003D09"",\n""3  c #003F0A"",\n""4  c #0C2A10"",\n""5  c #0E2C12"",\n""6  c #0F2D14"",\n""7  c #102E15"",\n""8  c #112F15"",\n""9  c #112F16"",\n""0  c #123017"",\n""q  c #133017"",\n""w  c #133117"",\n""e  c #00410A"",\n""r  c #00420A"",\n""t  c #00430A"",\n""y  c #00440A"",\n""u  c #00450A"",\n""i  c #00460B"",\n""p  c #00470B"",\n""a  c #00480B"",\n""s  c #004B0B"",\n""d  c #004E0C"",\n""f  c #00530D"",\n""g  c #03520F"",\n""h  c #007913"",\n""j  c #007B13"",\n""k  c #007C13"",\n""l  c #007D13"",\n""z  c #008D15"",\n""x  c #009716"",\n""c  c #00CC1F"",\n""v  c #02D222"",\n""b  c #00D521"",\n""n  c #00DB21"",\n""m  c #00E122"",\n""M  c #00E623"",\n""N  c #00EB24"",\n""B  c #00EE25"",\n""V  c #00F125"",\n""C  c #00F425"",\n""Z  c #00F626"",\n""A  c #00F826"",\n""S  c #00F926"",\n""D  c #01F827"",\n""F  c #01F927"",\n""G  c #00FA26"",\n""H  c #00FB26"",\n""J  c #00FC26"",\n""K  c #00FD26"",\n""L  c #00FC27"",\n""P  c #00FD27"",\n""I  c #01FD27"",\n""U  c #00FE26"",\n""Y  c #01FE26"",\n""T  c #00FE27"",\n""R  c #01FE27"",\n""E  c #00FF27"",\n""W  c #02FD28"",\n""Q  c #02FD29"",\n""!  c #03FD29"",\n""~  c #01FE28"",\n""^  c #02FE28"",\n""/  c #02FE29"",\n""(  c #03FE29"",\n"")  c #02FF29"",\n""_  c #03FF29"",\n""`  c #03FE2A"",\n""\'  c #03FF2A"",\n""]  c #05FC2A"",\n""[  c #04FD2A"",\n""{  c #04FD2B"",\n""}  c #06FC2B"",\n""|  c #06FD2B"",\n"" . c #04FF2A"",\n"".. c #07FD2D"",\n""X. c #09FB2E"",\n""o. c #0BFA2F"",\n""O. c #0AFB2F"",\n""+. c #08FC2D"",\n""@. c #08FE2D"",\n""#. c #09FD2E"",\n""$. c #09FE2F"",\n""%. c #0CFA30"",\n""&. c #0BFC30"",\n""*. c #0BFD30"",\n""=. c #0DFF32"",\n""-. c #10F734"",\n"";. c #13FA36"",\n"":. c #14FA37"",\n"">. c #11FE35"",\n"",. c #11FC36"",\n""<. c #12FF36"",\n""1. c #15FC37"",\n""2. c #16F538"",\n""3. c #16F539"",\n""4. c #18F739"",\n""5. c #1EF43D"",\n""6. c #1EF63E"",\n""7. c #17F939"",\n""8. c #15FD38"",\n""9. c #17FD3A"",\n""0. c #29EF47"",\n""q. c #2FEB4B"",\n""w. c #2FEC4B"",\n""e. c #33ED4E"",\n""r. c #24F745"",\n""t. c #20F941"",\n""y. c #23F843"",\n""u. c #21FD42"",\n""i. c #22FF43"",\n""p. c #23FF44"",\n""a. c #2CF049"",\n""s. c #2FF14C"",\n""d. c #29FB49"",\n""f. c #2BFF4B"",\n""g. c #3AE753"",\n""h. c #39EB53"",\n""j. c #3EE957"",\n""k. c #3EEA57"",\n""l. c #33F050"",\n""z. c #37F054"",\n""x. c #31FE50"",\n""c. c #32FE50"",\n""v. c #32FF51"",\n""b. c #36FE54"",\n""n. c #46DC5C"",\n""m. c #47DC5D"",\n""M. c #48DC5D"",\n""N. c #49DD5E"",\n""B. c #42E35A"",\n""V. c #43E65B"",\n""C. c #46E25E"",\n""Z. c #46E55D"",\n""A. c #45E65C"",\n""S. c #49E25E"",\n""D. c #48E55E"",\n""F. c #41E859"",\n""G. c #41F75C"",\n""H. c #4BDE60"",\n""J. c #55DD69"",\n""K. c #54DE69"",\n""L. c #62DD74"",\n""P. c #49E360"",\n""I. c #4AE360"",\n""U. c #49E460"",\n""Y. c #4AE461"",\n""T. c #4BE461"",\n""R. c #4BE561"",\n""E. c #4BE562"",\n""W. c #4CE662"",\n""Q. c #4FF969"",\n""!. c #5FE874"",\n""~. c #61F977"",\n""^. c #66FF7C"",\n""/. c #6DFE83"",\n""(. c #72FC86"",\n""). c #8ECA96"",\n""_. c #87F797"",\n""`. c #87F897"",\n""\'. c #8BF59B"",\n""]. c #8CFC9C"",\n""[. c #9AFDA7"",\n""{. c #9DF0A9"",\n""}. c #9EFBAB"",\n""|. c #A0FDAD"",\n"" X c #A5F7B0"",\n"".X c #ACFBB6"",\n""XX c #ABFDB6"",\n""oX c #B1F7BC"",\n""OX c #B5FBBF"",\n""+X c #B7FEC2"",\n""@X c #BEFAC6"",\n""#X c #CDF2D0"",\n""$X c #CDF2D2"",\n""%X c #E4EEE3"",\n""&X c #E8F5E9"",\n""*X c #F3F9F2"",\n""=X c #F4FBF3"",\n""-X c #F3FAF4"",\n"";X c #F7F8F7"",\n"":X c #F5FDF5"",\n"">X c #F5FCF6"",\n"",X c #F8F9F6"",\n""<X c #FAF9F7"",\n""1X c #F8FDF6"",\n""2X c #FBFAF9"",\n""3X c gray98"",\n""4X c #FBFBFB"",\n""5X c #FAFEFB"",\n""6X c #FCFCFB"",\n""7X c #FCFDFB"",\n""8X c gray99"",\n""9X c #FDFDFD"",\n""0X c #FCFEFC"",\n""qX c #FDFFFD"",\n""wX c #FEFEFE"",\n""eX c gray100"",\n""rX c None"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX( | E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXO.E E E E E E E E E E E E ( %.rXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX| E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX( E E E E E E E E E E E E E E E E E E E W rXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E E E E E E E E E E E E E E E E E E E | rXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXW E E E E E E E E E E E E ( O.E E E E E E E E E E E E F rXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E E E E 9.>.4.).( 8.@.E E E E E E E E E E ! rXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E E E >.rXrXrXrXrXrXrXrXrX@.E E E E E E E E E @.rXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E O.z.rXrXrXrXrXrXrXrXrXrXrXl.| E E E E E E E E rXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX| E E E E E E E ! L.rXrXrXrXrXrXrXrXrXrXrXrXrXj.E E E E E E E E rXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E :.rXrXrXrXrXrXrXrXrXrXrXrXrXrXrX&.E E E E E E E E rXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E ! rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX( E E E E E E E rXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E :.rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX! E E E E E E E rXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXd.E E E E E E E rXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E rXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E :.rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXO.E E E E E E E rX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E &.rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX..E E E E E E E rX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E ( rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX| E E E E E E E rX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX| E E E E E E E rX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX( E E E E E E E rX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrXrXrXE E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E rX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                        rXrXrXE E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E rX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                              rXrXE E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E rX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                  rXa.w.J.J.J.J.J.3.rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX-.3.q.g.B.H.C.s.rX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX% % % % % % % % % % % % % % % % % & rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                      rXrXrXrXrXrX%.5.0.e.h.j.F.V.A.A.D.D.M.M.M.M.M.M.M.M.H.M.M.M.M.M.M.M.M.M.M.S.W.T.T.T.T.T.T.I.I.T.r.rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                    rXrXrX( E E E E E E E E E E E E E E E E E E E E E ( E E ( ( E E ( ( E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXW E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E | rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX          rXrXrXE E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX      rXrXrXE E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrXrXrXrXrXrXE E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                rXrXrXrXrXrXrXrXrXrXrXE E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                      rXrXrXrXrXrXrXrXrXE E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                              rXrXrXrXrXrXrXW E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                    rXrXrXrXrXE E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                              rXW E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                w F E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                  w F E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                    w F E E E E E E E E E E E E E E E E E E E | r.!.t.( E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                      w F E E E E E E E E E E E E E E E E E E :.\'.*X4X>X/.( E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                        w F E E E E E E E E E E E E E E E E E E (.,X4X4X8X=X~.E E E E E E E E E E E E E E E E E E E E x rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                          w F E E E E E E E E E E E E E E E E E :.#X8X4X8X4X<X}.E E E E E E E E E E E E E E E E E E E E l   rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                            w F E E E E E E E E E E E E E E E E E 5.%X8X8X8X2X2X}.( E E E E E E E E E E E E E E E E E E E l     rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                              w F E E E E E E E E E E E E E E E E E E [.8X8XwX4X>X`.E E E E E E E E E E E E E E E E E E E E l       rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                                w F E E E E E E E E E E E E E E E E E E >.OX8X8XwX.X&.E E E E E E E E E E E E E E E E E E E E l         rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                                  w F E E E E E E E E E E E E E E E E E E E b.4XwX4Xf.E E E E E E E E E E E E E E E E E E E E E l           rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                                    w F E E E E E E E E E E E E E E E E E E E Q.4XwXwXG.E E E E E E E E E E E E E E E E E E E E E l             rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                                      0 F E E E E E E E E E E E E E E E E E E E oX4XwXwX{.E E E E E E E E E E E E E E E E E E E E E l               rXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                                        w F E E E E E E E E E E E E E E E E E E E +XwXwXwXXXE E E E E E E E E E E E E E E E E E E E E l                 rXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrX                                                                                          0 F E E E E E E E E E E E E E E E E E E t.&XwXwXwX@X@.E E E E E E E E E E E E E E E E E E E E l                   rXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrX                                                                                            0 F E E E E E E E E E E E E E E E E E E c.wXwXwXwX*Xu.E E E E E E E E E E E E E E E E E E E E j                     rXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrX                                                                                              7 F E E E E E E E E E E E E E E E E E E c.wXwXwXwX1Xp.E E E E E E E E E E E E E E E E E E E E j                       rXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrX                            rXrXrXrXrXrXrX                                                      0 F E E E E E E E E E E E E E E E E E E c.4XwXwXwX:Xu.E E E E E E E E E E E E E E E E E E E E z                         rXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrX                      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                              7 F E E E E E E E E E E E E E E E E E E 7.#X8XwX4X X( ( E E E E E E E E E E E E E E E E E E E rXrXrX                      rXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                        6 F E E E E E E E E E E E E E E E E E E ( t._.].^.*.E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrX                    rXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                      5 F E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrX                  rXrXrXrXrXrXrX"",\n""rXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                  4 F E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrX                rXrXrXrXrXrX"",\n""rXrXrXrXrX                rXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrX                                > F E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrX                rXrXrXrXrX"",\n""rXrXrXrXrX              rXrXrXrXrXrXrXrXrX                            rXrXrXrXrXrXrXrX                              : Z E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E F s   rXrXrXrXrXrXrXrXrX              rXrXrXrXrX"",\n""rXrXrXrX              rXrXrXrXrXrXrXrX                                  rXrXrXrXrXrXrXrX                            ; F E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E Z s       rXrXrXrXrXrXrXrX              rXrXrXrX"",\n""rXrXrXrX              rXrXrXrXrXrX                        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                          # Z E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrX            rXrXrXrX"",\n""rXrXrX              rXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                        + v E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E rXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrX"",\n""rXrXrX            rXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                          g c b n m M N B V Z Z Z F F E E E E E F E E ( E E E E E ( E E F E E F F F E E E E E E F E rXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rXrXrX"",\n""rXrX              rXrXrXrXrX                rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                            o + # * = - , < 1 3 3 e e e u u p u u a rXrXrXrXrXrXu u u u u u e f rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrX"",\n""rXrX            rXrXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                    rXrXrXrXrX                rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rXrX"",\n""rX              rXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                rXrXrXrXrXrX            rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rX"",\n""rX            rXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                rXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rX"",\n""rX            rXrXrXrXrX            rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                            rXrXrXrX                            rXrXrXrXrX            rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rX"",\n""rX            rXrXrXrXrX          rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                      rXrXrXrXrXrXrXrX                      rXrXrXrXrX            rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rX"",\n""rX          rXrXrXrXrX            rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrXrX                    rXrXrXrXrX          rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX          rX"",\n""            rXrXrXrXrX          rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrX          rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            "",\n""            rXrXrXrXrX          rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrX        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            "",\n""            rXrXrXrXrX        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrX          rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            "",\n""            rXrXrXrXrX        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrXrX                rXrXrXrX        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            "",\n""            rXrXrXrXrX      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrX        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            "",\n""            rXrXrXrXrX      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrX        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            "",\n""            rXrXrXrXrX      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrX      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            "",\n""rX          rXrXrXrXrX      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrXrX                    rXrXrXrXrX    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            "",\n""rX            rXrXrXrX      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                      rXrXrXrXrXrXrXrX                      rXrXrXrXrX    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rX"",\n""rX            rXrXrXrXrX    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                        rXrXrXrXrXrX                        rXrXrXrXrX    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rX"",\n""rX            rXrXrXrXrX    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                rXrXrXrXrX  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rX"",\n""rX              rXrXrXrXrX  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                rXrXrXrXrX  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rX"",\n""rXrX            rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rXrX"",\n""rXrX            rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rX                                        rX            rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rXrX"",\n""rXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rXrX                                    rXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrX"",\n""rXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrX                                rXrXrXrX            rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rXrXrX"",\n""rXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrXrXrX                        rXrXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrX"",\n""rXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX            rXrXrXrXrXrXrXrXrXrX            rXrXrXrXrXrXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrX"",\n""rXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrXrX"",\n""rXrXrXrXrX                rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                rXrXrXrXrX"",\n""rXrXrXrXrXrX                rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                rXrXrXrXrXrX"",\n""rXrXrXrXrXrXrX                rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                rXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                  rXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                    rXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrX                        rXrXrXrXrXrXrXrXrXrXrXrX                        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                        rXrXrXrXrXrXrXrXrXrXrXrX                        rXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrX                                                                  rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                                  rXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrX                                                              rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                              rXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                      rXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                                rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                                      rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX                        rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX"",\n""rXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrX""]\n\nview_locked = [""128 128 214 2 "",\n""   c black"",\n"".  c #010000"",\n""X  c #010101"",\n""o  c #020000"",\n""O  c #030000"",\n""+  c #060000"",\n""@  c #0D0000"",\n""#  c gray5"",\n""$  c #0E0E0E"",\n""%  c #130000"",\n""&  c #180000"",\n""*  c #1C0000"",\n""=  c #130D0D"",\n""-  c #120E0D"",\n"";  c #10100F"",\n"":  c #101010"",\n"">  c #111110"",\n"",  c gray7"",\n""<  c #200000"",\n""1  c #220000"",\n""2  c #240000"",\n""3  c #260000"",\n""4  c #270000"",\n""5  c #290000"",\n""6  c #2A0000"",\n""7  c #2B0000"",\n""8  c #330000"",\n""9  c #360000"",\n""0  c #390000"",\n""q  c #390101"",\n""w  c #3A0000"",\n""e  c #3B0000"",\n""r  c #331C1C"",\n""t  c #420000"",\n""y  c #4F0000"",\n""u  c #4F0A0A"",\n""i  c #500000"",\n""p  c #660000"",\n""a  c #8D0000"",\n""s  c #9B0000"",\n""d  c #9D1616"",\n""f  c #AB0000"",\n""g  c #B00000"",\n""h  c #A31C1C"",\n""j  c #AA2322"",\n""k  c #B02121"",\n""l  c #B22B2A"",\n""z  c #B72C2B"",\n""x  c #BE3232"",\n""c  c #CC0000"",\n""v  c #D60000"",\n""b  c #DE0000"",\n""n  c #C41B1A"",\n""m  c #D01D1D"",\n""M  c #E50000"",\n""N  c #EB0000"",\n""B  c #EF0000"",\n""V  c #E80F0F"",\n""C  c #F00000"",\n""Z  c #F20000"",\n""A  c #F30000"",\n""S  c #F40000"",\n""D  c #F60000"",\n""F  c #F80000"",\n""G  c #FA0000"",\n""H  c #FB0000"",\n""J  c #FC0000"",\n""K  c #FD0000"",\n""L  c #FD0101"",\n""P  c #FE0000"",\n""I  c red"",\n""U  c #FE0101"",\n""Y  c #FF0101"",\n""T  c #FD0303"",\n""R  c #FE0202"",\n""E  c #FF0202"",\n""W  c #FE0303"",\n""Q  c #FC0404"",\n""!  c #FD0404"",\n""~  c #FC0505"",\n""^  c #FE0404"",\n""/  c #FF0505"",\n""(  c #FD0606"",\n"")  c #FD0707"",\n""_  c #FE0707"",\n""`  c #FB0A0A"",\n""\'  c #FD0909"",\n""]  c #FE0909"",\n""[  c #FD0B0B"",\n""{  c #FF0A0A"",\n""}  c #FF0B0B"",\n""|  c #FA0D0D"",\n"" . c #F90E0E"",\n"".. c #FB0F0F"",\n""X. c #FC0E0E"",\n""o. c #FE0F0F"",\n""O. c #F61212"",\n""+. c #F71313"",\n""@. c #FB1313"",\n""#. c #FC1111"",\n""$. c #FD1212"",\n""%. c #FE1313"",\n""&. c #F91717"",\n""*. c #FF1414"",\n""=. c #FC1616"",\n""-. c #F21A18"",\n"";. c #F51818"",\n"":. c #F21E1D"",\n"">. c #F61E1C"",\n"",. c #F91818"",\n""<. c #F91919"",\n""1. c #C63A3A"",\n""2. c #CA3F3E"",\n""3. c #ED2C2C"",\n""4. c #EE2F2F"",\n""5. c #F02323"",\n""6. c #F82222"",\n""7. c #F02828"",\n""8. c #F72E2D"",\n""9. c #FB2C2C"",\n""0. c #FB2D2D"",\n""q. c #FD2D2D"",\n""w. c #E93434"",\n""e. c #EC3535"",\n""r. c #E73C3B"",\n""t. c #E63D3D"",\n""y. c #EA3B3A"",\n""u. c #E93F3E"",\n""i. c #FD3030"",\n""p. c #F43E3D"",\n""a. c #CE4342"",\n""s. c #D04443"",\n""d. c #D14645"",\n""f. c #D34847"",\n""g. c #D44848"",\n""h. c #D54949"",\n""j. c #D54A49"",\n""k. c #D74B4A"",\n""l. c #D74C4B"",\n""z. c #D84C4C"",\n""x. c #DC504F"",\n""c. c #E44343"",\n""v. c #E54443"",\n""b. c #E54646"",\n""n. c #E84242"",\n""m. c #E44847"",\n""M. c #E14A4A"",\n""N. c #E44B49"",\n""B. c #E34D4B"",\n""V. c #E44C4B"",\n""C. c #E04D4C"",\n""Z. c #E24E4D"",\n""A. c #E34E4D"",\n""S. c #E44D4D"",\n""D. c #E84B49"",\n""F. c #E2504F"",\n""G. c #EF5050"",\n""H. c #F85151"",\n""J. c #F85454"",\n""K. c #FE5958"",\n""L. c #EF7474"",\n""P. c #F57574"",\n""I. c #F17D7D"",\n""U. c #F97978"",\n""Y. c #F9807F"",\n""T. c #FE807F"",\n""R. c #FC8181"",\n""E. c #F58888"",\n""W. c #F98F8E"",\n""Q. c #FE8E8D"",\n""!. c #FA9696"",\n""~. c #FA9E9E"",\n""^. c #C9A0A0"",\n""/. c #EAA4A2"",\n""(. c #F9A9A9"",\n""). c #FCAAA9"",\n""_. c #F1BBBB"",\n""`. c #FABDBD"",\n""\'. c #F0C3C3"",\n""]. c #F8CDCD"",\n""[. c #FAD4D2"",\n""{. c #FBD5D5"",\n""}. c #F9DFDF"",\n""|. c #F5E4E4"",\n"" X c #FBE3E3"",\n"".X c #FCE7E5"",\n""XX c #F7E8E8"",\n""oX c #FAEBEB"",\n""OX c #FCE9E8"",\n""+X c #FBEDED"",\n""@X c #FDECEC"",\n""#X c #F7F1F0"",\n""$X c #F7F5F5"",\n""%X c #FCF0F0"",\n""&X c #FAF7F7"",\n""*X c #F9F9F9"",\n""=X c #FAF9F9"",\n""-X c #FBF9F9"",\n"";X c gray98"",\n"":X c #FAFAFB"",\n"">X c #FBFBFB"",\n"",X c #FDF9F9"",\n""<X c #FCFCFB"",\n""1X c #FBFCFC"",\n""2X c gray99"",\n""3X c #FCFDFC"",\n""4X c #FDFDFC"",\n""5X c #FDFDFD"",\n""6X c #FCFCFE"",\n""7X c #FDFDFE"",\n""8X c #FDFEFE"",\n""9X c #FEFEFE"",\n""0X c #FEFEFF"",\n""qX c None"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX^ P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX_ P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P ^ qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P ^ qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P ^ ` P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P q.%.D.^.,.q.>.W P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P } qXqXqXqXqXqXqXqXqXqX} W P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P ;.qXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P 6.qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P ^ qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX^ P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P ^ qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX,.P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P @.qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX^ P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P ^ qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXo.P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P } qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXX.P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P ^ qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P S qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P f O       qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P s               qXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P a O               qXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX5.s.m n l j h d u                   qXqXqXqXqXqXqXqXqXqXqXqXt.M.v.r.w.4.+.+.qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX> = - > > > - $ $ $ $ $ $ $ $ $ $ > qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX^ -.k z x 1.2.s.s.g.g.g.g.z.z.z.l.g.z.x.z.Z.F.Z.Z.S.S.S.N.N.m.b.b.n.u.y.e.4.7.:.X.} qXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqX#.P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX          qXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX      qXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                              qXqXqXqXqXqXqXqXqXqXqXP P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                    7 P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                      7 P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                        7 P P P P P P P P P P P P P P P P P P P P ^ o.G.*.^ P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                          7 P P P P P P P P P P P P P P P P P P P ^ E.oX&X+X(.} P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                            7 P P P P P P P P P P P P P P P P P P P J.&X1X2X:X:XT.P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                              7 P P P P P P P P P P P P P P P P P P ^ \'.:X2X2X:X<X.X} P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                                7 P P P P P P P P P P P P P P P P P P ^ ].1X2X2X2X:XOXo.P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                                  7 P P P P P P P P P P P P P P P P P P W I.1X<X<X2X<X).^ P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                                    7 P P P P P P P P P P P P P P P P P P P @._.<X2X2X}.i.P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                                      6 P P P P P P P P P P P P P P P P P P P P *..X1X2XL.P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                                        6 P P P P P P P P P P P P P P P P P P P P H.:X2X2XR.P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                                          6 P P P P P P P P P P P P P P P P P P P P K.2X1X2X!.P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                                            6 P P P P P P P P P P P P P P P P P P P P /.2X2X2X|.} P P P P P P P P P P P P P P P P P P P P qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqX                                                                                                              6 P P P P P P P P P P P P P P P P P P P P {.2X2X2X@X} P P P P P P P P P P P P P P P P P P P S qXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqX                                                                                                                6 G P P P P P P P P P P P P P P P P P P P {.2X2X2X%Xq.P P P P P P P P P P P P P P P P P P P A t qXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqX                                                                                                                  3 G P P P P P P P P P P P P P P P P P P p.#X2X2X2X2XU.P P P P P P P P P P P P P P P P P P P A e   qXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqX                            qXqXqXqXqXqXqX                                                                          3 G P P P P P P P P P P P P P P P P P P 8.XX2X2X2X2XP.P P P P P P P P P P P P P P P P P P P A e     qXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqX                      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                  3 S P P P P P P P P P P P P P P P P P P P ~.:X:X2X`.%.P P P P P P P P P P P P P P P P P P P A e       qXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                            1 S P P P P P P P P P P P P P P P P P P P o.U.W.Q.*.P P P P P P P P P P P P P P P P P P P P A e         qXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                          1 B P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P A 9           qXqXqXqXqXqXqX"",\n""qXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                      * N P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P A 9             qXqXqXqXqXqX"",\n""qXqXqXqXqX                qXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqX                                                    & M P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P S 9               qXqXqXqXqX"",\n""qXqXqXqXqX              qXqXqXqXqXqXqXqXqX                            qXqXqXqXqXqXqXqX                                                  % b P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qX              qXqXqXqXqX"",\n""qXqXqXqX              qXqXqXqXqXqXqXqX                                  qXqXqXqXqXqXqXqX                                                % v P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqX              qXqXqXqX"",\n""qXqXqXqX              qXqXqXqXqXqX                        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                              O c P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqX            qXqXqXqX"",\n""qXqXqX              qXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                              g P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqX              qXqXqX"",\n""qXqXqX            qXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                              e V P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P P qXqXqXqXqX            qXqXqX"",\n""qXqX              qXqXqXqXqX                qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                              r y i y y y y y i y i qXqXqXqXqXqXi y y i y y y p qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqX"",\n""qXqX            qXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                    qXqXqXqXqX                qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qXqX"",\n""qX              qXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                qXqXqXqXqXqX            qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qX"",\n""qX            qXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                qXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qX"",\n""qX            qXqXqXqXqX            qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                            qXqXqXqX                            qXqXqXqXqX            qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qX"",\n""qX            qXqXqXqXqX          qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                      qXqXqXqXqXqXqXqX                      qXqXqXqXqX            qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qX"",\n""qX          qXqXqXqXqX            qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqX          qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX          qX"",\n""            qXqXqXqXqX          qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqX          qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            "",\n""            qXqXqXqXqX          qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqX        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            "",\n""            qXqXqXqXqX        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqX          qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            "",\n""            qXqXqXqXqX        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqXqX                qXqXqXqX        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            "",\n""            qXqXqXqXqX      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqX        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            "",\n""            qXqXqXqXqX      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqX        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            "",\n""            qXqXqXqXqX      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqX      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            "",\n""qX          qXqXqXqXqX      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqX    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            "",\n""qX            qXqXqXqX      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                      qXqXqXqXqXqXqXqX                      qXqXqXqXqX    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qX"",\n""qX            qXqXqXqXqX    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                        qXqXqXqXqXqX                        qXqXqXqXqX    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qX"",\n""qX            qXqXqXqXqX    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                qXqXqXqXqX  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qX"",\n""qX              qXqXqXqXqX  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                qXqXqXqXqX  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qX"",\n""qXqX            qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qXqX"",\n""qXqX            qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qX                                        qX            qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qXqX"",\n""qXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qXqX                                    qXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqX"",\n""qXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqX                                qXqXqXqX            qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qXqXqX"",\n""qXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqXqXqX                        qXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqX"",\n""qXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX            qXqXqXqXqXqXqXqXqXqX            qXqXqXqXqXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqX"",\n""qXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqXqX"",\n""qXqXqXqXqX                qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                qXqXqXqXqX"",\n""qXqXqXqXqXqX                qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                qXqXqXqXqXqX"",\n""qXqXqXqXqXqXqX                qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                qXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                  qXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                    qXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqX                        qXqXqXqXqXqXqXqXqXqXqXqX                        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                        qXqXqXqXqXqXqXqXqXqXqXqX                        qXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqX                                                                  qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                                  qXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqX                                                              qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                              qXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                      qXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                                qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                                      qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX                        qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX"",\n""qXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqXqX""]\n\nmagnifying_glass = [""128 128 4 1 "",\n""  c black"",\n"". c #010101"",\n""X c #020202"",\n""o c None"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooooooooooooooooooooooooooooo                   ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooooooooooooooooooooooooo                           ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooooooooooooooooooooooooo                                 oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooooooooooooooooooo                                      oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooooooooooooooooo                                           ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooooooooooooooo                                               ooooooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooooooooooooo                                                  oooooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooooooooooooooo                                                     oooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooooooooooooo                                                        ooooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooooooooo                         ooooooooo                         ooooooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooooooo                     oooooooooooooooooooo                     oooooooooooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooooooooo                   oooooooooooooooooooooooooo                   ooooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooooo                  ooooooooooooooooooooooooooooooo                 oooooooooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooooooo                 ooooooooooooooooooooooooooooooooooo                ooooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooo                ooooooooooooooooooooooooooooooooooooooo               oooooooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooooo               oooooooooooooooooooooooooooooooooooooooooo               ooooooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooo               ooooooooooooooooooooooooooooooooooooooooooooo              oooooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooo              oooooooooooooooooooooooooooooooooooooooooooooooo              ooooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooo             oooooooooooooooooooooooooooooooooooooooooooooooooo              oooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooo             ooooooooooooooooooooooooooooooooooooooooooooooooooooo            oooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooo             ooooooooooooooooooooooooooooooooooooooooooooooooooooooo            ooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooo            ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo            oooooooooooooooooooooooooooooooooooooo"",\n""oooooooo            ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo            ooooooooooooooooooooooooooooooooooooo"",\n""ooooooo            oooooooooooooooooooooooooo         ooooooooooooooooooooooooo            ooooooooooooooooooooooooooooooooooooo"",\n""ooooooo           oooooooooooooooooooooooooo          oooooooooooooooooooooooooo            oooooooooooooooooooooooooooooooooooo"",\n""oooooo            oooooooooooooooooooooooooo          ooooooooooooooooooooooooooo           oooooooooooooooooooooooooooooooooooo"",\n""oooooo           ooooooooooooooooooooooooooo          oooooooooooooooooooooooooooo           ooooooooooooooooooooooooooooooooooo"",\n""ooooo           oooooooooooooooooooooooooooo          oooooooooooooooooooooooooooo           ooooooooooooooooooooooooooooooooooo"",\n""ooooo           oooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooo           oooooooooooooooooooooooooooooooooo"",\n""oooo           ooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooo           oooooooooooooooooooooooooooooooooo"",\n""oooo           ooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooooo"",\n""oooo          oooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooo           ooooooooooooooooooooooooooooooooo"",\n""ooo           oooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo"",\n""ooo          ooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo           oooooooooooooooooooooooooooooooo"",\n""ooo          ooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo"",\n""oo          oooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo"",\n""oo          oooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo"",\n""oo          oooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo"",\n""oo         ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo"",\n""o          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo"",\n""o          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo"",\n""o          ooooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooooo         ooooooooooooooooooooooooooooooo"",\n""o          ooooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o          oooooooooooooo                                                 oooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o         oooooooooooooo                                                 Xoooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o         oooooooooooooo                                                  oooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o         oooooooooooooo                                                  oooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o         oooooooooooooo                                                 Xoooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o         oooooooooooooo                                                 Xoooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o         oooooooooooooo                                                 Xoooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o         oooooooooooooo                                                 Xoooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o         oooooooooooooo                                                 Xoooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o         oooooooooooooo                                                 Xoooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o          ooooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooo"",\n""o          ooooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooooo         ooooooooooooooooooooooooooooooo"",\n""o          ooooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooooo         ooooooooooooooooooooooooooooooo"",\n""o          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo"",\n""o          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo"",\n""oo          oooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo"",\n""oo          oooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo"",\n""oo          oooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo"",\n""oo           ooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo"",\n""ooo          ooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooo"",\n""ooo          ooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo"",\n""ooo           oooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooooooo"",\n""oooo          oooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooo           ooooooooooooooooooooooooooooooooo"",\n""oooo           ooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooo          oooooooooooooooooooooooooooooooooo"",\n""ooooo          ooooooooooooooooooooooooooooo          ooooooooooooooooooooooooooooo           oooooooooooooooooooooooooooooooooo"",\n""ooooo           oooooooooooooooooooooooooooo          oooooooooooooooooooooooooooo           ooooooooooooooooooooooooooooooooooo"",\n""ooooo            ooooooooooooooooooooooooooo          oooooooooooooooooooooooooooo           ooooooooooooooooooooooooooooooooooo"",\n""oooooo           ooooooooooooooooooooooooooo          ooooooooooooooooooooooooooo            ooooooooooooooooooooooooooooooooooo"",\n""oooooo            oooooooooooooooooooooooooo          oooooooooooooooooooooooooo            oooooooooooooooooooooooooooooooooooo"",\n""ooooooo            oooooooooooooooooooooooooXXXXXXXXXXoooooooooooooooooooooooooo           ooooooooooooooooooooooooooooooooooooo"",\n""oooooooo            ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo            ooooooooooooooooooooooooooooooooooooo"",\n""oooooooo            oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo            oooooooooooooooooooooooooooooooooooooo"",\n""ooooooooo            oooooooooooooooooooooooooooooooooooooooooooooooooooooooo             oooooooooooooooooooooooooooooooooooooo"",\n""oooooooooo            oooooooooooooooooooooooooooooooooooooooooooooooooooooo             ooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooo             oooooooooooooooooooooooooooooooooooooooooooooooooooo             oooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooo              ooooooooooooooooooooooooooooooooooooooooooooooooo              oooooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooo              oooooooooooooooooooooooooooooooooooooooooooooo                 ooooooooooooooooooooooooooooooooooooooo"",\n""ooooooooooooo              oooooooooooooooooooooooooooooooooooooooooooo                   oooooooooooooooooooooooooooooooooooooo"",\n""oooooooooooooo               oooooooooooooooooooooooooooooooooooooooo                      oo     oooooooooooooooooooooooooooooo"",\n""ooooooooooooooo                ooooooooooooooooooooooooooooooooooooo                                 ooooooooooooooooooooooooooo"",\n""oooooooooooooooo                 ooooooooooooooooooooooooooooooooo                                    oooooooooooooooooooooooooo"",\n""ooooooooooooooooo                  ooooooooooooooooooooooooooooo                                       ooooooooooooooooooooooooo"",\n""oooooooooooooooooo                    ooooooooooooooooooooooo                                           oooooooooooooooooooooooo"",\n""ooooooooooooooooooo                       ooooooooooooooo                                                ooooooooooooooooooooooo"",\n""ooooooooooooooooooooo                                                         oo                          oooooooooooooooooooooo"",\n""oooooooooooooooooooooo                                                       oooo                          ooooooooooooooooooooo"",\n""ooooooooooooooooooooooo                                                    ooooooo                          oooooooooooooooooooo"",\n""ooooooooooooooooooooooooo                                                oooooooooo                          ooooooooooooooooooo"",\n""ooooooooooooooooooooooooooo                                             ooooooooooo                           oooooooooooooooooo"",\n""ooooooooooooooooooooooooooooo                                        ooooooooooooo                             ooooooooooooooooo"",\n""oooooooooooooooooooooooooooooooo                                   ooooooooooooooo                              oooooooooooooooo"",\n""oooooooooooooooooooooooooooooooooo                              oooooooooooooooooo                               ooooooooooooooo"",\n""oooooooooooooooooooooooooooooooooooooo                       ooooooooooooooooooooo                                oooooooooooooo"",\n""ooooooooooooooooooooooooooooooooooooooooooo            ooooooooooooooooooooooooooo                                 ooooooooooooo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                 oooooooooooo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                  ooooooooooo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                   oooooooooo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                   ooooooooo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                   oooooooo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                   ooooooo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                   oooooo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                   ooooo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                   oooo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                   ooo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                   oo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                  oo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                  o"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                 o"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                 "",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                                "",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                               "",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                              "",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                            o"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                           o"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                          o"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                        oo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                      ooo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                    oooo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                  ooooo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo                oooooo"",\n""ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo              ooooooo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo            oooooooo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo         ooooooooo"",\n""oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo    oooooooooooo""]\n\nmove = [""128 128 2 1 "",\n""  c #010101"",\n"". c None"",\n""...............................................................  ..............................................................."",\n""..............................................................    .............................................................."",\n"".............................................................      ............................................................."",\n""............................................................        ............................................................"",\n""...........................................................          ..........................................................."",\n""..........................................................            .........................................................."",\n"".........................................................              ........................................................."",\n""........................................................                ........................................................"",\n"".......................................................                  ......................................................."",\n""......................................................                    ......................................................"",\n"".....................................................                      ....................................................."",\n""....................................................                        ...................................................."",\n""...................................................                          ..................................................."",\n""..................................................                            .................................................."",\n"".................................................                              ................................................."",\n""................................................                                ................................................"",\n""...............................................                                  ..............................................."",\n""..............................................                                    .............................................."",\n"".............................................                                      ............................................."",\n""............................................                                        ............................................"",\n""...........................................                                          ..........................................."",\n""..........................................                                            .........................................."",\n"".........................................                                              ........................................."",\n""........................................                                                ........................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""....................... ................................                ................................ ......................."",\n""......................  ................................       ..       ................................  ......................"",\n"".....................   ................................      ....      ................................   ....................."",\n""....................    ................................     ......     ................................    ...................."",\n""...................     ................................    ........    ................................     ..................."",\n""..................      ................................   ..........   ................................      .................."",\n"".................       ................................  ............  ................................       ................."",\n""................        ................................ .............. ................................        ................"",\n""...............         ................................................................................         ..............."",\n""..............          ................................................................................          .............."",\n"".............           ................................................................................           ............."",\n""............            ................................................................................            ............"",\n""...........             ................................................................................             ..........."",\n""..........              ................................................................................              .........."",\n"".........               ................................................................................               ........."",\n""........                ................................................................................                ........"",\n"".......                                         ................................                                         ......."",\n""......                                         ..................................                                         ......"",\n"".....                                         ....................................                                         ....."",\n""....                                         ......................................                                         ...."",\n""...                                         ........................................                                         ..."",\n""..                                         ..........................................                                         .."",\n"".                                         ............................................                                         ."",\n""                                         ..............................................                                         "",\n""                                         ..............................................                                         "",\n"".                                         ............................................                                         ."",\n""..                                         ..........................................                                         .."",\n""...                                         ........................................                                         ..."",\n""....                                         ......................................                                         ...."",\n"".....                                         ....................................                                         ....."",\n""......                                         ..................................                                         ......"",\n"".......                                         ................................                                         ......."",\n""........                ................................................................................                ........"",\n"".........               ................................................................................               ........."",\n""..........              ................................................................................              .........."",\n""...........             ................................................................................             ..........."",\n""............            ................................................................................            ............"",\n"".............           ................................................................................           ............."",\n""..............          ................................................................................          .............."",\n""...............         ................................................................................         ..............."",\n""................        ................................ .............. ................................        ................"",\n"".................       ................................  ............  ................................       ................."",\n""..................      ................................   ..........   ................................      .................."",\n""...................     ................................    ........    ................................     ..................."",\n""....................    ................................     ......     ................................    ...................."",\n"".....................   ................................      ....      ................................   ....................."",\n""......................  ................................       ..       ................................  ......................"",\n""....................... ................................                ................................ ......................."",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................................                ........................................................"",\n""........................................                                                ........................................"",\n"".........................................                                              ........................................."",\n""..........................................                                            .........................................."",\n""...........................................                                          ..........................................."",\n""............................................                                        ............................................"",\n"".............................................                                      ............................................."",\n""..............................................                                    .............................................."",\n""...............................................                                  ..............................................."",\n""................................................                                ................................................"",\n"".................................................                              ................................................."",\n""..................................................                            .................................................."",\n""...................................................                          ..................................................."",\n""....................................................                        ...................................................."",\n"".....................................................                      ....................................................."",\n""......................................................                    ......................................................"",\n"".......................................................                  ......................................................."",\n""........................................................                ........................................................"",\n"".........................................................              ........................................................."",\n""..........................................................            .........................................................."",\n""...........................................................          ..........................................................."",\n""............................................................        ............................................................"",\n"".............................................................      ............................................................."",\n""..............................................................    .............................................................."",\n""...............................................................  ...............................................................""]\n\nbucket = [""128 128 2 1 "",\n""  c black"",\n"". c None"",\n""................................................................................................................................"",\n""................................................................................................................................"",\n"".....................................         .................................................................................."",\n""..................................               ..............................................................................."",\n""................................                   ............................................................................."",\n""..............................                       ..........................................................................."",\n"".............................           ..            .........................................................................."",\n""............................        ...........        ........................................................................."",\n""...........................       ...............       ........................................................................"",\n""..........................      ..................       ......................................................................."",\n"".........................      .....................      ......................................................................"",\n""........................      .......................     ......................................................................"",\n""........................     ........................      ....................................................................."",\n"".......................     ..........................     ....................................................................."",\n"".......................     ...........................     ...................................................................."",\n"".......................    ............................     ...................................................................."",\n""......................     .............................    ...................................................................."",\n""......................     .............................     ..................................................................."",\n""......................    ..............................     ..................................................................."",\n""......................    ..............................     ..................................................................."",\n""......................    ...............................    ..................................................................."",\n""......................    ...............................    ..................................................................."",\n""......................    ...............................    ..................................................................."",\n""......................    ...............................    ..................................................................."",\n""......................    ...............................    ..................................................................."",\n""......................    ...............................    ..................................................................."",\n""......................    .....................    ......    ..................................................................."",\n""......................    .....................     .....    ..................................................................."",\n""......................    .....................      ....    ..................................................................."",\n""......................    ......................      ...    ..................................................................."",\n""......................    .......................     ...    ..................................................................."",\n""......................    ........................    ...    ..................................................................."",\n""......................    .........................   ...    ..................................................................."",\n""......................    ........................    ...    ..................................................................."",\n""......................    .......................     ...    ..................................................................."",\n""......................    ......................      ...    ..................................................................."",\n""......................    .....................       ...    ..................................................................."",\n""......................    ....................        ...    ..................................................................."",\n""......................    ...................         ...    ..................................................................."",\n""......................    ..................          ...    ..................................................................."",\n""......................    .................           ...    ... ..............................................................."",\n""......................    ................            ...    ...  .............................................................."",\n""......................    ...............             ...    ...   ............................................................."",\n""......................    ..............              ...    ...    ............................................................"",\n""......................    .............               ...    ...     ..........................................................."",\n""......................    ............                ...    ...      .........................................................."",\n""......................    ...........                 ...    ...       ........................................................."",\n""......................    ..........                  ...    ...        ........................................................"",\n""......................    .........                   ...    ...         ......................................................."",\n""......................    ........                    ...    ...          ......................................................"",\n""......................    .......                     ...    ...           ....................................................."",\n""......................    ......                      ...    ...            ...................................................."",\n""......................    .....                       ...    ...             ..................................................."",\n""......................    ....                        ...    ...              .................................................."",\n""......................    ...                         ...    ...               ................................................."",\n""......................    ..                          ...    ...                ................................................"",\n""......................    .                           ...    ...                 ..............................................."",\n""......................                                ...    ...                  .............................................."",\n""......................                                ...    ...                   ............................................."",\n""......................                               ....    ...                    ............................................"",\n""......................                             ......    ....                    ..........................................."",\n""......................                            ......     ......                   .........................................."",\n"".....................                            ....          .....                   ........................................."",\n""....................                            ....             ...                    ........................................"",\n""...................                            ....               ...                    ......................................."",\n""..................                            ....                 ...                    ......................................"",\n""..................                            ...      .......     ...                     ....................................."",\n"".................                            ....     .........     ...                     ...................................."",\n""................                             ...     ...........    ...                      ..................................."",\n""................                             ...     ...     ...     ..                       .................................."",\n""...............                              ...    ...      ...     ..                        ................................."",\n""...............                              ...    ...       ...    ...                        ................................"",\n""...............                              ...    ...       ...    ...                         ..............................."",\n""..............                               ...    ....     ...     ..                           .............................."",\n""..............                               ...     ....   ....     ..                            ............................."",\n""..............                               ...     ..........     ...                             ............................"",\n""..............                               ....     .........     ...                              ..........................."",\n""..............                                ...       .....      ...                                .........................."",\n""..............                                ....                 ...                                 ........................."",\n""..............                                 ....               ...                           ..      ........................"",\n""..............                                  ....            .....                          ....     ........................"",\n""..............                                   .....         .....                          ......    ........................"",\n""..............                                    ................                           ........   ........................"",\n""..............                                     ..............                           ...................................."",\n""..............                                       ..........                            ....................................."",\n""..............                                                                            ......................................"",\n""...............                                                                          ......................................."",\n""...............                                                                         ........................................"",\n""...............                                                                        ........................................."",\n""................                                                                      .........................................."",\n""................                                                                     ..........................................."",\n"".................                                                                   ............................................"",\n"".................                                                                  ............................................."",\n""..................                                                                .............................................."",\n""...................                                                              ..............................................."",\n""....................                                                            ................................................"",\n""....................                                                           ................................................."",\n"".....................                                                         .................................................."",\n""......................                                                       ........................   ........................"",\n"".......................                                                     ........................     ......................."",\n""........................                                                   ........................       ......................"",\n"".........................                                                 ........................         ....................."",\n""..........................                                               .......................            ...................."",\n""...........................                                             .......................              ..................."",\n""............................                                           .......................                .................."",\n"".............................                                         ........................                 ................."",\n""..............................                                       ........................                   ................"",\n""...............................                                     ........................                     ..............."",\n""................................                                   .........................                     ..............."",\n""..................................                                .........................                       .............."",\n""...................................                              ..........................                       .............."",\n""....................................                            ...........................                       .............."",\n"".....................................                         ............................                        .............."",\n"".......................................                     ..............................                        .............."",\n""..........................................                ................................                        .............."",\n"".............................................          ....................................                       .............."",\n""...........................................................................................                       .............."",\n""...........................................................................................                       .............."",\n""...........................................................................................                       .............."",\n""............................................................................................                     ..............."",\n""............................................................................................                     ..............."",\n"".............................................................................................                   ................"",\n""..............................................................................................                 ................."",\n""...............................................................................................              ..................."",\n"".................................................................................................           ...................."",\n""....................................................................................................     ......................."",\n""................................................................................................................................"",\n""................................................................................................................................""]\n\npolygon = [""128 128 40 1 "",\n""  c black"",\n"". c #000100"",\n""X c #010001"",\n""o c #020100"",\n""O c #000102"",\n""+ c #010902"",\n""@ c #231902"",\n""# c #042307"",\n""$ c #052B09"",\n""% c #06330B"",\n""& c #06350B"",\n""* c #021121"",\n""= c #02162C"",\n""- c #29022C"",\n""; c #360339"",\n"": c #412F04"",\n""> c #594105"",\n"", c #614605"",\n""< c #795807"",\n""1 c #042345"",\n""2 c #052E5B"",\n""3 c #063C78"",\n""4 c #4C0451"",\n""5 c #540559"",\n""6 c #64066A"",\n""7 c #710678"",\n""8 c #A57709"",\n""9 c #14B326"",\n""0 c #15BD28"",\n""q c #19DB2F"",\n""w c #1AE631"",\n""e c #B3820A"",\n""r c #F2AF0D"",\n""t c #084E9D"",\n""y c #0A5DB9"",\n""u c #0D79F2"",\n""i c #94089D"",\n""p c #9C09A5"",\n""a c #E40DF2"",\n""s c None"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                          ssssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                            sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss :88888888888888888888888<  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss  ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss     ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss            ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                    ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                        ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssss                           ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""ssssss                          sssssssssssssssssss                               ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssss                           sssssssssssssss                             sssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssss 2yyyyyyyyyyyyyyyyyyyyyyy3  ssssssssss                              ssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  ssssss                              ssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  sss                             ssssssssssssssss ,rrrrrrrrrrrrrrrrrrrrrrre  sssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut                              ssssssssssssssssssss @>>>>>>>>>>>>>>>>>>>>>>>:  sssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut                          ssssssssssssssssssssssss                           ssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut                       sssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut                   sssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut               sssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut           ssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut       ssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut    sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssssssssss"",\n""sssss 3uuuuuuuuuuuuuuuuuuuuuuut  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssssss"",\n""sssss *11111111111111111111111=  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssssss"",\n""sssss                           ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssssss"",\n""ssssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssssss"",\n""ssssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssssssssss"",\n""ssssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssssssssss"",\n""ssssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssss"",\n""ssssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssss"",\n""ssssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssss"",\n""ssssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssssss"",\n""ssssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssssssss"",\n""ssssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssssssss"",\n""ssssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssss"",\n""ssssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssss"",\n""ssssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssss"",\n""ssssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssssss"",\n""ssssssssssssss       ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssssssss"",\n""ssssssssssssss       ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssssssss"",\n""ssssssssssssss       ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssss"",\n""ssssssssssssss       ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssss"",\n""ssssssssssssss       ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssss"",\n""ssssssssssssss       ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssssss"",\n""ssssssssssssss       sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssssss"",\n""ssssssssssssss       sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssssss"",\n""ssssssssssssss       sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssssss"",\n""ssssssssssssss       sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssss"",\n""ssssssssssssss       sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssss"",\n""sssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssssss"",\n""sssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssssss"",\n""sssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssssss"",\n""sssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssssss"",\n""sssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssss"",\n""sssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssss"",\n""sssssssssssss        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssssss"",\n""sssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssss"",\n""sssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssss"",\n""sssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssssss"",\n""sssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssss"",\n""sssssssssssss        sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssss"",\n""sssss                           ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssssss"",\n""sssss +&&&&&&&&&&&&&&&&&&&&&&&&  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       sssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        ssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq   sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       ssssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq            ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss        sssssssssssssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq                 ssssssssssssssssssssssssssssssssssssssssssssssss                           sssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq                      ssssssssssssssssssssssssssssssssssssssssss  ;55555555555555555555555- sssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq                          ssssssssssssssssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq                               sssssssssssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq                                    ssssssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  sss                                   ssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  sssssss                                    sssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssss $wwwwwwwwwwwwwwwwwwwwwwwq  ssssssssssss                                    ssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssss #000000000000000000000009  sssssssssssssssss                                    sssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssss                            sssssssssssssssssssss                                    sssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""ssssss                          sssssssssssssssssssssssssss                                      iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                                 iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                             iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                        iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                   iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss              iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss          iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss     iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss  iaaaaaaaaaaaaaaaaaaaaaaa7 sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss  6ppppppppppppppppppppppp4 sssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                           sssss"",\n""sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss                         ssssss"",\n""ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss""]\n'"
src/calipy/utils/matlab_file.py,0,"b'import warnings\nwith warnings.catch_warnings():\n    warnings.simplefilter(\'ignore\')\n    import h5py\nimport scipy.io as spio\n\n\ndef load(filename, force_dictionary=False, return_metadata=False, **kwargs):\n    """"""\n    this function should be called instead of direct spio.load\n    as it cures the problem of not properly recovering python dictionaries\n    from mat files. It calls the function check keys to cure all entries\n    which are still mat-objects\n    """"""\n    # Remove default parameters\n    user_kwargs = kwargs.keys()\n    if \'struct_as_record\' in user_kwargs:\n        kwargs.pop(\'struct_as_record\')\n    if \'squeeze_me\' in user_kwargs:\n        kwargs.pop(\'squeeze_me\')\n\n    try:\n        data = spio.loadmat(filename, struct_as_record=False, squeeze_me=True, **kwargs)\n        # Convert objects to nested dictionaries and return\n        data = _check_keys(data)\n        # Extract metadata\n        metadata = {v: data[v] for v in [\'__version__\', \'__header__\', \'__globals__\']}\n        # Remove metadata\n        data = {v: data[v] for v in data.keys() if v not in [\'__version__\', \'__header__\', \'__globals__\']}\n\n    except NotImplementedError:\n        with h5py.File(filename, mode=\'r\', libver=\'latest\') as f:\n            data = {k: f[k][:] for k in list(f.keys()) if not k.startswith(\'#\')}\n            metadata = dict()\n\n    # If user requested only some variables, return only those\n    variable_names = kwargs.get(\'variable_names\', None)\n    if variable_names is not None:\n        # Make \'variable_names\' a list\n        if isinstance(variable_names, str):\n            variable_names = [variable_names]\n        data = {v: data[v] for v in variable_names}\n\n    else:\n        variable_names = list(data.keys())\n\n    # Return result directly if only one variable requested\n    if len(variable_names) == 1 and not force_dictionary:\n        data = data[variable_names[0]]\n\n    if not return_metadata:\n        return data\n    else:\n        return data, metadata\n\ndef _check_keys(dict):\n    """"""\n    checks if entries in dictionary are mat-objects. If yes\n    _todict is called to change them to nested dictionaries\n    """"""\n    for key in dict:\n        if isinstance(dict[key], spio.matlab.mio5_params.mat_struct):\n            dict[key] = _todict(dict[key])\n    return dict\n\ndef _todict(matobj):\n    """"""\n    A recursive function which constructs from matobjects nested dictionaries\n    """"""\n    dict = {}\n    for strg in matobj._fieldnames:\n        elem = matobj.__dict__[strg]\n        if isinstance(elem, spio.matlab.mio5_params.mat_struct):\n            dict[strg] = _todict(elem)\n        else:\n            dict[strg] = elem\n    return dict\n'"
src/calipy/utils/misc.py,11,"b'# System packages\nfrom copy import copy\nimport collections\n\n# Numerical packages\nimport numpy as np\n\n\n###############################################################################\n# Colormap-related\n###############################################################################\ndef default_colors(normalize_01=True):\n    colors = [[11, 198, 255],\n              [255, 170, 0],\n              [0, 170, 0],\n              [255, 85, 255],\n              [0, 0, 255],\n              [255, 0, 4],\n              [190, 92, 35],\n              [255, 6, 114]]\n    colors = np.array(colors, dtype=int)\n    if normalize_01:\n        colors /= 255.\n    colors = list(zip(*colors.transpose()))\n\n    return colors\n\n\ndef cmapToColormap(cmap, nTicks=16):\n    """"""\n    Converts a Matplotlib cmap to pyqtgraph colormaps. No dependency on matplotlib.\n\n    Parameters:\n    *cmap*: Cmap object. Imported from matplotlib.cm.*\n    *nTicks*: Number of ticks to create when dict of functions is used. Otherwise unused.\n    """"""\n\n    # Case #1: a dictionary with \'red\'/\'green\'/\'blue\' values as list of ranges (e.g. \'jet\')\n    # The parameter \'cmap\' is a \'matplotlib.colors.LinearSegmentedColormap\' instance ...\n    if hasattr(cmap, \'_segmentdata\'):\n        colordata = getattr(cmap, \'_segmentdata\')\n        if (\'red\' in colordata) and isinstance(colordata[\'red\'], collections.Sequence):\n\n            # collect the color ranges from all channels into one dict to get unique indices\n            posDict = {}\n            for idx, channel in enumerate((\'red\', \'green\', \'blue\')):\n                for colorRange in colordata[channel]:\n                    posDict.setdefault(colorRange[0], [-1, -1, -1])[idx] = colorRange[2]\n\n            indexList = list(posDict.keys())\n            indexList.sort()\n            # interpolate missing values (== -1)\n            for channel in range(3):  # R,G,B\n                startIdx = indexList[0]\n                emptyIdx = []\n                for curIdx in indexList:\n                    if posDict[curIdx][channel] == -1:\n                        emptyIdx.append(curIdx)\n                    elif curIdx != indexList[0]:\n                        for eIdx in emptyIdx:\n                            rPos = (eIdx - startIdx) / (curIdx - startIdx)\n                            vStart = posDict[startIdx][channel]\n                            vRange = (posDict[curIdx][channel] - posDict[startIdx][channel])\n                            posDict[eIdx][channel] = rPos * vRange + vStart\n                        startIdx = curIdx\n                        del emptyIdx[:]\n            for channel in range(3):  # R,G,B\n                for curIdx in indexList:\n                    posDict[curIdx][channel] *= 255\n\n            rgb_list = [[i, posDict[i]] for i in indexList]\n\n        # Case #2: a dictionary with \'red\'/\'green\'/\'blue\' values as functions (e.g. \'gnuplot\')\n        elif (\'red\' in colordata) and isinstance(colordata[\'red\'], collections.Callable):\n            indices = np.linspace(0., 1., nTicks)\n            luts = [np.clip(np.array(colordata[rgb](indices), dtype=np.float), 0, 1) * 255 for rgb in (\'red\', \'green\', \'blue\')]\n            rgb_list = zip(indices, list(zip(*luts)))\n\n    # If the parameter \'cmap\' is a \'matplotlib.colors.ListedColormap\' instance, with the attributes \'colors\' and \'N\'\n    elif hasattr(cmap, \'colors\') and hasattr(cmap, \'N\'):\n        colordata = getattr(cmap, \'colors\')\n        # Case #3: a list with RGB values (e.g. \'seismic\')\n        if len(colordata[0]) == 3:\n            indices = np.linspace(0., 1., len(colordata))\n            scaledRgbTuples = [(rgbTuple[0] * 255, rgbTuple[1] * 255, rgbTuple[2] * 255) for rgbTuple in colordata]\n            rgb_list = zip(indices, scaledRgbTuples)\n\n        # Case #4: a list of tuples with positions and RGB-values (e.g. \'terrain\')\n        # -> this section is probably not needed anymore!?\n        elif len(colordata[0]) == 2:\n            rgb_list = [(idx, (vals[0] * 255, vals[1] * 255, vals[2] * 255)) for idx, vals in colordata]\n\n    # Case #X: unknown format or datatype was the wrong object type\n    else:\n        raise ValueError(""[cmapToColormap] Unknown cmap format or not a cmap!"")\n\n    # Convert the RGB float values to RGBA integer values\n    return list([(pos, (int(r), int(g), int(b), 255)) for pos, (r, g, b) in rgb_list])\n\n\n################################################################################\n# class-related\n################################################################################\ndef initialize_field(obj, field_name, value_type=""class"", initial_value=None, shape=None):\n    """"""Initialize an empty object with <field_name> type and adds it to an\n    object instance <obj>. This container can be accessed from <obj>.<field_name>\n\n    :param obj: [object] The parent object in which to initialize a new field.\n    :param field_name: [str] Name of the variable to add.\n    :param value_type: [str] Type of object to initialize: ""class"", ""list"",\n        ""array"" or ""="".\n    :param initial_value: Default attribute of the object. For ""list"" it is a\n        scalar containing the length of the list; for ""array"" it is the shape of\n        the array; for ""class"" it is ignored; for ""="" it becomes equal to\n        whatever <initial_value> is.\n    """"""\n\n    class subfield(dict):\n        def __init__(self, name=""subfield""):\n            # Initialize the instance as a dictionary and assign a name to it\n            dict.__init__(self)\n            self.__name__ = name\n\n            # Allow transformation between dot-call and key-call, i.e.,\n            # dict.subfield works as dict[""subfield""]\n            self.__dict__ = self\n\n    # Check whether the user inputted a list of fields to fill in\n    if isinstance(field_name, str):\n        field_name = [field_name]\n\n    for f in field_name:\n        value = None\n        if value_type == ""="":\n            # Use user\'s input\n            value = copy(initial_value)\n\n        elif value_type == ""class"":\n            # Use a dictionary to contain subfields\n            value = subfield(name=f)\n\n        elif value_type == ""list"":\n            # Make a list of Nones\n            value = np.empty(shape=shape, dtype=object).tolist()\n            # If initial_value is provided, place it in each item of the list\n            if initial_value is not None:\n                # Handle special instructions\n                if initial_value == \'list\':\n                    value = [list() for _ in value]\n                elif initial_value == \'array\':\n                    value = [np.array([]) for _ in value]\n                else:\n                    value = [copy(initial_value) for _ in value]\n\n        elif value_type == ""array"":\n            # Make a numpy array\n            value = np.empty(shape=shape, dtype=object)\n            # If initial_value is provided, place it in each item of the array\n            if initial_value is not None:\n                # Handle special instructions\n                rows, cols = np.unravel_index(np.arange(np.prod(shape)), shape)\n                if initial_value == \'list\':\n                    for row, col in zip(rows, cols):\n                        value[row, col] = list()\n                elif initial_value == \'array\':\n                    for row, col in zip(rows, cols):\n                        value[row, col] = np.array([])\n                else:\n                    for row, col in zip(rows, cols):\n                        value[row, col] = copy(initial_value)\n\n        # Assign value to object or dictionary\n        if type(obj).__name__ == ""subfield"":\n            obj[f] = value\n        else:\n            setattr(obj, f, value)\n\n\ndef make_new_ROI_id(already_existing):\n    """"""Find the lowest number that can be used as cluster id.""""""\n    # Get the set of all existing ids\n    already_existing = np.array(already_existing, dtype=int)\n    # If list is empty, return 1\n    if already_existing.shape[0] == 0:\n        return 1\n\n    last_id = int(np.max(already_existing))\n    return last_id + 1\n\n\ndef ask(question, answers, default_answer, type_validator=str):\n    # Get number of answers\n    if not isinstance(answers, list):\n        answers = [answers]\n    if answers[0] == \'\':\n        n_answers = 0\n    else:\n        n_answers = len(answers)\n\n    # Append answer hints to question\n    if n_answers > 0 or str(default_answer) != \'\':\n        question_to_show = question + \' (\'\n        if str(default_answer) != \'\':\n            question_to_show += \'[%s]\' % str(default_answer)\n            if n_answers > 0:\n                question_to_show += \'/\'\n        if n_answers > 0:\n            question_to_show += \'%s\' % \'/\'.join([i for i in answers if str(i) != str(default_answer)])\n        question_to_show += \')\'\n\n    else:\n        question_to_show = question\n\n    # Ask user for an answer\n    while True:\n        user_answer = input(question_to_show)\n        # Set default option when user presses Enter\n        if user_answer == \'\':\n            if str(default_answer) == \'\':\n                print(\'Please try again\')\n            else:\n                user_answer = default_answer\n        # Validate user answer\n        try:\n            user_answer = type_validator(user_answer)\n        except ValueError:\n            print(\'Answer type not allowed. Reply something that can be converted to \\\'%s\\\'\' % repr(type_validator))\n            continue\n\n        # Stop if got an answer that is allowed, or if there are no good answers\n        if user_answer in answers or n_answers == 0:\n            break\n        else:\n            print(\'Please try again\')\n\n    return user_answer\n\n\n'"
src/third_party/pyqtgraph/PlotData.py,2,"b'\n\nclass PlotData(object):\n    """"""\n    Class used for managing plot data\n      - allows data sharing between multiple graphics items (curve, scatter, graph..)\n      - each item may define the columns it needs\n      - column groupings (\'pos\' or x, y, z)\n      - efficiently appendable \n      - log, fft transformations\n      - color mode conversion (float/byte/qcolor)\n      - pen/brush conversion\n      - per-field cached masking\n        - allows multiple masking fields (different graphics need to mask on different criteria) \n        - removal of nan/inf values\n      - option for single value shared by entire column\n      - cached downsampling\n      - cached min / max / hasnan / isuniform\n    """"""\n    def __init__(self):\n        self.fields = {}\n        \n        self.maxVals = {}  ## cache for max/min\n        self.minVals = {}\n\n    def addFields(self, **fields):\n        for f in fields:\n            if f not in self.fields:\n                self.fields[f] = None\n\n    def hasField(self, f):\n        return f in self.fields\n\n    def __getitem__(self, field):\n        return self.fields[field]\n    \n    def __setitem__(self, field, val):\n        self.fields[field] = val\n    \n    def max(self, field):\n        mx = self.maxVals.get(field, None)\n        if mx is None:\n            mx = np.max(self[field])\n            self.maxVals[field] = mx\n        return mx\n    \n    def min(self, field):\n        mn = self.minVals.get(field, None)\n        if mn is None:\n            mn = np.min(self[field])\n            self.minVals[field] = mn\n        return mn\n    \n    \n    \n    '"
src/third_party/pyqtgraph/Point.py,4,"b'# -*- coding: utf-8 -*-\n""""""\nPoint.py -  Extension of QPointF which adds a few missing methods.\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n""""""\n\nfrom .Qt import QtCore\nimport numpy as np\n\ndef clip(x, mn, mx):\n    if x > mx:\n        return mx\n    if x < mn:\n        return mn\n    return x\n\nclass Point(QtCore.QPointF):\n    """"""Extension of QPointF which adds a few missing methods.""""""\n    \n    def __init__(self, *args):\n        if len(args) == 1:\n            if isinstance(args[0], QtCore.QSizeF):\n                QtCore.QPointF.__init__(self, float(args[0].width()), float(args[0].height()))\n                return\n            elif isinstance(args[0], float) or isinstance(args[0], int):\n                QtCore.QPointF.__init__(self, float(args[0]), float(args[0]))\n                return\n            elif hasattr(args[0], \'__getitem__\'):\n                QtCore.QPointF.__init__(self, float(args[0][0]), float(args[0][1]))\n                return\n        elif len(args) == 2:\n            QtCore.QPointF.__init__(self, args[0], args[1])\n            return\n        QtCore.QPointF.__init__(self, *args)\n        \n    def __len__(self):\n        return 2\n        \n    def __reduce__(self):\n        return (Point, (self.x(), self.y()))\n        \n    def __getitem__(self, i):\n        if i == 0:\n            return self.x()\n        elif i == 1:\n            return self.y()\n        else:\n            raise IndexError(""Point has no index %s"" % str(i))\n        \n    def __setitem__(self, i, x):\n        if i == 0:\n            return self.setX(x)\n        elif i == 1:\n            return self.setY(x)\n        else:\n            raise IndexError(""Point has no index %s"" % str(i))\n        \n    def __radd__(self, a):\n        return self._math_(\'__radd__\', a)\n    \n    def __add__(self, a):\n        return self._math_(\'__add__\', a)\n    \n    def __rsub__(self, a):\n        return self._math_(\'__rsub__\', a)\n    \n    def __sub__(self, a):\n        return self._math_(\'__sub__\', a)\n    \n    def __rmul__(self, a):\n        return self._math_(\'__rmul__\', a)\n    \n    def __mul__(self, a):\n        return self._math_(\'__mul__\', a)\n    \n    def __rdiv__(self, a):\n        return self._math_(\'__rdiv__\', a)\n    \n    def __div__(self, a):\n        return self._math_(\'__div__\', a)\n    \n    def __truediv__(self, a):\n        return self._math_(\'__truediv__\', a)\n    \n    def __rtruediv__(self, a):\n        return self._math_(\'__rtruediv__\', a)\n    \n    def __rpow__(self, a):\n        return self._math_(\'__rpow__\', a)\n    \n    def __pow__(self, a):\n        return self._math_(\'__pow__\', a)\n    \n    def _math_(self, op, x):\n        #print ""point math:"", op\n        #try:\n            #fn  = getattr(QtCore.QPointF, op)\n            #pt = fn(self, x)\n            #print fn, pt, self, x\n            #return Point(pt)\n        #except AttributeError:\n        x = Point(x)\n        return Point(getattr(self[0], op)(x[0]), getattr(self[1], op)(x[1]))\n    \n    def length(self):\n        """"""Returns the vector length of this Point.""""""\n        try:\n            return (self[0]**2 + self[1]**2) ** 0.5\n        except OverflowError:\n            try:\n                return self[1] / np.sin(np.arctan2(self[1], self[0]))\n            except OverflowError:\n                return np.inf\n    \n    def norm(self):\n        """"""Returns a vector in the same direction with unit length.""""""\n        return self / self.length()\n    \n    def angle(self, a):\n        """"""Returns the angle in degrees between this vector and the vector a.""""""\n        n1 = self.length()\n        n2 = a.length()\n        if n1 == 0. or n2 == 0.:\n            return None\n        ## Probably this should be done with arctan2 instead..\n        ang = np.arccos(clip(self.dot(a) / (n1 * n2), -1.0, 1.0)) ### in radians\n        c = self.cross(a)\n        if c > 0:\n            ang *= -1.\n        return ang * 180. / np.pi\n    \n    def dot(self, a):\n        """"""Returns the dot product of a and this Point.""""""\n        a = Point(a)\n        return self[0]*a[0] + self[1]*a[1]\n    \n    def cross(self, a):\n        a = Point(a)\n        return self[0]*a[1] - self[1]*a[0]\n        \n    def proj(self, b):\n        """"""Return the projection of this vector onto the vector b""""""\n        b1 = b / b.length()\n        return self.dot(b1) * b1\n    \n    def __repr__(self):\n        return ""Point(%f, %f)"" % (self[0], self[1])\n    \n    \n    def min(self):\n        return min(self[0], self[1])\n    \n    def max(self):\n        return max(self[0], self[1])\n        \n    def copy(self):\n        return Point(self)\n        \n    def toQPoint(self):\n        return QtCore.QPoint(*self)\n'"
src/third_party/pyqtgraph/Qt.py,0,"b'""""""\nThis module exists to smooth out some of the differences between PySide and PyQt4:\n\n* Automatically import either PyQt4 or PySide depending on availability\n* Allow to import QtCore/QtGui pyqtgraph.Qt without specifying which Qt wrapper\n  you want to use.\n* Declare QtCore.Signal, .Slot in PyQt4\n* Declare loadUiType function for Pyside\n\n""""""\n\nimport os, sys, re, time\n\nfrom .python2_3 import asUnicode\n\nPYSIDE = \'PySide\'\nPYSIDE2 = \'PySide2\'\nPYQT4 = \'PyQt4\'\nPYQT5 = \'PyQt5\'\n\nQT_LIB = os.getenv(\'PYQTGRAPH_QT_LIB\')\n\n## Automatically determine which Qt package to use (unless specified by\n## environment variable).\n## This is done by first checking to see whether one of the libraries\n## is already imported. If not, then attempt to import PyQt4, then PySide.\nif QT_LIB is None:\n    libOrder = [PYQT4, PYSIDE, PYQT5, PYSIDE2]\n\n    for lib in libOrder:\n        if lib in sys.modules:\n            QT_LIB = lib\n            break\n\nif QT_LIB is None:\n    for lib in libOrder:\n        try:\n            __import__(lib)\n            QT_LIB = lib\n            break\n        except ImportError:\n            pass\n\nif QT_LIB is None:\n    raise Exception(""PyQtGraph requires one of PyQt4, PyQt5, PySide or PySide2; none of these packages could be imported."")\n\n\nclass FailedImport(object):\n    """"""Used to defer ImportErrors until we are sure the module is needed.\n    """"""\n    def __init__(self, err):\n        self.err = err\n        \n    def __getattr__(self, attr):\n        raise self.err\n\n\ndef _isQObjectAlive(obj):\n    """"""An approximation of PyQt\'s isQObjectAlive().\n    """"""\n    try:\n        if hasattr(obj, \'parent\'):\n            obj.parent()\n        elif hasattr(obj, \'parentItem\'):\n            obj.parentItem()\n        else:\n            raise Exception(""Cannot determine whether Qt object %s is still alive."" % obj)\n    except RuntimeError:\n        return False\n    else:\n        return True\n\n\n# Make a loadUiType function like PyQt has\n\n# Credit:\n# http://stackoverflow.com/questions/4442286/python-code-genration-with-pyside-uic/14195313#14195313\n\nclass _StringIO(object):\n    """"""Alternative to built-in StringIO needed to circumvent unicode/ascii issues""""""\n    def __init__(self):\n        self.data = []\n    \n    def write(self, data):\n        self.data.append(data)\n        \n    def getvalue(self):\n        return \'\'.join(map(asUnicode, self.data)).encode(\'utf8\')\n\n    \ndef _loadUiType(uiFile):\n    """"""\n    PySide lacks a ""loadUiType"" command like PyQt4\'s, so we have to convert\n    the ui file to py code in-memory first and then execute it in a\n    special frame to retrieve the form_class.\n\n    from stackoverflow: http://stackoverflow.com/a/14195313/3781327\n\n    seems like this might also be a legitimate solution, but I\'m not sure\n    how to make PyQt4 and pyside look the same...\n        http://stackoverflow.com/a/8717832\n    """"""\n    import pysideuic\n    import xml.etree.ElementTree as xml\n    #from io import StringIO\n    \n    parsed = xml.parse(uiFile)\n    widget_class = parsed.find(\'widget\').get(\'class\')\n    form_class = parsed.find(\'class\').text\n    \n    with open(uiFile, \'r\') as f:\n        o = _StringIO()\n        frame = {}\n\n        pysideuic.compileUi(f, o, indent=0)\n        pyc = compile(o.getvalue(), \'<string>\', \'exec\')\n        exec(pyc, frame)\n\n        #Fetch the base_class and form class based on their type in the xml from designer\n        form_class = frame[\'Ui_%s\'%form_class]\n        base_class = eval(\'QtGui.%s\'%widget_class)\n\n    return form_class, base_class\n\n\nif QT_LIB == PYSIDE:\n    from PySide import QtGui, QtCore\n\n    try:\n        from PySide import QtOpenGL\n    except ImportError as err:\n        QtOpenGL = FailedImport(err)\n    try:\n        from PySide import QtSvg\n    except ImportError as err:\n        QtSvg = FailedImport(err)\n\n    try:\n        from PySide import QtTest\n    except ImportError as err:\n        QtTest = FailedImport(err)\n    \n    try:\n        from PySide import shiboken\n        isQObjectAlive = shiboken.isValid\n    except ImportError:\n        # use approximate version\n        isQObjectAlive = _isQObjectAlive\n    \n    import PySide\n    VERSION_INFO = \'PySide \' + PySide.__version__ + \' Qt \' + QtCore.__version__\n    \nelif QT_LIB == PYQT4:\n    from PyQt4 import QtGui, QtCore, uic\n    try:\n        from PyQt4 import QtSvg\n    except ImportError as err:\n        QtSvg = FailedImport(err)\n    try:\n        from PyQt4 import QtOpenGL\n    except ImportError as err:\n        QtOpenGL = FailedImport(err)\n    try:\n        from PyQt4 import QtTest\n    except ImportError as err:\n        QtTest = FailedImport(err)\n\n    VERSION_INFO = \'PyQt4 \' + QtCore.PYQT_VERSION_STR + \' Qt \' + QtCore.QT_VERSION_STR\n\nelif QT_LIB == PYQT5:\n    # We\'re using PyQt5 which has a different structure so we\'re going to use a shim to\n    # recreate the Qt4 structure for Qt5\n    from PyQt5 import QtGui, QtCore, QtWidgets, uic\n    \n    # PyQt5, starting in v5.5, calls qAbort when an exception is raised inside\n    # a slot. To maintain backward compatibility (and sanity for interactive\n    # users), we install a global exception hook to override this behavior.\n    ver = QtCore.PYQT_VERSION_STR.split(\'.\')\n    if int(ver[1]) >= 5:\n        if sys.excepthook == sys.__excepthook__:\n            sys_excepthook = sys.excepthook\n            def pyqt5_qabort_override(*args, **kwds):\n                return sys_excepthook(*args, **kwds)\n            sys.excepthook = pyqt5_qabort_override\n    \n    try:\n        from PyQt5 import QtSvg\n    except ImportError as err:\n        QtSvg = FailedImport(err)\n    try:\n        from PyQt5 import QtOpenGL\n    except ImportError as err:\n        QtOpenGL = FailedImport(err)\n    try:\n        from PyQt5 import QtTest\n        QtTest.QTest.qWaitForWindowShown = QtTest.QTest.qWaitForWindowExposed\n    except ImportError as err:\n        QtTest = FailedImport(err)\n\n    VERSION_INFO = \'PyQt5 \' + QtCore.PYQT_VERSION_STR + \' Qt \' + QtCore.QT_VERSION_STR\n\nelif QT_LIB == PYSIDE2:\n    from PySide2 import QtGui, QtCore, QtWidgets\n    \n    try:\n        from PySide2 import QtSvg\n    except ImportError as err:\n        QtSvg = FailedImport(err)\n    try:\n        from PySide2 import QtOpenGL\n    except ImportError as err:\n        QtOpenGL = FailedImport(err)\n    try:\n        from PySide2 import QtTest\n        QtTest.QTest.qWaitForWindowShown = QtTest.QTest.qWaitForWindowExposed\n    except ImportError as err:\n        QtTest = FailedImport(err)\n\n    isQObjectAlive = _isQObjectAlive\n    \n    import PySide2\n    VERSION_INFO = \'PySide2 \' + PySide2.__version__ + \' Qt \' + QtCore.__version__\n\nelse:\n    raise ValueError(""Invalid Qt lib \'%s\'"" % QT_LIB)\n\n\n# common to PyQt5 and PySide2\nif QT_LIB in [PYQT5, PYSIDE2]:\n    # We\'re using Qt5 which has a different structure so we\'re going to use a shim to\n    # recreate the Qt4 structure\n    \n    __QGraphicsItem_scale = QtWidgets.QGraphicsItem.scale\n\n    def scale(self, *args):\n        if args:\n            sx, sy = args\n            tr = self.transform()\n            tr.scale(sx, sy)\n            self.setTransform(tr)\n        else:\n            return __QGraphicsItem_scale(self)\n\n    QtWidgets.QGraphicsItem.scale = scale\n\n    def rotate(self, angle):\n        tr = self.transform()\n        tr.rotate(angle)\n        self.setTransform(tr)\n    QtWidgets.QGraphicsItem.rotate = rotate\n\n    def translate(self, dx, dy):\n        tr = self.transform()\n        tr.translate(dx, dy)\n        self.setTransform(tr)\n    QtWidgets.QGraphicsItem.translate = translate\n\n    def setMargin(self, i):\n        self.setContentsMargins(i, i, i, i)\n    QtWidgets.QGridLayout.setMargin = setMargin\n\n    def setResizeMode(self, *args):\n        self.setSectionResizeMode(*args)\n    QtWidgets.QHeaderView.setResizeMode = setResizeMode\n\n    \n    QtGui.QApplication = QtWidgets.QApplication\n    QtGui.QGraphicsScene = QtWidgets.QGraphicsScene\n    QtGui.QGraphicsObject = QtWidgets.QGraphicsObject\n    QtGui.QGraphicsWidget = QtWidgets.QGraphicsWidget\n\n    QtGui.QApplication.setGraphicsSystem = None\n    \n    # Import all QtWidgets objects into QtGui\n    for o in dir(QtWidgets):\n        if o.startswith(\'Q\'):\n            setattr(QtGui, o, getattr(QtWidgets,o) )\n    \n\n# Common to PySide and PySide2\nif QT_LIB in [PYSIDE, PYSIDE2]:\n    QtVersion = QtCore.__version__\n    loadUiType = _loadUiType\n        \n    # PySide does not implement qWait\n    if not isinstance(QtTest, FailedImport):\n        if not hasattr(QtTest.QTest, \'qWait\'):\n            @staticmethod\n            def qWait(msec):\n                start = time.time()\n                QtGui.QApplication.processEvents()\n                while time.time() < start + msec * 0.001:\n                    QtGui.QApplication.processEvents()\n            QtTest.QTest.qWait = qWait\n\n\n# Common to PyQt4 and 5\nif QT_LIB in [PYQT4, PYQT5]:\n    QtVersion = QtCore.QT_VERSION_STR\n    \n    import sip\n    def isQObjectAlive(obj):\n        return not sip.isdeleted(obj)\n    \n    loadUiType = uic.loadUiType\n\n    QtCore.Signal = QtCore.pyqtSignal\n    \n\n# USE_XXX variables are deprecated\nUSE_PYSIDE = QT_LIB == PYSIDE\nUSE_PYQT4 = QT_LIB == PYQT4\nUSE_PYQT5 = QT_LIB == PYQT5\n\n    \n## Make sure we have Qt >= 4.7\nversionReq = [4, 7]\nm = re.match(r\'(\\d+)\\.(\\d+).*\', QtVersion)\nif m is not None and list(map(int, m.groups())) < versionReq:\n    print(list(map(int, m.groups())))\n    raise Exception(\'pyqtgraph requires Qt version >= %d.%d  (your version is %s)\' % (versionReq[0], versionReq[1], QtVersion))\n\n\nQAPP = None\ndef mkQApp():\n    global QAPP    \n    QAPP = QtGui.QApplication.instance()\n    if QAPP is None:\n        QAPP = QtGui.QApplication([])\n    return QAPP\n'"
src/third_party/pyqtgraph/SRTTransform.py,2,"b'# -*- coding: utf-8 -*-\nfrom .Qt import QtCore, QtGui\nfrom .Point import Point\nimport numpy as np\n\n\nclass SRTTransform(QtGui.QTransform):\n    """"""Transform that can always be represented as a combination of 3 matrices: scale * rotate * translate\n    This transform has no shear; angles are always preserved.\n    """"""\n    def __init__(self, init=None):\n        QtGui.QTransform.__init__(self)\n        self.reset()\n        \n        if init is None:\n            return\n        elif isinstance(init, dict):\n            self.restoreState(init)\n        elif isinstance(init, SRTTransform):\n            self._state = {\n                \'pos\': Point(init._state[\'pos\']),\n                \'scale\': Point(init._state[\'scale\']),\n                \'angle\': init._state[\'angle\']\n            }\n            self.update()\n        elif isinstance(init, QtGui.QTransform):\n            self.setFromQTransform(init)\n        elif isinstance(init, QtGui.QMatrix4x4):\n            self.setFromMatrix4x4(init)\n        else:\n            raise Exception(""Cannot create SRTTransform from input type: %s"" % str(type(init)))\n\n        \n    def getScale(self):\n        return self._state[\'scale\']\n        \n    def getAngle(self):  \n        ## deprecated; for backward compatibility\n        return self.getRotation()\n        \n    def getRotation(self):\n        return self._state[\'angle\']\n        \n    def getTranslation(self):\n        return self._state[\'pos\']\n    \n    def reset(self):\n        self._state = {\n            \'pos\': Point(0,0),\n            \'scale\': Point(1,1),\n            \'angle\': 0.0  ## in degrees\n        }\n        self.update()\n        \n    def setFromQTransform(self, tr):\n        p1 = Point(tr.map(0., 0.))\n        p2 = Point(tr.map(1., 0.))\n        p3 = Point(tr.map(0., 1.))\n        \n        dp2 = Point(p2-p1)\n        dp3 = Point(p3-p1)\n        \n        ## detect flipped axes\n        if dp2.angle(dp3) > 0:\n            #da = 180\n            da = 0\n            sy = -1.0\n        else:\n            da = 0\n            sy = 1.0\n            \n        self._state = {\n            \'pos\': Point(p1),\n            \'scale\': Point(dp2.length(), dp3.length() * sy),\n            \'angle\': (np.arctan2(dp2[1], dp2[0]) * 180. / np.pi) + da\n        }\n        self.update()\n        \n    def setFromMatrix4x4(self, m):\n        m = SRTTransform3D(m)\n        angle, axis = m.getRotation()\n        if angle != 0 and (axis[0] != 0 or axis[1] != 0 or axis[2] != 1):\n            print(""angle: %s  axis: %s"" % (str(angle), str(axis)))\n            raise Exception(""Can only convert 4x4 matrix to 3x3 if rotation is around Z-axis."")\n        self._state = {\n            \'pos\': Point(m.getTranslation()),\n            \'scale\': Point(m.getScale()),\n            \'angle\': angle\n        }\n        self.update()\n        \n    def translate(self, *args):\n        """"""Acceptable arguments are: \n           x, y\n           [x, y]\n           Point(x,y)""""""\n        t = Point(*args)\n        self.setTranslate(self._state[\'pos\']+t)\n        \n    def setTranslate(self, *args):\n        """"""Acceptable arguments are: \n           x, y\n           [x, y]\n           Point(x,y)""""""\n        self._state[\'pos\'] = Point(*args)\n        self.update()\n        \n    def scale(self, *args):\n        """"""Acceptable arguments are: \n           x, y\n           [x, y]\n           Point(x,y)""""""\n        s = Point(*args)\n        self.setScale(self._state[\'scale\'] * s)\n        \n    def setScale(self, *args):\n        """"""Acceptable arguments are: \n           x, y\n           [x, y]\n           Point(x,y)""""""\n        self._state[\'scale\'] = Point(*args)\n        self.update()\n        \n    def rotate(self, angle):\n        """"""Rotate the transformation by angle (in degrees)""""""\n        self.setRotate(self._state[\'angle\'] + angle)\n        \n    def setRotate(self, angle):\n        """"""Set the transformation rotation to angle (in degrees)""""""\n        self._state[\'angle\'] = angle\n        self.update()\n\n    def __truediv__(self, t):\n        """"""A / B  ==  B^-1 * A""""""\n        dt = t.inverted()[0] * self\n        return SRTTransform(dt)\n        \n    def __div__(self, t):\n        return self.__truediv__(t)\n        \n    def __mul__(self, t):\n        return SRTTransform(QtGui.QTransform.__mul__(self, t))\n\n    def saveState(self):\n        p = self._state[\'pos\']\n        s = self._state[\'scale\']\n        #if s[0] == 0:\n            #raise Exception(\'Invalid scale: %s\' % str(s))\n        return {\'pos\': (p[0], p[1]), \'scale\': (s[0], s[1]), \'angle\': self._state[\'angle\']}\n\n    def restoreState(self, state):\n        self._state[\'pos\'] = Point(state.get(\'pos\', (0,0)))\n        self._state[\'scale\'] = Point(state.get(\'scale\', (1.,1.)))\n        self._state[\'angle\'] = state.get(\'angle\', 0)\n        self.update()\n\n    def update(self):\n        QtGui.QTransform.reset(self)\n        ## modifications to the transform are multiplied on the right, so we need to reverse order here.\n        QtGui.QTransform.translate(self, *self._state[\'pos\'])\n        QtGui.QTransform.rotate(self, self._state[\'angle\'])\n        QtGui.QTransform.scale(self, *self._state[\'scale\'])\n\n    def __repr__(self):\n        return str(self.saveState())\n        \n    def matrix(self):\n        return np.array([[self.m11(), self.m12(), self.m13()],[self.m21(), self.m22(), self.m23()],[self.m31(), self.m32(), self.m33()]])\n\n        \nif __name__ == \'__main__\':\n    from . import widgets\n    import GraphicsView\n    from .functions import *\n    app = QtGui.QApplication([])\n    win = QtGui.QMainWindow()\n    win.show()\n    cw = GraphicsView.GraphicsView()\n    #cw.enableMouse()  \n    win.setCentralWidget(cw)\n    s = QtGui.QGraphicsScene()\n    cw.setScene(s)\n    win.resize(600,600)\n    cw.enableMouse()\n    cw.setRange(QtCore.QRectF(-100., -100., 200., 200.))\n    \n    class Item(QtGui.QGraphicsItem):\n        def __init__(self):\n            QtGui.QGraphicsItem.__init__(self)\n            self.b = QtGui.QGraphicsRectItem(20, 20, 20, 20, self)\n            self.b.setPen(QtGui.QPen(mkPen(\'y\')))\n            self.t1 = QtGui.QGraphicsTextItem(self)\n            self.t1.setHtml(\'<span style=""color: #F00"">R</span>\')\n            self.t1.translate(20, 20)\n            self.l1 = QtGui.QGraphicsLineItem(10, 0, -10, 0, self)\n            self.l2 = QtGui.QGraphicsLineItem(0, 10, 0, -10, self)\n            self.l1.setPen(QtGui.QPen(mkPen(\'y\')))\n            self.l2.setPen(QtGui.QPen(mkPen(\'y\')))\n        def boundingRect(self):\n            return QtCore.QRectF()\n        def paint(self, *args):\n            pass\n            \n    #s.addItem(b)\n    #s.addItem(t1)\n    item = Item()\n    s.addItem(item)\n    l1 = QtGui.QGraphicsLineItem(10, 0, -10, 0)\n    l2 = QtGui.QGraphicsLineItem(0, 10, 0, -10)\n    l1.setPen(QtGui.QPen(mkPen(\'r\')))\n    l2.setPen(QtGui.QPen(mkPen(\'r\')))\n    s.addItem(l1)\n    s.addItem(l2)\n    \n    tr1 = SRTTransform()\n    tr2 = SRTTransform()\n    tr3 = QtGui.QTransform()\n    tr3.translate(20, 0)\n    tr3.rotate(45)\n    print(""QTransform -> Transform:"", SRTTransform(tr3))\n    \n    print(""tr1:"", tr1)\n    \n    tr2.translate(20, 0)\n    tr2.rotate(45)\n    print(""tr2:"", tr2)\n    \n    dt = tr2/tr1\n    print(""tr2 / tr1 = "", dt)\n    \n    print(""tr2 * tr1 = "", tr2*tr1)\n    \n    tr4 = SRTTransform()\n    tr4.scale(-1, 1)\n    tr4.rotate(30)\n    print(""tr1 * tr4 = "", tr1*tr4)\n    \n    w1 = widgets.TestROI((19,19), (22, 22), invertible=True)\n    #w2 = widgets.TestROI((0,0), (150, 150))\n    w1.setZValue(10)\n    s.addItem(w1)\n    #s.addItem(w2)\n    w1Base = w1.getState()\n    #w2Base = w2.getState()\n    def update():\n        tr1 = w1.getGlobalTransform(w1Base)\n        #tr2 = w2.getGlobalTransform(w2Base)\n        item.setTransform(tr1)\n        \n    #def update2():\n        #tr1 = w1.getGlobalTransform(w1Base)\n        #tr2 = w2.getGlobalTransform(w2Base)\n        #t1.setTransform(tr1)\n        #w1.setState(w1Base)\n        #w1.applyGlobalTransform(tr2)\n        \n    w1.sigRegionChanged.connect(update)\n    #w2.sigRegionChanged.connect(update2)\n    \nfrom .SRTTransform3D import SRTTransform3D\n'"
src/third_party/pyqtgraph/SRTTransform3D.py,8,"b'# -*- coding: utf-8 -*-\nfrom .Qt import QtCore, QtGui\nfrom .Vector import Vector\nfrom .Transform3D import Transform3D\nfrom .Vector import Vector\nimport numpy as np\n\nclass SRTTransform3D(Transform3D):\n    """"""4x4 Transform matrix that can always be represented as a combination of 3 matrices: scale * rotate * translate\n    This transform has no shear; angles are always preserved.\n    """"""\n    def __init__(self, init=None):\n        Transform3D.__init__(self)\n        self.reset()\n        if init is None:\n            return\n        if init.__class__ is QtGui.QTransform:\n            init = SRTTransform(init)\n        \n        if isinstance(init, dict):\n            self.restoreState(init)\n        elif isinstance(init, SRTTransform3D):\n            self._state = {\n                \'pos\': Vector(init._state[\'pos\']),\n                \'scale\': Vector(init._state[\'scale\']),\n                \'angle\': init._state[\'angle\'],\n                \'axis\': Vector(init._state[\'axis\']),\n            }\n            self.update()\n        elif isinstance(init, SRTTransform):\n            self._state = {\n                \'pos\': Vector(init._state[\'pos\']),\n                \'scale\': Vector(init._state[\'scale\']),\n                \'angle\': init._state[\'angle\'],\n                \'axis\': Vector(0, 0, 1),\n            }\n            self._state[\'scale\'][2] = 1.0\n            self.update()\n        elif isinstance(init, QtGui.QMatrix4x4):\n            self.setFromMatrix(init)\n        else:\n            raise Exception(""Cannot build SRTTransform3D from argument type:"", type(init))\n\n        \n    def getScale(self):\n        return Vector(self._state[\'scale\'])\n        \n    def getRotation(self):\n        """"""Return (angle, axis) of rotation""""""\n        return self._state[\'angle\'], Vector(self._state[\'axis\'])\n        \n    def getTranslation(self):\n        return Vector(self._state[\'pos\'])\n    \n    def reset(self):\n        self._state = {\n            \'pos\': Vector(0,0,0),\n            \'scale\': Vector(1,1,1),\n            \'angle\': 0.0,  ## in degrees\n            \'axis\': (0, 0, 1)\n        }\n        self.update()\n        \n    def translate(self, *args):\n        """"""Adjust the translation of this transform""""""\n        t = Vector(*args)\n        self.setTranslate(self._state[\'pos\']+t)\n        \n    def setTranslate(self, *args):\n        """"""Set the translation of this transform""""""\n        self._state[\'pos\'] = Vector(*args)\n        self.update()\n        \n    def scale(self, *args):\n        """"""adjust the scale of this transform""""""\n        ## try to prevent accidentally setting 0 scale on z axis\n        if len(args) == 1 and hasattr(args[0], \'__len__\'):\n            args = args[0]\n        if len(args) == 2:\n            args = args + (1,)\n            \n        s = Vector(*args)\n        self.setScale(self._state[\'scale\'] * s)\n        \n    def setScale(self, *args):\n        """"""Set the scale of this transform""""""\n        if len(args) == 1 and hasattr(args[0], \'__len__\'):\n            args = args[0]\n        if len(args) == 2:\n            args = args + (1,)\n        self._state[\'scale\'] = Vector(*args)\n        self.update()\n        \n    def rotate(self, angle, axis=(0,0,1)):\n        """"""Adjust the rotation of this transform""""""\n        origAxis = self._state[\'axis\']\n        if axis[0] == origAxis[0] and axis[1] == origAxis[1] and axis[2] == origAxis[2]:\n            self.setRotate(self._state[\'angle\'] + angle)\n        else:\n            m = QtGui.QMatrix4x4()\n            m.translate(*self._state[\'pos\'])\n            m.rotate(self._state[\'angle\'], *self._state[\'axis\'])\n            m.rotate(angle, *axis)\n            m.scale(*self._state[\'scale\'])\n            self.setFromMatrix(m)\n        \n    def setRotate(self, angle, axis=(0,0,1)):\n        """"""Set the transformation rotation to angle (in degrees)""""""\n        \n        self._state[\'angle\'] = angle\n        self._state[\'axis\'] = Vector(axis)\n        self.update()\n    \n    def setFromMatrix(self, m):\n        """"""\n        Set this transform based on the elements of *m*\n        The input matrix must be affine AND have no shear,\n        otherwise the conversion will most likely fail.\n        """"""\n        import numpy.linalg\n        for i in range(4):\n            self.setRow(i, m.row(i))\n        m = self.matrix().reshape(4,4)\n        ## translation is 4th column\n        self._state[\'pos\'] = m[:3,3]\n        \n        ## scale is vector-length of first three columns\n        scale = (m[:3,:3]**2).sum(axis=0)**0.5\n        ## see whether there is an inversion\n        z = np.cross(m[0, :3], m[1, :3])\n        if np.dot(z, m[2, :3]) < 0:\n            scale[1] *= -1  ## doesn\'t really matter which axis we invert\n        self._state[\'scale\'] = scale\n        \n        ## rotation axis is the eigenvector with eigenvalue=1\n        r = m[:3, :3] / scale[np.newaxis, :]\n        try:\n            evals, evecs = numpy.linalg.eig(r)\n        except:\n            print(""Rotation matrix: %s"" % str(r))\n            print(""Scale: %s"" % str(scale))\n            print(""Original matrix: %s"" % str(m))\n            raise\n        eigIndex = np.argwhere(np.abs(evals-1) < 1e-6)\n        if len(eigIndex) < 1:\n            print(""eigenvalues: %s"" % str(evals))\n            print(""eigenvectors: %s"" % str(evecs))\n            print(""index: %s, %s"" % (str(eigIndex), str(evals-1)))\n            raise Exception(""Could not determine rotation axis."")\n        axis = evecs[:,eigIndex[0,0]].real\n        axis /= ((axis**2).sum())**0.5\n        self._state[\'axis\'] = axis\n        \n        ## trace(r) == 2 cos(angle) + 1, so:\n        cos = (r.trace()-1)*0.5  ## this only gets us abs(angle)\n        \n        ## The off-diagonal values can be used to correct the angle ambiguity, \n        ## but we need to figure out which element to use:\n        axisInd = np.argmax(np.abs(axis))\n        rInd,sign = [((1,2), -1), ((0,2), 1), ((0,1), -1)][axisInd]\n        \n        ## Then we have r-r.T = sin(angle) * 2 * sign * axis[axisInd];\n        ## solve for sin(angle)\n        sin = (r-r.T)[rInd] / (2. * sign * axis[axisInd])\n        \n        ## finally, we get the complete angle from arctan(sin/cos)\n        self._state[\'angle\'] = np.arctan2(sin, cos) * 180 / np.pi\n        if self._state[\'angle\'] == 0:\n            self._state[\'axis\'] = (0,0,1)\n        \n    def as2D(self):\n        """"""Return a QTransform representing the x,y portion of this transform (if possible)""""""\n        return SRTTransform(self)\n\n    #def __div__(self, t):\n        #""""""A / B  ==  B^-1 * A""""""\n        #dt = t.inverted()[0] * self\n        #return SRTTransform(dt)\n        \n    #def __mul__(self, t):\n        #return SRTTransform(QtGui.QTransform.__mul__(self, t))\n\n    def saveState(self):\n        p = self._state[\'pos\']\n        s = self._state[\'scale\']\n        ax = self._state[\'axis\']\n        #if s[0] == 0:\n            #raise Exception(\'Invalid scale: %s\' % str(s))\n        return {\n            \'pos\': (p[0], p[1], p[2]), \n            \'scale\': (s[0], s[1], s[2]), \n            \'angle\': self._state[\'angle\'], \n            \'axis\': (ax[0], ax[1], ax[2])\n        }\n\n    def restoreState(self, state):\n        self._state[\'pos\'] = Vector(state.get(\'pos\', (0.,0.,0.)))\n        scale = state.get(\'scale\', (1.,1.,1.))\n        scale = tuple(scale) + (1.,) * (3-len(scale))\n        self._state[\'scale\'] = Vector(scale)\n        self._state[\'angle\'] = state.get(\'angle\', 0.)\n        self._state[\'axis\'] = state.get(\'axis\', (0, 0, 1))\n        self.update()\n\n    def update(self):\n        Transform3D.setToIdentity(self)\n        ## modifications to the transform are multiplied on the right, so we need to reverse order here.\n        Transform3D.translate(self, *self._state[\'pos\'])\n        Transform3D.rotate(self, self._state[\'angle\'], *self._state[\'axis\'])\n        Transform3D.scale(self, *self._state[\'scale\'])\n\n    def __repr__(self):\n        return str(self.saveState())\n        \n    def matrix(self, nd=3):\n        if nd == 3:\n            return np.array(self.copyDataTo()).reshape(4,4)\n        elif nd == 2:\n            m = np.array(self.copyDataTo()).reshape(4,4)\n            m[2] = m[3]\n            m[:,2] = m[:,3]\n            return m[:3,:3]\n        else:\n            raise Exception(""Argument \'nd\' must be 2 or 3"")\n        \nif __name__ == \'__main__\':\n    import widgets\n    import GraphicsView\n    from functions import *\n    app = QtGui.QApplication([])\n    win = QtGui.QMainWindow()\n    win.show()\n    cw = GraphicsView.GraphicsView()\n    #cw.enableMouse()  \n    win.setCentralWidget(cw)\n    s = QtGui.QGraphicsScene()\n    cw.setScene(s)\n    win.resize(600,600)\n    cw.enableMouse()\n    cw.setRange(QtCore.QRectF(-100., -100., 200., 200.))\n    \n    class Item(QtGui.QGraphicsItem):\n        def __init__(self):\n            QtGui.QGraphicsItem.__init__(self)\n            self.b = QtGui.QGraphicsRectItem(20, 20, 20, 20, self)\n            self.b.setPen(QtGui.QPen(mkPen(\'y\')))\n            self.t1 = QtGui.QGraphicsTextItem(self)\n            self.t1.setHtml(\'<span style=""color: #F00"">R</span>\')\n            self.t1.translate(20, 20)\n            self.l1 = QtGui.QGraphicsLineItem(10, 0, -10, 0, self)\n            self.l2 = QtGui.QGraphicsLineItem(0, 10, 0, -10, self)\n            self.l1.setPen(QtGui.QPen(mkPen(\'y\')))\n            self.l2.setPen(QtGui.QPen(mkPen(\'y\')))\n        def boundingRect(self):\n            return QtCore.QRectF()\n        def paint(self, *args):\n            pass\n            \n    #s.addItem(b)\n    #s.addItem(t1)\n    item = Item()\n    s.addItem(item)\n    l1 = QtGui.QGraphicsLineItem(10, 0, -10, 0)\n    l2 = QtGui.QGraphicsLineItem(0, 10, 0, -10)\n    l1.setPen(QtGui.QPen(mkPen(\'r\')))\n    l2.setPen(QtGui.QPen(mkPen(\'r\')))\n    s.addItem(l1)\n    s.addItem(l2)\n    \n    tr1 = SRTTransform()\n    tr2 = SRTTransform()\n    tr3 = QtGui.QTransform()\n    tr3.translate(20, 0)\n    tr3.rotate(45)\n    print(""QTransform -> Transform: %s"" % str(SRTTransform(tr3)))\n    \n    print(""tr1: %s"" % str(tr1))\n    \n    tr2.translate(20, 0)\n    tr2.rotate(45)\n    print(""tr2: %s"" % str(tr2))\n    \n    dt = tr2/tr1\n    print(""tr2 / tr1 = %s"" % str(dt))\n    \n    print(""tr2 * tr1 = %s"" % str(tr2*tr1))\n    \n    tr4 = SRTTransform()\n    tr4.scale(-1, 1)\n    tr4.rotate(30)\n    print(""tr1 * tr4 = %s"" % str(tr1*tr4))\n    \n    w1 = widgets.TestROI((19,19), (22, 22), invertible=True)\n    #w2 = widgets.TestROI((0,0), (150, 150))\n    w1.setZValue(10)\n    s.addItem(w1)\n    #s.addItem(w2)\n    w1Base = w1.getState()\n    #w2Base = w2.getState()\n    def update():\n        tr1 = w1.getGlobalTransform(w1Base)\n        #tr2 = w2.getGlobalTransform(w2Base)\n        item.setTransform(tr1)\n        \n    #def update2():\n        #tr1 = w1.getGlobalTransform(w1Base)\n        #tr2 = w2.getGlobalTransform(w2Base)\n        #t1.setTransform(tr1)\n        #w1.setState(w1Base)\n        #w1.applyGlobalTransform(tr2)\n        \n    w1.sigRegionChanged.connect(update)\n    #w2.sigRegionChanged.connect(update2)\n    \nfrom .SRTTransform import SRTTransform\n'"
src/third_party/pyqtgraph/SignalProxy.py,0,"b'# -*- coding: utf-8 -*-\nfrom .Qt import QtCore\nfrom .ptime import time\nfrom . import ThreadsafeTimer\nimport weakref\n\n__all__ = [\'SignalProxy\']\n\nclass SignalProxy(QtCore.QObject):\n    """"""Object which collects rapid-fire signals and condenses them\n    into a single signal or a rate-limited stream of signals. \n    Used, for example, to prevent a SpinBox from generating multiple \n    signals when the mouse wheel is rolled over it.\n    \n    Emits sigDelayed after input signals have stopped for a certain period of time.\n    """"""\n    \n    sigDelayed = QtCore.Signal(object)\n    \n    def __init__(self, signal, delay=0.3, rateLimit=0, slot=None):\n        """"""Initialization arguments:\n        signal - a bound Signal or pyqtSignal instance\n        delay - Time (in seconds) to wait for signals to stop before emitting (default 0.3s)\n        slot - Optional function to connect sigDelayed to.\n        rateLimit - (signals/sec) if greater than 0, this allows signals to stream out at a \n                    steady rate while they are being received.\n        """"""\n        \n        QtCore.QObject.__init__(self)\n        signal.connect(self.signalReceived)\n        self.signal = signal\n        self.delay = delay\n        self.rateLimit = rateLimit\n        self.args = None\n        self.timer = ThreadsafeTimer.ThreadsafeTimer()\n        self.timer.timeout.connect(self.flush)\n        self.block = False\n        self.slot = weakref.ref(slot)\n        self.lastFlushTime = None\n        if slot is not None:\n            self.sigDelayed.connect(slot)\n        \n    def setDelay(self, delay):\n        self.delay = delay\n        \n    def signalReceived(self, *args):\n        """"""Received signal. Cancel previous timer and store args to be forwarded later.""""""\n        if self.block:\n            return\n        self.args = args\n        if self.rateLimit == 0:\n            self.timer.stop()\n            self.timer.start((self.delay*1000)+1)\n        else:\n            now = time()\n            if self.lastFlushTime is None:\n                leakTime = 0\n            else:\n                lastFlush = self.lastFlushTime\n                leakTime = max(0, (lastFlush + (1.0 / self.rateLimit)) - now)\n                \n            self.timer.stop()\n            self.timer.start((min(leakTime, self.delay)*1000)+1)\n            \n        \n    def flush(self):\n        """"""If there is a signal queued up, send it now.""""""\n        if self.args is None or self.block:\n            return False\n        #self.emit(self.signal, *self.args)\n        self.sigDelayed.emit(self.args)\n        self.args = None\n        self.timer.stop()\n        self.lastFlushTime = time()\n        return True\n        \n    def disconnect(self):\n        self.block = True\n        try:\n            self.signal.disconnect(self.signalReceived)\n        except:\n            pass\n        try:\n            self.sigDelayed.disconnect(self.slot())\n        except:\n            pass\n   \n   \n\n#def proxyConnect(source, signal, slot, delay=0.3):\n    #""""""Connect a signal to a slot with delay. Returns the SignalProxy\n    #object that was created. Be sure to store this object so it is not\n    #garbage-collected immediately.""""""\n    #sp = SignalProxy(source, signal, delay)\n    #if source is None:\n        #sp.connect(sp, QtCore.SIGNAL(\'signal\'), slot)\n    #else:\n        #sp.connect(sp, signal, slot)\n    #return sp\n    \n    \nif __name__ == \'__main__\':\n    from .Qt import QtGui\n    app = QtGui.QApplication([])\n    win = QtGui.QMainWindow()\n    spin = QtGui.QSpinBox()\n    win.setCentralWidget(spin)\n    win.show()\n    \n    def fn(*args):\n        print(""Raw signal:"", args)\n    def fn2(*args):\n        print(""Delayed signal:"", args)\n    \n    \n    spin.valueChanged.connect(fn)\n    #proxy = proxyConnect(spin, QtCore.SIGNAL(\'valueChanged(int)\'), fn)\n    proxy = SignalProxy(spin.valueChanged, delay=0.5, slot=fn2)\n        '"
src/third_party/pyqtgraph/ThreadsafeTimer.py,0,"b'from .Qt import QtCore, QtGui\n\nclass ThreadsafeTimer(QtCore.QObject):\n    """"""\n    Thread-safe replacement for QTimer.\n    """"""\n    \n    timeout = QtCore.Signal()\n    sigTimerStopRequested = QtCore.Signal()\n    sigTimerStartRequested = QtCore.Signal(object)\n    \n    def __init__(self):\n        QtCore.QObject.__init__(self)\n        self.timer = QtCore.QTimer()\n        self.timer.timeout.connect(self.timerFinished)\n        self.timer.moveToThread(QtCore.QCoreApplication.instance().thread())\n        self.moveToThread(QtCore.QCoreApplication.instance().thread())\n        self.sigTimerStopRequested.connect(self.stop, QtCore.Qt.QueuedConnection)\n        self.sigTimerStartRequested.connect(self.start, QtCore.Qt.QueuedConnection)\n        \n        \n    def start(self, timeout):\n        isGuiThread = QtCore.QThread.currentThread() == QtCore.QCoreApplication.instance().thread()\n        if isGuiThread:\n            #print ""start timer"", self, ""from gui thread""\n            self.timer.start(timeout)\n        else:\n            #print ""start timer"", self, ""from remote thread""\n            self.sigTimerStartRequested.emit(timeout)\n        \n    def stop(self):\n        isGuiThread = QtCore.QThread.currentThread() == QtCore.QCoreApplication.instance().thread()\n        if isGuiThread:\n            #print ""stop timer"", self, ""from gui thread""\n            self.timer.stop()\n        else:\n            #print ""stop timer"", self, ""from remote thread""\n            self.sigTimerStopRequested.emit()\n        \n    def timerFinished(self):\n        self.timeout.emit()'"
src/third_party/pyqtgraph/Transform3D.py,5,"b'# -*- coding: utf-8 -*-\nfrom .Qt import QtCore, QtGui\nfrom . import functions as fn\nfrom .Vector import Vector\nimport numpy as np\n\n\nclass Transform3D(QtGui.QMatrix4x4):\n    """"""\n    Extension of QMatrix4x4 with some helpful methods added.\n    """"""\n    def __init__(self, *args):\n        if len(args) == 1:\n            if isinstance(args[0], (list, tuple, np.ndarray)):\n                args = [x for y in args[0] for x in y]\n                if len(args) != 16:\n                    raise TypeError(""Single argument to Transform3D must have 16 elements."")\n            elif isinstance(args[0], QtGui.QMatrix4x4):\n                args = list(args[0].copyDataTo())\n        \n        QtGui.QMatrix4x4.__init__(self, *args)\n        \n    def matrix(self, nd=3):\n        if nd == 3:\n            return np.array(self.copyDataTo()).reshape(4,4)\n        elif nd == 2:\n            m = np.array(self.copyDataTo()).reshape(4,4)\n            m[2] = m[3]\n            m[:,2] = m[:,3]\n            return m[:3,:3]\n        else:\n            raise Exception(""Argument \'nd\' must be 2 or 3"")\n        \n    def map(self, obj):\n        """"""\n        Extends QMatrix4x4.map() to allow mapping (3, ...) arrays of coordinates\n        """"""\n        if isinstance(obj, np.ndarray) and obj.shape[0] in (2,3):\n            if obj.ndim >= 2:\n                return fn.transformCoordinates(self, obj)\n            elif obj.ndim == 1:\n                v = QtGui.QMatrix4x4.map(self, Vector(obj))\n                return np.array([v.x(), v.y(), v.z()])[:obj.shape[0]]\n        elif isinstance(obj, (list, tuple)):\n            v = QtGui.QMatrix4x4.map(self, Vector(obj))\n            return type(obj)([v.x(), v.y(), v.z()])[:len(obj)]\n        else:\n            return QtGui.QMatrix4x4.map(self, obj)\n            \n    def inverted(self):\n        inv, b = QtGui.QMatrix4x4.inverted(self)\n        return Transform3D(inv), b\n'"
src/third_party/pyqtgraph/Vector.py,2,"b'# -*- coding: utf-8 -*-\n""""""\nVector.py -  Extension of QVector3D which adds a few missing methods.\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n""""""\n\nfrom .Qt import QtGui, QtCore, QT_LIB\nimport numpy as np\n\nclass Vector(QtGui.QVector3D):\n    """"""Extension of QVector3D which adds a few helpful methods.""""""\n    \n    def __init__(self, *args):\n        if len(args) == 1:\n            if isinstance(args[0], QtCore.QSizeF):\n                QtGui.QVector3D.__init__(self, float(args[0].width()), float(args[0].height()), 0)\n                return\n            elif isinstance(args[0], QtCore.QPoint) or isinstance(args[0], QtCore.QPointF):\n                QtGui.QVector3D.__init__(self, float(args[0].x()), float(args[0].y()), 0)\n            elif hasattr(args[0], \'__getitem__\'):\n                vals = list(args[0])\n                if len(vals) == 2:\n                    vals.append(0)\n                if len(vals) != 3:\n                    raise Exception(\'Cannot init Vector with sequence of length %d\' % len(args[0]))\n                QtGui.QVector3D.__init__(self, *vals)\n                return\n        elif len(args) == 2:\n            QtGui.QVector3D.__init__(self, args[0], args[1], 0)\n            return\n        QtGui.QVector3D.__init__(self, *args)\n\n    def __len__(self):\n        return 3\n\n    def __add__(self, b):\n        # workaround for pyside bug. see https://bugs.launchpad.net/pyqtgraph/+bug/1223173\n        if QT_LIB == \'PySide\' and isinstance(b, QtGui.QVector3D):\n            b = Vector(b)\n        return QtGui.QVector3D.__add__(self, b)\n    \n    #def __reduce__(self):\n        #return (Point, (self.x(), self.y()))\n        \n    def __getitem__(self, i):\n        if i == 0:\n            return self.x()\n        elif i == 1:\n            return self.y()\n        elif i == 2:\n            return self.z()\n        else:\n            raise IndexError(""Point has no index %s"" % str(i))\n        \n    def __setitem__(self, i, x):\n        if i == 0:\n            return self.setX(x)\n        elif i == 1:\n            return self.setY(x)\n        elif i == 2:\n            return self.setZ(x)\n        else:\n            raise IndexError(""Point has no index %s"" % str(i))\n        \n    def __iter__(self):\n        yield(self.x())\n        yield(self.y())\n        yield(self.z())\n\n    def angle(self, a):\n        """"""Returns the angle in degrees between this vector and the vector a.""""""\n        n1 = self.length()\n        n2 = a.length()\n        if n1 == 0. or n2 == 0.:\n            return None\n        ## Probably this should be done with arctan2 instead..\n        ang = np.arccos(np.clip(QtGui.QVector3D.dotProduct(self, a) / (n1 * n2), -1.0, 1.0)) ### in radians\n#        c = self.crossProduct(a)\n#        if c > 0:\n#            ang *= -1.\n        return ang * 180. / np.pi\n\n    def __abs__(self):\n        return Vector(abs(self.x()), abs(self.y()), abs(self.z()))\n        \n        '"
src/third_party/pyqtgraph/WidgetGroup.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nWidgetGroup.py -  WidgetGroup class for easily managing lots of Qt widgets\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n\nThis class addresses the problem of having to save and restore the state\nof a large group of widgets. \n""""""\n\nfrom .Qt import QtCore, QtGui, QT_LIB\nimport weakref, inspect\nfrom .python2_3 import asUnicode\n\n\n__all__ = [\'WidgetGroup\']\n\ndef splitterState(w):\n    s = str(w.saveState().toPercentEncoding())\n    return s\n    \ndef restoreSplitter(w, s):\n    if type(s) is list:\n        w.setSizes(s)\n    elif type(s) is str:\n        w.restoreState(QtCore.QByteArray.fromPercentEncoding(s))\n    else:\n        print(""Can\'t configure QSplitter using object of type"", type(s))\n    if w.count() > 0:   ## make sure at least one item is not collapsed\n        for i in w.sizes():\n            if i > 0:\n                return\n        w.setSizes([50] * w.count())\n        \ndef comboState(w):\n    ind = w.currentIndex()\n    data = w.itemData(ind)\n    #if not data.isValid():\n    if data is not None:\n        try:\n            if not data.isValid():\n                data = None\n            else:\n                data = data.toInt()[0]\n        except AttributeError:\n            pass\n    if data is None:\n        return asUnicode(w.itemText(ind))\n    else:\n        return data\n    \ndef setComboState(w, v):\n    if type(v) is int:\n        #ind = w.findData(QtCore.QVariant(v))\n        ind = w.findData(v)\n        if ind > -1:\n            w.setCurrentIndex(ind)\n            return\n    w.setCurrentIndex(w.findText(str(v)))\n        \n\nclass WidgetGroup(QtCore.QObject):\n    """"""This class takes a list of widgets and keeps an internal record of their\n    state that is always up to date. \n    \n    Allows reading and writing from groups of widgets simultaneously.\n    """"""\n    \n    ## List of widget types that can be handled by WidgetGroup.\n    ## The value for each type is a tuple (change signal function, get function, set function, [auto-add children])\n    ## The change signal function that takes an object and returns a signal that is emitted any time the state of the widget changes, not just \n    ##   when it is changed by user interaction. (for example, \'clicked\' is not a valid signal here)\n    ## If the change signal is None, the value of the widget is not cached.\n    ## Custom widgets not in this list can be made to work with WidgetGroup by giving them a \'widgetGroupInterface\' method\n    ##   which returns the tuple.\n    classes = {\n        QtGui.QSpinBox: \n            (lambda w: w.valueChanged, \n            QtGui.QSpinBox.value, \n            QtGui.QSpinBox.setValue),\n        QtGui.QDoubleSpinBox: \n            (lambda w: w.valueChanged, \n            QtGui.QDoubleSpinBox.value, \n            QtGui.QDoubleSpinBox.setValue),\n        QtGui.QSplitter: \n            (None, \n            splitterState,\n            restoreSplitter,\n            True),\n        QtGui.QCheckBox: \n            (lambda w: w.stateChanged,\n            QtGui.QCheckBox.isChecked,\n            QtGui.QCheckBox.setChecked),\n        QtGui.QComboBox:\n            (lambda w: w.currentIndexChanged,\n            comboState,\n            setComboState),\n        QtGui.QGroupBox:\n            (lambda w: w.toggled,\n            QtGui.QGroupBox.isChecked,\n            QtGui.QGroupBox.setChecked,\n            True),\n        QtGui.QLineEdit:\n            (lambda w: w.editingFinished,\n            lambda w: str(w.text()),\n            QtGui.QLineEdit.setText),\n        QtGui.QRadioButton:\n            (lambda w: w.toggled,\n            QtGui.QRadioButton.isChecked,\n            QtGui.QRadioButton.setChecked),\n        QtGui.QSlider:\n            (lambda w: w.valueChanged,\n            QtGui.QSlider.value,\n            QtGui.QSlider.setValue),\n    }\n    \n    sigChanged = QtCore.Signal(str, object)\n    \n    \n    def __init__(self, widgetList=None):\n        """"""Initialize WidgetGroup, adding specified widgets into this group.\n        widgetList can be: \n         - a list of widget specifications (widget, [name], [scale])\n         - a dict of name: widget pairs\n         - any QObject, and all compatible child widgets will be added recursively.\n        \n        The \'scale\' parameter for each widget allows QSpinBox to display a different value than the value recorded\n        in the group state (for example, the program may set a spin box value to 100e-6 and have it displayed as 100 to the user)\n        """"""\n        QtCore.QObject.__init__(self)\n        self.widgetList = weakref.WeakKeyDictionary() # Make sure widgets don\'t stick around just because they are listed here\n        self.scales = weakref.WeakKeyDictionary()\n        self.cache = {}  ## name:value pairs\n        self.uncachedWidgets = weakref.WeakKeyDictionary()\n        if isinstance(widgetList, QtCore.QObject):\n            self.autoAdd(widgetList)\n        elif isinstance(widgetList, list):\n            for w in widgetList:\n                self.addWidget(*w)\n        elif isinstance(widgetList, dict):\n            for name, w in widgetList.items():\n                self.addWidget(w, name)\n        elif widgetList is None:\n            return\n        else:\n            raise Exception(""Wrong argument type %s"" % type(widgetList))\n        \n    def addWidget(self, w, name=None, scale=None):\n        if not self.acceptsType(w):\n            raise Exception(""Widget type %s not supported by WidgetGroup"" % type(w))\n        if name is None:\n            name = str(w.objectName())\n        if name == \'\':\n            raise Exception(""Cannot add widget \'%s\' without a name."" % str(w))\n        self.widgetList[w] = name\n        self.scales[w] = scale\n        self.readWidget(w)\n            \n        if type(w) in WidgetGroup.classes:\n            signal = WidgetGroup.classes[type(w)][0]\n        else:\n            signal = w.widgetGroupInterface()[0]\n            \n        if signal is not None:\n            if inspect.isfunction(signal) or inspect.ismethod(signal):\n                signal = signal(w)\n            signal.connect(self.mkChangeCallback(w))\n        else:\n            self.uncachedWidgets[w] = None\n       \n    def findWidget(self, name):\n        for w in self.widgetList:\n            if self.widgetList[w] == name:\n                return w\n        return None\n       \n    def interface(self, obj):\n        t = type(obj)\n        if t in WidgetGroup.classes:\n            return WidgetGroup.classes[t]\n        else:\n            return obj.widgetGroupInterface()\n\n    def checkForChildren(self, obj):\n        """"""Return true if we should automatically search the children of this object for more.""""""\n        iface = self.interface(obj)\n        return (len(iface) > 3 and iface[3])\n       \n    def autoAdd(self, obj):\n        ## Find all children of this object and add them if possible.\n        accepted = self.acceptsType(obj)\n        if accepted:\n            #print ""%s  auto add %s"" % (self.objectName(), obj.objectName())\n            self.addWidget(obj)\n            \n        if not accepted or self.checkForChildren(obj):\n            for c in obj.children():\n                self.autoAdd(c)\n\n    def acceptsType(self, obj):\n        for c in WidgetGroup.classes:\n            if isinstance(obj, c):\n                return True\n        if hasattr(obj, \'widgetGroupInterface\'):\n            return True\n        return False\n\n    def setScale(self, widget, scale):\n        val = self.readWidget(widget)\n        self.scales[widget] = scale\n        self.setWidget(widget, val)\n\n    def mkChangeCallback(self, w):\n        return lambda *args: self.widgetChanged(w, *args)\n        \n    def widgetChanged(self, w, *args):\n        n = self.widgetList[w]\n        v1 = self.cache[n]\n        v2 = self.readWidget(w)\n        if v1 != v2:\n            if QT_LIB != \'PyQt5\':\n                # Old signal kept for backward compatibility.\n                self.emit(QtCore.SIGNAL(\'changed\'), self.widgetList[w], v2)\n            self.sigChanged.emit(self.widgetList[w], v2)\n        \n    def state(self):\n        for w in self.uncachedWidgets:\n            self.readWidget(w)\n        return self.cache.copy()\n\n    def setState(self, s):\n        for w in self.widgetList:\n            n = self.widgetList[w]\n            if n not in s:\n                continue\n            self.setWidget(w, s[n])\n\n    def readWidget(self, w):\n        if type(w) in WidgetGroup.classes:\n            getFunc = WidgetGroup.classes[type(w)][1]\n        else:\n            getFunc = w.widgetGroupInterface()[1]\n        \n        if getFunc is None:\n            return None\n            \n        ## if the getter function provided in the interface is a bound method,\n        ## then just call the method directly. Otherwise, pass in the widget as the first arg\n        ## to the function.\n        if inspect.ismethod(getFunc) and getFunc.__self__ is not None:  \n            val = getFunc()\n        else:\n            val = getFunc(w)\n            \n        if self.scales[w] is not None:\n            val /= self.scales[w]\n        #if isinstance(val, QtCore.QString):\n            #val = str(val)\n        n = self.widgetList[w]\n        self.cache[n] = val\n        return val\n\n    def setWidget(self, w, v):\n        v1 = v\n        if self.scales[w] is not None:\n            v *= self.scales[w]\n        \n        if type(w) in WidgetGroup.classes:\n            setFunc = WidgetGroup.classes[type(w)][2]\n        else:\n            setFunc = w.widgetGroupInterface()[2]\n            \n        ## if the setter function provided in the interface is a bound method,\n        ## then just call the method directly. Otherwise, pass in the widget as the first arg\n        ## to the function.\n        if inspect.ismethod(setFunc) and setFunc.__self__ is not None:  \n            setFunc(v)\n        else:\n            setFunc(w, v)\n            \n        #name = self.widgetList[w]\n        #if name in self.cache and (self.cache[name] != v1):\n            #print ""%s: Cached value %s != set value %s"" % (name, str(self.cache[name]), str(v1))\n\n        \n        '"
src/third_party/pyqtgraph/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nPyQtGraph - Scientific Graphics and GUI Library for Python\nwww.pyqtgraph.org\n""""""\n\n__version__ = \'0.11.0.dev0\'\n\n### import all the goodies and add some helper functions for easy CLI use\n\n## \'Qt\' is a local module; it is intended mainly to cover up the differences\n## between PyQt4 and PySide.\nfrom .Qt import QtGui, mkQApp\n\n## not really safe--If we accidentally create another QApplication, the process hangs (and it is very difficult to trace the cause)\n#if QtGui.QApplication.instance() is None:\n    #app = QtGui.QApplication([])\n\nimport numpy  ## pyqtgraph requires numpy\n              ## (import here to avoid massive error dump later on if numpy is not available)\n\nimport os, sys\n\n## check python version\n## Allow anything >= 2.7\nif sys.version_info[0] < 2 or (sys.version_info[0] == 2 and sys.version_info[1] < 6):\n    raise Exception(""Pyqtgraph requires Python version 2.6 or greater (this is %d.%d)"" % (sys.version_info[0], sys.version_info[1]))\n\n## helpers for 2/3 compatibility\nfrom . import python2_3\n\n## install workarounds for numpy bugs\nfrom . import numpy_fix\n\n## in general openGL is poorly supported with Qt+GraphicsView.\n## we only enable it where the performance benefit is critical.\n## Note this only applies to 2D graphics; 3D graphics always use OpenGL.\nif \'linux\' in sys.platform:  ## linux has numerous bugs in opengl implementation\n    useOpenGL = False\nelif \'darwin\' in sys.platform: ## openGL can have a major impact on mac, but also has serious bugs\n    useOpenGL = False\n    if QtGui.QApplication.instance() is not None:\n        print(\'Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(""raster"") before the QApplication is created).\')\n    if QtGui.QApplication.setGraphicsSystem:\n        QtGui.QApplication.setGraphicsSystem(\'raster\')  ## work around a variety of bugs in the native graphics system \nelse:\n    useOpenGL = False  ## on windows there\'s a more even performance / bugginess tradeoff. \n                \nCONFIG_OPTIONS = {\n    \'useOpenGL\': useOpenGL, ## by default, this is platform-dependent (see widgets/GraphicsView). Set to True or False to explicitly enable/disable opengl.\n    \'leftButtonPan\': True,  ## if false, left button drags a rubber band for zooming in viewbox\n    # foreground/background take any arguments to the \'mkColor\' in /pyqtgraph/functions.py\n    \'foreground\': \'d\',  ## default foreground color for axes, labels, etc.\n    \'background\': \'k\',        ## default background for GraphicsWidget\n    \'antialias\': False,\n    \'editorCommand\': None,  ## command used to invoke code editor from ConsoleWidgets\n    \'useWeave\': False,       ## Use weave to speed up some operations, if it is available\n    \'weaveDebug\': False,    ## Print full error message if weave compile fails\n    \'exitCleanup\': True,    ## Attempt to work around some exit crash bugs in PyQt and PySide\n    \'enableExperimental\': False, ## Enable experimental features (the curious can search for this key in the code)\n    \'crashWarning\': False,  # If True, print warnings about situations that may result in a crash\n    \'imageAxisOrder\': \'col-major\',  # For \'row-major\', image data is expected in the standard (row, col) order.\n                                 # For \'col-major\', image data is expected in reversed (col, row) order.\n                                 # The default is \'col-major\' for backward compatibility, but this may\n                                 # change in the future.\n} \n\n\ndef setConfigOption(opt, value):\n    global CONFIG_OPTIONS\n    if opt not in CONFIG_OPTIONS:\n        raise KeyError(\'Unknown configuration option ""%s""\' % opt)\n    if opt == \'imageAxisOrder\' and value not in (\'row-major\', \'col-major\'):\n        raise ValueError(\'imageAxisOrder must be either ""row-major"" or ""col-major""\')\n    CONFIG_OPTIONS[opt] = value\n\ndef setConfigOptions(**opts):\n    """"""Set global configuration options. \n    \n    Each keyword argument sets one global option. \n    """"""\n    for k,v in opts.items():\n        setConfigOption(k, v)\n\ndef getConfigOption(opt):\n    """"""Return the value of a single global configuration option.\n    """"""\n    return CONFIG_OPTIONS[opt]\n\n\ndef systemInfo():\n    print(""sys.platform: %s"" % sys.platform)\n    print(""sys.version: %s"" % sys.version)\n    from .Qt import VERSION_INFO\n    print(""qt bindings: %s"" % VERSION_INFO)\n    \n    global __version__\n    rev = None\n    if __version__ is None:  ## this code was probably checked out from bzr; look up the last-revision file\n        lastRevFile = os.path.join(os.path.dirname(__file__), \'..\', \'.bzr\', \'branch\', \'last-revision\')\n        if os.path.exists(lastRevFile):\n            rev = open(lastRevFile, \'r\').read().strip()\n    \n    print(""pyqtgraph: %s; %s"" % (__version__, rev))\n    print(""config:"")\n    import pprint\n    pprint.pprint(CONFIG_OPTIONS)\n\n## Rename orphaned .pyc files. This is *probably* safe :)\n## We only do this if __version__ is None, indicating the code was probably pulled\n## from the repository. \ndef renamePyc(startDir):\n    ### Used to rename orphaned .pyc files\n    ### When a python file changes its location in the repository, usually the .pyc file\n    ### is left behind, possibly causing mysterious and difficult to track bugs. \n\n    ### Note that this is no longer necessary for python 3.2; from PEP 3147:\n    ### ""If the py source file is missing, the pyc file inside __pycache__ will be ignored. \n    ### This eliminates the problem of accidental stale pyc file imports.""\n    \n    printed = False\n    startDir = os.path.abspath(startDir)\n    for path, dirs, files in os.walk(startDir):\n        if \'__pycache__\' in path:\n            continue\n        for f in files:\n            fileName = os.path.join(path, f)\n            base, ext = os.path.splitext(fileName)\n            py = base + "".py""\n            if ext == \'.pyc\' and not os.path.isfile(py):\n                if not printed:\n                    print(""NOTE: Renaming orphaned .pyc files:"")\n                    printed = True\n                n = 1\n                while True:\n                    name2 = fileName + "".renamed%d"" % n\n                    if not os.path.exists(name2):\n                        break\n                    n += 1\n                print(""  "" + fileName + ""  ==>"")\n                print(""  "" + name2)\n                os.rename(fileName, name2)\n                \npath = os.path.split(__file__)[0]\nif __version__ is None and not hasattr(sys, \'frozen\') and sys.version_info[0] == 2: ## If we are frozen, there\'s a good chance we don\'t have the original .py files anymore.\n    renamePyc(path)\n\n\n## Import almost everything to make it available from a single namespace\n## don\'t import the more complex systems--canvas, parametertree, flowchart, dockarea\n## these must be imported separately.\n#from . import frozenSupport\n#def importModules(path, globals, locals, excludes=()):\n    #""""""Import all modules residing within *path*, return a dict of name: module pairs.\n    \n    #Note that *path* MUST be relative to the module doing the import.    \n    #""""""\n    #d = os.path.join(os.path.split(globals[\'__file__\'])[0], path)\n    #files = set()\n    #for f in frozenSupport.listdir(d):\n        #if frozenSupport.isdir(os.path.join(d, f)) and f not in [\'__pycache__\', \'tests\']:\n            #files.add(f)\n        #elif f[-3:] == \'.py\' and f != \'__init__.py\':\n            #files.add(f[:-3])\n        #elif f[-4:] == \'.pyc\' and f != \'__init__.pyc\':\n            #files.add(f[:-4])\n        \n    #mods = {}\n    #path = path.replace(os.sep, \'.\')\n    #for modName in files:\n        #if modName in excludes:\n            #continue\n        #try:\n            #if len(path) > 0:\n                #modName = path + \'.\' + modName\n            #print( ""from .%s import * "" % modName)\n            #mod = __import__(modName, globals, locals, [\'*\'], 1)\n            #mods[modName] = mod\n        #except:\n            #import traceback\n            #traceback.print_stack()\n            #sys.excepthook(*sys.exc_info())\n            #print(""[Error importing module: %s]"" % modName)\n            \n    #return mods\n\n#def importAll(path, globals, locals, excludes=()):\n    #""""""Given a list of modules, import all names from each module into the global namespace.""""""\n    #mods = importModules(path, globals, locals, excludes)\n    #for mod in mods.values():\n        #if hasattr(mod, \'__all__\'):\n            #names = mod.__all__\n        #else:\n            #names = [n for n in dir(mod) if n[0] != \'_\']\n        #for k in names:\n            #if hasattr(mod, k):\n                #globals[k] = getattr(mod, k)\n\n# Dynamic imports are disabled. This causes too many problems.\n#importAll(\'graphicsItems\', globals(), locals())\n#importAll(\'widgets\', globals(), locals(),\n          #excludes=[\'MatplotlibWidget\', \'RawImageWidget\', \'RemoteGraphicsView\'])\n\nfrom .graphicsItems.VTickGroup import * \nfrom .graphicsItems.GraphicsWidget import * \nfrom .graphicsItems.ScaleBar import * \nfrom .graphicsItems.PlotDataItem import * \nfrom .graphicsItems.GraphItem import * \nfrom .graphicsItems.TextItem import * \nfrom .graphicsItems.GraphicsLayout import * \nfrom .graphicsItems.UIGraphicsItem import * \nfrom .graphicsItems.GraphicsObject import * \nfrom .graphicsItems.PlotItem import * \nfrom .graphicsItems.ROI import * \nfrom .graphicsItems.InfiniteLine import * \nfrom .graphicsItems.HistogramLUTItem import * \nfrom .graphicsItems.GridItem import * \nfrom .graphicsItems.GradientLegend import * \nfrom .graphicsItems.GraphicsItem import * \nfrom .graphicsItems.BarGraphItem import * \nfrom .graphicsItems.ViewBox import * \nfrom .graphicsItems.ArrowItem import * \nfrom .graphicsItems.ImageItem import * \nfrom .graphicsItems.AxisItem import * \nfrom .graphicsItems.LabelItem import * \nfrom .graphicsItems.CurvePoint import * \nfrom .graphicsItems.GraphicsWidgetAnchor import * \nfrom .graphicsItems.PlotCurveItem import * \nfrom .graphicsItems.ButtonItem import * \nfrom .graphicsItems.GradientEditorItem import * \nfrom .graphicsItems.MultiPlotItem import * \nfrom .graphicsItems.ErrorBarItem import * \nfrom .graphicsItems.IsocurveItem import * \nfrom .graphicsItems.LinearRegionItem import * \nfrom .graphicsItems.FillBetweenItem import * \nfrom .graphicsItems.LegendItem import * \nfrom .graphicsItems.ScatterPlotItem import * \nfrom .graphicsItems.ItemGroup import * \n\nfrom .widgets.MultiPlotWidget import * \nfrom .widgets.ScatterPlotWidget import * \nfrom .widgets.ColorMapWidget import * \nfrom .widgets.FileDialog import * \nfrom .widgets.ValueLabel import * \nfrom .widgets.HistogramLUTWidget import * \nfrom .widgets.CheckTable import * \nfrom .widgets.BusyCursor import * \nfrom .widgets.PlotWidget import * \nfrom .widgets.ComboBox import * \nfrom .widgets.GradientWidget import * \nfrom .widgets.DataFilterWidget import * \nfrom .widgets.SpinBox import * \nfrom .widgets.JoystickButton import * \nfrom .widgets.GraphicsLayoutWidget import * \nfrom .widgets.TreeWidget import * \nfrom .widgets.PathButton import * \nfrom .widgets.VerticalLabel import * \nfrom .widgets.FeedbackButton import * \nfrom .widgets.ColorButton import * \nfrom .widgets.DataTreeWidget import * \nfrom .widgets.DiffTreeWidget import * \nfrom .widgets.GraphicsView import * \nfrom .widgets.LayoutWidget import * \nfrom .widgets.TableWidget import * \nfrom .widgets.ProgressDialog import *\nfrom .widgets.GroupBox import GroupBox\n\nfrom .imageview import *\nfrom .WidgetGroup import *\nfrom .Point import Point\nfrom .Vector import Vector\nfrom .SRTTransform import SRTTransform\nfrom .Transform3D import Transform3D\nfrom .SRTTransform3D import SRTTransform3D\nfrom .functions import *\nfrom .graphicsWindows import *\nfrom .SignalProxy import *\nfrom .colormap import *\nfrom .ptime import time\nfrom .Qt import isQObjectAlive\n\n\n##############################################################\n## PyQt and PySide both are prone to crashing on exit. \n## There are two general approaches to dealing with this:\n##  1. Install atexit handlers that assist in tearing down to avoid crashes.\n##     This helps, but is never perfect.\n##  2. Terminate the process before python starts tearing down\n##     This is potentially dangerous\n\n## Attempts to work around exit crashes:\nimport atexit\n_cleanupCalled = False\ndef cleanup():\n    global _cleanupCalled\n    if _cleanupCalled:\n        return\n    \n    if not getConfigOption(\'exitCleanup\'):\n        return\n    \n    ViewBox.quit()  ## tell ViewBox that it doesn\'t need to deregister views anymore.\n    \n    ## Workaround for Qt exit crash:\n    ## ALL QGraphicsItems must have a scene before they are deleted.\n    ## This is potentially very expensive, but preferred over crashing.\n    ## Note: this appears to be fixed in PySide as of 2012.12, but it should be left in for a while longer..\n    app = QtGui.QApplication.instance()\n    if app is None or not isinstance(app, QtGui.QApplication):\n        # app was never constructed is already deleted or is an\n        # QCoreApplication/QGuiApplication and not a full QApplication\n        return\n    import gc\n    s = QtGui.QGraphicsScene()\n    for o in gc.get_objects():\n        try:\n            if isinstance(o, QtGui.QGraphicsItem) and isQObjectAlive(o) and o.scene() is None:\n                if getConfigOption(\'crashWarning\'):\n                    sys.stderr.write(\'Error: graphics item without scene. \'\n                        \'Make sure ViewBox.close() and GraphicsView.close() \'\n                        \'are properly called before app shutdown (%s)\\n\' % (o,))\n                \n                s.addItem(o)\n        except (RuntimeError, ReferenceError):  ## occurs if a python wrapper no longer has its underlying C++ object\n            continue\n    _cleanupCalled = True\n\natexit.register(cleanup)\n\n# Call cleanup when QApplication quits. This is necessary because sometimes\n# the QApplication will quit before the atexit callbacks are invoked.\n# Note: cannot connect this function until QApplication has been created, so\n# instead we have GraphicsView.__init__ call this for us.\n_cleanupConnected = False\ndef _connectCleanup():\n    global _cleanupConnected\n    if _cleanupConnected:\n        return\n    QtGui.QApplication.instance().aboutToQuit.connect(cleanup)\n    _cleanupConnected = True\n\n\n## Optional function for exiting immediately (with some manual teardown)\ndef exit():\n    """"""\n    Causes python to exit without garbage-collecting any objects, and thus avoids\n    calling object destructor methods. This is a sledgehammer workaround for \n    a variety of bugs in PyQt and Pyside that cause crashes on exit.\n    \n    This function does the following in an attempt to \'safely\' terminate\n    the process:\n    \n    * Invoke atexit callbacks\n    * Close all open file handles\n    * os._exit()\n    \n    Note: there is some potential for causing damage with this function if you\n    are using objects that _require_ their destructors to be called (for example,\n    to properly terminate log files, disconnect from devices, etc). Situations\n    like this are probably quite rare, but use at your own risk.\n    """"""\n    \n    ## first disable our own cleanup function; won\'t be needing it.\n    setConfigOptions(exitCleanup=False)\n    \n    ## invoke atexit callbacks\n    atexit._run_exitfuncs()\n    \n    ## close file handles\n    if sys.platform == \'darwin\':\n        for fd in range(3, 4096):\n            if fd not in [7]:  # trying to close 7 produces an illegal instruction on the Mac.\n                os.close(fd)\n    else:\n        os.closerange(3, 4096) ## just guessing on the maximum descriptor count..\n\n    os._exit(0)\n    \n\n\n## Convenience functions for command-line use\n\nplots = []\nimages = []\nQAPP = None\n\ndef plot(*args, **kargs):\n    """"""\n    Create and return a :class:`PlotWindow <pyqtgraph.PlotWindow>` \n    (this is just a window with :class:`PlotWidget <pyqtgraph.PlotWidget>` inside), plot data in it.\n    Accepts a *title* argument to set the title of the window.\n    All other arguments are used to plot data. (see :func:`PlotItem.plot() <pyqtgraph.PlotItem.plot>`)\n    """"""\n    mkQApp()\n    #if \'title\' in kargs:\n        #w = PlotWindow(title=kargs[\'title\'])\n        #del kargs[\'title\']\n    #else:\n        #w = PlotWindow()\n    #if len(args)+len(kargs) > 0:\n        #w.plot(*args, **kargs)\n        \n    pwArgList = [\'title\', \'labels\', \'name\', \'left\', \'right\', \'top\', \'bottom\', \'background\']\n    pwArgs = {}\n    dataArgs = {}\n    for k in kargs:\n        if k in pwArgList:\n            pwArgs[k] = kargs[k]\n        else:\n            dataArgs[k] = kargs[k]\n        \n    w = PlotWindow(**pwArgs)\n    if len(args) > 0 or len(dataArgs) > 0:\n        w.plot(*args, **dataArgs)\n    plots.append(w)\n    w.show()\n    return w\n    \ndef image(*args, **kargs):\n    """"""\n    Create and return an :class:`ImageWindow <pyqtgraph.ImageWindow>` \n    (this is just a window with :class:`ImageView <pyqtgraph.ImageView>` widget inside), show image data inside.\n    Will show 2D or 3D image data.\n    Accepts a *title* argument to set the title of the window.\n    All other arguments are used to show data. (see :func:`ImageView.setImage() <pyqtgraph.ImageView.setImage>`)\n    """"""\n    mkQApp()\n    w = ImageWindow(*args, **kargs)\n    images.append(w)\n    w.show()\n    return w\nshow = image  ## for backward compatibility\n\ndef dbg(*args, **kwds):\n    """"""\n    Create a console window and begin watching for exceptions.\n    \n    All arguments are passed to :func:`ConsoleWidget.__init__() <pyqtgraph.console.ConsoleWidget.__init__>`.\n    """"""\n    mkQApp()\n    from . import console\n    c = console.ConsoleWidget(*args, **kwds)\n    c.catchAllExceptions()\n    c.show()\n    global consoles\n    try:\n        consoles.append(c)\n    except NameError:\n        consoles = [c]\n    return c\n\n\ndef stack(*args, **kwds):\n    """"""\n    Create a console window and show the current stack trace.\n    \n    All arguments are passed to :func:`ConsoleWidget.__init__() <pyqtgraph.console.ConsoleWidget.__init__>`.\n    """"""\n    mkQApp()\n    from . import console\n    c = console.ConsoleWidget(*args, **kwds)\n    c.setStack()\n    c.show()\n    global consoles\n    try:\n        consoles.append(c)\n    except NameError:\n        consoles = [c]\n    return c\n'"
src/third_party/pyqtgraph/colormap.py,19,"b'import numpy as np\nfrom .Qt import QtGui, QtCore\nfrom .python2_3 import basestring\n\n\nclass ColorMap(object):\n    """"""\n    A ColorMap defines a relationship between a scalar value and a range of colors. \n    ColorMaps are commonly used for false-coloring monochromatic images, coloring \n    scatter-plot points, and coloring surface plots by height. \n    \n    Each color map is defined by a set of colors, each corresponding to a\n    particular scalar value. For example:\n    \n        | 0.0  -> black\n        | 0.2  -> red\n        | 0.6  -> yellow\n        | 1.0  -> white\n        \n    The colors for intermediate values are determined by interpolating between \n    the two nearest colors in either RGB or HSV color space.\n    \n    To provide user-defined color mappings, see :class:`GradientWidget <pyqtgraph.GradientWidget>`.\n    """"""\n    \n    \n    ## color interpolation modes\n    RGB = 1\n    HSV_POS = 2\n    HSV_NEG = 3\n    \n    ## boundary modes\n    CLIP = 1\n    REPEAT = 2\n    MIRROR = 3\n    \n    ## return types\n    BYTE = 1\n    FLOAT = 2\n    QCOLOR = 3\n    \n    enumMap = {\n        \'rgb\': RGB,\n        \'hsv+\': HSV_POS,\n        \'hsv-\': HSV_NEG,\n        \'clip\': CLIP,\n        \'repeat\': REPEAT,\n        \'mirror\': MIRROR,\n        \'byte\': BYTE,\n        \'float\': FLOAT,\n        \'qcolor\': QCOLOR,\n    }\n    \n    def __init__(self, pos, color, mode=None):\n        """"""\n        ===============     ==============================================================\n        **Arguments:**\n        pos                 Array of positions where each color is defined\n        color               Array of RGBA colors.\n                            Integer data types are interpreted as 0-255; float data types\n                            are interpreted as 0.0-1.0\n        mode                Array of color modes (ColorMap.RGB, HSV_POS, or HSV_NEG)\n                            indicating the color space that should be used when\n                            interpolating between stops. Note that the last mode value is\n                            ignored. By default, the mode is entirely RGB.\n        ===============     ==============================================================\n        """"""\n        self.pos = np.array(pos)\n        order = np.argsort(self.pos)\n        self.pos = self.pos[order]\n        self.color = np.array(color)[order]\n        if mode is None:\n            mode = np.ones(len(pos))\n        self.mode = mode\n        self.stopsCache = {}\n        \n    def map(self, data, mode=\'byte\'):\n        """"""\n        Return an array of colors corresponding to the values in *data*. \n        Data must be either a scalar position or an array (any shape) of positions.\n        \n        The *mode* argument determines the type of data returned:\n        \n        =========== ===============================================================\n        byte        (default) Values are returned as 0-255 unsigned bytes.\n        float       Values are returned as 0.0-1.0 floats. \n        qcolor      Values are returned as an array of QColor objects.\n        =========== ===============================================================\n        """"""\n        if isinstance(mode, basestring):\n            mode = self.enumMap[mode.lower()]\n            \n        if mode == self.QCOLOR:\n            pos, color = self.getStops(self.BYTE)\n        else:\n            pos, color = self.getStops(mode)\n            \n        # don\'t need this--np.interp takes care of it.\n        #data = np.clip(data, pos.min(), pos.max())\n            \n        # Interpolate\n        # TODO: is griddata faster?\n        #          interp = scipy.interpolate.griddata(pos, color, data)\n        if np.isscalar(data):\n            interp = np.empty((color.shape[1],), dtype=color.dtype)\n        else:\n            if not isinstance(data, np.ndarray):\n                data = np.array(data)\n            interp = np.empty(data.shape + (color.shape[1],), dtype=color.dtype)\n        for i in range(color.shape[1]):\n            interp[...,i] = np.interp(data, pos, color[:,i])\n\n        # Convert to QColor if requested\n        if mode == self.QCOLOR:\n            if np.isscalar(data):\n                return QtGui.QColor(*interp)\n            else:\n                return [QtGui.QColor(*x) for x in interp]\n        else:\n            return interp\n        \n    def mapToQColor(self, data):\n        """"""Convenience function; see :func:`map() <pyqtgraph.ColorMap.map>`.""""""\n        return self.map(data, mode=self.QCOLOR)\n\n    def mapToByte(self, data):\n        """"""Convenience function; see :func:`map() <pyqtgraph.ColorMap.map>`.""""""\n        return self.map(data, mode=self.BYTE)\n\n    def mapToFloat(self, data):\n        """"""Convenience function; see :func:`map() <pyqtgraph.ColorMap.map>`.""""""\n        return self.map(data, mode=self.FLOAT)\n    \n    def getGradient(self, p1=None, p2=None):\n        """"""Return a QLinearGradient object spanning from QPoints p1 to p2.""""""\n        if p1 == None:\n            p1 = QtCore.QPointF(0,0)\n        if p2 == None:\n            p2 = QtCore.QPointF(self.pos.max()-self.pos.min(),0)\n        g = QtGui.QLinearGradient(p1, p2)\n        \n        pos, color = self.getStops(mode=self.BYTE)\n        color = [QtGui.QColor(*x) for x in color]\n        g.setStops(zip(pos, color))\n        \n        #if self.colorMode == \'rgb\':\n            #ticks = self.listTicks()\n            #g.setStops([(x, QtGui.QColor(t.color)) for t,x in ticks])\n        #elif self.colorMode == \'hsv\':  ## HSV mode is approximated for display by interpolating 10 points between each stop\n            #ticks = self.listTicks()\n            #stops = []\n            #stops.append((ticks[0][1], ticks[0][0].color))\n            #for i in range(1,len(ticks)):\n                #x1 = ticks[i-1][1]\n                #x2 = ticks[i][1]\n                #dx = (x2-x1) / 10.\n                #for j in range(1,10):\n                    #x = x1 + dx*j\n                    #stops.append((x, self.getColor(x)))\n                #stops.append((x2, self.getColor(x2)))\n            #g.setStops(stops)\n        return g\n    \n    def getColors(self, mode=None):\n        """"""Return list of all color stops converted to the specified mode.\n        If mode is None, then no conversion is done.""""""\n        if isinstance(mode, basestring):\n            mode = self.enumMap[mode.lower()]\n        \n        color = self.color\n        if mode in [self.BYTE, self.QCOLOR] and color.dtype.kind == \'f\':\n            color = (color * 255).astype(np.ubyte)\n        elif mode == self.FLOAT and color.dtype.kind != \'f\':\n            color = color.astype(float) / 255.\n            \n        if mode == self.QCOLOR:\n            color = [QtGui.QColor(*x) for x in color]\n            \n        return color\n        \n    def getStops(self, mode):\n        ## Get fully-expanded set of RGBA stops in either float or byte mode.\n        if mode not in self.stopsCache:\n            color = self.color\n            if mode == self.BYTE and color.dtype.kind == \'f\':\n                color = (color * 255).astype(np.ubyte)\n            elif mode == self.FLOAT and color.dtype.kind != \'f\':\n                color = color.astype(float) / 255.\n        \n            ## to support HSV mode, we need to do a little more work..\n            #stops = []\n            #for i in range(len(self.pos)):\n                #pos = self.pos[i]\n                #color = color[i]\n                \n                #imode = self.mode[i]\n                #if imode == self.RGB:\n                    #stops.append((x,color)) \n                #else:\n                    #ns = \n            self.stopsCache[mode] = (self.pos, color)\n        return self.stopsCache[mode]\n        \n    def getLookupTable(self, start=0.0, stop=1.0, nPts=512, alpha=None, mode=\'byte\'):\n        """"""\n        Return an RGB(A) lookup table (ndarray). \n        \n        ===============   =============================================================================\n        **Arguments:**\n        start             The starting value in the lookup table (default=0.0)\n        stop              The final value in the lookup table (default=1.0)\n        nPts              The number of points in the returned lookup table.\n        alpha             True, False, or None - Specifies whether or not alpha values are included\n                          in the table. If alpha is None, it will be automatically determined.\n        mode              Determines return type: \'byte\' (0-255), \'float\' (0.0-1.0), or \'qcolor\'.\n                          See :func:`map() <pyqtgraph.ColorMap.map>`.\n        ===============   =============================================================================\n        """"""\n        if isinstance(mode, basestring):\n            mode = self.enumMap[mode.lower()]\n        \n        if alpha is None:\n            alpha = self.usesAlpha()\n            \n        x = np.linspace(start, stop, nPts)\n        table = self.map(x, mode)\n        \n        if not alpha:\n            return table[:,:3]\n        else:\n            return table\n    \n    def usesAlpha(self):\n        """"""Return True if any stops have an alpha < 255""""""\n        max = 1.0 if self.color.dtype.kind == \'f\' else 255\n        return np.any(self.color[:,3] != max)\n            \n    def isMapTrivial(self):\n        """"""\n        Return True if the gradient has exactly two stops in it: black at 0.0 and white at 1.0.\n        """"""\n        if len(self.pos) != 2:\n            return False\n        if self.pos[0] != 0.0 or self.pos[1] != 1.0:\n            return False\n        if self.color.dtype.kind == \'f\':\n            return np.all(self.color == np.array([[0.,0.,0.,1.], [1.,1.,1.,1.]]))\n        else:\n            return np.all(self.color == np.array([[0,0,0,255], [255,255,255,255]]))\n\n    def __repr__(self):\n        pos = repr(self.pos).replace(\'\\n\', \'\')\n        color = repr(self.color).replace(\'\\n\', \'\')\n        return ""ColorMap(%s, %s)"" % (pos, color)\n'"
src/third_party/pyqtgraph/configfile.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nconfigfile.py - Human-readable text configuration file library \nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n\nUsed for reading and writing dictionary objects to a python-like configuration\nfile format. Data structures may be nested and contain any data type as long\nas it can be converted to/from a string using repr and eval.\n""""""\n\nimport re, os, sys, datetime\nimport numpy\nfrom .pgcollections import OrderedDict\nfrom . import units\nfrom .python2_3 import asUnicode, basestring\nfrom .Qt import QtCore\nfrom .Point import Point\nfrom .colormap import ColorMap\nGLOBAL_PATH = None # so not thread safe.\n\n\nclass ParseError(Exception):\n    def __init__(self, message, lineNum, line, fileName=None):\n        self.lineNum = lineNum\n        self.line = line\n        #self.message = message\n        self.fileName = fileName\n        Exception.__init__(self, message)\n        \n    def __str__(self):\n        if self.fileName is None:\n            msg = ""Error parsing string at line %d:\\n"" % self.lineNum\n        else:\n            msg = ""Error parsing config file \'%s\' at line %d:\\n"" % (self.fileName, self.lineNum)\n        msg += ""%s\\n%s"" % (self.line, self.message)\n        return msg\n        #raise Exception()\n        \n\ndef writeConfigFile(data, fname):\n    s = genString(data)\n    fd = open(fname, \'w\')\n    fd.write(s)\n    fd.close()\n    \ndef readConfigFile(fname):\n    #cwd = os.getcwd()\n    global GLOBAL_PATH\n    if GLOBAL_PATH is not None:\n        fname2 = os.path.join(GLOBAL_PATH, fname)\n        if os.path.exists(fname2):\n            fname = fname2\n\n    GLOBAL_PATH = os.path.dirname(os.path.abspath(fname))\n        \n    try:\n        #os.chdir(newDir)  ## bad.\n        fd = open(fname)\n        s = asUnicode(fd.read())\n        fd.close()\n        s = s.replace(""\\r\\n"", ""\\n"")\n        s = s.replace(""\\r"", ""\\n"")\n        data = parseString(s)[1]\n    except ParseError:\n        sys.exc_info()[1].fileName = fname\n        raise\n    except:\n        print(""Error while reading config file %s:""% fname)\n        raise\n    #finally:\n        #os.chdir(cwd)\n    return data\n\ndef appendConfigFile(data, fname):\n    s = genString(data)\n    fd = open(fname, \'a\')\n    fd.write(s)\n    fd.close()\n\n\ndef genString(data, indent=\'\'):\n    s = \'\'\n    for k in data:\n        sk = str(k)\n        if len(sk) == 0:\n            print(data)\n            raise Exception(\'blank dict keys not allowed (see data above)\')\n        if sk[0] == \' \' or \':\' in sk:\n            print(data)\n            raise Exception(\'dict keys must not contain "":"" or start with spaces [offending key is ""%s""]\' % sk)\n        if isinstance(data[k], dict):\n            s += indent + sk + \':\\n\'\n            s += genString(data[k], indent + \'    \')\n        else:\n            s += indent + sk + \': \' + repr(data[k]) + \'\\n\'\n    return s\n    \ndef parseString(lines, start=0):\n    \n    data = OrderedDict()\n    if isinstance(lines, basestring):\n        lines = lines.split(\'\\n\')\n        lines = [l for l in lines if re.search(r\'\\S\', l) and not re.match(r\'\\s*#\', l)]  ## remove empty lines\n        \n    indent = measureIndent(lines[start])\n    ln = start - 1\n    \n    try:\n        while True:\n            ln += 1\n            #print ln\n            if ln >= len(lines):\n                break\n            \n            l = lines[ln]\n            \n            ## Skip blank lines or lines starting with #\n            if re.match(r\'\\s*#\', l) or not re.search(r\'\\S\', l):\n                continue\n            \n            ## Measure line indentation, make sure it is correct for this level\n            lineInd = measureIndent(l)\n            if lineInd < indent:\n                ln -= 1\n                break\n            if lineInd > indent:\n                #print lineInd, indent\n                raise ParseError(\'Indentation is incorrect. Expected %d, got %d\' % (indent, lineInd), ln+1, l)\n            \n            \n            if \':\' not in l:\n                raise ParseError(\'Missing colon\', ln+1, l)\n            \n            (k, p, v) = l.partition(\':\')\n            k = k.strip()\n            v = v.strip()\n            \n            ## set up local variables to use for eval\n            local = units.allUnits.copy()\n            local[\'OrderedDict\'] = OrderedDict\n            local[\'readConfigFile\'] = readConfigFile\n            local[\'Point\'] = Point\n            local[\'QtCore\'] = QtCore\n            local[\'ColorMap\'] = ColorMap\n            local[\'datetime\'] = datetime\n            # Needed for reconstructing numpy arrays\n            local[\'array\'] = numpy.array\n            for dtype in [\'int8\', \'uint8\', \n                          \'int16\', \'uint16\', \'float16\',\n                          \'int32\', \'uint32\', \'float32\',\n                          \'int64\', \'uint64\', \'float64\']:\n                local[dtype] = getattr(numpy, dtype)\n                \n            if len(k) < 1:\n                raise ParseError(\'Missing name preceding colon\', ln+1, l)\n            if k[0] == \'(\' and k[-1] == \')\':  ## If the key looks like a tuple, try evaluating it.\n                try:\n                    k1 = eval(k, local)\n                    if type(k1) is tuple:\n                        k = k1\n                except:\n                    pass\n            if re.search(r\'\\S\', v) and v[0] != \'#\':  ## eval the value\n                try:\n                    val = eval(v, local)\n                except:\n                    ex = sys.exc_info()[1]\n                    raise ParseError(""Error evaluating expression \'%s\': [%s: %s]"" % (v, ex.__class__.__name__, str(ex)), (ln+1), l)\n            else:\n                if ln+1 >= len(lines) or measureIndent(lines[ln+1]) <= indent:\n                    #print ""blank dict""\n                    val = {}\n                else:\n                    #print ""Going deeper.."", ln+1\n                    (ln, val) = parseString(lines, start=ln+1)\n            data[k] = val\n        #print k, repr(val)\n    except ParseError:\n        raise\n    except:\n        ex = sys.exc_info()[1]\n        raise ParseError(""%s: %s"" % (ex.__class__.__name__, str(ex)), ln+1, l)\n    #print ""Returning shallower.."", ln+1\n    return (ln, data)\n    \ndef measureIndent(s):\n    n = 0\n    while n < len(s) and s[n] == \' \':\n        n += 1\n    return n\n    \n    \n    \nif __name__ == \'__main__\':\n    import tempfile\n    fn = tempfile.mktemp()\n    tf = open(fn, \'w\')\n    cf = """"""\nkey: \'value\'\nkey2:              ##comment\n                   ##comment\n    key21: \'value\' ## comment\n                   ##comment\n    key22: [1,2,3]\n    key23: 234  #comment\n    """"""\n    tf.write(cf)\n    tf.close()\n    print(""=== Test:==="")\n    num = 1\n    for line in cf.split(\'\\n\'):\n        print(""%02d   %s"" % (num, line))\n        num += 1\n    print(cf)\n    print(""============"")\n    data = readConfigFile(fn)\n    print(data)\n    os.remove(fn)\n'"
src/third_party/pyqtgraph/debug.py,0,"b'# -*- coding: utf-8 -*-\n""""""\ndebug.py - Functions to aid in debugging \nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n""""""\n\nfrom __future__ import print_function\n\nimport sys, traceback, time, gc, re, types, weakref, inspect, os, cProfile, threading\nfrom . import ptime\nfrom numpy import ndarray\nfrom .Qt import QtCore, QtGui\nfrom .util.mutex import Mutex\nfrom .util import cprint\n\n__ftraceDepth = 0\ndef ftrace(func):\n    """"""Decorator used for marking the beginning and end of function calls.\n    Automatically indents nested calls.\n    """"""\n    def w(*args, **kargs):\n        global __ftraceDepth\n        pfx = ""  "" * __ftraceDepth\n        print(pfx + func.__name__ + "" start"")\n        __ftraceDepth += 1\n        try:\n            rv = func(*args, **kargs)\n        finally:\n            __ftraceDepth -= 1\n        print(pfx + func.__name__ + "" done"")\n        return rv\n    return w\n\n\nclass Tracer(object):\n    """"""\n    Prints every function enter/exit. Useful for debugging crashes / lockups.\n    """"""\n    def __init__(self):\n        self.count = 0\n        self.stack = []\n\n    def trace(self, frame, event, arg):\n        self.count += 1\n        # If it has been a long time since we saw the top of the stack, \n        # print a reminder\n        if self.count % 1000 == 0:\n            print(""----- current stack: -----"")\n            for line in self.stack:\n                print(line)\n        if event == \'call\':\n            line = ""  "" * len(self.stack) + "">> "" + self.frameInfo(frame) \n            print(line)\n            self.stack.append(line)\n        elif event == \'return\':\n            self.stack.pop()\n            line = ""  "" * len(self.stack) + ""<< "" + self.frameInfo(frame) \n            print(line)\n            if len(self.stack) == 0:\n                self.count = 0\n\n        return self.trace\n\n    def stop(self):\n        sys.settrace(None)\n\n    def start(self):\n        sys.settrace(self.trace)\n\n    def frameInfo(self, fr):\n        filename = fr.f_code.co_filename\n        funcname = fr.f_code.co_name\n        lineno = fr.f_lineno\n        callfr = sys._getframe(3)\n        callline = ""%s %d"" % (callfr.f_code.co_name, callfr.f_lineno)\n        args, _, _, value_dict = inspect.getargvalues(fr)\n        if len(args) and args[0] == \'self\':\n            instance = value_dict.get(\'self\', None)\n            if instance is not None:\n                cls = getattr(instance, \'__class__\', None)\n                if cls is not None:\n                    funcname = cls.__name__ + ""."" + funcname\n        return ""%s: %s %s: %s"" % (callline, filename, lineno, funcname)\n\n\ndef warnOnException(func):\n    """"""Decorator that catches/ignores exceptions and prints a stack trace.""""""\n    def w(*args, **kwds):\n        try:\n            func(*args, **kwds)\n        except:\n            printExc(\'Ignored exception:\')\n    return w\n\n\ndef getExc(indent=4, prefix=\'|  \', skip=1):\n    lines = formatException(*sys.exc_info(), skip=skip)\n    lines2 = []\n    for l in lines:\n        lines2.extend(l.strip(\'\\n\').split(\'\\n\'))\n    lines3 = ["" ""*indent + prefix + l for l in lines2]\n    return \'\\n\'.join(lines3)\n\n\ndef printExc(msg=\'\', indent=4, prefix=\'|\'):\n    """"""Print an error message followed by an indented exception backtrace\n    (This function is intended to be called within except: blocks)""""""\n    exc = getExc(indent, prefix + \'  \', skip=2)\n    print(""[%s]  %s\\n"" % (time.strftime(""%H:%M:%S""), msg))\n    print("" ""*indent + prefix + \'=\'*30 + \'>>\')\n    print(exc)\n    print("" ""*indent + prefix + \'=\'*30 + \'<<\')\n\n    \ndef printTrace(msg=\'\', indent=4, prefix=\'|\'):\n    """"""Print an error message followed by an indented stack trace""""""\n    trace = backtrace(1)\n    #exc = getExc(indent, prefix + \'  \')\n    print(""[%s]  %s\\n"" % (time.strftime(""%H:%M:%S""), msg))\n    print("" ""*indent + prefix + \'=\'*30 + \'>>\')\n    for line in trace.split(\'\\n\'):\n        print("" ""*indent + prefix + "" "" + line)\n    print("" ""*indent + prefix + \'=\'*30 + \'<<\')\n    \n\ndef backtrace(skip=0):\n    return \'\'.join(traceback.format_stack()[:-(skip+1)])    \n\n\ndef formatException(exctype, value, tb, skip=0):\n    """"""Return a list of formatted exception strings.\n    \n    Similar to traceback.format_exception, but displays the entire stack trace\n    rather than just the portion downstream of the point where the exception is\n    caught. In particular, unhandled exceptions that occur during Qt signal\n    handling do not usually show the portion of the stack that emitted the\n    signal.\n    """"""\n    lines = traceback.format_exception(exctype, value, tb)\n    lines = [lines[0]] + traceback.format_stack()[:-(skip+1)] + [\'  --- exception caught here ---\\n\'] + lines[1:]\n    return lines\n\n\ndef printException(exctype, value, traceback):\n    """"""Print an exception with its full traceback.\n    \n    Set `sys.excepthook = printException` to ensure that exceptions caught\n    inside Qt signal handlers are printed with their full stack trace.\n    """"""\n    print(\'\'.join(formatException(exctype, value, traceback, skip=1)))\n\n    \ndef listObjs(regex=\'Q\', typ=None):\n    """"""List all objects managed by python gc with class name matching regex.\n    Finds \'Q...\' classes by default.""""""\n    if typ is not None:\n        return [x for x in gc.get_objects() if isinstance(x, typ)]\n    else:\n        return [x for x in gc.get_objects() if re.match(regex, type(x).__name__)]\n        \n\n    \ndef findRefPath(startObj, endObj, maxLen=8, restart=True, seen={}, path=None, ignore=None):\n    """"""Determine all paths of object references from startObj to endObj""""""\n    refs = []\n    if path is None:\n        path = [endObj]\n    if ignore is None:\n        ignore = {}\n    ignore[id(sys._getframe())] = None\n    ignore[id(path)] = None\n    ignore[id(seen)] = None\n    prefix = "" ""*(8-maxLen)\n    #print prefix + str(map(type, path))\n    prefix += "" ""\n    if restart:\n        #gc.collect()\n        seen.clear()\n    gc.collect()\n    newRefs = [r for r in gc.get_referrers(endObj) if id(r) not in ignore]\n    ignore[id(newRefs)] = None\n    #fo = allFrameObjs()\n    #newRefs = []\n    #for r in gc.get_referrers(endObj):\n        #try:\n            #if r not in fo:\n                #newRefs.append(r)\n        #except:\n            #newRefs.append(r)            \n        \n    for r in newRefs:\n        #print prefix+""->""+str(type(r))\n        if type(r).__name__ in [\'frame\', \'function\', \'listiterator\']:\n            #print prefix+""  FRAME""\n            continue\n        try:\n            if any([r is x for x in  path]):\n                #print prefix+""  LOOP"", objChainString([r]+path)\n                continue\n        except:\n            print(r)\n            print(path)\n            raise\n        if r is startObj:\n            refs.append([r])\n            print(refPathString([startObj]+path))\n            continue\n        if maxLen == 0:\n            #print prefix+""  END:"", objChainString([r]+path)\n            continue\n        ## See if we have already searched this node.\n        ## If not, recurse.\n        tree = None\n        try:\n            cache = seen[id(r)]\n            if cache[0] >= maxLen:\n                tree = cache[1]\n                for p in tree:\n                    print(refPathString(p+path))\n        except KeyError:\n            pass\n        \n        ignore[id(tree)] = None\n        if tree is None:\n            tree = findRefPath(startObj, r, maxLen-1, restart=False, path=[r]+path, ignore=ignore)\n            seen[id(r)] = [maxLen, tree]\n        ## integrate any returned results\n        if len(tree) == 0:\n            #print prefix+""  EMPTY TREE""\n            continue\n        else:\n            for p in tree:\n                refs.append(p+[r])\n        #seen[id(r)] = [maxLen, refs]\n    return refs\n\n\ndef objString(obj):\n    """"""Return a short but descriptive string for any object""""""\n    try:\n        if type(obj) in [int, float]:\n            return str(obj)\n        elif isinstance(obj, dict):\n            if len(obj) > 5:\n                return ""<dict {%s,...}>"" % ("","".join(list(obj.keys())[:5]))\n            else:\n                return ""<dict {%s}>"" % ("","".join(list(obj.keys())))\n        elif isinstance(obj, str):\n            if len(obj) > 50:\n                return \'""%s...""\' % obj[:50]\n            else:\n                return obj[:]\n        elif isinstance(obj, ndarray):\n            return ""<ndarray %s %s>"" % (str(obj.dtype), str(obj.shape))\n        elif hasattr(obj, \'__len__\'):\n            if len(obj) > 5:\n                return ""<%s [%s,...]>"" % (type(obj).__name__, "","".join([type(o).__name__ for o in obj[:5]]))\n            else:\n                return ""<%s [%s]>"" % (type(obj).__name__, "","".join([type(o).__name__ for o in obj]))\n        else:\n            return ""<%s %s>"" % (type(obj).__name__, obj.__class__.__name__)\n    except:\n        return str(type(obj))\n\ndef refPathString(chain):\n    """"""Given a list of adjacent objects in a reference path, print the \'natural\' path\n    names (ie, attribute names, keys, and indexes) that follow from one object to the next .""""""\n    s = objString(chain[0])\n    i = 0\n    while i < len(chain)-1:\n        #print "" -> "", i\n        i += 1\n        o1 = chain[i-1]\n        o2 = chain[i]\n        cont = False\n        if isinstance(o1, list) or isinstance(o1, tuple):\n            if any([o2 is x for x in o1]):\n                s += ""[%d]"" % o1.index(o2)\n                continue\n        #print ""  not list""\n        if isinstance(o2, dict) and hasattr(o1, \'__dict__\') and o2 == o1.__dict__:\n            i += 1\n            if i >= len(chain):\n                s += "".__dict__""\n                continue\n            o3 = chain[i]\n            for k in o2:\n                if o2[k] is o3:\n                    s += \'.%s\' % k\n                    cont = True\n                    continue\n        #print ""  not __dict__""\n        if isinstance(o1, dict):\n            try:\n                if o2 in o1:\n                    s += ""[key:%s]"" % objString(o2)\n                    continue\n            except TypeError:\n                pass\n            for k in o1:\n                if o1[k] is o2:\n                    s += ""[%s]"" % objString(k)\n                    cont = True\n                    continue\n        #print ""  not dict""\n        #for k in dir(o1):  ## Not safe to request attributes like this.\n            #if getattr(o1, k) is o2:\n                #s += "".%s"" % k\n                #cont = True\n                #continue\n        #print ""  not attr""\n        if cont:\n            continue\n        s += "" ? ""\n        sys.stdout.flush()\n    return s\n\n    \ndef objectSize(obj, ignore=None, verbose=False, depth=0, recursive=False):\n    """"""Guess how much memory an object is using""""""\n    ignoreTypes = [\'MethodType\', \'UnboundMethodType\', \'BuiltinMethodType\', \'FunctionType\', \'BuiltinFunctionType\']\n    ignoreTypes = [getattr(types, key) for key in ignoreTypes if hasattr(types, key)]\n    ignoreRegex = re.compile(\'(method-wrapper|Flag|ItemChange|Option|Mode)\')\n    \n    \n    if ignore is None:\n        ignore = {}\n        \n    indent = \'  \'*depth\n    \n    try:\n        hash(obj)\n        hsh = obj\n    except:\n        hsh = ""%s:%d"" % (str(type(obj)), id(obj))\n        \n    if hsh in ignore:\n        return 0\n    ignore[hsh] = 1\n    \n    try:\n        size = sys.getsizeof(obj)\n    except TypeError:\n        size = 0\n        \n    if isinstance(obj, ndarray):\n        try:\n            size += len(obj.data)\n        except:\n            pass\n            \n        \n    if recursive:\n        if type(obj) in [list, tuple]:\n            if verbose:\n                print(indent+""list:"")\n            for o in obj:\n                s = objectSize(o, ignore=ignore, verbose=verbose, depth=depth+1)\n                if verbose:\n                    print(indent+\'  +\', s)\n                size += s\n        elif isinstance(obj, dict):\n            if verbose:\n                print(indent+""list:"")\n            for k in obj:\n                s = objectSize(obj[k], ignore=ignore, verbose=verbose, depth=depth+1)\n                if verbose:\n                    print(indent+\'  +\', k, s)\n                size += s\n        #elif isinstance(obj, QtCore.QObject):\n            #try:\n                #childs = obj.children()\n                #if verbose:\n                    #print indent+""Qt children:""\n                #for ch in childs:\n                    #s = objectSize(obj, ignore=ignore, verbose=verbose, depth=depth+1)\n                    #size += s\n                    #if verbose:\n                        #print indent + \'  +\', ch.objectName(), s\n                    \n            #except:\n                #pass\n    #if isinstance(obj, types.InstanceType):\n        gc.collect()\n        if verbose:\n            print(indent+\'attrs:\')\n        for k in dir(obj):\n            if k in [\'__dict__\']:\n                continue\n            o = getattr(obj, k)\n            if type(o) in ignoreTypes:\n                continue\n            strtyp = str(type(o))\n            if ignoreRegex.search(strtyp):\n                continue\n            #if isinstance(o, types.ObjectType) and strtyp == ""<type \'method-wrapper\'>"":\n                #continue\n            \n            #if verbose:\n                #print indent, k, \'?\'\n            refs = [r for r in gc.get_referrers(o) if type(r) != types.FrameType]\n            if len(refs) == 1:\n                s = objectSize(o, ignore=ignore, verbose=verbose, depth=depth+1)\n                size += s\n                if verbose:\n                    print(indent + ""  +"", k, s)\n            #else:\n                #if verbose:\n                    #print indent + \'  -\', k, len(refs)\n    return size\n\nclass GarbageWatcher(object):\n    """"""\n    Convenient dictionary for holding weak references to objects.\n    Mainly used to check whether the objects have been collect yet or not.\n    \n    Example:\n        gw = GarbageWatcher()\n        gw[\'objName\'] = obj\n        gw[\'objName2\'] = obj2\n        gw.check()  \n        \n    \n    """"""\n    def __init__(self):\n        self.objs = weakref.WeakValueDictionary()\n        self.allNames = []\n        \n    def add(self, obj, name):\n        self.objs[name] = obj\n        self.allNames.append(name)\n        \n    def __setitem__(self, name, obj):\n        self.add(obj, name)\n        \n    def check(self):\n        """"""Print a list of all watched objects and whether they have been collected.""""""\n        gc.collect()\n        dead = self.allNames[:]\n        alive = []\n        for k in self.objs:\n            dead.remove(k)\n            alive.append(k)\n        print(""Deleted objects:"", dead)\n        print(""Live objects:"", alive)\n        \n    def __getitem__(self, item):\n        return self.objs[item]\n\n    \n\n\nclass Profiler(object):\n    """"""Simple profiler allowing measurement of multiple time intervals.\n\n    By default, profilers are disabled.  To enable profiling, set the\n    environment variable `PYQTGRAPHPROFILE` to a comma-separated list of\n    fully-qualified names of profiled functions.\n\n    Calling a profiler registers a message (defaulting to an increasing\n    counter) that contains the time elapsed since the last call.  When the\n    profiler is about to be garbage-collected, the messages are passed to the\n    outer profiler if one is running, or printed to stdout otherwise.\n\n    If `delayed` is set to False, messages are immediately printed instead.\n\n    Example:\n        def function(...):\n            profiler = Profiler()\n            ... do stuff ...\n            profiler(\'did stuff\')\n            ... do other stuff ...\n            profiler(\'did other stuff\')\n            # profiler is garbage-collected and flushed at function end\n\n    If this function is a method of class C, setting `PYQTGRAPHPROFILE` to\n    ""C.function"" (without the module name) will enable this profiler.\n\n    For regular functions, use the qualified name of the function, stripping\n    only the initial ""pyqtgraph."" prefix from the module.\n    """"""\n\n    _profilers = os.environ.get(""PYQTGRAPHPROFILE"", None)\n    _profilers = _profilers.split("","") if _profilers is not None else []\n    \n    _depth = 0\n    _msgs = []\n    disable = False  # set this flag to disable all or individual profilers at runtime\n    \n    class DisabledProfiler(object):\n        def __init__(self, *args, **kwds):\n            pass\n        def __call__(self, *args):\n            pass\n        def finish(self):\n            pass\n        def mark(self, msg=None):\n            pass\n    _disabledProfiler = DisabledProfiler()\n        \n    def __new__(cls, msg=None, disabled=\'env\', delayed=True):\n        """"""Optionally create a new profiler based on caller\'s qualname.\n        """"""\n        if disabled is True or (disabled == \'env\' and len(cls._profilers) == 0):\n            return cls._disabledProfiler\n                        \n        # determine the qualified name of the caller function\n        caller_frame = sys._getframe(1)\n        try:\n            caller_object_type = type(caller_frame.f_locals[""self""])\n        except KeyError: # we are in a regular function\n            qualifier = caller_frame.f_globals[""__name__""].split(""."", 1)[-1]\n        else: # we are in a method\n            qualifier = caller_object_type.__name__\n        func_qualname = qualifier + ""."" + caller_frame.f_code.co_name\n        if disabled == \'env\' and func_qualname not in cls._profilers: # don\'t do anything\n            return cls._disabledProfiler\n        # create an actual profiling object\n        cls._depth += 1\n        obj = super(Profiler, cls).__new__(cls)\n        obj._name = msg or func_qualname\n        obj._delayed = delayed\n        obj._markCount = 0\n        obj._finished = False\n        obj._firstTime = obj._lastTime = ptime.time()\n        obj._newMsg(""> Entering "" + obj._name)\n        return obj\n\n    def __call__(self, msg=None):\n        """"""Register or print a new message with timing information.\n        """"""\n        if self.disable:\n            return\n        if msg is None:\n            msg = str(self._markCount)\n        self._markCount += 1\n        newTime = ptime.time()\n        self._newMsg(""  %s: %0.4f ms"", \n                     msg, (newTime - self._lastTime) * 1000)\n        self._lastTime = newTime\n        \n    def mark(self, msg=None):\n        self(msg)\n\n    def _newMsg(self, msg, *args):\n        msg = ""  "" * (self._depth - 1) + msg\n        if self._delayed:\n            self._msgs.append((msg, args))\n        else:\n            self.flush()\n            print(msg % args)\n\n    def __del__(self):\n        self.finish()\n    \n    def finish(self, msg=None):\n        """"""Add a final message; flush the message list if no parent profiler.\n        """"""\n        if self._finished or self.disable:\n            return        \n        self._finished = True\n        if msg is not None:\n            self(msg)\n        self._newMsg(""< Exiting %s, total time: %0.4f ms"", \n                     self._name, (ptime.time() - self._firstTime) * 1000)\n        type(self)._depth -= 1\n        if self._depth < 1:\n            self.flush()\n        \n    def flush(self):\n        if self._msgs:\n            print(""\\n"".join([m[0]%m[1] for m in self._msgs]))\n            type(self)._msgs = []\n\n\ndef profile(code, name=\'profile_run\', sort=\'cumulative\', num=30):\n    """"""Common-use for cProfile""""""\n    cProfile.run(code, name)\n    stats = pstats.Stats(name)\n    stats.sort_stats(sort)\n    stats.print_stats(num)\n    return stats\n        \n        \n  \n#### Code for listing (nearly) all objects in the known universe\n#### http://utcc.utoronto.ca/~cks/space/blog/python/GetAllObjects\n# Recursively expand slist\'s objects\n# into olist, using seen to track\n# already processed objects.\ndef _getr(slist, olist, first=True):\n    i = 0 \n    for e in slist:\n        \n        oid = id(e)\n        typ = type(e)\n        if oid in olist or typ is int:    ## or e in olist:     ## since we\'re excluding all ints, there is no longer a need to check for olist keys\n            continue\n        olist[oid] = e\n        if first and (i%1000) == 0:\n            gc.collect()\n        tl = gc.get_referents(e)\n        if tl:\n            _getr(tl, olist, first=False)\n        i += 1        \n# The public function.\ndef get_all_objects():\n    """"""Return a list of all live Python objects (excluding int and long), not including the list itself.""""""\n    gc.collect()\n    gcl = gc.get_objects()\n    olist = {}\n    _getr(gcl, olist)\n    \n    del olist[id(olist)]\n    del olist[id(gcl)]\n    del olist[id(sys._getframe())]\n    return olist\n\n\ndef lookup(oid, objects=None):\n    """"""Return an object given its ID, if it exists.""""""\n    if objects is None:\n        objects = get_all_objects()\n    return objects[oid]\n        \n        \n                    \n        \nclass ObjTracker(object):\n    """"""\n    Tracks all objects under the sun, reporting the changes between snapshots: what objects are created, deleted, and persistent.\n    This class is very useful for tracking memory leaks. The class goes to great (but not heroic) lengths to avoid tracking \n    its own internal objects.\n    \n    Example:\n        ot = ObjTracker()   # takes snapshot of currently existing objects\n           ... do stuff ...\n        ot.diff()           # prints lists of objects created and deleted since ot was initialized\n           ... do stuff ...\n        ot.diff()           # prints lists of objects created and deleted since last call to ot.diff()\n                            # also prints list of items that were created since initialization AND have not been deleted yet\n                            #   (if done correctly, this list can tell you about objects that were leaked)\n           \n        arrays = ot.findPersistent(\'ndarray\')  ## returns all objects matching \'ndarray\' (string match, not instance checking)\n                                               ## that were considered persistent when the last diff() was run\n                                               \n        describeObj(arrays[0])    ## See if we can determine who has references to this array\n    """"""\n    \n    \n    allObjs = {} ## keep track of all objects created and stored within class instances\n    allObjs[id(allObjs)] = None\n    \n    def __init__(self):\n        self.startRefs = {}        ## list of objects that exist when the tracker is initialized {oid: weakref}\n                                   ##   (If it is not possible to weakref the object, then the value is None)\n        self.startCount = {}       \n        self.newRefs = {}          ## list of objects that have been created since initialization\n        self.persistentRefs = {}   ## list of objects considered \'persistent\' when the last diff() was called\n        self.objTypes = {}\n            \n        ObjTracker.allObjs[id(self)] = None\n        self.objs = [self.__dict__, self.startRefs, self.startCount, self.newRefs, self.persistentRefs, self.objTypes]\n        self.objs.append(self.objs)\n        for v in self.objs:\n            ObjTracker.allObjs[id(v)] = None\n            \n        self.start()\n\n    def findNew(self, regex):\n        """"""Return all objects matching regex that were considered \'new\' when the last diff() was run.""""""\n        return self.findTypes(self.newRefs, regex)\n    \n    def findPersistent(self, regex):\n        """"""Return all objects matching regex that were considered \'persistent\' when the last diff() was run.""""""\n        return self.findTypes(self.persistentRefs, regex)\n        \n    \n    def start(self):\n        """"""\n        Remember the current set of objects as the comparison for all future calls to diff()\n        Called automatically on init, but can be called manually as well.\n        """"""\n        refs, count, objs = self.collect()\n        for r in self.startRefs:\n            self.forgetRef(self.startRefs[r])\n        self.startRefs.clear()\n        self.startRefs.update(refs)\n        for r in refs:\n            self.rememberRef(r)\n        self.startCount.clear()\n        self.startCount.update(count)\n        #self.newRefs.clear()\n        #self.newRefs.update(refs)\n\n    def diff(self, **kargs):\n        """"""\n        Compute all differences between the current object set and the reference set.\n        Print a set of reports for created, deleted, and persistent objects\n        """"""\n        refs, count, objs = self.collect()   ## refs contains the list of ALL objects\n        \n        ## Which refs have disappeared since call to start()  (these are only displayed once, then forgotten.)\n        delRefs = {}\n        for i in list(self.startRefs.keys()):\n            if i not in refs:\n                delRefs[i] = self.startRefs[i]\n                del self.startRefs[i]\n                self.forgetRef(delRefs[i])\n        for i in list(self.newRefs.keys()):\n            if i not in refs:\n                delRefs[i] = self.newRefs[i]\n                del self.newRefs[i]\n                self.forgetRef(delRefs[i])\n        #print ""deleted:"", len(delRefs)\n                \n        ## Which refs have appeared since call to start() or diff()\n        persistentRefs = {}      ## created since start(), but before last diff()\n        createRefs = {}          ## created since last diff()\n        for o in refs:\n            if o not in self.startRefs:       \n                if o not in self.newRefs:     \n                    createRefs[o] = refs[o]          ## object has been created since last diff()\n                else:\n                    persistentRefs[o] = refs[o]      ## object has been created since start(), but before last diff() (persistent)\n        #print ""new:"", len(newRefs)\n                \n        ## self.newRefs holds the entire set of objects created since start()\n        for r in self.newRefs:\n            self.forgetRef(self.newRefs[r])\n        self.newRefs.clear()\n        self.newRefs.update(persistentRefs)\n        self.newRefs.update(createRefs)\n        for r in self.newRefs:\n            self.rememberRef(self.newRefs[r])\n        #print ""created:"", len(createRefs)\n        \n        ## self.persistentRefs holds all objects considered persistent.\n        self.persistentRefs.clear()\n        self.persistentRefs.update(persistentRefs)\n        \n                \n        print(""----------- Count changes since start: ----------"")\n        c1 = count.copy()\n        for k in self.startCount:\n            c1[k] = c1.get(k, 0) - self.startCount[k]\n        typs = list(c1.keys())\n        typs.sort(key=lambda a: c1[a])\n        for t in typs:\n            if c1[t] == 0:\n                continue\n            num = ""%d"" % c1[t]\n            print(""  "" + num + "" ""*(10-len(num)) + str(t))\n            \n        print(""-----------  %d Deleted since last diff: ------------"" % len(delRefs))\n        self.report(delRefs, objs, **kargs)\n        print(""-----------  %d Created since last diff: ------------"" % len(createRefs))\n        self.report(createRefs, objs, **kargs)\n        print(""-----------  %d Created since start (persistent): ------------"" % len(persistentRefs))\n        self.report(persistentRefs, objs, **kargs)\n        \n        \n    def __del__(self):\n        self.startRefs.clear()\n        self.startCount.clear()\n        self.newRefs.clear()\n        self.persistentRefs.clear()\n        \n        del ObjTracker.allObjs[id(self)]\n        for v in self.objs:\n            del ObjTracker.allObjs[id(v)]\n            \n    @classmethod\n    def isObjVar(cls, o):\n        return type(o) is cls or id(o) in cls.allObjs\n            \n    def collect(self):\n        print(""Collecting list of all objects..."")\n        gc.collect()\n        objs = get_all_objects()\n        frame = sys._getframe()\n        del objs[id(frame)]  ## ignore the current frame \n        del objs[id(frame.f_code)]\n        \n        ignoreTypes = [int]\n        refs = {}\n        count = {}\n        for k in objs:\n            o = objs[k]\n            typ = type(o)\n            oid = id(o)\n            if ObjTracker.isObjVar(o) or typ in ignoreTypes:\n                continue\n            \n            try:\n                ref = weakref.ref(obj)\n            except:\n                ref = None\n            refs[oid] = ref\n            typ = type(o)\n            typStr = typeStr(o)\n            self.objTypes[oid] = typStr\n            ObjTracker.allObjs[id(typStr)] = None\n            count[typ] = count.get(typ, 0) + 1\n            \n        print(""All objects: %d   Tracked objects: %d"" % (len(objs), len(refs)))\n        return refs, count, objs\n        \n    def forgetRef(self, ref):\n        if ref is not None:\n            del ObjTracker.allObjs[id(ref)]\n        \n    def rememberRef(self, ref):\n        ## Record the address of the weakref object so it is not included in future object counts.\n        if ref is not None:\n            ObjTracker.allObjs[id(ref)] = None\n            \n        \n    def lookup(self, oid, ref, objs=None):\n        if ref is None or ref() is None:\n            try:\n                obj = lookup(oid, objects=objs)\n            except:\n                obj = None\n        else:\n            obj = ref()\n        return obj\n                    \n                    \n    def report(self, refs, allobjs=None, showIDs=False):\n        if allobjs is None:\n            allobjs = get_all_objects()\n        \n        count = {}\n        rev = {}\n        for oid in refs:\n            obj = self.lookup(oid, refs[oid], allobjs)\n            if obj is None:\n                typ = ""[del] "" + self.objTypes[oid]\n            else:\n                typ = typeStr(obj)\n            if typ not in rev:\n                rev[typ] = []\n            rev[typ].append(oid)\n            c = count.get(typ, [0,0])\n            count[typ] =  [c[0]+1, c[1]+objectSize(obj)]\n        typs = list(count.keys())\n        typs.sort(key=lambda a: count[a][1])\n        \n        for t in typs:\n            line = ""  %d\\t%d\\t%s"" % (count[t][0], count[t][1], t)\n            if showIDs:\n                line += ""\\t""+"","".join(map(str,rev[t]))\n            print(line)\n        \n    def findTypes(self, refs, regex):\n        allObjs = get_all_objects()\n        ids = {}\n        objs = []\n        r = re.compile(regex)\n        for k in refs:\n            if r.search(self.objTypes[k]):\n                objs.append(self.lookup(k, refs[k], allObjs))\n        return objs\n        \n\n    \n    \ndef describeObj(obj, depth=4, path=None, ignore=None):\n    """"""\n    Trace all reference paths backward, printing a list of different ways this object can be accessed.\n    Attempts to answer the question ""who has a reference to this object""\n    """"""\n    if path is None:\n        path = [obj]\n    if ignore is None:\n        ignore = {}   ## holds IDs of objects used within the function.\n    ignore[id(sys._getframe())] = None\n    ignore[id(path)] = None\n    gc.collect()\n    refs = gc.get_referrers(obj)\n    ignore[id(refs)] = None\n    printed=False\n    for ref in refs:\n        if id(ref) in ignore:\n            continue\n        if id(ref) in list(map(id, path)):\n            print(""Cyclic reference: "" + refPathString([ref]+path))\n            printed = True\n            continue\n        newPath = [ref]+path\n        if len(newPath) >= depth:\n            refStr = refPathString(newPath)\n            if \'[_]\' not in refStr:           ## ignore \'_\' references generated by the interactive shell\n                print(refStr)\n            printed = True\n        else:\n            describeObj(ref, depth, newPath, ignore)\n            printed = True\n    if not printed:\n        print(""Dead end: "" + refPathString(path))\n        \n    \n    \ndef typeStr(obj):\n    """"""Create a more useful type string by making <instance> types report their class.""""""\n    typ = type(obj)\n    if typ == getattr(types, \'InstanceType\', None):\n        return ""<instance of %s>"" % obj.__class__.__name__\n    else:\n        return str(typ)\n    \ndef searchRefs(obj, *args):\n    """"""Pseudo-interactive function for tracing references backward.\n    **Arguments:**\n    \n        obj:   The initial object from which to start searching\n        args:  A set of string or int arguments.\n               each integer selects one of obj\'s referrers to be the new \'obj\'\n               each string indicates an action to take on the current \'obj\':\n                  t:  print the types of obj\'s referrers\n                  l:  print the lengths of obj\'s referrers (if they have __len__)\n                  i:  print the IDs of obj\'s referrers\n                  o:  print obj\n                  ro: return obj\n                  rr: return list of obj\'s referrers\n    \n    Examples::\n    \n       searchRefs(obj, \'t\')                    ## Print types of all objects referring to obj\n       searchRefs(obj, \'t\', 0, \'t\')            ##   ..then select the first referrer and print the types of its referrers\n       searchRefs(obj, \'t\', 0, \'t\', \'l\')       ##   ..also print lengths of the last set of referrers\n       searchRefs(obj, 0, 1, \'ro\')             ## Select index 0 from obj\'s referrer, then select index 1 from the next set of referrers, then return that object\n       \n    """"""\n    ignore = {id(sys._getframe()): None}\n    gc.collect()\n    refs = gc.get_referrers(obj)\n    ignore[id(refs)] = None\n    refs = [r for r in refs if id(r) not in ignore]\n    for a in args:\n        \n        #fo = allFrameObjs()\n        #refs = [r for r in refs if r not in fo]\n        \n        if type(a) is int:\n            obj = refs[a]\n            gc.collect()\n            refs = gc.get_referrers(obj)\n            ignore[id(refs)] = None\n            refs = [r for r in refs if id(r) not in ignore]\n        elif a == \'t\':\n            print(list(map(typeStr, refs)))\n        elif a == \'i\':\n            print(list(map(id, refs)))\n        elif a == \'l\':\n            def slen(o):\n                if hasattr(o, \'__len__\'):\n                    return len(o)\n                else:\n                    return None\n            print(list(map(slen, refs)))\n        elif a == \'o\':\n            print(obj)\n        elif a == \'ro\':\n            return obj\n        elif a == \'rr\':\n            return refs\n    \ndef allFrameObjs():\n    """"""Return list of frame objects in current stack. Useful if you want to ignore these objects in refernece searches""""""\n    f = sys._getframe()\n    objs = []\n    while f is not None:\n        objs.append(f)\n        objs.append(f.f_code)\n        #objs.append(f.f_locals)\n        #objs.append(f.f_globals)\n        #objs.append(f.f_builtins)\n        f = f.f_back\n    return objs\n        \n    \ndef findObj(regex):\n    """"""Return a list of objects whose typeStr matches regex""""""\n    allObjs = get_all_objects()\n    objs = []\n    r = re.compile(regex)\n    for i in allObjs:\n        obj = allObjs[i]\n        if r.search(typeStr(obj)):\n            objs.append(obj)\n    return objs\n    \n\n\ndef listRedundantModules():\n    """"""List modules that have been imported more than once via different paths.""""""\n    mods = {}\n    for name, mod in sys.modules.items():\n        if not hasattr(mod, \'__file__\'):\n            continue\n        mfile = os.path.abspath(mod.__file__)\n        if mfile[-1] == \'c\':\n            mfile = mfile[:-1]\n        if mfile in mods:\n            print(""module at %s has 2 names: %s, %s"" % (mfile, name, mods[mfile]))\n        else:\n            mods[mfile] = name\n            \n\ndef walkQObjectTree(obj, counts=None, verbose=False, depth=0):\n    """"""\n    Walk through a tree of QObjects, doing nothing to them.\n    The purpose of this function is to find dead objects and generate a crash\n    immediately rather than stumbling upon them later.\n    Prints a count of the objects encountered, for fun. (or is it?)\n    """"""\n    \n    if verbose:\n        print(""  ""*depth + typeStr(obj))\n    report = False\n    if counts is None:\n        counts = {}\n        report = True\n    typ = str(type(obj))\n    try:\n        counts[typ] += 1\n    except KeyError:\n        counts[typ] = 1\n    for child in obj.children():\n        walkQObjectTree(child, counts, verbose, depth+1)\n        \n    return counts\n\nQObjCache = {}\ndef qObjectReport(verbose=False):\n    """"""Generate a report counting all QObjects and their types""""""\n    global qObjCache\n    count = {}\n    for obj in findObj(\'PyQt\'):\n        if isinstance(obj, QtCore.QObject):\n            oid = id(obj)\n            if oid not in QObjCache:\n                QObjCache[oid] = typeStr(obj) + ""  "" + obj.objectName()\n                try:\n                    QObjCache[oid] += ""  "" + obj.parent().objectName()\n                    QObjCache[oid] += ""  "" + obj.text()\n                except:\n                    pass\n            print(""check obj"", oid, str(QObjCache[oid]))\n            if obj.parent() is None:\n                walkQObjectTree(obj, count, verbose)\n            \n    typs = list(count.keys())\n    typs.sort()\n    for t in typs:\n        print(count[t], ""\\t"", t)\n        \n\nclass PrintDetector(object):\n    """"""Find code locations that print to stdout.""""""\n    def __init__(self):\n        self.stdout = sys.stdout\n        sys.stdout = self\n    \n    def remove(self):\n        sys.stdout = self.stdout\n        \n    def __del__(self):\n        self.remove()\n    \n    def write(self, x):\n        self.stdout.write(x)\n        traceback.print_stack()\n        \n    def flush(self):\n        self.stdout.flush()\n\n\ndef listQThreads():\n    """"""Prints Thread IDs (Qt\'s, not OS\'s) for all QThreads.""""""\n    thr = findObj(\'[Tt]hread\')\n    thr = [t for t in thr if isinstance(t, QtCore.QThread)]\n    import sip\n    for t in thr:\n        print(""--> "", t)\n        print(""     Qt ID: 0x%x"" % sip.unwrapinstance(t))\n\n\ndef pretty(data, indent=\'\'):\n    """"""Format nested dict/list/tuple structures into a more human-readable string\n    This function is a bit better than pprint for displaying OrderedDicts.\n    """"""\n    ret = """"\n    ind2 = indent + ""    ""\n    if isinstance(data, dict):\n        ret = indent+""{\\n""\n        for k, v in data.items():\n            ret += ind2 + repr(k) + "":  "" + pretty(v, ind2).strip() + ""\\n""\n        ret += indent+""}\\n""\n    elif isinstance(data, list) or isinstance(data, tuple):\n        s = repr(data)\n        if len(s) < 40:\n            ret += indent + s\n        else:\n            if isinstance(data, list):\n                d = \'[]\'\n            else:\n                d = \'()\'\n            ret = indent+d[0]+""\\n""\n            for i, v in enumerate(data):\n                ret += ind2 + str(i) + "":  "" + pretty(v, ind2).strip() + ""\\n""\n            ret += indent+d[1]+""\\n""\n    else:\n        ret += indent + repr(data)\n    return ret\n\n\nclass ThreadTrace(object):\n    """""" \n    Used to debug freezing by starting a new thread that reports on the \n    location of other threads periodically.\n    """"""\n    def __init__(self, interval=10.0):\n        self.interval = interval\n        self.lock = Mutex()\n        self._stop = False\n        self.start()\n\n    def stop(self):\n        with self.lock:\n            self._stop = True\n\n    def start(self, interval=None):\n        if interval is not None:\n            self.interval = interval\n        self._stop = False\n        self.thread = threading.Thread(target=self.run)\n        self.thread.daemon = True\n        self.thread.start()\n\n    def run(self):\n        while True:\n            with self.lock:\n                if self._stop is True:\n                    return\n                    \n            print(""\\n=============  THREAD FRAMES:  ================"")\n            for id, frame in sys._current_frames().items():\n                if id == threading.current_thread().ident:\n                    continue\n                print(""<< thread %d >>"" % id)\n                traceback.print_stack(frame)\n            print(""===============================================\\n"")\n            \n            time.sleep(self.interval)\n\n\nclass ThreadColor(object):\n    """"""\n    Wrapper on stdout/stderr that colors text by the current thread ID.\n\n    *stream* must be \'stdout\' or \'stderr\'.\n    """"""\n    colors = {}\n    lock = Mutex()\n\n    def __init__(self, stream):\n        self.stream = getattr(sys, stream)\n        self.err = stream == \'stderr\'\n        setattr(sys, stream, self)\n\n    def write(self, msg):\n        with self.lock:\n            cprint.cprint(self.stream, self.color(), msg, -1, stderr=self.err)\n\n    def flush(self):\n        with self.lock:\n            self.stream.flush()\n\n    def color(self):\n        tid = threading.current_thread()\n        if tid not in self.colors:\n            c = (len(self.colors) % 15) + 1\n            self.colors[tid] = c\n        return self.colors[tid]\n\n\ndef enableFaulthandler():\n    """""" Enable faulthandler for all threads. \n    \n    If the faulthandler package is available, this function disables and then \n    re-enables fault handling for all threads (this is necessary to ensure any\n    new threads are handled correctly), and returns True.\n\n    If faulthandler is not available, then returns False.\n    """"""\n    try:\n        import faulthandler\n        # necessary to disable first or else new threads may not be handled.\n        faulthandler.disable()\n        faulthandler.enable(all_threads=True)\n        return True\n    except ImportError:\n        return False\n\n'"
src/third_party/pyqtgraph/exceptionHandling.py,0,"b'# -*- coding: utf-8 -*-\n""""""This module installs a wrapper around sys.excepthook which allows multiple\nnew exception handlers to be registered. \n\nOptionally, the wrapper also stops exceptions from causing long-term storage \nof local stack frames. This has two major effects:\n  - Unhandled exceptions will no longer cause memory leaks\n    (If an exception occurs while a lot of data is present on the stack, \n    such as when loading large files, the data would ordinarily be kept\n    until the next exception occurs. We would rather release this memory \n    as soon as possible.)\n  - Some debuggers may have a hard time handling uncaught exceptions\n \nThe module also provides a callback mechanism allowing others to respond \nto exceptions.\n""""""\n\nimport sys, time\n#from lib.Manager import logMsg\nimport traceback\n#from log import *\n\n#logging = False\n\ncallbacks = []\nclear_tracebacks = False\n\ndef register(fn):\n    """"""\n    Register a callable to be invoked when there is an unhandled exception.\n    The callback will be passed the output of sys.exc_info(): (exception type, exception, traceback)\n    Multiple callbacks will be invoked in the order they were registered.\n    """"""\n    callbacks.append(fn)\n    \ndef unregister(fn):\n    """"""Unregister a previously registered callback.""""""\n    callbacks.remove(fn)\n\ndef setTracebackClearing(clear=True):\n    """"""\n    Enable or disable traceback clearing.\n    By default, clearing is disabled and Python will indefinitely store unhandled exception stack traces.\n    This function is provided since Python\'s default behavior can cause unexpected retention of \n    large memory-consuming objects.\n    """"""\n    global clear_tracebacks\n    clear_tracebacks = clear\n    \nclass ExceptionHandler(object):\n    def __call__(self, *args):\n        ## Start by extending recursion depth just a bit. \n        ## If the error we are catching is due to recursion, we don\'t want to generate another one here.\n        recursionLimit = sys.getrecursionlimit()\n        try:\n            sys.setrecursionlimit(recursionLimit+100)\n        \n        \n            ## call original exception handler first (prints exception)\n            global original_excepthook, callbacks, clear_tracebacks\n            try:\n                print(""===== %s ====="" % str(time.strftime(""%Y.%m.%d %H:%m:%S"", time.localtime(time.time()))))\n            except Exception:\n                sys.stderr.write(""Warning: stdout is broken! Falling back to stderr.\\n"")\n                sys.stdout = sys.stderr\n\n            ret = original_excepthook(*args)\n                \n            for cb in callbacks:\n                try:\n                    cb(*args)\n                except Exception:\n                    print(""   --------------------------------------------------------------"")\n                    print(""      Error occurred during exception callback %s"" % str(cb))\n                    print(""   --------------------------------------------------------------"")\n                    traceback.print_exception(*sys.exc_info())\n                \n            \n            ## Clear long-term storage of last traceback to prevent memory-hogging.\n            ## (If an exception occurs while a lot of data is present on the stack, \n            ## such as when loading large files, the data would ordinarily be kept\n            ## until the next exception occurs. We would rather release this memory \n            ## as soon as possible.)\n            if clear_tracebacks is True:\n                sys.last_traceback = None\n        \n        finally:\n            sys.setrecursionlimit(recursionLimit)            \n            \n            \n    def implements(self, interface=None):\n        ## this just makes it easy for us to detect whether an ExceptionHook is already installed.\n        if interface is None:\n            return [\'ExceptionHandler\']\n        else:\n            return interface == \'ExceptionHandler\'\n    \n\n\n## replace built-in excepthook only if this has not already been done\nif not (hasattr(sys.excepthook, \'implements\') and sys.excepthook.implements(\'ExceptionHandler\')):\n    original_excepthook = sys.excepthook\n    sys.excepthook = ExceptionHandler()\n\n\n\n'"
src/third_party/pyqtgraph/frozenSupport.py,0,"b'## Definitions helpful in frozen environments (eg py2exe)\nimport os, sys, zipfile\n\ndef listdir(path):\n    """"""Replacement for os.listdir that works in frozen environments.""""""\n    if not hasattr(sys, \'frozen\'):\n        return os.listdir(path)\n    \n    (zipPath, archivePath) = splitZip(path)\n    if archivePath is None:\n        return os.listdir(path)\n    \n    with zipfile.ZipFile(zipPath, ""r"") as zipobj:\n        contents = zipobj.namelist()\n    results = set()\n    for name in contents:\n        # components in zip archive paths are always separated by forward slash\n        if name.startswith(archivePath) and len(name) > len(archivePath):\n            name = name[len(archivePath):].split(\'/\')[0]\n            results.add(name)\n    return list(results)\n\ndef isdir(path):\n    """"""Replacement for os.path.isdir that works in frozen environments.""""""\n    if not hasattr(sys, \'frozen\'):\n        return os.path.isdir(path)\n    \n    (zipPath, archivePath) = splitZip(path)\n    if archivePath is None:\n        return os.path.isdir(path)\n    with zipfile.ZipFile(zipPath, ""r"") as zipobj:\n        contents = zipobj.namelist()\n    archivePath = archivePath.rstrip(\'/\') + \'/\'   ## make sure there\'s exactly one \'/\' at the end\n    for c in contents:\n        if c.startswith(archivePath):\n            return True\n    return False\n    \n    \ndef splitZip(path):\n    """"""Splits a path containing a zip file into (zipfile, subpath).\n    If there is no zip file, returns (path, None)""""""\n    components = os.path.normpath(path).split(os.sep)\n    for index, component in enumerate(components):\n        if component.endswith(\'.zip\'):\n            zipPath = os.sep.join(components[0:index+1])\n            archivePath = \'\'.join([x+\'/\' for x in components[index+1:]])\n            return (zipPath, archivePath)\n    else:\n        return (path, None)\n    \n    '"
src/third_party/pyqtgraph/functions.py,137,"b'# -*- coding: utf-8 -*-\n""""""\nfunctions.py -  Miscellaneous functions with no other home\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n""""""\n\nfrom __future__ import division\nimport warnings\nimport numpy as np\nimport decimal, re\nimport ctypes\nimport sys, struct\nfrom .python2_3 import asUnicode, basestring\nfrom .Qt import QtGui, QtCore, QT_LIB\nfrom . import getConfigOption, setConfigOptions\nfrom . import debug, reload\nfrom .reload import getPreviousVersion \nfrom .metaarray import MetaArray\n\n\nColors = {\n    \'b\': QtGui.QColor(0,0,255,255),\n    \'g\': QtGui.QColor(0,255,0,255),\n    \'r\': QtGui.QColor(255,0,0,255),\n    \'c\': QtGui.QColor(0,255,255,255),\n    \'m\': QtGui.QColor(255,0,255,255),\n    \'y\': QtGui.QColor(255,255,0,255),\n    \'k\': QtGui.QColor(0,0,0,255),\n    \'w\': QtGui.QColor(255,255,255,255),\n    \'d\': QtGui.QColor(150,150,150,255),\n    \'l\': QtGui.QColor(200,200,200,255),\n    \'s\': QtGui.QColor(100,100,150,255),\n}  \n\nSI_PREFIXES = asUnicode(\'yzafpn\xc2\xb5m kMGTPEZY\')\nSI_PREFIXES_ASCII = \'yzafpnum kMGTPEZY\'\nSI_PREFIX_EXPONENTS = dict([(SI_PREFIXES[i], (i-8)*3) for i in range(len(SI_PREFIXES))])\nSI_PREFIX_EXPONENTS[\'u\'] = -6\n\nFLOAT_REGEX = re.compile(r\'(?P<number>[+-]?((\\d+(\\.\\d*)?)|(\\d*\\.\\d+))([eE][+-]?\\d+)?)\\s*((?P<siPrefix>[u\' + SI_PREFIXES + r\']?)(?P<suffix>\\w.*))?$\')\nINT_REGEX = re.compile(r\'(?P<number>[+-]?\\d+)\\s*(?P<siPrefix>[u\' + SI_PREFIXES + r\']?)(?P<suffix>.*)$\')\n\n    \ndef siScale(x, minVal=1e-25, allowUnicode=True):\n    """"""\n    Return the recommended scale factor and SI prefix string for x.\n    \n    Example::\n    \n        siScale(0.0001)   # returns (1e6, \'\xce\xbc\')\n        # This indicates that the number 0.0001 is best represented as 0.0001 * 1e6 = 100 \xce\xbcUnits\n    """"""\n    \n    if isinstance(x, decimal.Decimal):\n        x = float(x)\n        \n    try:\n        if np.isnan(x) or np.isinf(x):\n            return(1, \'\')\n    except:\n        print(x, type(x))\n        raise\n    if abs(x) < minVal:\n        m = 0\n        x = 0\n    else:\n        m = int(np.clip(np.floor(np.log(abs(x))/np.log(1000)), -9.0, 9.0))\n    \n    if m == 0:\n        pref = \'\'\n    elif m < -8 or m > 8:\n        pref = \'e%d\' % (m*3)\n    else:\n        if allowUnicode:\n            pref = SI_PREFIXES[m+8]\n        else:\n            pref = SI_PREFIXES_ASCII[m+8]\n    p = .001**m\n    \n    return (p, pref)    \n\n\ndef siFormat(x, precision=3, suffix=\'\', space=True, error=None, minVal=1e-25, allowUnicode=True):\n    """"""\n    Return the number x formatted in engineering notation with SI prefix.\n    \n    Example::\n        siFormat(0.0001, suffix=\'V\')  # returns ""100 \xce\xbcV""\n    """"""\n    \n    if space is True:\n        space = \' \'\n    if space is False:\n        space = \'\'\n        \n    \n    (p, pref) = siScale(x, minVal, allowUnicode)\n    if not (len(pref) > 0 and pref[0] == \'e\'):\n        pref = space + pref\n    \n    if error is None:\n        fmt = ""%."" + str(precision) + ""g%s%s""\n        return fmt % (x*p, pref, suffix)\n    else:\n        if allowUnicode:\n            plusminus = space + asUnicode(""\xc2\xb1"") + space\n        else:\n            plusminus = "" +/- ""\n        fmt = ""%."" + str(precision) + ""g%s%s%s%s""\n        return fmt % (x*p, pref, suffix, plusminus, siFormat(error, precision=precision, suffix=suffix, space=space, minVal=minVal))\n\n\ndef siParse(s, regex=FLOAT_REGEX, suffix=None):\n    """"""Convert a value written in SI notation to a tuple (number, si_prefix, suffix).\n    \n    Example::\n    \n        siParse(\'100 \xce\xbcV"")  # returns (\'100\', \'\xce\xbc\', \'V\')\n    """"""\n    s = asUnicode(s)\n    s = s.strip()\n    if suffix is not None and len(suffix) > 0:\n        if s[-len(suffix):] != suffix:\n            raise ValueError(""String \'%s\' does not have the expected suffix \'%s\'"" % (s, suffix))\n        s = s[:-len(suffix)] + \'X\'  # add a fake suffix so the regex still picks up the si prefix\n        \n    m = regex.match(s)\n    if m is None:\n        raise ValueError(\'Cannot parse number ""%s""\' % s)\n    try:\n        sip = m.group(\'siPrefix\')\n    except IndexError:\n        sip = \'\'\n    \n    if suffix is None:\n        try:\n            suf = m.group(\'suffix\')\n        except IndexError:\n            suf = \'\'\n    else:\n        suf = suffix\n    \n    return m.group(\'number\'), \'\' if sip is None else sip, \'\' if suf is None else suf \n\n\ndef siEval(s, typ=float, regex=FLOAT_REGEX, suffix=None):\n    """"""\n    Convert a value written in SI notation to its equivalent prefixless value.\n\n    Example::\n    \n        siEval(""100 \xce\xbcV"")  # returns 0.0001\n    """"""\n    val, siprefix, suffix = siParse(s, regex, suffix=suffix)\n    v = typ(val)\n    return siApply(v, siprefix)\n\n    \ndef siApply(val, siprefix):\n    """"""\n    """"""\n    n = SI_PREFIX_EXPONENTS[siprefix] if siprefix != \'\' else 0\n    if n > 0:\n        return val * 10**n\n    elif n < 0:\n        # this case makes it possible to use Decimal objects here\n        return val / 10**-n\n    else:\n        return val\n    \n\nclass Color(QtGui.QColor):\n    def __init__(self, *args):\n        QtGui.QColor.__init__(self, mkColor(*args))\n        \n    def glColor(self):\n        """"""Return (r,g,b,a) normalized for use in opengl""""""\n        return (self.red()/255., self.green()/255., self.blue()/255., self.alpha()/255.)\n        \n    def __getitem__(self, ind):\n        return (self.red, self.green, self.blue, self.alpha)[ind]()\n        \n    \ndef mkColor(*args):\n    """"""\n    Convenience function for constructing QColor from a variety of argument types. Accepted arguments are:\n    \n    ================ ================================================\n     \'c\'             one of: r, g, b, c, m, y, k, w                      \n     R, G, B, [A]    integers 0-255\n     (R, G, B, [A])  tuple of integers 0-255\n     float           greyscale, 0.0-1.0\n     int             see :func:`intColor() <pyqtgraph.intColor>`\n     (int, hues)     see :func:`intColor() <pyqtgraph.intColor>`\n     ""RGB""           hexadecimal strings; may begin with \'#\'\n     ""RGBA""          \n     ""RRGGBB""       \n     ""RRGGBBAA""     \n     QColor          QColor instance; makes a copy.\n    ================ ================================================\n    """"""\n    err = \'Not sure how to make a color from ""%s""\' % str(args)\n    if len(args) == 1:\n        if isinstance(args[0], basestring):\n            c = args[0]\n            if c[0] == \'#\':\n                c = c[1:]\n            if len(c) == 1:\n                try:\n                    return Colors[c]\n                except KeyError:\n                    raise ValueError(\'No color named ""%s""\' % c)\n            if len(c) == 3:\n                r = int(c[0]*2, 16)\n                g = int(c[1]*2, 16)\n                b = int(c[2]*2, 16)\n                a = 255\n            elif len(c) == 4:\n                r = int(c[0]*2, 16)\n                g = int(c[1]*2, 16)\n                b = int(c[2]*2, 16)\n                a = int(c[3]*2, 16)\n            elif len(c) == 6:\n                r = int(c[0:2], 16)\n                g = int(c[2:4], 16)\n                b = int(c[4:6], 16)\n                a = 255\n            elif len(c) == 8:\n                r = int(c[0:2], 16)\n                g = int(c[2:4], 16)\n                b = int(c[4:6], 16)\n                a = int(c[6:8], 16)\n        elif isinstance(args[0], QtGui.QColor):\n            return QtGui.QColor(args[0])\n        elif isinstance(args[0], float):\n            r = g = b = int(args[0] * 255)\n            a = 255\n        elif hasattr(args[0], \'__len__\'):\n            if len(args[0]) == 3:\n                (r, g, b) = args[0]\n                a = 255\n            elif len(args[0]) == 4:\n                (r, g, b, a) = args[0]\n            elif len(args[0]) == 2:\n                return intColor(*args[0])\n            else:\n                raise TypeError(err)\n        elif type(args[0]) == int:\n            return intColor(args[0])\n        else:\n            raise TypeError(err)\n    elif len(args) == 3:\n        (r, g, b) = args\n        a = 255\n    elif len(args) == 4:\n        (r, g, b, a) = args\n    else:\n        raise TypeError(err)\n    \n    args = [r,g,b,a]\n    args = [0 if np.isnan(a) or np.isinf(a) else a for a in args]\n    args = list(map(int, args))\n    return QtGui.QColor(*args)\n\n\ndef mkBrush(*args, **kwds):\n    """"""\n    | Convenience function for constructing Brush.\n    | This function always constructs a solid brush and accepts the same arguments as :func:`mkColor() <pyqtgraph.mkColor>`\n    | Calling mkBrush(None) returns an invisible brush.\n    """"""\n    if \'color\' in kwds:\n        color = kwds[\'color\']\n    elif len(args) == 1:\n        arg = args[0]\n        if arg is None:\n            return QtGui.QBrush(QtCore.Qt.NoBrush)\n        elif isinstance(arg, QtGui.QBrush):\n            return QtGui.QBrush(arg)\n        else:\n            color = arg\n    elif len(args) > 1:\n        color = args\n    return QtGui.QBrush(mkColor(color))\n\n\ndef mkPen(*args, **kargs):\n    """"""\n    Convenience function for constructing QPen. \n    \n    Examples::\n    \n        mkPen(color)\n        mkPen(color, width=2)\n        mkPen(cosmetic=False, width=4.5, color=\'r\')\n        mkPen({\'color\': ""FF0"", width: 2})\n        mkPen(None)   # (no pen)\n    \n    In these examples, *color* may be replaced with any arguments accepted by :func:`mkColor() <pyqtgraph.mkColor>`    """"""\n    \n    color = kargs.get(\'color\', None)\n    width = kargs.get(\'width\', 1)\n    style = kargs.get(\'style\', None)\n    dash = kargs.get(\'dash\', None)\n    cosmetic = kargs.get(\'cosmetic\', True)\n    hsv = kargs.get(\'hsv\', None)\n    \n    if len(args) == 1:\n        arg = args[0]\n        if isinstance(arg, dict):\n            return mkPen(**arg)\n        if isinstance(arg, QtGui.QPen):\n            return QtGui.QPen(arg)  ## return a copy of this pen\n        elif arg is None:\n            style = QtCore.Qt.NoPen\n        else:\n            color = arg\n    if len(args) > 1:\n        color = args\n        \n    if color is None:\n        color = mkColor(\'l\')\n    if hsv is not None:\n        color = hsvColor(*hsv)\n    else:\n        color = mkColor(color)\n        \n    pen = QtGui.QPen(QtGui.QBrush(color), width)\n    pen.setCosmetic(cosmetic)\n    if style is not None:\n        pen.setStyle(style)\n    if dash is not None:\n        pen.setDashPattern(dash)\n    return pen\n\n\ndef hsvColor(hue, sat=1.0, val=1.0, alpha=1.0):\n    """"""Generate a QColor from HSVa values. (all arguments are float 0.0-1.0)""""""\n    c = QtGui.QColor()\n    c.setHsvF(hue, sat, val, alpha)\n    return c\n\n    \ndef colorTuple(c):\n    """"""Return a tuple (R,G,B,A) from a QColor""""""\n    return (c.red(), c.green(), c.blue(), c.alpha())\n\n\ndef colorStr(c):\n    """"""Generate a hex string code from a QColor""""""\n    return (\'%02x\'*4) % colorTuple(c)\n\n\ndef intColor(index, hues=9, values=1, maxValue=255, minValue=150, maxHue=360, minHue=0, sat=255, alpha=255):\n    """"""\n    Creates a QColor from a single index. Useful for stepping through a predefined list of colors.\n    \n    The argument *index* determines which color from the set will be returned. All other arguments determine what the set of predefined colors will be\n     \n    Colors are chosen by cycling across hues while varying the value (brightness). \n    By default, this selects from a list of 9 hues.""""""\n    hues = int(hues)\n    values = int(values)\n    ind = int(index) % (hues * values)\n    indh = ind % hues\n    indv = ind // hues\n    if values > 1:\n        v = minValue + indv * ((maxValue-minValue) / (values-1))\n    else:\n        v = maxValue\n    h = minHue + (indh * (maxHue-minHue)) / hues\n    \n    c = QtGui.QColor()\n    c.setHsv(h, sat, v)\n    c.setAlpha(alpha)\n    return c\n\n\ndef glColor(*args, **kargs):\n    """"""\n    Convert a color to OpenGL color format (r,g,b,a) floats 0.0-1.0\n    Accepts same arguments as :func:`mkColor <pyqtgraph.mkColor>`.\n    """"""\n    c = mkColor(*args, **kargs)\n    return (c.red()/255., c.green()/255., c.blue()/255., c.alpha()/255.)\n\n    \n\ndef makeArrowPath(headLen=20, tipAngle=20, tailLen=20, tailWidth=3, baseAngle=0):\n    """"""\n    Construct a path outlining an arrow with the given dimensions.\n    The arrow points in the -x direction with tip positioned at 0,0.\n    If *tipAngle* is supplied (in degrees), it overrides *headWidth*.\n    If *tailLen* is None, no tail will be drawn.\n    """"""\n    headWidth = headLen * np.tan(tipAngle * 0.5 * np.pi/180.)\n    path = QtGui.QPainterPath()\n    path.moveTo(0,0)\n    path.lineTo(headLen, -headWidth)\n    if tailLen is None:\n        innerY = headLen - headWidth * np.tan(baseAngle*np.pi/180.)\n        path.lineTo(innerY, 0)\n    else:\n        tailWidth *= 0.5\n        innerY = headLen - (headWidth-tailWidth) * np.tan(baseAngle*np.pi/180.)\n        path.lineTo(innerY, -tailWidth)\n        path.lineTo(headLen + tailLen, -tailWidth)\n        path.lineTo(headLen + tailLen, tailWidth)\n        path.lineTo(innerY, tailWidth)\n    path.lineTo(headLen, headWidth)\n    path.lineTo(0,0)\n    return path\n    \n    \ndef eq(a, b):\n    """"""The great missing equivalence function: Guaranteed evaluation to a single bool value.\n    \n    This function has some important differences from the == operator:\n    \n    1. Returns True if a IS b, even if a==b still evaluates to False, such as with nan values.\n    2. Tests for equivalence using ==, but silently ignores some common exceptions that can occur\n       (AtrtibuteError, ValueError).\n    3. When comparing arrays, returns False if the array shapes are not the same.\n    4. When comparing arrays of the same shape, returns True only if all elements are equal (whereas\n       the == operator would return a boolean array).\n    """"""\n    if a is b:\n        return True\n\n    # Avoid comparing large arrays against scalars; this is expensive and we know it should return False.\n    aIsArr = isinstance(a, (np.ndarray, MetaArray))\n    bIsArr = isinstance(b, (np.ndarray, MetaArray))\n    if (aIsArr or bIsArr) and type(a) != type(b):\n        return False\n\n    # If both inputs are arrays, we can speeed up comparison if shapes / dtypes don\'t match\n    # NOTE: arrays of dissimilar type should be considered unequal even if they are numerically\n    # equal because they may behave differently when computed on.\n    if aIsArr and bIsArr and (a.shape != b.shape or a.dtype != b.dtype):\n        return False\n\n    # Test for equivalence. \n    # If the test raises a recognized exception, then return Falase\n    try:\n        try:\n            # Sometimes running catch_warnings(module=np) generates AttributeError ???\n            catcher =  warnings.catch_warnings(module=np)  # ignore numpy futurewarning (numpy v. 1.10)\n            catcher.__enter__()\n        except Exception:\n            catcher = None\n        e = a==b\n    except (ValueError, AttributeError): \n        return False\n    except:\n        print(\'failed to evaluate equivalence for:\')\n        print(""  a:"", str(type(a)), str(a))\n        print(""  b:"", str(type(b)), str(b))\n        raise\n    finally:\n        if catcher is not None:\n            catcher.__exit__(None, None, None)\n    \n    t = type(e)\n    if t is bool:\n        return e\n    elif t is np.bool_:\n        return bool(e)\n    elif isinstance(e, np.ndarray) or (hasattr(e, \'implements\') and e.implements(\'MetaArray\')):\n        try:   ## disaster: if a is an empty array and b is not, then e.all() is True\n            if a.shape != b.shape:\n                return False\n        except:\n            return False\n        if (hasattr(e, \'implements\') and e.implements(\'MetaArray\')):\n            return e.asarray().all()\n        else:\n            return e.all()\n    else:\n        raise Exception(""== operator returned type %s"" % str(type(e)))\n\n\ndef affineSliceCoords(shape, origin, vectors, axes):\n    """"""Return the array of coordinates used to sample data arrays in affineSlice().\n    """"""\n    # sanity check\n    if len(shape) != len(vectors):\n        raise Exception(""shape and vectors must have same length."")\n    if len(origin) != len(axes):\n        raise Exception(""origin and axes must have same length."")\n    for v in vectors:\n        if len(v) != len(axes):\n            raise Exception(""each vector must be same length as axes."")\n        \n    shape = list(map(np.ceil, shape))\n\n    ## make sure vectors are arrays\n    if not isinstance(vectors, np.ndarray):\n        vectors = np.array(vectors)\n    if not isinstance(origin, np.ndarray):\n        origin = np.array(origin)\n    origin.shape = (len(axes),) + (1,)*len(shape)\n\n    ## Build array of sample locations. \n    grid = np.mgrid[tuple([slice(0,x) for x in shape])]  ## mesh grid of indexes\n    x = (grid[np.newaxis,...] * vectors.transpose()[(Ellipsis,) + (np.newaxis,)*len(shape)]).sum(axis=1)  ## magic\n    x += origin\n\n    return x\n\n    \ndef affineSlice(data, shape, origin, vectors, axes, order=1, returnCoords=False, **kargs):\n    """"""\n    Take a slice of any orientation through an array. This is useful for extracting sections of multi-dimensional arrays\n    such as MRI images for viewing as 1D or 2D data.\n    \n    The slicing axes are aribtrary; they do not need to be orthogonal to the original data or even to each other. It is\n    possible to use this function to extract arbitrary linear, rectangular, or parallelepiped shapes from within larger\n    datasets. The original data is interpolated onto a new array of coordinates using either interpolateArray if order<2\n    or scipy.ndimage.map_coordinates otherwise.\n    \n    For a graphical interface to this function, see :func:`ROI.getArrayRegion <pyqtgraph.ROI.getArrayRegion>`\n    \n    ==============  ====================================================================================================\n    **Arguments:**\n    *data*          (ndarray) the original dataset\n    *shape*         the shape of the slice to take (Note the return value may have more dimensions than len(shape))\n    *origin*        the location in the original dataset that will become the origin of the sliced data.\n    *vectors*       list of unit vectors which point in the direction of the slice axes. Each vector must have the same \n                    length as *axes*. If the vectors are not unit length, the result will be scaled relative to the \n                    original data. If the vectors are not orthogonal, the result will be sheared relative to the \n                    original data.\n    *axes*          The axes in the original dataset which correspond to the slice *vectors*\n    *order*         The order of spline interpolation. Default is 1 (linear). See scipy.ndimage.map_coordinates\n                    for more information.\n    *returnCoords*  If True, return a tuple (result, coords) where coords is the array of coordinates used to select\n                    values from the original dataset.\n    *All extra keyword arguments are passed to scipy.ndimage.map_coordinates.*\n    --------------------------------------------------------------------------------------------------------------------\n    ==============  ====================================================================================================\n    \n    Note the following must be true: \n        \n        | len(shape) == len(vectors) \n        | len(origin) == len(axes) == len(vectors[i])\n        \n    Example: start with a 4D fMRI data set, take a diagonal-planar slice out of the last 3 axes\n        \n        * data = array with dims (time, x, y, z) = (100, 40, 40, 40)\n        * The plane to pull out is perpendicular to the vector (x,y,z) = (1,1,1) \n        * The origin of the slice will be at (x,y,z) = (40, 0, 0)\n        * We will slice a 20x20 plane from each timepoint, giving a final shape (100, 20, 20)\n        \n    The call for this example would look like::\n        \n        affineSlice(data, shape=(20,20), origin=(40,0,0), vectors=((-1, 1, 0), (-1, 0, 1)), axes=(1,2,3))\n    \n    """"""\n    x = affineSliceCoords(shape, origin, vectors, axes)\n\n    ## transpose data so slice axes come first\n    trAx = list(range(data.ndim))\n    for ax in axes:\n        trAx.remove(ax)\n    tr1 = tuple(axes) + tuple(trAx)\n    data = data.transpose(tr1)\n    #print ""tr1:"", tr1\n    ## dims are now [(slice axes), (other axes)]\n\n    if order > 1:\n        try:\n            import scipy.ndimage\n        except ImportError:\n            raise ImportError(""Interpolating with order > 1 requires the scipy.ndimage module, but it could not be imported."")\n\n        # iterate manually over unused axes since map_coordinates won\'t do it for us\n        extraShape = data.shape[len(axes):]\n        output = np.empty(tuple(shape) + extraShape, dtype=data.dtype)\n        for inds in np.ndindex(*extraShape):\n            ind = (Ellipsis,) + inds\n            output[ind] = scipy.ndimage.map_coordinates(data[ind], x, order=order, **kargs)\n    else:\n        # map_coordinates expects the indexes as the first axis, whereas\n        # interpolateArray expects indexes at the last axis. \n        tr = tuple(range(1, x.ndim)) + (0,)\n        output = interpolateArray(data, x.transpose(tr), order=order)\n    \n    tr = list(range(output.ndim))\n    trb = []\n    for i in range(min(axes)):\n        ind = tr1.index(i) + (len(shape)-len(axes))\n        tr.remove(ind)\n        trb.append(ind)\n    tr2 = tuple(trb+tr)\n\n    ## Untranspose array before returning\n    output = output.transpose(tr2)\n    if returnCoords:\n        return (output, x)\n    else:\n        return output\n\n\ndef interpolateArray(data, x, default=0.0, order=1):\n    """"""\n    N-dimensional interpolation similar to scipy.ndimage.map_coordinates.\n    \n    This function returns linearly-interpolated values sampled from a regular\n    grid of data. It differs from `ndimage.map_coordinates` by allowing broadcasting\n    within the input array.\n    \n    ==============  ===========================================================================================\n    **Arguments:**\n    *data*          Array of any shape containing the values to be interpolated.\n    *x*             Array with (shape[-1] <= data.ndim) containing the locations within *data* to interpolate.\n                    (note: the axes for this argument are transposed relative to the same argument for\n                    `ndimage.map_coordinates`).\n    *default*       Value to return for locations in *x* that are outside the bounds of *data*.\n    *order*         Order of interpolation: 0=nearest, 1=linear.\n    ==============  ===========================================================================================\n    \n    Returns array of shape (x.shape[:-1] + data.shape[x.shape[-1]:])\n    \n    For example, assume we have the following 2D image data::\n    \n        >>> data = np.array([[1,   2,   4  ],\n                             [10,  20,  40 ],\n                             [100, 200, 400]])\n        \n    To compute a single interpolated point from this data::\n        \n        >>> x = np.array([(0.5, 0.5)])\n        >>> interpolateArray(data, x)\n        array([ 8.25])\n        \n    To compute a 1D list of interpolated locations:: \n        \n        >>> x = np.array([(0.5, 0.5),\n                          (1.0, 1.0),\n                          (1.0, 2.0),\n                          (1.5, 0.0)])\n        >>> interpolateArray(data, x)\n        array([  8.25,  20.  ,  40.  ,  55.  ])\n        \n    To compute a 2D array of interpolated locations::\n    \n        >>> x = np.array([[(0.5, 0.5), (1.0, 2.0)],\n                          [(1.0, 1.0), (1.5, 0.0)]])\n        >>> interpolateArray(data, x)\n        array([[  8.25,  40.  ],\n               [ 20.  ,  55.  ]])\n               \n    ..and so on. The *x* argument may have any shape as long as \n    ```x.shape[-1] <= data.ndim```. In the case that \n    ```x.shape[-1] < data.ndim```, then the remaining axes are simply \n    broadcasted as usual. For example, we can interpolate one location\n    from an entire row of the data::\n    \n        >>> x = np.array([[0.5]])\n        >>> interpolateArray(data, x)\n        array([[  5.5,  11. ,  22. ]])\n\n    This is useful for interpolating from arrays of colors, vertexes, etc.\n    """"""\n    if order not in (0, 1):\n        raise ValueError(""interpolateArray requires order=0 or 1 (got %s)"" % order)\n\n    prof = debug.Profiler()\n\n    nd = data.ndim\n    md = x.shape[-1]\n    if md > nd:\n        raise TypeError(""x.shape[-1] must be less than or equal to data.ndim"")\n\n    totalMask = np.ones(x.shape[:-1], dtype=bool) # keep track of out-of-bound indexes\n    if order == 0:\n        xinds = np.round(x).astype(int)  # NOTE: for 0.5 this rounds to the nearest *even* number\n        for ax in range(md):\n            mask = (xinds[...,ax] >= 0) & (xinds[...,ax] <= data.shape[ax]-1) \n            xinds[...,ax][~mask] = 0\n            # keep track of points that need to be set to default\n            totalMask &= mask\n        result = data[tuple([xinds[...,i] for i in range(xinds.shape[-1])])]\n        \n    elif order == 1:\n        # First we generate arrays of indexes that are needed to \n        # extract the data surrounding each point\n        fields = np.mgrid[(slice(0,order+1),) * md]\n        xmin = np.floor(x).astype(int)\n        xmax = xmin + 1\n        indexes = np.concatenate([xmin[np.newaxis, ...], xmax[np.newaxis, ...]])\n        fieldInds = []\n        for ax in range(md):\n            mask = (xmin[...,ax] >= 0) & (x[...,ax] <= data.shape[ax]-1) \n            # keep track of points that need to be set to default\n            totalMask &= mask\n            \n            # ..and keep track of indexes that are out of bounds \n            # (note that when x[...,ax] == data.shape[ax], then xmax[...,ax] will be out\n            #  of bounds, but the interpolation will work anyway)\n            mask &= (xmax[...,ax] < data.shape[ax])\n            axisIndex = indexes[...,ax][fields[ax]]\n            axisIndex[axisIndex < 0] = 0\n            axisIndex[axisIndex >= data.shape[ax]] = 0\n            fieldInds.append(axisIndex)\n        prof()\n\n        # Get data values surrounding each requested point\n        fieldData = data[tuple(fieldInds)]\n        prof()\n    \n        ## Interpolate\n        s = np.empty((md,) + fieldData.shape, dtype=float)\n        dx = x - xmin\n        # reshape fields for arithmetic against dx\n        for ax in range(md):\n            f1 = fields[ax].reshape(fields[ax].shape + (1,)*(dx.ndim-1))\n            sax = f1 * dx[...,ax] + (1-f1) * (1-dx[...,ax])\n            sax = sax.reshape(sax.shape + (1,) * (s.ndim-1-sax.ndim))\n            s[ax] = sax\n        s = np.product(s, axis=0)\n        result = fieldData * s\n        for i in range(md):\n            result = result.sum(axis=0)\n\n    prof()\n\n    if totalMask.ndim > 0:\n        result[~totalMask] = default\n    else:\n        if totalMask is False:\n            result[:] = default\n\n    prof()\n    return result\n\n\ndef subArray(data, offset, shape, stride):\n    """"""\n    Unpack a sub-array from *data* using the specified offset, shape, and stride.\n    \n    Note that *stride* is specified in array elements, not bytes.\n    For example, we have a 2x3 array packed in a 1D array as follows::\n    \n        data = [_, _, 00, 01, 02, _, 10, 11, 12, _]\n        \n    Then we can unpack the sub-array with this call::\n    \n        subArray(data, offset=2, shape=(2, 3), stride=(4, 1))\n        \n    ..which returns::\n    \n        [[00, 01, 02],\n         [10, 11, 12]]\n         \n    This function operates only on the first axis of *data*. So changing \n    the input in the example above to have shape (10, 7) would cause the\n    output to have shape (2, 3, 7).\n    """"""\n    data = np.ascontiguousarray(data)[offset:]\n    shape = tuple(shape)\n    extraShape = data.shape[1:]\n\n    strides = list(data.strides[::-1])\n    itemsize = strides[-1]\n    for s in stride[1::-1]:\n        strides.append(itemsize * s)\n    strides = tuple(strides[::-1])\n    \n    return np.ndarray(buffer=data, shape=shape+extraShape, strides=strides, dtype=data.dtype)\n\n\ndef transformToArray(tr):\n    """"""\n    Given a QTransform, return a 3x3 numpy array.\n    Given a QMatrix4x4, return a 4x4 numpy array.\n    \n    Example: map an array of x,y coordinates through a transform::\n    \n        ## coordinates to map are (1,5), (2,6), (3,7), and (4,8)\n        coords = np.array([[1,2,3,4], [5,6,7,8], [1,1,1,1]])  # the extra \'1\' coordinate is needed for translation to work\n        \n        ## Make an example transform\n        tr = QtGui.QTransform()\n        tr.translate(3,4)\n        tr.scale(2, 0.1)\n        \n        ## convert to array\n        m = pg.transformToArray()[:2]  # ignore the perspective portion of the transformation\n        \n        ## map coordinates through transform\n        mapped = np.dot(m, coords)\n    """"""\n    #return np.array([[tr.m11(), tr.m12(), tr.m13()],[tr.m21(), tr.m22(), tr.m23()],[tr.m31(), tr.m32(), tr.m33()]])\n    ## The order of elements given by the method names m11..m33 is misleading--\n    ## It is most common for x,y translation to occupy the positions 1,3 and 2,3 in\n    ## a transformation matrix. However, with QTransform these values appear at m31 and m32.\n    ## So the correct interpretation is transposed:\n    if isinstance(tr, QtGui.QTransform):\n        return np.array([[tr.m11(), tr.m21(), tr.m31()], [tr.m12(), tr.m22(), tr.m32()], [tr.m13(), tr.m23(), tr.m33()]])\n    elif isinstance(tr, QtGui.QMatrix4x4):\n        return np.array(tr.copyDataTo()).reshape(4,4)\n    else:\n        raise Exception(""Transform argument must be either QTransform or QMatrix4x4."")\n\ndef transformCoordinates(tr, coords, transpose=False):\n    """"""\n    Map a set of 2D or 3D coordinates through a QTransform or QMatrix4x4.\n    The shape of coords must be (2,...) or (3,...)\n    The mapping will _ignore_ any perspective transformations.\n    \n    For coordinate arrays with ndim=2, this is basically equivalent to matrix multiplication.\n    Most arrays, however, prefer to put the coordinate axis at the end (eg. shape=(...,3)). To \n    allow this, use transpose=True.\n    \n    """"""\n    \n    if transpose:\n        ## move last axis to beginning. This transposition will be reversed before returning the mapped coordinates.\n        coords = coords.transpose((coords.ndim-1,) + tuple(range(0,coords.ndim-1)))\n    \n    nd = coords.shape[0]\n    if isinstance(tr, np.ndarray):\n        m = tr\n    else:\n        m = transformToArray(tr)\n        m = m[:m.shape[0]-1]  # remove perspective\n    \n    ## If coords are 3D and tr is 2D, assume no change for Z axis\n    if m.shape == (2,3) and nd == 3:\n        m2 = np.zeros((3,4))\n        m2[:2, :2] = m[:2,:2]\n        m2[:2, 3] = m[:2,2]\n        m2[2,2] = 1\n        m = m2\n    \n    ## if coords are 2D and tr is 3D, ignore Z axis\n    if m.shape == (3,4) and nd == 2:\n        m2 = np.empty((2,3))\n        m2[:,:2] = m[:2,:2]\n        m2[:,2] = m[:2,3]\n        m = m2\n    \n    ## reshape tr and coords to prepare for multiplication\n    m = m.reshape(m.shape + (1,)*(coords.ndim-1))\n    coords = coords[np.newaxis, ...]\n    \n    # separate scale/rotate and translation    \n    translate = m[:,-1]  \n    m = m[:, :-1]\n    \n    ## map coordinates and return\n    mapped = (m*coords).sum(axis=1)  ## apply scale/rotate\n    mapped += translate\n    \n    if transpose:\n        ## move first axis to end.\n        mapped = mapped.transpose(tuple(range(1,mapped.ndim)) + (0,))\n    return mapped\n    \n    \n\n    \ndef solve3DTransform(points1, points2):\n    """"""\n    Find a 3D transformation matrix that maps points1 onto points2.\n    Points must be specified as either lists of 4 Vectors or \n    (4, 3) arrays.\n    """"""\n    import numpy.linalg\n    pts = []\n    for inp in (points1, points2):\n        if isinstance(inp, np.ndarray):\n            A = np.empty((4,4), dtype=float)\n            A[:,:3] = inp[:,:3]\n            A[:,3] = 1.0\n        else:\n            A = np.array([[inp[i].x(), inp[i].y(), inp[i].z(), 1] for i in range(4)])\n        pts.append(A)\n    \n    ## solve 3 sets of linear equations to determine transformation matrix elements\n    matrix = np.zeros((4,4))\n    for i in range(3):\n        ## solve Ax = B; x is one row of the desired transformation matrix\n        matrix[i] = numpy.linalg.solve(pts[0], pts[1][:,i])  \n    \n    return matrix\n    \ndef solveBilinearTransform(points1, points2):\n    """"""\n    Find a bilinear transformation matrix (2x4) that maps points1 onto points2.\n    Points must be specified as a list of 4 Vector, Point, QPointF, etc.\n    \n    To use this matrix to map a point [x,y]::\n    \n        mapped = np.dot(matrix, [x*y, x, y, 1])\n    """"""\n    import numpy.linalg\n    ## A is 4 rows (points) x 4 columns (xy, x, y, 1)\n    ## B is 4 rows (points) x 2 columns (x, y)\n    A = np.array([[points1[i].x()*points1[i].y(), points1[i].x(), points1[i].y(), 1] for i in range(4)])\n    B = np.array([[points2[i].x(), points2[i].y()] for i in range(4)])\n    \n    ## solve 2 sets of linear equations to determine transformation matrix elements\n    matrix = np.zeros((2,4))\n    for i in range(2):\n        matrix[i] = numpy.linalg.solve(A, B[:,i])  ## solve Ax = B; x is one row of the desired transformation matrix\n    \n    return matrix\n    \ndef rescaleData(data, scale, offset, dtype=None, clip=None):\n    """"""Return data rescaled and optionally cast to a new dtype::\n    \n        data => (data-offset) * scale\n        \n    """"""\n    if dtype is None:\n        dtype = data.dtype\n    else:\n        dtype = np.dtype(dtype)\n    \n    try:\n        if not getConfigOption(\'useWeave\'):\n            raise Exception(\'Weave is disabled; falling back to slower version.\')\n        try:\n            import scipy.weave\n        except ImportError:\n            raise Exception(\'scipy.weave is not importable; falling back to slower version.\')\n        \n        ## require native dtype when using weave\n        if not data.dtype.isnative:\n            data = data.astype(data.dtype.newbyteorder(\'=\'))\n        if not dtype.isnative:\n            weaveDtype = dtype.newbyteorder(\'=\')\n        else:\n            weaveDtype = dtype\n        \n        newData = np.empty((data.size,), dtype=weaveDtype)\n        flat = np.ascontiguousarray(data).reshape(data.size)\n        size = data.size\n        \n        code = """"""\n        double sc = (double)scale;\n        double off = (double)offset;\n        for( int i=0; i<size; i++ ) {\n            newData[i] = ((double)flat[i] - off) * sc;\n        }\n        """"""\n        scipy.weave.inline(code, [\'flat\', \'newData\', \'size\', \'offset\', \'scale\'], compiler=\'gcc\')\n        if dtype != weaveDtype:\n            newData = newData.astype(dtype)\n        data = newData.reshape(data.shape)\n    except:\n        if getConfigOption(\'useWeave\'):\n            if getConfigOption(\'weaveDebug\'):\n                debug.printExc(""Error; disabling weave."")\n            setConfigOptions(useWeave=False)\n        \n        #p = np.poly1d([scale, -offset*scale])\n        #d2 = p(data)\n        d2 = data - float(offset)\n        d2 *= scale\n        \n        # Clip before converting dtype to avoid overflow\n        if dtype.kind in \'ui\':\n            lim = np.iinfo(dtype)\n            if clip is None:\n                # don\'t let rescale cause integer overflow\n                d2 = np.clip(d2, lim.min, lim.max)\n            else:\n                d2 = np.clip(d2, max(clip[0], lim.min), min(clip[1], lim.max))\n        else:\n            if clip is not None:\n                d2 = np.clip(d2, *clip)\n        data = d2.astype(dtype)\n    return data\n    \ndef applyLookupTable(data, lut):\n    """"""\n    Uses values in *data* as indexes to select values from *lut*.\n    The returned data has shape data.shape + lut.shape[1:]\n    \n    Note: color gradient lookup tables can be generated using GradientWidget.\n    """"""\n    if data.dtype.kind not in (\'i\', \'u\'):\n        data = data.astype(int)\n    \n    return np.take(lut, data, axis=0, mode=\'clip\')  \n    \n\ndef makeRGBA(*args, **kwds):\n    """"""Equivalent to makeARGB(..., useRGBA=True)""""""\n    kwds[\'useRGBA\'] = True\n    return makeARGB(*args, **kwds)\n\n\ndef makeARGB(data, lut=None, levels=None, scale=None, useRGBA=False): \n    """""" \n    Convert an array of values into an ARGB array suitable for building QImages,\n    OpenGL textures, etc.\n    \n    Returns the ARGB array (unsigned byte) and a boolean indicating whether\n    there is alpha channel data. This is a two stage process:\n    \n        1) Rescale the data based on the values in the *levels* argument (min, max).\n        2) Determine the final output by passing the rescaled values through a\n           lookup table.\n   \n    Both stages are optional.\n    \n    ============== ==================================================================================\n    **Arguments:**\n    data           numpy array of int/float types. If \n    levels         List [min, max]; optionally rescale data before converting through the\n                   lookup table. The data is rescaled such that min->0 and max->*scale*::\n                   \n                      rescaled = (clip(data, min, max) - min) * (*scale* / (max - min))\n                   \n                   It is also possible to use a 2D (N,2) array of values for levels. In this case,\n                   it is assumed that each pair of min,max values in the levels array should be \n                   applied to a different subset of the input data (for example, the input data may \n                   already have RGB values and the levels are used to independently scale each \n                   channel). The use of this feature requires that levels.shape[0] == data.shape[-1].\n    scale          The maximum value to which data will be rescaled before being passed through the \n                   lookup table (or returned if there is no lookup table). By default this will\n                   be set to the length of the lookup table, or 255 if no lookup table is provided.\n    lut            Optional lookup table (array with dtype=ubyte).\n                   Values in data will be converted to color by indexing directly from lut.\n                   The output data shape will be input.shape + lut.shape[1:].\n                   Lookup tables can be built using ColorMap or GradientWidget.\n    useRGBA        If True, the data is returned in RGBA order (useful for building OpenGL textures). \n                   The default is False, which returns in ARGB order for use with QImage \n                   (Note that \'ARGB\' is a term used by the Qt documentation; the *actual* order \n                   is BGRA).\n    ============== ==================================================================================\n    """"""\n    profile = debug.Profiler()\n\n    if data.ndim not in (2, 3):\n        raise TypeError(""data must be 2D or 3D"")\n    if data.ndim == 3 and data.shape[2] > 4:\n        raise TypeError(""data.shape[2] must be <= 4"")\n    \n    if lut is not None and not isinstance(lut, np.ndarray):\n        lut = np.array(lut)\n    \n    if levels is None:\n        # automatically decide levels based on data dtype\n        if data.dtype.kind == \'u\':\n            levels = np.array([0, 2**(data.itemsize*8)-1])\n        elif data.dtype.kind == \'i\':\n            s = 2**(data.itemsize*8 - 1)\n            levels = np.array([-s, s-1])\n        elif data.dtype.kind == \'b\':\n            levels = np.array([0,1])\n        else:\n            raise Exception(\'levels argument is required for float input types\')\n    if not isinstance(levels, np.ndarray):\n        levels = np.array(levels)\n    if levels.ndim == 1:\n        if levels.shape[0] != 2:\n            raise Exception(\'levels argument must have length 2\')\n    elif levels.ndim == 2:\n        if lut is not None and lut.ndim > 1:\n            raise Exception(\'Cannot make ARGB data when both levels and lut have ndim > 2\')\n        if levels.shape != (data.shape[-1], 2):\n            raise Exception(\'levels must have shape (data.shape[-1], 2)\')\n    else:\n        raise Exception(""levels argument must be 1D or 2D (got shape=%s)."" % repr(levels.shape))\n\n    profile()\n\n    # Decide on maximum scaled value\n    if scale is None:\n        if lut is not None:\n            scale = lut.shape[0] - 1\n        else:\n            scale = 255.\n\n    # Decide on the dtype we want after scaling\n    if lut is None:\n        dtype = np.ubyte\n    else:\n        dtype = np.min_scalar_type(lut.shape[0]-1)\n            \n    # Apply levels if given\n    if levels is not None:\n        if isinstance(levels, np.ndarray) and levels.ndim == 2:\n            # we are going to rescale each channel independently\n            if levels.shape[0] != data.shape[-1]:\n                raise Exception(""When rescaling multi-channel data, there must be the same number of levels as channels (data.shape[-1] == levels.shape[0])"")\n            newData = np.empty(data.shape, dtype=int)\n            for i in range(data.shape[-1]):\n                minVal, maxVal = levels[i]\n                if minVal == maxVal:\n                    maxVal += 1e-16\n                rng = maxVal-minVal\n                rng = 1 if rng == 0 else rng\n                newData[...,i] = rescaleData(data[...,i], scale / rng, minVal, dtype=dtype)\n            data = newData\n        else:\n            # Apply level scaling unless it would have no effect on the data\n            minVal, maxVal = levels\n            if minVal != 0 or maxVal != scale:\n                if minVal == maxVal:\n                    maxVal += 1e-16\n                data = rescaleData(data, scale/(maxVal-minVal), minVal, dtype=dtype)\n            \n\n    profile()\n\n    # apply LUT if given\n    if lut is not None:\n        data = applyLookupTable(data, lut)\n    else:\n        if data.dtype is not np.ubyte:\n            data = np.clip(data, 0, 255).astype(np.ubyte)\n\n    profile()\n\n    # this will be the final image array\n    imgData = np.empty(data.shape[:2]+(4,), dtype=np.ubyte)\n\n    profile()\n\n    # decide channel order\n    if useRGBA:\n        order = [0,1,2,3] # array comes out RGBA\n    else:\n        order = [2,1,0,3] # for some reason, the colors line up as BGR in the final image.\n        \n    # copy data into image array\n    if data.ndim == 2:\n        # This is tempting:\n        #   imgData[..., :3] = data[..., np.newaxis]\n        # ..but it turns out this is faster:\n        for i in range(3):\n            imgData[..., i] = data\n    elif data.shape[2] == 1:\n        for i in range(3):\n            imgData[..., i] = data[..., 0]\n    else:\n        for i in range(0, data.shape[2]):\n            imgData[..., i] = data[..., order[i]] \n        \n    profile()\n    \n    # add opaque alpha channel if needed\n    if data.ndim == 2 or data.shape[2] == 3:\n        alpha = False\n        imgData[..., 3] = 255\n    else:\n        alpha = True\n        \n    profile()\n    return imgData, alpha\n\n\ndef makeQImage(imgData, alpha=None, copy=True, transpose=True):\n    """"""\n    Turn an ARGB array into QImage.\n    By default, the data is copied; changes to the array will not\n    be reflected in the image. The image will be given a \'data\' attribute\n    pointing to the array which shares its data to prevent python\n    freeing that memory while the image is in use.\n    \n    ============== ===================================================================\n    **Arguments:**\n    imgData        Array of data to convert. Must have shape (width, height, 3 or 4) \n                   and dtype=ubyte. The order of values in the 3rd axis must be \n                   (b, g, r, a).\n    alpha          If True, the QImage returned will have format ARGB32. If False,\n                   the format will be RGB32. By default, _alpha_ is True if\n                   array.shape[2] == 4.\n    copy           If True, the data is copied before converting to QImage.\n                   If False, the new QImage points directly to the data in the array.\n                   Note that the array must be contiguous for this to work\n                   (see numpy.ascontiguousarray).\n    transpose      If True (the default), the array x/y axes are transposed before \n                   creating the image. Note that Qt expects the axes to be in \n                   (height, width) order whereas pyqtgraph usually prefers the \n                   opposite.\n    ============== ===================================================================    \n    """"""\n    ## create QImage from buffer\n    profile = debug.Profiler()\n    \n    ## If we didn\'t explicitly specify alpha, check the array shape.\n    if alpha is None:\n        alpha = (imgData.shape[2] == 4)\n        \n    copied = False\n    if imgData.shape[2] == 3:  ## need to make alpha channel (even if alpha==False; QImage requires 32 bpp)\n        if copy is True:\n            d2 = np.empty(imgData.shape[:2] + (4,), dtype=imgData.dtype)\n            d2[:,:,:3] = imgData\n            d2[:,:,3] = 255\n            imgData = d2\n            copied = True\n        else:\n            raise Exception(\'Array has only 3 channels; cannot make QImage without copying.\')\n    \n    if alpha:\n        imgFormat = QtGui.QImage.Format_ARGB32\n    else:\n        imgFormat = QtGui.QImage.Format_RGB32\n        \n    if transpose:\n        imgData = imgData.transpose((1, 0, 2))  ## QImage expects the row/column order to be opposite\n\n    profile()\n\n    if not imgData.flags[\'C_CONTIGUOUS\']:\n        if copy is False:\n            extra = \' (try setting transpose=False)\' if transpose else \'\'\n            raise Exception(\'Array is not contiguous; cannot make QImage without copying.\'+extra)\n        imgData = np.ascontiguousarray(imgData)\n        copied = True\n        \n    if copy is True and copied is False:\n        imgData = imgData.copy()\n        \n    if QT_LIB in [\'PySide\', \'PySide2\']:\n        ch = ctypes.c_char.from_buffer(imgData, 0)\n        \n        # Bug in PySide + Python 3 causes refcount for image data to be improperly \n        # incremented, which leads to leaked memory. As a workaround, we manually\n        # reset the reference count after creating the QImage.\n        # See: https://bugreports.qt.io/browse/PYSIDE-140\n        \n        # Get initial reference count (PyObject struct has ob_refcnt as first element)\n        rcount = ctypes.c_long.from_address(id(ch)).value\n        img = QtGui.QImage(ch, imgData.shape[1], imgData.shape[0], imgFormat)\n        if sys.version[0] == \'3\':\n            # Reset refcount only on python 3. Technically this would have no effect\n            # on python 2, but this is a nasty hack, and checking for version here \n            # helps to mitigate possible unforseen consequences.\n            ctypes.c_long.from_address(id(ch)).value = rcount\n    else:\n        #addr = ctypes.addressof(ctypes.c_char.from_buffer(imgData, 0))\n        ## PyQt API for QImage changed between 4.9.3 and 4.9.6 (I don\'t know exactly which version it was)\n        ## So we first attempt the 4.9.6 API, then fall back to 4.9.3\n        #addr = ctypes.c_char.from_buffer(imgData, 0)\n        #try:\n            #img = QtGui.QImage(addr, imgData.shape[1], imgData.shape[0], imgFormat)\n        #except TypeError:  \n            #addr = ctypes.addressof(addr)\n            #img = QtGui.QImage(addr, imgData.shape[1], imgData.shape[0], imgFormat)\n        try:\n            img = QtGui.QImage(imgData.ctypes.data, imgData.shape[1], imgData.shape[0], imgFormat)\n        except:\n            if copy:\n                # does not leak memory, is not mutable\n                img = QtGui.QImage(buffer(imgData), imgData.shape[1], imgData.shape[0], imgFormat)\n            else:\n                # mutable, but leaks memory\n                img = QtGui.QImage(memoryview(imgData), imgData.shape[1], imgData.shape[0], imgFormat)\n                \n    img.data = imgData\n    return img\n    #try:\n        #buf = imgData.data\n    #except AttributeError:  ## happens when image data is non-contiguous\n        #buf = imgData.data\n        \n    #profiler()\n    #qimage = QtGui.QImage(buf, imgData.shape[1], imgData.shape[0], imgFormat)\n    #profiler()\n    #qimage.data = imgData\n    #return qimage\n\ndef imageToArray(img, copy=False, transpose=True):\n    """"""\n    Convert a QImage into numpy array. The image must have format RGB32, ARGB32, or ARGB32_Premultiplied.\n    By default, the image is not copied; changes made to the array will appear in the QImage as well (beware: if \n    the QImage is collected before the array, there may be trouble).\n    The array will have shape (width, height, (b,g,r,a)).\n    """"""\n    fmt = img.format()\n    ptr = img.bits()\n    if QT_LIB in [\'PySide\', \'PySide2\']:\n        arr = np.frombuffer(ptr, dtype=np.ubyte)\n    else:\n        ptr.setsize(img.byteCount())\n        arr = np.asarray(ptr)\n        if img.byteCount() != arr.size * arr.itemsize:\n            # Required for Python 2.6, PyQt 4.10\n            # If this works on all platforms, then there is no need to use np.asarray..\n            arr = np.frombuffer(ptr, np.ubyte, img.byteCount())\n    \n    arr = arr.reshape(img.height(), img.width(), 4)\n    if fmt == img.Format_RGB32:\n        arr[...,3] = 255\n    \n    if copy:\n        arr = arr.copy()\n        \n    if transpose:\n        return arr.transpose((1,0,2))\n    else:\n        return arr\n    \ndef colorToAlpha(data, color):\n    """"""\n    Given an RGBA image in *data*, convert *color* to be transparent. \n    *data* must be an array (w, h, 3 or 4) of ubyte values and *color* must be \n    an array (3) of ubyte values.\n    This is particularly useful for use with images that have a black or white background.\n    \n    Algorithm is taken from Gimp\'s color-to-alpha function in plug-ins/common/colortoalpha.c\n    Credit:\n        /*\n        * Color To Alpha plug-in v1.0 by Seth Burgess, sjburges@gimp.org 1999/05/14\n        *  with algorithm by clahey\n        */\n    \n    """"""\n    data = data.astype(float)\n    if data.shape[-1] == 3:  ## add alpha channel if needed\n        d2 = np.empty(data.shape[:2]+(4,), dtype=data.dtype)\n        d2[...,:3] = data\n        d2[...,3] = 255\n        data = d2\n    \n    color = color.astype(float)\n    alpha = np.zeros(data.shape[:2]+(3,), dtype=float)\n    output = data.copy()\n    \n    for i in [0,1,2]:\n        d = data[...,i]\n        c = color[i]\n        mask = d > c\n        alpha[...,i][mask] = (d[mask] - c) / (255. - c)\n        imask = d < c\n        alpha[...,i][imask] = (c - d[imask]) / c\n    \n    output[...,3] = alpha.max(axis=2) * 255.\n    \n    mask = output[...,3] >= 1.0  ## avoid zero division while processing alpha channel\n    correction = 255. / output[...,3][mask]  ## increase value to compensate for decreased alpha\n    for i in [0,1,2]:\n        output[...,i][mask] = ((output[...,i][mask]-color[i]) * correction) + color[i]\n        output[...,3][mask] *= data[...,3][mask] / 255.  ## combine computed and previous alpha values\n    \n    #raise Exception()\n    return np.clip(output, 0, 255).astype(np.ubyte)\n\ndef gaussianFilter(data, sigma):\n    """"""\n    Drop-in replacement for scipy.ndimage.gaussian_filter.\n    \n    (note: results are only approximately equal to the output of\n     gaussian_filter)\n    """"""\n    if np.isscalar(sigma):\n        sigma = (sigma,) * data.ndim\n        \n    baseline = data.mean()\n    filtered = data - baseline\n    for ax in range(data.ndim):\n        s = sigma[ax]\n        if s == 0:\n            continue\n        \n        # generate 1D gaussian kernel\n        ksize = int(s * 6)\n        x = np.arange(-ksize, ksize)\n        kernel = np.exp(-x**2 / (2*s**2))\n        kshape = [1,] * data.ndim\n        kshape[ax] = len(kernel)\n        kernel = kernel.reshape(kshape)\n        \n        # convolve as product of FFTs\n        shape = data.shape[ax] + ksize\n        scale = 1.0 / (abs(s) * (2*np.pi)**0.5)\n        filtered = scale * np.fft.irfft(np.fft.rfft(filtered, shape, axis=ax) * \n                                        np.fft.rfft(kernel, shape, axis=ax), \n                                        axis=ax)\n        \n        # clip off extra data\n        sl = [slice(None)] * data.ndim\n        sl[ax] = slice(filtered.shape[ax]-data.shape[ax],None,None)\n        filtered = filtered[sl]\n    return filtered + baseline\n    \n    \ndef downsample(data, n, axis=0, xvals=\'subsample\'):\n    """"""Downsample by averaging points together across axis.\n    If multiple axes are specified, runs once per axis.\n    If a metaArray is given, then the axis values can be either subsampled\n    or downsampled to match.\n    """"""\n    ma = None\n    if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        ma = data\n        data = data.view(np.ndarray)\n        \n    \n    if hasattr(axis, \'__len__\'):\n        if not hasattr(n, \'__len__\'):\n            n = [n]*len(axis)\n        for i in range(len(axis)):\n            data = downsample(data, n[i], axis[i])\n        return data\n    \n    if n <= 1:\n        return data\n    nPts = int(data.shape[axis] / n)\n    s = list(data.shape)\n    s[axis] = nPts\n    s.insert(axis+1, n)\n    sl = [slice(None)] * data.ndim\n    sl[axis] = slice(0, nPts*n)\n    d1 = data[tuple(sl)]\n    #print d1.shape, s\n    d1.shape = tuple(s)\n    d2 = d1.mean(axis+1)\n    \n    if ma is None:\n        return d2\n    else:\n        info = ma.infoCopy()\n        if \'values\' in info[axis]:\n            if xvals == \'subsample\':\n                info[axis][\'values\'] = info[axis][\'values\'][::n][:nPts]\n            elif xvals == \'downsample\':\n                info[axis][\'values\'] = downsample(info[axis][\'values\'], n)\n        return MetaArray(d2, info=info)\n\n\ndef arrayToQPath(x, y, connect=\'all\'):\n    """"""Convert an array of x,y coordinats to QPainterPath as efficiently as possible.\n    The *connect* argument may be \'all\', indicating that each point should be\n    connected to the next; \'pairs\', indicating that each pair of points\n    should be connected, or an array of int32 values (0 or 1) indicating\n    connections.\n    """"""\n\n    ## Create all vertices in path. The method used below creates a binary format so that all\n    ## vertices can be read in at once. This binary format may change in future versions of Qt,\n    ## so the original (slower) method is left here for emergencies:\n        #path.moveTo(x[0], y[0])\n        #if connect == \'all\':\n            #for i in range(1, y.shape[0]):\n                #path.lineTo(x[i], y[i])\n        #elif connect == \'pairs\':\n            #for i in range(1, y.shape[0]):\n                #if i%2 == 0:\n                    #path.lineTo(x[i], y[i])\n                #else:\n                    #path.moveTo(x[i], y[i])\n        #elif isinstance(connect, np.ndarray):\n            #for i in range(1, y.shape[0]):\n                #if connect[i] == 1:\n                    #path.lineTo(x[i], y[i])\n                #else:\n                    #path.moveTo(x[i], y[i])\n        #else:\n            #raise Exception(\'connect argument must be ""all"", ""pairs"", or array\')\n\n    ## Speed this up using >> operator\n    ## Format is:\n    ##    numVerts(i4)   0(i4)\n    ##    x(f8)   y(f8)   0(i4)    <-- 0 means this vertex does not connect\n    ##    x(f8)   y(f8)   1(i4)    <-- 1 means this vertex connects to the previous vertex\n    ##    ...\n    ##    0(i4)\n    ##\n    ## All values are big endian--pack using struct.pack(\'>d\') or struct.pack(\'>i\')\n\n    path = QtGui.QPainterPath()\n\n    #profiler = debug.Profiler()\n    n = x.shape[0]\n    # create empty array, pad with extra space on either end\n    arr = np.empty(n+2, dtype=[(\'x\', \'>f8\'), (\'y\', \'>f8\'), (\'c\', \'>i4\')])\n    # write first two integers\n    #profiler(\'allocate empty\')\n    byteview = arr.view(dtype=np.ubyte)\n    byteview[:12] = 0\n    byteview.data[12:20] = struct.pack(\'>ii\', n, 0)\n    #profiler(\'pack header\')\n    # Fill array with vertex values\n    arr[1:-1][\'x\'] = x\n    arr[1:-1][\'y\'] = y\n\n    # decide which points are connected by lines\n    if eq(connect, \'all\'):\n        arr[1:-1][\'c\'] = 1\n    elif eq(connect, \'pairs\'):\n        arr[1:-1][\'c\'][::2] = 1\n        arr[1:-1][\'c\'][1::2] = 0\n    elif eq(connect, \'finite\'):\n        arr[1:-1][\'c\'] = np.isfinite(x) & np.isfinite(y)\n    elif isinstance(connect, np.ndarray):\n        arr[1:-1][\'c\'] = connect\n    else:\n        raise Exception(\'connect argument must be ""all"", ""pairs"", ""finite"", or array\')\n\n    #profiler(\'fill array\')\n    # write last 0\n    lastInd = 20*(n+1)\n    byteview.data[lastInd:lastInd+4] = struct.pack(\'>i\', 0)\n    #profiler(\'footer\')\n    # create datastream object and stream into path\n\n    ## Avoiding this method because QByteArray(str) leaks memory in PySide\n    #buf = QtCore.QByteArray(arr.data[12:lastInd+4])  # I think one unnecessary copy happens here\n\n    path.strn = byteview.data[12:lastInd+4] # make sure data doesn\'t run away\n    try:\n        buf = QtCore.QByteArray.fromRawData(path.strn)\n    except TypeError:\n        buf = QtCore.QByteArray(bytes(path.strn))\n    #profiler(\'create buffer\')\n    ds = QtCore.QDataStream(buf)\n\n    ds >> path\n    #profiler(\'load\')\n\n    return path\n\n#def isosurface(data, level):\n    #""""""\n    #Generate isosurface from volumetric data using marching tetrahedra algorithm.\n    #See Paul Bourke, ""Polygonising a Scalar Field Using Tetrahedrons""  (http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/)\n    \n    #*data*   3D numpy array of scalar values\n    #*level*  The level at which to generate an isosurface\n    #""""""\n    \n    #facets = []\n    \n    ### mark everything below the isosurface level\n    #mask = data < level\n    \n    #### make eight sub-fields \n    #fields = np.empty((2,2,2), dtype=object)\n    #slices = [slice(0,-1), slice(1,None)]\n    #for i in [0,1]:\n        #for j in [0,1]:\n            #for k in [0,1]:\n                #fields[i,j,k] = mask[slices[i], slices[j], slices[k]]\n    \n    \n    \n    ### split each cell into 6 tetrahedra\n    ### these all have the same \'orienation\'; points 1,2,3 circle \n    ### clockwise around point 0\n    #tetrahedra = [\n        #[(0,1,0), (1,1,1), (0,1,1), (1,0,1)],\n        #[(0,1,0), (0,1,1), (0,0,1), (1,0,1)],\n        #[(0,1,0), (0,0,1), (0,0,0), (1,0,1)],\n        #[(0,1,0), (0,0,0), (1,0,0), (1,0,1)],\n        #[(0,1,0), (1,0,0), (1,1,0), (1,0,1)],\n        #[(0,1,0), (1,1,0), (1,1,1), (1,0,1)]\n    #]\n    \n    ### each tetrahedron will be assigned an index\n    ### which determines how to generate its facets.\n    ### this structure is: \n    ###    facets[index][facet1, facet2, ...]\n    ### where each facet is triangular and its points are each \n    ### interpolated between two points on the tetrahedron\n    ###    facet = [(p1a, p1b), (p2a, p2b), (p3a, p3b)]\n    ### facet points always circle clockwise if you are looking \n    ### at them from below the isosurface.\n    #indexFacets = [\n        #[],  ## all above\n        #[[(0,1), (0,2), (0,3)]],  # 0 below\n        #[[(1,0), (1,3), (1,2)]],   # 1 below\n        #[[(0,2), (1,3), (1,2)], [(0,2), (0,3), (1,3)]],   # 0,1 below\n        #[[(2,0), (2,1), (2,3)]],   # 2 below\n        #[[(0,3), (1,2), (2,3)], [(0,3), (0,1), (1,2)]],   # 0,2 below\n        #[[(1,0), (2,3), (2,0)], [(1,0), (1,3), (2,3)]],   # 1,2 below\n        #[[(3,0), (3,1), (3,2)]],   # 3 above\n        #[[(3,0), (3,2), (3,1)]],   # 3 below\n        #[[(1,0), (2,0), (2,3)], [(1,0), (2,3), (1,3)]],   # 0,3 below\n        #[[(0,3), (2,3), (1,2)], [(0,3), (1,2), (0,1)]],   # 1,3 below\n        #[[(2,0), (2,3), (2,1)]], # 0,1,3 below\n        #[[(0,2), (1,2), (1,3)], [(0,2), (1,3), (0,3)]],   # 2,3 below\n        #[[(1,0), (1,2), (1,3)]], # 0,2,3 below\n        #[[(0,1), (0,3), (0,2)]], # 1,2,3 below\n        #[]  ## all below\n    #]\n    \n    #for tet in tetrahedra:\n        \n        ### get the 4 fields for this tetrahedron\n        #tetFields = [fields[c] for c in tet]\n        \n        ### generate an index for each grid cell\n        #index = tetFields[0] + tetFields[1]*2 + tetFields[2]*4 + tetFields[3]*8\n        \n        ### add facets\n        #for i in xrange(index.shape[0]):                 # data x-axis\n            #for j in xrange(index.shape[1]):             # data y-axis\n                #for k in xrange(index.shape[2]):         # data z-axis\n                    #for f in indexFacets[index[i,j,k]]:  # faces to generate for this tet\n                        #pts = []\n                        #for l in [0,1,2]:      # points in this face\n                            #p1 = tet[f[l][0]]  # tet corner 1\n                            #p2 = tet[f[l][1]]  # tet corner 2\n                            #pts.append([(p1[x]+p2[x])*0.5+[i,j,k][x]+0.5 for x in [0,1,2]]) ## interpolate between tet corners\n                        #facets.append(pts)\n\n    #return facets\n    \n\ndef isocurve(data, level, connected=False, extendToEdge=False, path=False):\n    """"""\n    Generate isocurve from 2D data using marching squares algorithm.\n    \n    ============== =========================================================\n    **Arguments:**\n    data           2D numpy array of scalar values\n    level          The level at which to generate an isosurface\n    connected      If False, return a single long list of point pairs\n                   If True, return multiple long lists of connected point \n                   locations. (This is slower but better for drawing \n                   continuous lines)\n    extendToEdge   If True, extend the curves to reach the exact edges of \n                   the data. \n    path           if True, return a QPainterPath rather than a list of \n                   vertex coordinates. This forces connected=True.\n    ============== =========================================================\n    \n    This function is SLOW; plenty of room for optimization here.\n    """"""    \n    \n    if path is True:\n        connected = True\n    \n    if extendToEdge:\n        d2 = np.empty((data.shape[0]+2, data.shape[1]+2), dtype=data.dtype)\n        d2[1:-1, 1:-1] = data\n        d2[0, 1:-1] = data[0]\n        d2[-1, 1:-1] = data[-1]\n        d2[1:-1, 0] = data[:, 0]\n        d2[1:-1, -1] = data[:, -1]\n        d2[0,0] = d2[0,1]\n        d2[0,-1] = d2[1,-1]\n        d2[-1,0] = d2[-1,1]\n        d2[-1,-1] = d2[-1,-2]\n        data = d2\n    \n    sideTable = [\n        [],\n        [0,1],\n        [1,2],\n        [0,2],\n        [0,3],\n        [1,3],\n        [0,1,2,3],\n        [2,3],\n        [2,3],\n        [0,1,2,3],\n        [1,3],\n        [0,3],\n        [0,2],\n        [1,2],\n        [0,1],\n        []\n        ]\n    \n    edgeKey=[\n        [(0,1), (0,0)],\n        [(0,0), (1,0)],\n        [(1,0), (1,1)],\n        [(1,1), (0,1)]\n        ]\n    \n    \n    lines = []\n    \n    ## mark everything below the isosurface level\n    mask = data < level\n    \n    ### make four sub-fields and compute indexes for grid cells\n    index = np.zeros([x-1 for x in data.shape], dtype=np.ubyte)\n    fields = np.empty((2,2), dtype=object)\n    slices = [slice(0,-1), slice(1,None)]\n    for i in [0,1]:\n        for j in [0,1]:\n            fields[i,j] = mask[slices[i], slices[j]]\n            #vertIndex = i - 2*j*i + 3*j + 4*k  ## this is just to match Bourk\'s vertex numbering scheme\n            vertIndex = i+2*j\n            #print i,j,k,"" : "", fields[i,j,k], 2**vertIndex\n            np.add(index, fields[i,j] * 2**vertIndex, out=index, casting=\'unsafe\')\n            #print index\n    #print index\n    \n    ## add lines\n    for i in range(index.shape[0]):                 # data x-axis\n        for j in range(index.shape[1]):             # data y-axis     \n            sides = sideTable[index[i,j]]\n            for l in range(0, len(sides), 2):     ## faces for this grid cell\n                edges = sides[l:l+2]\n                pts = []\n                for m in [0,1]:      # points in this face\n                    p1 = edgeKey[edges[m]][0] # p1, p2 are points at either side of an edge\n                    p2 = edgeKey[edges[m]][1]\n                    v1 = data[i+p1[0], j+p1[1]] # v1 and v2 are the values at p1 and p2\n                    v2 = data[i+p2[0], j+p2[1]]\n                    f = (level-v1) / (v2-v1)\n                    fi = 1.0 - f\n                    p = (    ## interpolate between corners\n                        p1[0]*fi + p2[0]*f + i + 0.5, \n                        p1[1]*fi + p2[1]*f + j + 0.5\n                        )\n                    if extendToEdge:\n                        ## check bounds\n                        p = (\n                            min(data.shape[0]-2, max(0, p[0]-1)),\n                            min(data.shape[1]-2, max(0, p[1]-1)),                        \n                        )\n                    if connected:\n                        gridKey = i + (1 if edges[m]==2 else 0), j + (1 if edges[m]==3 else 0), edges[m]%2\n                        pts.append((p, gridKey))  ## give the actual position and a key identifying the grid location (for connecting segments)\n                    else:\n                        pts.append(p)\n                \n                lines.append(pts)\n\n    if not connected:\n        return lines\n                \n    ## turn disjoint list of segments into continuous lines\n\n    #lines = [[2,5], [5,4], [3,4], [1,3], [6,7], [7,8], [8,6], [11,12], [12,15], [11,13], [13,14]]\n    #lines = [[(float(a), a), (float(b), b)] for a,b in lines]\n    points = {}  ## maps each point to its connections\n    for a,b in lines:\n        if a[1] not in points:\n            points[a[1]] = []\n        points[a[1]].append([a,b])\n        if b[1] not in points:\n            points[b[1]] = []\n        points[b[1]].append([b,a])\n\n    ## rearrange into chains\n    for k in list(points.keys()):\n        try:\n            chains = points[k]\n        except KeyError:   ## already used this point elsewhere\n            continue\n        #print ""==========="", k\n        for chain in chains:\n            #print ""  chain:"", chain\n            x = None\n            while True:\n                if x == chain[-1][1]:\n                    break ## nothing left to do on this chain\n                    \n                x = chain[-1][1]\n                if x == k:  \n                    break ## chain has looped; we\'re done and can ignore the opposite chain\n                y = chain[-2][1]\n                connects = points[x]\n                for conn in connects[:]:\n                    if conn[1][1] != y:\n                        #print ""    ext:"", conn\n                        chain.extend(conn[1:])\n                #print ""    del:"", x\n                del points[x]\n            if chain[0][1] == chain[-1][1]:  # looped chain; no need to continue the other direction\n                chains.pop()\n                break\n                \n\n    ## extract point locations \n    lines = []\n    for chain in points.values():\n        if len(chain) == 2:\n            chain = chain[1][1:][::-1] + chain[0]  # join together ends of chain\n        else:\n            chain = chain[0]\n        lines.append([p[0] for p in chain])\n    \n    if not path:\n        return lines ## a list of pairs of points\n    \n    path = QtGui.QPainterPath()\n    for line in lines:\n        path.moveTo(*line[0])\n        for p in line[1:]:\n            path.lineTo(*p)\n    \n    return path\n    \n    \ndef traceImage(image, values, smooth=0.5):\n    """"""\n    Convert an image to a set of QPainterPath curves.\n    One curve will be generated for each item in *values*; each curve outlines the area\n    of the image that is closer to its value than to any others.\n    \n    If image is RGB or RGBA, then the shape of values should be (nvals, 3/4)\n    The parameter *smooth* is expressed in pixels.\n    """"""\n    try:\n        import scipy.ndimage as ndi\n    except ImportError:\n        raise Exception(""traceImage() requires the package scipy.ndimage, but it is not importable."")\n    \n    if values.ndim == 2:\n        values = values.T\n    values = values[np.newaxis, np.newaxis, ...].astype(float)\n    image = image[..., np.newaxis].astype(float)\n    diff = np.abs(image-values)\n    if values.ndim == 4:\n        diff = diff.sum(axis=2)\n        \n    labels = np.argmin(diff, axis=2)\n    \n    paths = []\n    for i in range(diff.shape[-1]):    \n        d = (labels==i).astype(float)\n        d = gaussianFilter(d, (smooth, smooth))\n        lines = isocurve(d, 0.5, connected=True, extendToEdge=True)\n        path = QtGui.QPainterPath()\n        for line in lines:\n            path.moveTo(*line[0])\n            for p in line[1:]:\n                path.lineTo(*p)\n        \n        paths.append(path)\n    return paths\n    \n    \n    \nIsosurfaceDataCache = None\ndef isosurface(data, level):\n    """"""\n    Generate isosurface from volumetric data using marching cubes algorithm.\n    See Paul Bourke, ""Polygonising a Scalar Field""  \n    (http://paulbourke.net/geometry/polygonise/)\n    \n    *data*   3D numpy array of scalar values. Must be contiguous.\n    *level*  The level at which to generate an isosurface\n    \n    Returns an array of vertex coordinates (Nv, 3) and an array of \n    per-face vertex indexes (Nf, 3)    \n    """"""\n    ## For improvement, see:\n    ## \n    ## Efficient implementation of Marching Cubes\' cases with topological guarantees.\n    ## Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan Tavares.\n    ## Journal of Graphics Tools 8(2): pp. 1-15 (december 2003)\n    \n    ## Precompute lookup tables on the first run\n    global IsosurfaceDataCache\n    if IsosurfaceDataCache is None:\n        ## map from grid cell index to edge index.\n        ## grid cell index tells us which corners are below the isosurface,\n        ## edge index tells us which edges are cut by the isosurface.\n        ## (Data stolen from Bourk; see above.)\n        edgeTable = np.array([\n            0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,\n            0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,\n            0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,\n            0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,\n            0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,\n            0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,\n            0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,\n            0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,\n            0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,\n            0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,\n            0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,\n            0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,\n            0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,\n            0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,\n            0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,\n            0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,\n            0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,\n            0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,\n            0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,\n            0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,\n            0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,\n            0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,\n            0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,\n            0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,\n            0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,\n            0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,\n            0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,\n            0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,\n            0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,\n            0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,\n            0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,\n            0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0   \n            ], dtype=np.uint16)\n        \n        ## Table of triangles to use for filling each grid cell.\n        ## Each set of three integers tells us which three edges to\n        ## draw a triangle between.\n        ## (Data stolen from Bourk; see above.)\n        triTable = [\n            [],\n            [0, 8, 3],\n            [0, 1, 9],\n            [1, 8, 3, 9, 8, 1],\n            [1, 2, 10],\n            [0, 8, 3, 1, 2, 10],\n            [9, 2, 10, 0, 2, 9],\n            [2, 8, 3, 2, 10, 8, 10, 9, 8],\n            [3, 11, 2],\n            [0, 11, 2, 8, 11, 0],\n            [1, 9, 0, 2, 3, 11],\n            [1, 11, 2, 1, 9, 11, 9, 8, 11],\n            [3, 10, 1, 11, 10, 3],\n            [0, 10, 1, 0, 8, 10, 8, 11, 10],\n            [3, 9, 0, 3, 11, 9, 11, 10, 9],\n            [9, 8, 10, 10, 8, 11],\n            [4, 7, 8],\n            [4, 3, 0, 7, 3, 4],\n            [0, 1, 9, 8, 4, 7],\n            [4, 1, 9, 4, 7, 1, 7, 3, 1],\n            [1, 2, 10, 8, 4, 7],\n            [3, 4, 7, 3, 0, 4, 1, 2, 10],\n            [9, 2, 10, 9, 0, 2, 8, 4, 7],\n            [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4],\n            [8, 4, 7, 3, 11, 2],\n            [11, 4, 7, 11, 2, 4, 2, 0, 4],\n            [9, 0, 1, 8, 4, 7, 2, 3, 11],\n            [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1],\n            [3, 10, 1, 3, 11, 10, 7, 8, 4],\n            [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4],\n            [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3],\n            [4, 7, 11, 4, 11, 9, 9, 11, 10],\n            [9, 5, 4],\n            [9, 5, 4, 0, 8, 3],\n            [0, 5, 4, 1, 5, 0],\n            [8, 5, 4, 8, 3, 5, 3, 1, 5],\n            [1, 2, 10, 9, 5, 4],\n            [3, 0, 8, 1, 2, 10, 4, 9, 5],\n            [5, 2, 10, 5, 4, 2, 4, 0, 2],\n            [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8],\n            [9, 5, 4, 2, 3, 11],\n            [0, 11, 2, 0, 8, 11, 4, 9, 5],\n            [0, 5, 4, 0, 1, 5, 2, 3, 11],\n            [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5],\n            [10, 3, 11, 10, 1, 3, 9, 5, 4],\n            [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10],\n            [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3],\n            [5, 4, 8, 5, 8, 10, 10, 8, 11],\n            [9, 7, 8, 5, 7, 9],\n            [9, 3, 0, 9, 5, 3, 5, 7, 3],\n            [0, 7, 8, 0, 1, 7, 1, 5, 7],\n            [1, 5, 3, 3, 5, 7],\n            [9, 7, 8, 9, 5, 7, 10, 1, 2],\n            [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3],\n            [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2],\n            [2, 10, 5, 2, 5, 3, 3, 5, 7],\n            [7, 9, 5, 7, 8, 9, 3, 11, 2],\n            [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11],\n            [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7],\n            [11, 2, 1, 11, 1, 7, 7, 1, 5],\n            [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11],\n            [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0],\n            [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0],\n            [11, 10, 5, 7, 11, 5],\n            [10, 6, 5],\n            [0, 8, 3, 5, 10, 6],\n            [9, 0, 1, 5, 10, 6],\n            [1, 8, 3, 1, 9, 8, 5, 10, 6],\n            [1, 6, 5, 2, 6, 1],\n            [1, 6, 5, 1, 2, 6, 3, 0, 8],\n            [9, 6, 5, 9, 0, 6, 0, 2, 6],\n            [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8],\n            [2, 3, 11, 10, 6, 5],\n            [11, 0, 8, 11, 2, 0, 10, 6, 5],\n            [0, 1, 9, 2, 3, 11, 5, 10, 6],\n            [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11],\n            [6, 3, 11, 6, 5, 3, 5, 1, 3],\n            [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6],\n            [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9],\n            [6, 5, 9, 6, 9, 11, 11, 9, 8],\n            [5, 10, 6, 4, 7, 8],\n            [4, 3, 0, 4, 7, 3, 6, 5, 10],\n            [1, 9, 0, 5, 10, 6, 8, 4, 7],\n            [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4],\n            [6, 1, 2, 6, 5, 1, 4, 7, 8],\n            [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7],\n            [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6],\n            [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9],\n            [3, 11, 2, 7, 8, 4, 10, 6, 5],\n            [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11],\n            [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6],\n            [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6],\n            [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6],\n            [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11],\n            [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7],\n            [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9],\n            [10, 4, 9, 6, 4, 10],\n            [4, 10, 6, 4, 9, 10, 0, 8, 3],\n            [10, 0, 1, 10, 6, 0, 6, 4, 0],\n            [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10],\n            [1, 4, 9, 1, 2, 4, 2, 6, 4],\n            [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4],\n            [0, 2, 4, 4, 2, 6],\n            [8, 3, 2, 8, 2, 4, 4, 2, 6],\n            [10, 4, 9, 10, 6, 4, 11, 2, 3],\n            [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6],\n            [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10],\n            [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1],\n            [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3],\n            [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1],\n            [3, 11, 6, 3, 6, 0, 0, 6, 4],\n            [6, 4, 8, 11, 6, 8],\n            [7, 10, 6, 7, 8, 10, 8, 9, 10],\n            [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10],\n            [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0],\n            [10, 6, 7, 10, 7, 1, 1, 7, 3],\n            [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7],\n            [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9],\n            [7, 8, 0, 7, 0, 6, 6, 0, 2],\n            [7, 3, 2, 6, 7, 2],\n            [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7],\n            [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7],\n            [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11],\n            [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1],\n            [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6],\n            [0, 9, 1, 11, 6, 7],\n            [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0],\n            [7, 11, 6],\n            [7, 6, 11],\n            [3, 0, 8, 11, 7, 6],\n            [0, 1, 9, 11, 7, 6],\n            [8, 1, 9, 8, 3, 1, 11, 7, 6],\n            [10, 1, 2, 6, 11, 7],\n            [1, 2, 10, 3, 0, 8, 6, 11, 7],\n            [2, 9, 0, 2, 10, 9, 6, 11, 7],\n            [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8],\n            [7, 2, 3, 6, 2, 7],\n            [7, 0, 8, 7, 6, 0, 6, 2, 0],\n            [2, 7, 6, 2, 3, 7, 0, 1, 9],\n            [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6],\n            [10, 7, 6, 10, 1, 7, 1, 3, 7],\n            [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8],\n            [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7],\n            [7, 6, 10, 7, 10, 8, 8, 10, 9],\n            [6, 8, 4, 11, 8, 6],\n            [3, 6, 11, 3, 0, 6, 0, 4, 6],\n            [8, 6, 11, 8, 4, 6, 9, 0, 1],\n            [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6],\n            [6, 8, 4, 6, 11, 8, 2, 10, 1],\n            [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6],\n            [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9],\n            [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3],\n            [8, 2, 3, 8, 4, 2, 4, 6, 2],\n            [0, 4, 2, 4, 6, 2],\n            [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8],\n            [1, 9, 4, 1, 4, 2, 2, 4, 6],\n            [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1],\n            [10, 1, 0, 10, 0, 6, 6, 0, 4],\n            [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3],\n            [10, 9, 4, 6, 10, 4],\n            [4, 9, 5, 7, 6, 11],\n            [0, 8, 3, 4, 9, 5, 11, 7, 6],\n            [5, 0, 1, 5, 4, 0, 7, 6, 11],\n            [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5],\n            [9, 5, 4, 10, 1, 2, 7, 6, 11],\n            [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5],\n            [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2],\n            [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6],\n            [7, 2, 3, 7, 6, 2, 5, 4, 9],\n            [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7],\n            [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0],\n            [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8],\n            [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7],\n            [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4],\n            [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10],\n            [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10],\n            [6, 9, 5, 6, 11, 9, 11, 8, 9],\n            [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5],\n            [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11],\n            [6, 11, 3, 6, 3, 5, 5, 3, 1],\n            [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6],\n            [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10],\n            [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5],\n            [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3],\n            [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2],\n            [9, 5, 6, 9, 6, 0, 0, 6, 2],\n            [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8],\n            [1, 5, 6, 2, 1, 6],\n            [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6],\n            [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0],\n            [0, 3, 8, 5, 6, 10],\n            [10, 5, 6],\n            [11, 5, 10, 7, 5, 11],\n            [11, 5, 10, 11, 7, 5, 8, 3, 0],\n            [5, 11, 7, 5, 10, 11, 1, 9, 0],\n            [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1],\n            [11, 1, 2, 11, 7, 1, 7, 5, 1],\n            [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11],\n            [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7],\n            [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2],\n            [2, 5, 10, 2, 3, 5, 3, 7, 5],\n            [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5],\n            [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2],\n            [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2],\n            [1, 3, 5, 3, 7, 5],\n            [0, 8, 7, 0, 7, 1, 1, 7, 5],\n            [9, 0, 3, 9, 3, 5, 5, 3, 7],\n            [9, 8, 7, 5, 9, 7],\n            [5, 8, 4, 5, 10, 8, 10, 11, 8],\n            [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0],\n            [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5],\n            [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4],\n            [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8],\n            [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11],\n            [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5],\n            [9, 4, 5, 2, 11, 3],\n            [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4],\n            [5, 10, 2, 5, 2, 4, 4, 2, 0],\n            [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9],\n            [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2],\n            [8, 4, 5, 8, 5, 3, 3, 5, 1],\n            [0, 4, 5, 1, 0, 5],\n            [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5],\n            [9, 4, 5],\n            [4, 11, 7, 4, 9, 11, 9, 10, 11],\n            [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11],\n            [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11],\n            [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4],\n            [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2],\n            [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3],\n            [11, 7, 4, 11, 4, 2, 2, 4, 0],\n            [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4],\n            [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9],\n            [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7],\n            [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10],\n            [1, 10, 2, 8, 7, 4],\n            [4, 9, 1, 4, 1, 7, 7, 1, 3],\n            [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1],\n            [4, 0, 3, 7, 4, 3],\n            [4, 8, 7],\n            [9, 10, 8, 10, 11, 8],\n            [3, 0, 9, 3, 9, 11, 11, 9, 10],\n            [0, 1, 10, 0, 10, 8, 8, 10, 11],\n            [3, 1, 10, 11, 3, 10],\n            [1, 2, 11, 1, 11, 9, 9, 11, 8],\n            [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9],\n            [0, 2, 11, 8, 0, 11],\n            [3, 2, 11],\n            [2, 3, 8, 2, 8, 10, 10, 8, 9],\n            [9, 10, 2, 0, 9, 2],\n            [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8],\n            [1, 10, 2],\n            [1, 3, 8, 9, 1, 8],\n            [0, 9, 1],\n            [0, 3, 8],\n            []\n        ]    \n        edgeShifts = np.array([  ## maps edge ID (0-11) to (x,y,z) cell offset and edge ID (0-2)\n            [0, 0, 0, 0],   \n            [1, 0, 0, 1],\n            [0, 1, 0, 0],\n            [0, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 1],\n            [0, 1, 1, 0],\n            [0, 0, 1, 1],\n            [0, 0, 0, 2],\n            [1, 0, 0, 2],\n            [1, 1, 0, 2],\n            [0, 1, 0, 2],\n            #[9, 9, 9, 9]  ## fake\n        ], dtype=np.uint16) # don\'t use ubyte here! This value gets added to cell index later; will need the extra precision.\n        nTableFaces = np.array([len(f)/3 for f in triTable], dtype=np.ubyte)\n        faceShiftTables = [None]\n        for i in range(1,6):\n            ## compute lookup table of index: vertexes mapping\n            faceTableI = np.zeros((len(triTable), i*3), dtype=np.ubyte)\n            faceTableInds = np.argwhere(nTableFaces == i)\n            faceTableI[faceTableInds[:,0]] = np.array([triTable[j[0]] for j in faceTableInds])\n            faceTableI = faceTableI.reshape((len(triTable), i, 3))\n            faceShiftTables.append(edgeShifts[faceTableI])\n            \n        ## Let\'s try something different:\n        #faceTable = np.empty((256, 5, 3, 4), dtype=np.ubyte)   # (grid cell index, faces, vertexes, edge lookup)\n        #for i,f in enumerate(triTable):\n            #f = np.array(f + [12] * (15-len(f))).reshape(5,3)\n            #faceTable[i] = edgeShifts[f]\n        \n        \n        IsosurfaceDataCache = (faceShiftTables, edgeShifts, edgeTable, nTableFaces)\n    else:\n        faceShiftTables, edgeShifts, edgeTable, nTableFaces = IsosurfaceDataCache\n\n    # We use strides below, which means we need contiguous array input.\n    # Ideally we can fix this just by removing the dependency on strides.\n    if not data.flags[\'C_CONTIGUOUS\']:\n        raise TypeError(""isosurface input data must be c-contiguous."")\n    \n    ## mark everything below the isosurface level\n    mask = data < level\n    \n    ### make eight sub-fields and compute indexes for grid cells\n    index = np.zeros([x-1 for x in data.shape], dtype=np.ubyte)\n    fields = np.empty((2,2,2), dtype=object)\n    slices = [slice(0,-1), slice(1,None)]\n    for i in [0,1]:\n        for j in [0,1]:\n            for k in [0,1]:\n                fields[i,j,k] = mask[slices[i], slices[j], slices[k]]\n                vertIndex = i - 2*j*i + 3*j + 4*k  ## this is just to match Bourk\'s vertex numbering scheme\n                np.add(index, fields[i,j,k] * 2**vertIndex, out=index, casting=\'unsafe\')\n    \n    ### Generate table of edges that have been cut\n    cutEdges = np.zeros([x+1 for x in index.shape]+[3], dtype=np.uint32)\n    edges = edgeTable[index]\n    for i, shift in enumerate(edgeShifts[:12]):        \n        slices = [slice(shift[j],cutEdges.shape[j]+(shift[j]-1)) for j in range(3)]\n        cutEdges[slices[0], slices[1], slices[2], shift[3]] += edges & 2**i\n    \n    ## for each cut edge, interpolate to see where exactly the edge is cut and generate vertex positions\n    m = cutEdges > 0\n    vertexInds = np.argwhere(m)   ## argwhere is slow!\n    vertexes = vertexInds[:,:3].astype(np.float32)\n    dataFlat = data.reshape(data.shape[0]*data.shape[1]*data.shape[2])\n    \n    ## re-use the cutEdges array as a lookup table for vertex IDs\n    cutEdges[vertexInds[:,0], vertexInds[:,1], vertexInds[:,2], vertexInds[:,3]] = np.arange(vertexInds.shape[0])\n    \n    for i in [0,1,2]:\n        vim = vertexInds[:,3] == i\n        vi = vertexInds[vim, :3]\n        viFlat = (vi * (np.array(data.strides[:3]) // data.itemsize)[np.newaxis,:]).sum(axis=1)\n        v1 = dataFlat[viFlat]\n        v2 = dataFlat[viFlat + data.strides[i]//data.itemsize]\n        vertexes[vim,i] += (level-v1) / (v2-v1)\n    \n    ### compute the set of vertex indexes for each face. \n    \n    ## This works, but runs a bit slower.\n    #cells = np.argwhere((index != 0) & (index != 255))  ## all cells with at least one face\n    #cellInds = index[cells[:,0], cells[:,1], cells[:,2]]\n    #verts = faceTable[cellInds]\n    #mask = verts[...,0,0] != 9\n    #verts[...,:3] += cells[:,np.newaxis,np.newaxis,:]  ## we now have indexes into cutEdges\n    #verts = verts[mask]\n    #faces = cutEdges[verts[...,0], verts[...,1], verts[...,2], verts[...,3]]  ## and these are the vertex indexes we want.\n    \n    \n    ## To allow this to be vectorized efficiently, we count the number of faces in each \n    ## grid cell and handle each group of cells with the same number together.\n    ## determine how many faces to assign to each grid cell\n    nFaces = nTableFaces[index]\n    totFaces = nFaces.sum()\n    faces = np.empty((totFaces, 3), dtype=np.uint32)\n    ptr = 0\n    #import debug\n    #p = debug.Profiler()\n    \n    ## this helps speed up an indexing operation later on\n    cs = np.array(cutEdges.strides)//cutEdges.itemsize\n    cutEdges = cutEdges.flatten()\n\n    ## this, strangely, does not seem to help.\n    #ins = np.array(index.strides)/index.itemsize\n    #index = index.flatten()\n\n    for i in range(1,6):\n        ### expensive:\n        #profiler()\n        cells = np.argwhere(nFaces == i)  ## all cells which require i faces  (argwhere is expensive)\n        #profiler()\n        if cells.shape[0] == 0:\n            continue\n        cellInds = index[cells[:,0], cells[:,1], cells[:,2]]   ## index values of cells to process for this round\n        #profiler()\n        \n        ### expensive:\n        verts = faceShiftTables[i][cellInds]\n        #profiler()\n        np.add(verts[...,:3], cells[:,np.newaxis,np.newaxis,:], out=verts[...,:3], casting=\'unsafe\')  ## we now have indexes into cutEdges\n        verts = verts.reshape((verts.shape[0]*i,)+verts.shape[2:])\n        #profiler()\n        \n        ### expensive:\n        verts = (verts * cs[np.newaxis, np.newaxis, :]).sum(axis=2)\n        vertInds = cutEdges[verts]\n        #profiler()\n        nv = vertInds.shape[0]\n        #profiler()\n        faces[ptr:ptr+nv] = vertInds #.reshape((nv, 3))\n        #profiler()\n        ptr += nv\n        \n    return vertexes, faces\n\n\n    \ndef invertQTransform(tr):\n    """"""Return a QTransform that is the inverse of *tr*.\n    Rasises an exception if tr is not invertible.\n    \n    Note that this function is preferred over QTransform.inverted() due to\n    bugs in that method. (specifically, Qt has floating-point precision issues\n    when determining whether a matrix is invertible)\n    """"""\n    try:\n        import numpy.linalg\n        arr = np.array([[tr.m11(), tr.m12(), tr.m13()], [tr.m21(), tr.m22(), tr.m23()], [tr.m31(), tr.m32(), tr.m33()]])\n        inv = numpy.linalg.inv(arr)\n        return QtGui.QTransform(inv[0,0], inv[0,1], inv[0,2], inv[1,0], inv[1,1], inv[1,2], inv[2,0], inv[2,1])\n    except ImportError:\n        inv = tr.inverted()\n        if inv[1] is False:\n            raise Exception(""Transform is not invertible."")\n        return inv[0]\n    \n    \ndef pseudoScatter(data, spacing=None, shuffle=True, bidir=False):\n    """"""\n    Used for examining the distribution of values in a set. Produces scattering as in beeswarm or column scatter plots.\n    \n    Given a list of x-values, construct a set of y-values such that an x,y scatter-plot\n    will not have overlapping points (it will look similar to a histogram).\n    """"""\n    inds = np.arange(len(data))\n    if shuffle:\n        np.random.shuffle(inds)\n        \n    data = data[inds]\n    \n    if spacing is None:\n        spacing = 2.*np.std(data)/len(data)**0.5\n    s2 = spacing**2\n    \n    yvals = np.empty(len(data))\n    if len(data) == 0:\n        return yvals\n    yvals[0] = 0\n    for i in range(1,len(data)):\n        x = data[i]     # current x value to be placed\n        x0 = data[:i]   # all x values already placed\n        y0 = yvals[:i]  # all y values already placed\n        y = 0\n        \n        dx = (x0-x)**2  # x-distance to each previous point\n        xmask = dx < s2  # exclude anything too far away\n        \n        if xmask.sum() > 0:\n            if bidir:\n                dirs = [-1, 1]\n            else:\n                dirs = [1]\n            yopts = []\n            for direction in dirs:\n                y = 0\n                dx2 = dx[xmask]\n                dy = (s2 - dx2)**0.5   \n                limits = np.empty((2,len(dy)))  # ranges of y-values to exclude\n                limits[0] = y0[xmask] - dy\n                limits[1] = y0[xmask] + dy    \n                while True:\n                    # ignore anything below this y-value\n                    if direction > 0:\n                        mask = limits[1] >= y\n                    else:\n                        mask = limits[0] <= y\n                        \n                    limits2 = limits[:,mask]\n                    \n                    # are we inside an excluded region?\n                    mask = (limits2[0] < y) & (limits2[1] > y)\n                    if mask.sum() == 0:\n                        break\n                        \n                    if direction > 0:\n                        y = limits2[:,mask].max()\n                    else:\n                        y = limits2[:,mask].min()\n                yopts.append(y)\n            if bidir:\n                y = yopts[0] if -yopts[0] < yopts[1] else yopts[1]\n            else:\n                y = yopts[0]\n        yvals[i] = y\n    \n    return yvals[np.argsort(inds)]  ## un-shuffle values before returning\n\n\n\ndef toposort(deps, nodes=None, seen=None, stack=None, depth=0):\n    """"""Topological sort. Arguments are:\n      deps    dictionary describing dependencies where a:[b,c] means ""a depends on b and c""\n      nodes   optional, specifies list of starting nodes (these should be the nodes \n              which are not depended on by any other nodes). Other candidate starting\n              nodes will be ignored.\n              \n    Example::\n\n        # Sort the following graph:\n        # \n        #   B \xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80> C <\xe2\x94\x80\xe2\x94\x80 D\n        #       \xe2\x94\x82       \xe2\x94\x82       \n        #   E <\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80> A <\xe2\x94\x80\xe2\x94\x98\n        #     \n        deps = {\'a\': [\'b\', \'c\'], \'c\': [\'b\', \'d\'], \'e\': [\'b\']}\n        toposort(deps)\n         => [\'b\', \'d\', \'c\', \'a\', \'e\']\n    """"""\n    # fill in empty dep lists\n    deps = deps.copy()\n    for k,v in list(deps.items()):\n        for k in v:\n            if k not in deps:\n                deps[k] = []\n    \n    if nodes is None:\n        ## run through deps to find nodes that are not depended upon\n        rem = set()\n        for dep in deps.values():\n            rem |= set(dep)\n        nodes = set(deps.keys()) - rem\n    if seen is None:\n        seen = set()\n        stack = []\n    sorted = []\n    for n in nodes:\n        if n in stack:\n            raise Exception(""Cyclic dependency detected"", stack + [n])\n        if n in seen:\n            continue\n        seen.add(n)\n        sorted.extend( toposort(deps, deps[n], seen, stack+[n], depth=depth+1))\n        sorted.append(n)\n    return sorted\n\n\ndef disconnect(signal, slot):\n    """"""Disconnect a Qt signal from a slot.\n\n    This method augments Qt\'s Signal.disconnect():\n\n    * Return bool indicating whether disconnection was successful, rather than\n      raising an exception\n    * Attempt to disconnect prior versions of the slot when using pg.reload    \n    """"""\n    while True:\n        try:\n            signal.disconnect(slot)\n            return True\n        except (TypeError, RuntimeError):\n            slot = reload.getPreviousVersion(slot)\n            if slot is None:\n                return False\n\n\nclass SignalBlock(object):\n    """"""Class used to temporarily block a Qt signal connection::\n\n        with SignalBlock(signal, slot):\n            # do something that emits a signal; it will\n            # not be delivered to slot\n    """"""\n    def __init__(self, signal, slot):\n        self.signal = signal\n        self.slot = slot\n\n    def __enter__(self):\n        self.reconnect = disconnect(self.signal, self.slot)\n        return self\n\n    def __exit__(self, *args):\n        if self.reconnect:\n            self.signal.connect(self.slot)\n\n\n\n'"
src/third_party/pyqtgraph/graphicsWindows.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nDEPRECATED:  The classes below are convenience classes that create a new window\ncontainting a single, specific widget. These classes are now unnecessary because\nit is possible to place any widget into its own window by simply calling its\nshow() method.\n""""""\n\nfrom .Qt import QtCore, QtGui, mkQApp\nfrom .widgets.PlotWidget import *\nfrom .imageview import *\nfrom .widgets.GraphicsLayoutWidget import GraphicsLayoutWidget\nfrom .widgets.GraphicsView import GraphicsView\n\n\nclass GraphicsWindow(GraphicsLayoutWidget):\n    """"""\n    (deprecated; use GraphicsLayoutWidget instead)\n    \n    Convenience subclass of :class:`GraphicsLayoutWidget \n    <pyqtgraph.GraphicsLayoutWidget>`. This class is intended for use from \n    the interactive python prompt.\n    """"""\n    def __init__(self, title=None, size=(800,600), **kargs):\n        mkQApp()\n        GraphicsLayoutWidget.__init__(self, **kargs)\n        self.resize(*size)\n        if title is not None:\n            self.setWindowTitle(title)\n        self.show()\n        \n\nclass TabWindow(QtGui.QMainWindow):\n    """"""\n    (deprecated)\n    """"""\n    def __init__(self, title=None, size=(800,600)):\n        mkQApp()\n        QtGui.QMainWindow.__init__(self)\n        self.resize(*size)\n        self.cw = QtGui.QTabWidget()\n        self.setCentralWidget(self.cw)\n        if title is not None:\n            self.setWindowTitle(title)\n        self.show()\n        \n    def __getattr__(self, attr):\n        if hasattr(self.cw, attr):\n            return getattr(self.cw, attr)\n        else:\n            raise NameError(attr)\n    \n\nclass PlotWindow(PlotWidget):\n    """"""\n    (deprecated; use PlotWidget instead)\n    """"""\n    def __init__(self, title=None, **kargs):\n        mkQApp()\n        self.win = QtGui.QMainWindow()\n        PlotWidget.__init__(self, **kargs)\n        self.win.setCentralWidget(self)\n        for m in [\'resize\']:\n            setattr(self, m, getattr(self.win, m))\n        if title is not None:\n            self.win.setWindowTitle(title)\n        self.win.show()\n\n\nclass ImageWindow(ImageView):\n    """"""\n    (deprecated; use ImageView instead)\n    """"""\n    def __init__(self, *args, **kargs):\n        mkQApp()\n        self.win = QtGui.QMainWindow()\n        self.win.resize(800,600)\n        if \'title\' in kargs:\n            self.win.setWindowTitle(kargs[\'title\'])\n            del kargs[\'title\']\n        ImageView.__init__(self, self.win)\n        if len(args) > 0 or len(kargs) > 0:\n            self.setImage(*args, **kargs)\n        self.win.setCentralWidget(self)\n        for m in [\'resize\']:\n            setattr(self, m, getattr(self.win, m))\n        #for m in [\'setImage\', \'autoRange\', \'addItem\', \'removeItem\', \'blackLevel\', \'whiteLevel\', \'imageItem\']:\n            #setattr(self, m, getattr(self.cw, m))\n        self.win.show()\n'"
src/third_party/pyqtgraph/numpy_fix.py,5,"b'try:\n    import numpy as np\n    \n    ## Wrap np.concatenate to catch and avoid a segmentation fault bug\n    ## (numpy trac issue #2084)\n    if not hasattr(np, \'concatenate_orig\'):\n        np.concatenate_orig = np.concatenate\n    def concatenate(vals, *args, **kwds):\n        """"""Wrapper around numpy.concatenate (see pyqtgraph/numpy_fix.py)""""""\n        dtypes = [getattr(v, \'dtype\', None) for v in vals]\n        names = [getattr(dt, \'names\', None) for dt in dtypes]\n        if len(dtypes) < 2 or all([n is None for n in names]):\n            return np.concatenate_orig(vals, *args, **kwds)\n        if any([dt != dtypes[0] for dt in dtypes[1:]]):\n            raise TypeError(""Cannot concatenate structured arrays of different dtype."")\n        return np.concatenate_orig(vals, *args, **kwds)\n    \n    np.concatenate = concatenate\n    \nexcept ImportError:\n    pass\n\n'"
src/third_party/pyqtgraph/ordereddict.py,0,"b'# Copyright (c) 2009 Raymond Hettinger\n#\n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation files\n# (the ""Software""), to deal in the Software without restriction,\n# including without limitation the rights to use, copy, modify, merge,\n# publish, distribute, sublicense, and/or sell copies of the Software,\n# and to permit persons to whom the Software is furnished to do so,\n# subject to the following conditions:\n#\n#     The above copyright notice and this permission notice shall be\n#     included in all copies or substantial portions of the Software.\n#\n#     THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,\n#     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n#     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n#     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n#     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n#     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n#     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n#     OTHER DEALINGS IN THE SOFTWARE.\n\nimport sys\nif sys.version[0] > \'2\':\n    from collections import OrderedDict\nelse:\n    from UserDict import DictMixin\n\n    class OrderedDict(dict, DictMixin):\n\n        def __init__(self, *args, **kwds):\n            if len(args) > 1:\n                raise TypeError(\'expected at most 1 arguments, got %d\' % len(args))\n            try:\n                self.__end\n            except AttributeError:\n                self.clear()\n            self.update(*args, **kwds)\n\n        def clear(self):\n            self.__end = end = []\n            end += [None, end, end]         # sentinel node for doubly linked list\n            self.__map = {}                 # key --> [key, prev, next]\n            dict.clear(self)\n\n        def __setitem__(self, key, value):\n            if key not in self:\n                end = self.__end\n                curr = end[1]\n                curr[2] = end[1] = self.__map[key] = [key, curr, end]\n            dict.__setitem__(self, key, value)\n\n        def __delitem__(self, key):\n            dict.__delitem__(self, key)\n            key, prev, next = self.__map.pop(key)\n            prev[2] = next\n            next[1] = prev\n\n        def __iter__(self):\n            end = self.__end\n            curr = end[2]\n            while curr is not end:\n                yield curr[0]\n                curr = curr[2]\n\n        def __reversed__(self):\n            end = self.__end\n            curr = end[1]\n            while curr is not end:\n                yield curr[0]\n                curr = curr[1]\n\n        def popitem(self, last=True):\n            if not self:\n                raise KeyError(\'dictionary is empty\')\n            if last:\n                key = reversed(self).next()\n            else:\n                key = iter(self).next()\n            value = self.pop(key)\n            return key, value\n\n        def __reduce__(self):\n            items = [[k, self[k]] for k in self]\n            tmp = self.__map, self.__end\n            del self.__map, self.__end\n            inst_dict = vars(self).copy()\n            self.__map, self.__end = tmp\n            if inst_dict:\n                return (self.__class__, (items,), inst_dict)\n            return self.__class__, (items,)\n\n        def keys(self):\n            return list(self)\n\n        setdefault = DictMixin.setdefault\n        update = DictMixin.update\n        pop = DictMixin.pop\n        values = DictMixin.values\n        items = DictMixin.items\n        iterkeys = DictMixin.iterkeys\n        itervalues = DictMixin.itervalues\n        iteritems = DictMixin.iteritems\n\n        def __repr__(self):\n            if not self:\n                return \'%s()\' % (self.__class__.__name__,)\n            return \'%s(%r)\' % (self.__class__.__name__, self.items())\n\n        def copy(self):\n            return self.__class__(self)\n\n        @classmethod\n        def fromkeys(cls, iterable, value=None):\n            d = cls()\n            for key in iterable:\n                d[key] = value\n            return d\n\n        def __eq__(self, other):\n            if isinstance(other, OrderedDict):\n                if len(self) != len(other):\n                    return False\n                for p, q in  zip(self.items(), other.items()):\n                    if p != q:\n                        return False\n                return True\n            return dict.__eq__(self, other)\n\n        def __ne__(self, other):\n            return not self == other\n'"
src/third_party/pyqtgraph/pgcollections.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nadvancedTypes.py - Basic data structures not included with python \nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n\nIncludes:\n  - OrderedDict - Dictionary which preserves the order of its elements\n  - BiDict, ReverseDict - Bi-directional dictionaries\n  - ThreadsafeDict, ThreadsafeList - Self-mutexed data structures\n""""""\n\nimport threading, sys, copy, collections\n#from debug import *\n\ntry:\n    from collections import OrderedDict\nexcept ImportError:\n    # fallback: try to use the ordereddict backport when using python 2.6\n    from ordereddict import OrderedDict\n        \n\nclass ReverseDict(dict):\n    """"""extends dict so that reverse lookups are possible by requesting the key as a list of length 1:\n       d = BiDict({\'x\': 1, \'y\': 2})\n       d[\'x\']\n         1\n       d[[2]]\n         \'y\'\n    """"""\n    def __init__(self, data=None):\n        if data is None:\n            data = {}\n        self.reverse = {}\n        for k in data:\n            self.reverse[data[k]] = k\n        dict.__init__(self, data)\n        \n    def __getitem__(self, item):\n        if type(item) is list:\n            return self.reverse[item[0]]\n        else:\n            return dict.__getitem__(self, item)\n\n    def __setitem__(self, item, value):\n        self.reverse[value] = item\n        dict.__setitem__(self, item, value)\n\n    def __deepcopy__(self, memo):\n        raise Exception(""deepcopy not implemented"")\n        \n        \nclass BiDict(dict):\n    """"""extends dict so that reverse lookups are possible by adding each reverse combination to the dict.\n    This only works if all values and keys are unique.""""""\n    def __init__(self, data=None):\n        if data is None:\n            data = {}\n        dict.__init__(self)\n        for k in data:\n            self[data[k]] = k\n        \n    def __setitem__(self, item, value):\n        dict.__setitem__(self, item, value)\n        dict.__setitem__(self, value, item)\n    \n    def __deepcopy__(self, memo):\n        raise Exception(""deepcopy not implemented"")\n\nclass ThreadsafeDict(dict):\n    """"""Extends dict so that getitem, setitem, and contains are all thread-safe.\n    Also adds lock/unlock functions for extended exclusive operations\n    Converts all sub-dicts and lists to threadsafe as well.\n    """"""\n    \n    def __init__(self, *args, **kwargs):\n        self.mutex = threading.RLock()\n        dict.__init__(self, *args, **kwargs)\n        for k in self:\n            if type(self[k]) is dict:\n                self[k] = ThreadsafeDict(self[k])\n\n    def __getitem__(self, attr):\n        self.lock()\n        try:\n            val = dict.__getitem__(self, attr)\n        finally:\n            self.unlock()\n        return val\n\n    def __setitem__(self, attr, val):\n        if type(val) is dict:\n            val = ThreadsafeDict(val)\n        self.lock()\n        try:\n            dict.__setitem__(self, attr, val)\n        finally:\n            self.unlock()\n        \n    def __contains__(self, attr):\n        self.lock()\n        try:\n            val = dict.__contains__(self, attr)\n        finally:\n            self.unlock()\n        return val\n\n    def __len__(self):\n        self.lock()\n        try:\n            val = dict.__len__(self)\n        finally:\n            self.unlock()\n        return val\n\n    def clear(self):\n        self.lock()\n        try:\n            dict.clear(self)\n        finally:\n            self.unlock()\n\n    def lock(self):\n        self.mutex.acquire()\n        \n    def unlock(self):\n        self.mutex.release()\n\n    def __deepcopy__(self, memo):\n        raise Exception(""deepcopy not implemented"")\n        \nclass ThreadsafeList(list):\n    """"""Extends list so that getitem, setitem, and contains are all thread-safe.\n    Also adds lock/unlock functions for extended exclusive operations\n    Converts all sub-lists and dicts to threadsafe as well.\n    """"""\n    \n    def __init__(self, *args, **kwargs):\n        self.mutex = threading.RLock()\n        list.__init__(self, *args, **kwargs)\n        for k in self:\n            self[k] = mkThreadsafe(self[k])\n\n    def __getitem__(self, attr):\n        self.lock()\n        try:\n            val = list.__getitem__(self, attr)\n        finally:\n            self.unlock()\n        return val\n\n    def __setitem__(self, attr, val):\n        val = makeThreadsafe(val)\n        self.lock()\n        try:\n            list.__setitem__(self, attr, val)\n        finally:\n            self.unlock()\n        \n    def __contains__(self, attr):\n        self.lock()\n        try:\n            val = list.__contains__(self, attr)\n        finally:\n            self.unlock()\n        return val\n\n    def __len__(self):\n        self.lock()\n        try:\n            val = list.__len__(self)\n        finally:\n            self.unlock()\n        return val\n    \n    def lock(self):\n        self.mutex.acquire()\n        \n    def unlock(self):\n        self.mutex.release()\n\n    def __deepcopy__(self, memo):\n        raise Exception(""deepcopy not implemented"")\n        \n        \ndef makeThreadsafe(obj):\n    if type(obj) is dict:\n        return ThreadsafeDict(obj)\n    elif type(obj) is list:\n        return ThreadsafeList(obj)\n    elif type(obj) in [str, int, float, bool, tuple]:\n        return obj\n    else:\n        raise Exception(""Not sure how to make object of type %s thread-safe"" % str(type(obj)))\n        \n        \nclass Locker(object):\n    def __init__(self, lock):\n        self.lock = lock\n        self.lock.acquire()\n    def __del__(self):\n        try:\n            self.lock.release()\n        except:\n            pass\n\nclass CaselessDict(OrderedDict):\n    """"""Case-insensitive dict. Values can be set and retrieved using keys of any case.\n    Note that when iterating, the original case is returned for each key.""""""\n    def __init__(self, *args):\n        OrderedDict.__init__(self, {}) ## requirement for the empty {} here seems to be a python bug?\n        self.keyMap = OrderedDict([(k.lower(), k) for k in OrderedDict.keys(self)])\n        if len(args) == 0:\n            return\n        elif len(args) == 1 and isinstance(args[0], dict):\n            for k in args[0]:\n                self[k] = args[0][k]\n        else:\n            raise Exception(""CaselessDict may only be instantiated with a single dict."")\n        \n    #def keys(self):\n        #return self.keyMap.values()\n    \n    def __setitem__(self, key, val):\n        kl = key.lower()\n        if kl in self.keyMap:\n            OrderedDict.__setitem__(self, self.keyMap[kl], val)\n        else:\n            OrderedDict.__setitem__(self, key, val)\n            self.keyMap[kl] = key\n            \n    def __getitem__(self, key):\n        kl = key.lower()\n        if kl not in self.keyMap:\n            raise KeyError(key)\n        return OrderedDict.__getitem__(self, self.keyMap[kl])\n        \n    def __contains__(self, key):\n        return key.lower() in self.keyMap\n    \n    def update(self, d):\n        for k, v in d.items():\n            self[k] = v\n            \n    def copy(self):\n        return CaselessDict(OrderedDict.copy(self))\n        \n    def __delitem__(self, key):\n        kl = key.lower()\n        if kl not in self.keyMap:\n            raise KeyError(key)\n        OrderedDict.__delitem__(self, self.keyMap[kl])\n        del self.keyMap[kl]\n            \n    def __deepcopy__(self, memo):\n        raise Exception(""deepcopy not implemented"")\n\n    def clear(self):\n        OrderedDict.clear(self)\n        self.keyMap.clear()\n\n\n\nclass ProtectedDict(dict):\n    """"""\n    A class allowing read-only \'view\' of a dict. \n    The object can be treated like a normal dict, but will never modify the original dict it points to.\n    Any values accessed from the dict will also be read-only.\n    """"""\n    def __init__(self, data):\n        self._data_ = data\n    \n    ## List of methods to directly wrap from _data_\n    wrapMethods = [\'_cmp_\', \'__contains__\', \'__eq__\', \'__format__\', \'__ge__\', \'__gt__\', \'__le__\', \'__len__\', \'__lt__\', \'__ne__\', \'__reduce__\', \'__reduce_ex__\', \'__repr__\', \'__str__\', \'count\', \'has_key\', \'iterkeys\', \'keys\', ]\n    \n    ## List of methods which wrap from _data_ but return protected results\n    protectMethods = [\'__getitem__\', \'__iter__\', \'get\', \'items\', \'values\']\n    \n    ## List of methods to disable\n    disableMethods = [\'__delitem__\', \'__setitem__\', \'clear\', \'pop\', \'popitem\', \'setdefault\', \'update\']\n    \n    \n    ## Template methods \n    def wrapMethod(methodName):\n        return lambda self, *a, **k: getattr(self._data_, methodName)(*a, **k)\n        \n    def protectMethod(methodName):\n        return lambda self, *a, **k: protect(getattr(self._data_, methodName)(*a, **k))\n    \n    def error(self, *args, **kargs):\n        raise Exception(""Can not modify read-only list."")\n    \n    \n    ## Directly (and explicitly) wrap some methods from _data_\n    ## Many of these methods can not be intercepted using __getattribute__, so they\n    ## must be implemented explicitly\n    for methodName in wrapMethods:\n        locals()[methodName] = wrapMethod(methodName)\n\n    ## Wrap some methods from _data_ with the results converted to protected objects\n    for methodName in protectMethods:\n        locals()[methodName] = protectMethod(methodName)\n\n    ## Disable any methods that could change data in the list\n    for methodName in disableMethods:\n        locals()[methodName] = error\n\n    \n    ## Add a few extra methods.\n    def copy(self):\n        raise Exception(""It is not safe to copy protected dicts! (instead try deepcopy, but be careful.)"")\n    \n    def itervalues(self):\n        for v in self._data_.values():\n            yield protect(v)\n        \n    def iteritems(self):\n        for k, v in self._data_.items():\n            yield (k, protect(v))\n        \n    def deepcopy(self):\n        return copy.deepcopy(self._data_)\n    \n    def __deepcopy__(self, memo):\n        return copy.deepcopy(self._data_, memo)\n\n\n            \nclass ProtectedList(collections.Sequence):\n    """"""\n    A class allowing read-only \'view\' of a list or dict. \n    The object can be treated like a normal list, but will never modify the original list it points to.\n    Any values accessed from the list will also be read-only.\n    \n    Note: It would be nice if we could inherit from list or tuple so that isinstance checks would work.\n          However, doing this causes tuple(obj) to return unprotected results (importantly, this means\n          unpacking into function arguments will also fail)\n    """"""\n    def __init__(self, data):\n        self._data_ = data\n        #self.__mro__ = (ProtectedList, object)\n        \n    ## List of methods to directly wrap from _data_\n    wrapMethods = [\'__contains__\', \'__eq__\', \'__format__\', \'__ge__\', \'__gt__\', \'__le__\', \'__len__\', \'__lt__\', \'__ne__\', \'__reduce__\', \'__reduce_ex__\', \'__repr__\', \'__str__\', \'count\', \'index\']\n    \n    ## List of methods which wrap from _data_ but return protected results\n    protectMethods = [\'__getitem__\', \'__getslice__\', \'__mul__\', \'__reversed__\', \'__rmul__\']\n    \n    ## List of methods to disable\n    disableMethods = [\'__delitem__\', \'__delslice__\', \'__iadd__\', \'__imul__\', \'__setitem__\', \'__setslice__\', \'append\', \'extend\', \'insert\', \'pop\', \'remove\', \'reverse\', \'sort\']\n    \n    \n    ## Template methods \n    def wrapMethod(methodName):\n        return lambda self, *a, **k: getattr(self._data_, methodName)(*a, **k)\n        \n    def protectMethod(methodName):\n        return lambda self, *a, **k: protect(getattr(self._data_, methodName)(*a, **k))\n    \n    def error(self, *args, **kargs):\n        raise Exception(""Can not modify read-only list."")\n    \n    \n    ## Directly (and explicitly) wrap some methods from _data_\n    ## Many of these methods can not be intercepted using __getattribute__, so they\n    ## must be implemented explicitly\n    for methodName in wrapMethods:\n        locals()[methodName] = wrapMethod(methodName)\n\n    ## Wrap some methods from _data_ with the results converted to protected objects\n    for methodName in protectMethods:\n        locals()[methodName] = protectMethod(methodName)\n\n    ## Disable any methods that could change data in the list\n    for methodName in disableMethods:\n        locals()[methodName] = error\n\n    \n    ## Add a few extra methods.\n    def __iter__(self):\n        for item in self._data_:\n            yield protect(item)\n    \n    \n    def __add__(self, op):\n        if isinstance(op, ProtectedList):\n            return protect(self._data_.__add__(op._data_))\n        elif isinstance(op, list):\n            return protect(self._data_.__add__(op))\n        else:\n            raise TypeError(""Argument must be a list."")\n    \n    def __radd__(self, op):\n        if isinstance(op, ProtectedList):\n            return protect(op._data_.__add__(self._data_))\n        elif isinstance(op, list):\n            return protect(op.__add__(self._data_))\n        else:\n            raise TypeError(""Argument must be a list."")\n        \n    def deepcopy(self):\n        return copy.deepcopy(self._data_)\n    \n    def __deepcopy__(self, memo):\n        return copy.deepcopy(self._data_, memo)\n    \n    def poop(self):\n        raise Exception(""This is a list. It does not poop."")\n\n\nclass ProtectedTuple(collections.Sequence):\n    """"""\n    A class allowing read-only \'view\' of a tuple.\n    The object can be treated like a normal tuple, but its contents will be returned as protected objects.\n    \n    Note: It would be nice if we could inherit from list or tuple so that isinstance checks would work.\n          However, doing this causes tuple(obj) to return unprotected results (importantly, this means\n          unpacking into function arguments will also fail)\n    """"""\n    def __init__(self, data):\n        self._data_ = data\n    \n    ## List of methods to directly wrap from _data_\n    wrapMethods = [\'__contains__\', \'__eq__\', \'__format__\', \'__ge__\', \'__getnewargs__\', \'__gt__\', \'__hash__\', \'__le__\', \'__len__\', \'__lt__\', \'__ne__\', \'__reduce__\', \'__reduce_ex__\', \'__repr__\', \'__str__\', \'count\', \'index\']\n    \n    ## List of methods which wrap from _data_ but return protected results\n    protectMethods = [\'__getitem__\', \'__getslice__\', \'__iter__\', \'__add__\', \'__mul__\', \'__reversed__\', \'__rmul__\']\n    \n    \n    ## Template methods \n    def wrapMethod(methodName):\n        return lambda self, *a, **k: getattr(self._data_, methodName)(*a, **k)\n        \n    def protectMethod(methodName):\n        return lambda self, *a, **k: protect(getattr(self._data_, methodName)(*a, **k))\n    \n    \n    ## Directly (and explicitly) wrap some methods from _data_\n    ## Many of these methods can not be intercepted using __getattribute__, so they\n    ## must be implemented explicitly\n    for methodName in wrapMethods:\n        locals()[methodName] = wrapMethod(methodName)\n\n    ## Wrap some methods from _data_ with the results converted to protected objects\n    for methodName in protectMethods:\n        locals()[methodName] = protectMethod(methodName)\n\n    \n    ## Add a few extra methods.\n    def deepcopy(self):\n        return copy.deepcopy(self._data_)\n    \n    def __deepcopy__(self, memo):\n        return copy.deepcopy(self._data_, memo)\n    \n\n\ndef protect(obj):\n    if isinstance(obj, dict):\n        return ProtectedDict(obj)\n    elif isinstance(obj, list):\n        return ProtectedList(obj)\n    elif isinstance(obj, tuple):\n        return ProtectedTuple(obj)\n    else:\n        return obj\n    \n    \nif __name__ == \'__main__\':\n    d = {\'x\': 1, \'y\': [1,2], \'z\': ({\'a\': 2, \'b\': [3,4], \'c\': (5,6)}, 1, 2)}\n    dp = protect(d)\n    \n    l = [1, \'x\', [\'a\', \'b\'], (\'c\', \'d\'), {\'x\': 1, \'y\': 2}]\n    lp = protect(l)\n    \n    t = (1, \'x\', [\'a\', \'b\'], (\'c\', \'d\'), {\'x\': 1, \'y\': 2})\n    tp = protect(t)\n'"
src/third_party/pyqtgraph/ptime.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nptime.py -  Precision time function made os-independent (should have been taken care of by python)\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n""""""\n\n\nimport sys\nimport time as systime\nSTART_TIME = None\ntime = None\n\ndef winTime():\n    """"""Return the current time in seconds with high precision (windows version, use Manager.time() to stay platform independent).""""""\n    return systime.clock() + START_TIME\n    #return systime.time()\n\ndef unixTime():\n    """"""Return the current time in seconds with high precision (unix version, use Manager.time() to stay platform independent).""""""\n    return systime.time()\n\nif sys.platform.startswith(\'win\'):\n    cstart = systime.clock()  ### Required to start the clock in windows\n    START_TIME = systime.time() - cstart\n    \n    time = winTime\nelse:\n    time = unixTime\n\n'"
src/third_party/pyqtgraph/python2_3.py,0,"b'""""""\nHelper functions that smooth out the differences between python 2 and 3.\n""""""\nimport sys\n\ndef asUnicode(x):\n    if sys.version_info[0] == 2:\n        if isinstance(x, unicode):\n            return x\n        elif isinstance(x, str):\n            return x.decode(\'UTF-8\')\n        else:\n            return unicode(x)\n    else:\n        return str(x)\n        \ndef cmpToKey(mycmp):\n    \'Convert a cmp= function into a key= function\'\n    class K(object):\n        def __init__(self, obj, *args):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0\n        def __eq__(self, other):\n            return mycmp(self.obj, other.obj) == 0\n        def __le__(self, other):\n            return mycmp(self.obj, other.obj) <= 0\n        def __ge__(self, other):\n            return mycmp(self.obj, other.obj) >= 0\n        def __ne__(self, other):\n            return mycmp(self.obj, other.obj) != 0\n    return K\n\ndef sortList(l, cmpFunc):\n    if sys.version_info[0] == 2:\n        l.sort(cmpFunc)\n    else:\n        l.sort(key=cmpToKey(cmpFunc))\n\nif sys.version_info[0] == 3:\n    basestring = str\n    def cmp(a,b):\n        if a>b:\n            return 1\n        elif b > a:\n            return -1\n        else:\n            return 0\n    xrange = range\nelse:\n    import __builtin__\n    basestring = __builtin__.basestring\n    cmp = __builtin__.cmp\n    xrange = __builtin__.xrange\n    \n    '"
src/third_party/pyqtgraph/reload.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nMagic Reload Library\nLuke Campagnola   2010\n\nPython reload function that actually works (the way you expect it to)\n - No re-importing necessary\n - Modules can be reloaded in any order\n - Replaces functions and methods with their updated code\n - Changes instances to use updated classes\n - Automatically decides which modules to update by comparing file modification times\n \nDoes NOT:\n - re-initialize exting instances, even if __init__ changes\n - update references to any module-level objects\n   ie, this does not reload correctly:\n       from module import someObject\n       print someObject\n   ..but you can use this instead: (this works even for the builtin reload)\n       import module\n       print module.someObject\n""""""\n\nfrom __future__ import print_function\nimport inspect, os, sys, gc, traceback, types\nfrom .debug import printExc\ntry:\n    from importlib import reload as orig_reload\nexcept ImportError:\n    orig_reload = reload\n\n\npy3 = sys.version_info >= (3,)\n\n\ndef reloadAll(prefix=None, debug=False):\n    """"""Automatically reload everything whose __file__ begins with prefix.\n    - Skips reload if the file has not been updated (if .pyc is newer than .py)\n    - if prefix is None, checks all loaded modules\n    """"""\n    failed = []\n    changed = []\n    for modName, mod in list(sys.modules.items()):  ## don\'t use iteritems; size may change during reload\n        if not inspect.ismodule(mod):\n            continue\n        if modName == \'__main__\':\n            continue\n        \n        ## Ignore if the file name does not start with prefix\n        if not hasattr(mod, \'__file__\') or os.path.splitext(mod.__file__)[1] not in [\'.py\', \'.pyc\']:\n            continue\n        if prefix is not None and mod.__file__[:len(prefix)] != prefix:\n            continue\n        \n        ## ignore if the .pyc is newer than the .py (or if there is no pyc or py)\n        py = os.path.splitext(mod.__file__)[0] + \'.py\'\n        pyc = py + \'c\'\n        if py not in changed and os.path.isfile(pyc) and os.path.isfile(py) and os.stat(pyc).st_mtime >= os.stat(py).st_mtime:\n            #if debug:\n                #print ""Ignoring module %s; unchanged"" % str(mod)\n            continue\n        changed.append(py)  ## keep track of which modules have changed to insure that duplicate-import modules get reloaded.\n        \n        try:\n            reload(mod, debug=debug)\n        except:\n            printExc(""Error while reloading module %s, skipping\\n"" % mod)\n            failed.append(mod.__name__)\n        \n    if len(failed) > 0:\n        raise Exception(""Some modules failed to reload: %s"" % \', \'.join(failed))\n\ndef reload(module, debug=False, lists=False, dicts=False):\n    """"""Replacement for the builtin reload function:\n    - Reloads the module as usual\n    - Updates all old functions and class methods to use the new code\n    - Updates all instances of each modified class to use the new class\n    - Can update lists and dicts, but this is disabled by default\n    - Requires that class and function names have not changed\n    """"""\n    if debug:\n        print(""Reloading %s"" % str(module))\n        \n    ## make a copy of the old module dictionary, reload, then grab the new module dictionary for comparison\n    oldDict = module.__dict__.copy()\n    orig_reload(module)\n    newDict = module.__dict__\n    \n    ## Allow modules access to the old dictionary after they reload\n    if hasattr(module, \'__reload__\'):\n        module.__reload__(oldDict)\n    \n    ## compare old and new elements from each dict; update where appropriate\n    for k in oldDict:\n        old = oldDict[k]\n        new = newDict.get(k, None)\n        if old is new or new is None:\n            continue\n        \n        if inspect.isclass(old):\n            if debug:\n                print(""  Updating class %s.%s (0x%x -> 0x%x)"" % (module.__name__, k, id(old), id(new)))\n            updateClass(old, new, debug)\n            # don\'t put this inside updateClass because it is reentrant.\n            new.__previous_reload_version__ = old\n\n        elif inspect.isfunction(old):\n            depth = updateFunction(old, new, debug)\n            if debug:\n                extra = """"\n                if depth > 0:\n                    extra = "" (and %d previous versions)"" % depth\n                print(""  Updating function %s.%s%s"" % (module.__name__, k, extra))\n        elif lists and isinstance(old, list):\n            l = old.len()\n            old.extend(new)\n            for i in range(l):\n                old.pop(0)\n        elif dicts and isinstance(old, dict):\n            old.update(new)\n            for k in old:\n                if k not in new:\n                    del old[k]\n        \n\n\n## For functions:\n##  1) update the code and defaults to new versions.\n##  2) keep a reference to the previous version so ALL versions get updated for every reload\ndef updateFunction(old, new, debug, depth=0, visited=None):\n    #if debug and depth > 0:\n        #print ""    -> also updating previous version"", old, "" -> "", new\n        \n    old.__code__ = new.__code__\n    old.__defaults__ = new.__defaults__\n    if hasattr(old, \'__kwdefaults\'):\n        old.__kwdefaults__ = new.__kwdefaults__\n    old.__doc__ = new.__doc__\n    \n    if visited is None:\n        visited = []\n    if old in visited:\n        return\n    visited.append(old)\n    \n    ## finally, update any previous versions still hanging around..\n    if hasattr(old, \'__previous_reload_version__\'):\n        maxDepth = updateFunction(old.__previous_reload_version__, new, debug, depth=depth+1, visited=visited)\n    else:\n        maxDepth = depth\n        \n    ## We need to keep a pointer to the previous version so we remember to update BOTH\n    ## when the next reload comes around.\n    if depth == 0:\n        new.__previous_reload_version__ = old\n    return maxDepth\n\n\n\n## For classes:\n##  1) find all instances of the old class and set instance.__class__ to the new class\n##  2) update all old class methods to use code from the new class methods\n\n\ndef updateClass(old, new, debug):\n    ## Track town all instances and subclasses of old\n    refs = gc.get_referrers(old)\n    for ref in refs:\n        try:\n            if isinstance(ref, old) and ref.__class__ is old:\n                ref.__class__ = new\n                if debug:\n                    print(""    Changed class for %s"" % safeStr(ref))\n            elif inspect.isclass(ref) and issubclass(ref, old) and old in ref.__bases__:\n                ind = ref.__bases__.index(old)\n                \n                ## Does not work:\n                #ref.__bases__ = ref.__bases__[:ind] + (new,) + ref.__bases__[ind+1:]\n                ## reason: Even though we change the code on methods, they remain bound\n                ## to their old classes (changing im_class is not allowed). Instead,\n                ## we have to update the __bases__ such that this class will be allowed\n                ## as an argument to older methods.\n                \n                ## This seems to work. Is there any reason not to?\n                ## Note that every time we reload, the class hierarchy becomes more complex.\n                ## (and I presume this may slow things down?)\n                newBases = ref.__bases__[:ind] + (new,old) + ref.__bases__[ind+1:]\n                try:\n                    ref.__bases__ = newBases\n                except TypeError:\n                    print(""    Error setting bases for class %s"" % ref)\n                    print(""        old bases: %s"" % repr(ref.__bases__))\n                    print(""        new bases: %s"" % repr(newBases))\n                    raise\n                if debug:\n                    print(""    Changed superclass for %s"" % safeStr(ref))\n            #else:\n                #if debug:\n                    #print ""    Ignoring reference"", type(ref)\n        except Exception:\n            print(""Error updating reference (%s) for class change (%s -> %s)"" % (safeStr(ref), safeStr(old), safeStr(new)))\n            raise\n        \n    ## update all class methods to use new code.\n    ## Generally this is not needed since instances already know about the new class, \n    ## but it fixes a few specific cases (pyqt signals, for one)\n    for attr in dir(old):\n        oa = getattr(old, attr)\n        if (py3 and inspect.isfunction(oa)) or inspect.ismethod(oa):\n            # note python2 has unbound methods, whereas python3 just uses plain functions\n            try:\n                na = getattr(new, attr)\n            except AttributeError:\n                if debug:\n                    print(""    Skipping method update for %s; new class does not have this attribute"" % attr)\n                continue\n                \n            ofunc = getattr(oa, \'__func__\', oa)  # in py2 we have to get the __func__ from unbound method,\n            nfunc = getattr(na, \'__func__\', na)  # in py3 the attribute IS the function\n\n            if ofunc is not nfunc:\n                depth = updateFunction(ofunc, nfunc, debug)\n                if not hasattr(nfunc, \'__previous_reload_method__\'):\n                    nfunc.__previous_reload_method__ = oa  # important for managing signal connection\n                    #oa.__class__ = new  ## bind old method to new class  ## not allowed\n                if debug:\n                    extra = """"\n                    if depth > 0:\n                        extra = "" (and %d previous versions)"" % depth\n                    print(""    Updating method %s%s"" % (attr, extra))\n                \n    ## And copy in new functions that didn\'t exist previously\n    for attr in dir(new):\n        if attr == \'__previous_reload_version__\':\n            continue\n        if not hasattr(old, attr):\n            if debug:\n                print(""    Adding missing attribute %s"" % attr)\n            setattr(old, attr, getattr(new, attr))\n            \n    ## finally, update any previous versions still hanging around..\n    if hasattr(old, \'__previous_reload_version__\'):\n        updateClass(old.__previous_reload_version__, new, debug)\n\n\n## It is possible to build classes for which str(obj) just causes an exception.\n## Avoid thusly:\ndef safeStr(obj):\n    try:\n        s = str(obj)\n    except Exception:\n        try:\n            s = repr(obj)\n        except Exception:\n            s = ""<instance of %s at 0x%x>"" % (safeStr(type(obj)), id(obj))\n    return s\n\n\ndef getPreviousVersion(obj):\n    """"""Return the previous version of *obj*, or None if this object has not\n    been reloaded.\n    """"""\n    if isinstance(obj, type) or inspect.isfunction(obj):\n        return getattr(obj, \'__previous_reload_version__\', None)\n    elif inspect.ismethod(obj):\n        if obj.__self__ is None:\n            # unbound method\n            return getattr(obj.__func__, \'__previous_reload_method__\', None)\n        else:\n            oldmethod = getattr(obj.__func__, \'__previous_reload_method__\', None)\n            if oldmethod is None:\n                return None\n            self = obj.__self__\n            oldfunc = getattr(oldmethod, \'__func__\', oldmethod)\n            if hasattr(oldmethod, \'im_class\'):\n                # python 2\n                cls = oldmethod.im_class\n                return types.MethodType(oldfunc, self, cls)\n            else:\n                # python 3\n                return types.MethodType(oldfunc, self)\n\n\n\n## Tests:\n#  write modules to disk, import, then re-write and run again\nif __name__ == \'__main__\':\n    doQtTest = True\n    try:\n        from PyQt4 import QtCore\n        if not hasattr(QtCore, \'Signal\'):\n            QtCore.Signal = QtCore.pyqtSignal\n        #app = QtGui.QApplication([])\n        class Btn(QtCore.QObject):\n            sig = QtCore.Signal()\n            def emit(self):\n                self.sig.emit()\n        btn = Btn()\n    except:\n        raise\n        print(""Error; skipping Qt tests"")\n        doQtTest = False\n\n\n\n    import os\n    if not os.path.isdir(\'test1\'):\n        os.mkdir(\'test1\')\n    open(\'test1/__init__.py\', \'w\')\n    modFile1 = ""test1/test1.py""\n    modCode1 = """"""\nimport sys\nclass A(object):\n    def __init__(self, msg):\n        object.__init__(self)\n        self.msg = msg\n    def fn(self, pfx = """"):\n        print(pfx+""A class: %%s %%s"" %% (str(self.__class__), str(id(self.__class__))))\n        print(pfx+""  %%s: %d"" %% self.msg)\n\nclass B(A):\n    def fn(self, pfx=""""):\n        print(pfx+""B class:"", self.__class__, id(self.__class__))\n        print(pfx+""  %%s: %d"" %% self.msg)\n        print(pfx+""  calling superclass.. (%%s)"" %% id(A) )\n        A.fn(self, ""  "")\n""""""\n\n    modFile2 = ""test2.py""\n    modCode2 = """"""\nfrom test1.test1 import A\nfrom test1.test1 import B\n\na1 = A(""ax1"")\nb1 = B(""bx1"")\nclass C(A):\n    def __init__(self, msg):\n        #print ""| C init:""\n        #print ""|   C.__bases__ = "", map(id, C.__bases__)\n        #print ""|   A:"", id(A)\n        #print ""|   A.__init__ = "", id(A.__init__.im_func), id(A.__init__.im_func.__code__), id(A.__init__.im_class)\n        A.__init__(self, msg + ""(init from C)"")\n        \ndef fn():\n    print(""fn: %s"")\n"""""" \n\n    open(modFile1, \'w\').write(modCode1%(1,1))\n    open(modFile2, \'w\').write(modCode2%""message 1"")\n    import test1.test1 as test1\n    import test2\n    print(""Test 1 originals:"")\n    A1 = test1.A\n    B1 = test1.B\n    a1 = test1.A(""a1"")\n    b1 = test1.B(""b1"")\n    a1.fn()\n    b1.fn()\n    #print ""function IDs  a1 bound method: %d a1 func: %d  a1 class: %d  b1 func: %d  b1 class: %d"" % (id(a1.fn), id(a1.fn.im_func), id(a1.fn.im_class), id(b1.fn.im_func), id(b1.fn.im_class))\n\n\n    from test2 import fn, C\n    \n    if doQtTest:\n        print(""Button test before:"")\n        btn.sig.connect(fn)\n        btn.sig.connect(a1.fn)\n        btn.emit()\n        #btn.sig.emit()\n        print("""")\n    \n    #print ""a1.fn referrers:"", sys.getrefcount(a1.fn.im_func), gc.get_referrers(a1.fn.im_func)\n    \n    \n    print(""Test2 before reload:"")\n    \n    fn()\n    oldfn = fn\n    test2.a1.fn()\n    test2.b1.fn()\n    c1 = test2.C(\'c1\')\n    c1.fn()\n    \n    os.remove(modFile1+\'c\')\n    open(modFile1, \'w\').write(modCode1%(2,2))\n    print(""\\n----RELOAD test1-----\\n"")\n    reloadAll(os.path.abspath(__file__)[:10], debug=True)\n    \n    \n    print(""Subclass test:"")\n    c2 = test2.C(\'c2\')\n    c2.fn()\n    \n    \n    os.remove(modFile2+\'c\')\n    open(modFile2, \'w\').write(modCode2%""message 2"")\n    print(""\\n----RELOAD test2-----\\n"")\n    reloadAll(os.path.abspath(__file__)[:10], debug=True)\n\n    if doQtTest:\n        print(""Button test after:"")\n        btn.emit()\n        #btn.sig.emit()\n\n    #print ""a1.fn referrers:"", sys.getrefcount(a1.fn.im_func), gc.get_referrers(a1.fn.im_func)\n\n    print(""Test2 after reload:"")\n    fn()\n    test2.a1.fn()\n    test2.b1.fn()\n    \n    print(""\\n==> Test 1 Old instances:"")\n    a1.fn()\n    b1.fn()\n    c1.fn()\n    #print ""function IDs  a1 bound method: %d a1 func: %d  a1 class: %d  b1 func: %d  b1 class: %d"" % (id(a1.fn), id(a1.fn.im_func), id(a1.fn.im_class), id(b1.fn.im_func), id(b1.fn.im_class))\n\n    print(""\\n==> Test 1 New instances:"")\n    a2 = test1.A(""a2"")\n    b2 = test1.B(""b2"")\n    a2.fn()\n    b2.fn()\n    c2 = test2.C(\'c2\')\n    c2.fn()\n    #print ""function IDs  a1 bound method: %d a1 func: %d  a1 class: %d  b1 func: %d  b1 class: %d"" % (id(a1.fn), id(a1.fn.im_func), id(a1.fn.im_class), id(b1.fn.im_func), id(b1.fn.im_class))\n\n\n\n\n    os.remove(modFile1+\'c\')\n    os.remove(modFile2+\'c\')\n    open(modFile1, \'w\').write(modCode1%(3,3))\n    open(modFile2, \'w\').write(modCode2%""message 3"")\n    \n    print(""\\n----RELOAD-----\\n"")\n    reloadAll(os.path.abspath(__file__)[:10], debug=True)\n\n    if doQtTest:\n        print(""Button test after:"")\n        btn.emit()\n        #btn.sig.emit()\n\n    #print ""a1.fn referrers:"", sys.getrefcount(a1.fn.im_func), gc.get_referrers(a1.fn.im_func)\n\n    print(""Test2 after reload:"")\n    fn()\n    test2.a1.fn()\n    test2.b1.fn()\n    \n    print(""\\n==> Test 1 Old instances:"")\n    a1.fn()\n    b1.fn()\n    print(""function IDs  a1 bound method: %d a1 func: %d  a1 class: %d  b1 func: %d  b1 class: %d"" % (id(a1.fn), id(a1.fn.__func__), id(a1.fn.__self__.__class__), id(b1.fn.__func__), id(b1.fn.__self__.__class__)))\n\n    print(""\\n==> Test 1 New instances:"")\n    a2 = test1.A(""a2"")\n    b2 = test1.B(""b2"")\n    a2.fn()\n    b2.fn()\n    print(""function IDs  a1 bound method: %d a1 func: %d  a1 class: %d  b1 func: %d  b1 class: %d"" % (id(a1.fn), id(a1.fn.__func__), id(a1.fn.__self__.__class__), id(b1.fn.__func__), id(b1.fn.__self__.__class__)))\n\n\n    os.remove(modFile1)\n    os.remove(modFile2)\n    os.remove(modFile1+\'c\')\n    os.remove(modFile2+\'c\')\n    os.system(\'rm -r test1\')\n\n\n\n\n\n\n\n\n#\n#        Failure graveyard ahead:\n#\n\n\n""""""Reload Importer:\nHooks into import system to \n1) keep a record of module dependencies as they are imported\n2) make sure modules are always reloaded in correct order\n3) update old classes and functions to use reloaded code""""""\n\n#import imp, sys\n\n## python\'s import hook mechanism doesn\'t work since we need to be \n## informed every time there is an import statement, not just for new imports\n#class ReloadImporter:\n    #def __init__(self):\n        #self.depth = 0\n        \n    #def find_module(self, name, path):\n        #print ""  ""*self.depth + ""find: "", name, path\n        ##if name == \'PyQt4\' and path is None:\n            ##print ""PyQt4 -> PySide""\n            ##self.modData = imp.find_module(\'PySide\')\n            ##return self\n        ##return None ## return none to allow the import to proceed normally; return self to intercept with load_module\n        #self.modData = imp.find_module(name, path)\n        #self.depth += 1\n        ##sys.path_importer_cache = {}\n        #return self\n        \n    #def load_module(self, name):\n        #mod =  imp.load_module(name, *self.modData)\n        #self.depth -= 1\n        #print ""  ""*self.depth + ""load: "", name\n        #return mod\n\n#def pathHook(path):\n    #print ""path hook:"", path\n    #raise ImportError\n#sys.path_hooks.append(pathHook)\n\n#sys.meta_path.append(ReloadImporter())\n\n\n### replace __import__ with a wrapper that tracks module dependencies\n#modDeps = {}\n#reloadModule = None\n#origImport = __builtins__.__import__\n#def _import(name, globals=None, locals=None, fromlist=None, level=-1, stack=[]):\n    ### Note that stack behaves as a static variable.\n    ##print ""  ""*len(importStack) + ""import %s"" % args[0]\n    #stack.append(set())\n    #mod = origImport(name, globals, locals, fromlist, level)\n    #deps = stack.pop()\n    #if len(stack) > 0:\n        #stack[-1].add(mod)\n    #elif reloadModule is not None:     ## If this is the top level import AND we\'re inside a module reload\n        #modDeps[reloadModule].add(mod)\n            \n    #if mod in modDeps:\n        #modDeps[mod] |= deps\n    #else:\n        #modDeps[mod] = deps\n        \n    \n    #return mod\n    \n#__builtins__.__import__ = _import\n\n### replace \n#origReload = __builtins__.reload\n#def _reload(mod):\n    #reloadModule = mod\n    #ret = origReload(mod)\n    #reloadModule = None\n    #return ret\n#__builtins__.reload = _reload\n\n\n#def reload(mod, visited=None):\n    #if visited is None:\n        #visited = set()\n    #if mod in visited:\n        #return\n    #visited.add(mod)\n    #for dep in modDeps.get(mod, []):\n        #reload(dep, visited)\n    #__builtins__.reload(mod)\n'"
src/third_party/pyqtgraph/units.py,0,"b'# -*- coding: utf-8 -*-\n## Very simple unit support:\n##  - creates variable names like \'mV\' and \'kHz\'\n##  - the value assigned to the variable corresponds to the scale prefix\n##    (mV = 0.001)\n##  - the actual units are purely cosmetic for making code clearer:\n##  \n##    x = 20*pA    is identical to    x = 20*1e-12\n\n## No unicode variable names (\xce\xbc,\xce\xa9) allowed until python 3\n\nSI_PREFIXES = \'yzafpnum kMGTPEZY\'\nUNITS = \'m,s,g,W,J,V,A,F,T,Hz,Ohm,S,N,C,px,b,B\'.split(\',\')\nallUnits = {}\n\ndef addUnit(p, n):\n    g = globals()\n    v = 1000**n\n    for u in UNITS:\n        g[p+u] = v\n        allUnits[p+u] = v\n    \nfor p in SI_PREFIXES:\n    if p ==  \' \':\n        p = \'\'\n        n = 0\n    elif p == \'u\':\n        n = -2\n    else:\n        n = SI_PREFIXES.index(p) - 8\n\n    addUnit(p, n)\n\ncm = 0.01\n\n\n\n\n\n\ndef evalUnits(unitStr):\n    """"""\n    Evaluate a unit string into ([numerators,...], [denominators,...])\n    Examples:\n        N m/s^2   =>  ([N, m], [s, s])\n        A*s / V   =>  ([A, s], [V,])\n    """"""\n    pass\n    \ndef formatUnits(units):\n    """"""\n    Format a unit specification ([numerators,...], [denominators,...])\n    into a string (this is the inverse of evalUnits)\n    """"""\n    pass\n    \ndef simplify(units):\n    """"""\n    Cancel units that appear in both numerator and denominator, then attempt to replace \n    groups of units with single units where possible (ie, J/s => W)\n    """"""\n    pass\n    \n    '"
src/third_party/pyqtgraph/GraphicsScene/GraphicsScene.py,0,"b'import weakref\nfrom ..Qt import QtCore, QtGui\nfrom ..python2_3 import sortList, cmp\nfrom ..Point import Point\nfrom .. import functions as fn\nfrom .. import ptime as ptime\nfrom .mouseEvents import *\nfrom .. import debug as debug\n\n\nif hasattr(QtCore, \'PYQT_VERSION\'):\n    try:\n        import sip\n        HAVE_SIP = True\n    except ImportError:\n        HAVE_SIP = False\nelse:\n    HAVE_SIP = False\n\n\n__all__ = [\'GraphicsScene\']\n\nclass GraphicsScene(QtGui.QGraphicsScene):\n    """"""\n    Extension of QGraphicsScene that implements a complete, parallel mouse event system.\n    (It would have been preferred to just alter the way QGraphicsScene creates and delivers \n    events, but this turned out to be impossible because the constructor for QGraphicsMouseEvent\n    is private)\n    \n    *  Generates MouseClicked events in addition to the usual press/move/release events. \n       (This works around a problem where it is impossible to have one item respond to a \n       drag if another is watching for a click.)\n    *  Adjustable radius around click that will catch objects so you don\'t have to click *exactly* over small/thin objects\n    *  Global context menu--if an item implements a context menu, then its parent(s) may also add items to the menu.\n    *  Allows items to decide _before_ a mouse click which item will be the recipient of mouse events.\n       This lets us indicate unambiguously to the user which item they are about to click/drag on\n    *  Eats mouseMove events that occur too soon after a mouse press.\n    *  Reimplements items() and itemAt() to circumvent PyQt bug\n\n    ====================== ==================================================================\n    **Signals**\n    sigMouseClicked(event) Emitted when the mouse is clicked over the scene. Use ev.pos() to\n                           get the click position relative to the item that was clicked on,\n                           or ev.scenePos() to get the click position in scene coordinates.\n                           See :class:`pyqtgraph.GraphicsScene.MouseClickEvent`.                        \n    sigMouseMoved(pos)     Emitted when the mouse cursor moves over the scene. The position\n                           is given in scene coordinates.\n    sigMouseHover(items)   Emitted when the mouse is moved over the scene. Items is a list\n                           of items under the cursor.\n    ====================== ==================================================================\n    \n    Mouse interaction is as follows:\n    \n    1) Every time the mouse moves, the scene delivers both the standard hoverEnter/Move/LeaveEvents \n       as well as custom HoverEvents. \n    2) Items are sent HoverEvents in Z-order and each item may optionally call event.acceptClicks(button), \n       acceptDrags(button) or both. If this method call returns True, this informs the item that _if_ \n       the user clicks/drags the specified mouse button, the item is guaranteed to be the \n       recipient of click/drag events (the item may wish to change its appearance to indicate this).\n       If the call to acceptClicks/Drags returns False, then the item is guaranteed to *not* receive\n       the requested event (because another item has already accepted it). \n    3) If the mouse is clicked, a mousePressEvent is generated as usual. If any items accept this press event, then\n       No click/drag events will be generated and mouse interaction proceeds as defined by Qt. This allows\n       items to function properly if they are expecting the usual press/move/release sequence of events.\n       (It is recommended that items do NOT accept press events, and instead use click/drag events)\n       Note: The default implementation of QGraphicsItem.mousePressEvent will *accept* the event if the \n       item is has its Selectable or Movable flags enabled. You may need to override this behavior.\n    4) If no item accepts the mousePressEvent, then the scene will begin delivering mouseDrag and/or mouseClick events.\n       If the mouse is moved a sufficient distance (or moved slowly enough) before the button is released, \n       then a mouseDragEvent is generated.\n       If no drag events are generated before the button is released, then a mouseClickEvent is generated. \n    5) Click/drag events are delivered to the item that called acceptClicks/acceptDrags on the HoverEvent\n       in step 1. If no such items exist, then the scene attempts to deliver the events to items near the event. \n       ClickEvents may be delivered in this way even if no\n       item originally claimed it could accept the click. DragEvents may only be delivered this way if it is the initial\n       move in a drag.\n    """"""\n    \n    sigMouseHover = QtCore.Signal(object)   ## emits a list of objects hovered over\n    sigMouseMoved = QtCore.Signal(object)   ## emits position of mouse on every move\n    sigMouseClicked = QtCore.Signal(object)   ## emitted when mouse is clicked. Check for event.isAccepted() to see whether the event has already been acted on.\n    \n    sigPrepareForPaint = QtCore.Signal()  ## emitted immediately before the scene is about to be rendered\n    \n    _addressCache = weakref.WeakValueDictionary()\n    \n    ExportDirectory = None\n    \n    @classmethod\n    def registerObject(cls, obj):\n        """"""\n        Workaround for PyQt bug in qgraphicsscene.items()\n        All subclasses of QGraphicsObject must register themselves with this function.\n        (otherwise, mouse interaction with those objects will likely fail)\n        """"""\n        if HAVE_SIP and isinstance(obj, sip.wrapper):\n            cls._addressCache[sip.unwrapinstance(sip.cast(obj, QtGui.QGraphicsItem))] = obj\n            \n            \n    def __init__(self, clickRadius=2, moveDistance=5, parent=None):\n        QtGui.QGraphicsScene.__init__(self, parent)\n        self.setClickRadius(clickRadius)\n        self.setMoveDistance(moveDistance)\n        self.exportDirectory = None\n        \n        self.clickEvents = []\n        self.dragButtons = []\n        self.mouseGrabber = None\n        self.dragItem = None\n        self.lastDrag = None\n        self.hoverItems = weakref.WeakKeyDictionary()\n        self.lastHoverEvent = None\n        self.minDragTime = 0.5  # drags shorter than 0.5 sec are interpreted as clicks\n        \n        self.contextMenu = [QtGui.QAction(""Export..."", self)]\n        self.contextMenu[0].triggered.connect(self.showExportDialog)\n        \n        self.exportDialog = None\n        \n    def render(self, *args):\n        self.prepareForPaint()\n        return QtGui.QGraphicsScene.render(self, *args)\n\n    def prepareForPaint(self):\n        """"""Called before every render. This method will inform items that the scene is about to\n        be rendered by emitting sigPrepareForPaint.\n        \n        This allows items to delay expensive processing until they know a paint will be required.""""""\n        self.sigPrepareForPaint.emit()\n    \n\n    def setClickRadius(self, r):\n        """"""\n        Set the distance away from mouse clicks to search for interacting items.\n        When clicking, the scene searches first for items that directly intersect the click position\n        followed by any other items that are within a rectangle that extends r pixels away from the \n        click position. \n        """"""\n        self._clickRadius = r\n        \n    def setMoveDistance(self, d):\n        """"""\n        Set the distance the mouse must move after a press before mouseMoveEvents will be delivered.\n        This ensures that clicks with a small amount of movement are recognized as clicks instead of\n        drags.\n        """"""\n        self._moveDistance = d\n\n    def mousePressEvent(self, ev):\n        QtGui.QGraphicsScene.mousePressEvent(self, ev)\n        if self.mouseGrabberItem() is None:  ## nobody claimed press; we are free to generate drag/click events\n            if self.lastHoverEvent is not None:\n                # If the mouse has moved since the last hover event, send a new one.\n                # This can happen if a context menu is open while the mouse is moving.\n                if ev.scenePos() != self.lastHoverEvent.scenePos():\n                    self.sendHoverEvents(ev)\n            \n            self.clickEvents.append(MouseClickEvent(ev))\n            \n            ## set focus on the topmost focusable item under this click\n            items = self.items(ev.scenePos())\n            for i in items:\n                if i.isEnabled() and i.isVisible() and int(i.flags() & i.ItemIsFocusable) > 0:\n                    i.setFocus(QtCore.Qt.MouseFocusReason)\n                    break\n        \n    def mouseMoveEvent(self, ev):\n        self.sigMouseMoved.emit(ev.scenePos())\n        \n        ## First allow QGraphicsScene to deliver hoverEnter/Move/ExitEvents\n        QtGui.QGraphicsScene.mouseMoveEvent(self, ev)\n        \n        ## Next deliver our own HoverEvents\n        self.sendHoverEvents(ev)\n        \n        if int(ev.buttons()) != 0:  ## button is pressed; send mouseMoveEvents and mouseDragEvents\n            QtGui.QGraphicsScene.mouseMoveEvent(self, ev)\n            if self.mouseGrabberItem() is None:\n                now = ptime.time()\n                init = False\n                ## keep track of which buttons are involved in dragging\n                for btn in [QtCore.Qt.LeftButton, QtCore.Qt.MidButton, QtCore.Qt.RightButton]:\n                    if int(ev.buttons() & btn) == 0:\n                        continue\n                    if int(btn) not in self.dragButtons:  ## see if we\'ve dragged far enough yet\n                        cev = [e for e in self.clickEvents if int(e.button()) == int(btn)][0]\n                        dist = Point(ev.scenePos() - cev.scenePos()).length()\n                        if dist == 0 or (dist < self._moveDistance and now - cev.time() < self.minDragTime):\n                            continue\n                        init = init or (len(self.dragButtons) == 0)  ## If this is the first button to be dragged, then init=True\n                        self.dragButtons.append(int(btn))\n                        \n                ## If we have dragged buttons, deliver a drag event\n                if len(self.dragButtons) > 0:\n                    if self.sendDragEvent(ev, init=init):\n                        ev.accept()\n                \n    def leaveEvent(self, ev):  ## inform items that mouse is gone\n        if len(self.dragButtons) == 0:\n            self.sendHoverEvents(ev, exitOnly=True)\n                \n    def mouseReleaseEvent(self, ev):\n        if self.mouseGrabberItem() is None:\n            if ev.button() in self.dragButtons:\n                if self.sendDragEvent(ev, final=True):\n                    #print ""sent drag event""\n                    ev.accept()\n                self.dragButtons.remove(ev.button())\n            else:\n                cev = [e for e in self.clickEvents if int(e.button()) == int(ev.button())]\n                if self.sendClickEvent(cev[0]):\n                    #print ""sent click event""\n                    ev.accept()\n                self.clickEvents.remove(cev[0])\n                \n        if int(ev.buttons()) == 0:\n            self.dragItem = None\n            self.dragButtons = []\n            self.clickEvents = []\n            self.lastDrag = None\n        QtGui.QGraphicsScene.mouseReleaseEvent(self, ev)\n        \n        self.sendHoverEvents(ev)  ## let items prepare for next click/drag\n\n    def mouseDoubleClickEvent(self, ev):\n        QtGui.QGraphicsScene.mouseDoubleClickEvent(self, ev)\n        if self.mouseGrabberItem() is None:  ## nobody claimed press; we are free to generate drag/click events\n            self.clickEvents.append(MouseClickEvent(ev, double=True))\n        \n    def sendHoverEvents(self, ev, exitOnly=False):\n        ## if exitOnly, then just inform all previously hovered items that the mouse has left.\n        \n        if exitOnly:\n            acceptable=False\n            items = []\n            event = HoverEvent(None, acceptable)\n        else:\n            acceptable = int(ev.buttons()) == 0  ## if we are in mid-drag, do not allow items to accept the hover event.\n            event = HoverEvent(ev, acceptable)\n            items = self.itemsNearEvent(event, hoverable=True)\n            self.sigMouseHover.emit(items)\n            \n        prevItems = list(self.hoverItems.keys())\n            \n        for item in items:\n            if hasattr(item, \'hoverEvent\'):\n                event.currentItem = item\n                if item not in self.hoverItems:\n                    self.hoverItems[item] = None\n                    event.enter = True\n                else:\n                    prevItems.remove(item)\n                    event.enter = False\n                    \n                try:\n                    item.hoverEvent(event)\n                except:\n                    debug.printExc(""Error sending hover event:"")\n        \n        event.enter = False\n        event.exit = True\n        #print ""hover exit items:"", prevItems\n        for item in prevItems:\n            event.currentItem = item\n            try:\n                item.hoverEvent(event)\n            except:\n                debug.printExc(""Error sending hover exit event:"")\n            finally:\n                del self.hoverItems[item]\n        \n        # Update last hover event unless:\n        #   - mouse is dragging (move+buttons); in this case we want the dragged\n        #     item to continue receiving events until the drag is over\n        #   - event is not a mouse event (QEvent.Leave sometimes appears here)\n        if (ev.type() == ev.GraphicsSceneMousePress or \n            (ev.type() == ev.GraphicsSceneMouseMove and int(ev.buttons()) == 0)):\n            self.lastHoverEvent = event  ## save this so we can ask about accepted events later.\n\n    def sendDragEvent(self, ev, init=False, final=False):\n        ## Send a MouseDragEvent to the current dragItem or to \n        ## items near the beginning of the drag\n        event = MouseDragEvent(ev, self.clickEvents[0], self.lastDrag, start=init, finish=final)\n        #print ""dragEvent: init="", init, \'final=\', final, \'self.dragItem=\', self.dragItem\n        if init and self.dragItem is None:\n            if self.lastHoverEvent is not None:\n                acceptedItem = self.lastHoverEvent.dragItems().get(event.button(), None)\n            else:\n                acceptedItem = None\n                \n            if acceptedItem is not None:\n                #print ""Drag -> pre-selected item:"", acceptedItem\n                self.dragItem = acceptedItem\n                event.currentItem = self.dragItem\n                try:\n                    self.dragItem.mouseDragEvent(event)\n                except:\n                    debug.printExc(""Error sending drag event:"")\n                    \n            else:\n                #print ""drag -> new item""\n                for item in self.itemsNearEvent(event):\n                    #print ""check item:"", item\n                    if not item.isVisible() or not item.isEnabled():\n                        continue\n                    if hasattr(item, \'mouseDragEvent\'):\n                        event.currentItem = item\n                        try:\n                            item.mouseDragEvent(event)\n                        except:\n                            debug.printExc(""Error sending drag event:"")\n                        if event.isAccepted():\n                            #print ""   --> accepted""\n                            self.dragItem = item\n                            if int(item.flags() & item.ItemIsFocusable) > 0:\n                                item.setFocus(QtCore.Qt.MouseFocusReason)\n                            break\n        elif self.dragItem is not None:\n            event.currentItem = self.dragItem\n            try:\n                self.dragItem.mouseDragEvent(event)\n            except:\n                debug.printExc(""Error sending hover exit event:"")\n            \n        self.lastDrag = event\n        \n        return event.isAccepted()\n            \n        \n    def sendClickEvent(self, ev):\n        ## if we are in mid-drag, click events may only go to the dragged item.\n        if self.dragItem is not None and hasattr(self.dragItem, \'mouseClickEvent\'):\n            ev.currentItem = self.dragItem\n            self.dragItem.mouseClickEvent(ev)\n            \n        ## otherwise, search near the cursor\n        else:\n            if self.lastHoverEvent is not None:\n                acceptedItem = self.lastHoverEvent.clickItems().get(ev.button(), None)\n            else:\n                acceptedItem = None\n            if acceptedItem is not None:\n                ev.currentItem = acceptedItem\n                try:\n                    acceptedItem.mouseClickEvent(ev)\n                except:\n                    debug.printExc(""Error sending click event:"")\n            else:\n                for item in self.itemsNearEvent(ev):\n                    if not item.isVisible() or not item.isEnabled():\n                        continue\n                    if hasattr(item, \'mouseClickEvent\'):\n                        ev.currentItem = item\n                        try:\n                            item.mouseClickEvent(ev)\n                        except:\n                            debug.printExc(""Error sending click event:"")\n                            \n                        if ev.isAccepted():\n                            if int(item.flags() & item.ItemIsFocusable) > 0:\n                                item.setFocus(QtCore.Qt.MouseFocusReason)\n                            break\n        self.sigMouseClicked.emit(ev)\n        return ev.isAccepted()\n        \n    def items(self, *args):\n        #print \'args:\', args\n        items = QtGui.QGraphicsScene.items(self, *args)\n        ## PyQt bug: items() returns a list of QGraphicsItem instances. If the item is subclassed from QGraphicsObject,\n        ## then the object returned will be different than the actual item that was originally added to the scene\n        items2 = list(map(self.translateGraphicsItem, items))\n        #if HAVE_SIP and isinstance(self, sip.wrapper):\n            #items2 = []\n            #for i in items:\n                #addr = sip.unwrapinstance(sip.cast(i, QtGui.QGraphicsItem))\n                #i2 = GraphicsScene._addressCache.get(addr, i)\n                ##print i, ""==>"", i2\n                #items2.append(i2)\n        #print \'items:\', items\n        return items2\n    \n    def selectedItems(self, *args):\n        items = QtGui.QGraphicsScene.selectedItems(self, *args)\n        ## PyQt bug: items() returns a list of QGraphicsItem instances. If the item is subclassed from QGraphicsObject,\n        ## then the object returned will be different than the actual item that was originally added to the scene\n        #if HAVE_SIP and isinstance(self, sip.wrapper):\n            #items2 = []\n            #for i in items:\n                #addr = sip.unwrapinstance(sip.cast(i, QtGui.QGraphicsItem))\n                #i2 = GraphicsScene._addressCache.get(addr, i)\n                ##print i, ""==>"", i2\n                #items2.append(i2)\n        items2 = list(map(self.translateGraphicsItem, items))\n\n        #print \'items:\', items\n        return items2\n\n    def itemAt(self, *args):\n        item = QtGui.QGraphicsScene.itemAt(self, *args)\n        \n        ## PyQt bug: items() returns a list of QGraphicsItem instances. If the item is subclassed from QGraphicsObject,\n        ## then the object returned will be different than the actual item that was originally added to the scene\n        #if HAVE_SIP and isinstance(self, sip.wrapper):\n            #addr = sip.unwrapinstance(sip.cast(item, QtGui.QGraphicsItem))\n            #item = GraphicsScene._addressCache.get(addr, item)\n        #return item\n        return self.translateGraphicsItem(item)\n\n    def itemsNearEvent(self, event, selMode=QtCore.Qt.IntersectsItemShape, sortOrder=QtCore.Qt.DescendingOrder, hoverable=False):\n        """"""\n        Return an iterator that iterates first through the items that directly intersect point (in Z order)\n        followed by any other items that are within the scene\'s click radius.\n        """"""\n        #tr = self.getViewWidget(event.widget()).transform()\n        view = self.views()[0]\n        tr = view.viewportTransform()\n        r = self._clickRadius\n        rect = view.mapToScene(QtCore.QRect(0, 0, 2*r, 2*r)).boundingRect()\n        \n        seen = set()\n        if hasattr(event, \'buttonDownScenePos\'):\n            point = event.buttonDownScenePos()\n        else:\n            point = event.scenePos()\n        w = rect.width()\n        h = rect.height()\n        rgn = QtCore.QRectF(point.x()-w, point.y()-h, 2*w, 2*h)\n        #self.searchRect.setRect(rgn)\n\n\n        items = self.items(point, selMode, sortOrder, tr)\n        \n        ## remove items whose shape does not contain point (scene.items() apparently sucks at this)\n        items2 = []\n        for item in items:\n            if hoverable and not hasattr(item, \'hoverEvent\'):\n                continue\n            shape = item.shape() # Note: default shape() returns boundingRect()\n            if shape is None:\n                continue\n            if shape.contains(item.mapFromScene(point)):\n                items2.append(item)\n        \n        ## Sort by descending Z-order (don\'t trust scene.itms() to do this either)\n        ## use \'absolute\' z value, which is the sum of all item/parent ZValues\n        def absZValue(item):\n            if item is None:\n                return 0\n            return item.zValue() + absZValue(item.parentItem())\n        \n        sortList(items2, lambda a,b: cmp(absZValue(b), absZValue(a)))\n        \n        return items2\n        \n        #for item in items:\n            ##seen.add(item)\n\n            #shape = item.mapToScene(item.shape())\n            #if not shape.contains(point):\n                #continue\n            #yield item\n        #for item in self.items(rgn, selMode, sortOrder, tr):\n            ##if item not in seen:\n            #yield item\n        \n    def getViewWidget(self):\n        return self.views()[0]\n    \n    #def getViewWidget(self, widget):\n        ### same pyqt bug -- mouseEvent.widget() doesn\'t give us the original python object.\n        ### [[doesn\'t seem to work correctly]]\n        #if HAVE_SIP and isinstance(self, sip.wrapper):\n            #addr = sip.unwrapinstance(sip.cast(widget, QtGui.QWidget))\n            ##print ""convert"", widget, addr\n            #for v in self.views():\n                #addr2 = sip.unwrapinstance(sip.cast(v, QtGui.QWidget))\n                ##print ""   check:"", v, addr2\n                #if addr2 == addr:\n                    #return v\n        #else:\n            #return widget\n\n    def addParentContextMenus(self, item, menu, event):\n        """"""\n        Can be called by any item in the scene to expand its context menu to include parent context menus.\n        Parents may implement getContextMenus to add new menus / actions to the existing menu.\n        getContextMenus must accept 1 argument (the event that generated the original menu) and\n        return a single QMenu or a list of QMenus.\n        \n        The final menu will look like:\n        \n            |    Original Item 1\n            |    Original Item 2\n            |    ...\n            |    Original Item N\n            |    ------------------\n            |    Parent Item 1\n            |    Parent Item 2\n            |    ...\n            |    Grandparent Item 1\n            |    ...\n            \n        \n        ==============  ==================================================\n        **Arguments:**\n        item            The item that initially created the context menu \n                        (This is probably the item making the call to this function)\n        menu            The context menu being shown by the item\n        event           The original event that triggered the menu to appear.\n        ==============  ==================================================\n        """"""\n\n        menusToAdd = []\n        while item is not self:\n            item = item.parentItem()\n            if item is None:\n                item = self\n            if not hasattr(item, ""getContextMenus""):\n                continue\n            subMenus = item.getContextMenus(event) or []\n            if isinstance(subMenus, list): ## so that some items (like FlowchartViewBox) can return multiple menus\n                menusToAdd.extend(subMenus)\n            else:\n                menusToAdd.append(subMenus)\n\n        if menusToAdd:\n            menu.addSeparator()\n\n        for m in menusToAdd:\n            if isinstance(m, QtGui.QMenu):\n                menu.addMenu(m)\n            elif isinstance(m, QtGui.QAction):\n                menu.addAction(m)\n            else:\n                raise Exception(""Cannot add object %s (type=%s) to QMenu."" % (str(m), str(type(m))))\n            \n        return menu\n\n    def getContextMenus(self, event):\n        self.contextMenuItem = event.acceptedItem\n        return self.contextMenu\n\n    def showExportDialog(self):\n        if self.exportDialog is None:\n            from . import exportDialog\n            self.exportDialog = exportDialog.ExportDialog(self)\n        self.exportDialog.show(self.contextMenuItem)\n\n    @staticmethod\n    def translateGraphicsItem(item):\n        ## for fixing pyqt bugs where the wrong item is returned\n        if HAVE_SIP and isinstance(item, sip.wrapper):\n            addr = sip.unwrapinstance(sip.cast(item, QtGui.QGraphicsItem))\n            item = GraphicsScene._addressCache.get(addr, item)\n        return item\n\n    @staticmethod\n    def translateGraphicsItems(items):\n        return list(map(GraphicsScene.translateGraphicsItem, items))\n\n\n\n'"
src/third_party/pyqtgraph/GraphicsScene/__init__.py,0,b'from .GraphicsScene import *\n'
src/third_party/pyqtgraph/GraphicsScene/exportDialog.py,0,"b'from ..Qt import QtCore, QtGui, QT_LIB\nfrom .. import exporters as exporters\nfrom .. import functions as fn\nfrom ..graphicsItems.ViewBox import ViewBox\nfrom ..graphicsItems.PlotItem import PlotItem\n\nif QT_LIB == \'PySide\':\n    from . import exportDialogTemplate_pyside as exportDialogTemplate\nelif QT_LIB == \'PySide2\':\n    from . import exportDialogTemplate_pyside2 as exportDialogTemplate\nelif QT_LIB == \'PyQt5\':\n    from . import exportDialogTemplate_pyqt5 as exportDialogTemplate\nelse:\n    from . import exportDialogTemplate_pyqt as exportDialogTemplate\n\n\nclass ExportDialog(QtGui.QWidget):\n    def __init__(self, scene):\n        QtGui.QWidget.__init__(self)\n        self.setVisible(False)\n        self.setWindowTitle(""Export"")\n        self.shown = False\n        self.currentExporter = None\n        self.scene = scene\n            \n        self.selectBox = QtGui.QGraphicsRectItem()\n        self.selectBox.setPen(fn.mkPen(\'y\', width=3, style=QtCore.Qt.DashLine))\n        self.selectBox.hide()\n        self.scene.addItem(self.selectBox)\n        \n        self.ui = exportDialogTemplate.Ui_Form()\n        self.ui.setupUi(self)\n        \n        self.ui.closeBtn.clicked.connect(self.close)\n        self.ui.exportBtn.clicked.connect(self.exportClicked)\n        self.ui.copyBtn.clicked.connect(self.copyClicked)\n        self.ui.itemTree.currentItemChanged.connect(self.exportItemChanged)\n        self.ui.formatList.currentItemChanged.connect(self.exportFormatChanged)\n        \n\n    def show(self, item=None):\n        if item is not None:\n            ## Select next exportable parent of the item originally clicked on\n            while not isinstance(item, ViewBox) and not isinstance(item, PlotItem) and item is not None:\n                item = item.parentItem()\n            ## if this is a ViewBox inside a PlotItem, select the parent instead.\n            if isinstance(item, ViewBox) and isinstance(item.parentItem(), PlotItem):\n                item = item.parentItem()\n            self.updateItemList(select=item)\n        self.setVisible(True)\n        self.activateWindow()\n        self.raise_()\n        self.selectBox.setVisible(True)\n        \n        if not self.shown:\n            self.shown = True\n            vcenter = self.scene.getViewWidget().geometry().center()\n            self.setGeometry(vcenter.x()-self.width()/2, vcenter.y()-self.height()/2, self.width(), self.height())\n        \n    def updateItemList(self, select=None):\n        self.ui.itemTree.clear()\n        si = QtGui.QTreeWidgetItem([""Entire Scene""])\n        si.gitem = self.scene\n        self.ui.itemTree.addTopLevelItem(si)\n        self.ui.itemTree.setCurrentItem(si)\n        si.setExpanded(True)\n        for child in self.scene.items():\n            if child.parentItem() is None:\n                self.updateItemTree(child, si, select=select)\n                \n    def updateItemTree(self, item, treeItem, select=None):\n        si = None\n        if isinstance(item, ViewBox):\n            si = QtGui.QTreeWidgetItem([\'ViewBox\'])\n        elif isinstance(item, PlotItem):\n            si = QtGui.QTreeWidgetItem([\'Plot\'])\n            \n        if si is not None:\n            si.gitem = item\n            treeItem.addChild(si)\n            treeItem = si\n            if si.gitem is select:\n                self.ui.itemTree.setCurrentItem(si)\n            \n        for ch in item.childItems():\n            self.updateItemTree(ch, treeItem, select=select)\n        \n            \n    def exportItemChanged(self, item, prev):\n        if item is None:\n            return\n        if item.gitem is self.scene:\n            newBounds = self.scene.views()[0].viewRect()\n        else:\n            newBounds = item.gitem.sceneBoundingRect()\n        self.selectBox.setRect(newBounds)\n        self.selectBox.show()\n        self.updateFormatList()\n        \n    def updateFormatList(self):\n        current = self.ui.formatList.currentItem()\n        if current is not None:\n            current = str(current.text())\n        self.ui.formatList.clear()\n        self.exporterClasses = {}\n        gotCurrent = False\n        for exp in exporters.listExporters():\n            self.ui.formatList.addItem(exp.Name)\n            self.exporterClasses[exp.Name] = exp\n            if exp.Name == current:\n                self.ui.formatList.setCurrentRow(self.ui.formatList.count()-1)\n                gotCurrent = True\n                \n        if not gotCurrent:\n            self.ui.formatList.setCurrentRow(0)\n        \n    def exportFormatChanged(self, item, prev):\n        if item is None:\n            self.currentExporter = None\n            self.ui.paramTree.clear()\n            return\n        expClass = self.exporterClasses[str(item.text())]\n        exp = expClass(item=self.ui.itemTree.currentItem().gitem)\n        params = exp.parameters()\n        if params is None:\n            self.ui.paramTree.clear()\n        else:\n            self.ui.paramTree.setParameters(params)\n        self.currentExporter = exp\n        self.ui.copyBtn.setEnabled(exp.allowCopy)\n        \n    def exportClicked(self):\n        self.selectBox.hide()\n        self.currentExporter.export()\n        \n    def copyClicked(self):\n        self.selectBox.hide()\n        self.currentExporter.export(copy=True)\n        \n    def close(self):\n        self.selectBox.setVisible(False)\n        self.setVisible(False)\n\n    def closeEvent(self, event):\n        self.close()\n        QtGui.QWidget.closeEvent(self, event)\n'"
src/third_party/pyqtgraph/GraphicsScene/exportDialogTemplate_pyqt.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/GraphicsScene/exportDialogTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:52 2013\n#      by: PyQt4 UI code generator 4.10\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt4 import QtCore, QtGui\n\ntry:\n    _fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n    def _fromUtf8(s):\n        return s\n\ntry:\n    _encoding = QtGui.QApplication.UnicodeUTF8\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig, _encoding)\nexcept AttributeError:\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig)\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(""Form""))\n        Form.resize(241, 367)\n        self.gridLayout = QtGui.QGridLayout(Form)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(_fromUtf8(""gridLayout""))\n        self.label = QtGui.QLabel(Form)\n        self.label.setObjectName(_fromUtf8(""label""))\n        self.gridLayout.addWidget(self.label, 0, 0, 1, 3)\n        self.itemTree = QtGui.QTreeWidget(Form)\n        self.itemTree.setObjectName(_fromUtf8(""itemTree""))\n        self.itemTree.headerItem().setText(0, _fromUtf8(""1""))\n        self.itemTree.header().setVisible(False)\n        self.gridLayout.addWidget(self.itemTree, 1, 0, 1, 3)\n        self.label_2 = QtGui.QLabel(Form)\n        self.label_2.setObjectName(_fromUtf8(""label_2""))\n        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 3)\n        self.formatList = QtGui.QListWidget(Form)\n        self.formatList.setObjectName(_fromUtf8(""formatList""))\n        self.gridLayout.addWidget(self.formatList, 3, 0, 1, 3)\n        self.exportBtn = QtGui.QPushButton(Form)\n        self.exportBtn.setObjectName(_fromUtf8(""exportBtn""))\n        self.gridLayout.addWidget(self.exportBtn, 6, 1, 1, 1)\n        self.closeBtn = QtGui.QPushButton(Form)\n        self.closeBtn.setObjectName(_fromUtf8(""closeBtn""))\n        self.gridLayout.addWidget(self.closeBtn, 6, 2, 1, 1)\n        self.paramTree = ParameterTree(Form)\n        self.paramTree.setObjectName(_fromUtf8(""paramTree""))\n        self.paramTree.headerItem().setText(0, _fromUtf8(""1""))\n        self.paramTree.header().setVisible(False)\n        self.gridLayout.addWidget(self.paramTree, 5, 0, 1, 3)\n        self.label_3 = QtGui.QLabel(Form)\n        self.label_3.setObjectName(_fromUtf8(""label_3""))\n        self.gridLayout.addWidget(self.label_3, 4, 0, 1, 3)\n        self.copyBtn = QtGui.QPushButton(Form)\n        self.copyBtn.setObjectName(_fromUtf8(""copyBtn""))\n        self.gridLayout.addWidget(self.copyBtn, 6, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(_translate(""Form"", ""Export"", None))\n        self.label.setText(_translate(""Form"", ""Item to export:"", None))\n        self.label_2.setText(_translate(""Form"", ""Export format"", None))\n        self.exportBtn.setText(_translate(""Form"", ""Export"", None))\n        self.closeBtn.setText(_translate(""Form"", ""Close"", None))\n        self.label_3.setText(_translate(""Form"", ""Export options"", None))\n        self.copyBtn.setText(_translate(""Form"", ""Copy"", None))\n\nfrom ..parametertree import ParameterTree\n'"
src/third_party/pyqtgraph/GraphicsScene/exportDialogTemplate_pyqt5.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/GraphicsScene/exportDialogTemplate.ui\'\n#\n# Created: Wed Mar 26 15:09:29 2014\n#      by: PyQt5 UI code generator 5.0.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(241, 367)\n        self.gridLayout = QtWidgets.QGridLayout(Form)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.label = QtWidgets.QLabel(Form)\n        self.label.setObjectName(""label"")\n        self.gridLayout.addWidget(self.label, 0, 0, 1, 3)\n        self.itemTree = QtWidgets.QTreeWidget(Form)\n        self.itemTree.setObjectName(""itemTree"")\n        self.itemTree.headerItem().setText(0, ""1"")\n        self.itemTree.header().setVisible(False)\n        self.gridLayout.addWidget(self.itemTree, 1, 0, 1, 3)\n        self.label_2 = QtWidgets.QLabel(Form)\n        self.label_2.setObjectName(""label_2"")\n        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 3)\n        self.formatList = QtWidgets.QListWidget(Form)\n        self.formatList.setObjectName(""formatList"")\n        self.gridLayout.addWidget(self.formatList, 3, 0, 1, 3)\n        self.exportBtn = QtWidgets.QPushButton(Form)\n        self.exportBtn.setObjectName(""exportBtn"")\n        self.gridLayout.addWidget(self.exportBtn, 6, 1, 1, 1)\n        self.closeBtn = QtWidgets.QPushButton(Form)\n        self.closeBtn.setObjectName(""closeBtn"")\n        self.gridLayout.addWidget(self.closeBtn, 6, 2, 1, 1)\n        self.paramTree = ParameterTree(Form)\n        self.paramTree.setObjectName(""paramTree"")\n        self.paramTree.headerItem().setText(0, ""1"")\n        self.paramTree.header().setVisible(False)\n        self.gridLayout.addWidget(self.paramTree, 5, 0, 1, 3)\n        self.label_3 = QtWidgets.QLabel(Form)\n        self.label_3.setObjectName(""label_3"")\n        self.gridLayout.addWidget(self.label_3, 4, 0, 1, 3)\n        self.copyBtn = QtWidgets.QPushButton(Form)\n        self.copyBtn.setObjectName(""copyBtn"")\n        self.gridLayout.addWidget(self.copyBtn, 6, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Export""))\n        self.label.setText(_translate(""Form"", ""Item to export:""))\n        self.label_2.setText(_translate(""Form"", ""Export format""))\n        self.exportBtn.setText(_translate(""Form"", ""Export""))\n        self.closeBtn.setText(_translate(""Form"", ""Close""))\n        self.label_3.setText(_translate(""Form"", ""Export options""))\n        self.copyBtn.setText(_translate(""Form"", ""Copy""))\n\nfrom ..parametertree import ParameterTree\n'"
src/third_party/pyqtgraph/GraphicsScene/exportDialogTemplate_pyside.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/GraphicsScene/exportDialogTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:53 2013\n#      by: pyside-uic 0.2.14 running on PySide 1.1.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide import QtCore, QtGui\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(241, 367)\n        self.gridLayout = QtGui.QGridLayout(Form)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.label = QtGui.QLabel(Form)\n        self.label.setObjectName(""label"")\n        self.gridLayout.addWidget(self.label, 0, 0, 1, 3)\n        self.itemTree = QtGui.QTreeWidget(Form)\n        self.itemTree.setObjectName(""itemTree"")\n        self.itemTree.headerItem().setText(0, ""1"")\n        self.itemTree.header().setVisible(False)\n        self.gridLayout.addWidget(self.itemTree, 1, 0, 1, 3)\n        self.label_2 = QtGui.QLabel(Form)\n        self.label_2.setObjectName(""label_2"")\n        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 3)\n        self.formatList = QtGui.QListWidget(Form)\n        self.formatList.setObjectName(""formatList"")\n        self.gridLayout.addWidget(self.formatList, 3, 0, 1, 3)\n        self.exportBtn = QtGui.QPushButton(Form)\n        self.exportBtn.setObjectName(""exportBtn"")\n        self.gridLayout.addWidget(self.exportBtn, 6, 1, 1, 1)\n        self.closeBtn = QtGui.QPushButton(Form)\n        self.closeBtn.setObjectName(""closeBtn"")\n        self.gridLayout.addWidget(self.closeBtn, 6, 2, 1, 1)\n        self.paramTree = ParameterTree(Form)\n        self.paramTree.setObjectName(""paramTree"")\n        self.paramTree.headerItem().setText(0, ""1"")\n        self.paramTree.header().setVisible(False)\n        self.gridLayout.addWidget(self.paramTree, 5, 0, 1, 3)\n        self.label_3 = QtGui.QLabel(Form)\n        self.label_3.setObjectName(""label_3"")\n        self.gridLayout.addWidget(self.label_3, 4, 0, 1, 3)\n        self.copyBtn = QtGui.QPushButton(Form)\n        self.copyBtn.setObjectName(""copyBtn"")\n        self.gridLayout.addWidget(self.copyBtn, 6, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtGui.QApplication.translate(""Form"", ""Export"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label.setText(QtGui.QApplication.translate(""Form"", ""Item to export:"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label_2.setText(QtGui.QApplication.translate(""Form"", ""Export format"", None, QtGui.QApplication.UnicodeUTF8))\n        self.exportBtn.setText(QtGui.QApplication.translate(""Form"", ""Export"", None, QtGui.QApplication.UnicodeUTF8))\n        self.closeBtn.setText(QtGui.QApplication.translate(""Form"", ""Close"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label_3.setText(QtGui.QApplication.translate(""Form"", ""Export options"", None, QtGui.QApplication.UnicodeUTF8))\n        self.copyBtn.setText(QtGui.QApplication.translate(""Form"", ""Copy"", None, QtGui.QApplication.UnicodeUTF8))\n\nfrom ..parametertree import ParameterTree\n'"
src/third_party/pyqtgraph/GraphicsScene/exportDialogTemplate_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'exportDialogTemplate.ui\'\n#\n# Created: Sun Sep 18 19:19:58 2016\n#      by: pyside2-uic  running on PySide2 2.0.0~alpha0\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide2 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(241, 367)\n        self.gridLayout = QtWidgets.QGridLayout(Form)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.label = QtWidgets.QLabel(Form)\n        self.label.setObjectName(""label"")\n        self.gridLayout.addWidget(self.label, 0, 0, 1, 3)\n        self.itemTree = QtWidgets.QTreeWidget(Form)\n        self.itemTree.setObjectName(""itemTree"")\n        self.itemTree.headerItem().setText(0, ""1"")\n        self.itemTree.header().setVisible(False)\n        self.gridLayout.addWidget(self.itemTree, 1, 0, 1, 3)\n        self.label_2 = QtWidgets.QLabel(Form)\n        self.label_2.setObjectName(""label_2"")\n        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 3)\n        self.formatList = QtWidgets.QListWidget(Form)\n        self.formatList.setObjectName(""formatList"")\n        self.gridLayout.addWidget(self.formatList, 3, 0, 1, 3)\n        self.exportBtn = QtWidgets.QPushButton(Form)\n        self.exportBtn.setObjectName(""exportBtn"")\n        self.gridLayout.addWidget(self.exportBtn, 6, 1, 1, 1)\n        self.closeBtn = QtWidgets.QPushButton(Form)\n        self.closeBtn.setObjectName(""closeBtn"")\n        self.gridLayout.addWidget(self.closeBtn, 6, 2, 1, 1)\n        self.paramTree = ParameterTree(Form)\n        self.paramTree.setObjectName(""paramTree"")\n        self.paramTree.headerItem().setText(0, ""1"")\n        self.paramTree.header().setVisible(False)\n        self.gridLayout.addWidget(self.paramTree, 5, 0, 1, 3)\n        self.label_3 = QtWidgets.QLabel(Form)\n        self.label_3.setObjectName(""label_3"")\n        self.gridLayout.addWidget(self.label_3, 4, 0, 1, 3)\n        self.copyBtn = QtWidgets.QPushButton(Form)\n        self.copyBtn.setObjectName(""copyBtn"")\n        self.gridLayout.addWidget(self.copyBtn, 6, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtWidgets.QApplication.translate(""Form"", ""Export"", None, -1))\n        self.label.setText(QtWidgets.QApplication.translate(""Form"", ""Item to export:"", None, -1))\n        self.label_2.setText(QtWidgets.QApplication.translate(""Form"", ""Export format"", None, -1))\n        self.exportBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Export"", None, -1))\n        self.closeBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Close"", None, -1))\n        self.label_3.setText(QtWidgets.QApplication.translate(""Form"", ""Export options"", None, -1))\n        self.copyBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Copy"", None, -1))\n\nfrom ..parametertree import ParameterTree\n'"
src/third_party/pyqtgraph/GraphicsScene/mouseEvents.py,0,"b'from ..Point import Point\nfrom ..Qt import QtCore, QtGui\nimport weakref\nfrom .. import ptime as ptime\n\nclass MouseDragEvent(object):\n    """"""\n    Instances of this class are delivered to items in a :class:`GraphicsScene <pyqtgraph.GraphicsScene>` via their mouseDragEvent() method when the item is being mouse-dragged. \n    \n    """"""\n    \n    \n    \n    def __init__(self, moveEvent, pressEvent, lastEvent, start=False, finish=False):\n        self.start = start\n        self.finish = finish\n        self.accepted = False\n        self.currentItem = None\n        self._buttonDownScenePos = {}\n        self._buttonDownScreenPos = {}\n        for btn in [QtCore.Qt.LeftButton, QtCore.Qt.MidButton, QtCore.Qt.RightButton]:\n            self._buttonDownScenePos[int(btn)] = moveEvent.buttonDownScenePos(btn)\n            self._buttonDownScreenPos[int(btn)] = moveEvent.buttonDownScreenPos(btn)\n        self._scenePos = moveEvent.scenePos()\n        self._screenPos = moveEvent.screenPos()\n        if lastEvent is None:\n            self._lastScenePos = pressEvent.scenePos()\n            self._lastScreenPos = pressEvent.screenPos()\n        else:\n            self._lastScenePos = lastEvent.scenePos()\n            self._lastScreenPos = lastEvent.screenPos()\n        self._buttons = moveEvent.buttons()\n        self._button = pressEvent.button()\n        self._modifiers = moveEvent.modifiers()\n        self.acceptedItem = None\n        \n    def accept(self):\n        """"""An item should call this method if it can handle the event. This will prevent the event being delivered to any other items.""""""\n        self.accepted = True\n        self.acceptedItem = self.currentItem\n        \n    def ignore(self):\n        """"""An item should call this method if it cannot handle the event. This will allow the event to be delivered to other items.""""""\n        self.accepted = False\n    \n    def isAccepted(self):\n        return self.accepted\n    \n    def scenePos(self):\n        """"""Return the current scene position of the mouse.""""""\n        return Point(self._scenePos)\n    \n    def screenPos(self):\n        """"""Return the current screen position (pixels relative to widget) of the mouse.""""""\n        return Point(self._screenPos)\n    \n    def buttonDownScenePos(self, btn=None):\n        """"""\n        Return the scene position of the mouse at the time *btn* was pressed.\n        If *btn* is omitted, then the button that initiated the drag is assumed.\n        """"""\n        if btn is None:\n            btn = self.button()\n        return Point(self._buttonDownScenePos[int(btn)])\n    \n    def buttonDownScreenPos(self, btn=None):\n        """"""\n        Return the screen position (pixels relative to widget) of the mouse at the time *btn* was pressed.\n        If *btn* is omitted, then the button that initiated the drag is assumed.\n        """"""\n        if btn is None:\n            btn = self.button()\n        return Point(self._buttonDownScreenPos[int(btn)])\n    \n    def lastScenePos(self):\n        """"""\n        Return the scene position of the mouse immediately prior to this event.\n        """"""\n        return Point(self._lastScenePos)\n    \n    def lastScreenPos(self):\n        """"""\n        Return the screen position of the mouse immediately prior to this event.\n        """"""\n        return Point(self._lastScreenPos)\n    \n    def buttons(self):\n        """"""\n        Return the buttons currently pressed on the mouse.\n        (see QGraphicsSceneMouseEvent::buttons in the Qt documentation)\n        """"""\n        return self._buttons\n        \n    def button(self):\n        """"""Return the button that initiated the drag (may be different from the buttons currently pressed)\n        (see QGraphicsSceneMouseEvent::button in the Qt documentation)\n        \n        """"""\n        return self._button\n        \n    def pos(self):\n        """"""\n        Return the current position of the mouse in the coordinate system of the item\n        that the event was delivered to.\n        """"""\n        return Point(self.currentItem.mapFromScene(self._scenePos))\n    \n    def lastPos(self):\n        """"""\n        Return the previous position of the mouse in the coordinate system of the item\n        that the event was delivered to.\n        """"""\n        return Point(self.currentItem.mapFromScene(self._lastScenePos))\n        \n    def buttonDownPos(self, btn=None):\n        """"""\n        Return the position of the mouse at the time the drag was initiated\n        in the coordinate system of the item that the event was delivered to.\n        """"""\n        if btn is None:\n            btn = self.button()\n        return Point(self.currentItem.mapFromScene(self._buttonDownScenePos[int(btn)]))\n    \n    def isStart(self):\n        """"""Returns True if this event is the first since a drag was initiated.""""""\n        return self.start\n        \n    def isFinish(self):\n        """"""Returns False if this is the last event in a drag. Note that this\n        event will have the same position as the previous one.""""""\n        return self.finish\n\n    def __repr__(self):\n        if self.currentItem is None:\n            lp = self._lastScenePos\n            p = self._scenePos\n        else:\n            lp = self.lastPos()\n            p = self.pos()\n        return ""<MouseDragEvent (%g,%g)->(%g,%g) buttons=%d start=%s finish=%s>"" % (lp.x(), lp.y(), p.x(), p.y(), int(self.buttons()), str(self.isStart()), str(self.isFinish()))\n        \n    def modifiers(self):\n        """"""Return any keyboard modifiers currently pressed.\n        (see QGraphicsSceneMouseEvent::modifiers in the Qt documentation)\n        \n        """"""\n        return self._modifiers\n\n\n\nclass MouseClickEvent(object):\n    """"""\n    Instances of this class are delivered to items in a :class:`GraphicsScene <pyqtgraph.GraphicsScene>` via their mouseClickEvent() method when the item is clicked. \n    \n    \n    """"""\n    \n    def __init__(self, pressEvent, double=False):\n        self.accepted = False\n        self.currentItem = None\n        self._double = double\n        self._scenePos = pressEvent.scenePos()\n        self._screenPos = pressEvent.screenPos()\n        self._button = pressEvent.button()\n        self._buttons = pressEvent.buttons()\n        self._modifiers = pressEvent.modifiers()\n        self._time = ptime.time()\n        self.acceptedItem = None\n        \n    def accept(self):\n        """"""An item should call this method if it can handle the event. This will prevent the event being delivered to any other items.""""""\n        self.accepted = True\n        self.acceptedItem = self.currentItem\n        \n    def ignore(self):\n        """"""An item should call this method if it cannot handle the event. This will allow the event to be delivered to other items.""""""\n        self.accepted = False\n    \n    def isAccepted(self):\n        return self.accepted\n    \n    def scenePos(self):\n        """"""Return the current scene position of the mouse.""""""\n        return Point(self._scenePos)\n    \n    def screenPos(self):\n        """"""Return the current screen position (pixels relative to widget) of the mouse.""""""\n        return Point(self._screenPos)\n    \n    def buttons(self):\n        """"""\n        Return the buttons currently pressed on the mouse.\n        (see QGraphicsSceneMouseEvent::buttons in the Qt documentation)\n        """"""\n        return self._buttons\n    \n    def button(self):\n        """"""Return the mouse button that generated the click event.\n        (see QGraphicsSceneMouseEvent::button in the Qt documentation)\n        """"""\n        return self._button\n    \n    def double(self):\n        """"""Return True if this is a double-click.""""""\n        return self._double\n\n    def pos(self):\n        """"""\n        Return the current position of the mouse in the coordinate system of the item\n        that the event was delivered to.\n        """"""\n        return Point(self.currentItem.mapFromScene(self._scenePos))\n    \n    def lastPos(self):\n        """"""\n        Return the previous position of the mouse in the coordinate system of the item\n        that the event was delivered to.\n        """"""\n        return Point(self.currentItem.mapFromScene(self._lastScenePos))\n        \n    def modifiers(self):\n        """"""Return any keyboard modifiers currently pressed.\n        (see QGraphicsSceneMouseEvent::modifiers in the Qt documentation)        \n        """"""\n        return self._modifiers\n\n    def __repr__(self):\n        try:\n            if self.currentItem is None:\n                p = self._scenePos\n            else:\n                p = self.pos()\n            return ""<MouseClickEvent (%g,%g) button=%d>"" % (p.x(), p.y(), int(self.button()))\n        except:\n            return ""<MouseClickEvent button=%d>"" % (int(self.button()))\n\n    def time(self):\n        return self._time\n\n\n\nclass HoverEvent(object):\n    """"""\n    Instances of this class are delivered to items in a :class:`GraphicsScene <pyqtgraph.GraphicsScene>` via their hoverEvent() method when the mouse is hovering over the item.\n    This event class both informs items that the mouse cursor is nearby and allows items to \n    communicate with one another about whether each item will accept *potential* mouse events. \n    \n    It is common for multiple overlapping items to receive hover events and respond by changing \n    their appearance. This can be misleading to the user since, in general, only one item will\n    respond to mouse events. To avoid this, items make calls to event.acceptClicks(button) \n    and/or acceptDrags(button).\n    \n    Each item may make multiple calls to acceptClicks/Drags, each time for a different button. \n    If the method returns True, then the item is guaranteed to be\n    the recipient of the claimed event IF the user presses the specified mouse button before\n    moving. If claimEvent returns False, then this item is guaranteed NOT to get the specified\n    event (because another has already claimed it) and the item should change its appearance \n    accordingly.\n    \n    event.isEnter() returns True if the mouse has just entered the item\'s shape;\n    event.isExit() returns True if the mouse has just left.\n    """"""\n    def __init__(self, moveEvent, acceptable):\n        self.enter = False\n        self.acceptable = acceptable\n        self.exit = False\n        self.__clickItems = weakref.WeakValueDictionary()\n        self.__dragItems = weakref.WeakValueDictionary()\n        self.currentItem = None\n        if moveEvent is not None:\n            self._scenePos = moveEvent.scenePos()\n            self._screenPos = moveEvent.screenPos()\n            self._lastScenePos = moveEvent.lastScenePos()\n            self._lastScreenPos = moveEvent.lastScreenPos()\n            self._buttons = moveEvent.buttons()\n            self._modifiers = moveEvent.modifiers()\n        else:\n            self.exit = True\n        \n    def isEnter(self):\n        """"""Returns True if the mouse has just entered the item\'s shape""""""\n        return self.enter\n        \n    def isExit(self):\n        """"""Returns True if the mouse has just exited the item\'s shape""""""\n        return self.exit\n        \n    def acceptClicks(self, button):\n        """"""Inform the scene that the item (that the event was delivered to)\n        would accept a mouse click event if the user were to click before\n        moving the mouse again.\n        \n        Returns True if the request is successful, otherwise returns False (indicating\n        that some other item would receive an incoming click).\n        """"""\n        if not self.acceptable:\n            return False\n        if button not in self.__clickItems:\n            self.__clickItems[button] = self.currentItem\n            return True\n        return False\n        \n    def acceptDrags(self, button):\n        """"""Inform the scene that the item (that the event was delivered to)\n        would accept a mouse drag event if the user were to drag before\n        the next hover event.\n        \n        Returns True if the request is successful, otherwise returns False (indicating\n        that some other item would receive an incoming drag event).\n        """"""\n        if not self.acceptable:\n            return False\n        if button not in self.__dragItems:\n            self.__dragItems[button] = self.currentItem\n            return True\n        return False\n        \n    def scenePos(self):\n        """"""Return the current scene position of the mouse.""""""\n        return Point(self._scenePos)\n    \n    def screenPos(self):\n        """"""Return the current screen position of the mouse.""""""\n        return Point(self._screenPos)\n    \n    def lastScenePos(self):\n        """"""Return the previous scene position of the mouse.""""""\n        return Point(self._lastScenePos)\n    \n    def lastScreenPos(self):\n        """"""Return the previous screen position of the mouse.""""""\n        return Point(self._lastScreenPos)\n    \n    def buttons(self):\n        """"""\n        Return the buttons currently pressed on the mouse.\n        (see QGraphicsSceneMouseEvent::buttons in the Qt documentation)\n        """"""\n        return self._buttons\n        \n    def pos(self):\n        """"""\n        Return the current position of the mouse in the coordinate system of the item\n        that the event was delivered to.\n        """"""\n        return Point(self.currentItem.mapFromScene(self._scenePos))\n    \n    def lastPos(self):\n        """"""\n        Return the previous position of the mouse in the coordinate system of the item\n        that the event was delivered to.\n        """"""\n        return Point(self.currentItem.mapFromScene(self._lastScenePos))\n\n    def __repr__(self):\n        if self.exit:\n            return ""<HoverEvent exit=True>""\n        \n        if self.currentItem is None:\n            lp = self._lastScenePos\n            p = self._scenePos\n        else:\n            lp = self.lastPos()\n            p = self.pos()\n        return ""<HoverEvent (%g,%g)->(%g,%g) buttons=%d enter=%s exit=%s>"" % (lp.x(), lp.y(), p.x(), p.y(), int(self.buttons()), str(self.isEnter()), str(self.isExit()))\n        \n    def modifiers(self):\n        """"""Return any keyboard modifiers currently pressed.\n        (see QGraphicsSceneMouseEvent::modifiers in the Qt documentation)        \n        """"""\n        return self._modifiers\n    \n    def clickItems(self):\n        return self.__clickItems\n        \n    def dragItems(self):\n        return self.__dragItems\n        \n    \n    '"
src/third_party/pyqtgraph/canvas/Canvas.py,0,"b'# -*- coding: utf-8 -*-\nif __name__ == \'__main__\':\n    import sys, os\n    md = os.path.dirname(os.path.abspath(__file__))\n    sys.path = [os.path.dirname(md), os.path.join(md, \'..\', \'..\', \'..\')] + sys.path\n\nfrom ..Qt import QtGui, QtCore, QT_LIB\nfrom ..graphicsItems.ROI import ROI\nfrom ..graphicsItems.ViewBox import ViewBox\nfrom ..graphicsItems.GridItem import GridItem\n\nif QT_LIB == \'PySide\':\n    from .CanvasTemplate_pyside import *\nelif QT_LIB == \'PyQt4\':\n    from .CanvasTemplate_pyqt import *\nelif QT_LIB == \'PySide2\':\n    from .CanvasTemplate_pyside2 import *\nelif QT_LIB == \'PyQt5\':\n    from .CanvasTemplate_pyqt5 import *\n    \nimport numpy as np\nfrom .. import debug\nimport weakref\nimport gc\nfrom .CanvasManager import CanvasManager\nfrom .CanvasItem import CanvasItem, GroupCanvasItem\n\n\nclass Canvas(QtGui.QWidget):\n    \n    sigSelectionChanged = QtCore.Signal(object, object)\n    sigItemTransformChanged = QtCore.Signal(object, object)\n    sigItemTransformChangeFinished = QtCore.Signal(object, object)\n    \n    def __init__(self, parent=None, allowTransforms=True, hideCtrl=False, name=None):\n        QtGui.QWidget.__init__(self, parent)\n        self.ui = Ui_Form()\n        self.ui.setupUi(self)\n        self.view = ViewBox()\n        self.ui.view.setCentralItem(self.view)\n        self.itemList = self.ui.itemList\n        self.itemList.setSelectionMode(self.itemList.ExtendedSelection)\n        self.allowTransforms = allowTransforms\n        self.multiSelectBox = SelectBox()\n        self.view.addItem(self.multiSelectBox)\n        self.multiSelectBox.hide()\n        self.multiSelectBox.setZValue(1e6)\n        self.ui.mirrorSelectionBtn.hide()\n        self.ui.reflectSelectionBtn.hide()\n        self.ui.resetTransformsBtn.hide()\n        \n        self.redirect = None  ## which canvas to redirect items to\n        self.items = []\n        \n        self.view.setAspectLocked(True)\n        \n        grid = GridItem()\n        self.grid = CanvasItem(grid, name=\'Grid\', movable=False)\n        self.addItem(self.grid)\n        \n        self.hideBtn = QtGui.QPushButton(\'>\', self)\n        self.hideBtn.setFixedWidth(20)\n        self.hideBtn.setFixedHeight(20)\n        self.ctrlSize = 200\n        self.sizeApplied = False\n        self.hideBtn.clicked.connect(self.hideBtnClicked)\n        self.ui.splitter.splitterMoved.connect(self.splitterMoved)\n        \n        self.ui.itemList.itemChanged.connect(self.treeItemChanged)\n        self.ui.itemList.sigItemMoved.connect(self.treeItemMoved)\n        self.ui.itemList.itemSelectionChanged.connect(self.treeItemSelected)\n        self.ui.autoRangeBtn.clicked.connect(self.autoRange)\n        self.ui.redirectCheck.toggled.connect(self.updateRedirect)\n        self.ui.redirectCombo.currentIndexChanged.connect(self.updateRedirect)\n        self.multiSelectBox.sigRegionChanged.connect(self.multiSelectBoxChanged)\n        self.multiSelectBox.sigRegionChangeFinished.connect(self.multiSelectBoxChangeFinished)\n        self.ui.mirrorSelectionBtn.clicked.connect(self.mirrorSelectionClicked)\n        self.ui.reflectSelectionBtn.clicked.connect(self.reflectSelectionClicked)\n        self.ui.resetTransformsBtn.clicked.connect(self.resetTransformsClicked)\n        \n        self.resizeEvent()\n        if hideCtrl:\n            self.hideBtnClicked()\n            \n        if name is not None:\n            self.registeredName = CanvasManager.instance().registerCanvas(self, name)\n            self.ui.redirectCombo.setHostName(self.registeredName)\n            \n        self.menu = QtGui.QMenu()\n        remAct = QtGui.QAction(""Remove item"", self.menu)\n        remAct.triggered.connect(self.removeClicked)\n        self.menu.addAction(remAct)\n        self.menu.remAct = remAct\n        self.ui.itemList.contextMenuEvent = self.itemListContextMenuEvent\n\n    def splitterMoved(self):\n        self.resizeEvent()\n\n    def hideBtnClicked(self):\n        ctrlSize = self.ui.splitter.sizes()[1]\n        if ctrlSize == 0:\n            cs = self.ctrlSize\n            w = self.ui.splitter.size().width()\n            if cs > w:\n                cs = w - 20\n            self.ui.splitter.setSizes([w-cs, cs])\n            self.hideBtn.setText(\'>\')\n        else:\n            self.ctrlSize = ctrlSize\n            self.ui.splitter.setSizes([100, 0])\n            self.hideBtn.setText(\'<\')\n        self.resizeEvent()\n\n    def autoRange(self):\n        self.view.autoRange()\n\n    def resizeEvent(self, ev=None):\n        if ev is not None:\n            QtGui.QWidget.resizeEvent(self, ev)\n        self.hideBtn.move(self.ui.view.size().width() - self.hideBtn.width(), 0)\n        \n        if not self.sizeApplied:\n            self.sizeApplied = True\n            s = min(self.width(), max(100, min(200, self.width()*0.25)))\n            s2 = self.width()-s\n            self.ui.splitter.setSizes([s2, s])\n    \n    def updateRedirect(self, *args):\n        ### Decide whether/where to redirect items and make it so\n        cname = str(self.ui.redirectCombo.currentText())\n        man = CanvasManager.instance()\n        if self.ui.redirectCheck.isChecked() and cname != \'\':\n            redirect = man.getCanvas(cname)\n        else:\n            redirect = None\n            \n        if self.redirect is redirect:\n            return\n            \n        self.redirect = redirect\n        if redirect is None:\n            self.reclaimItems()\n        else:\n            self.redirectItems(redirect)\n    \n    def redirectItems(self, canvas):\n        for i in self.items:\n            if i is self.grid:\n                continue\n            li = i.listItem\n            parent = li.parent()\n            if parent is None:\n                tree = li.treeWidget()\n                if tree is None:\n                    print(""Skipping item"", i, i.name)\n                    continue\n                tree.removeTopLevelItem(li)\n            else:\n                parent.removeChild(li)\n            canvas.addItem(i)\n\n    def reclaimItems(self):\n        items = self.items\n        self.items = [self.grid]\n        items.remove(self.grid)\n        \n        for i in items:\n            i.canvas.removeItem(i)\n            self.addItem(i)\n\n    def treeItemChanged(self, item, col):\n        try:\n            citem = item.canvasItem()\n        except AttributeError:\n            return\n        if item.checkState(0) == QtCore.Qt.Checked:\n            for i in range(item.childCount()):\n                item.child(i).setCheckState(0, QtCore.Qt.Checked)\n            citem.show()\n        else:\n            for i in range(item.childCount()):\n                item.child(i).setCheckState(0, QtCore.Qt.Unchecked)\n            citem.hide()\n\n    def treeItemSelected(self):\n        sel = self.selectedItems()\n\n        if len(sel) == 0:\n            return\n            \n        multi = len(sel) > 1\n        for i in self.items:\n            ## updated the selected state of every item\n            i.selectionChanged(i in sel, multi)\n            \n        if len(sel)==1:\n            self.multiSelectBox.hide()\n            self.ui.mirrorSelectionBtn.hide()\n            self.ui.reflectSelectionBtn.hide()\n            self.ui.resetTransformsBtn.hide()\n        elif len(sel) > 1:\n            self.showMultiSelectBox()\n        \n        self.sigSelectionChanged.emit(self, sel)\n        \n    def selectedItems(self):\n        """"""\n        Return list of all selected canvasItems\n        """"""\n        return [item.canvasItem() for item in self.itemList.selectedItems() if item.canvasItem() is not None]\n        \n    def selectItem(self, item):\n        li = item.listItem\n        self.itemList.setCurrentItem(li)\n        \n    def showMultiSelectBox(self):\n        ## Get list of selected canvas items\n        items = self.selectedItems()\n        \n        rect = self.view.itemBoundingRect(items[0].graphicsItem())\n        for i in items:\n            if not i.isMovable():  ## all items in selection must be movable\n                return\n            br = self.view.itemBoundingRect(i.graphicsItem())\n            rect = rect|br\n            \n        self.multiSelectBox.blockSignals(True)\n        self.multiSelectBox.setPos([rect.x(), rect.y()])\n        self.multiSelectBox.setSize(rect.size())\n        self.multiSelectBox.setAngle(0)\n        self.multiSelectBox.blockSignals(False)\n        \n        self.multiSelectBox.show()\n        \n        self.ui.mirrorSelectionBtn.show()\n        self.ui.reflectSelectionBtn.show()\n        self.ui.resetTransformsBtn.show()\n\n    def mirrorSelectionClicked(self):\n        for ci in self.selectedItems():\n            ci.mirrorY()\n        self.showMultiSelectBox()\n\n    def reflectSelectionClicked(self):\n        for ci in self.selectedItems():\n            ci.mirrorXY()\n        self.showMultiSelectBox()\n            \n    def resetTransformsClicked(self):\n        for i in self.selectedItems():\n            i.resetTransformClicked()\n        self.showMultiSelectBox()\n\n    def multiSelectBoxChanged(self):\n        self.multiSelectBoxMoved()\n        \n    def multiSelectBoxChangeFinished(self):\n        for ci in self.selectedItems():\n            ci.applyTemporaryTransform()\n            ci.sigTransformChangeFinished.emit(ci)\n        \n    def multiSelectBoxMoved(self):\n        transform = self.multiSelectBox.getGlobalTransform()\n        for ci in self.selectedItems():\n            ci.setTemporaryTransform(transform)\n            ci.sigTransformChanged.emit(ci)\n        \n    def addGraphicsItem(self, item, **opts):\n        """"""Add a new GraphicsItem to the scene at pos.\n        Common options are name, pos, scale, and z\n        """"""\n        citem = CanvasItem(item, **opts)\n        item._canvasItem = citem\n        self.addItem(citem)\n        return citem\n\n    def addGroup(self, name, **kargs):\n        group = GroupCanvasItem(name=name)\n        self.addItem(group, **kargs)\n        return group\n\n    def addItem(self, citem):\n        """"""\n        Add an item to the canvas. \n        """"""\n        \n        ## Check for redirections\n        if self.redirect is not None:\n            name = self.redirect.addItem(citem)\n            self.items.append(citem)\n            return name\n\n        if not self.allowTransforms:\n            citem.setMovable(False)\n\n        citem.sigTransformChanged.connect(self.itemTransformChanged)\n        citem.sigTransformChangeFinished.connect(self.itemTransformChangeFinished)\n        citem.sigVisibilityChanged.connect(self.itemVisibilityChanged)\n\n        \n        ## Determine name to use in the item list\n        name = citem.opts[\'name\']\n        if name is None:\n            name = \'item\'\n        newname = name\n\n        ## If name already exists, append a number to the end\n        ## NAH. Let items have the same name if they really want.\n        #c=0\n        #while newname in self.items:\n            #c += 1\n            #newname = name + \'_%03d\' %c\n        #name = newname\n            \n        ## find parent and add item to tree\n        insertLocation = 0\n        #print ""Inserting node:"", name\n        \n            \n        ## determine parent list item where this item should be inserted\n        parent = citem.parentItem()\n        if parent in (None, self.view.childGroup):\n            parent = self.itemList.invisibleRootItem()\n        else:\n            parent = parent.listItem\n        \n        ## set Z value above all other siblings if none was specified\n        siblings = [parent.child(i).canvasItem() for i in range(parent.childCount())]\n        z = citem.zValue()\n        if z is None:\n            zvals = [i.zValue() for i in siblings]\n            if parent is self.itemList.invisibleRootItem():\n                if len(zvals) == 0:\n                    z = 0\n                else:\n                    z = max(zvals)+10\n            else:\n                if len(zvals) == 0:\n                    z = parent.canvasItem().zValue()\n                else:\n                    z = max(zvals)+1\n            citem.setZValue(z)\n            \n        ## determine location to insert item relative to its siblings\n        for i in range(parent.childCount()):\n            ch = parent.child(i)\n            zval = ch.canvasItem().graphicsItem().zValue()  ## should we use CanvasItem.zValue here?\n            if zval < z:\n                insertLocation = i\n                break\n            else:\n                insertLocation = i+1\n                \n        node = QtGui.QTreeWidgetItem([name])\n        flags = node.flags() | QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsDragEnabled\n        if not isinstance(citem, GroupCanvasItem):\n            flags = flags & ~QtCore.Qt.ItemIsDropEnabled\n        node.setFlags(flags)\n        if citem.opts[\'visible\']:\n            node.setCheckState(0, QtCore.Qt.Checked)\n        else:\n            node.setCheckState(0, QtCore.Qt.Unchecked)\n        \n        node.name = name\n        parent.insertChild(insertLocation, node)\n        \n        citem.name = name\n        citem.listItem = node\n        node.canvasItem = weakref.ref(citem)\n        self.items.append(citem)\n\n        ctrl = citem.ctrlWidget()\n        ctrl.hide()\n        self.ui.ctrlLayout.addWidget(ctrl)\n        \n        ## inform the canvasItem that its parent canvas has changed\n        citem.setCanvas(self)\n\n        ## Autoscale to fit the first item added (not including the grid).\n        if len(self.items) == 2:\n            self.autoRange()\n            \n        return citem\n\n    def treeItemMoved(self, item, parent, index):\n        ##Item moved in tree; update Z values\n        if parent is self.itemList.invisibleRootItem():\n            item.canvasItem().setParentItem(self.view.childGroup)\n        else:\n            item.canvasItem().setParentItem(parent.canvasItem())\n        siblings = [parent.child(i).canvasItem() for i in range(parent.childCount())]\n        \n        zvals = [i.zValue() for i in siblings]\n        zvals.sort(reverse=True)\n        \n        for i in range(len(siblings)):\n            item = siblings[i]\n            item.setZValue(zvals[i])\n        \n    def itemVisibilityChanged(self, item):\n        listItem = item.listItem\n        checked = listItem.checkState(0) == QtCore.Qt.Checked\n        vis = item.isVisible()\n        if vis != checked:\n            if vis:\n                listItem.setCheckState(0, QtCore.Qt.Checked)\n            else:\n                listItem.setCheckState(0, QtCore.Qt.Unchecked)\n\n    def removeItem(self, item):\n        if isinstance(item, QtGui.QTreeWidgetItem):\n            item = item.canvasItem()\n            \n        if isinstance(item, CanvasItem):\n            item.setCanvas(None)\n            listItem = item.listItem\n            listItem.canvasItem = None\n            item.listItem = None\n            self.itemList.removeTopLevelItem(listItem)\n            self.items.remove(item)\n            ctrl = item.ctrlWidget()\n            ctrl.hide()\n            self.ui.ctrlLayout.removeWidget(ctrl)\n            ctrl.setParent(None)\n        else:\n            if hasattr(item, \'_canvasItem\'):\n                self.removeItem(item._canvasItem)\n            else:\n                self.view.removeItem(item)\n                \n        gc.collect()\n        \n    def clear(self):\n        while len(self.items) > 0:\n            self.removeItem(self.items[0])\n\n    def addToScene(self, item):\n        self.view.addItem(item)\n        \n    def removeFromScene(self, item):\n        self.view.removeItem(item)\n    \n    def listItems(self):\n        """"""Return a dictionary of name:item pairs""""""\n        return self.items\n        \n    def getListItem(self, name):\n        return self.items[name]\n        \n    def itemTransformChanged(self, item):\n        self.sigItemTransformChanged.emit(self, item)\n    \n    def itemTransformChangeFinished(self, item):\n        self.sigItemTransformChangeFinished.emit(self, item)\n        \n    def itemListContextMenuEvent(self, ev):\n        self.menuItem = self.itemList.itemAt(ev.pos())\n        self.menu.popup(ev.globalPos())\n        \n    def removeClicked(self):\n        for item in self.selectedItems():\n            self.removeItem(item)\n        self.menuItem = None\n        import gc\n        gc.collect()\n\n\nclass SelectBox(ROI):\n    def __init__(self, scalable=False):\n        #QtGui.QGraphicsRectItem.__init__(self, 0, 0, size[0], size[1])\n        ROI.__init__(self, [0,0], [1,1])\n        center = [0.5, 0.5]\n            \n        if scalable:\n            self.addScaleHandle([1, 1], center, lockAspect=True)\n            self.addScaleHandle([0, 0], center, lockAspect=True)\n        self.addRotateHandle([0, 1], center)\n        self.addRotateHandle([1, 0], center)\n'"
src/third_party/pyqtgraph/canvas/CanvasItem.py,1,"b'# -*- coding: utf-8 -*-\nimport numpy as np\nfrom ..Qt import QtGui, QtCore, QtSvg, QT_LIB\nfrom ..graphicsItems.ROI import ROI\nfrom .. import SRTTransform, ItemGroup\nif QT_LIB == \'PySide\':\n    from . import TransformGuiTemplate_pyside as TransformGuiTemplate\nelif QT_LIB == \'PyQt4\':\n    from . import TransformGuiTemplate_pyqt as TransformGuiTemplate\nelif QT_LIB == \'PySide2\':\n    from . import TransformGuiTemplate_pyside2 as TransformGuiTemplate\nelif QT_LIB == \'PyQt5\':\n    from . import TransformGuiTemplate_pyqt5 as TransformGuiTemplate\n\nfrom .. import debug\n\nclass SelectBox(ROI):\n    def __init__(self, scalable=False, rotatable=True):\n        #QtGui.QGraphicsRectItem.__init__(self, 0, 0, size[0], size[1])\n        ROI.__init__(self, [0,0], [1,1], invertible=True)\n        center = [0.5, 0.5]\n            \n        if scalable:\n            self.addScaleHandle([1, 1], center, lockAspect=True)\n            self.addScaleHandle([0, 0], center, lockAspect=True)\n        if rotatable:\n            self.addRotateHandle([0, 1], center)\n            self.addRotateHandle([1, 0], center)\n\nclass CanvasItem(QtCore.QObject):\n    \n    sigResetUserTransform = QtCore.Signal(object)\n    sigTransformChangeFinished = QtCore.Signal(object)\n    sigTransformChanged = QtCore.Signal(object)\n    \n    """"""CanvasItem takes care of managing an item\'s state--alpha, visibility, z-value, transformations, etc. and\n    provides a control widget""""""\n    \n    sigVisibilityChanged = QtCore.Signal(object)\n    transformCopyBuffer = None\n    \n    def __init__(self, item, **opts):\n        defOpts = {\'name\': None, \'z\': None, \'movable\': True, \'scalable\': False, \'rotatable\': True, \'visible\': True, \'parent\':None} #\'pos\': [0,0], \'scale\': [1,1], \'angle\':0,\n        defOpts.update(opts)\n        self.opts = defOpts\n        self.selectedAlone = False  ## whether this item is the only one selected\n        \n        QtCore.QObject.__init__(self)\n        self.canvas = None\n        self._graphicsItem = item\n        \n        parent = self.opts[\'parent\']\n        if parent is not None:\n            self._graphicsItem.setParentItem(parent.graphicsItem())\n            self._parentItem = parent\n        else:\n            self._parentItem = None\n        \n        z = self.opts[\'z\']\n        if z is not None:\n            item.setZValue(z)\n\n        self.ctrl = QtGui.QWidget()\n        self.layout = QtGui.QGridLayout()\n        self.layout.setSpacing(0)\n        self.layout.setContentsMargins(0,0,0,0)\n        self.ctrl.setLayout(self.layout)\n        \n        self.alphaLabel = QtGui.QLabel(""Alpha"")\n        self.alphaSlider = QtGui.QSlider()\n        self.alphaSlider.setMaximum(1023)\n        self.alphaSlider.setOrientation(QtCore.Qt.Horizontal)\n        self.alphaSlider.setValue(1023)\n        self.layout.addWidget(self.alphaLabel, 0, 0)\n        self.layout.addWidget(self.alphaSlider, 0, 1)\n        self.resetTransformBtn = QtGui.QPushButton(\'Reset Transform\')\n        self.copyBtn = QtGui.QPushButton(\'Copy\')\n        self.pasteBtn = QtGui.QPushButton(\'Paste\')\n        \n        self.transformWidget = QtGui.QWidget()\n        self.transformGui = TransformGuiTemplate.Ui_Form()\n        self.transformGui.setupUi(self.transformWidget)\n        self.layout.addWidget(self.transformWidget, 3, 0, 1, 2)\n        self.transformGui.mirrorImageBtn.clicked.connect(self.mirrorY)\n        self.transformGui.reflectImageBtn.clicked.connect(self.mirrorXY)\n        \n        self.layout.addWidget(self.resetTransformBtn, 1, 0, 1, 2)\n        self.layout.addWidget(self.copyBtn, 2, 0, 1, 1)\n        self.layout.addWidget(self.pasteBtn, 2, 1, 1, 1)\n        self.alphaSlider.valueChanged.connect(self.alphaChanged)\n        self.alphaSlider.sliderPressed.connect(self.alphaPressed)\n        self.alphaSlider.sliderReleased.connect(self.alphaReleased)\n        self.resetTransformBtn.clicked.connect(self.resetTransformClicked)\n        self.copyBtn.clicked.connect(self.copyClicked)\n        self.pasteBtn.clicked.connect(self.pasteClicked)\n        \n        self.setMovable(self.opts[\'movable\'])  ## update gui to reflect this option\n\n        if \'transform\' in self.opts:\n            self.baseTransform = self.opts[\'transform\']\n        else:\n            self.baseTransform = SRTTransform()\n            if \'pos\' in self.opts and self.opts[\'pos\'] is not None:\n                self.baseTransform.translate(self.opts[\'pos\'])\n            if \'angle\' in self.opts and self.opts[\'angle\'] is not None:\n                self.baseTransform.rotate(self.opts[\'angle\'])\n            if \'scale\' in self.opts and self.opts[\'scale\'] is not None:\n                self.baseTransform.scale(self.opts[\'scale\'])\n\n        ## create selection box (only visible when selected)\n        tr = self.baseTransform.saveState()\n        if \'scalable\' not in opts and tr[\'scale\'] == (1,1):\n            self.opts[\'scalable\'] = True\n            \n        ## every CanvasItem implements its own individual selection box \n        ## so that subclasses are free to make their own.\n        self.selectBox = SelectBox(scalable=self.opts[\'scalable\'], rotatable=self.opts[\'rotatable\'])\n        self.selectBox.hide()\n        self.selectBox.setZValue(1e6)\n        self.selectBox.sigRegionChanged.connect(self.selectBoxChanged)  ## calls selectBoxMoved\n        self.selectBox.sigRegionChangeFinished.connect(self.selectBoxChangeFinished)\n\n        ## set up the transformations that will be applied to the item\n        ## (It is not safe to use item.setTransform, since the item might count on that not changing)\n        self.itemRotation = QtGui.QGraphicsRotation()\n        self.itemScale = QtGui.QGraphicsScale()\n        self._graphicsItem.setTransformations([self.itemRotation, self.itemScale])\n        \n        self.tempTransform = SRTTransform() ## holds the additional transform that happens during a move - gets added to the userTransform when move is done.\n        self.userTransform = SRTTransform() ## stores the total transform of the object\n        self.resetUserTransform() \n\n        \n    def setMovable(self, m):\n        self.opts[\'movable\'] = m\n        \n        if m:\n            self.resetTransformBtn.show()\n            self.copyBtn.show()\n            self.pasteBtn.show()\n        else:\n            self.resetTransformBtn.hide()\n            self.copyBtn.hide()\n            self.pasteBtn.hide()\n\n    def setCanvas(self, canvas):\n        ## Called by canvas whenever the item is added.\n        ## It is our responsibility to add all graphicsItems to the canvas\'s scene\n        ## The canvas will automatically add our graphicsitem, \n        ## so we just need to take care of the selectbox.\n        if canvas is self.canvas:\n            return\n            \n        if canvas is None:\n            self.canvas.removeFromScene(self._graphicsItem)\n            self.canvas.removeFromScene(self.selectBox)\n        else:\n            canvas.addToScene(self._graphicsItem)\n            canvas.addToScene(self.selectBox)\n        self.canvas = canvas\n\n    def graphicsItem(self):\n        """"""Return the graphicsItem for this canvasItem.""""""\n        return self._graphicsItem\n        \n    def parentItem(self):\n        return self._parentItem\n\n    def setParentItem(self, parent):\n        self._parentItem = parent\n        if parent is not None:\n            if isinstance(parent, CanvasItem):\n                parent = parent.graphicsItem()\n        self.graphicsItem().setParentItem(parent)\n\n    #def name(self):\n        #return self.opts[\'name\']\n    \n    def copyClicked(self):\n        CanvasItem.transformCopyBuffer = self.saveTransform()\n        \n    def pasteClicked(self):\n        t = CanvasItem.transformCopyBuffer\n        if t is None:\n            return\n        else:\n            self.restoreTransform(t)\n            \n    def mirrorY(self):\n        if not self.isMovable():\n            return\n        \n        #flip = self.transformGui.mirrorImageCheck.isChecked()\n        #tr = self.userTransform.saveState()\n        \n        inv = SRTTransform()\n        inv.scale(-1, 1)\n        self.userTransform = self.userTransform * inv\n        self.updateTransform()\n        self.selectBoxFromUser()\n        self.sigTransformChangeFinished.emit(self)\n        #if flip:\n            #if tr[\'scale\'][0] < 0 xor tr[\'scale\'][1] < 0:\n                #return\n            #else:\n                #self.userTransform.setScale([-tr[\'scale\'][0], tr[\'scale\'][1]])\n                #self.userTransform.setTranslate([-tr[\'pos\'][0], tr[\'pos\'][1]])\n                #self.userTransform.setRotate(-tr[\'angle\'])\n                #self.updateTransform()\n                #self.selectBoxFromUser()\n                #return\n        #elif not flip:\n            #if tr[\'scale\'][0] > 0 and tr[\'scale\'][1] > 0:\n                #return\n            #else:\n                #self.userTransform.setScale([-tr[\'scale\'][0], tr[\'scale\'][1]])\n                #self.userTransform.setTranslate([-tr[\'pos\'][0], tr[\'pos\'][1]])\n                #self.userTransform.setRotate(-tr[\'angle\'])\n                #self.updateTransform()\n                #self.selectBoxFromUser()\n                #return\n\n    def mirrorXY(self):\n        if not self.isMovable():\n            return\n        self.rotate(180.)\n        # inv = SRTTransform()\n        # inv.scale(-1, -1)\n        # self.userTransform = self.userTransform * inv #flip lr/ud\n        # s=self.updateTransform()\n        # self.setTranslate(-2*s[\'pos\'][0], -2*s[\'pos\'][1])\n        # self.selectBoxFromUser()\n \n    def hasUserTransform(self):\n        #print self.userRotate, self.userTranslate\n        return not self.userTransform.isIdentity()\n\n    def ctrlWidget(self):\n        return self.ctrl\n        \n    def alphaChanged(self, val):\n        alpha = val / 1023.\n        self._graphicsItem.setOpacity(alpha)\n        \n    def setAlpha(self, alpha):\n        self.alphaSlider.setValue(int(np.clip(alpha * 1023, 0, 1023)))\n        \n    def alpha(self):\n        return self.alphaSlider.value() / 1023.\n        \n    def isMovable(self):\n        return self.opts[\'movable\']\n        \n    def selectBoxMoved(self):\n        """"""The selection box has moved; get its transformation information and pass to the graphics item""""""\n        self.userTransform = self.selectBox.getGlobalTransform(relativeTo=self.selectBoxBase)\n        self.updateTransform()\n\n    def scale(self, x, y):\n        self.userTransform.scale(x, y)\n        self.selectBoxFromUser()\n        self.updateTransform()\n        \n    def rotate(self, ang):\n        self.userTransform.rotate(ang)\n        self.selectBoxFromUser()\n        self.updateTransform()\n        \n    def translate(self, x, y):\n        self.userTransform.translate(x, y)\n        self.selectBoxFromUser()\n        self.updateTransform()\n        \n    def setTranslate(self, x, y):\n        self.userTransform.setTranslate(x, y)\n        self.selectBoxFromUser()\n        self.updateTransform()\n        \n    def setRotate(self, angle):\n        self.userTransform.setRotate(angle)\n        self.selectBoxFromUser()\n        self.updateTransform()\n        \n    def setScale(self, x, y):\n        self.userTransform.setScale(x, y)\n        self.selectBoxFromUser()\n        self.updateTransform()\n\n    def setTemporaryTransform(self, transform):\n        self.tempTransform = transform\n        self.updateTransform()\n    \n    def applyTemporaryTransform(self):\n        """"""Collapses tempTransform into UserTransform, resets tempTransform""""""\n        self.userTransform = self.userTransform * self.tempTransform ## order is important!\n        self.resetTemporaryTransform()\n        self.selectBoxFromUser()  ## update the selection box to match the new userTransform\n\n    def resetTemporaryTransform(self):\n        self.tempTransform = SRTTransform()  ## don\'t use Transform.reset()--this transform might be used elsewhere.\n        self.updateTransform()\n        \n    def transform(self): \n        return self._graphicsItem.transform()\n\n    def updateTransform(self):\n        """"""Regenerate the item position from the base, user, and temp transforms""""""\n        transform = self.baseTransform * self.userTransform * self.tempTransform ## order is important\n        s = transform.saveState()\n        self._graphicsItem.setPos(*s[\'pos\'])\n        \n        self.itemRotation.setAngle(s[\'angle\'])\n        self.itemScale.setXScale(s[\'scale\'][0])\n        self.itemScale.setYScale(s[\'scale\'][1])\n\n        self.displayTransform(transform)\n        return(s) # return the transform state\n        \n    def displayTransform(self, transform):\n        """"""Updates transform numbers in the ctrl widget.""""""\n        tr = transform.saveState()\n        \n        self.transformGui.translateLabel.setText(""Translate: (%f, %f)"" %(tr[\'pos\'][0], tr[\'pos\'][1]))\n        self.transformGui.rotateLabel.setText(""Rotate: %f degrees"" %tr[\'angle\'])\n        self.transformGui.scaleLabel.setText(""Scale: (%f, %f)"" %(tr[\'scale\'][0], tr[\'scale\'][1]))\n\n    def resetUserTransform(self):\n        self.userTransform.reset()\n        self.updateTransform()\n        \n        self.selectBox.blockSignals(True)\n        self.selectBoxToItem()\n        self.selectBox.blockSignals(False)\n        self.sigTransformChanged.emit(self)\n        self.sigTransformChangeFinished.emit(self)\n       \n    def resetTransformClicked(self):\n        self.resetUserTransform()\n        self.sigResetUserTransform.emit(self)\n        \n    def restoreTransform(self, tr):\n        try:\n            self.userTransform = SRTTransform(tr)\n            self.updateTransform()\n            \n            self.selectBoxFromUser() ## move select box to match\n            self.sigTransformChanged.emit(self)\n            self.sigTransformChangeFinished.emit(self)\n        except:\n            self.userTransform = SRTTransform()\n            debug.printExc(""Failed to load transform:"")\n        \n    def saveTransform(self):\n        """"""Return a dict containing the current user transform""""""\n        return self.userTransform.saveState()\n        \n    def selectBoxFromUser(self):\n        """"""Move the selection box to match the current userTransform""""""\n        ## user transform\n        #trans = QtGui.QTransform()\n        #trans.translate(*self.userTranslate)\n        #trans.rotate(-self.userRotate)\n        \n        #x2, y2 = trans.map(*self.selectBoxBase[\'pos\'])\n        \n        self.selectBox.blockSignals(True)\n        self.selectBox.setState(self.selectBoxBase)\n        self.selectBox.applyGlobalTransform(self.userTransform)\n        #self.selectBox.setAngle(self.userRotate)\n        #self.selectBox.setPos([x2, y2])\n        self.selectBox.blockSignals(False)\n\n    def selectBoxToItem(self):\n        """"""Move/scale the selection box so it fits the item\'s bounding rect. (assumes item is not rotated)""""""\n        self.itemRect = self._graphicsItem.boundingRect()\n        rect = self._graphicsItem.mapRectToParent(self.itemRect)\n        self.selectBox.blockSignals(True)\n        self.selectBox.setPos([rect.x(), rect.y()])\n        self.selectBox.setSize(rect.size())\n        self.selectBox.setAngle(0)\n        self.selectBoxBase = self.selectBox.getState().copy()\n        self.selectBox.blockSignals(False)\n\n    def zValue(self):\n        return self.opts[\'z\']\n        \n    def setZValue(self, z):\n        self.opts[\'z\'] = z\n        if z is not None:\n            self._graphicsItem.setZValue(z)\n           \n    def selectionChanged(self, sel, multi):\n        """"""\n        Inform the item that its selection state has changed. \n        ============== =========================================================\n        **Arguments:**\n        sel            (bool) whether the item is currently selected\n        multi          (bool) whether there are multiple items currently \n                       selected\n        ============== =========================================================\n        """"""\n        self.selectedAlone = sel and not multi\n        self.showSelectBox()\n        if self.selectedAlone:\n            self.ctrlWidget().show()\n        else:\n            self.ctrlWidget().hide()\n        \n    def showSelectBox(self):\n        """"""Display the selection box around this item if it is selected and movable""""""\n        if self.selectedAlone and self.isMovable() and self.isVisible():  #and len(self.canvas.itemList.selectedItems())==1:\n            self.selectBox.show()\n        else:\n            self.selectBox.hide()\n        \n    def hideSelectBox(self):\n        self.selectBox.hide()\n                \n    def selectBoxChanged(self):\n        self.selectBoxMoved()\n        self.sigTransformChanged.emit(self)\n        \n    def selectBoxChangeFinished(self):\n        self.sigTransformChangeFinished.emit(self)\n\n    def alphaPressed(self):\n        """"""Hide selection box while slider is moving""""""\n        self.hideSelectBox()\n        \n    def alphaReleased(self):\n        self.showSelectBox()\n        \n    def show(self):\n        if self.opts[\'visible\']:\n            return\n        self.opts[\'visible\'] = True\n        self._graphicsItem.show()\n        self.showSelectBox()\n        self.sigVisibilityChanged.emit(self)\n        \n    def hide(self):\n        if not self.opts[\'visible\']:\n            return\n        self.opts[\'visible\'] = False\n        self._graphicsItem.hide()\n        self.hideSelectBox()\n        self.sigVisibilityChanged.emit(self)\n\n    def setVisible(self, vis):\n        if vis:\n            self.show()\n        else:\n            self.hide()\n\n    def isVisible(self):\n        return self.opts[\'visible\']\n\n    def saveState(self):\n        return {\n            \'type\': self.__class__.__name__,\n            \'name\': self.name,\n            \'visible\': self.isVisible(),\n            \'alpha\': self.alpha(),\n            \'userTransform\': self.saveTransform(), \n            \'z\': self.zValue(),\n            \'scalable\': self.opts[\'scalable\'],\n            \'rotatable\': self.opts[\'rotatable\'],\n            \'movable\': self.opts[\'movable\'],\n        }\n    \n    def restoreState(self, state):\n        self.setVisible(state[\'visible\'])\n        self.setAlpha(state[\'alpha\'])\n        self.restoreTransform(state[\'userTransform\'])\n        self.setZValue(state[\'z\'])\n\n\nclass GroupCanvasItem(CanvasItem):\n    """"""\n    Canvas item used for grouping others\n    """"""\n    \n    def __init__(self, **opts):\n        defOpts = {\'movable\': False, \'scalable\': False}\n        defOpts.update(opts)\n        item = ItemGroup()\n        CanvasItem.__init__(self, item, **defOpts)\n    \n'"
src/third_party/pyqtgraph/canvas/CanvasManager.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtCore, QtGui\nif not hasattr(QtCore, \'Signal\'):\n    QtCore.Signal = QtCore.pyqtSignal\nimport weakref\n\nclass CanvasManager(QtCore.QObject):\n    SINGLETON = None\n    \n    sigCanvasListChanged = QtCore.Signal()\n    \n    def __init__(self):\n        if CanvasManager.SINGLETON is not None:\n            raise Exception(""Can only create one canvas manager."")\n        CanvasManager.SINGLETON = self\n        QtCore.QObject.__init__(self)\n        self.canvases = weakref.WeakValueDictionary()\n\n    @classmethod\n    def instance(cls):\n        return CanvasManager.SINGLETON\n        \n    def registerCanvas(self, canvas, name):\n        n2 = name\n        i = 0\n        while n2 in self.canvases:\n            n2 = ""%s_%03d"" % (name, i)\n            i += 1\n        self.canvases[n2] = canvas\n        self.sigCanvasListChanged.emit()\n        return n2\n        \n    def unregisterCanvas(self, name):\n        c = self.canvases[name]\n        del self.canvases[name]\n        self.sigCanvasListChanged.emit()\n        \n    def listCanvases(self):\n        return list(self.canvases.keys())\n        \n    def getCanvas(self, name):\n        return self.canvases[name]\n        \n    \nmanager = CanvasManager()\n\n\nclass CanvasCombo(QtGui.QComboBox):\n    def __init__(self, parent=None):\n        QtGui.QComboBox.__init__(self, parent)\n        man = CanvasManager.instance()\n        man.sigCanvasListChanged.connect(self.updateCanvasList)\n        self.hostName = None\n        self.updateCanvasList()\n        \n    def updateCanvasList(self):\n        canvases = CanvasManager.instance().listCanvases()\n        canvases.insert(0, """")\n        if self.hostName in canvases:\n            canvases.remove(self.hostName)\n            \n        sel = self.currentText()\n        if sel in canvases:\n            self.blockSignals(True)  ## change does not affect current selection; block signals during update\n        self.clear()\n        for i in canvases:\n            self.addItem(i)\n            if i == sel:\n                self.setCurrentIndex(self.count())\n            \n        self.blockSignals(False)\n        \n    def setHostName(self, name):\n        self.hostName = name\n        self.updateCanvasList()\n\n'"
src/third_party/pyqtgraph/canvas/CanvasTemplate_pyqt.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'CanvasTemplate.ui\'\n#\n# Created by: PyQt4 UI code generator 4.11.4\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt4 import QtCore, QtGui\n\ntry:\n    _fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n    def _fromUtf8(s):\n        return s\n\ntry:\n    _encoding = QtGui.QApplication.UnicodeUTF8\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig, _encoding)\nexcept AttributeError:\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig)\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(""Form""))\n        Form.resize(821, 578)\n        self.gridLayout_2 = QtGui.QGridLayout(Form)\n        self.gridLayout_2.setMargin(0)\n        self.gridLayout_2.setSpacing(0)\n        self.gridLayout_2.setObjectName(_fromUtf8(""gridLayout_2""))\n        self.splitter = QtGui.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Horizontal)\n        self.splitter.setObjectName(_fromUtf8(""splitter""))\n        self.view = GraphicsView(self.splitter)\n        self.view.setObjectName(_fromUtf8(""view""))\n        self.vsplitter = QtGui.QSplitter(self.splitter)\n        self.vsplitter.setOrientation(QtCore.Qt.Vertical)\n        self.vsplitter.setObjectName(_fromUtf8(""vsplitter""))\n        self.canvasCtrlWidget = QtGui.QWidget(self.vsplitter)\n        self.canvasCtrlWidget.setObjectName(_fromUtf8(""canvasCtrlWidget""))\n        self.gridLayout = QtGui.QGridLayout(self.canvasCtrlWidget)\n        self.gridLayout.setObjectName(_fromUtf8(""gridLayout""))\n        self.autoRangeBtn = QtGui.QPushButton(self.canvasCtrlWidget)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.autoRangeBtn.sizePolicy().hasHeightForWidth())\n        self.autoRangeBtn.setSizePolicy(sizePolicy)\n        self.autoRangeBtn.setObjectName(_fromUtf8(""autoRangeBtn""))\n        self.gridLayout.addWidget(self.autoRangeBtn, 0, 0, 1, 2)\n        self.horizontalLayout = QtGui.QHBoxLayout()\n        self.horizontalLayout.setSpacing(0)\n        self.horizontalLayout.setObjectName(_fromUtf8(""horizontalLayout""))\n        self.redirectCheck = QtGui.QCheckBox(self.canvasCtrlWidget)\n        self.redirectCheck.setObjectName(_fromUtf8(""redirectCheck""))\n        self.horizontalLayout.addWidget(self.redirectCheck)\n        self.redirectCombo = CanvasCombo(self.canvasCtrlWidget)\n        self.redirectCombo.setObjectName(_fromUtf8(""redirectCombo""))\n        self.horizontalLayout.addWidget(self.redirectCombo)\n        self.gridLayout.addLayout(self.horizontalLayout, 1, 0, 1, 2)\n        self.itemList = TreeWidget(self.canvasCtrlWidget)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(100)\n        sizePolicy.setHeightForWidth(self.itemList.sizePolicy().hasHeightForWidth())\n        self.itemList.setSizePolicy(sizePolicy)\n        self.itemList.setHeaderHidden(True)\n        self.itemList.setObjectName(_fromUtf8(""itemList""))\n        self.itemList.headerItem().setText(0, _fromUtf8(""1""))\n        self.gridLayout.addWidget(self.itemList, 2, 0, 1, 2)\n        self.resetTransformsBtn = QtGui.QPushButton(self.canvasCtrlWidget)\n        self.resetTransformsBtn.setObjectName(_fromUtf8(""resetTransformsBtn""))\n        self.gridLayout.addWidget(self.resetTransformsBtn, 3, 0, 1, 2)\n        self.mirrorSelectionBtn = QtGui.QPushButton(self.canvasCtrlWidget)\n        self.mirrorSelectionBtn.setObjectName(_fromUtf8(""mirrorSelectionBtn""))\n        self.gridLayout.addWidget(self.mirrorSelectionBtn, 4, 0, 1, 1)\n        self.reflectSelectionBtn = QtGui.QPushButton(self.canvasCtrlWidget)\n        self.reflectSelectionBtn.setObjectName(_fromUtf8(""reflectSelectionBtn""))\n        self.gridLayout.addWidget(self.reflectSelectionBtn, 4, 1, 1, 1)\n        self.canvasItemCtrl = QtGui.QWidget(self.vsplitter)\n        self.canvasItemCtrl.setObjectName(_fromUtf8(""canvasItemCtrl""))\n        self.ctrlLayout = QtGui.QGridLayout(self.canvasItemCtrl)\n        self.ctrlLayout.setMargin(0)\n        self.ctrlLayout.setSpacing(0)\n        self.ctrlLayout.setObjectName(_fromUtf8(""ctrlLayout""))\n        self.gridLayout_2.addWidget(self.splitter, 0, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(_translate(""Form"", ""Form"", None))\n        self.autoRangeBtn.setText(_translate(""Form"", ""Auto Range"", None))\n        self.redirectCheck.setToolTip(_translate(""Form"", ""Check to display all local items in a remote canvas."", None))\n        self.redirectCheck.setText(_translate(""Form"", ""Redirect"", None))\n        self.resetTransformsBtn.setText(_translate(""Form"", ""Reset Transforms"", None))\n        self.mirrorSelectionBtn.setText(_translate(""Form"", ""Mirror Selection"", None))\n        self.reflectSelectionBtn.setText(_translate(""Form"", ""MirrorXY"", None))\n\nfrom ..widgets.GraphicsView import GraphicsView\nfrom ..widgets.TreeWidget import TreeWidget\nfrom .CanvasManager import CanvasCombo\n'"
src/third_party/pyqtgraph/canvas/CanvasTemplate_pyqt5.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'CanvasTemplate.ui\'\n#\n# Created by: PyQt5 UI code generator 5.7.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(821, 578)\n        self.gridLayout_2 = QtWidgets.QGridLayout(Form)\n        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_2.setSpacing(0)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.splitter = QtWidgets.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Horizontal)\n        self.splitter.setObjectName(""splitter"")\n        self.view = GraphicsView(self.splitter)\n        self.view.setObjectName(""view"")\n        self.vsplitter = QtWidgets.QSplitter(self.splitter)\n        self.vsplitter.setOrientation(QtCore.Qt.Vertical)\n        self.vsplitter.setObjectName(""vsplitter"")\n        self.canvasCtrlWidget = QtWidgets.QWidget(self.vsplitter)\n        self.canvasCtrlWidget.setObjectName(""canvasCtrlWidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.canvasCtrlWidget)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.autoRangeBtn = QtWidgets.QPushButton(self.canvasCtrlWidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.autoRangeBtn.sizePolicy().hasHeightForWidth())\n        self.autoRangeBtn.setSizePolicy(sizePolicy)\n        self.autoRangeBtn.setObjectName(""autoRangeBtn"")\n        self.gridLayout.addWidget(self.autoRangeBtn, 0, 0, 1, 2)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setSpacing(0)\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.redirectCheck = QtWidgets.QCheckBox(self.canvasCtrlWidget)\n        self.redirectCheck.setObjectName(""redirectCheck"")\n        self.horizontalLayout.addWidget(self.redirectCheck)\n        self.redirectCombo = CanvasCombo(self.canvasCtrlWidget)\n        self.redirectCombo.setObjectName(""redirectCombo"")\n        self.horizontalLayout.addWidget(self.redirectCombo)\n        self.gridLayout.addLayout(self.horizontalLayout, 1, 0, 1, 2)\n        self.itemList = TreeWidget(self.canvasCtrlWidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(100)\n        sizePolicy.setHeightForWidth(self.itemList.sizePolicy().hasHeightForWidth())\n        self.itemList.setSizePolicy(sizePolicy)\n        self.itemList.setHeaderHidden(True)\n        self.itemList.setObjectName(""itemList"")\n        self.itemList.headerItem().setText(0, ""1"")\n        self.gridLayout.addWidget(self.itemList, 2, 0, 1, 2)\n        self.resetTransformsBtn = QtWidgets.QPushButton(self.canvasCtrlWidget)\n        self.resetTransformsBtn.setObjectName(""resetTransformsBtn"")\n        self.gridLayout.addWidget(self.resetTransformsBtn, 3, 0, 1, 2)\n        self.mirrorSelectionBtn = QtWidgets.QPushButton(self.canvasCtrlWidget)\n        self.mirrorSelectionBtn.setObjectName(""mirrorSelectionBtn"")\n        self.gridLayout.addWidget(self.mirrorSelectionBtn, 4, 0, 1, 1)\n        self.reflectSelectionBtn = QtWidgets.QPushButton(self.canvasCtrlWidget)\n        self.reflectSelectionBtn.setObjectName(""reflectSelectionBtn"")\n        self.gridLayout.addWidget(self.reflectSelectionBtn, 4, 1, 1, 1)\n        self.canvasItemCtrl = QtWidgets.QWidget(self.vsplitter)\n        self.canvasItemCtrl.setObjectName(""canvasItemCtrl"")\n        self.ctrlLayout = QtWidgets.QGridLayout(self.canvasItemCtrl)\n        self.ctrlLayout.setContentsMargins(0, 0, 0, 0)\n        self.ctrlLayout.setSpacing(0)\n        self.ctrlLayout.setObjectName(""ctrlLayout"")\n        self.gridLayout_2.addWidget(self.splitter, 0, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Form""))\n        self.autoRangeBtn.setText(_translate(""Form"", ""Auto Range""))\n        self.redirectCheck.setToolTip(_translate(""Form"", ""Check to display all local items in a remote canvas.""))\n        self.redirectCheck.setText(_translate(""Form"", ""Redirect""))\n        self.resetTransformsBtn.setText(_translate(""Form"", ""Reset Transforms""))\n        self.mirrorSelectionBtn.setText(_translate(""Form"", ""Mirror Selection""))\n        self.reflectSelectionBtn.setText(_translate(""Form"", ""MirrorXY""))\n\nfrom ..widgets.GraphicsView import GraphicsView\nfrom ..widgets.TreeWidget import TreeWidget\nfrom .CanvasManager import CanvasCombo\n'"
src/third_party/pyqtgraph/canvas/CanvasTemplate_pyside.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'CanvasTemplate.ui\'\n#\n# Created: Fri Mar 24 16:09:39 2017\n#      by: pyside-uic 0.2.15 running on PySide 1.2.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide import QtCore, QtGui\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(821, 578)\n        self.gridLayout_2 = QtGui.QGridLayout(Form)\n        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_2.setSpacing(0)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.splitter = QtGui.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Horizontal)\n        self.splitter.setObjectName(""splitter"")\n        self.view = GraphicsView(self.splitter)\n        self.view.setObjectName(""view"")\n        self.vsplitter = QtGui.QSplitter(self.splitter)\n        self.vsplitter.setOrientation(QtCore.Qt.Vertical)\n        self.vsplitter.setObjectName(""vsplitter"")\n        self.canvasCtrlWidget = QtGui.QWidget(self.vsplitter)\n        self.canvasCtrlWidget.setObjectName(""canvasCtrlWidget"")\n        self.gridLayout = QtGui.QGridLayout(self.canvasCtrlWidget)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.autoRangeBtn = QtGui.QPushButton(self.canvasCtrlWidget)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.autoRangeBtn.sizePolicy().hasHeightForWidth())\n        self.autoRangeBtn.setSizePolicy(sizePolicy)\n        self.autoRangeBtn.setObjectName(""autoRangeBtn"")\n        self.gridLayout.addWidget(self.autoRangeBtn, 0, 0, 1, 2)\n        self.horizontalLayout = QtGui.QHBoxLayout()\n        self.horizontalLayout.setSpacing(0)\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.redirectCheck = QtGui.QCheckBox(self.canvasCtrlWidget)\n        self.redirectCheck.setObjectName(""redirectCheck"")\n        self.horizontalLayout.addWidget(self.redirectCheck)\n        self.redirectCombo = CanvasCombo(self.canvasCtrlWidget)\n        self.redirectCombo.setObjectName(""redirectCombo"")\n        self.horizontalLayout.addWidget(self.redirectCombo)\n        self.gridLayout.addLayout(self.horizontalLayout, 1, 0, 1, 2)\n        self.itemList = TreeWidget(self.canvasCtrlWidget)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(100)\n        sizePolicy.setHeightForWidth(self.itemList.sizePolicy().hasHeightForWidth())\n        self.itemList.setSizePolicy(sizePolicy)\n        self.itemList.setHeaderHidden(True)\n        self.itemList.setObjectName(""itemList"")\n        self.itemList.headerItem().setText(0, ""1"")\n        self.gridLayout.addWidget(self.itemList, 2, 0, 1, 2)\n        self.resetTransformsBtn = QtGui.QPushButton(self.canvasCtrlWidget)\n        self.resetTransformsBtn.setObjectName(""resetTransformsBtn"")\n        self.gridLayout.addWidget(self.resetTransformsBtn, 3, 0, 1, 2)\n        self.mirrorSelectionBtn = QtGui.QPushButton(self.canvasCtrlWidget)\n        self.mirrorSelectionBtn.setObjectName(""mirrorSelectionBtn"")\n        self.gridLayout.addWidget(self.mirrorSelectionBtn, 4, 0, 1, 1)\n        self.reflectSelectionBtn = QtGui.QPushButton(self.canvasCtrlWidget)\n        self.reflectSelectionBtn.setObjectName(""reflectSelectionBtn"")\n        self.gridLayout.addWidget(self.reflectSelectionBtn, 4, 1, 1, 1)\n        self.canvasItemCtrl = QtGui.QWidget(self.vsplitter)\n        self.canvasItemCtrl.setObjectName(""canvasItemCtrl"")\n        self.ctrlLayout = QtGui.QGridLayout(self.canvasItemCtrl)\n        self.ctrlLayout.setContentsMargins(0, 0, 0, 0)\n        self.ctrlLayout.setSpacing(0)\n        self.ctrlLayout.setContentsMargins(0, 0, 0, 0)\n        self.ctrlLayout.setObjectName(""ctrlLayout"")\n        self.gridLayout_2.addWidget(self.splitter, 0, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtGui.QApplication.translate(""Form"", ""Form"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoRangeBtn.setText(QtGui.QApplication.translate(""Form"", ""Auto Range"", None, QtGui.QApplication.UnicodeUTF8))\n        self.redirectCheck.setToolTip(QtGui.QApplication.translate(""Form"", ""Check to display all local items in a remote canvas."", None, QtGui.QApplication.UnicodeUTF8))\n        self.redirectCheck.setText(QtGui.QApplication.translate(""Form"", ""Redirect"", None, QtGui.QApplication.UnicodeUTF8))\n        self.resetTransformsBtn.setText(QtGui.QApplication.translate(""Form"", ""Reset Transforms"", None, QtGui.QApplication.UnicodeUTF8))\n        self.mirrorSelectionBtn.setText(QtGui.QApplication.translate(""Form"", ""Mirror Selection"", None, QtGui.QApplication.UnicodeUTF8))\n        self.reflectSelectionBtn.setText(QtGui.QApplication.translate(""Form"", ""MirrorXY"", None, QtGui.QApplication.UnicodeUTF8))\n\nfrom .CanvasManager import CanvasCombo\nfrom ..widgets.TreeWidget import TreeWidget\nfrom ..widgets.GraphicsView import GraphicsView\n'"
src/third_party/pyqtgraph/canvas/CanvasTemplate_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'CanvasTemplate.ui\'\n#\n# Created: Sun Sep 18 19:18:22 2016\n#      by: pyside2-uic  running on PySide2 2.0.0~alpha0\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide2 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(490, 414)\n        self.gridLayout = QtWidgets.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.splitter = QtWidgets.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Horizontal)\n        self.splitter.setObjectName(""splitter"")\n        self.view = GraphicsView(self.splitter)\n        self.view.setObjectName(""view"")\n        self.layoutWidget = QtWidgets.QWidget(self.splitter)\n        self.layoutWidget.setObjectName(""layoutWidget"")\n        self.gridLayout_2 = QtWidgets.QGridLayout(self.layoutWidget)\n        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.autoRangeBtn = QtWidgets.QPushButton(self.layoutWidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.autoRangeBtn.sizePolicy().hasHeightForWidth())\n        self.autoRangeBtn.setSizePolicy(sizePolicy)\n        self.autoRangeBtn.setObjectName(""autoRangeBtn"")\n        self.gridLayout_2.addWidget(self.autoRangeBtn, 2, 0, 1, 2)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setSpacing(0)\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.redirectCheck = QtWidgets.QCheckBox(self.layoutWidget)\n        self.redirectCheck.setObjectName(""redirectCheck"")\n        self.horizontalLayout.addWidget(self.redirectCheck)\n        self.redirectCombo = CanvasCombo(self.layoutWidget)\n        self.redirectCombo.setObjectName(""redirectCombo"")\n        self.horizontalLayout.addWidget(self.redirectCombo)\n        self.gridLayout_2.addLayout(self.horizontalLayout, 5, 0, 1, 2)\n        self.itemList = TreeWidget(self.layoutWidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(100)\n        sizePolicy.setHeightForWidth(self.itemList.sizePolicy().hasHeightForWidth())\n        self.itemList.setSizePolicy(sizePolicy)\n        self.itemList.setHeaderHidden(True)\n        self.itemList.setObjectName(""itemList"")\n        self.itemList.headerItem().setText(0, ""1"")\n        self.gridLayout_2.addWidget(self.itemList, 6, 0, 1, 2)\n        self.ctrlLayout = QtWidgets.QGridLayout()\n        self.ctrlLayout.setSpacing(0)\n        self.ctrlLayout.setObjectName(""ctrlLayout"")\n        self.gridLayout_2.addLayout(self.ctrlLayout, 10, 0, 1, 2)\n        self.resetTransformsBtn = QtWidgets.QPushButton(self.layoutWidget)\n        self.resetTransformsBtn.setObjectName(""resetTransformsBtn"")\n        self.gridLayout_2.addWidget(self.resetTransformsBtn, 7, 0, 1, 1)\n        self.mirrorSelectionBtn = QtWidgets.QPushButton(self.layoutWidget)\n        self.mirrorSelectionBtn.setObjectName(""mirrorSelectionBtn"")\n        self.gridLayout_2.addWidget(self.mirrorSelectionBtn, 3, 0, 1, 1)\n        self.reflectSelectionBtn = QtWidgets.QPushButton(self.layoutWidget)\n        self.reflectSelectionBtn.setObjectName(""reflectSelectionBtn"")\n        self.gridLayout_2.addWidget(self.reflectSelectionBtn, 3, 1, 1, 1)\n        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtWidgets.QApplication.translate(""Form"", ""Form"", None, -1))\n        self.autoRangeBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Auto Range"", None, -1))\n        self.redirectCheck.setToolTip(QtWidgets.QApplication.translate(""Form"", ""Check to display all local items in a remote canvas."", None, -1))\n        self.redirectCheck.setText(QtWidgets.QApplication.translate(""Form"", ""Redirect"", None, -1))\n        self.resetTransformsBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Reset Transforms"", None, -1))\n        self.mirrorSelectionBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Mirror Selection"", None, -1))\n        self.reflectSelectionBtn.setText(QtWidgets.QApplication.translate(""Form"", ""MirrorXY"", None, -1))\n\nfrom ..widgets.TreeWidget import TreeWidget\nfrom CanvasManager import CanvasCombo\nfrom ..widgets.GraphicsView import GraphicsView\n'"
src/third_party/pyqtgraph/canvas/TransformGuiTemplate_pyqt.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'pyqtgraph/canvas/TransformGuiTemplate.ui\'\n#\n# Created by: PyQt4 UI code generator 4.11.4\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt4 import QtCore, QtGui\n\ntry:\n    _fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n    def _fromUtf8(s):\n        return s\n\ntry:\n    _encoding = QtGui.QApplication.UnicodeUTF8\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig, _encoding)\nexcept AttributeError:\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig)\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(""Form""))\n        Form.resize(224, 117)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(Form.sizePolicy().hasHeightForWidth())\n        Form.setSizePolicy(sizePolicy)\n        self.verticalLayout = QtGui.QVBoxLayout(Form)\n        self.verticalLayout.setMargin(0)\n        self.verticalLayout.setSpacing(1)\n        self.verticalLayout.setObjectName(_fromUtf8(""verticalLayout""))\n        self.translateLabel = QtGui.QLabel(Form)\n        self.translateLabel.setObjectName(_fromUtf8(""translateLabel""))\n        self.verticalLayout.addWidget(self.translateLabel)\n        self.rotateLabel = QtGui.QLabel(Form)\n        self.rotateLabel.setObjectName(_fromUtf8(""rotateLabel""))\n        self.verticalLayout.addWidget(self.rotateLabel)\n        self.scaleLabel = QtGui.QLabel(Form)\n        self.scaleLabel.setObjectName(_fromUtf8(""scaleLabel""))\n        self.verticalLayout.addWidget(self.scaleLabel)\n        self.horizontalLayout = QtGui.QHBoxLayout()\n        self.horizontalLayout.setObjectName(_fromUtf8(""horizontalLayout""))\n        self.mirrorImageBtn = QtGui.QPushButton(Form)\n        self.mirrorImageBtn.setToolTip(_fromUtf8(""""))\n        self.mirrorImageBtn.setObjectName(_fromUtf8(""mirrorImageBtn""))\n        self.horizontalLayout.addWidget(self.mirrorImageBtn)\n        self.reflectImageBtn = QtGui.QPushButton(Form)\n        self.reflectImageBtn.setObjectName(_fromUtf8(""reflectImageBtn""))\n        self.horizontalLayout.addWidget(self.reflectImageBtn)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(_translate(""Form"", ""Form"", None))\n        self.translateLabel.setText(_translate(""Form"", ""Translate:"", None))\n        self.rotateLabel.setText(_translate(""Form"", ""Rotate:"", None))\n        self.scaleLabel.setText(_translate(""Form"", ""Scale:"", None))\n        self.mirrorImageBtn.setText(_translate(""Form"", ""Mirror"", None))\n        self.reflectImageBtn.setText(_translate(""Form"", ""Reflect"", None))\n\n'"
src/third_party/pyqtgraph/canvas/TransformGuiTemplate_pyqt5.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'pyqtgraph/canvas/TransformGuiTemplate.ui\'\n#\n# Created by: PyQt5 UI code generator 5.5.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(224, 117)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(Form.sizePolicy().hasHeightForWidth())\n        Form.setSizePolicy(sizePolicy)\n        self.verticalLayout = QtWidgets.QVBoxLayout(Form)\n        self.verticalLayout.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout.setSpacing(1)\n        self.verticalLayout.setObjectName(""verticalLayout"")\n        self.translateLabel = QtWidgets.QLabel(Form)\n        self.translateLabel.setObjectName(""translateLabel"")\n        self.verticalLayout.addWidget(self.translateLabel)\n        self.rotateLabel = QtWidgets.QLabel(Form)\n        self.rotateLabel.setObjectName(""rotateLabel"")\n        self.verticalLayout.addWidget(self.rotateLabel)\n        self.scaleLabel = QtWidgets.QLabel(Form)\n        self.scaleLabel.setObjectName(""scaleLabel"")\n        self.verticalLayout.addWidget(self.scaleLabel)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.mirrorImageBtn = QtWidgets.QPushButton(Form)\n        self.mirrorImageBtn.setToolTip("""")\n        self.mirrorImageBtn.setObjectName(""mirrorImageBtn"")\n        self.horizontalLayout.addWidget(self.mirrorImageBtn)\n        self.reflectImageBtn = QtWidgets.QPushButton(Form)\n        self.reflectImageBtn.setObjectName(""reflectImageBtn"")\n        self.horizontalLayout.addWidget(self.reflectImageBtn)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Form""))\n        self.translateLabel.setText(_translate(""Form"", ""Translate:""))\n        self.rotateLabel.setText(_translate(""Form"", ""Rotate:""))\n        self.scaleLabel.setText(_translate(""Form"", ""Scale:""))\n        self.mirrorImageBtn.setText(_translate(""Form"", ""Mirror""))\n        self.reflectImageBtn.setText(_translate(""Form"", ""Reflect""))\n\n'"
src/third_party/pyqtgraph/canvas/TransformGuiTemplate_pyside.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'pyqtgraph/canvas/TransformGuiTemplate.ui\'\n#\n# Created: Wed Nov  9 17:57:16 2016\n#      by: pyside-uic 0.2.15 running on PySide 1.2.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide import QtCore, QtGui\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(224, 117)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(Form.sizePolicy().hasHeightForWidth())\n        Form.setSizePolicy(sizePolicy)\n        self.verticalLayout = QtGui.QVBoxLayout(Form)\n        self.verticalLayout.setSpacing(1)\n        self.verticalLayout.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout.setObjectName(""verticalLayout"")\n        self.translateLabel = QtGui.QLabel(Form)\n        self.translateLabel.setObjectName(""translateLabel"")\n        self.verticalLayout.addWidget(self.translateLabel)\n        self.rotateLabel = QtGui.QLabel(Form)\n        self.rotateLabel.setObjectName(""rotateLabel"")\n        self.verticalLayout.addWidget(self.rotateLabel)\n        self.scaleLabel = QtGui.QLabel(Form)\n        self.scaleLabel.setObjectName(""scaleLabel"")\n        self.verticalLayout.addWidget(self.scaleLabel)\n        self.horizontalLayout = QtGui.QHBoxLayout()\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.mirrorImageBtn = QtGui.QPushButton(Form)\n        self.mirrorImageBtn.setToolTip("""")\n        self.mirrorImageBtn.setObjectName(""mirrorImageBtn"")\n        self.horizontalLayout.addWidget(self.mirrorImageBtn)\n        self.reflectImageBtn = QtGui.QPushButton(Form)\n        self.reflectImageBtn.setObjectName(""reflectImageBtn"")\n        self.horizontalLayout.addWidget(self.reflectImageBtn)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtGui.QApplication.translate(""Form"", ""Form"", None, QtGui.QApplication.UnicodeUTF8))\n        self.translateLabel.setText(QtGui.QApplication.translate(""Form"", ""Translate:"", None, QtGui.QApplication.UnicodeUTF8))\n        self.rotateLabel.setText(QtGui.QApplication.translate(""Form"", ""Rotate:"", None, QtGui.QApplication.UnicodeUTF8))\n        self.scaleLabel.setText(QtGui.QApplication.translate(""Form"", ""Scale:"", None, QtGui.QApplication.UnicodeUTF8))\n        self.mirrorImageBtn.setText(QtGui.QApplication.translate(""Form"", ""Mirror"", None, QtGui.QApplication.UnicodeUTF8))\n        self.reflectImageBtn.setText(QtGui.QApplication.translate(""Form"", ""Reflect"", None, QtGui.QApplication.UnicodeUTF8))\n\n'"
src/third_party/pyqtgraph/canvas/TransformGuiTemplate_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'TransformGuiTemplate.ui\'\n#\n# Created: Sun Sep 18 19:18:41 2016\n#      by: pyside2-uic  running on PySide2 2.0.0~alpha0\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide2 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(224, 117)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(Form.sizePolicy().hasHeightForWidth())\n        Form.setSizePolicy(sizePolicy)\n        self.verticalLayout = QtWidgets.QVBoxLayout(Form)\n        self.verticalLayout.setSpacing(1)\n        self.verticalLayout.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout.setObjectName(""verticalLayout"")\n        self.translateLabel = QtWidgets.QLabel(Form)\n        self.translateLabel.setObjectName(""translateLabel"")\n        self.verticalLayout.addWidget(self.translateLabel)\n        self.rotateLabel = QtWidgets.QLabel(Form)\n        self.rotateLabel.setObjectName(""rotateLabel"")\n        self.verticalLayout.addWidget(self.rotateLabel)\n        self.scaleLabel = QtWidgets.QLabel(Form)\n        self.scaleLabel.setObjectName(""scaleLabel"")\n        self.verticalLayout.addWidget(self.scaleLabel)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.mirrorImageBtn = QtWidgets.QPushButton(Form)\n        self.mirrorImageBtn.setToolTip("""")\n        self.mirrorImageBtn.setObjectName(""mirrorImageBtn"")\n        self.horizontalLayout.addWidget(self.mirrorImageBtn)\n        self.reflectImageBtn = QtWidgets.QPushButton(Form)\n        self.reflectImageBtn.setObjectName(""reflectImageBtn"")\n        self.horizontalLayout.addWidget(self.reflectImageBtn)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtWidgets.QApplication.translate(""Form"", ""Form"", None, -1))\n        self.translateLabel.setText(QtWidgets.QApplication.translate(""Form"", ""Translate:"", None, -1))\n        self.rotateLabel.setText(QtWidgets.QApplication.translate(""Form"", ""Rotate:"", None, -1))\n        self.scaleLabel.setText(QtWidgets.QApplication.translate(""Form"", ""Scale:"", None, -1))\n        self.mirrorImageBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Mirror"", None, -1))\n        self.reflectImageBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Reflect"", None, -1))\n\n'"
src/third_party/pyqtgraph/canvas/__init__.py,0,b'# -*- coding: utf-8 -*-\nfrom .Canvas import *\nfrom .CanvasItem import *'
src/third_party/pyqtgraph/console/CmdInput.py,0,"b'from ..Qt import QtCore, QtGui\nfrom ..python2_3 import asUnicode\n\nclass CmdInput(QtGui.QLineEdit):\n    \n    sigExecuteCmd = QtCore.Signal(object)\n    \n    def __init__(self, parent):\n        QtGui.QLineEdit.__init__(self, parent)\n        self.history = [""""]\n        self.ptr = 0\n    \n    def keyPressEvent(self, ev):\n        if ev.key() == QtCore.Qt.Key_Up:\n            if self.ptr < len(self.history) - 1:\n                self.setHistory(self.ptr+1)\n                ev.accept()\n                return\n        elif ev.key() ==  QtCore.Qt.Key_Down:\n            if self.ptr > 0:\n                self.setHistory(self.ptr-1)\n                ev.accept()\n                return\n        elif ev.key() == QtCore.Qt.Key_Return:\n            self.execCmd()\n        else:\n            QtGui.QLineEdit.keyPressEvent(self, ev)\n            self.history[0] = asUnicode(self.text())\n        \n    def execCmd(self):\n        cmd = asUnicode(self.text())\n        if len(self.history) == 1 or cmd != self.history[1]:\n            self.history.insert(1, cmd)\n        self.history[0] = """"\n        self.setHistory(0)\n        self.sigExecuteCmd.emit(cmd)\n        \n    def setHistory(self, num):\n        self.ptr = num\n        self.setText(self.history[self.ptr])\n'"
src/third_party/pyqtgraph/console/Console.py,0,"b'import sys, re, os, time, traceback, subprocess\nimport pickle\n\nfrom ..Qt import QtCore, QtGui, QT_LIB\nfrom ..python2_3 import basestring\nfrom .. import exceptionHandling as exceptionHandling\nfrom .. import getConfigOption\nfrom ..functions import SignalBlock\nif QT_LIB == \'PySide\':\n    from . import template_pyside as template\nelif QT_LIB == \'PySide2\':\n    from . import template_pyside2 as template\nelif QT_LIB == \'PyQt5\':\n    from . import template_pyqt5 as template\nelse:\n    from . import template_pyqt as template\n\n\nclass ConsoleWidget(QtGui.QWidget):\n    """"""\n    Widget displaying console output and accepting command input.\n    Implements:\n        \n    - eval python expressions / exec python statements\n    - storable history of commands\n    - exception handling allowing commands to be interpreted in the context of any level in the exception stack frame\n    \n    Why not just use python in an interactive shell (or ipython) ? There are a few reasons:\n       \n    - pyside does not yet allow Qt event processing and interactive shell at the same time\n    - on some systems, typing in the console _blocks_ the qt event loop until the user presses enter. This can \n      be baffling and frustrating to users since it would appear the program has frozen.\n    - some terminals (eg windows cmd.exe) have notoriously unfriendly interfaces\n    - ability to add extra features like exception stack introspection\n    - ability to have multiple interactive prompts, including for spawned sub-processes\n    """"""\n    _threadException = QtCore.Signal(object)\n    \n    def __init__(self, parent=None, namespace=None, historyFile=None, text=None, editor=None):\n        """"""\n        ==============  ============================================================================\n        **Arguments:**\n        namespace       dictionary containing the initial variables present in the default namespace\n        historyFile     optional file for storing command history\n        text            initial text to display in the console window\n        editor          optional string for invoking code editor (called when stack trace entries are \n                        double-clicked). May contain {fileName} and {lineNum} format keys. Example:: \n                      \n                            editorCommand --loadfile {fileName} --gotoline {lineNum}\n        ==============  =============================================================================\n        """"""\n        QtGui.QWidget.__init__(self, parent)\n        if namespace is None:\n            namespace = {}\n        namespace[\'__console__\'] = self\n        self.localNamespace = namespace\n        self.editor = editor\n        self.multiline = None\n        self.inCmd = False\n        self.frames = []  # stack frames to access when an item in the stack list is selected\n        \n        self.ui = template.Ui_Form()\n        self.ui.setupUi(self)\n        self.output = self.ui.output\n        self.input = self.ui.input\n        self.input.setFocus()\n        \n        if text is not None:\n            self.output.setPlainText(text)\n\n        self.historyFile = historyFile\n        \n        history = self.loadHistory()\n        if history is not None:\n            self.input.history = [""""] + history\n            self.ui.historyList.addItems(history[::-1])\n        self.ui.historyList.hide()\n        self.ui.exceptionGroup.hide()\n        \n        self.input.sigExecuteCmd.connect(self.runCmd)\n        self.ui.historyBtn.toggled.connect(self.ui.historyList.setVisible)\n        self.ui.historyList.itemClicked.connect(self.cmdSelected)\n        self.ui.historyList.itemDoubleClicked.connect(self.cmdDblClicked)\n        self.ui.exceptionBtn.toggled.connect(self.ui.exceptionGroup.setVisible)\n        \n        self.ui.catchAllExceptionsBtn.toggled.connect(self.catchAllExceptions)\n        self.ui.catchNextExceptionBtn.toggled.connect(self.catchNextException)\n        self.ui.clearExceptionBtn.clicked.connect(self.clearExceptionClicked)\n        self.ui.exceptionStackList.itemClicked.connect(self.stackItemClicked)\n        self.ui.exceptionStackList.itemDoubleClicked.connect(self.stackItemDblClicked)\n        self.ui.onlyUncaughtCheck.toggled.connect(self.updateSysTrace)\n        \n        self.currentTraceback = None\n\n        # send exceptions raised in non-gui threads back to the main thread by signal.\n        self._threadException.connect(self._threadExceptionHandler)\n        \n    def loadHistory(self):\n        """"""Return the list of previously-invoked command strings (or None).""""""\n        if self.historyFile is not None:\n            return pickle.load(open(self.historyFile, \'rb\'))\n        \n    def saveHistory(self, history):\n        """"""Store the list of previously-invoked command strings.""""""\n        if self.historyFile is not None:\n            pickle.dump(open(self.historyFile, \'wb\'), history)\n        \n    def runCmd(self, cmd):\n        self.stdout = sys.stdout\n        self.stderr = sys.stderr\n        encCmd = re.sub(r\'>\', \'&gt;\', re.sub(r\'<\', \'&lt;\', cmd))\n        encCmd = re.sub(r\' \', \'&nbsp;\', encCmd)\n        \n        self.ui.historyList.addItem(cmd)\n        self.saveHistory(self.input.history[1:100])\n        \n        try:\n            sys.stdout = self\n            sys.stderr = self\n            if self.multiline is not None:\n                self.write(""<br><b>%s</b>\\n""%encCmd, html=True, scrollToBottom=True)\n                self.execMulti(cmd)\n            else:\n                self.write(""<br><div style=\'background-color: #CCF; color: black\'><b>%s</b>\\n""%encCmd, html=True, scrollToBottom=True)\n                self.inCmd = True\n                self.execSingle(cmd)\n            \n            if not self.inCmd:\n                self.write(""</div>\\n"", html=True, scrollToBottom=True)\n                \n        finally:\n            sys.stdout = self.stdout\n            sys.stderr = self.stderr\n            \n            sb = self.ui.historyList.verticalScrollBar()\n            sb.setValue(sb.maximum())\n            \n    def globals(self):\n        frame = self.currentFrame()\n        if frame is not None and self.ui.runSelectedFrameCheck.isChecked():\n            return self.currentFrame().f_globals\n        else:\n            return self.localNamespace\n        \n    def locals(self):\n        frame = self.currentFrame()\n        if frame is not None and self.ui.runSelectedFrameCheck.isChecked():\n            return self.currentFrame().f_locals\n        else:\n            return self.localNamespace\n            \n    def currentFrame(self):\n        ## Return the currently selected exception stack frame (or None if there is no exception)\n        index = self.ui.exceptionStackList.currentRow()\n        if index >= 0 and index < len(self.frames):\n            return self.frames[index]\n        else:\n            return None\n        \n    def execSingle(self, cmd):\n        try:\n            output = eval(cmd, self.globals(), self.locals())\n            self.write(repr(output) + \'\\n\')\n        except SyntaxError:\n            try:\n                exec(cmd, self.globals(), self.locals())\n            except SyntaxError as exc:\n                if \'unexpected EOF\' in exc.msg:\n                    self.multiline = cmd\n                else:\n                    self.displayException()\n            except:\n                self.displayException()\n        except:\n            self.displayException()\n            \n    def execMulti(self, nextLine):\n        #self.stdout.write(nextLine+""\\n"")\n        if nextLine.strip() != \'\':\n            self.multiline += ""\\n"" + nextLine\n            return\n        else:\n            cmd = self.multiline\n            \n        try:\n            output = eval(cmd, self.globals(), self.locals())\n            self.write(str(output) + \'\\n\')\n            self.multiline = None\n        except SyntaxError:\n            try:\n                exec(cmd, self.globals(), self.locals())\n                self.multiline = None\n            except SyntaxError as exc:\n                if \'unexpected EOF\' in exc.msg:\n                    self.multiline = cmd\n                else:\n                    self.displayException()\n                    self.multiline = None\n            except:\n                self.displayException()\n                self.multiline = None\n        except:\n            self.displayException()\n            self.multiline = None\n\n    def write(self, strn, html=False, scrollToBottom=\'auto\'):\n        """"""Write a string into the console.\n\n        If scrollToBottom is \'auto\', then the console is automatically scrolled\n        to fit the new text only if it was already at the bottom.\n        """"""\n        isGuiThread = QtCore.QThread.currentThread() == QtCore.QCoreApplication.instance().thread()\n        if not isGuiThread:\n            self.stdout.write(strn)\n            return\n\n        sb = self.output.verticalScrollBar()\n        scroll = sb.value()\n        if scrollToBottom == \'auto\':\n            atBottom = scroll == sb.maximum()\n            scrollToBottom = atBottom\n\n        self.output.moveCursor(QtGui.QTextCursor.End)\n        if html:\n            self.output.textCursor().insertHtml(strn)\n        else:\n            if self.inCmd:\n                self.inCmd = False\n                self.output.textCursor().insertHtml(""</div><br><div style=\'font-weight: normal; background-color: #FFF; color: black\'>"")\n            self.output.insertPlainText(strn)\n\n        if scrollToBottom:\n            sb.setValue(sb.maximum())\n        else:\n            sb.setValue(scroll)\n\n    def displayException(self):\n        """"""\n        Display the current exception and stack.\n        """"""\n        tb = traceback.format_exc()\n        lines = []\n        indent = 4\n        prefix = \'\' \n        for l in tb.split(\'\\n\'):\n            lines.append("" ""*indent + prefix + l)\n        self.write(\'\\n\'.join(lines))\n        self.exceptionHandler(*sys.exc_info())\n        \n    def cmdSelected(self, item):\n        index = -(self.ui.historyList.row(item)+1)\n        self.input.setHistory(index)\n        self.input.setFocus()\n        \n    def cmdDblClicked(self, item):\n        index = -(self.ui.historyList.row(item)+1)\n        self.input.setHistory(index)\n        self.input.execCmd()\n        \n    def flush(self):\n        pass\n\n    def catchAllExceptions(self, catch=True):\n        """"""\n        If True, the console will catch all unhandled exceptions and display the stack\n        trace. Each exception caught clears the last.\n        """"""\n        with SignalBlock(self.ui.catchAllExceptionsBtn.toggled, self.catchAllExceptions):\n            self.ui.catchAllExceptionsBtn.setChecked(catch)\n        \n        if catch:\n            with SignalBlock(self.ui.catchNextExceptionBtn.toggled, self.catchNextException):\n                self.ui.catchNextExceptionBtn.setChecked(False)\n            self.enableExceptionHandling()\n            self.ui.exceptionBtn.setChecked(True)\n        else:\n            self.disableExceptionHandling()\n        \n    def catchNextException(self, catch=True):\n        """"""\n        If True, the console will catch the next unhandled exception and display the stack\n        trace.\n        """"""\n        with SignalBlock(self.ui.catchNextExceptionBtn.toggled, self.catchNextException):\n            self.ui.catchNextExceptionBtn.setChecked(catch)\n        if catch:\n            with SignalBlock(self.ui.catchAllExceptionsBtn.toggled, self.catchAllExceptions):\n                self.ui.catchAllExceptionsBtn.setChecked(False)\n            self.enableExceptionHandling()\n            self.ui.exceptionBtn.setChecked(True)\n        else:\n            self.disableExceptionHandling()\n        \n    def enableExceptionHandling(self):\n        exceptionHandling.register(self.exceptionHandler)\n        self.updateSysTrace()\n        \n    def disableExceptionHandling(self):\n        exceptionHandling.unregister(self.exceptionHandler)\n        self.updateSysTrace()\n        \n    def clearExceptionClicked(self):\n        self.currentTraceback = None\n        self.frames = []\n        self.ui.exceptionInfoLabel.setText(""[No current exception]"")\n        self.ui.exceptionStackList.clear()\n        self.ui.clearExceptionBtn.setEnabled(False)\n        \n    def stackItemClicked(self, item):\n        pass\n    \n    def stackItemDblClicked(self, item):\n        editor = self.editor\n        if editor is None:\n            editor = getConfigOption(\'editorCommand\')\n        if editor is None:\n            return\n        tb = self.currentFrame()\n        lineNum = tb.tb_lineno\n        fileName = tb.tb_frame.f_code.co_filename\n        subprocess.Popen(self.editor.format(fileName=fileName, lineNum=lineNum), shell=True)\n        \n    def updateSysTrace(self):\n        ## Install or uninstall  sys.settrace handler \n        \n        if not self.ui.catchNextExceptionBtn.isChecked() and not self.ui.catchAllExceptionsBtn.isChecked():\n            if sys.gettrace() == self.systrace:\n                sys.settrace(None)\n            return\n        \n        if self.ui.onlyUncaughtCheck.isChecked():\n            if sys.gettrace() == self.systrace:\n                sys.settrace(None)\n        else:\n            if sys.gettrace() is not None and sys.gettrace() != self.systrace:\n                self.ui.onlyUncaughtCheck.setChecked(False)\n                raise Exception(""sys.settrace is in use; cannot monitor for caught exceptions."")\n            else:\n                sys.settrace(self.systrace)\n        \n    def exceptionHandler(self, excType, exc, tb, systrace=False, frame=None):\n        if frame is None:\n            frame = sys._getframe()\n\n        # exceptions raised in non-gui threads must be handled separately\n        isGuiThread = QtCore.QThread.currentThread() == QtCore.QCoreApplication.instance().thread()\n        if not isGuiThread:\n            # sending a frame from one thread to another.. probably not safe, but better than just\n            # dropping the exception?\n            self._threadException.emit((excType, exc, tb, systrace, frame.f_back))\n            return\n\n        if self.ui.catchNextExceptionBtn.isChecked():\n            self.ui.catchNextExceptionBtn.setChecked(False)\n        elif not self.ui.catchAllExceptionsBtn.isChecked():\n            return\n        \n        self.currentTraceback = tb\n        \n        excMessage = \'\'.join(traceback.format_exception_only(excType, exc))\n        self.ui.exceptionInfoLabel.setText(excMessage)\n\n        if systrace:\n            # exceptions caught using systrace don\'t need the usual \n            # call stack + traceback handling\n            self.setStack(frame.f_back.f_back)\n        else:\n            self.setStack(frame=frame.f_back, tb=tb)\n    \n    def _threadExceptionHandler(self, args):\n        self.exceptionHandler(*args)\n\n    def setStack(self, frame=None, tb=None):\n        """"""Display a call stack and exception traceback.\n\n        This allows the user to probe the contents of any frame in the given stack.\n\n        *frame* may either be a Frame instance or None, in which case the current \n        frame is retrieved from ``sys._getframe()``. \n\n        If *tb* is provided then the frames in the traceback will be appended to \n        the end of the stack list. If *tb* is None, then sys.exc_info() will \n        be checked instead.\n        """"""\n        self.ui.clearExceptionBtn.setEnabled(True)\n        \n        if frame is None:\n            frame = sys._getframe().f_back\n\n        if tb is None:\n            tb = sys.exc_info()[2]\n\n        self.ui.exceptionStackList.clear()\n        self.frames = []\n\n        # Build stack up to this point\n        for index, line in enumerate(traceback.extract_stack(frame)):\n            # extract_stack return value changed in python 3.5\n            if \'FrameSummary\' in str(type(line)):\n                line = (line.filename, line.lineno, line.name, line._line)\n            \n            self.ui.exceptionStackList.addItem(\'File ""%s"", line %s, in %s()\\n  %s\' % line)\n        while frame is not None:\n            self.frames.insert(0, frame)\n            frame = frame.f_back\n\n        if tb is None:\n            return\n\n        self.ui.exceptionStackList.addItem(\'-- exception caught here: --\')\n        item = self.ui.exceptionStackList.item(self.ui.exceptionStackList.count()-1)\n        item.setBackground(QtGui.QBrush(QtGui.QColor(200, 200, 200)))\n        item.setForeground(QtGui.QBrush(QtGui.QColor(50, 50, 50)))\n        self.frames.append(None)\n\n        # And finish the rest of the stack up to the exception\n        for index, line in enumerate(traceback.extract_tb(tb)):\n            # extract_stack return value changed in python 3.5\n            if \'FrameSummary\' in str(type(line)):\n                line = (line.filename, line.lineno, line.name, line._line)\n            \n            self.ui.exceptionStackList.addItem(\'File ""%s"", line %s, in %s()\\n  %s\' % line)\n        while tb is not None:\n            self.frames.append(tb.tb_frame)\n            tb = tb.tb_next\n\n    def systrace(self, frame, event, arg):\n        if event == \'exception\' and self.checkException(*arg):\n            self.exceptionHandler(*arg, systrace=True)\n        return self.systrace\n        \n    def checkException(self, excType, exc, tb):\n        ## Return True if the exception is interesting; False if it should be ignored.\n        \n        filename = tb.tb_frame.f_code.co_filename\n        function = tb.tb_frame.f_code.co_name\n        \n        filterStr = str(self.ui.filterText.text())\n        if filterStr != \'\':\n            if isinstance(exc, Exception):\n                msg = exc.message\n            elif isinstance(exc, basestring):\n                msg = exc\n            else:\n                msg = repr(exc)\n            match = re.search(filterStr, ""%s:%s:%s"" % (filename, function, msg))\n            return match is not None\n\n        ## Go through a list of common exception points we like to ignore:\n        if excType is GeneratorExit or excType is StopIteration:\n            return False\n        if excType is KeyError:\n            if filename.endswith(\'python2.7/weakref.py\') and function in (\'__contains__\', \'get\'):\n                return False\n            if filename.endswith(\'python2.7/copy.py\') and function == \'_keep_alive\':\n                return False\n        if excType is AttributeError:\n            if filename.endswith(\'python2.7/collections.py\') and function == \'__init__\':\n                return False\n            if filename.endswith(\'numpy/core/fromnumeric.py\') and function in (\'all\', \'_wrapit\', \'transpose\', \'sum\'):\n                return False\n            if filename.endswith(\'numpy/core/arrayprint.py\') and function in (\'_array2string\'):\n                return False\n            if filename.endswith(\'MetaArray.py\') and function == \'__getattr__\':\n                for name in (\'__array_interface__\', \'__array_struct__\', \'__array__\'):  ## numpy looks for these when converting objects to array\n                    if name in exc:\n                        return False\n            if filename.endswith(\'flowchart/eq.py\'):\n                return False\n            if filename.endswith(\'pyqtgraph/functions.py\') and function == \'makeQImage\':\n                return False\n        if excType is TypeError:\n            if filename.endswith(\'numpy/lib/function_base.py\') and function == \'iterable\':\n                return False\n        if excType is ZeroDivisionError:\n            if filename.endswith(\'python2.7/traceback.py\'):\n                return False\n            \n        return True\n    \n'"
src/third_party/pyqtgraph/console/__init__.py,0,b'from .Console import ConsoleWidget'
src/third_party/pyqtgraph/console/template_pyqt.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'pyqtgraph/console/template.ui\'\n#\n# Created by: PyQt4 UI code generator 4.11.4\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt4 import QtCore, QtGui\n\ntry:\n    _fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n    def _fromUtf8(s):\n        return s\n\ntry:\n    _encoding = QtGui.QApplication.UnicodeUTF8\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig, _encoding)\nexcept AttributeError:\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig)\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(""Form""))\n        Form.resize(739, 497)\n        self.gridLayout = QtGui.QGridLayout(Form)\n        self.gridLayout.setMargin(0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(_fromUtf8(""gridLayout""))\n        self.splitter = QtGui.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Vertical)\n        self.splitter.setObjectName(_fromUtf8(""splitter""))\n        self.layoutWidget = QtGui.QWidget(self.splitter)\n        self.layoutWidget.setObjectName(_fromUtf8(""layoutWidget""))\n        self.verticalLayout = QtGui.QVBoxLayout(self.layoutWidget)\n        self.verticalLayout.setObjectName(_fromUtf8(""verticalLayout""))\n        self.output = QtGui.QPlainTextEdit(self.layoutWidget)\n        font = QtGui.QFont()\n        font.setFamily(_fromUtf8(""Monospace""))\n        self.output.setFont(font)\n        self.output.setReadOnly(True)\n        self.output.setObjectName(_fromUtf8(""output""))\n        self.verticalLayout.addWidget(self.output)\n        self.horizontalLayout = QtGui.QHBoxLayout()\n        self.horizontalLayout.setObjectName(_fromUtf8(""horizontalLayout""))\n        self.input = CmdInput(self.layoutWidget)\n        self.input.setObjectName(_fromUtf8(""input""))\n        self.horizontalLayout.addWidget(self.input)\n        self.historyBtn = QtGui.QPushButton(self.layoutWidget)\n        self.historyBtn.setCheckable(True)\n        self.historyBtn.setObjectName(_fromUtf8(""historyBtn""))\n        self.horizontalLayout.addWidget(self.historyBtn)\n        self.exceptionBtn = QtGui.QPushButton(self.layoutWidget)\n        self.exceptionBtn.setCheckable(True)\n        self.exceptionBtn.setObjectName(_fromUtf8(""exceptionBtn""))\n        self.horizontalLayout.addWidget(self.exceptionBtn)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n        self.historyList = QtGui.QListWidget(self.splitter)\n        font = QtGui.QFont()\n        font.setFamily(_fromUtf8(""Monospace""))\n        self.historyList.setFont(font)\n        self.historyList.setObjectName(_fromUtf8(""historyList""))\n        self.exceptionGroup = QtGui.QGroupBox(self.splitter)\n        self.exceptionGroup.setObjectName(_fromUtf8(""exceptionGroup""))\n        self.gridLayout_2 = QtGui.QGridLayout(self.exceptionGroup)\n        self.gridLayout_2.setContentsMargins(-1, 0, -1, 0)\n        self.gridLayout_2.setHorizontalSpacing(2)\n        self.gridLayout_2.setVerticalSpacing(0)\n        self.gridLayout_2.setObjectName(_fromUtf8(""gridLayout_2""))\n        self.clearExceptionBtn = QtGui.QPushButton(self.exceptionGroup)\n        self.clearExceptionBtn.setEnabled(False)\n        self.clearExceptionBtn.setObjectName(_fromUtf8(""clearExceptionBtn""))\n        self.gridLayout_2.addWidget(self.clearExceptionBtn, 0, 6, 1, 1)\n        self.catchAllExceptionsBtn = QtGui.QPushButton(self.exceptionGroup)\n        self.catchAllExceptionsBtn.setCheckable(True)\n        self.catchAllExceptionsBtn.setObjectName(_fromUtf8(""catchAllExceptionsBtn""))\n        self.gridLayout_2.addWidget(self.catchAllExceptionsBtn, 0, 1, 1, 1)\n        self.catchNextExceptionBtn = QtGui.QPushButton(self.exceptionGroup)\n        self.catchNextExceptionBtn.setCheckable(True)\n        self.catchNextExceptionBtn.setObjectName(_fromUtf8(""catchNextExceptionBtn""))\n        self.gridLayout_2.addWidget(self.catchNextExceptionBtn, 0, 0, 1, 1)\n        self.onlyUncaughtCheck = QtGui.QCheckBox(self.exceptionGroup)\n        self.onlyUncaughtCheck.setChecked(True)\n        self.onlyUncaughtCheck.setObjectName(_fromUtf8(""onlyUncaughtCheck""))\n        self.gridLayout_2.addWidget(self.onlyUncaughtCheck, 0, 4, 1, 1)\n        self.exceptionStackList = QtGui.QListWidget(self.exceptionGroup)\n        self.exceptionStackList.setAlternatingRowColors(True)\n        self.exceptionStackList.setObjectName(_fromUtf8(""exceptionStackList""))\n        self.gridLayout_2.addWidget(self.exceptionStackList, 2, 0, 1, 7)\n        self.runSelectedFrameCheck = QtGui.QCheckBox(self.exceptionGroup)\n        self.runSelectedFrameCheck.setChecked(True)\n        self.runSelectedFrameCheck.setObjectName(_fromUtf8(""runSelectedFrameCheck""))\n        self.gridLayout_2.addWidget(self.runSelectedFrameCheck, 3, 0, 1, 7)\n        self.exceptionInfoLabel = QtGui.QLabel(self.exceptionGroup)\n        self.exceptionInfoLabel.setWordWrap(True)\n        self.exceptionInfoLabel.setObjectName(_fromUtf8(""exceptionInfoLabel""))\n        self.gridLayout_2.addWidget(self.exceptionInfoLabel, 1, 0, 1, 7)\n        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)\n        self.gridLayout_2.addItem(spacerItem, 0, 5, 1, 1)\n        self.label = QtGui.QLabel(self.exceptionGroup)\n        self.label.setObjectName(_fromUtf8(""label""))\n        self.gridLayout_2.addWidget(self.label, 0, 2, 1, 1)\n        self.filterText = QtGui.QLineEdit(self.exceptionGroup)\n        self.filterText.setObjectName(_fromUtf8(""filterText""))\n        self.gridLayout_2.addWidget(self.filterText, 0, 3, 1, 1)\n        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(_translate(""Form"", ""Console"", None))\n        self.historyBtn.setText(_translate(""Form"", ""History.."", None))\n        self.exceptionBtn.setText(_translate(""Form"", ""Exceptions.."", None))\n        self.exceptionGroup.setTitle(_translate(""Form"", ""Exception Handling"", None))\n        self.clearExceptionBtn.setText(_translate(""Form"", ""Clear Stack"", None))\n        self.catchAllExceptionsBtn.setText(_translate(""Form"", ""Show All Exceptions"", None))\n        self.catchNextExceptionBtn.setText(_translate(""Form"", ""Show Next Exception"", None))\n        self.onlyUncaughtCheck.setText(_translate(""Form"", ""Only Uncaught Exceptions"", None))\n        self.runSelectedFrameCheck.setText(_translate(""Form"", ""Run commands in selected stack frame"", None))\n        self.exceptionInfoLabel.setText(_translate(""Form"", ""Stack Trace"", None))\n        self.label.setText(_translate(""Form"", ""Filter (regex):"", None))\n\nfrom .CmdInput import CmdInput\n'"
src/third_party/pyqtgraph/console/template_pyqt5.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'pyqtgraph/console/template.ui\'\n#\n# Created by: PyQt5 UI code generator 5.5.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(739, 497)\n        self.gridLayout = QtWidgets.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.splitter = QtWidgets.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Vertical)\n        self.splitter.setObjectName(""splitter"")\n        self.layoutWidget = QtWidgets.QWidget(self.splitter)\n        self.layoutWidget.setObjectName(""layoutWidget"")\n        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)\n        self.verticalLayout.setObjectName(""verticalLayout"")\n        self.output = QtWidgets.QPlainTextEdit(self.layoutWidget)\n        font = QtGui.QFont()\n        font.setFamily(""Monospace"")\n        self.output.setFont(font)\n        self.output.setReadOnly(True)\n        self.output.setObjectName(""output"")\n        self.verticalLayout.addWidget(self.output)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.input = CmdInput(self.layoutWidget)\n        self.input.setObjectName(""input"")\n        self.horizontalLayout.addWidget(self.input)\n        self.historyBtn = QtWidgets.QPushButton(self.layoutWidget)\n        self.historyBtn.setCheckable(True)\n        self.historyBtn.setObjectName(""historyBtn"")\n        self.horizontalLayout.addWidget(self.historyBtn)\n        self.exceptionBtn = QtWidgets.QPushButton(self.layoutWidget)\n        self.exceptionBtn.setCheckable(True)\n        self.exceptionBtn.setObjectName(""exceptionBtn"")\n        self.horizontalLayout.addWidget(self.exceptionBtn)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n        self.historyList = QtWidgets.QListWidget(self.splitter)\n        font = QtGui.QFont()\n        font.setFamily(""Monospace"")\n        self.historyList.setFont(font)\n        self.historyList.setObjectName(""historyList"")\n        self.exceptionGroup = QtWidgets.QGroupBox(self.splitter)\n        self.exceptionGroup.setObjectName(""exceptionGroup"")\n        self.gridLayout_2 = QtWidgets.QGridLayout(self.exceptionGroup)\n        self.gridLayout_2.setContentsMargins(-1, 0, -1, 0)\n        self.gridLayout_2.setHorizontalSpacing(2)\n        self.gridLayout_2.setVerticalSpacing(0)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.clearExceptionBtn = QtWidgets.QPushButton(self.exceptionGroup)\n        self.clearExceptionBtn.setEnabled(False)\n        self.clearExceptionBtn.setObjectName(""clearExceptionBtn"")\n        self.gridLayout_2.addWidget(self.clearExceptionBtn, 0, 6, 1, 1)\n        self.catchAllExceptionsBtn = QtWidgets.QPushButton(self.exceptionGroup)\n        self.catchAllExceptionsBtn.setCheckable(True)\n        self.catchAllExceptionsBtn.setObjectName(""catchAllExceptionsBtn"")\n        self.gridLayout_2.addWidget(self.catchAllExceptionsBtn, 0, 1, 1, 1)\n        self.catchNextExceptionBtn = QtWidgets.QPushButton(self.exceptionGroup)\n        self.catchNextExceptionBtn.setCheckable(True)\n        self.catchNextExceptionBtn.setObjectName(""catchNextExceptionBtn"")\n        self.gridLayout_2.addWidget(self.catchNextExceptionBtn, 0, 0, 1, 1)\n        self.onlyUncaughtCheck = QtWidgets.QCheckBox(self.exceptionGroup)\n        self.onlyUncaughtCheck.setChecked(True)\n        self.onlyUncaughtCheck.setObjectName(""onlyUncaughtCheck"")\n        self.gridLayout_2.addWidget(self.onlyUncaughtCheck, 0, 4, 1, 1)\n        self.exceptionStackList = QtWidgets.QListWidget(self.exceptionGroup)\n        self.exceptionStackList.setAlternatingRowColors(True)\n        self.exceptionStackList.setObjectName(""exceptionStackList"")\n        self.gridLayout_2.addWidget(self.exceptionStackList, 2, 0, 1, 7)\n        self.runSelectedFrameCheck = QtWidgets.QCheckBox(self.exceptionGroup)\n        self.runSelectedFrameCheck.setChecked(True)\n        self.runSelectedFrameCheck.setObjectName(""runSelectedFrameCheck"")\n        self.gridLayout_2.addWidget(self.runSelectedFrameCheck, 3, 0, 1, 7)\n        self.exceptionInfoLabel = QtWidgets.QLabel(self.exceptionGroup)\n        self.exceptionInfoLabel.setWordWrap(True)\n        self.exceptionInfoLabel.setObjectName(""exceptionInfoLabel"")\n        self.gridLayout_2.addWidget(self.exceptionInfoLabel, 1, 0, 1, 7)\n        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout_2.addItem(spacerItem, 0, 5, 1, 1)\n        self.label = QtWidgets.QLabel(self.exceptionGroup)\n        self.label.setObjectName(""label"")\n        self.gridLayout_2.addWidget(self.label, 0, 2, 1, 1)\n        self.filterText = QtWidgets.QLineEdit(self.exceptionGroup)\n        self.filterText.setObjectName(""filterText"")\n        self.gridLayout_2.addWidget(self.filterText, 0, 3, 1, 1)\n        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Console""))\n        self.historyBtn.setText(_translate(""Form"", ""History..""))\n        self.exceptionBtn.setText(_translate(""Form"", ""Exceptions..""))\n        self.exceptionGroup.setTitle(_translate(""Form"", ""Exception Handling""))\n        self.clearExceptionBtn.setText(_translate(""Form"", ""Clear Stack""))\n        self.catchAllExceptionsBtn.setText(_translate(""Form"", ""Show All Exceptions""))\n        self.catchNextExceptionBtn.setText(_translate(""Form"", ""Show Next Exception""))\n        self.onlyUncaughtCheck.setText(_translate(""Form"", ""Only Uncaught Exceptions""))\n        self.runSelectedFrameCheck.setText(_translate(""Form"", ""Run commands in selected stack frame""))\n        self.exceptionInfoLabel.setText(_translate(""Form"", ""Stack Trace""))\n        self.label.setText(_translate(""Form"", ""Filter (regex):""))\n\nfrom .CmdInput import CmdInput\n'"
src/third_party/pyqtgraph/console/template_pyside.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'pyqtgraph/console/template.ui\'\n#\n# Created: Tue Sep 19 09:45:18 2017\n#      by: pyside-uic 0.2.15 running on PySide 1.2.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide import QtCore, QtGui\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(739, 497)\n        self.gridLayout = QtGui.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.splitter = QtGui.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Vertical)\n        self.splitter.setObjectName(""splitter"")\n        self.layoutWidget = QtGui.QWidget(self.splitter)\n        self.layoutWidget.setObjectName(""layoutWidget"")\n        self.verticalLayout = QtGui.QVBoxLayout(self.layoutWidget)\n        self.verticalLayout.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout.setObjectName(""verticalLayout"")\n        self.output = QtGui.QPlainTextEdit(self.layoutWidget)\n        font = QtGui.QFont()\n        font.setFamily(""Monospace"")\n        self.output.setFont(font)\n        self.output.setReadOnly(True)\n        self.output.setObjectName(""output"")\n        self.verticalLayout.addWidget(self.output)\n        self.horizontalLayout = QtGui.QHBoxLayout()\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.input = CmdInput(self.layoutWidget)\n        self.input.setObjectName(""input"")\n        self.horizontalLayout.addWidget(self.input)\n        self.historyBtn = QtGui.QPushButton(self.layoutWidget)\n        self.historyBtn.setCheckable(True)\n        self.historyBtn.setObjectName(""historyBtn"")\n        self.horizontalLayout.addWidget(self.historyBtn)\n        self.exceptionBtn = QtGui.QPushButton(self.layoutWidget)\n        self.exceptionBtn.setCheckable(True)\n        self.exceptionBtn.setObjectName(""exceptionBtn"")\n        self.horizontalLayout.addWidget(self.exceptionBtn)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n        self.historyList = QtGui.QListWidget(self.splitter)\n        font = QtGui.QFont()\n        font.setFamily(""Monospace"")\n        self.historyList.setFont(font)\n        self.historyList.setObjectName(""historyList"")\n        self.exceptionGroup = QtGui.QGroupBox(self.splitter)\n        self.exceptionGroup.setObjectName(""exceptionGroup"")\n        self.gridLayout_2 = QtGui.QGridLayout(self.exceptionGroup)\n        self.gridLayout_2.setContentsMargins(-1, 0, -1, 0)\n        self.gridLayout_2.setHorizontalSpacing(2)\n        self.gridLayout_2.setVerticalSpacing(0)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.clearExceptionBtn = QtGui.QPushButton(self.exceptionGroup)\n        self.clearExceptionBtn.setEnabled(False)\n        self.clearExceptionBtn.setObjectName(""clearExceptionBtn"")\n        self.gridLayout_2.addWidget(self.clearExceptionBtn, 0, 6, 1, 1)\n        self.catchAllExceptionsBtn = QtGui.QPushButton(self.exceptionGroup)\n        self.catchAllExceptionsBtn.setCheckable(True)\n        self.catchAllExceptionsBtn.setObjectName(""catchAllExceptionsBtn"")\n        self.gridLayout_2.addWidget(self.catchAllExceptionsBtn, 0, 1, 1, 1)\n        self.catchNextExceptionBtn = QtGui.QPushButton(self.exceptionGroup)\n        self.catchNextExceptionBtn.setCheckable(True)\n        self.catchNextExceptionBtn.setObjectName(""catchNextExceptionBtn"")\n        self.gridLayout_2.addWidget(self.catchNextExceptionBtn, 0, 0, 1, 1)\n        self.onlyUncaughtCheck = QtGui.QCheckBox(self.exceptionGroup)\n        self.onlyUncaughtCheck.setChecked(True)\n        self.onlyUncaughtCheck.setObjectName(""onlyUncaughtCheck"")\n        self.gridLayout_2.addWidget(self.onlyUncaughtCheck, 0, 4, 1, 1)\n        self.exceptionStackList = QtGui.QListWidget(self.exceptionGroup)\n        self.exceptionStackList.setAlternatingRowColors(True)\n        self.exceptionStackList.setObjectName(""exceptionStackList"")\n        self.gridLayout_2.addWidget(self.exceptionStackList, 2, 0, 1, 7)\n        self.runSelectedFrameCheck = QtGui.QCheckBox(self.exceptionGroup)\n        self.runSelectedFrameCheck.setChecked(True)\n        self.runSelectedFrameCheck.setObjectName(""runSelectedFrameCheck"")\n        self.gridLayout_2.addWidget(self.runSelectedFrameCheck, 3, 0, 1, 7)\n        self.exceptionInfoLabel = QtGui.QLabel(self.exceptionGroup)\n        self.exceptionInfoLabel.setWordWrap(True)\n        self.exceptionInfoLabel.setObjectName(""exceptionInfoLabel"")\n        self.gridLayout_2.addWidget(self.exceptionInfoLabel, 1, 0, 1, 7)\n        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)\n        self.gridLayout_2.addItem(spacerItem, 0, 5, 1, 1)\n        self.label = QtGui.QLabel(self.exceptionGroup)\n        self.label.setObjectName(""label"")\n        self.gridLayout_2.addWidget(self.label, 0, 2, 1, 1)\n        self.filterText = QtGui.QLineEdit(self.exceptionGroup)\n        self.filterText.setObjectName(""filterText"")\n        self.gridLayout_2.addWidget(self.filterText, 0, 3, 1, 1)\n        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtGui.QApplication.translate(""Form"", ""Console"", None, QtGui.QApplication.UnicodeUTF8))\n        self.historyBtn.setText(QtGui.QApplication.translate(""Form"", ""History.."", None, QtGui.QApplication.UnicodeUTF8))\n        self.exceptionBtn.setText(QtGui.QApplication.translate(""Form"", ""Exceptions.."", None, QtGui.QApplication.UnicodeUTF8))\n        self.exceptionGroup.setTitle(QtGui.QApplication.translate(""Form"", ""Exception Handling"", None, QtGui.QApplication.UnicodeUTF8))\n        self.clearExceptionBtn.setText(QtGui.QApplication.translate(""Form"", ""Clear Stack"", None, QtGui.QApplication.UnicodeUTF8))\n        self.catchAllExceptionsBtn.setText(QtGui.QApplication.translate(""Form"", ""Show All Exceptions"", None, QtGui.QApplication.UnicodeUTF8))\n        self.catchNextExceptionBtn.setText(QtGui.QApplication.translate(""Form"", ""Show Next Exception"", None, QtGui.QApplication.UnicodeUTF8))\n        self.onlyUncaughtCheck.setText(QtGui.QApplication.translate(""Form"", ""Only Uncaught Exceptions"", None, QtGui.QApplication.UnicodeUTF8))\n        self.runSelectedFrameCheck.setText(QtGui.QApplication.translate(""Form"", ""Run commands in selected stack frame"", None, QtGui.QApplication.UnicodeUTF8))\n        self.exceptionInfoLabel.setText(QtGui.QApplication.translate(""Form"", ""Stack Trace"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label.setText(QtGui.QApplication.translate(""Form"", ""Filter (regex):"", None, QtGui.QApplication.UnicodeUTF8))\n\nfrom .CmdInput import CmdInput\n'"
src/third_party/pyqtgraph/console/template_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'template.ui\'\n#\n# Created: Sun Sep 18 19:19:10 2016\n#      by: pyside2-uic  running on PySide2 2.0.0~alpha0\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide2 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(694, 497)\n        self.gridLayout = QtWidgets.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.splitter = QtWidgets.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Vertical)\n        self.splitter.setObjectName(""splitter"")\n        self.layoutWidget = QtWidgets.QWidget(self.splitter)\n        self.layoutWidget.setObjectName(""layoutWidget"")\n        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)\n        self.verticalLayout.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout.setObjectName(""verticalLayout"")\n        self.output = QtWidgets.QPlainTextEdit(self.layoutWidget)\n        font = QtGui.QFont()\n        font.setFamily(""Monospace"")\n        self.output.setFont(font)\n        self.output.setReadOnly(True)\n        self.output.setObjectName(""output"")\n        self.verticalLayout.addWidget(self.output)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.input = CmdInput(self.layoutWidget)\n        self.input.setObjectName(""input"")\n        self.horizontalLayout.addWidget(self.input)\n        self.historyBtn = QtWidgets.QPushButton(self.layoutWidget)\n        self.historyBtn.setCheckable(True)\n        self.historyBtn.setObjectName(""historyBtn"")\n        self.horizontalLayout.addWidget(self.historyBtn)\n        self.exceptionBtn = QtWidgets.QPushButton(self.layoutWidget)\n        self.exceptionBtn.setCheckable(True)\n        self.exceptionBtn.setObjectName(""exceptionBtn"")\n        self.horizontalLayout.addWidget(self.exceptionBtn)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n        self.historyList = QtWidgets.QListWidget(self.splitter)\n        font = QtGui.QFont()\n        font.setFamily(""Monospace"")\n        self.historyList.setFont(font)\n        self.historyList.setObjectName(""historyList"")\n        self.exceptionGroup = QtWidgets.QGroupBox(self.splitter)\n        self.exceptionGroup.setObjectName(""exceptionGroup"")\n        self.gridLayout_2 = QtWidgets.QGridLayout(self.exceptionGroup)\n        self.gridLayout_2.setSpacing(0)\n        self.gridLayout_2.setContentsMargins(-1, 0, -1, 0)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.clearExceptionBtn = QtWidgets.QPushButton(self.exceptionGroup)\n        self.clearExceptionBtn.setEnabled(False)\n        self.clearExceptionBtn.setObjectName(""clearExceptionBtn"")\n        self.gridLayout_2.addWidget(self.clearExceptionBtn, 0, 6, 1, 1)\n        self.catchAllExceptionsBtn = QtWidgets.QPushButton(self.exceptionGroup)\n        self.catchAllExceptionsBtn.setCheckable(True)\n        self.catchAllExceptionsBtn.setObjectName(""catchAllExceptionsBtn"")\n        self.gridLayout_2.addWidget(self.catchAllExceptionsBtn, 0, 1, 1, 1)\n        self.catchNextExceptionBtn = QtWidgets.QPushButton(self.exceptionGroup)\n        self.catchNextExceptionBtn.setCheckable(True)\n        self.catchNextExceptionBtn.setObjectName(""catchNextExceptionBtn"")\n        self.gridLayout_2.addWidget(self.catchNextExceptionBtn, 0, 0, 1, 1)\n        self.onlyUncaughtCheck = QtWidgets.QCheckBox(self.exceptionGroup)\n        self.onlyUncaughtCheck.setChecked(True)\n        self.onlyUncaughtCheck.setObjectName(""onlyUncaughtCheck"")\n        self.gridLayout_2.addWidget(self.onlyUncaughtCheck, 0, 4, 1, 1)\n        self.exceptionStackList = QtWidgets.QListWidget(self.exceptionGroup)\n        self.exceptionStackList.setAlternatingRowColors(True)\n        self.exceptionStackList.setObjectName(""exceptionStackList"")\n        self.gridLayout_2.addWidget(self.exceptionStackList, 2, 0, 1, 7)\n        self.runSelectedFrameCheck = QtWidgets.QCheckBox(self.exceptionGroup)\n        self.runSelectedFrameCheck.setChecked(True)\n        self.runSelectedFrameCheck.setObjectName(""runSelectedFrameCheck"")\n        self.gridLayout_2.addWidget(self.runSelectedFrameCheck, 3, 0, 1, 7)\n        self.exceptionInfoLabel = QtWidgets.QLabel(self.exceptionGroup)\n        self.exceptionInfoLabel.setObjectName(""exceptionInfoLabel"")\n        self.gridLayout_2.addWidget(self.exceptionInfoLabel, 1, 0, 1, 7)\n        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout_2.addItem(spacerItem, 0, 5, 1, 1)\n        self.label = QtWidgets.QLabel(self.exceptionGroup)\n        self.label.setObjectName(""label"")\n        self.gridLayout_2.addWidget(self.label, 0, 2, 1, 1)\n        self.filterText = QtWidgets.QLineEdit(self.exceptionGroup)\n        self.filterText.setObjectName(""filterText"")\n        self.gridLayout_2.addWidget(self.filterText, 0, 3, 1, 1)\n        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtWidgets.QApplication.translate(""Form"", ""Console"", None, -1))\n        self.historyBtn.setText(QtWidgets.QApplication.translate(""Form"", ""History.."", None, -1))\n        self.exceptionBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Exceptions.."", None, -1))\n        self.exceptionGroup.setTitle(QtWidgets.QApplication.translate(""Form"", ""Exception Handling"", None, -1))\n        self.clearExceptionBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Clear Exception"", None, -1))\n        self.catchAllExceptionsBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Show All Exceptions"", None, -1))\n        self.catchNextExceptionBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Show Next Exception"", None, -1))\n        self.onlyUncaughtCheck.setText(QtWidgets.QApplication.translate(""Form"", ""Only Uncaught Exceptions"", None, -1))\n        self.runSelectedFrameCheck.setText(QtWidgets.QApplication.translate(""Form"", ""Run commands in selected stack frame"", None, -1))\n        self.exceptionInfoLabel.setText(QtWidgets.QApplication.translate(""Form"", ""Exception Info"", None, -1))\n        self.label.setText(QtWidgets.QApplication.translate(""Form"", ""Filter (regex):"", None, -1))\n\nfrom .CmdInput import CmdInput\n'"
src/third_party/pyqtgraph/dockarea/Container.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtCore, QtGui\nimport weakref\n\nclass Container(object):\n    #sigStretchChanged = QtCore.Signal()  ## can\'t do this here; not a QObject.\n    \n    def __init__(self, area):\n        object.__init__(self)\n        self.area = area\n        self._container = None\n        self._stretch = (10, 10)\n        self.stretches = weakref.WeakKeyDictionary()\n        \n    def container(self):\n        return self._container\n        \n    def containerChanged(self, c):\n        self._container = c\n        if c is None:\n            self.area = None\n        else:\n            self.area = c.area\n\n    def type(self):\n        return None\n\n    def insert(self, new, pos=None, neighbor=None):\n        if not isinstance(new, list):\n            new = [new]\n        for n in new:\n            # remove from existing parent first\n            n.setParent(None)\n        if neighbor is None:\n            if pos == \'before\':\n                index = 0\n            else:\n                index = self.count()\n        else:\n            index = self.indexOf(neighbor)\n            if index == -1:\n                index = 0\n            if pos == \'after\':\n                index += 1\n                \n        for n in new:\n            #print ""insert"", n, "" -> "", self, index\n            self._insertItem(n, index)\n            #print ""change container"", n, "" -> "", self\n            n.containerChanged(self)\n            index += 1\n            n.sigStretchChanged.connect(self.childStretchChanged)\n        #print ""child added"", self\n        self.updateStretch()\n            \n    def apoptose(self, propagate=True):\n        # if there is only one (or zero) item in this container, disappear.\n        # if propagate is True, then also attempt to apoptose parent containers.\n        cont = self._container\n        c = self.count()\n        if c > 1:\n            return\n        if c == 1:  ## if there is one item, give it to the parent container (unless this is the top)\n            ch = self.widget(0)\n            if (self.area is not None and self is self.area.topContainer and not isinstance(ch, Container)) or self.container() is None:\n                return\n            self.container().insert(ch, \'before\', self)\n        #print ""apoptose:"", self\n        self.close()\n        if propagate and cont is not None:\n            cont.apoptose()\n\n    def close(self):\n        self.setParent(None)\n        if self.area is not None and self.area.topContainer is self:\n            self.area.topContainer = None\n        self.containerChanged(None)\n        \n    def childEvent(self, ev):\n        ch = ev.child()\n        if ev.removed() and hasattr(ch, \'sigStretchChanged\'):\n            #print ""Child"", ev.child(), ""removed, updating"", self\n            try:\n                ch.sigStretchChanged.disconnect(self.childStretchChanged)\n            except:\n                pass\n            self.updateStretch()\n        \n    def childStretchChanged(self):\n        #print ""child"", QtCore.QObject.sender(self), ""changed shape, updating"", self\n        self.updateStretch()\n        \n    def setStretch(self, x=None, y=None):\n        #print ""setStretch"", self, x, y\n        self._stretch = (x, y)\n        self.sigStretchChanged.emit()\n\n    def updateStretch(self):\n        ###Set the stretch values for this container to reflect its contents\n        pass\n        \n    def stretch(self):\n        """"""Return the stretch factors for this container""""""\n        return self._stretch\n            \n\nclass SplitContainer(Container, QtGui.QSplitter):\n    """"""Horizontal or vertical splitter with some changes:\n     - save/restore works correctly\n    """"""\n    sigStretchChanged = QtCore.Signal()\n    \n    def __init__(self, area, orientation):\n        QtGui.QSplitter.__init__(self)\n        self.setOrientation(orientation)\n        Container.__init__(self, area)\n        #self.splitterMoved.connect(self.restretchChildren)\n        \n    def _insertItem(self, item, index):\n        self.insertWidget(index, item)\n        item.show()  ## need to show since it may have been previously hidden by tab\n        \n    def saveState(self):\n        sizes = self.sizes()\n        if all([x == 0 for x in sizes]):\n            sizes = [10] * len(sizes)\n        return {\'sizes\': sizes}\n        \n    def restoreState(self, state):\n        sizes = state[\'sizes\']\n        self.setSizes(sizes)\n        for i in range(len(sizes)):\n            self.setStretchFactor(i, sizes[i])\n\n    def childEvent(self, ev):\n        QtGui.QSplitter.childEvent(self, ev)\n        Container.childEvent(self, ev)\n\n    #def restretchChildren(self):\n        #sizes = self.sizes()\n        #tot = sum(sizes)\n        \n        \n        \n\nclass HContainer(SplitContainer):\n    def __init__(self, area):\n        SplitContainer.__init__(self, area, QtCore.Qt.Horizontal)\n        \n    def type(self):\n        return \'horizontal\'\n        \n    def updateStretch(self):\n        ##Set the stretch values for this container to reflect its contents\n        #print ""updateStretch"", self\n        x = 0\n        y = 0\n        sizes = []\n        for i in range(self.count()):\n            wx, wy = self.widget(i).stretch()\n            x += wx\n            y = max(y, wy)\n            sizes.append(wx)\n            #print ""  child"", self.widget(i), wx, wy\n        self.setStretch(x, y)\n        #print sizes\n        \n        tot = float(sum(sizes))\n        if tot == 0:\n            scale = 1.0\n        else:\n            scale = self.width() / tot\n        self.setSizes([int(s*scale) for s in sizes])\n        \n\n\nclass VContainer(SplitContainer):\n    def __init__(self, area):\n        SplitContainer.__init__(self, area, QtCore.Qt.Vertical)\n        \n    def type(self):\n        return \'vertical\'\n\n    def updateStretch(self):\n        ##Set the stretch values for this container to reflect its contents\n        #print ""updateStretch"", self\n        x = 0\n        y = 0\n        sizes = []\n        for i in range(self.count()):\n            wx, wy = self.widget(i).stretch()\n            y += wy\n            x = max(x, wx)\n            sizes.append(wy)\n            #print ""  child"", self.widget(i), wx, wy\n        self.setStretch(x, y)\n\n        #print sizes\n        tot = float(sum(sizes))\n        if tot == 0:\n            scale = 1.0\n        else:\n            scale = self.height() / tot\n        self.setSizes([int(s*scale) for s in sizes])\n\n\nclass TContainer(Container, QtGui.QWidget):\n    sigStretchChanged = QtCore.Signal()\n    def __init__(self, area):\n        QtGui.QWidget.__init__(self)\n        Container.__init__(self, area)\n        self.layout = QtGui.QGridLayout()\n        self.layout.setSpacing(0)\n        self.layout.setContentsMargins(0,0,0,0)\n        self.setLayout(self.layout)\n        \n        self.hTabLayout = QtGui.QHBoxLayout()\n        self.hTabBox = QtGui.QWidget()\n        self.hTabBox.setLayout(self.hTabLayout)\n        self.hTabLayout.setSpacing(2)\n        self.hTabLayout.setContentsMargins(0,0,0,0)\n        self.layout.addWidget(self.hTabBox, 0, 1)\n\n        self.stack = QtGui.QStackedWidget()\n        self.layout.addWidget(self.stack, 1, 1)\n        self.stack.childEvent = self.stackChildEvent\n\n\n        self.setLayout(self.layout)\n        for n in [\'count\', \'widget\', \'indexOf\']:\n            setattr(self, n, getattr(self.stack, n))\n\n\n    def _insertItem(self, item, index):\n        if not isinstance(item, Dock.Dock):\n            raise Exception(""Tab containers may hold only docks, not other containers."")\n        self.stack.insertWidget(index, item)\n        self.hTabLayout.insertWidget(index, item.label)\n        #QtCore.QObject.connect(item.label, QtCore.SIGNAL(\'clicked\'), self.tabClicked)\n        item.label.sigClicked.connect(self.tabClicked)\n        self.tabClicked(item.label)\n        \n    def tabClicked(self, tab, ev=None):\n        if ev is None or ev.button() == QtCore.Qt.LeftButton:\n            for i in range(self.count()):\n                w = self.widget(i)\n                if w is tab.dock:\n                    w.label.setDim(False)\n                    self.stack.setCurrentIndex(i)\n                else:\n                    w.label.setDim(True)\n        \n    def raiseDock(self, dock):\n        """"""Move *dock* to the top of the stack""""""\n        self.stack.currentWidget().label.setDim(True)\n        self.stack.setCurrentWidget(dock)\n        dock.label.setDim(False)\n        \n        \n    def type(self):\n        return \'tab\'\n\n    def saveState(self):\n        return {\'index\': self.stack.currentIndex()}\n        \n    def restoreState(self, state):\n        self.stack.setCurrentIndex(state[\'index\'])\n        \n    def updateStretch(self):\n        ##Set the stretch values for this container to reflect its contents\n        x = 0\n        y = 0\n        for i in range(self.count()):\n            wx, wy = self.widget(i).stretch()\n            x = max(x, wx)\n            y = max(y, wy)\n        self.setStretch(x, y)\n        \n    def stackChildEvent(self, ev):\n        QtGui.QStackedWidget.childEvent(self.stack, ev)\n        Container.childEvent(self, ev)\n        \nfrom . import Dock\n'"
src/third_party/pyqtgraph/dockarea/Dock.py,0,"b'from ..Qt import QtCore, QtGui\n\nfrom .DockDrop import *\nfrom ..widgets.VerticalLabel import VerticalLabel\nfrom ..python2_3 import asUnicode\n\nclass Dock(QtGui.QWidget, DockDrop):\n    \n    sigStretchChanged = QtCore.Signal()\n    sigClosed = QtCore.Signal(object)\n    \n    def __init__(self, name, area=None, size=(10, 10), widget=None, hideTitle=False, autoOrientation=True, closable=False):\n        QtGui.QWidget.__init__(self)\n        DockDrop.__init__(self)\n        self._container = None\n        self._name = name\n        self.area = area\n        self.label = DockLabel(name, self, closable)\n        if closable:\n            self.label.sigCloseClicked.connect(self.close)\n        self.labelHidden = False\n        self.moveLabel = True  ## If false, the dock is no longer allowed to move the label.\n        self.autoOrient = autoOrientation\n        self.orientation = \'horizontal\'\n        #self.label.setAlignment(QtCore.Qt.AlignHCenter)\n        self.topLayout = QtGui.QGridLayout()\n        self.topLayout.setContentsMargins(0, 0, 0, 0)\n        self.topLayout.setSpacing(0)\n        self.setLayout(self.topLayout)\n        self.topLayout.addWidget(self.label, 0, 1)\n        self.widgetArea = QtGui.QWidget()\n        self.topLayout.addWidget(self.widgetArea, 1, 1)\n        self.layout = QtGui.QGridLayout()\n        self.layout.setContentsMargins(0, 0, 0, 0)\n        self.layout.setSpacing(0)\n        self.widgetArea.setLayout(self.layout)\n        self.widgetArea.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)\n        self.widgets = []\n        self._container = None\n        self.currentRow = 0\n        #self.titlePos = \'top\'\n        self.raiseOverlay()\n        self.hStyle = """"""\n        Dock > QWidget {\n            border: 1px solid #000;\n            border-radius: 5px;\n            border-top-left-radius: 0px;\n            border-top-right-radius: 0px;\n            border-top-width: 0px;\n        }""""""\n        self.vStyle = """"""\n        Dock > QWidget {\n            border: 1px solid #000;\n            border-radius: 5px;\n            border-top-left-radius: 0px;\n            border-bottom-left-radius: 0px;\n            border-left-width: 0px;\n        }""""""\n        self.nStyle = """"""\n        Dock > QWidget {\n            border: 1px solid #000;\n            border-radius: 5px;\n        }""""""\n        self.dragStyle = """"""\n        Dock > QWidget {\n            border: 4px solid #00F;\n            border-radius: 5px;\n        }""""""\n        self.setAutoFillBackground(False)\n        self.widgetArea.setStyleSheet(self.hStyle)\n        \n        self.setStretch(*size)\n        \n        if widget is not None:\n            self.addWidget(widget)\n\n        if hideTitle:\n            self.hideTitleBar()\n\n    def implements(self, name=None):\n        if name is None:\n            return [\'dock\']\n        else:\n            return name == \'dock\'\n        \n    def setStretch(self, x=None, y=None):\n        """"""\n        Set the \'target\' size for this Dock.\n        The actual size will be determined by comparing this Dock\'s\n        stretch value to the rest of the docks it shares space with.\n        """"""\n        #print ""setStretch"", self, x, y\n        #self._stretch = (x, y)\n        if x is None:\n            x = 0\n        if y is None:\n            y = 0\n        #policy = self.sizePolicy()\n        #policy.setHorizontalStretch(x)\n        #policy.setVerticalStretch(y)\n        #self.setSizePolicy(policy)\n        self._stretch = (x, y)\n        self.sigStretchChanged.emit()\n        #print ""setStretch"", self, x, y, self.stretch()\n        \n    def stretch(self):\n        #policy = self.sizePolicy()\n        #return policy.horizontalStretch(), policy.verticalStretch()\n        return self._stretch\n        \n    #def stretch(self):\n        #return self._stretch\n\n    def hideTitleBar(self):\n        """"""\n        Hide the title bar for this Dock.\n        This will prevent the Dock being moved by the user.\n        """"""\n        self.label.hide()\n        self.labelHidden = True\n        if \'center\' in self.allowedAreas:\n            self.allowedAreas.remove(\'center\')\n        self.updateStyle()\n        \n    def showTitleBar(self):\n        """"""\n        Show the title bar for this Dock.\n        """"""\n        self.label.show()\n        self.labelHidden = False\n        self.allowedAreas.add(\'center\')\n        self.updateStyle()\n\n    def title(self):\n        """"""\n        Gets the text displayed in the title bar for this dock.\n        """"""\n        return asUnicode(self.label.text())\n\n    def setTitle(self, text):\n        """"""\n        Sets the text displayed in title bar for this Dock.\n        """"""\n        self.label.setText(text)\n        \n    def setOrientation(self, o=\'auto\', force=False):\n        """"""\n        Sets the orientation of the title bar for this Dock.\n        Must be one of \'auto\', \'horizontal\', or \'vertical\'.\n        By default (\'auto\'), the orientation is determined\n        based on the aspect ratio of the Dock.\n        """"""\n        #print self.name(), ""setOrientation"", o, force\n        if o == \'auto\' and self.autoOrient:\n            if self.container().type() == \'tab\':\n                o = \'horizontal\'\n            elif self.width() > self.height()*1.5:\n                o = \'vertical\'\n            else:\n                o = \'horizontal\'\n        if force or self.orientation != o:\n            self.orientation = o\n            self.label.setOrientation(o)\n            self.updateStyle()\n        \n    def updateStyle(self):\n        ## updates orientation and appearance of title bar\n        #print self.name(), ""update style:"", self.orientation, self.moveLabel, self.label.isVisible()\n        if self.labelHidden:\n            self.widgetArea.setStyleSheet(self.nStyle)\n        elif self.orientation == \'vertical\':\n            self.label.setOrientation(\'vertical\')\n            if self.moveLabel:\n                #print self.name(), ""reclaim label""\n                self.topLayout.addWidget(self.label, 1, 0)\n            self.widgetArea.setStyleSheet(self.vStyle)\n        else:\n            self.label.setOrientation(\'horizontal\')\n            if self.moveLabel:\n                #print self.name(), ""reclaim label""\n                self.topLayout.addWidget(self.label, 0, 1)\n            self.widgetArea.setStyleSheet(self.hStyle)\n\n    def resizeEvent(self, ev):\n        self.setOrientation()\n        self.resizeOverlay(self.size())\n\n    def name(self):\n        return self._name\n\n    def addWidget(self, widget, row=None, col=0, rowspan=1, colspan=1):\n        """"""\n        Add a new widget to the interior of this Dock.\n        Each Dock uses a QGridLayout to arrange widgets within.\n        """"""\n        if row is None:\n            row = self.currentRow\n        self.currentRow = max(row+1, self.currentRow)\n        self.widgets.append(widget)\n        self.layout.addWidget(widget, row, col, rowspan, colspan)\n        self.raiseOverlay()\n        \n    def startDrag(self):\n        self.drag = QtGui.QDrag(self)\n        mime = QtCore.QMimeData()\n        #mime.setPlainText(""asd"")\n        self.drag.setMimeData(mime)\n        self.widgetArea.setStyleSheet(self.dragStyle)\n        self.update()\n        action = self.drag.exec_()\n        self.updateStyle()\n        \n    def float(self):\n        self.area.floatDock(self)\n            \n    def container(self):\n        return self._container\n\n    def containerChanged(self, c):\n        if self._container is not None:\n            # ask old container to close itself if it is no longer needed\n            self._container.apoptose()\n        #print self.name(), ""container changed""\n        self._container = c\n        if c is None:\n            self.area = None\n        else:\n            self.area = c.area\n            if c.type() != \'tab\':\n                self.moveLabel = True\n                self.label.setDim(False)\n            else:\n                self.moveLabel = False\n                \n            self.setOrientation(force=True)\n\n    def raiseDock(self):\n        """"""If this Dock is stacked underneath others, raise it to the top.""""""\n        self.container().raiseDock(self)\n\n    def close(self):\n        """"""Remove this dock from the DockArea it lives inside.""""""\n        self.setParent(None)\n        self.label.setParent(None)\n        self._container.apoptose()\n        self._container = None\n        self.sigClosed.emit(self)\n\n    def __repr__(self):\n        return ""<Dock %s %s>"" % (self.name(), self.stretch())\n\n    ## PySide bug: We need to explicitly redefine these methods\n    ## or else drag/drop events will not be delivered.\n    def dragEnterEvent(self, *args):\n        DockDrop.dragEnterEvent(self, *args)\n\n    def dragMoveEvent(self, *args):\n        DockDrop.dragMoveEvent(self, *args)\n\n    def dragLeaveEvent(self, *args):\n        DockDrop.dragLeaveEvent(self, *args)\n\n    def dropEvent(self, *args):\n        DockDrop.dropEvent(self, *args)\n\n\nclass DockLabel(VerticalLabel):\n    \n    sigClicked = QtCore.Signal(object, object)\n    sigCloseClicked = QtCore.Signal()\n    \n    def __init__(self, text, dock, showCloseButton):\n        self.dim = False\n        self.fixedWidth = False\n        VerticalLabel.__init__(self, text, orientation=\'horizontal\', forceWidth=False)\n        self.setAlignment(QtCore.Qt.AlignTop|QtCore.Qt.AlignHCenter)\n        self.dock = dock\n        self.updateStyle()\n        self.setAutoFillBackground(False)\n        self.startedDrag = False\n\n        self.closeButton = None\n        if showCloseButton:\n            self.closeButton = QtGui.QToolButton(self)\n            self.closeButton.clicked.connect(self.sigCloseClicked)\n            self.closeButton.setIcon(QtGui.QApplication.style().standardIcon(QtGui.QStyle.SP_TitleBarCloseButton))\n\n    def updateStyle(self):\n        r = \'3px\'\n        if self.dim:\n            fg = \'#aaa\'\n            bg = \'#44a\'\n            border = \'#339\'\n        else:\n            fg = \'#fff\'\n            bg = \'#66c\'\n            border = \'#55B\'\n        \n        if self.orientation == \'vertical\':\n            self.vStyle = """"""DockLabel {\n                background-color : %s;\n                color : %s;\n                border-top-right-radius: 0px;\n                border-top-left-radius: %s;\n                border-bottom-right-radius: 0px;\n                border-bottom-left-radius: %s;\n                border-width: 0px;\n                border-right: 2px solid %s;\n                padding-top: 3px;\n                padding-bottom: 3px;\n            }"""""" % (bg, fg, r, r, border)\n            self.setStyleSheet(self.vStyle)\n        else:\n            self.hStyle = """"""DockLabel {\n                background-color : %s;\n                color : %s;\n                border-top-right-radius: %s;\n                border-top-left-radius: %s;\n                border-bottom-right-radius: 0px;\n                border-bottom-left-radius: 0px;\n                border-width: 0px;\n                border-bottom: 2px solid %s;\n                padding-left: 3px;\n                padding-right: 3px;\n            }"""""" % (bg, fg, r, r, border)\n            self.setStyleSheet(self.hStyle)\n\n    def setDim(self, d):\n        if self.dim != d:\n            self.dim = d\n            self.updateStyle()\n    \n    def setOrientation(self, o):\n        VerticalLabel.setOrientation(self, o)\n        self.updateStyle()\n\n    def mousePressEvent(self, ev):\n        if ev.button() == QtCore.Qt.LeftButton:\n            self.pressPos = ev.pos()\n            self.startedDrag = False\n            ev.accept()\n        \n    def mouseMoveEvent(self, ev):\n        if not self.startedDrag and (ev.pos() - self.pressPos).manhattanLength() > QtGui.QApplication.startDragDistance():\n            self.dock.startDrag()\n        ev.accept()\n            \n    def mouseReleaseEvent(self, ev):\n        if not self.startedDrag:\n            self.sigClicked.emit(self, ev)\n        ev.accept()\n        \n    def mouseDoubleClickEvent(self, ev):\n        if ev.button() == QtCore.Qt.LeftButton:\n            self.dock.float()\n            \n    def resizeEvent (self, ev):\n        if self.closeButton:\n            if self.orientation == \'vertical\':\n                size = ev.size().width()\n                pos = QtCore.QPoint(0, 0)\n            else:\n                size = ev.size().height()\n                pos = QtCore.QPoint(ev.size().width() - size, 0)\n            self.closeButton.setFixedSize(QtCore.QSize(size, size))\n            self.closeButton.move(pos)\n        super(DockLabel,self).resizeEvent(ev)\n'"
src/third_party/pyqtgraph/dockarea/DockArea.py,0,"b'# -*- coding: utf-8 -*-\nimport weakref\nfrom ..Qt import QtCore, QtGui\nfrom .Container import *\nfrom .DockDrop import *\nfrom .Dock import Dock\nfrom .. import debug as debug\nfrom ..python2_3 import basestring\n\n\nclass DockArea(Container, QtGui.QWidget, DockDrop):\n    def __init__(self, temporary=False, home=None):\n        Container.__init__(self, self)\n        QtGui.QWidget.__init__(self)\n        DockDrop.__init__(self, allowedAreas=[\'left\', \'right\', \'top\', \'bottom\'])\n        self.layout = QtGui.QVBoxLayout()\n        self.layout.setContentsMargins(0,0,0,0)\n        self.layout.setSpacing(0)\n        self.setLayout(self.layout)\n        self.docks = weakref.WeakValueDictionary()\n        self.topContainer = None\n        self.raiseOverlay()\n        self.temporary = temporary\n        self.tempAreas = []\n        self.home = home\n        \n    def type(self):\n        return ""top""\n        \n    def addDock(self, dock=None, position=\'bottom\', relativeTo=None, **kwds):\n        """"""Adds a dock to this area.\n        \n        ============== =================================================================\n        **Arguments:**\n        dock           The new Dock object to add. If None, then a new Dock will be \n                       created.\n        position       \'bottom\', \'top\', \'left\', \'right\', \'above\', or \'below\'\n        relativeTo     If relativeTo is None, then the new Dock is added to fill an \n                       entire edge of the window. If relativeTo is another Dock, then \n                       the new Dock is placed adjacent to it (or in a tabbed \n                       configuration for \'above\' and \'below\'). \n        ============== =================================================================\n        \n        All extra keyword arguments are passed to Dock.__init__() if *dock* is\n        None.        \n        """"""\n        if dock is None:\n            dock = Dock(**kwds)\n            \n        # store original area that the dock will return to when un-floated\n        if not self.temporary:\n            dock.orig_area = self\n        \n        \n        ## Determine the container to insert this dock into.\n        ## If there is no neighbor, then the container is the top.\n        if relativeTo is None or relativeTo is self:\n            if self.topContainer is None:\n                container = self\n                neighbor = None\n            else:\n                container = self.topContainer\n                neighbor = None\n        else:\n            if isinstance(relativeTo, basestring):\n                relativeTo = self.docks[relativeTo]\n            container = self.getContainer(relativeTo)\n            if container is None:\n                raise TypeError(""Dock %s is not contained in a DockArea; cannot add another dock relative to it."" % relativeTo)\n            neighbor = relativeTo\n        \n        ## what container type do we need?\n        neededContainer = {\n            \'bottom\': \'vertical\',\n            \'top\': \'vertical\',\n            \'left\': \'horizontal\',\n            \'right\': \'horizontal\',\n            \'above\': \'tab\',\n            \'below\': \'tab\'\n        }[position]\n        \n        ## Can\'t insert new containers into a tab container; insert outside instead.\n        if neededContainer != container.type() and container.type() == \'tab\':\n            neighbor = container\n            container = container.container()\n            \n        ## Decide if the container we have is suitable.\n        ## If not, insert a new container inside.\n        if neededContainer != container.type():\n            if neighbor is None:\n                container = self.addContainer(neededContainer, self.topContainer)\n            else:\n                container = self.addContainer(neededContainer, neighbor)\n            \n        ## Insert the new dock before/after its neighbor\n        insertPos = {\n            \'bottom\': \'after\',\n            \'top\': \'before\',\n            \'left\': \'before\',\n            \'right\': \'after\',\n            \'above\': \'before\',\n            \'below\': \'after\'\n        }[position]\n        #print ""request insert"", dock, insertPos, neighbor\n        old = dock.container()\n        container.insert(dock, insertPos, neighbor)\n        self.docks[dock.name()] = dock\n        if old is not None:\n            old.apoptose()\n        \n        return dock\n        \n    def moveDock(self, dock, position, neighbor):\n        """"""\n        Move an existing Dock to a new location. \n        """"""\n        ## Moving to the edge of a tabbed dock causes a drop outside the tab box\n        if position in [\'left\', \'right\', \'top\', \'bottom\'] and neighbor is not None and neighbor.container() is not None and neighbor.container().type() == \'tab\':\n            neighbor = neighbor.container()\n        self.addDock(dock, position, neighbor)\n        \n    def getContainer(self, obj):\n        if obj is None:\n            return self\n        return obj.container()\n        \n    def makeContainer(self, typ):\n        if typ == \'vertical\':\n            new = VContainer(self)\n        elif typ == \'horizontal\':\n            new = HContainer(self)\n        elif typ == \'tab\':\n            new = TContainer(self)\n        return new\n        \n    def addContainer(self, typ, obj):\n        """"""Add a new container around obj""""""\n        new = self.makeContainer(typ)\n        \n        container = self.getContainer(obj)\n        container.insert(new, \'before\', obj)\n        #print ""Add container:"", new, "" -> "", container\n        if obj is not None:\n            new.insert(obj)\n        self.raiseOverlay()\n        return new\n    \n    def insert(self, new, pos=None, neighbor=None):\n        if self.topContainer is not None:\n            # Adding new top-level container; addContainer() should\n            # take care of giving the old top container a new home.\n            self.topContainer.containerChanged(None)\n        self.layout.addWidget(new)\n        new.containerChanged(self)\n        self.topContainer = new\n        self.raiseOverlay()\n        \n    def count(self):\n        if self.topContainer is None:\n            return 0\n        return 1\n        \n    def resizeEvent(self, ev):\n        self.resizeOverlay(self.size())\n        \n    def addTempArea(self):\n        if self.home is None:\n            area = DockArea(temporary=True, home=self)\n            self.tempAreas.append(area)\n            win = TempAreaWindow(area)\n            area.win = win\n            win.show()\n        else:\n            area = self.home.addTempArea()\n        #print ""added temp area"", area, area.window()\n        return area\n        \n    def floatDock(self, dock):\n        """"""Removes *dock* from this DockArea and places it in a new window.""""""\n        area = self.addTempArea()\n        area.win.resize(dock.size())\n        area.moveDock(dock, \'top\', None)\n        \n    def removeTempArea(self, area):\n        self.tempAreas.remove(area)\n        #print ""close window"", area.window()\n        area.window().close()\n        \n    def saveState(self):\n        """"""\n        Return a serialized (storable) representation of the state of\n        all Docks in this DockArea.""""""\n\n        if self.topContainer is None:\n            main = None\n        else:\n            main = self.childState(self.topContainer)\n\n        state = {\'main\': main, \'float\': []}\n        for a in self.tempAreas:\n            geo = a.win.geometry()\n            geo = (geo.x(), geo.y(), geo.width(), geo.height())\n            state[\'float\'].append((a.saveState(), geo))\n        return state\n        \n    def childState(self, obj):\n        if isinstance(obj, Dock):\n            return (\'dock\', obj.name(), {})\n        else:\n            childs = []\n            for i in range(obj.count()):\n                childs.append(self.childState(obj.widget(i)))\n            return (obj.type(), childs, obj.saveState())\n        \n    def restoreState(self, state, missing=\'error\', extra=\'bottom\'):\n        """"""\n        Restore Dock configuration as generated by saveState.\n        \n        This function does not create any Docks--it will only \n        restore the arrangement of an existing set of Docks.\n        \n        By default, docks that are described in *state* but do not exist\n        in the dock area will cause an exception to be raised. This behavior\n        can be changed by setting *missing* to \'ignore\' or \'create\'.\n        \n        Extra docks that are in the dockarea but that are not mentioned in\n        *state* will be added to the bottom of the dockarea, unless otherwise\n        specified by the *extra* argument.\n        """"""\n        \n        ## 1) make dict of all docks and list of existing containers\n        containers, docks = self.findAll()\n        oldTemps = self.tempAreas[:]\n        #print ""found docks:"", docks\n        \n        ## 2) create container structure, move docks into new containers\n        if state[\'main\'] is not None:\n            self.buildFromState(state[\'main\'], docks, self, missing=missing)\n        \n        ## 3) create floating areas, populate\n        for s in state[\'float\']:\n            a = self.addTempArea()\n            a.buildFromState(s[0][\'main\'], docks, a, missing=missing)\n            a.win.setGeometry(*s[1])\n            a.apoptose()  # ask temp area to close itself if it is empty\n        \n        ## 4) Add any remaining docks to a float\n        for d in docks.values():\n            if extra == \'float\':\n                a = self.addTempArea()\n                a.addDock(d, \'below\')\n            else:\n                self.moveDock(d, extra, None)\n        \n        #print ""\\nKill old containers:""\n        ## 5) kill old containers\n        for c in containers:\n            c.close()\n        for a in oldTemps:\n            a.apoptose()\n\n    def buildFromState(self, state, docks, root, depth=0, missing=\'error\'):\n        typ, contents, state = state\n        pfx = ""  "" * depth\n        if typ == \'dock\':\n            try:\n                obj = docks[contents]\n                del docks[contents]\n            except KeyError:\n                if missing == \'error\':\n                    raise Exception(\'Cannot restore dock state; no dock with name ""%s""\' % contents)\n                elif missing == \'create\':\n                    obj = Dock(name=contents)\n                elif missing == \'ignore\':\n                    return\n                else:\n                    raise ValueError(\'""missing"" argument must be one of ""error"", ""create"", or ""ignore"".\')\n\n        else:\n            obj = self.makeContainer(typ)\n            \n        root.insert(obj, \'after\')\n        #print pfx+""Add:"", obj, "" -> "", root\n        \n        if typ != \'dock\':\n            for o in contents:\n                self.buildFromState(o, docks, obj, depth+1, missing=missing)\n            # remove this container if possible. (there are valid situations when a restore will\n            # generate empty containers, such as when using missing=\'ignore\')\n            obj.apoptose(propagate=False)\n            obj.restoreState(state)  ## this has to be done later?     \n\n    def findAll(self, obj=None, c=None, d=None):\n        if obj is None:\n            obj = self.topContainer\n        \n        ## check all temp areas first\n        if c is None:\n            c = []\n            d = {}\n            for a in self.tempAreas:\n                c1, d1 = a.findAll()\n                c.extend(c1)\n                d.update(d1)\n        \n        if isinstance(obj, Dock):\n            d[obj.name()] = obj\n        elif obj is not None:\n            c.append(obj)\n            for i in range(obj.count()):\n                o2 = obj.widget(i)\n                c2, d2 = self.findAll(o2)\n                c.extend(c2)\n                d.update(d2)\n        return (c, d)\n\n    def apoptose(self, propagate=True):\n        # remove top container if possible, close this area if it is temporary.\n        #print ""apoptose area:"", self.temporary, self.topContainer, self.topContainer.count()\n        if self.topContainer is None or self.topContainer.count() == 0:\n            self.topContainer = None\n            if self.temporary:\n                self.home.removeTempArea(self)\n                #self.close()\n                \n    def clear(self):\n        docks = self.findAll()[1]\n        for dock in docks.values():\n            dock.close()\n            \n    ## PySide bug: We need to explicitly redefine these methods\n    ## or else drag/drop events will not be delivered.\n    def dragEnterEvent(self, *args):\n        DockDrop.dragEnterEvent(self, *args)\n\n    def dragMoveEvent(self, *args):\n        DockDrop.dragMoveEvent(self, *args)\n\n    def dragLeaveEvent(self, *args):\n        DockDrop.dragLeaveEvent(self, *args)\n\n    def dropEvent(self, *args):\n        DockDrop.dropEvent(self, *args)\n\n    def printState(self, state=None, name=\'Main\'):\n        # for debugging\n        if state is None:\n            state = self.saveState()\n        print(""=== %s dock area ==="" % name)\n        if state[\'main\'] is None:\n            print(""   (empty)"")\n        else:\n            self._printAreaState(state[\'main\'])\n        for i, float in enumerate(state[\'float\']):\n            self.printState(float[0], name=\'float %d\' % i)\n\n    def _printAreaState(self, area, indent=0):\n        if area[0] == \'dock\':\n            print(""  "" * indent + area[0] + "" "" + str(area[1:]))\n            return\n        else:\n            print(""  "" * indent + area[0])\n            for ch in area[1]:\n                self._printAreaState(ch, indent+1)\n\n\n\nclass TempAreaWindow(QtGui.QWidget):\n    def __init__(self, area, **kwargs):\n        QtGui.QWidget.__init__(self, **kwargs)\n        self.layout = QtGui.QGridLayout()\n        self.setLayout(self.layout)\n        self.layout.setContentsMargins(0, 0, 0, 0)\n        self.dockarea = area\n        self.layout.addWidget(area)\n\n    def closeEvent(self, *args):\n        # restore docks to their original area\n        docks = self.dockarea.findAll()[1]\n        for dock in docks.values():\n            if hasattr(dock, \'orig_area\'):\n                dock.orig_area.addDock(dock, )\n        # clear dock area, and close remaining docks\n        self.dockarea.clear()\n        QtGui.QWidget.closeEvent(self, *args)\n'"
src/third_party/pyqtgraph/dockarea/DockDrop.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtCore, QtGui\n\nclass DockDrop(object):\n    """"""Provides dock-dropping methods""""""\n    def __init__(self, allowedAreas=None):\n        object.__init__(self)\n        if allowedAreas is None:\n            allowedAreas = [\'center\', \'right\', \'left\', \'top\', \'bottom\']\n        self.allowedAreas = set(allowedAreas)\n        self.setAcceptDrops(True)\n        self.dropArea = None\n        self.overlay = DropAreaOverlay(self)\n        self.overlay.raise_()\n    \n    def resizeOverlay(self, size):\n        self.overlay.resize(size)\n        \n    def raiseOverlay(self):\n        self.overlay.raise_()\n    \n    def dragEnterEvent(self, ev):\n        src = ev.source()\n        if hasattr(src, \'implements\') and src.implements(\'dock\'):\n            #print ""drag enter accept""\n            ev.accept()\n        else:\n            #print ""drag enter ignore""\n            ev.ignore()\n        \n    def dragMoveEvent(self, ev):\n        #print ""drag move""\n        ld = ev.pos().x()\n        rd = self.width() - ld\n        td = ev.pos().y()\n        bd = self.height() - td\n        \n        mn = min(ld, rd, td, bd)\n        if mn > 30:\n            self.dropArea = ""center""\n        elif (ld == mn or td == mn) and mn > self.height()/3.:\n            self.dropArea = ""center""\n        elif (rd == mn or ld == mn) and mn > self.width()/3.:\n            self.dropArea = ""center""\n            \n        elif rd == mn:\n            self.dropArea = ""right""\n        elif ld == mn:\n            self.dropArea = ""left""\n        elif td == mn:\n            self.dropArea = ""top""\n        elif bd == mn:\n            self.dropArea = ""bottom""\n            \n        if ev.source() is self and self.dropArea == \'center\':\n            #print ""  no self-center""\n            self.dropArea = None\n            ev.ignore()\n        elif self.dropArea not in self.allowedAreas:\n            #print ""  not allowed""\n            self.dropArea = None\n            ev.ignore()\n        else:\n            #print ""  ok""\n            ev.accept()\n        self.overlay.setDropArea(self.dropArea)\n            \n    def dragLeaveEvent(self, ev):\n        self.dropArea = None\n        self.overlay.setDropArea(self.dropArea)\n    \n    def dropEvent(self, ev):\n        area = self.dropArea\n        if area is None:\n            return\n        if area == \'center\':\n            area = \'above\'\n        self.area.moveDock(ev.source(), area, self)\n        self.dropArea = None\n        self.overlay.setDropArea(self.dropArea)\n\n        \n\nclass DropAreaOverlay(QtGui.QWidget):\n    """"""Overlay widget that draws drop areas during a drag-drop operation""""""\n    \n    def __init__(self, parent):\n        QtGui.QWidget.__init__(self, parent)\n        self.dropArea = None\n        self.hide()\n        self.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents)\n        \n    def setDropArea(self, area):\n        self.dropArea = area\n        if area is None:\n            self.hide()\n        else:\n            ## Resize overlay to just the region where drop area should be displayed.\n            ## This works around a Qt bug--can\'t display transparent widgets over QGLWidget\n            prgn = self.parent().rect()\n            rgn = QtCore.QRect(prgn)\n            w = min(30, prgn.width()/3.)\n            h = min(30, prgn.height()/3.)\n            \n            if self.dropArea == \'left\':\n                rgn.setWidth(w)\n            elif self.dropArea == \'right\':\n                rgn.setLeft(rgn.left() + prgn.width() - w)\n            elif self.dropArea == \'top\':\n                rgn.setHeight(h)\n            elif self.dropArea == \'bottom\':\n                rgn.setTop(rgn.top() + prgn.height() - h)\n            elif self.dropArea == \'center\':\n                rgn.adjust(w, h, -w, -h)\n            self.setGeometry(rgn)\n            self.show()\n\n        self.update()\n    \n    def paintEvent(self, ev):\n        if self.dropArea is None:\n            return\n        p = QtGui.QPainter(self)\n        rgn = self.rect()\n\n        p.setBrush(QtGui.QBrush(QtGui.QColor(100, 100, 255, 50)))\n        p.setPen(QtGui.QPen(QtGui.QColor(50, 50, 150), 3))\n        p.drawRect(rgn)\n'"
src/third_party/pyqtgraph/dockarea/__init__.py,0,b'from .DockArea import DockArea\nfrom .Dock import Dock'
src/third_party/pyqtgraph/exporters/CSVExporter.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .Exporter import Exporter\nfrom ..parametertree import Parameter\nfrom .. import PlotItem\n\n__all__ = [\'CSVExporter\']\n    \n    \nclass CSVExporter(Exporter):\n    Name = ""CSV from plot data""\n    windows = []\n    def __init__(self, item):\n        Exporter.__init__(self, item)\n        self.params = Parameter(name=\'params\', type=\'group\', children=[\n            {\'name\': \'separator\', \'type\': \'list\', \'value\': \'comma\', \'values\': [\'comma\', \'tab\']},\n            {\'name\': \'precision\', \'type\': \'int\', \'value\': 10, \'limits\': [0, None]},\n            {\'name\': \'columnMode\', \'type\': \'list\', \'values\': [\'(x,y) per plot\', \'(x,y,y,y) for all plots\']}\n        ])\n        \n    def parameters(self):\n        return self.params\n    \n    def export(self, fileName=None):\n        \n        if not isinstance(self.item, PlotItem):\n            raise Exception(""Must have a PlotItem selected for CSV export."")\n        \n        if fileName is None:\n            self.fileSaveDialog(filter=[""*.csv"", ""*.tsv""])\n            return\n\n        fd = open(fileName, \'w\')\n        data = []\n        header = []\n\n        appendAllX = self.params[\'columnMode\'] == \'(x,y) per plot\'\n\n        for i, c in enumerate(self.item.curves):\n            cd = c.getData()\n            if cd[0] is None:\n                continue\n            data.append(cd)\n            if hasattr(c, \'implements\') and c.implements(\'plotData\') and c.name() is not None:\n                name = c.name().replace(\'""\', \'""""\') + \'_\'\n                xName, yName = \'""\'+name+\'x""\', \'""\'+name+\'y""\'\n            else:\n                xName = \'x%04d\' % i\n                yName = \'y%04d\' % i\n            if appendAllX or i == 0:\n                header.extend([xName, yName])\n            else:\n                header.extend([yName])\n\n        if self.params[\'separator\'] == \'comma\':\n            sep = \',\'\n        else:\n            sep = \'\\t\'\n            \n        fd.write(sep.join(header) + \'\\n\')\n        i = 0\n        numFormat = \'%%0.%dg\' % self.params[\'precision\']\n        numRows = max([len(d[0]) for d in data])\n        for i in range(numRows):\n            for j, d in enumerate(data):\n                # write x value if this is the first column, or if we want x \n                # for all rows\n                if appendAllX or j == 0:\n                    if d is not None and i < len(d[0]):\n                        fd.write(numFormat % d[0][i] + sep)\n                    else:\n                        fd.write(\' %s\' % sep)\n                \n                # write y value \n                if d is not None and i < len(d[1]):\n                    fd.write(numFormat % d[1][i] + sep)\n                else:\n                    fd.write(\' %s\' % sep)\n            fd.write(\'\\n\')\n        fd.close()\n\nCSVExporter.register()        \n                \n        \n'"
src/third_party/pyqtgraph/exporters/Exporter.py,0,"b'from ..widgets.FileDialog import FileDialog\nfrom ..Qt import QtGui, QtCore, QtSvg\nfrom ..python2_3 import asUnicode, basestring\nfrom ..GraphicsScene import GraphicsScene\nimport os, re\nLastExportDirectory = None\n\n\nclass Exporter(object):\n    """"""\n    Abstract class used for exporting graphics to file / printer / whatever.\n    """"""    \n    allowCopy = False  # subclasses set this to True if they can use the copy buffer\n    Exporters = []\n    \n    @classmethod\n    def register(cls):\n        """"""\n        Used to register Exporter classes to appear in the export dialog.\n        """"""\n        Exporter.Exporters.append(cls)\n    \n    def __init__(self, item):\n        """"""\n        Initialize with the item to be exported.\n        Can be an individual graphics item or a scene.\n        """"""\n        object.__init__(self)\n        self.item = item\n        \n    def parameters(self):\n        """"""Return the parameters used to configure this exporter.""""""\n        raise Exception(""Abstract method must be overridden in subclass."")\n        \n    def export(self, fileName=None, toBytes=False, copy=False):\n        """"""\n        If *fileName* is None, pop-up a file dialog.\n        If *toBytes* is True, return a bytes object rather than writing to file.\n        If *copy* is True, export to the copy buffer rather than writing to file.\n        """"""\n        raise Exception(""Abstract method must be overridden in subclass."")\n\n    def fileSaveDialog(self, filter=None, opts=None):\n        ## Show a file dialog, call self.export(fileName) when finished.\n        if opts is None:\n            opts = {}\n        self.fileDialog = FileDialog()\n        self.fileDialog.setFileMode(QtGui.QFileDialog.AnyFile)\n        self.fileDialog.setAcceptMode(QtGui.QFileDialog.AcceptSave)\n        if filter is not None:\n            if isinstance(filter, basestring):\n                self.fileDialog.setNameFilter(filter)\n            elif isinstance(filter, list):\n                self.fileDialog.setNameFilters(filter)\n        global LastExportDirectory\n        exportDir = LastExportDirectory\n        if exportDir is not None:\n            self.fileDialog.setDirectory(exportDir)\n        self.fileDialog.show()\n        self.fileDialog.opts = opts\n        self.fileDialog.fileSelected.connect(self.fileSaveFinished)\n        return\n        \n    def fileSaveFinished(self, fileName):\n        fileName = asUnicode(fileName)\n        global LastExportDirectory\n        LastExportDirectory = os.path.split(fileName)[0]\n        \n        ## If file name does not match selected extension, append it now\n        ext = os.path.splitext(fileName)[1].lower().lstrip(\'.\')\n        selectedExt = re.search(r\'\\*\\.(\\w+)\\b\', asUnicode(self.fileDialog.selectedNameFilter()))\n        if selectedExt is not None:\n            selectedExt = selectedExt.groups()[0].lower()\n            if ext != selectedExt:\n                fileName = fileName + \'.\' + selectedExt.lstrip(\'.\')\n        \n        self.export(fileName=fileName, **self.fileDialog.opts)\n        \n    def getScene(self):\n        if isinstance(self.item, GraphicsScene):\n            return self.item\n        else:\n            return self.item.scene()\n        \n    def getSourceRect(self):\n        if isinstance(self.item, GraphicsScene):\n            w = self.item.getViewWidget()\n            return w.viewportTransform().inverted()[0].mapRect(w.rect())\n        else:\n            return self.item.sceneBoundingRect()\n        \n    def getTargetRect(self):        \n        if isinstance(self.item, GraphicsScene):\n            return self.item.getViewWidget().rect()\n        else:\n            return self.item.mapRectToDevice(self.item.boundingRect())\n        \n    def setExportMode(self, export, opts=None):\n        """"""\n        Call setExportMode(export, opts) on all items that will \n        be painted during the export. This informs the item\n        that it is about to be painted for export, allowing it to \n        alter its appearance temporarily\n        \n        \n        *export*  - bool; must be True before exporting and False afterward\n        *opts*    - dict; common parameters are \'antialias\' and \'background\'\n        """"""\n        if opts is None:\n            opts = {}\n        for item in self.getPaintItems():\n            if hasattr(item, \'setExportMode\'):\n                item.setExportMode(export, opts)\n    \n    def getPaintItems(self, root=None):\n        """"""Return a list of all items that should be painted in the correct order.""""""\n        if root is None:\n            root = self.item\n        preItems = []\n        postItems = []\n        if isinstance(root, QtGui.QGraphicsScene):\n            childs = [i for i in root.items() if i.parentItem() is None]\n            rootItem = []\n        else:\n            childs = root.childItems()\n            rootItem = [root]\n        childs.sort(key=lambda a: a.zValue())\n        while len(childs) > 0:\n            ch = childs.pop(0)\n            tree = self.getPaintItems(ch)\n            if int(ch.flags() & ch.ItemStacksBehindParent) > 0 or (ch.zValue() < 0 and int(ch.flags() & ch.ItemNegativeZStacksBehindParent) > 0):\n                preItems.extend(tree)\n            else:\n                postItems.extend(tree)\n                \n        return preItems + rootItem + postItems\n\n    def render(self, painter, targetRect, sourceRect, item=None):\n        self.getScene().render(painter, QtCore.QRectF(targetRect), QtCore.QRectF(sourceRect))\n'"
src/third_party/pyqtgraph/exporters/HDF5Exporter.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .Exporter import Exporter\nfrom ..parametertree import Parameter\nfrom .. import PlotItem\n\nimport numpy \ntry:\n    import h5py\n    HAVE_HDF5 = True\nexcept ImportError:\n    HAVE_HDF5 = False\n    \n__all__ = [\'HDF5Exporter\']\n\n    \nclass HDF5Exporter(Exporter):\n    Name = ""HDF5 Export: plot (x,y)""\n    windows = []\n    allowCopy = False\n\n    def __init__(self, item):\n        Exporter.__init__(self, item)\n        self.params = Parameter(name=\'params\', type=\'group\', children=[\n            {\'name\': \'Name\', \'type\': \'str\', \'value\': \'Export\',},\n            {\'name\': \'columnMode\', \'type\': \'list\', \'values\': [\'(x,y) per plot\', \'(x,y,y,y) for all plots\']},\n        ])\n        \n    def parameters(self):\n        return self.params\n    \n    def export(self, fileName=None):\n        if not HAVE_HDF5:\n            raise RuntimeError(""This exporter requires the h5py package, ""\n                               ""but it was not importable."")\n        \n        if not isinstance(self.item, PlotItem):\n            raise Exception(""Must have a PlotItem selected for HDF5 export."")\n        \n        if fileName is None:\n            self.fileSaveDialog(filter=[""*.h5"", ""*.hdf"", ""*.hd5""])\n            return\n        dsname = self.params[\'Name\']\n        fd = h5py.File(fileName, \'a\') # forces append to file... \'w\' doesn\'t seem to ""delete/overwrite""\n        data = []\n\n        appendAllX = self.params[\'columnMode\'] == \'(x,y) per plot\'\n        #print dir(self.item.curves[0])\n        tlen = 0\n        for i, c in enumerate(self.item.curves):\n            d = c.getData()\n            if i > 0 and len(d[0]) != tlen:\n                raise ValueError (""HDF5 Export requires all curves in plot to have same length"")\n            if appendAllX or i == 0:\n                data.append(d[0])\n                tlen = len(d[0])\n            data.append(d[1])\n\n\n        fdata = numpy.array(data).astype(\'double\')\n        dset = fd.create_dataset(dsname, data=fdata)\n        fd.close()\n\nif HAVE_HDF5:\n    HDF5Exporter.register()\n'"
src/third_party/pyqtgraph/exporters/ImageExporter.py,2,"b'from .Exporter import Exporter\nfrom ..parametertree import Parameter\nfrom ..Qt import QtGui, QtCore, QtSvg, QT_LIB\nfrom .. import functions as fn\nimport numpy as np\n\n__all__ = [\'ImageExporter\']\n\nclass ImageExporter(Exporter):\n    Name = ""Image File (PNG, TIF, JPG, ...)""\n    allowCopy = True\n    \n    def __init__(self, item):\n        Exporter.__init__(self, item)\n        tr = self.getTargetRect()\n        if isinstance(item, QtGui.QGraphicsItem):\n            scene = item.scene()\n        else:\n            scene = item\n        bgbrush = scene.views()[0].backgroundBrush()\n        bg = bgbrush.color()\n        if bgbrush.style() == QtCore.Qt.NoBrush:\n            bg.setAlpha(0)\n            \n        self.params = Parameter(name=\'params\', type=\'group\', children=[\n            {\'name\': \'width\', \'type\': \'int\', \'value\': int(tr.width()), \'limits\': (0, None)},\n            {\'name\': \'height\', \'type\': \'int\', \'value\': int(tr.height()), \'limits\': (0, None)},\n            {\'name\': \'antialias\', \'type\': \'bool\', \'value\': True},\n            {\'name\': \'background\', \'type\': \'color\', \'value\': bg},\n            {\'name\': \'invertValue\', \'type\': \'bool\', \'value\': False}\n        ])\n        self.params.param(\'width\').sigValueChanged.connect(self.widthChanged)\n        self.params.param(\'height\').sigValueChanged.connect(self.heightChanged)\n        \n    def widthChanged(self):\n        sr = self.getSourceRect()\n        ar = float(sr.height()) / sr.width()\n        self.params.param(\'height\').setValue(int(self.params[\'width\'] * ar), blockSignal=self.heightChanged)\n        \n    def heightChanged(self):\n        sr = self.getSourceRect()\n        ar = float(sr.width()) / sr.height()\n        self.params.param(\'width\').setValue(int(self.params[\'height\'] * ar), blockSignal=self.widthChanged)\n        \n    def parameters(self):\n        return self.params\n    \n    def export(self, fileName=None, toBytes=False, copy=False):\n        if fileName is None and not toBytes and not copy:\n            if QT_LIB in [\'PySide\', \'PySide2\']:\n                filter = [""*.""+str(f) for f in QtGui.QImageWriter.supportedImageFormats()]\n            else:\n                filter = [""*.""+bytes(f).decode(\'utf-8\') for f in QtGui.QImageWriter.supportedImageFormats()]\n            preferred = [\'*.png\', \'*.tif\', \'*.jpg\']\n            for p in preferred[::-1]:\n                if p in filter:\n                    filter.remove(p)\n                    filter.insert(0, p)\n            self.fileSaveDialog(filter=filter)\n            return\n            \n        targetRect = QtCore.QRect(0, 0, self.params[\'width\'], self.params[\'height\'])\n        sourceRect = self.getSourceRect()\n        \n        \n        #self.png = QtGui.QImage(targetRect.size(), QtGui.QImage.Format_ARGB32)\n        #self.png.fill(pyqtgraph.mkColor(self.params[\'background\']))\n        w, h = self.params[\'width\'], self.params[\'height\']\n        if w == 0 or h == 0:\n            raise Exception(""Cannot export image with size=0 (requested export size is %dx%d)"" % (w,h))\n        bg = np.empty((self.params[\'height\'], self.params[\'width\'], 4), dtype=np.ubyte)\n        color = self.params[\'background\']\n        bg[:,:,0] = color.blue()\n        bg[:,:,1] = color.green()\n        bg[:,:,2] = color.red()\n        bg[:,:,3] = color.alpha()\n\n        self.png = fn.makeQImage(bg, alpha=True, copy=False, transpose=False)\n        self.bg = bg\n        \n        ## set resolution of image:\n        origTargetRect = self.getTargetRect()\n        resolutionScale = targetRect.width() / origTargetRect.width()\n        #self.png.setDotsPerMeterX(self.png.dotsPerMeterX() * resolutionScale)\n        #self.png.setDotsPerMeterY(self.png.dotsPerMeterY() * resolutionScale)\n        \n        painter = QtGui.QPainter(self.png)\n        #dtr = painter.deviceTransform()\n        try:\n            self.setExportMode(True, {\'antialias\': self.params[\'antialias\'], \'background\': self.params[\'background\'], \'painter\': painter, \'resolutionScale\': resolutionScale})\n            painter.setRenderHint(QtGui.QPainter.Antialiasing, self.params[\'antialias\'])\n            self.getScene().render(painter, QtCore.QRectF(targetRect), QtCore.QRectF(sourceRect))\n        finally:\n            self.setExportMode(False)\n        painter.end()\n        \n        if self.params[\'invertValue\']:\n            mn = bg[...,:3].min(axis=2)\n            mx = bg[...,:3].max(axis=2)\n            d = (255 - mx) - mn\n            bg[...,:3] += d[...,np.newaxis]\n        \n        if copy:\n            QtGui.QApplication.clipboard().setImage(self.png)\n        elif toBytes:\n            return self.png\n        else:\n            self.png.save(fileName)\n        \nImageExporter.register()        \n        \n'"
src/third_party/pyqtgraph/exporters/Matplotlib.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .Exporter import Exporter\nfrom .. import PlotItem\nfrom .. import functions as fn\n\n__all__ = [\'MatplotlibExporter\']\n\n""""""\nIt is helpful when using the matplotlib Exporter if your\n.matplotlib/matplotlibrc file is configured appropriately.\nThe following are suggested for getting usable PDF output that\ncan be edited in Illustrator, etc.\n\nbackend      : Qt4Agg\ntext.usetex : True  # Assumes you have a findable LaTeX installation\ninteractive : False\nfont.family : sans-serif\nfont.sans-serif : \'Arial\'  # (make first in list)\nmathtext.default : sf\nfigure.facecolor : white  # personal preference\n# next setting allows pdf font to be readable in Adobe Illustrator\npdf.fonttype : 42   # set fonts to TrueType (otherwise it will be 3\n                    # and the text will be vectorized.\ntext.dvipnghack : True  # primarily to clean up font appearance on Mac\n\nThe advantage is that there is less to do to get an exported file cleaned and ready for\npublication. Fonts are not vectorized (outlined), and window colors are white.\n\n""""""\n    \nclass MatplotlibExporter(Exporter):\n    Name = ""Matplotlib Window""\n    windows = []\n    def __init__(self, item):\n        Exporter.__init__(self, item)\n        \n    def parameters(self):\n        return None\n\n    def cleanAxes(self, axl):\n        if type(axl) is not list:\n            axl = [axl]\n        for ax in axl:\n            if ax is None:\n                continue\n            for loc, spine in ax.spines.items():\n                if loc in [\'left\', \'bottom\']:\n                    pass\n                elif loc in [\'right\', \'top\']:\n                    spine.set_color(\'none\')\n                    # do not draw the spine\n                else:\n                    raise ValueError(\'Unknown spine location: %s\' % loc)\n                # turn off ticks when there is no spine\n                ax.xaxis.set_ticks_position(\'bottom\')\n    \n    def export(self, fileName=None):\n        \n        if isinstance(self.item, PlotItem):\n            mpw = MatplotlibWindow()\n            MatplotlibExporter.windows.append(mpw)\n\n            stdFont = \'Arial\'\n            \n            fig = mpw.getFigure()\n            \n            # get labels from the graphic item\n            xlabel = self.item.axes[\'bottom\'][\'item\'].label.toPlainText()\n            ylabel = self.item.axes[\'left\'][\'item\'].label.toPlainText()\n            title = self.item.titleLabel.text\n\n            ax = fig.add_subplot(111, title=title)\n            ax.clear()\n            self.cleanAxes(ax)\n            #ax.grid(True)\n            for item in self.item.curves:\n                x, y = item.getData()\n                opts = item.opts\n                pen = fn.mkPen(opts[\'pen\'])\n                if pen.style() == QtCore.Qt.NoPen:\n                    linestyle = \'\'\n                else:\n                    linestyle = \'-\'\n                color = tuple([c/255. for c in fn.colorTuple(pen.color())])\n                symbol = opts[\'symbol\']\n                if symbol == \'t\':\n                    symbol = \'^\'\n                symbolPen = fn.mkPen(opts[\'symbolPen\'])\n                symbolBrush = fn.mkBrush(opts[\'symbolBrush\'])\n                markeredgecolor = tuple([c/255. for c in fn.colorTuple(symbolPen.color())])\n                markerfacecolor = tuple([c/255. for c in fn.colorTuple(symbolBrush.color())])\n                markersize = opts[\'symbolSize\']\n                \n                if opts[\'fillLevel\'] is not None and opts[\'fillBrush\'] is not None:\n                    fillBrush = fn.mkBrush(opts[\'fillBrush\'])\n                    fillcolor = tuple([c/255. for c in fn.colorTuple(fillBrush.color())])\n                    ax.fill_between(x=x, y1=y, y2=opts[\'fillLevel\'], facecolor=fillcolor)\n                \n                pl = ax.plot(x, y, marker=symbol, color=color, linewidth=pen.width(), \n                        linestyle=linestyle, markeredgecolor=markeredgecolor, markerfacecolor=markerfacecolor,\n                        markersize=markersize)\n                xr, yr = self.item.viewRange()\n                ax.set_xbound(*xr)\n                ax.set_ybound(*yr)\n            ax.set_xlabel(xlabel)  # place the labels.\n            ax.set_ylabel(ylabel)\n            mpw.draw()\n        else:\n            raise Exception(""Matplotlib export currently only works with plot items"")\n                \nMatplotlibExporter.register()        \n        \n\nclass MatplotlibWindow(QtGui.QMainWindow):\n    def __init__(self):\n        from ..widgets import MatplotlibWidget\n        QtGui.QMainWindow.__init__(self)\n        self.mpl = MatplotlibWidget.MatplotlibWidget()\n        self.setCentralWidget(self.mpl)\n        self.show()\n        \n    def __getattr__(self, attr):\n        return getattr(self.mpl, attr)\n        \n    def closeEvent(self, ev):\n        MatplotlibExporter.windows.remove(self)\n\n\n'"
src/third_party/pyqtgraph/exporters/PrintExporter.py,0,"b'from .Exporter import Exporter\nfrom ..parametertree import Parameter\nfrom ..Qt import QtGui, QtCore, QtSvg\nimport re\n\n__all__ = [\'PrintExporter\']  \n#__all__ = []   ## Printer is disabled for now--does not work very well.\n\nclass PrintExporter(Exporter):\n    Name = ""Printer""\n    def __init__(self, item):\n        Exporter.__init__(self, item)\n        tr = self.getTargetRect()\n        self.params = Parameter(name=\'params\', type=\'group\', children=[\n            {\'name\': \'width\', \'type\': \'float\', \'value\': 0.1, \'limits\': (0, None), \'suffix\': \'m\', \'siPrefix\': True},\n            {\'name\': \'height\', \'type\': \'float\', \'value\': (0.1 * tr.height()) / tr.width(), \'limits\': (0, None), \'suffix\': \'m\', \'siPrefix\': True},\n        ])\n        self.params.param(\'width\').sigValueChanged.connect(self.widthChanged)\n        self.params.param(\'height\').sigValueChanged.connect(self.heightChanged)\n\n    def widthChanged(self):\n        sr = self.getSourceRect()\n        ar = sr.height() / sr.width()\n        self.params.param(\'height\').setValue(self.params[\'width\'] * ar, blockSignal=self.heightChanged)\n        \n    def heightChanged(self):\n        sr = self.getSourceRect()\n        ar = sr.width() / sr.height()\n        self.params.param(\'width\').setValue(self.params[\'height\'] * ar, blockSignal=self.widthChanged)\n        \n    def parameters(self):\n        return self.params\n    \n    def export(self, fileName=None):\n        printer = QtGui.QPrinter(QtGui.QPrinter.HighResolution)\n        dialog = QtGui.QPrintDialog(printer)\n        dialog.setWindowTitle(""Print Document"")\n        if dialog.exec_() != QtGui.QDialog.Accepted:\n            return\n            \n        #dpi = QtGui.QDesktopWidget().physicalDpiX()\n        \n        #self.svg.setSize(QtCore.QSize(100,100))\n        #self.svg.setResolution(600)\n        #res = printer.resolution()\n        sr = self.getSourceRect()\n        #res = sr.width() * .4 / (self.params[\'width\'] * 100 / 2.54)\n        res = QtGui.QDesktopWidget().physicalDpiX()\n        printer.setResolution(res)\n        rect = printer.pageRect()\n        center = rect.center()\n        h = self.params[\'height\'] * res * 100. / 2.54\n        w = self.params[\'width\'] * res * 100. / 2.54\n        x = center.x() - w/2.\n        y = center.y() - h/2.\n        \n        targetRect = QtCore.QRect(x, y, w, h)\n        sourceRect = self.getSourceRect()\n        painter = QtGui.QPainter(printer)\n        try:\n            self.setExportMode(True, {\'painter\': painter})\n            self.getScene().render(painter, QtCore.QRectF(targetRect), QtCore.QRectF(sourceRect))\n        finally:\n            self.setExportMode(False)\n        painter.end()\n\n\n#PrintExporter.register()        \n'"
src/third_party/pyqtgraph/exporters/SVGExporter.py,5,"b'from .Exporter import Exporter\nfrom ..python2_3 import asUnicode\nfrom ..parametertree import Parameter\nfrom ..Qt import QtGui, QtCore, QtSvg, QT_LIB\nfrom .. import debug\nfrom .. import functions as fn\nimport re\nimport xml.dom.minidom as xml\nimport numpy as np\n\n\n__all__ = [\'SVGExporter\']\n\nclass SVGExporter(Exporter):\n    Name = ""Scalable Vector Graphics (SVG)""\n    allowCopy=True\n    \n    def __init__(self, item):\n        Exporter.__init__(self, item)\n        #tr = self.getTargetRect()\n        self.params = Parameter(name=\'params\', type=\'group\', children=[\n            #{\'name\': \'width\', \'type\': \'float\', \'value\': tr.width(), \'limits\': (0, None)},\n            #{\'name\': \'height\', \'type\': \'float\', \'value\': tr.height(), \'limits\': (0, None)},\n            #{\'name\': \'viewbox clipping\', \'type\': \'bool\', \'value\': True},\n            #{\'name\': \'normalize coordinates\', \'type\': \'bool\', \'value\': True},\n            {\'name\': \'scaling stroke\', \'type\': \'bool\', \'value\': False, \'tip\': ""If False, strokes are non-scaling, ""\n             ""which means that they appear the same width on screen regardless of how they are scaled or how the view is zoomed.""},\n        ])\n        #self.params.param(\'width\').sigValueChanged.connect(self.widthChanged)\n        #self.params.param(\'height\').sigValueChanged.connect(self.heightChanged)\n\n    def widthChanged(self):\n        sr = self.getSourceRect()\n        ar = sr.height() / sr.width()\n        self.params.param(\'height\').setValue(self.params[\'width\'] * ar, blockSignal=self.heightChanged)\n        \n    def heightChanged(self):\n        sr = self.getSourceRect()\n        ar = sr.width() / sr.height()\n        self.params.param(\'width\').setValue(self.params[\'height\'] * ar, blockSignal=self.widthChanged)\n        \n    def parameters(self):\n        return self.params\n    \n    def export(self, fileName=None, toBytes=False, copy=False):\n        if toBytes is False and copy is False and fileName is None:\n            self.fileSaveDialog(filter=""Scalable Vector Graphics (*.svg)"")\n            return\n        \n        ## Qt\'s SVG generator is not complete. (notably, it lacks clipping)\n        ## Instead, we will use Qt to generate SVG for each item independently,\n        ## then manually reconstruct the entire document.\n        options = {ch.name():ch.value() for ch in self.params.children()}\n        xml = generateSvg(self.item, options)\n        \n        if toBytes:\n            return xml.encode(\'UTF-8\')\n        elif copy:\n            md = QtCore.QMimeData()\n            md.setData(\'image/svg+xml\', QtCore.QByteArray(xml.encode(\'UTF-8\')))\n            QtGui.QApplication.clipboard().setMimeData(md)\n        else:\n            with open(fileName, \'wb\') as fh:\n                fh.write(asUnicode(xml).encode(\'utf-8\'))\n\n\nxmlHeader = """"""\\\n<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>\n<svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink""  version=""1.2"" baseProfile=""tiny"">\n<title>pyqtgraph SVG export</title>\n<desc>Generated with Qt and pyqtgraph</desc>\n""""""\n\ndef generateSvg(item, options={}):\n    global xmlHeader\n    try:\n        node, defs = _generateItemSvg(item, options=options)\n    finally:\n        ## reset export mode for all items in the tree\n        if isinstance(item, QtGui.QGraphicsScene):\n            items = item.items()\n        else:\n            items = [item]\n            for i in items:\n                items.extend(i.childItems())\n        for i in items:\n            if hasattr(i, \'setExportMode\'):\n                i.setExportMode(False)\n    \n    cleanXml(node)\n    \n    defsXml = ""<defs>\\n""\n    for d in defs:\n        defsXml += d.toprettyxml(indent=\'    \')\n    defsXml += ""</defs>\\n""\n    return xmlHeader + defsXml + node.toprettyxml(indent=\'    \') + ""\\n</svg>\\n""\n\n\ndef _generateItemSvg(item, nodes=None, root=None, options={}):\n    ## This function is intended to work around some issues with Qt\'s SVG generator\n    ## and SVG in general.\n    ## 1) Qt SVG does not implement clipping paths. This is absurd.\n    ##    The solution is to let Qt generate SVG for each item independently,\n    ##    then glue them together manually with clipping.\n    ##    \n    ##    The format Qt generates for all items looks like this:\n    ##    \n    ##    <g>\n    ##        <g transform=""matrix(...)"">\n    ##            one or more of: <path/> or <polyline/> or <text/>\n    ##        </g>\n    ##        <g transform=""matrix(...)"">\n    ##            one or more of: <path/> or <polyline/> or <text/>\n    ##        </g>\n    ##        . . .\n    ##    </g>\n    ##    \n    ## 2) There seems to be wide disagreement over whether path strokes\n    ##    should be scaled anisotropically. \n    ##      see: http://web.mit.edu/jonas/www/anisotropy/\n    ##    Given that both inkscape and illustrator seem to prefer isotropic\n    ##    scaling, we will optimize for those cases.  \n    ##    \n    ## 3) Qt generates paths using non-scaling-stroke from SVG 1.2, but \n    ##    inkscape only supports 1.1. \n    ##    \n    ##    Both 2 and 3 can be addressed by drawing all items in world coordinates.\n    \n    profiler = debug.Profiler()\n    \n    if nodes is None:  ## nodes maps all node IDs to their XML element. \n                       ## this allows us to ensure all elements receive unique names.\n        nodes = {}\n        \n    if root is None:\n        root = item\n                \n    ## Skip hidden items\n    if hasattr(item, \'isVisible\') and not item.isVisible():\n        return None\n        \n    ## If this item defines its own SVG generator, use that.\n    if hasattr(item, \'generateSvg\'):\n        return item.generateSvg(nodes)\n    \n\n    ## Generate SVG text for just this item (exclude its children; we\'ll handle them later)\n    tr = QtGui.QTransform()\n    if isinstance(item, QtGui.QGraphicsScene):\n        xmlStr = ""<g>\\n</g>\\n""\n        doc = xml.parseString(xmlStr)\n        childs = [i for i in item.items() if i.parentItem() is None]\n    elif item.__class__.paint == QtGui.QGraphicsItem.paint:\n        xmlStr = ""<g>\\n</g>\\n""\n        doc = xml.parseString(xmlStr)\n        childs = item.childItems()\n    else:\n        childs = item.childItems()\n        tr = itemTransform(item, item.scene())\n        \n        ## offset to corner of root item\n        if isinstance(root, QtGui.QGraphicsScene):\n            rootPos = QtCore.QPoint(0,0)\n        else:\n            rootPos = root.scenePos()\n        tr2 = QtGui.QTransform()\n        tr2.translate(-rootPos.x(), -rootPos.y())\n        tr = tr * tr2\n\n        arr = QtCore.QByteArray()\n        buf = QtCore.QBuffer(arr)\n        svg = QtSvg.QSvgGenerator()\n        svg.setOutputDevice(buf)\n        dpi = QtGui.QDesktopWidget().logicalDpiX()\n        svg.setResolution(dpi)\n\n        p = QtGui.QPainter()\n        p.begin(svg)\n        if hasattr(item, \'setExportMode\'):\n            item.setExportMode(True, {\'painter\': p})\n        try:\n            p.setTransform(tr)\n            opt = QtGui.QStyleOptionGraphicsItem()\n            if item.flags() & QtGui.QGraphicsItem.ItemUsesExtendedStyleOption:\n                opt.exposedRect = item.boundingRect()\n            item.paint(p, opt, None)\n        finally:\n            p.end()\n            ## Can\'t do this here--we need to wait until all children have painted as well.\n            ## this is taken care of in generateSvg instead.\n            #if hasattr(item, \'setExportMode\'):\n                #item.setExportMode(False)\n\n        if QT_LIB in [\'PySide\', \'PySide2\']:\n            xmlStr = str(arr)\n        else:\n            xmlStr = bytes(arr).decode(\'utf-8\')\n        doc = xml.parseString(xmlStr.encode(\'utf-8\'))\n        \n    try:\n        ## Get top-level group for this item\n        g1 = doc.getElementsByTagName(\'g\')[0]\n        ## get list of sub-groups\n        g2 = [n for n in g1.childNodes if isinstance(n, xml.Element) and n.tagName == \'g\']\n        \n        defs = doc.getElementsByTagName(\'defs\')\n        if len(defs) > 0:\n            defs = [n for n in defs[0].childNodes if isinstance(n, xml.Element)]\n    except:\n        print(doc.toxml())\n        raise\n\n    profiler(\'render\')\n\n    ## Get rid of group transformation matrices by applying\n    ## transformation to inner coordinates\n    correctCoordinates(g1, defs, item, options)\n    profiler(\'correct\')\n    \n    ## decide on a name for this item\n    baseName = item.__class__.__name__\n    i = 1\n    while True:\n        name = baseName + ""_%d"" % i\n        if name not in nodes:\n            break\n        i += 1\n    nodes[name] = g1\n    g1.setAttribute(\'id\', name)\n    \n    ## If this item clips its children, we need to take care of that.\n    childGroup = g1  ## add children directly to this node unless we are clipping\n    if not isinstance(item, QtGui.QGraphicsScene):\n        ## See if this item clips its children\n        if int(item.flags() & item.ItemClipsChildrenToShape) > 0:\n            ## Generate svg for just the path\n            path = QtGui.QGraphicsPathItem(item.mapToScene(item.shape()))\n            item.scene().addItem(path)\n            try:\n                pathNode = _generateItemSvg(path, root=root, options=options)[0].getElementsByTagName(\'path\')[0]\n                # assume <defs> for this path is empty.. possibly problematic.\n            finally:\n                item.scene().removeItem(path)\n            \n            ## and for the clipPath element\n            clip = name + \'_clip\'\n            clipNode = g1.ownerDocument.createElement(\'clipPath\')\n            clipNode.setAttribute(\'id\', clip)\n            clipNode.appendChild(pathNode)\n            g1.appendChild(clipNode)\n            \n            childGroup = g1.ownerDocument.createElement(\'g\')\n            childGroup.setAttribute(\'clip-path\', \'url(#%s)\' % clip)\n            g1.appendChild(childGroup)\n    profiler(\'clipping\')\n            \n    ## Add all child items as sub-elements.\n    childs.sort(key=lambda c: c.zValue())\n    for ch in childs:\n        csvg = _generateItemSvg(ch, nodes, root, options=options)\n        if csvg is None:\n            continue\n        cg, cdefs = csvg\n        childGroup.appendChild(cg)  ### this isn\'t quite right--some items draw below their parent (good enough for now)\n        defs.extend(cdefs)\n\n    profiler(\'children\')\n    return g1, defs\n\n\ndef correctCoordinates(node, defs, item, options):\n    # TODO: correct gradient coordinates inside defs\n    \n    ## Remove transformation matrices from <g> tags by applying matrix to coordinates inside.\n    ## Each item is represented by a single top-level group with one or more groups inside.\n    ## Each inner group contains one or more drawing primitives, possibly of different types.\n    groups = node.getElementsByTagName(\'g\')\n    \n    ## Since we leave text unchanged, groups which combine text and non-text primitives must be split apart.\n    ## (if at some point we start correcting text transforms as well, then it should be safe to remove this)\n    groups2 = []\n    for grp in groups:\n        subGroups = [grp.cloneNode(deep=False)]\n        textGroup = None\n        for ch in grp.childNodes[:]:\n            if isinstance(ch, xml.Element):\n                if textGroup is None:\n                    textGroup = ch.tagName == \'text\'\n                if ch.tagName == \'text\':\n                    if textGroup is False:\n                        subGroups.append(grp.cloneNode(deep=False))\n                        textGroup = True\n                else:\n                    if textGroup is True:\n                        subGroups.append(grp.cloneNode(deep=False))\n                        textGroup = False\n            subGroups[-1].appendChild(ch)\n        groups2.extend(subGroups)\n        for sg in subGroups:\n            node.insertBefore(sg, grp)\n        node.removeChild(grp)\n    groups = groups2\n        \n    \n    for grp in groups:\n        matrix = grp.getAttribute(\'transform\')\n        match = re.match(r\'matrix\\((.*)\\)\', matrix)\n        if match is None:\n            vals = [1,0,0,1,0,0]\n        else:\n            vals = [float(a) for a in match.groups()[0].split(\',\')]\n        tr = np.array([[vals[0], vals[2], vals[4]], [vals[1], vals[3], vals[5]]])\n        \n        removeTransform = False\n        for ch in grp.childNodes:\n            if not isinstance(ch, xml.Element):\n                continue\n            if ch.tagName == \'polyline\':\n                removeTransform = True\n                coords = np.array([[float(a) for a in c.split(\',\')] for c in ch.getAttribute(\'points\').strip().split(\' \')])\n                coords = fn.transformCoordinates(tr, coords, transpose=True)\n                ch.setAttribute(\'points\', \' \'.join([\',\'.join([str(a) for a in c]) for c in coords]))\n            elif ch.tagName == \'path\':\n                removeTransform = True\n                newCoords = \'\'\n                oldCoords = ch.getAttribute(\'d\').strip()\n                if oldCoords == \'\':\n                    continue\n                for c in oldCoords.split(\' \'):\n                    x,y = c.split(\',\')\n                    if x[0].isalpha():\n                        t = x[0]\n                        x = x[1:]\n                    else:\n                        t = \'\'\n                    nc = fn.transformCoordinates(tr, np.array([[float(x),float(y)]]), transpose=True)\n                    newCoords += t+str(nc[0,0])+\',\'+str(nc[0,1])+\' \'\n                # If coords start with L instead of M, then the entire path will not be rendered.\n                # (This can happen if the first point had nan values in it--Qt will skip it on export)\n                if newCoords[0] != \'M\':\n                    newCoords = \'M\' + newCoords[1:]\n                ch.setAttribute(\'d\', newCoords)\n            elif ch.tagName == \'text\':\n                removeTransform = False\n                ## leave text alone for now. Might need this later to correctly render text with outline.\n                #c = np.array([\n                    #[float(ch.getAttribute(\'x\')), float(ch.getAttribute(\'y\'))], \n                    #[float(ch.getAttribute(\'font-size\')), 0], \n                    #[0,0]])\n                #c = fn.transformCoordinates(tr, c, transpose=True)\n                #ch.setAttribute(\'x\', str(c[0,0]))\n                #ch.setAttribute(\'y\', str(c[0,1]))\n                #fs = c[1]-c[2]\n                #fs = (fs**2).sum()**0.5\n                #ch.setAttribute(\'font-size\', str(fs))\n                \n                ## Correct some font information\n                families = ch.getAttribute(\'font-family\').split(\',\')\n                if len(families) == 1:\n                    font = QtGui.QFont(families[0].strip(\'"" \'))\n                    if font.style() == font.SansSerif:\n                        families.append(\'sans-serif\')\n                    elif font.style() == font.Serif:\n                        families.append(\'serif\')\n                    elif font.style() == font.Courier:\n                        families.append(\'monospace\')\n                    ch.setAttribute(\'font-family\', \', \'.join([f if \' \' not in f else \'""%s""\'%f for f in families]))\n                \n            ## correct line widths if needed\n            if removeTransform and ch.getAttribute(\'vector-effect\') != \'non-scaling-stroke\' and grp.getAttribute(\'stroke-width\') != \'\':\n                w = float(grp.getAttribute(\'stroke-width\'))\n                s = fn.transformCoordinates(tr, np.array([[w,0], [0,0]]), transpose=True)\n                w = ((s[0]-s[1])**2).sum()**0.5\n                ch.setAttribute(\'stroke-width\', str(w))\n            \n            # Remove non-scaling-stroke if requested\n            if options.get(\'scaling stroke\') is True and ch.getAttribute(\'vector-effect\') == \'non-scaling-stroke\':\n                ch.removeAttribute(\'vector-effect\')\n\n        if removeTransform:\n            grp.removeAttribute(\'transform\')\n\n\nSVGExporter.register()        \n\n\ndef itemTransform(item, root):\n    ## Return the transformation mapping item to root\n    ## (actually to parent coordinate system of root)\n    \n    if item is root:\n        tr = QtGui.QTransform()\n        tr.translate(*item.pos())\n        tr = tr * item.transform()\n        return tr\n        \n    \n    if int(item.flags() & item.ItemIgnoresTransformations) > 0:\n        pos = item.pos()\n        parent = item.parentItem()\n        if parent is not None:\n            pos = itemTransform(parent, root).map(pos)\n        tr = QtGui.QTransform()\n        tr.translate(pos.x(), pos.y())\n        tr = item.transform() * tr\n    else:\n        ## find next parent that is either the root item or \n        ## an item that ignores its transformation\n        nextRoot = item\n        while True:\n            nextRoot = nextRoot.parentItem()\n            if nextRoot is None:\n                nextRoot = root\n                break\n            if nextRoot is root or int(nextRoot.flags() & nextRoot.ItemIgnoresTransformations) > 0:\n                break\n        \n        if isinstance(nextRoot, QtGui.QGraphicsScene):\n            tr = item.sceneTransform()\n        else:\n            tr = itemTransform(nextRoot, root) * item.itemTransform(nextRoot)[0]\n    \n    return tr\n\n            \ndef cleanXml(node):\n    ## remove extraneous text; let the xml library do the formatting.\n    hasElement = False\n    nonElement = []\n    for ch in node.childNodes:\n        if isinstance(ch, xml.Element):\n            hasElement = True\n            cleanXml(ch)\n        else:\n            nonElement.append(ch)\n    \n    if hasElement:\n        for ch in nonElement:\n            node.removeChild(ch)\n    elif node.tagName == \'g\':  ## remove childless groups\n        node.parentNode.removeChild(node)\n'"
src/third_party/pyqtgraph/exporters/__init__.py,0,b'from .Exporter import Exporter\nfrom .ImageExporter import *\nfrom .SVGExporter import *\nfrom .Matplotlib import *\nfrom .CSVExporter import *\nfrom .PrintExporter import *\nfrom .HDF5Exporter import *\n\ndef listExporters():\n    return Exporter.Exporters[:]\n\n'
src/third_party/pyqtgraph/flowchart/Flowchart.py,5,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtCore, QtGui, QT_LIB\nfrom .Node import *\nfrom ..pgcollections import OrderedDict\nfrom ..widgets.TreeWidget import *\nfrom .. import FileDialog, DataTreeWidget\n\n## pyside and pyqt use incompatible ui files.\nif QT_LIB == \'PySide\':\n    from . import FlowchartTemplate_pyside as FlowchartTemplate\n    from . import FlowchartCtrlTemplate_pyside as FlowchartCtrlTemplate\nelif QT_LIB == \'PySide2\':\n    from . import FlowchartTemplate_pyside2 as FlowchartTemplate\n    from . import FlowchartCtrlTemplate_pyside2 as FlowchartCtrlTemplate\nelif QT_LIB == \'PyQt5\':\n    from . import FlowchartTemplate_pyqt5 as FlowchartTemplate\n    from . import FlowchartCtrlTemplate_pyqt5 as FlowchartCtrlTemplate\nelse:\n    from . import FlowchartTemplate_pyqt as FlowchartTemplate\n    from . import FlowchartCtrlTemplate_pyqt as FlowchartCtrlTemplate\n    \nfrom .Terminal import Terminal\nfrom numpy import ndarray\nfrom .library import LIBRARY\nfrom ..debug import printExc\nfrom .. import configfile as configfile\nfrom .. import dockarea as dockarea\nfrom . import FlowchartGraphicsView\nfrom .. import functions as fn\n\ndef strDict(d):\n    return dict([(str(k), v) for k, v in d.items()])\n\n\n        \n\nclass Flowchart(Node):\n    sigFileLoaded = QtCore.Signal(object)\n    sigFileSaved = QtCore.Signal(object)\n    \n    \n    #sigOutputChanged = QtCore.Signal() ## inherited from Node\n    sigChartLoaded = QtCore.Signal()\n    sigStateChanged = QtCore.Signal()  # called when output is expected to have changed\n    sigChartChanged = QtCore.Signal(object, object, object) # called when nodes are added, removed, or renamed.\n                                                            # (self, action, node)\n    \n    def __init__(self, terminals=None, name=None, filePath=None, library=None):\n        self.library = library or LIBRARY\n        if name is None:\n            name = ""Flowchart""\n        if terminals is None:\n            terminals = {}\n        self.filePath = filePath\n        Node.__init__(self, name, allowAddInput=True, allowAddOutput=True)  ## create node without terminals; we\'ll add these later\n        \n        \n        self.inputWasSet = False  ## flag allows detection of changes in the absence of input change.\n        self._nodes = {}\n        self.nextZVal = 10\n        #self.connects = []\n        #self._chartGraphicsItem = FlowchartGraphicsItem(self)\n        self._widget = None\n        self._scene = None\n        self.processing = False ## flag that prevents recursive node updates\n        \n        self.widget()\n        \n        self.inputNode = Node(\'Input\', allowRemove=False, allowAddOutput=True)\n        self.outputNode = Node(\'Output\', allowRemove=False, allowAddInput=True)\n        self.addNode(self.inputNode, \'Input\', [-150, 0])\n        self.addNode(self.outputNode, \'Output\', [300, 0])\n        \n        self.outputNode.sigOutputChanged.connect(self.outputChanged)\n        self.outputNode.sigTerminalRenamed.connect(self.internalTerminalRenamed)\n        self.inputNode.sigTerminalRenamed.connect(self.internalTerminalRenamed)\n        self.outputNode.sigTerminalRemoved.connect(self.internalTerminalRemoved)\n        self.inputNode.sigTerminalRemoved.connect(self.internalTerminalRemoved)\n        self.outputNode.sigTerminalAdded.connect(self.internalTerminalAdded)\n        self.inputNode.sigTerminalAdded.connect(self.internalTerminalAdded)\n        \n        self.viewBox.autoRange(padding = 0.04)\n            \n        for name, opts in terminals.items():\n            self.addTerminal(name, **opts)\n      \n    def setLibrary(self, lib):\n        self.library = lib\n        self.widget().chartWidget.buildMenu()\n      \n    def setInput(self, **args):\n        """"""Set the input values of the flowchart. This will automatically propagate\n        the new values throughout the flowchart, (possibly) causing the output to change.\n        """"""\n        #print ""setInput"", args\n        #Node.setInput(self, **args)\n        #print ""  .....""\n        self.inputWasSet = True\n        self.inputNode.setOutput(**args)\n        \n    def outputChanged(self):\n        ## called when output of internal node has changed\n        vals = self.outputNode.inputValues()\n        self.widget().outputChanged(vals)\n        self.setOutput(**vals)\n        #self.sigOutputChanged.emit(self)\n        \n    def output(self):\n        """"""Return a dict of the values on the Flowchart\'s output terminals.\n        """"""\n        return self.outputNode.inputValues()\n        \n    def nodes(self):\n        return self._nodes\n        \n    def addTerminal(self, name, **opts):\n        term = Node.addTerminal(self, name, **opts)\n        name = term.name()\n        if opts[\'io\'] == \'in\':  ## inputs to the flowchart become outputs on the input node\n            opts[\'io\'] = \'out\'\n            opts[\'multi\'] = False\n            self.inputNode.sigTerminalAdded.disconnect(self.internalTerminalAdded)\n            try:\n                term2 = self.inputNode.addTerminal(name, **opts)\n            finally:\n                self.inputNode.sigTerminalAdded.connect(self.internalTerminalAdded)\n                \n        else:\n            opts[\'io\'] = \'in\'\n            #opts[\'multi\'] = False\n            self.outputNode.sigTerminalAdded.disconnect(self.internalTerminalAdded)\n            try:\n                term2 = self.outputNode.addTerminal(name, **opts)\n            finally:\n                self.outputNode.sigTerminalAdded.connect(self.internalTerminalAdded)\n        return term\n\n    def removeTerminal(self, name):\n        #print ""remove:"", name\n        term = self[name]\n        inTerm = self.internalTerminal(term)\n        Node.removeTerminal(self, name)\n        inTerm.node().removeTerminal(inTerm.name())\n        \n    def internalTerminalRenamed(self, term, oldName):\n        self[oldName].rename(term.name())\n        \n    def internalTerminalAdded(self, node, term):\n        if term._io == \'in\':\n            io = \'out\'\n        else:\n            io = \'in\'\n        Node.addTerminal(self, term.name(), io=io, renamable=term.isRenamable(), removable=term.isRemovable(), multiable=term.isMultiable())\n        \n    def internalTerminalRemoved(self, node, term):\n        try:\n            Node.removeTerminal(self, term.name())\n        except KeyError:\n            pass\n        \n    def terminalRenamed(self, term, oldName):\n        newName = term.name()\n        #print ""flowchart rename"", newName, oldName\n        #print self.terminals\n        Node.terminalRenamed(self, self[oldName], oldName)\n        #print self.terminals\n        for n in [self.inputNode, self.outputNode]:\n            if oldName in n.terminals:\n                n[oldName].rename(newName)\n\n    def createNode(self, nodeType, name=None, pos=None):\n        """"""Create a new Node and add it to this flowchart.\n        """"""\n        if name is None:\n            n = 0\n            while True:\n                name = ""%s.%d"" % (nodeType, n)\n                if name not in self._nodes:\n                    break\n                n += 1\n                \n        node = self.library.getNodeType(nodeType)(name)\n        self.addNode(node, name, pos)\n        return node\n        \n    def addNode(self, node, name, pos=None):\n        """"""Add an existing Node to this flowchart.\n        \n        See also: createNode()\n        """"""\n        if pos is None:\n            pos = [0, 0]\n        if type(pos) in [QtCore.QPoint, QtCore.QPointF]:\n            pos = [pos.x(), pos.y()]\n        item = node.graphicsItem()\n        item.setZValue(self.nextZVal*2)\n        self.nextZVal += 1\n        self.viewBox.addItem(item)\n        item.moveBy(*pos)\n        self._nodes[name] = node\n        if node is not self.inputNode and node is not self.outputNode:\n            self.widget().addNode(node) \n        node.sigClosed.connect(self.nodeClosed)\n        node.sigRenamed.connect(self.nodeRenamed)\n        node.sigOutputChanged.connect(self.nodeOutputChanged)\n        self.sigChartChanged.emit(self, \'add\', node)\n        \n    def removeNode(self, node):\n        """"""Remove a Node from this flowchart.\n        """"""\n        node.close()\n        \n    def nodeClosed(self, node):\n        del self._nodes[node.name()]\n        self.widget().removeNode(node)\n        for signal in [\'sigClosed\', \'sigRenamed\', \'sigOutputChanged\']:\n            try:\n                getattr(node, signal).disconnect(self.nodeClosed)\n            except (TypeError, RuntimeError):\n                pass\n        self.sigChartChanged.emit(self, \'remove\', node)\n        \n    def nodeRenamed(self, node, oldName):\n        del self._nodes[oldName]\n        self._nodes[node.name()] = node\n        self.widget().nodeRenamed(node, oldName)\n        self.sigChartChanged.emit(self, \'rename\', node)\n        \n    def arrangeNodes(self):\n        pass\n        \n    def internalTerminal(self, term):\n        """"""If the terminal belongs to the external Node, return the corresponding internal terminal""""""\n        if term.node() is self:\n            if term.isInput():\n                return self.inputNode[term.name()]\n            else:\n                return self.outputNode[term.name()]\n        else:\n            return term\n        \n    def connectTerminals(self, term1, term2):\n        """"""Connect two terminals together within this flowchart.""""""\n        term1 = self.internalTerminal(term1)\n        term2 = self.internalTerminal(term2)\n        term1.connectTo(term2)\n        \n    def process(self, **args):\n        """"""\n        Process data through the flowchart, returning the output.\n        \n        Keyword arguments must be the names of input terminals. \n        The return value is a dict with one key per output terminal.\n        \n        """"""\n        data = {}  ## Stores terminal:value pairs\n        \n        ## determine order of operations\n        ## order should look like [(\'p\', node1), (\'p\', node2), (\'d\', terminal1), ...] \n        ## Each tuple specifies either (p)rocess this node or (d)elete the result from this terminal\n        order = self.processOrder()\n        #print ""ORDER:"", order\n        \n        ## Record inputs given to process()\n        for n, t in self.inputNode.outputs().items():\n            # if n not in args:\n            #     raise Exception(""Parameter %s required to process this chart."" % n)\n            if n in args:\n                data[t] = args[n]\n        \n        ret = {}\n            \n        ## process all in order\n        for c, arg in order:\n            \n            if c == \'p\':     ## Process a single node\n                #print ""===> process:"", arg\n                node = arg\n                if node is self.inputNode:\n                    continue  ## input node has already been processed.\n                \n                            \n                ## get input and output terminals for this node\n                outs = list(node.outputs().values())\n                ins = list(node.inputs().values())\n                \n                ## construct input value dictionary\n                args = {}\n                for inp in ins:\n                    inputs = inp.inputTerminals()\n                    if len(inputs) == 0:\n                        continue\n                    if inp.isMultiValue():  ## multi-input terminals require a dict of all inputs\n                        args[inp.name()] = dict([(i, data[i]) for i in inputs if i in data])\n                    else:                   ## single-inputs terminals only need the single input value available\n                        args[inp.name()] = data[inputs[0]]  \n                        \n                if node is self.outputNode:\n                    ret = args  ## we now have the return value, but must keep processing in case there are other endpoint nodes in the chart\n                else:\n                    try:\n                        if node.isBypassed():\n                            result = node.processBypassed(args)\n                        else:\n                            result = node.process(display=False, **args)\n                    except:\n                        print(""Error processing node %s. Args are: %s"" % (str(node), str(args)))\n                        raise\n                    for out in outs:\n                        #print ""    Output:"", out, out.name()\n                        #print out.name()\n                        try:\n                            data[out] = result[out.name()]\n                        except KeyError:\n                            pass\n            elif c == \'d\':   ## delete a terminal result (no longer needed; may be holding a lot of memory)\n                #print ""===> delete"", arg\n                if arg in data:\n                    del data[arg]\n\n        return ret\n        \n    def processOrder(self):\n        """"""Return the order of operations required to process this chart.\n        The order returned should look like [(\'p\', node1), (\'p\', node2), (\'d\', terminal1), ...] \n        where each tuple specifies either (p)rocess this node or (d)elete the result from this terminal\n        """"""\n        \n        ## first collect list of nodes/terminals and their dependencies\n        deps = {}\n        tdeps = {}   ## {terminal: [nodes that depend on terminal]}\n        for name, node in self._nodes.items():\n            deps[node] = node.dependentNodes()\n            for t in node.outputs().values():\n                tdeps[t] = t.dependentNodes()\n            \n        #print ""DEPS:"", deps\n        ## determine correct node-processing order\n        order = fn.toposort(deps)\n        #print ""ORDER1:"", order\n        \n        ## construct list of operations\n        ops = [(\'p\', n) for n in order]\n        \n        ## determine when it is safe to delete terminal values\n        dels = []\n        for t, nodes in tdeps.items():\n            lastInd = 0\n            lastNode = None\n            for n in nodes:  ## determine which node is the last to be processed according to order\n                if n is self:\n                    lastInd = None\n                    break\n                else:\n                    try:\n                        ind = order.index(n)\n                    except ValueError:\n                        continue\n                if lastNode is None or ind > lastInd:\n                    lastNode = n\n                    lastInd = ind\n            if lastInd is not None:\n                dels.append((lastInd+1, t))\n        dels.sort(key=lambda a: a[0], reverse=True)\n        for i, t in dels:\n            ops.insert(i, (\'d\', t))\n        return ops\n        \n        \n    def nodeOutputChanged(self, startNode):\n        """"""Triggered when a node\'s output values have changed. (NOT called during process())\n        Propagates new data forward through network.""""""\n        ## first collect list of nodes/terminals and their dependencies\n        \n        if self.processing:\n            return\n        self.processing = True\n        try:\n            deps = {}\n            for name, node in self._nodes.items():\n                deps[node] = []\n                for t in node.outputs().values():\n                    deps[node].extend(t.dependentNodes())\n            \n            ## determine order of updates \n            order = fn.toposort(deps, nodes=[startNode])\n            order.reverse()\n            \n            ## keep track of terminals that have been updated\n            terms = set(startNode.outputs().values())\n            \n            #print ""======= Updating"", startNode\n            # print(""Order:"", order)\n            for node in order[1:]:\n                # print(""Processing node"", node)\n                update = False\n                for term in list(node.inputs().values()):\n                    # print(""  checking terminal"", term)\n                    deps = list(term.connections().keys())\n                    for d in deps:\n                        if d in terms:\n                            # print(""    ..input"", d, ""changed"")\n                            update |= True\n                            term.inputChanged(d, process=False)\n                if update:\n                    # print(""  processing.."")\n                    node.update()\n                    terms |= set(node.outputs().values())\n                    \n        finally:\n            self.processing = False\n            if self.inputWasSet:\n                self.inputWasSet = False\n            else:\n                self.sigStateChanged.emit()\n\n    def chartGraphicsItem(self):\n        """"""Return the graphicsItem that displays the internal nodes and\n        connections of this flowchart.\n        \n        Note that the similar method `graphicsItem()` is inherited from Node\n        and returns the *external* graphical representation of this flowchart.""""""\n        return self.viewBox\n        \n    def widget(self):\n        """"""Return the control widget for this flowchart.\n        \n        This widget provides GUI access to the parameters for each node and a\n        graphical representation of the flowchart.\n        """"""\n        if self._widget is None:\n            self._widget = FlowchartCtrlWidget(self)\n            self.scene = self._widget.scene()\n            self.viewBox = self._widget.viewBox()\n        return self._widget\n\n    def listConnections(self):\n        conn = set()\n        for n in self._nodes.values():\n            terms = n.outputs()\n            for n, t in terms.items():\n                for c in t.connections():\n                    conn.add((t, c))\n        return conn\n\n    def saveState(self):\n        """"""Return a serializable data structure representing the current state of this flowchart. \n        """"""\n        state = Node.saveState(self)\n        state[\'nodes\'] = []\n        state[\'connects\'] = []\n        \n        for name, node in self._nodes.items():\n            cls = type(node)\n            if hasattr(cls, \'nodeName\'):\n                clsName = cls.nodeName\n                pos = node.graphicsItem().pos()\n                ns = {\'class\': clsName, \'name\': name, \'pos\': (pos.x(), pos.y()), \'state\': node.saveState()}\n                state[\'nodes\'].append(ns)\n            \n        conn = self.listConnections()\n        for a, b in conn:\n            state[\'connects\'].append((a.node().name(), a.name(), b.node().name(), b.name()))\n        \n        state[\'inputNode\'] = self.inputNode.saveState()\n        state[\'outputNode\'] = self.outputNode.saveState()\n        \n        return state\n        \n    def restoreState(self, state, clear=False):\n        """"""Restore the state of this flowchart from a previous call to `saveState()`.\n        """"""\n        self.blockSignals(True)\n        try:\n            if clear:\n                self.clear()\n            Node.restoreState(self, state)\n            nodes = state[\'nodes\']\n            nodes.sort(key=lambda a: a[\'pos\'][0])\n            for n in nodes:\n                if n[\'name\'] in self._nodes:\n                    self._nodes[n[\'name\']].restoreState(n[\'state\'])\n                    continue\n                try:\n                    node = self.createNode(n[\'class\'], name=n[\'name\'])\n                    node.restoreState(n[\'state\'])\n                except:\n                    printExc(""Error creating node %s: (continuing anyway)"" % n[\'name\'])\n                \n            self.inputNode.restoreState(state.get(\'inputNode\', {}))\n            self.outputNode.restoreState(state.get(\'outputNode\', {}))\n                \n            #self.restoreTerminals(state[\'terminals\'])\n            for n1, t1, n2, t2 in state[\'connects\']:\n                try:\n                    self.connectTerminals(self._nodes[n1][t1], self._nodes[n2][t2])\n                except:\n                    print(self._nodes[n1].terminals)\n                    print(self._nodes[n2].terminals)\n                    printExc(""Error connecting terminals %s.%s - %s.%s:"" % (n1, t1, n2, t2))\n                \n        finally:\n            self.blockSignals(False)\n            \n        self.sigChartLoaded.emit()\n        self.outputChanged()\n        self.sigStateChanged.emit()\n            \n    def loadFile(self, fileName=None, startDir=None):\n        """"""Load a flowchart (*.fc) file.\n        """"""\n        if fileName is None:\n            if startDir is None:\n                startDir = self.filePath\n            if startDir is None:\n                startDir = \'.\'\n            self.fileDialog = FileDialog(None, ""Load Flowchart.."", startDir, ""Flowchart (*.fc)"")\n            self.fileDialog.show()\n            self.fileDialog.fileSelected.connect(self.loadFile)\n            return\n            ## NOTE: was previously using a real widget for the file dialog\'s parent, but this caused weird mouse event bugs..\n        fileName = unicode(fileName)\n        state = configfile.readConfigFile(fileName)\n        self.restoreState(state, clear=True)\n        self.viewBox.autoRange()\n        self.sigFileLoaded.emit(fileName)\n        \n    def saveFile(self, fileName=None, startDir=None, suggestedFileName=\'flowchart.fc\'):\n        """"""Save this flowchart to a .fc file\n        """"""\n        if fileName is None:\n            if startDir is None:\n                startDir = self.filePath\n            if startDir is None:\n                startDir = \'.\'\n            self.fileDialog = FileDialog(None, ""Save Flowchart.."", startDir, ""Flowchart (*.fc)"")\n            self.fileDialog.setAcceptMode(QtGui.QFileDialog.AcceptSave) \n            self.fileDialog.show()\n            self.fileDialog.fileSelected.connect(self.saveFile)\n            return\n        fileName = unicode(fileName)\n        configfile.writeConfigFile(self.saveState(), fileName)\n        self.sigFileSaved.emit(fileName)\n\n    def clear(self):\n        """"""Remove all nodes from this flowchart except the original input/output nodes.\n        """"""\n        for n in list(self._nodes.values()):\n            if n is self.inputNode or n is self.outputNode:\n                continue\n            n.close()  ## calls self.nodeClosed(n) by signal\n        #self.clearTerminals()\n        self.widget().clear()\n        \n    def clearTerminals(self):\n        Node.clearTerminals(self)\n        self.inputNode.clearTerminals()\n        self.outputNode.clearTerminals()\n\n\nclass FlowchartGraphicsItem(GraphicsObject):\n    \n    def __init__(self, chart):\n        GraphicsObject.__init__(self)\n        self.chart = chart ## chart is an instance of Flowchart()\n        self.updateTerminals()\n        \n    def updateTerminals(self):\n        self.terminals = {}\n        bounds = self.boundingRect()\n        inp = self.chart.inputs()\n        dy = bounds.height() / (len(inp)+1)\n        y = dy\n        for n, t in inp.items():\n            item = t.graphicsItem()\n            self.terminals[n] = item\n            item.setParentItem(self)\n            item.setAnchor(bounds.width(), y)\n            y += dy\n        out = self.chart.outputs()\n        dy = bounds.height() / (len(out)+1)\n        y = dy\n        for n, t in out.items():\n            item = t.graphicsItem()\n            self.terminals[n] = item\n            item.setParentItem(self)\n            item.setAnchor(0, y)\n            y += dy\n        \n    def boundingRect(self):\n        #print ""FlowchartGraphicsItem.boundingRect""\n        return QtCore.QRectF()\n        \n    def paint(self, p, *args):\n        #print ""FlowchartGraphicsItem.paint""\n        pass\n        #p.drawRect(self.boundingRect())\n    \n\nclass FlowchartCtrlWidget(QtGui.QWidget):\n    """"""The widget that contains the list of all the nodes in a flowchart and their controls, as well as buttons for loading/saving flowcharts.""""""\n    \n    def __init__(self, chart):\n        self.items = {}\n        #self.loadDir = loadDir  ## where to look initially for chart files\n        self.currentFileName = None\n        QtGui.QWidget.__init__(self)\n        self.chart = chart\n        self.ui = FlowchartCtrlTemplate.Ui_Form()\n        self.ui.setupUi(self)\n        self.ui.ctrlList.setColumnCount(2)\n        #self.ui.ctrlList.setColumnWidth(0, 200)\n        self.ui.ctrlList.setColumnWidth(1, 20)\n        self.ui.ctrlList.setVerticalScrollMode(self.ui.ctrlList.ScrollPerPixel)\n        self.ui.ctrlList.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        \n        self.chartWidget = FlowchartWidget(chart, self)\n        #self.chartWidget.viewBox().autoRange()\n        self.cwWin = QtGui.QMainWindow()\n        self.cwWin.setWindowTitle(\'Flowchart\')\n        self.cwWin.setCentralWidget(self.chartWidget)\n        self.cwWin.resize(1000,800)\n        \n        h = self.ui.ctrlList.header()\n        if QT_LIB in [\'PyQt4\', \'PySide\']:\n            h.setResizeMode(0, h.Stretch)\n        else:\n            h.setSectionResizeMode(0, h.Stretch)\n        \n        self.ui.ctrlList.itemChanged.connect(self.itemChanged)\n        self.ui.loadBtn.clicked.connect(self.loadClicked)\n        self.ui.saveBtn.clicked.connect(self.saveClicked)\n        self.ui.saveAsBtn.clicked.connect(self.saveAsClicked)\n        self.ui.showChartBtn.toggled.connect(self.chartToggled)\n        self.chart.sigFileLoaded.connect(self.setCurrentFile)\n        self.ui.reloadBtn.clicked.connect(self.reloadClicked)\n        self.chart.sigFileSaved.connect(self.fileSaved)\n        \n    \n        \n    #def resizeEvent(self, ev):\n        #QtGui.QWidget.resizeEvent(self, ev)\n        #self.ui.ctrlList.setColumnWidth(0, self.ui.ctrlList.viewport().width()-20)\n        \n    def chartToggled(self, b):\n        if b:\n            self.cwWin.show()\n        else:\n            self.cwWin.hide()\n\n    def reloadClicked(self):\n        try:\n            self.chartWidget.reloadLibrary()\n            self.ui.reloadBtn.success(""Reloaded."")\n        except:\n            self.ui.reloadBtn.success(""Error."")\n            raise\n            \n            \n    def loadClicked(self):\n        newFile = self.chart.loadFile()\n        #self.setCurrentFile(newFile)\n        \n    def fileSaved(self, fileName):\n        self.setCurrentFile(unicode(fileName))\n        self.ui.saveBtn.success(""Saved."")\n        \n    def saveClicked(self):\n        if self.currentFileName is None:\n            self.saveAsClicked()\n        else:\n            try:\n                self.chart.saveFile(self.currentFileName)\n                #self.ui.saveBtn.success(""Saved."")\n            except:\n                self.ui.saveBtn.failure(""Error"")\n                raise\n        \n    def saveAsClicked(self):\n        try:\n            if self.currentFileName is None:\n                newFile = self.chart.saveFile()\n            else:\n                newFile = self.chart.saveFile(suggestedFileName=self.currentFileName)\n            #self.ui.saveAsBtn.success(""Saved."")\n            #print ""Back to saveAsClicked.""\n        except:\n            self.ui.saveBtn.failure(""Error"")\n            raise\n            \n        #self.setCurrentFile(newFile)\n            \n    def setCurrentFile(self, fileName):\n        self.currentFileName = unicode(fileName)\n        if fileName is None:\n            self.ui.fileNameLabel.setText(""<b>[ new ]</b>"")\n        else:\n            self.ui.fileNameLabel.setText(""<b>%s</b>"" % os.path.split(self.currentFileName)[1])\n        self.resizeEvent(None)\n\n    def itemChanged(self, *args):\n        pass\n    \n    def scene(self):\n        return self.chartWidget.scene() ## returns the GraphicsScene object\n    \n    def viewBox(self):\n        return self.chartWidget.viewBox()\n\n    def nodeRenamed(self, node, oldName):\n        self.items[node].setText(0, node.name())\n\n    def addNode(self, node):\n        ctrl = node.ctrlWidget()\n        #if ctrl is None:\n            #return\n        item = QtGui.QTreeWidgetItem([node.name(), \'\', \'\'])\n        self.ui.ctrlList.addTopLevelItem(item)\n        byp = QtGui.QPushButton(\'X\')\n        byp.setCheckable(True)\n        byp.setFixedWidth(20)\n        item.bypassBtn = byp\n        self.ui.ctrlList.setItemWidget(item, 1, byp)\n        byp.node = node\n        node.bypassButton = byp\n        byp.setChecked(node.isBypassed())\n        byp.clicked.connect(self.bypassClicked)\n        \n        if ctrl is not None:\n            item2 = QtGui.QTreeWidgetItem()\n            item.addChild(item2)\n            self.ui.ctrlList.setItemWidget(item2, 0, ctrl)\n            \n        self.items[node] = item\n        \n    def removeNode(self, node):\n        if node in self.items:\n            item = self.items[node]\n            #self.disconnect(item.bypassBtn, QtCore.SIGNAL(\'clicked()\'), self.bypassClicked)\n            try:\n                item.bypassBtn.clicked.disconnect(self.bypassClicked)\n            except (TypeError, RuntimeError):\n                pass\n            self.ui.ctrlList.removeTopLevelItem(item)\n            \n    def bypassClicked(self):\n        btn = QtCore.QObject.sender(self)\n        btn.node.bypass(btn.isChecked())\n            \n    def chartWidget(self):\n        return self.chartWidget\n\n    def outputChanged(self, data):\n        pass\n        #self.ui.outputTree.setData(data, hideRoot=True)\n\n    def clear(self):\n        self.chartWidget.clear()\n        \n    def select(self, node):\n        item = self.items[node]\n        self.ui.ctrlList.setCurrentItem(item)\n\n\nclass FlowchartWidget(dockarea.DockArea):\n    """"""Includes the actual graphical flowchart and debugging interface""""""\n    def __init__(self, chart, ctrl):\n        #QtGui.QWidget.__init__(self)\n        dockarea.DockArea.__init__(self)\n        self.chart = chart\n        self.ctrl = ctrl\n        self.hoverItem = None\n        #self.setMinimumWidth(250)\n        #self.setSizePolicy(QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Expanding))\n        \n        #self.ui = FlowchartTemplate.Ui_Form()\n        #self.ui.setupUi(self)\n        \n        ## build user interface (it was easier to do it here than via developer)\n        self.view = FlowchartGraphicsView.FlowchartGraphicsView(self)\n        self.viewDock = dockarea.Dock(\'view\', size=(1000,600))\n        self.viewDock.addWidget(self.view)\n        self.viewDock.hideTitleBar()\n        self.addDock(self.viewDock)\n    \n\n        self.hoverText = QtGui.QTextEdit()\n        self.hoverText.setReadOnly(True)\n        self.hoverDock = dockarea.Dock(\'Hover Info\', size=(1000,20))\n        self.hoverDock.addWidget(self.hoverText)\n        self.addDock(self.hoverDock, \'bottom\')\n\n        self.selInfo = QtGui.QWidget()\n        self.selInfoLayout = QtGui.QGridLayout()\n        self.selInfo.setLayout(self.selInfoLayout)\n        self.selDescLabel = QtGui.QLabel()\n        self.selNameLabel = QtGui.QLabel()\n        self.selDescLabel.setWordWrap(True)\n        self.selectedTree = DataTreeWidget()\n        #self.selectedTree.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n        #self.selInfoLayout.addWidget(self.selNameLabel)\n        self.selInfoLayout.addWidget(self.selDescLabel)\n        self.selInfoLayout.addWidget(self.selectedTree)\n        self.selDock = dockarea.Dock(\'Selected Node\', size=(1000,200))\n        self.selDock.addWidget(self.selInfo)\n        self.addDock(self.selDock, \'bottom\')\n        \n        self._scene = self.view.scene()\n        self._viewBox = self.view.viewBox()\n        #self._scene = QtGui.QGraphicsScene()\n        #self._scene = FlowchartGraphicsView.FlowchartGraphicsScene()\n        #self.view.setScene(self._scene)\n        \n        self.buildMenu()\n        #self.ui.addNodeBtn.mouseReleaseEvent = self.addNodeBtnReleased\n            \n        self._scene.selectionChanged.connect(self.selectionChanged)\n        self._scene.sigMouseHover.connect(self.hoverOver)\n        #self.view.sigClicked.connect(self.showViewMenu)\n        #self._scene.sigSceneContextMenu.connect(self.showViewMenu)\n        #self._viewBox.sigActionPositionChanged.connect(self.menuPosChanged)\n        \n        \n    def reloadLibrary(self):\n        #QtCore.QObject.disconnect(self.nodeMenu, QtCore.SIGNAL(\'triggered(QAction*)\'), self.nodeMenuTriggered)\n        self.nodeMenu.triggered.disconnect(self.nodeMenuTriggered)\n        self.nodeMenu = None\n        self.subMenus = []\n        self.chart.library.reload()\n        self.buildMenu()\n        \n    def buildMenu(self, pos=None):\n        def buildSubMenu(node, rootMenu, subMenus, pos=None):\n            for section, node in node.items():\n                menu = QtGui.QMenu(section)\n                rootMenu.addMenu(menu)\n                if isinstance(node, OrderedDict): \n                    buildSubMenu(node, menu, subMenus, pos=pos)\n                    subMenus.append(menu)\n                else:\n                    act = rootMenu.addAction(section)\n                    act.nodeType = section\n                    act.pos = pos\n        self.nodeMenu = QtGui.QMenu()\n        self.subMenus = []       \n        buildSubMenu(self.chart.library.getNodeTree(), self.nodeMenu, self.subMenus, pos=pos)\n        self.nodeMenu.triggered.connect(self.nodeMenuTriggered)\n        return self.nodeMenu\n    \n    def menuPosChanged(self, pos):\n        self.menuPos = pos\n    \n    def showViewMenu(self, ev):\n        #QtGui.QPushButton.mouseReleaseEvent(self.ui.addNodeBtn, ev)\n        #if ev.button() == QtCore.Qt.RightButton:\n            #self.menuPos = self.view.mapToScene(ev.pos())\n            #self.nodeMenu.popup(ev.globalPos())\n        #print ""Flowchart.showViewMenu called""\n\n        #self.menuPos = ev.scenePos()\n        self.buildMenu(ev.scenePos())\n        self.nodeMenu.popup(ev.screenPos())\n        \n    def scene(self):\n        return self._scene ## the GraphicsScene item\n\n    def viewBox(self):\n        return self._viewBox ## the viewBox that items should be added to\n\n    def nodeMenuTriggered(self, action):\n        nodeType = action.nodeType\n        if action.pos is not None:\n            pos = action.pos\n        else:\n            pos = self.menuPos\n        pos = self.viewBox().mapSceneToView(pos)\n\n        self.chart.createNode(nodeType, pos=pos)\n\n\n    def selectionChanged(self):\n        #print ""FlowchartWidget.selectionChanged called.""\n        items = self._scene.selectedItems()\n        #print ""     scene.selectedItems: "", items\n        if len(items) == 0:\n            data = None\n        else:\n            item = items[0]\n            if hasattr(item, \'node\') and isinstance(item.node, Node):\n                n = item.node\n                self.ctrl.select(n)\n                data = {\'outputs\': n.outputValues(), \'inputs\': n.inputValues()}\n                self.selNameLabel.setText(n.name())\n                if hasattr(n, \'nodeName\'):\n                    self.selDescLabel.setText(""<b>%s</b>: %s"" % (n.nodeName, n.__class__.__doc__))\n                else:\n                    self.selDescLabel.setText("""")\n                if n.exception is not None:\n                    data[\'exception\'] = n.exception\n            else:\n                data = None\n        self.selectedTree.setData(data, hideRoot=True)\n\n    def hoverOver(self, items):\n        #print ""FlowchartWidget.hoverOver called.""\n        term = None\n        for item in items:\n            if item is self.hoverItem:\n                return\n            self.hoverItem = item\n            if hasattr(item, \'term\') and isinstance(item.term, Terminal):\n                term = item.term\n                break\n        if term is None:\n            self.hoverText.setPlainText("""")\n        else:\n            val = term.value()\n            if isinstance(val, ndarray):\n                val = ""%s %s %s"" % (type(val).__name__, str(val.shape), str(val.dtype))\n            else:\n                val = str(val)\n                if len(val) > 400:\n                    val = val[:400] + ""...""\n            self.hoverText.setPlainText(""%s.%s = %s"" % (term.node().name(), term.name(), val))\n            #self.hoverLabel.setCursorPosition(0)\n\n    \n\n    def clear(self):\n        #self.outputTree.setData(None)\n        self.selectedTree.setData(None)\n        self.hoverText.setPlainText(\'\')\n        self.selNameLabel.setText(\'\')\n        self.selDescLabel.setText(\'\')\n        \n        \nclass FlowchartNode(Node):\n    pass\n\n'"
src/third_party/pyqtgraph/flowchart/FlowchartCtrlTemplate_pyqt.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/flowchart/FlowchartCtrlTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:50 2013\n#      by: PyQt4 UI code generator 4.10\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt4 import QtCore, QtGui\n\ntry:\n    _fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n    def _fromUtf8(s):\n        return s\n\ntry:\n    _encoding = QtGui.QApplication.UnicodeUTF8\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig, _encoding)\nexcept AttributeError:\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig)\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(""Form""))\n        Form.resize(217, 499)\n        self.gridLayout = QtGui.QGridLayout(Form)\n        self.gridLayout.setMargin(0)\n        self.gridLayout.setVerticalSpacing(0)\n        self.gridLayout.setObjectName(_fromUtf8(""gridLayout""))\n        self.loadBtn = QtGui.QPushButton(Form)\n        self.loadBtn.setObjectName(_fromUtf8(""loadBtn""))\n        self.gridLayout.addWidget(self.loadBtn, 1, 0, 1, 1)\n        self.saveBtn = FeedbackButton(Form)\n        self.saveBtn.setObjectName(_fromUtf8(""saveBtn""))\n        self.gridLayout.addWidget(self.saveBtn, 1, 1, 1, 2)\n        self.saveAsBtn = FeedbackButton(Form)\n        self.saveAsBtn.setObjectName(_fromUtf8(""saveAsBtn""))\n        self.gridLayout.addWidget(self.saveAsBtn, 1, 3, 1, 1)\n        self.reloadBtn = FeedbackButton(Form)\n        self.reloadBtn.setCheckable(False)\n        self.reloadBtn.setFlat(False)\n        self.reloadBtn.setObjectName(_fromUtf8(""reloadBtn""))\n        self.gridLayout.addWidget(self.reloadBtn, 4, 0, 1, 2)\n        self.showChartBtn = QtGui.QPushButton(Form)\n        self.showChartBtn.setCheckable(True)\n        self.showChartBtn.setObjectName(_fromUtf8(""showChartBtn""))\n        self.gridLayout.addWidget(self.showChartBtn, 4, 2, 1, 2)\n        self.ctrlList = TreeWidget(Form)\n        self.ctrlList.setObjectName(_fromUtf8(""ctrlList""))\n        self.ctrlList.headerItem().setText(0, _fromUtf8(""1""))\n        self.ctrlList.header().setVisible(False)\n        self.ctrlList.header().setStretchLastSection(False)\n        self.gridLayout.addWidget(self.ctrlList, 3, 0, 1, 4)\n        self.fileNameLabel = QtGui.QLabel(Form)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.fileNameLabel.setFont(font)\n        self.fileNameLabel.setText(_fromUtf8(""""))\n        self.fileNameLabel.setAlignment(QtCore.Qt.AlignCenter)\n        self.fileNameLabel.setObjectName(_fromUtf8(""fileNameLabel""))\n        self.gridLayout.addWidget(self.fileNameLabel, 0, 1, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(_translate(""Form"", ""Form"", None))\n        self.loadBtn.setText(_translate(""Form"", ""Load.."", None))\n        self.saveBtn.setText(_translate(""Form"", ""Save"", None))\n        self.saveAsBtn.setText(_translate(""Form"", ""As.."", None))\n        self.reloadBtn.setText(_translate(""Form"", ""Reload Libs"", None))\n        self.showChartBtn.setText(_translate(""Form"", ""Flowchart"", None))\n\nfrom ..widgets.TreeWidget import TreeWidget\nfrom ..widgets.FeedbackButton import FeedbackButton\n'"
src/third_party/pyqtgraph/flowchart/FlowchartCtrlTemplate_pyqt5.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/flowchart/FlowchartCtrlTemplate.ui\'\n#\n# Created: Wed Mar 26 15:09:28 2014\n#      by: PyQt5 UI code generator 5.0.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(217, 499)\n        self.gridLayout = QtWidgets.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setVerticalSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.loadBtn = QtWidgets.QPushButton(Form)\n        self.loadBtn.setObjectName(""loadBtn"")\n        self.gridLayout.addWidget(self.loadBtn, 1, 0, 1, 1)\n        self.saveBtn = FeedbackButton(Form)\n        self.saveBtn.setObjectName(""saveBtn"")\n        self.gridLayout.addWidget(self.saveBtn, 1, 1, 1, 2)\n        self.saveAsBtn = FeedbackButton(Form)\n        self.saveAsBtn.setObjectName(""saveAsBtn"")\n        self.gridLayout.addWidget(self.saveAsBtn, 1, 3, 1, 1)\n        self.reloadBtn = FeedbackButton(Form)\n        self.reloadBtn.setCheckable(False)\n        self.reloadBtn.setFlat(False)\n        self.reloadBtn.setObjectName(""reloadBtn"")\n        self.gridLayout.addWidget(self.reloadBtn, 4, 0, 1, 2)\n        self.showChartBtn = QtWidgets.QPushButton(Form)\n        self.showChartBtn.setCheckable(True)\n        self.showChartBtn.setObjectName(""showChartBtn"")\n        self.gridLayout.addWidget(self.showChartBtn, 4, 2, 1, 2)\n        self.ctrlList = TreeWidget(Form)\n        self.ctrlList.setObjectName(""ctrlList"")\n        self.ctrlList.headerItem().setText(0, ""1"")\n        self.ctrlList.header().setVisible(False)\n        self.ctrlList.header().setStretchLastSection(False)\n        self.gridLayout.addWidget(self.ctrlList, 3, 0, 1, 4)\n        self.fileNameLabel = QtWidgets.QLabel(Form)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.fileNameLabel.setFont(font)\n        self.fileNameLabel.setText("""")\n        self.fileNameLabel.setAlignment(QtCore.Qt.AlignCenter)\n        self.fileNameLabel.setObjectName(""fileNameLabel"")\n        self.gridLayout.addWidget(self.fileNameLabel, 0, 1, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Form""))\n        self.loadBtn.setText(_translate(""Form"", ""Load..""))\n        self.saveBtn.setText(_translate(""Form"", ""Save""))\n        self.saveAsBtn.setText(_translate(""Form"", ""As..""))\n        self.reloadBtn.setText(_translate(""Form"", ""Reload Libs""))\n        self.showChartBtn.setText(_translate(""Form"", ""Flowchart""))\n\nfrom ..widgets.FeedbackButton import FeedbackButton\nfrom ..widgets.TreeWidget import TreeWidget\n'"
src/third_party/pyqtgraph/flowchart/FlowchartCtrlTemplate_pyside.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/flowchart/FlowchartCtrlTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:51 2013\n#      by: pyside-uic 0.2.14 running on PySide 1.1.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide import QtCore, QtGui\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(217, 499)\n        self.gridLayout = QtGui.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setVerticalSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.loadBtn = QtGui.QPushButton(Form)\n        self.loadBtn.setObjectName(""loadBtn"")\n        self.gridLayout.addWidget(self.loadBtn, 1, 0, 1, 1)\n        self.saveBtn = FeedbackButton(Form)\n        self.saveBtn.setObjectName(""saveBtn"")\n        self.gridLayout.addWidget(self.saveBtn, 1, 1, 1, 2)\n        self.saveAsBtn = FeedbackButton(Form)\n        self.saveAsBtn.setObjectName(""saveAsBtn"")\n        self.gridLayout.addWidget(self.saveAsBtn, 1, 3, 1, 1)\n        self.reloadBtn = FeedbackButton(Form)\n        self.reloadBtn.setCheckable(False)\n        self.reloadBtn.setFlat(False)\n        self.reloadBtn.setObjectName(""reloadBtn"")\n        self.gridLayout.addWidget(self.reloadBtn, 4, 0, 1, 2)\n        self.showChartBtn = QtGui.QPushButton(Form)\n        self.showChartBtn.setCheckable(True)\n        self.showChartBtn.setObjectName(""showChartBtn"")\n        self.gridLayout.addWidget(self.showChartBtn, 4, 2, 1, 2)\n        self.ctrlList = TreeWidget(Form)\n        self.ctrlList.setObjectName(""ctrlList"")\n        self.ctrlList.headerItem().setText(0, ""1"")\n        self.ctrlList.header().setVisible(False)\n        self.ctrlList.header().setStretchLastSection(False)\n        self.gridLayout.addWidget(self.ctrlList, 3, 0, 1, 4)\n        self.fileNameLabel = QtGui.QLabel(Form)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.fileNameLabel.setFont(font)\n        self.fileNameLabel.setText("""")\n        self.fileNameLabel.setAlignment(QtCore.Qt.AlignCenter)\n        self.fileNameLabel.setObjectName(""fileNameLabel"")\n        self.gridLayout.addWidget(self.fileNameLabel, 0, 1, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtGui.QApplication.translate(""Form"", ""Form"", None, QtGui.QApplication.UnicodeUTF8))\n        self.loadBtn.setText(QtGui.QApplication.translate(""Form"", ""Load.."", None, QtGui.QApplication.UnicodeUTF8))\n        self.saveBtn.setText(QtGui.QApplication.translate(""Form"", ""Save"", None, QtGui.QApplication.UnicodeUTF8))\n        self.saveAsBtn.setText(QtGui.QApplication.translate(""Form"", ""As.."", None, QtGui.QApplication.UnicodeUTF8))\n        self.reloadBtn.setText(QtGui.QApplication.translate(""Form"", ""Reload Libs"", None, QtGui.QApplication.UnicodeUTF8))\n        self.showChartBtn.setText(QtGui.QApplication.translate(""Form"", ""Flowchart"", None, QtGui.QApplication.UnicodeUTF8))\n\nfrom ..widgets.TreeWidget import TreeWidget\nfrom ..widgets.FeedbackButton import FeedbackButton\n'"
src/third_party/pyqtgraph/flowchart/FlowchartCtrlTemplate_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'FlowchartCtrlTemplate.ui\'\n#\n# Created: Sun Sep 18 19:16:46 2016\n#      by: pyside2-uic  running on PySide2 2.0.0~alpha0\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide2 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(217, 499)\n        self.gridLayout = QtWidgets.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setVerticalSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.loadBtn = QtWidgets.QPushButton(Form)\n        self.loadBtn.setObjectName(""loadBtn"")\n        self.gridLayout.addWidget(self.loadBtn, 1, 0, 1, 1)\n        self.saveBtn = FeedbackButton(Form)\n        self.saveBtn.setObjectName(""saveBtn"")\n        self.gridLayout.addWidget(self.saveBtn, 1, 1, 1, 2)\n        self.saveAsBtn = FeedbackButton(Form)\n        self.saveAsBtn.setObjectName(""saveAsBtn"")\n        self.gridLayout.addWidget(self.saveAsBtn, 1, 3, 1, 1)\n        self.reloadBtn = FeedbackButton(Form)\n        self.reloadBtn.setCheckable(False)\n        self.reloadBtn.setFlat(False)\n        self.reloadBtn.setObjectName(""reloadBtn"")\n        self.gridLayout.addWidget(self.reloadBtn, 4, 0, 1, 2)\n        self.showChartBtn = QtWidgets.QPushButton(Form)\n        self.showChartBtn.setCheckable(True)\n        self.showChartBtn.setObjectName(""showChartBtn"")\n        self.gridLayout.addWidget(self.showChartBtn, 4, 2, 1, 2)\n        self.ctrlList = TreeWidget(Form)\n        self.ctrlList.setObjectName(""ctrlList"")\n        self.ctrlList.headerItem().setText(0, ""1"")\n        self.ctrlList.header().setVisible(False)\n        self.ctrlList.header().setStretchLastSection(False)\n        self.gridLayout.addWidget(self.ctrlList, 3, 0, 1, 4)\n        self.fileNameLabel = QtWidgets.QLabel(Form)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.fileNameLabel.setFont(font)\n        self.fileNameLabel.setText("""")\n        self.fileNameLabel.setAlignment(QtCore.Qt.AlignCenter)\n        self.fileNameLabel.setObjectName(""fileNameLabel"")\n        self.gridLayout.addWidget(self.fileNameLabel, 0, 1, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtWidgets.QApplication.translate(""Form"", ""Form"", None, -1))\n        self.loadBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Load.."", None, -1))\n        self.saveBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Save"", None, -1))\n        self.saveAsBtn.setText(QtWidgets.QApplication.translate(""Form"", ""As.."", None, -1))\n        self.reloadBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Reload Libs"", None, -1))\n        self.showChartBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Flowchart"", None, -1))\n\nfrom ..widgets.FeedbackButton import FeedbackButton\nfrom ..widgets.TreeWidget import TreeWidget\n'"
src/third_party/pyqtgraph/flowchart/FlowchartGraphicsView.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtGui, QtCore\nfrom ..widgets.GraphicsView import GraphicsView\nfrom ..GraphicsScene import GraphicsScene\nfrom ..graphicsItems.ViewBox import ViewBox\n\n\nclass FlowchartGraphicsView(GraphicsView):\n    \n    sigHoverOver = QtCore.Signal(object)\n    sigClicked = QtCore.Signal(object)\n    \n    def __init__(self, widget, *args):\n        GraphicsView.__init__(self, *args, useOpenGL=False)\n        self._vb = FlowchartViewBox(widget, lockAspect=True, invertY=True)\n        self.setCentralItem(self._vb)\n        self.setRenderHint(QtGui.QPainter.Antialiasing, True)\n    \n    def viewBox(self):\n        return self._vb\n    \n        \nclass FlowchartViewBox(ViewBox):\n    \n    def __init__(self, widget, *args, **kwargs):\n        ViewBox.__init__(self, *args, **kwargs)\n        self.widget = widget\n        \n    def getMenu(self, ev):\n        ## called by ViewBox to create a new context menu\n        self._fc_menu = QtGui.QMenu()\n        self._subMenus = self.getContextMenus(ev)\n        for menu in self._subMenus:\n            self._fc_menu.addMenu(menu)\n        return self._fc_menu\n    \n    def getContextMenus(self, ev):\n        ## called by scene to add menus on to someone else\'s context menu\n        menu = self.widget.buildMenu(ev.scenePos())\n        menu.setTitle(""Add node"")\n        return [menu, ViewBox.getMenu(self, ev)]\n'"
src/third_party/pyqtgraph/flowchart/FlowchartTemplate_pyqt.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/flowchart/FlowchartTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:51 2013\n#      by: PyQt4 UI code generator 4.10\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt4 import QtCore, QtGui\n\ntry:\n    _fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n    def _fromUtf8(s):\n        return s\n\ntry:\n    _encoding = QtGui.QApplication.UnicodeUTF8\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig, _encoding)\nexcept AttributeError:\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig)\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(""Form""))\n        Form.resize(529, 329)\n        self.selInfoWidget = QtGui.QWidget(Form)\n        self.selInfoWidget.setGeometry(QtCore.QRect(260, 10, 264, 222))\n        self.selInfoWidget.setObjectName(_fromUtf8(""selInfoWidget""))\n        self.gridLayout = QtGui.QGridLayout(self.selInfoWidget)\n        self.gridLayout.setMargin(0)\n        self.gridLayout.setObjectName(_fromUtf8(""gridLayout""))\n        self.selDescLabel = QtGui.QLabel(self.selInfoWidget)\n        self.selDescLabel.setText(_fromUtf8(""""))\n        self.selDescLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)\n        self.selDescLabel.setWordWrap(True)\n        self.selDescLabel.setObjectName(_fromUtf8(""selDescLabel""))\n        self.gridLayout.addWidget(self.selDescLabel, 0, 0, 1, 1)\n        self.selNameLabel = QtGui.QLabel(self.selInfoWidget)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.selNameLabel.setFont(font)\n        self.selNameLabel.setText(_fromUtf8(""""))\n        self.selNameLabel.setObjectName(_fromUtf8(""selNameLabel""))\n        self.gridLayout.addWidget(self.selNameLabel, 0, 1, 1, 1)\n        self.selectedTree = DataTreeWidget(self.selInfoWidget)\n        self.selectedTree.setObjectName(_fromUtf8(""selectedTree""))\n        self.selectedTree.headerItem().setText(0, _fromUtf8(""1""))\n        self.gridLayout.addWidget(self.selectedTree, 1, 0, 1, 2)\n        self.hoverText = QtGui.QTextEdit(Form)\n        self.hoverText.setGeometry(QtCore.QRect(0, 240, 521, 81))\n        self.hoverText.setObjectName(_fromUtf8(""hoverText""))\n        self.view = FlowchartGraphicsView(Form)\n        self.view.setGeometry(QtCore.QRect(0, 0, 256, 192))\n        self.view.setObjectName(_fromUtf8(""view""))\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(_translate(""Form"", ""Form"", None))\n\nfrom ..flowchart.FlowchartGraphicsView import FlowchartGraphicsView\nfrom ..widgets.DataTreeWidget import DataTreeWidget\n'"
src/third_party/pyqtgraph/flowchart/FlowchartTemplate_pyqt5.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/flowchart/FlowchartTemplate.ui\'\n#\n# Created: Wed Mar 26 15:09:28 2014\n#      by: PyQt5 UI code generator 5.0.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(529, 329)\n        self.selInfoWidget = QtWidgets.QWidget(Form)\n        self.selInfoWidget.setGeometry(QtCore.QRect(260, 10, 264, 222))\n        self.selInfoWidget.setObjectName(""selInfoWidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.selInfoWidget)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.selDescLabel = QtWidgets.QLabel(self.selInfoWidget)\n        self.selDescLabel.setText("""")\n        self.selDescLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)\n        self.selDescLabel.setWordWrap(True)\n        self.selDescLabel.setObjectName(""selDescLabel"")\n        self.gridLayout.addWidget(self.selDescLabel, 0, 0, 1, 1)\n        self.selNameLabel = QtWidgets.QLabel(self.selInfoWidget)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.selNameLabel.setFont(font)\n        self.selNameLabel.setText("""")\n        self.selNameLabel.setObjectName(""selNameLabel"")\n        self.gridLayout.addWidget(self.selNameLabel, 0, 1, 1, 1)\n        self.selectedTree = DataTreeWidget(self.selInfoWidget)\n        self.selectedTree.setObjectName(""selectedTree"")\n        self.selectedTree.headerItem().setText(0, ""1"")\n        self.gridLayout.addWidget(self.selectedTree, 1, 0, 1, 2)\n        self.hoverText = QtWidgets.QTextEdit(Form)\n        self.hoverText.setGeometry(QtCore.QRect(0, 240, 521, 81))\n        self.hoverText.setObjectName(""hoverText"")\n        self.view = FlowchartGraphicsView(Form)\n        self.view.setGeometry(QtCore.QRect(0, 0, 256, 192))\n        self.view.setObjectName(""view"")\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Form""))\n\nfrom ..widgets.DataTreeWidget import DataTreeWidget\nfrom ..flowchart.FlowchartGraphicsView import FlowchartGraphicsView\n'"
src/third_party/pyqtgraph/flowchart/FlowchartTemplate_pyside.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/flowchart/FlowchartTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:51 2013\n#      by: pyside-uic 0.2.14 running on PySide 1.1.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide import QtCore, QtGui\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(529, 329)\n        self.selInfoWidget = QtGui.QWidget(Form)\n        self.selInfoWidget.setGeometry(QtCore.QRect(260, 10, 264, 222))\n        self.selInfoWidget.setObjectName(""selInfoWidget"")\n        self.gridLayout = QtGui.QGridLayout(self.selInfoWidget)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.selDescLabel = QtGui.QLabel(self.selInfoWidget)\n        self.selDescLabel.setText("""")\n        self.selDescLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)\n        self.selDescLabel.setWordWrap(True)\n        self.selDescLabel.setObjectName(""selDescLabel"")\n        self.gridLayout.addWidget(self.selDescLabel, 0, 0, 1, 1)\n        self.selNameLabel = QtGui.QLabel(self.selInfoWidget)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.selNameLabel.setFont(font)\n        self.selNameLabel.setText("""")\n        self.selNameLabel.setObjectName(""selNameLabel"")\n        self.gridLayout.addWidget(self.selNameLabel, 0, 1, 1, 1)\n        self.selectedTree = DataTreeWidget(self.selInfoWidget)\n        self.selectedTree.setObjectName(""selectedTree"")\n        self.selectedTree.headerItem().setText(0, ""1"")\n        self.gridLayout.addWidget(self.selectedTree, 1, 0, 1, 2)\n        self.hoverText = QtGui.QTextEdit(Form)\n        self.hoverText.setGeometry(QtCore.QRect(0, 240, 521, 81))\n        self.hoverText.setObjectName(""hoverText"")\n        self.view = FlowchartGraphicsView(Form)\n        self.view.setGeometry(QtCore.QRect(0, 0, 256, 192))\n        self.view.setObjectName(""view"")\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtGui.QApplication.translate(""Form"", ""Form"", None, QtGui.QApplication.UnicodeUTF8))\n\nfrom ..flowchart.FlowchartGraphicsView import FlowchartGraphicsView\nfrom ..widgets.DataTreeWidget import DataTreeWidget\n'"
src/third_party/pyqtgraph/flowchart/FlowchartTemplate_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'FlowchartTemplate.ui\'\n#\n# Created: Sun Sep 18 19:16:03 2016\n#      by: pyside2-uic  running on PySide2 2.0.0~alpha0\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide2 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(529, 329)\n        self.selInfoWidget = QtWidgets.QWidget(Form)\n        self.selInfoWidget.setGeometry(QtCore.QRect(260, 10, 264, 222))\n        self.selInfoWidget.setObjectName(""selInfoWidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.selInfoWidget)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.selDescLabel = QtWidgets.QLabel(self.selInfoWidget)\n        self.selDescLabel.setText("""")\n        self.selDescLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)\n        self.selDescLabel.setWordWrap(True)\n        self.selDescLabel.setObjectName(""selDescLabel"")\n        self.gridLayout.addWidget(self.selDescLabel, 0, 0, 1, 1)\n        self.selNameLabel = QtWidgets.QLabel(self.selInfoWidget)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.selNameLabel.setFont(font)\n        self.selNameLabel.setText("""")\n        self.selNameLabel.setObjectName(""selNameLabel"")\n        self.gridLayout.addWidget(self.selNameLabel, 0, 1, 1, 1)\n        self.selectedTree = DataTreeWidget(self.selInfoWidget)\n        self.selectedTree.setObjectName(""selectedTree"")\n        self.selectedTree.headerItem().setText(0, ""1"")\n        self.gridLayout.addWidget(self.selectedTree, 1, 0, 1, 2)\n        self.hoverText = QtWidgets.QTextEdit(Form)\n        self.hoverText.setGeometry(QtCore.QRect(0, 240, 521, 81))\n        self.hoverText.setObjectName(""hoverText"")\n        self.view = FlowchartGraphicsView(Form)\n        self.view.setGeometry(QtCore.QRect(0, 0, 256, 192))\n        self.view.setObjectName(""view"")\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtWidgets.QApplication.translate(""Form"", ""Form"", None, -1))\n\nfrom ..flowchart.FlowchartGraphicsView import FlowchartGraphicsView\nfrom ..widgets.DataTreeWidget import DataTreeWidget\n'"
src/third_party/pyqtgraph/flowchart/Node.py,1,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtCore, QtGui\nfrom ..graphicsItems.GraphicsObject import GraphicsObject\nfrom .. import functions as fn\nfrom .Terminal import *\nfrom ..pgcollections import OrderedDict\nfrom ..debug import *\nimport numpy as np\n\n\ndef strDict(d):\n    return dict([(str(k), v) for k, v in d.items()])\n\nclass Node(QtCore.QObject):\n    """"""\n    Node represents the basic processing unit of a flowchart. \n    A Node subclass implements at least:\n    \n    1) A list of input / ouptut terminals and their properties\n    2) a process() function which takes the names of input terminals as keyword arguments and returns a dict with the names of output terminals as keys.\n\n    A flowchart thus consists of multiple instances of Node subclasses, each of which is connected\n    to other by wires between their terminals. A flowchart is, itself, also a special subclass of Node.\n    This allows Nodes within the flowchart to connect to the input/output nodes of the flowchart itself.\n\n    Optionally, a node class can implement the ctrlWidget() method, which must return a QWidget (usually containing other widgets) that will be displayed in the flowchart control panel. Some nodes implement fairly complex control widgets, but most nodes follow a simple form-like pattern: a list of parameter names and a single value (represented as spin box, check box, etc..) for each parameter. To make this easier, the CtrlNode subclass allows you to instead define a simple data structure that CtrlNode will use to automatically generate the control widget.     """"""\n    \n    sigOutputChanged = QtCore.Signal(object)   # self\n    sigClosed = QtCore.Signal(object)\n    sigRenamed = QtCore.Signal(object, object)\n    sigTerminalRenamed = QtCore.Signal(object, object)  # term, oldName\n    sigTerminalAdded = QtCore.Signal(object, object)  # self, term\n    sigTerminalRemoved = QtCore.Signal(object, object)  # self, term\n\n    \n    def __init__(self, name, terminals=None, allowAddInput=False, allowAddOutput=False, allowRemove=True):\n        """"""\n        ==============  ============================================================\n        **Arguments:**\n        name            The name of this specific node instance. It can be any \n                        string, but must be unique within a flowchart. Usually,\n                        we simply let the flowchart decide on a name when calling\n                        Flowchart.addNode(...)\n        terminals       Dict-of-dicts specifying the terminals present on this Node.\n                        Terminal specifications look like::\n                        \n                            \'inputTerminalName\': {\'io\': \'in\'}\n                            \'outputTerminalName\': {\'io\': \'out\'} \n                            \n                        There are a number of optional parameters for terminals:\n                        multi, pos, renamable, removable, multiable, bypass. See\n                        the Terminal class for more information.\n        allowAddInput   bool; whether the user is allowed to add inputs by the\n                        context menu.\n        allowAddOutput  bool; whether the user is allowed to add outputs by the\n                        context menu.\n        allowRemove     bool; whether the user is allowed to remove this node by the\n                        context menu.\n        ==============  ============================================================  \n        \n        """"""\n        QtCore.QObject.__init__(self)\n        self._name = name\n        self._bypass = False\n        self.bypassButton = None  ## this will be set by the flowchart ctrl widget..\n        self._graphicsItem = None\n        self.terminals = OrderedDict()\n        self._inputs = OrderedDict()\n        self._outputs = OrderedDict()\n        self._allowAddInput = allowAddInput   ## flags to allow the user to add/remove terminals\n        self._allowAddOutput = allowAddOutput\n        self._allowRemove = allowRemove\n        \n        self.exception = None\n        if terminals is None:\n            return\n        for name, opts in terminals.items():\n            self.addTerminal(name, **opts)\n\n        \n    def nextTerminalName(self, name):\n        """"""Return an unused terminal name""""""\n        name2 = name\n        i = 1\n        while name2 in self.terminals:\n            name2 = ""%s.%d"" % (name, i)\n            i += 1\n        return name2\n        \n    def addInput(self, name=""Input"", **args):\n        """"""Add a new input terminal to this Node with the given name. Extra\n        keyword arguments are passed to Terminal.__init__.\n        \n        This is a convenience function that just calls addTerminal(io=\'in\', ...)""""""\n        #print ""Node.addInput called.""\n        return self.addTerminal(name, io=\'in\', **args)\n        \n    def addOutput(self, name=""Output"", **args):\n        """"""Add a new output terminal to this Node with the given name. Extra\n        keyword arguments are passed to Terminal.__init__.\n        \n        This is a convenience function that just calls addTerminal(io=\'out\', ...)""""""\n        return self.addTerminal(name, io=\'out\', **args)\n        \n    def removeTerminal(self, term):\n        """"""Remove the specified terminal from this Node. May specify either the \n        terminal\'s name or the terminal itself.\n        \n        Causes sigTerminalRemoved to be emitted.""""""\n        if isinstance(term, Terminal):\n            name = term.name()\n        else:\n            name = term\n            term = self.terminals[name]\n        \n        #print ""remove"", name\n        #term.disconnectAll()\n        term.close()\n        del self.terminals[name]\n        if name in self._inputs:\n            del self._inputs[name]\n        if name in self._outputs:\n            del self._outputs[name]\n        self.graphicsItem().updateTerminals()\n        self.sigTerminalRemoved.emit(self, term)\n        \n        \n    def terminalRenamed(self, term, oldName):\n        """"""Called after a terminal has been renamed        \n        \n        Causes sigTerminalRenamed to be emitted.""""""\n        newName = term.name()\n        for d in [self.terminals, self._inputs, self._outputs]:\n            if oldName not in d:\n                continue\n            d[newName] = d[oldName]\n            del d[oldName]\n            \n        self.graphicsItem().updateTerminals()\n        self.sigTerminalRenamed.emit(term, oldName)\n        \n    def addTerminal(self, name, **opts):\n        """"""Add a new terminal to this Node with the given name. Extra\n        keyword arguments are passed to Terminal.__init__.\n                \n        Causes sigTerminalAdded to be emitted.""""""\n        name = self.nextTerminalName(name)\n        term = Terminal(self, name, **opts)\n        self.terminals[name] = term\n        if term.isInput():\n            self._inputs[name] = term\n        elif term.isOutput():\n            self._outputs[name] = term\n        self.graphicsItem().updateTerminals()\n        self.sigTerminalAdded.emit(self, term)\n        return term\n\n        \n    def inputs(self):\n        """"""Return dict of all input terminals.\n        Warning: do not modify.""""""\n        return self._inputs\n        \n    def outputs(self):\n        """"""Return dict of all output terminals.\n        Warning: do not modify.""""""\n        return self._outputs\n        \n    def process(self, **kargs):\n        """"""Process data through this node. This method is called any time the flowchart \n        wants the node to process data. It will be called with one keyword argument\n        corresponding to each input terminal, and must return a dict mapping the name\n        of each output terminal to its new value.\n        \n        This method is also called with a \'display\' keyword argument, which indicates\n        whether the node should update its display (if it implements any) while processing\n        this data. This is primarily used to disable expensive display operations\n        during batch processing.\n        """"""\n        return {}\n    \n    def graphicsItem(self):\n        """"""Return the GraphicsItem for this node. Subclasses may re-implement\n        this method to customize their appearance in the flowchart.""""""\n        if self._graphicsItem is None:\n            self._graphicsItem = NodeGraphicsItem(self)\n        return self._graphicsItem\n    \n    ## this is just bad planning. Causes too many bugs.\n    def __getattr__(self, attr):\n        """"""Return the terminal with the given name""""""\n        if attr not in self.terminals:\n            raise AttributeError(attr)\n        else:\n            import traceback\n            traceback.print_stack()\n            print(""Warning: use of node.terminalName is deprecated; use node[\'terminalName\'] instead."")\n            return self.terminals[attr]\n            \n    def __getitem__(self, item):\n        #return getattr(self, item)\n        """"""Return the terminal with the given name""""""\n        if item not in self.terminals:\n            raise KeyError(item)\n        else:\n            return self.terminals[item]\n            \n    def name(self):\n        """"""Return the name of this node.""""""\n        return self._name\n\n    def rename(self, name):\n        """"""Rename this node. This will cause sigRenamed to be emitted.""""""\n        oldName = self._name\n        self._name = name\n        #self.emit(QtCore.SIGNAL(\'renamed\'), self, oldName)\n        self.sigRenamed.emit(self, oldName)\n\n    def dependentNodes(self):\n        """"""Return the list of nodes which provide direct input to this node""""""\n        nodes = set()\n        for t in self.inputs().values():\n            nodes |= set([i.node() for i in t.inputTerminals()])\n        return nodes\n        #return set([t.inputTerminals().node() for t in self.listInputs().values()])\n        \n    def __repr__(self):\n        return ""<Node %s @%x>"" % (self.name(), id(self))\n        \n    def ctrlWidget(self):\n        """"""Return this Node\'s control widget. \n        \n        By default, Nodes have no control widget. Subclasses may reimplement this \n        method to provide a custom widget. This method is called by Flowcharts\n        when they are constructing their Node list.""""""\n        return None\n\n    def bypass(self, byp):\n        """"""Set whether this node should be bypassed.\n        \n        When bypassed, a Node\'s process() method is never called. In some cases,\n        data is automatically copied directly from specific input nodes to \n        output nodes instead (see the bypass argument to Terminal.__init__). \n        This is usually called when the user disables a node from the flowchart \n        control panel.\n        """"""\n        self._bypass = byp\n        if self.bypassButton is not None:\n            self.bypassButton.setChecked(byp)\n        self.update()\n        \n    def isBypassed(self):\n        """"""Return True if this Node is currently bypassed.""""""\n        return self._bypass\n\n    def setInput(self, **args):\n        """"""Set the values on input terminals. For most nodes, this will happen automatically through Terminal.inputChanged.\n        This is normally only used for nodes with no connected inputs.""""""\n        changed = False\n        for k, v in args.items():\n            term = self._inputs[k]\n            oldVal = term.value()\n            if not fn.eq(oldVal, v):\n                changed = True\n            term.setValue(v, process=False)\n        if changed and \'_updatesHandled_\' not in args:\n            self.update()\n        \n    def inputValues(self):\n        """"""Return a dict of all input values currently assigned to this node.""""""\n        vals = {}\n        for n, t in self.inputs().items():\n            vals[n] = t.value()\n        return vals\n            \n    def outputValues(self):\n        """"""Return a dict of all output values currently generated by this node.""""""\n        vals = {}\n        for n, t in self.outputs().items():\n            vals[n] = t.value()\n        return vals\n            \n    def connected(self, localTerm, remoteTerm):\n        """"""Called whenever one of this node\'s terminals is connected elsewhere.""""""\n        pass\n    \n    def disconnected(self, localTerm, remoteTerm):\n        """"""Called whenever one of this node\'s terminals is disconnected from another.""""""\n        pass \n    \n    def update(self, signal=True):\n        """"""Collect all input values, attempt to process new output values, and propagate downstream.\n        Subclasses should call update() whenever thir internal state has changed\n        (such as when the user interacts with the Node\'s control widget). Update\n        is automatically called when the inputs to the node are changed.\n        """"""\n        vals = self.inputValues()\n        #print ""  inputs:"", vals\n        try:\n            if self.isBypassed():\n                out = self.processBypassed(vals)\n            else:\n                out = self.process(**strDict(vals))\n            #print ""  output:"", out\n            if out is not None:\n                if signal:\n                    self.setOutput(**out)\n                else:\n                    self.setOutputNoSignal(**out)\n            for n,t in self.inputs().items():\n                t.setValueAcceptable(True)\n            self.clearException()\n        except:\n            #printExc( ""Exception while processing %s:"" % self.name())\n            for n,t in self.outputs().items():\n                t.setValue(None)\n            self.setException(sys.exc_info())\n            \n            if signal:\n                #self.emit(QtCore.SIGNAL(\'outputChanged\'), self)  ## triggers flowchart to propagate new data\n                self.sigOutputChanged.emit(self)  ## triggers flowchart to propagate new data\n\n    def processBypassed(self, args):\n        """"""Called when the flowchart would normally call Node.process, but this node is currently bypassed.\n        The default implementation looks for output terminals with a bypass connection and returns the\n        corresponding values. Most Node subclasses will _not_ need to reimplement this method.""""""\n        result = {}\n        for term in list(self.outputs().values()):\n            byp = term.bypassValue()\n            if byp is None:\n                result[term.name()] = None\n            else:\n                result[term.name()] = args.get(byp, None)\n        return result\n\n    def setOutput(self, **vals):\n        self.setOutputNoSignal(**vals)\n        #self.emit(QtCore.SIGNAL(\'outputChanged\'), self)  ## triggers flowchart to propagate new data\n        self.sigOutputChanged.emit(self)  ## triggers flowchart to propagate new data\n\n    def setOutputNoSignal(self, **vals):\n        for k, v in vals.items():\n            term = self.outputs()[k]\n            term.setValue(v)\n            #targets = term.connections()\n            #for t in targets:  ## propagate downstream\n                #if t is term:\n                    #continue\n                #t.inputChanged(term)\n            term.setValueAcceptable(True)\n\n    def setException(self, exc):\n        self.exception = exc\n        self.recolor()\n        \n    def clearException(self):\n        self.setException(None)\n        \n    def recolor(self):\n        if self.exception is None:\n            self.graphicsItem().setPen(QtGui.QPen(QtGui.QColor(0, 0, 0)))\n        else:\n            self.graphicsItem().setPen(QtGui.QPen(QtGui.QColor(150, 0, 0), 3))\n\n    def saveState(self):\n        """"""Return a dictionary representing the current state of this node\n        (excluding input / output values). This is used for saving/reloading\n        flowcharts. The default implementation returns this Node\'s position,\n        bypass state, and information about each of its terminals. \n        \n        Subclasses may want to extend this method, adding extra keys to the returned\n        dict.""""""\n        pos = self.graphicsItem().pos()\n        state = {\'pos\': (pos.x(), pos.y()), \'bypass\': self.isBypassed()}\n        termsEditable = self._allowAddInput | self._allowAddOutput\n        for term in self._inputs.values() + self._outputs.values():\n            termsEditable |= term._renamable | term._removable | term._multiable\n        if termsEditable:\n            state[\'terminals\'] = self.saveTerminals()\n        return state\n        \n    def restoreState(self, state):\n        """"""Restore the state of this node from a structure previously generated\n        by saveState(). """"""\n        pos = state.get(\'pos\', (0,0))\n        self.graphicsItem().setPos(*pos)\n        self.bypass(state.get(\'bypass\', False))\n        if \'terminals\' in state:\n            self.restoreTerminals(state[\'terminals\'])\n\n    def saveTerminals(self):\n        terms = OrderedDict()\n        for n, t in self.terminals.items():\n            terms[n] = (t.saveState())\n        return terms\n        \n    def restoreTerminals(self, state):\n        for name in list(self.terminals.keys()):\n            if name not in state:\n                self.removeTerminal(name)\n        for name, opts in state.items():\n            if name in self.terminals:\n                term = self[name]\n                term.setOpts(**opts)\n                continue\n            try:\n                opts = strDict(opts)\n                self.addTerminal(name, **opts)\n            except:\n                printExc(""Error restoring terminal %s (%s):"" % (str(name), str(opts)))\n                \n        \n    def clearTerminals(self):\n        for t in self.terminals.values():\n            t.close()\n        self.terminals = OrderedDict()\n        self._inputs = OrderedDict()\n        self._outputs = OrderedDict()\n        \n    def close(self):\n        """"""Cleans up after the node--removes terminals, graphicsItem, widget""""""\n        self.disconnectAll()\n        self.clearTerminals()\n        item = self.graphicsItem()\n        if item.scene() is not None:\n            item.scene().removeItem(item)\n        self._graphicsItem = None\n        w = self.ctrlWidget()\n        if w is not None:\n            w.setParent(None)\n        #self.emit(QtCore.SIGNAL(\'closed\'), self)\n        self.sigClosed.emit(self)\n            \n    def disconnectAll(self):\n        for t in self.terminals.values():\n            t.disconnectAll()\n    \n\n#class NodeGraphicsItem(QtGui.QGraphicsItem):\nclass NodeGraphicsItem(GraphicsObject):\n    def __init__(self, node):\n        #QtGui.QGraphicsItem.__init__(self)\n        GraphicsObject.__init__(self)\n        #QObjectWorkaround.__init__(self)\n        \n        #self.shadow = QtGui.QGraphicsDropShadowEffect()\n        #self.shadow.setOffset(5,5)\n        #self.shadow.setBlurRadius(10)\n        #self.setGraphicsEffect(self.shadow)\n        \n        self.pen = fn.mkPen(0,0,0)\n        self.selectPen = fn.mkPen(200,200,200,width=2)\n        self.brush = fn.mkBrush(200, 200, 200, 150)\n        self.hoverBrush = fn.mkBrush(200, 200, 200, 200)\n        self.selectBrush = fn.mkBrush(200, 200, 255, 200)\n        self.hovered = False\n        \n        self.node = node\n        flags = self.ItemIsMovable | self.ItemIsSelectable | self.ItemIsFocusable |self.ItemSendsGeometryChanges\n        #flags =  self.ItemIsFocusable |self.ItemSendsGeometryChanges\n\n        self.setFlags(flags)\n        self.bounds = QtCore.QRectF(0, 0, 100, 100)\n        self.nameItem = QtGui.QGraphicsTextItem(self.node.name(), self)\n        self.nameItem.setDefaultTextColor(QtGui.QColor(50, 50, 50))\n        self.nameItem.moveBy(self.bounds.width()/2. - self.nameItem.boundingRect().width()/2., 0)\n        self.nameItem.setTextInteractionFlags(QtCore.Qt.TextEditorInteraction)\n        self.updateTerminals()\n        #self.setZValue(10)\n\n        self.nameItem.focusOutEvent = self.labelFocusOut\n        self.nameItem.keyPressEvent = self.labelKeyPress\n        \n        self.menu = None\n        self.buildMenu()\n        \n        #self.node.sigTerminalRenamed.connect(self.updateActionMenu)\n        \n    #def setZValue(self, z):\n        #for t, item in self.terminals.values():\n            #item.setZValue(z+1)\n        #GraphicsObject.setZValue(self, z)\n        \n    def labelFocusOut(self, ev):\n        QtGui.QGraphicsTextItem.focusOutEvent(self.nameItem, ev)\n        self.labelChanged()\n        \n    def labelKeyPress(self, ev):\n        if ev.key() == QtCore.Qt.Key_Enter or ev.key() == QtCore.Qt.Key_Return:\n            self.labelChanged()\n        else:\n            QtGui.QGraphicsTextItem.keyPressEvent(self.nameItem, ev)\n        \n    def labelChanged(self):\n        newName = str(self.nameItem.toPlainText())\n        if newName != self.node.name():\n            self.node.rename(newName)\n            \n        ### re-center the label\n        bounds = self.boundingRect()\n        self.nameItem.setPos(bounds.width()/2. - self.nameItem.boundingRect().width()/2., 0)\n\n    def setPen(self, *args, **kwargs):\n        self.pen = fn.mkPen(*args, **kwargs)\n        self.update()\n        \n    def setBrush(self, brush):\n        self.brush = brush\n        self.update()\n        \n        \n    def updateTerminals(self):\n        bounds = self.bounds\n        self.terminals = {}\n        inp = self.node.inputs()\n        dy = bounds.height() / (len(inp)+1)\n        y = dy\n        for i, t in inp.items():\n            item = t.graphicsItem()\n            item.setParentItem(self)\n            #item.setZValue(self.zValue()+1)\n            br = self.bounds\n            item.setAnchor(0, y)\n            self.terminals[i] = (t, item)\n            y += dy\n        \n        out = self.node.outputs()\n        dy = bounds.height() / (len(out)+1)\n        y = dy\n        for i, t in out.items():\n            item = t.graphicsItem()\n            item.setParentItem(self)\n            item.setZValue(self.zValue())\n            br = self.bounds\n            item.setAnchor(bounds.width(), y)\n            self.terminals[i] = (t, item)\n            y += dy\n        \n        #self.buildMenu()\n        \n        \n    def boundingRect(self):\n        return self.bounds.adjusted(-5, -5, 5, 5)\n        \n    def paint(self, p, *args):\n        \n        p.setPen(self.pen)\n        if self.isSelected():\n            p.setPen(self.selectPen)\n            p.setBrush(self.selectBrush)\n        else:\n            p.setPen(self.pen)\n            if self.hovered:\n                p.setBrush(self.hoverBrush)\n            else:\n                p.setBrush(self.brush)\n                \n        p.drawRect(self.bounds)\n\n        \n    def mousePressEvent(self, ev):\n        ev.ignore()\n\n\n    def mouseClickEvent(self, ev):\n        #print ""Node.mouseClickEvent called.""\n        if int(ev.button()) == int(QtCore.Qt.LeftButton):\n            ev.accept()\n            #print ""    ev.button: left""\n            sel = self.isSelected()\n            #ret = QtGui.QGraphicsItem.mousePressEvent(self, ev)\n            self.setSelected(True)\n            if not sel and self.isSelected():\n                #self.setBrush(QtGui.QBrush(QtGui.QColor(200, 200, 255)))\n                #self.emit(QtCore.SIGNAL(\'selected\'))\n                #self.scene().selectionChanged.emit() ## for some reason this doesn\'t seem to be happening automatically\n                self.update()\n            #return ret\n        \n        elif int(ev.button()) == int(QtCore.Qt.RightButton):\n            #print ""    ev.button: right""\n            ev.accept()\n            #pos = ev.screenPos()\n            self.raiseContextMenu(ev)\n            #self.menu.popup(QtCore.QPoint(pos.x(), pos.y()))\n            \n    def mouseDragEvent(self, ev):\n        #print ""Node.mouseDrag""\n        if ev.button() == QtCore.Qt.LeftButton:\n            ev.accept()\n            self.setPos(self.pos()+self.mapToParent(ev.pos())-self.mapToParent(ev.lastPos()))\n        \n    def hoverEvent(self, ev):\n        if not ev.isExit() and ev.acceptClicks(QtCore.Qt.LeftButton):\n            ev.acceptDrags(QtCore.Qt.LeftButton)\n            self.hovered = True\n        else:\n            self.hovered = False\n        self.update()\n            \n    def keyPressEvent(self, ev):\n        if ev.key() == QtCore.Qt.Key_Delete or ev.key() == QtCore.Qt.Key_Backspace:\n            ev.accept()\n            if not self.node._allowRemove:\n                return\n            self.node.close()\n        else:\n            ev.ignore()\n\n    def itemChange(self, change, val):\n        if change == self.ItemPositionHasChanged:\n            for k, t in self.terminals.items():\n                t[1].nodeMoved()\n        return GraphicsObject.itemChange(self, change, val)\n            \n\n    def getMenu(self):\n        return self.menu\n    \n    def raiseContextMenu(self, ev):\n        menu = self.scene().addParentContextMenus(self, self.getMenu(), ev)\n        pos = ev.screenPos()\n        menu.popup(QtCore.QPoint(pos.x(), pos.y()))\n        \n    def buildMenu(self):\n        self.menu = QtGui.QMenu()\n        self.menu.setTitle(""Node"")\n        a = self.menu.addAction(""Add input"", self.addInputFromMenu)\n        if not self.node._allowAddInput:\n            a.setEnabled(False)\n        a = self.menu.addAction(""Add output"", self.addOutputFromMenu)\n        if not self.node._allowAddOutput:\n            a.setEnabled(False)\n        a = self.menu.addAction(""Remove node"", self.node.close)\n        if not self.node._allowRemove:\n            a.setEnabled(False)\n        \n    def addInputFromMenu(self):  ## called when add input is clicked in context menu\n        self.node.addInput(renamable=True, removable=True, multiable=True)\n        \n    def addOutputFromMenu(self):  ## called when add output is clicked in context menu\n        self.node.addOutput(renamable=True, removable=True, multiable=False)\n        \n'"
src/third_party/pyqtgraph/flowchart/NodeLibrary.py,0,"b'from ..pgcollections import OrderedDict\nfrom .Node import Node\n\ndef isNodeClass(cls):\n    try:\n        if not issubclass(cls, Node):\n            return False\n    except:\n        return False\n    return hasattr(cls, \'nodeName\')\n\n\n\nclass NodeLibrary:\n    """"""\n    A library of flowchart Node types. Custom libraries may be built to provide \n    each flowchart with a specific set of allowed Node types.\n    """"""\n\n    def __init__(self):\n        self.nodeList = OrderedDict()\n        self.nodeTree = OrderedDict()\n        \n    def addNodeType(self, nodeClass, paths, override=False):\n        """"""\n        Register a new node type. If the type\'s name is already in use,\n        an exception will be raised (unless override=True).\n        \n        ============== =========================================================\n        **Arguments:**\n        \n        nodeClass      a subclass of Node (must have typ.nodeName)\n        paths          list of tuples specifying the location(s) this \n                       type will appear in the library tree.\n        override       if True, overwrite any class having the same name\n        ============== =========================================================\n        """"""\n        if not isNodeClass(nodeClass):\n            raise Exception(""Object %s is not a Node subclass"" % str(nodeClass))\n        \n        name = nodeClass.nodeName\n        if not override and name in self.nodeList:\n            raise Exception(""Node type name \'%s\' is already registered."" % name)\n        \n        self.nodeList[name] = nodeClass\n        for path in paths:\n            root = self.nodeTree\n            for n in path:\n                if n not in root:\n                    root[n] = OrderedDict()\n                root = root[n]\n            root[name] = nodeClass\n\n    def getNodeType(self, name):\n        try:\n            return self.nodeList[name]\n        except KeyError:\n            raise Exception(""No node type called \'%s\'"" % name)\n\n    def getNodeTree(self):\n        return self.nodeTree\n\n    def copy(self):\n        """"""\n        Return a copy of this library.\n        """"""\n        lib = NodeLibrary()\n        lib.nodeList = self.nodeList.copy()\n        lib.nodeTree = self.treeCopy(self.nodeTree)\n        return lib\n\n    @staticmethod\n    def treeCopy(tree):\n        copy = OrderedDict()\n        for k,v in tree.items():\n            if isNodeClass(v):\n                copy[k] = v\n            else:\n                copy[k] = NodeLibrary.treeCopy(v)\n        return copy\n\n    def reload(self):\n        """"""\n        Reload Node classes in this library.\n        """"""\n        raise NotImplementedError()\n'"
src/third_party/pyqtgraph/flowchart/Terminal.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtCore, QtGui\nimport weakref\nfrom ..graphicsItems.GraphicsObject import GraphicsObject\nfrom .. import functions as fn\nfrom ..Point import Point\n\n\nclass Terminal(object):\n    def __init__(self, node, name, io, optional=False, multi=False, pos=None, renamable=False, removable=False, multiable=False, bypass=None):\n        """"""\n        Construct a new terminal. \n        \n        ==============  =================================================================================\n        **Arguments:**\n        node            the node to which this terminal belongs\n        name            string, the name of the terminal\n        io              \'in\' or \'out\'\n        optional        bool, whether the node may process without connection to this terminal\n        multi           bool, for inputs: whether this terminal may make multiple connections\n                        for outputs: whether this terminal creates a different value for each connection\n        pos             [x, y], the position of the terminal within its node\'s boundaries\n        renamable       (bool) Whether the terminal can be renamed by the user\n        removable       (bool) Whether the terminal can be removed by the user\n        multiable       (bool) Whether the user may toggle the *multi* option for this terminal\n        bypass          (str) Name of the terminal from which this terminal\'s value is derived\n                        when the Node is in bypass mode.\n        ==============  =================================================================================\n        """"""\n        self._io = io\n        self._optional = optional\n        self._multi = multi\n        self._node = weakref.ref(node)\n        self._name = name\n        self._renamable = renamable\n        self._removable = removable\n        self._multiable = multiable\n        self._connections = {}\n        self._graphicsItem = TerminalGraphicsItem(self, parent=self._node().graphicsItem())\n        self._bypass = bypass\n        \n        if multi:\n            self._value = {}  ## dictionary of terminal:value pairs.\n        else:\n            self._value = None  \n        \n        self.valueOk = None\n        self.recolor()\n        \n    def value(self, term=None):\n        """"""Return the value this terminal provides for the connected terminal""""""\n        if term is None:\n            return self._value\n            \n        if self.isMultiValue():\n            return self._value.get(term, None)\n        else:\n            return self._value\n\n    def bypassValue(self):\n        return self._bypass\n\n    def setValue(self, val, process=True):\n        """"""If this is a single-value terminal, val should be a single value.\n        If this is a multi-value terminal, val should be a dict of terminal:value pairs""""""\n        if not self.isMultiValue():\n            if fn.eq(val, self._value):\n                return\n            self._value = val\n        else:\n            if not isinstance(self._value, dict):\n                self._value = {}\n            if val is not None:\n                self._value.update(val)\n            \n        self.setValueAcceptable(None)  ## by default, input values are \'unchecked\' until Node.update(). \n        if self.isInput() and process:\n            self.node().update()\n            \n        self.recolor()\n        \n    def setOpts(self, **opts):\n        self._renamable = opts.get(\'renamable\', self._renamable)\n        self._removable = opts.get(\'removable\', self._removable)\n        self._multiable = opts.get(\'multiable\', self._multiable)\n        if \'multi\' in opts:\n            self.setMultiValue(opts[\'multi\'])\n\n    def connected(self, term):\n        """"""Called whenever this terminal has been connected to another. (note--this function is called on both terminals)""""""\n        if self.isInput() and term.isOutput():\n            self.inputChanged(term)\n        if self.isOutput() and self.isMultiValue():\n            self.node().update()\n        self.node().connected(self, term)\n        \n    def disconnected(self, term):\n        """"""Called whenever this terminal has been disconnected from another. (note--this function is called on both terminals)""""""\n        if self.isMultiValue() and term in self._value:\n            del self._value[term]\n            self.node().update()\n        else:\n            if self.isInput():\n                self.setValue(None)\n        self.node().disconnected(self, term)\n\n    def inputChanged(self, term, process=True):\n        """"""Called whenever there is a change to the input value to this terminal.\n        It may often be useful to override this function.""""""\n        if self.isMultiValue():\n            self.setValue({term: term.value(self)}, process=process)\n        else:\n            self.setValue(term.value(self), process=process)\n            \n    def valueIsAcceptable(self):\n        """"""Returns True->acceptable  None->unknown  False->Unacceptable""""""\n        return self.valueOk\n        \n    def setValueAcceptable(self, v=True):\n        self.valueOk = v\n        self.recolor()\n        \n    def connections(self):\n        return self._connections\n        \n    def node(self):\n        return self._node()\n        \n    def isInput(self):\n        return self._io == \'in\'\n    \n    def isMultiValue(self):\n        return self._multi\n    \n    def setMultiValue(self, multi):\n        """"""Set whether this is a multi-value terminal.""""""\n        self._multi = multi\n        if not multi and len(self.inputTerminals()) > 1:\n            self.disconnectAll()\n            \n        for term in self.inputTerminals():\n            self.inputChanged(term)\n\n    def isOutput(self):\n        return self._io == \'out\'\n        \n    def isRenamable(self):\n        return self._renamable\n\n    def isRemovable(self):\n        return self._removable\n\n    def isMultiable(self):\n        return self._multiable\n\n    def name(self):\n        return self._name\n        \n    def graphicsItem(self):\n        return self._graphicsItem\n        \n    def isConnected(self):\n        return len(self.connections()) > 0\n        \n    def connectedTo(self, term):\n        return term in self.connections()\n        \n    def hasInput(self):\n        for t in self.connections():\n            if t.isOutput():\n                return True\n        return False        \n        \n    def inputTerminals(self):\n        """"""Return the terminal(s) that give input to this one.""""""\n        return [t for t in self.connections() if t.isOutput()]\n        \n    def dependentNodes(self):\n        """"""Return the list of nodes which receive input from this terminal.""""""\n        return set([t.node() for t in self.connections() if t.isInput()])\n        \n    def connectTo(self, term, connectionItem=None):\n        try:\n            if self.connectedTo(term):\n                raise Exception(\'Already connected\')\n            if term is self:\n                raise Exception(\'Not connecting terminal to self\')\n            if term.node() is self.node():\n                raise Exception(""Can\'t connect to terminal on same node."")\n            for t in [self, term]:\n                if t.isInput() and not t._multi and len(t.connections()) > 0:\n                    raise Exception(""Cannot connect %s <-> %s: Terminal %s is already connected to %s (and does not allow multiple connections)"" % (self, term, t, list(t.connections().keys())))\n        except:\n            if connectionItem is not None:\n                connectionItem.close()\n            raise\n            \n        if connectionItem is None:\n            connectionItem = ConnectionItem(self.graphicsItem(), term.graphicsItem())\n            self.graphicsItem().getViewBox().addItem(connectionItem)\n        self._connections[term] = connectionItem\n        term._connections[self] = connectionItem\n        \n        self.recolor()\n        \n        self.connected(term)\n        term.connected(self)\n        \n        return connectionItem\n        \n    def disconnectFrom(self, term):\n        if not self.connectedTo(term):\n            return\n        item = self._connections[term]\n        item.close()\n        del self._connections[term]\n        del term._connections[self]\n        self.recolor()\n        term.recolor()\n        \n        self.disconnected(term)\n        term.disconnected(self)\n            \n        \n    def disconnectAll(self):\n        for t in list(self._connections.keys()):\n            self.disconnectFrom(t)\n        \n    def recolor(self, color=None, recurse=True):\n        if color is None:\n            if not self.isConnected():       ## disconnected terminals are black\n                color = QtGui.QColor(0,0,0)\n            elif self.isInput() and not self.hasInput():   ## input terminal with no connected output terminals \n                color = QtGui.QColor(200,200,0)\n            elif self._value is None or fn.eq(self._value, {}):  ## terminal is connected but has no data (possibly due to processing error) \n                color = QtGui.QColor(255,255,255)\n            elif self.valueIsAcceptable() is None:   ## terminal has data, but it is unknown if the data is ok\n                color = QtGui.QColor(200, 200, 0)\n            elif self.valueIsAcceptable() is True:   ## terminal has good input, all ok\n                color = QtGui.QColor(0, 200, 0)\n            else:                                    ## terminal has bad input\n                color = QtGui.QColor(200, 0, 0)\n        self.graphicsItem().setBrush(QtGui.QBrush(color))\n        \n        if recurse:\n            for t in self.connections():\n                t.recolor(color, recurse=False)\n        \n    def rename(self, name):\n        oldName = self._name\n        self._name = name\n        self.node().terminalRenamed(self, oldName)\n        self.graphicsItem().termRenamed(name)\n        \n    def __repr__(self):\n        return ""<Terminal %s.%s>"" % (str(self.node().name()), str(self.name()))\n        \n    def __hash__(self):\n        return id(self)\n\n    def close(self):\n        self.disconnectAll()\n        item = self.graphicsItem()\n        if item.scene() is not None:\n            item.scene().removeItem(item)\n        \n    def saveState(self):\n        return {\'io\': self._io, \'multi\': self._multi, \'optional\': self._optional, \'renamable\': self._renamable, \'removable\': self._removable, \'multiable\': self._multiable}\n\n\nclass TerminalGraphicsItem(GraphicsObject):\n    \n    def __init__(self, term, parent=None):\n        self.term = term\n        GraphicsObject.__init__(self, parent)\n        self.brush = fn.mkBrush(0,0,0)\n        self.box = QtGui.QGraphicsRectItem(0, 0, 10, 10, self)\n        self.label = QtGui.QGraphicsTextItem(self.term.name(), self)\n        self.label.scale(0.7, 0.7)\n        self.newConnection = None\n        self.setFiltersChildEvents(True)  ## to pick up mouse events on the rectitem\n        if self.term.isRenamable():\n            self.label.setTextInteractionFlags(QtCore.Qt.TextEditorInteraction)\n            self.label.focusOutEvent = self.labelFocusOut\n            self.label.keyPressEvent = self.labelKeyPress\n        self.setZValue(1)\n        self.menu = None\n\n    def labelFocusOut(self, ev):\n        QtGui.QGraphicsTextItem.focusOutEvent(self.label, ev)\n        self.labelChanged()\n        \n    def labelKeyPress(self, ev):\n        if ev.key() == QtCore.Qt.Key_Enter or ev.key() == QtCore.Qt.Key_Return:\n            self.labelChanged()\n        else:\n            QtGui.QGraphicsTextItem.keyPressEvent(self.label, ev)\n        \n    def labelChanged(self):\n        newName = str(self.label.toPlainText())\n        if newName != self.term.name():\n            self.term.rename(newName)\n\n    def termRenamed(self, name):\n        self.label.setPlainText(name)\n\n    def setBrush(self, brush):\n        self.brush = brush\n        self.box.setBrush(brush)\n\n    def disconnect(self, target):\n        self.term.disconnectFrom(target.term)\n\n    def boundingRect(self):\n        br = self.box.mapRectToParent(self.box.boundingRect())\n        lr = self.label.mapRectToParent(self.label.boundingRect())\n        return br | lr\n        \n    def paint(self, p, *args):\n        pass\n        \n    def setAnchor(self, x, y):\n        pos = QtCore.QPointF(x, y)\n        self.anchorPos = pos\n        br = self.box.mapRectToParent(self.box.boundingRect())\n        lr = self.label.mapRectToParent(self.label.boundingRect())\n        \n        \n        if self.term.isInput():\n            self.box.setPos(pos.x(), pos.y()-br.height()/2.)\n            self.label.setPos(pos.x() + br.width(), pos.y() - lr.height()/2.)\n        else:\n            self.box.setPos(pos.x()-br.width(), pos.y()-br.height()/2.)\n            self.label.setPos(pos.x()-br.width()-lr.width(), pos.y()-lr.height()/2.)\n        self.updateConnections()\n        \n    def updateConnections(self):\n        for t, c in self.term.connections().items():\n            c.updateLine()\n            \n    def mousePressEvent(self, ev):\n        #ev.accept()\n        ev.ignore() ## necessary to allow click/drag events to process correctly\n\n    def mouseClickEvent(self, ev):\n        if ev.button() == QtCore.Qt.LeftButton:\n            ev.accept()\n            self.label.setFocus(QtCore.Qt.MouseFocusReason)\n        elif ev.button() == QtCore.Qt.RightButton:\n            ev.accept()\n            self.raiseContextMenu(ev)\n            \n    def raiseContextMenu(self, ev):\n        ## only raise menu if this terminal is removable\n        menu = self.getMenu()\n        menu = self.scene().addParentContextMenus(self, menu, ev)\n        pos = ev.screenPos()\n        menu.popup(QtCore.QPoint(pos.x(), pos.y()))\n        \n    def getMenu(self):\n        if self.menu is None:\n            self.menu = QtGui.QMenu()\n            self.menu.setTitle(""Terminal"")\n            remAct = QtGui.QAction(""Remove terminal"", self.menu)\n            remAct.triggered.connect(self.removeSelf)\n            self.menu.addAction(remAct)\n            self.menu.remAct = remAct\n            if not self.term.isRemovable():\n                remAct.setEnabled(False)\n            multiAct = QtGui.QAction(""Multi-value"", self.menu)\n            multiAct.setCheckable(True)\n            multiAct.setChecked(self.term.isMultiValue())\n            multiAct.setEnabled(self.term.isMultiable())\n            \n            multiAct.triggered.connect(self.toggleMulti)\n            self.menu.addAction(multiAct)\n            self.menu.multiAct = multiAct\n            if self.term.isMultiable():\n                multiAct.setEnabled = False\n        return self.menu\n\n    def toggleMulti(self):\n        multi = self.menu.multiAct.isChecked()\n        self.term.setMultiValue(multi)\n    \n    def removeSelf(self):\n        self.term.node().removeTerminal(self.term)\n        \n    def mouseDragEvent(self, ev):\n        if ev.button() != QtCore.Qt.LeftButton:\n            ev.ignore()\n            return\n        \n        ev.accept()\n        if ev.isStart():\n            if self.newConnection is None:\n                self.newConnection = ConnectionItem(self)\n                #self.scene().addItem(self.newConnection)\n                self.getViewBox().addItem(self.newConnection)\n                #self.newConnection.setParentItem(self.parent().parent())\n\n            self.newConnection.setTarget(self.mapToView(ev.pos()))\n        elif ev.isFinish():\n            if self.newConnection is not None:\n                items = self.scene().items(ev.scenePos())\n                gotTarget = False\n                for i in items:\n                    if isinstance(i, TerminalGraphicsItem):\n                        self.newConnection.setTarget(i)\n                        try:\n                            self.term.connectTo(i.term, self.newConnection)\n                            gotTarget = True\n                        except:\n                            self.scene().removeItem(self.newConnection)\n                            self.newConnection = None\n                            raise\n                        break\n                \n                if not gotTarget:\n                    self.newConnection.close()\n                self.newConnection = None\n        else:\n            if self.newConnection is not None:\n                self.newConnection.setTarget(self.mapToView(ev.pos()))\n        \n    def hoverEvent(self, ev):\n        if not ev.isExit() and ev.acceptDrags(QtCore.Qt.LeftButton):\n            ev.acceptClicks(QtCore.Qt.LeftButton) ## we don\'t use the click, but we also don\'t want anyone else to use it.\n            ev.acceptClicks(QtCore.Qt.RightButton)\n            self.box.setBrush(fn.mkBrush(\'w\'))\n        else:\n            self.box.setBrush(self.brush)\n        self.update()\n        \n    def connectPoint(self):\n        ## return the connect position of this terminal in view coords\n        return self.mapToView(self.mapFromItem(self.box, self.box.boundingRect().center()))\n\n    def nodeMoved(self):\n        for t, item in self.term.connections().items():\n            item.updateLine()\n\n\nclass ConnectionItem(GraphicsObject):\n    \n    def __init__(self, source, target=None):\n        GraphicsObject.__init__(self)\n        self.setFlags(\n            self.ItemIsSelectable | \n            self.ItemIsFocusable\n        )\n        self.source = source\n        self.target = target\n        self.length = 0\n        self.hovered = False\n        self.path = None\n        self.shapePath = None\n        self.style = {\n            \'shape\': \'line\',\n            \'color\': (100, 100, 250),\n            \'width\': 1.0,\n            \'hoverColor\': (150, 150, 250),\n            \'hoverWidth\': 1.0,\n            \'selectedColor\': (200, 200, 0),\n            \'selectedWidth\': 3.0,\n            }\n        self.source.getViewBox().addItem(self)\n        self.updateLine()\n        self.setZValue(0)\n        \n    def close(self):\n        if self.scene() is not None:\n            self.scene().removeItem(self)\n        \n    def setTarget(self, target):\n        self.target = target\n        self.updateLine()\n    \n    def setStyle(self, **kwds):\n        self.style.update(kwds)\n        if \'shape\' in kwds:\n            self.updateLine()\n        else:\n            self.update()\n    \n    def updateLine(self):\n        start = Point(self.source.connectPoint())\n        if isinstance(self.target, TerminalGraphicsItem):\n            stop = Point(self.target.connectPoint())\n        elif isinstance(self.target, QtCore.QPointF):\n            stop = Point(self.target)\n        else:\n            return\n        self.prepareGeometryChange()\n        \n        self.path = self.generatePath(start, stop)\n        self.shapePath = None\n        self.update()\n        \n    def generatePath(self, start, stop):\n        path = QtGui.QPainterPath()\n        path.moveTo(start)\n        if self.style[\'shape\'] == \'line\':\n            path.lineTo(stop)\n        elif self.style[\'shape\'] == \'cubic\':\n            path.cubicTo(Point(stop.x(), start.y()), Point(start.x(), stop.y()), Point(stop.x(), stop.y()))\n        else:\n            raise Exception(\'Invalid shape ""%s""; options are ""line"" or ""cubic""\' % self.style[\'shape\'])\n        return path\n\n    def keyPressEvent(self, ev):\n        if not self.isSelected():\n            ev.ignore()\n            return\n        \n        if ev.key() == QtCore.Qt.Key_Delete or ev.key() == QtCore.Qt.Key_Backspace:\n            self.source.disconnect(self.target)\n            ev.accept()\n        else:\n            ev.ignore()\n    \n    def mousePressEvent(self, ev):\n        ev.ignore()\n        \n    def mouseClickEvent(self, ev):\n        if ev.button() == QtCore.Qt.LeftButton:\n            ev.accept()\n            sel = self.isSelected()\n            self.setSelected(True)\n            self.setFocus()\n            if not sel and self.isSelected():\n                self.update()\n                \n    def hoverEvent(self, ev):\n        if (not ev.isExit()) and ev.acceptClicks(QtCore.Qt.LeftButton):\n            self.hovered = True\n        else:\n            self.hovered = False\n        self.update()\n            \n    def boundingRect(self):\n        return self.shape().boundingRect()\n\n    def viewRangeChanged(self):\n        self.shapePath = None\n        self.prepareGeometryChange()\n        \n    def shape(self):\n        if self.shapePath is None:\n            if self.path is None:\n                return QtGui.QPainterPath()\n            stroker = QtGui.QPainterPathStroker()\n            px = self.pixelWidth()\n            stroker.setWidth(px*8)\n            self.shapePath = stroker.createStroke(self.path)\n        return self.shapePath\n        \n    def paint(self, p, *args):\n        if self.isSelected():\n            p.setPen(fn.mkPen(self.style[\'selectedColor\'], width=self.style[\'selectedWidth\']))\n        else:\n            if self.hovered:\n                p.setPen(fn.mkPen(self.style[\'hoverColor\'], width=self.style[\'hoverWidth\']))\n            else:\n                p.setPen(fn.mkPen(self.style[\'color\'], width=self.style[\'width\']))\n        \n        p.drawPath(self.path)\n'"
src/third_party/pyqtgraph/flowchart/__init__.py,0,"b'# -*- coding: utf-8 -*-\nfrom .Flowchart import *\n\nfrom .library import getNodeType, registerNodeType, getNodeTree'"
src/third_party/pyqtgraph/graphicsItems/ArrowItem.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .. import functions as fn\nimport numpy as np\n__all__ = [\'ArrowItem\']\n\nclass ArrowItem(QtGui.QGraphicsPathItem):\n    """"""\n    For displaying scale-invariant arrows.\n    For arrows pointing to a location on a curve, see CurveArrow\n    \n    """"""\n    \n    \n    def __init__(self, **opts):\n        """"""\n        Arrows can be initialized with any keyword arguments accepted by \n        the setStyle() method.\n        """"""\n        self.opts = {}\n        QtGui.QGraphicsPathItem.__init__(self, opts.get(\'parent\', None))\n\n        if \'size\' in opts:\n            opts[\'headLen\'] = opts[\'size\']\n        if \'width\' in opts:\n            opts[\'headWidth\'] = opts[\'width\']\n        defaultOpts = {\n            \'pxMode\': True,\n            \'angle\': -150,   ## If the angle is 0, the arrow points left\n            \'pos\': (0,0),\n            \'headLen\': 20,\n            \'tipAngle\': 25,\n            \'baseAngle\': 0,\n            \'tailLen\': None,\n            \'tailWidth\': 3,\n            \'pen\': (200,200,200),\n            \'brush\': (50,50,200),\n        }\n        defaultOpts.update(opts)\n        \n        self.setStyle(**defaultOpts)\n        \n        self.moveBy(*self.opts[\'pos\'])\n    \n    def setStyle(self, **opts):\n        """"""\n        Changes the appearance of the arrow.\n        All arguments are optional:\n        \n        ======================  =================================================\n        **Keyword Arguments:**\n        angle                   Orientation of the arrow in degrees. Default is\n                                0; arrow pointing to the left.\n        headLen                 Length of the arrow head, from tip to base.\n                                default=20\n        headWidth               Width of the arrow head at its base.\n        tipAngle                Angle of the tip of the arrow in degrees. Smaller\n                                values make a \'sharper\' arrow. If tipAngle is\n                                specified, ot overrides headWidth. default=25\n        baseAngle               Angle of the base of the arrow head. Default is\n                                0, which means that the base of the arrow head\n                                is perpendicular to the arrow tail.\n        tailLen                 Length of the arrow tail, measured from the base\n                                of the arrow head to the end of the tail. If\n                                this value is None, no tail will be drawn.\n                                default=None\n        tailWidth               Width of the tail. default=3\n        pen                     The pen used to draw the outline of the arrow.\n        brush                   The brush used to fill the arrow.\n        ======================  =================================================\n        """"""\n        self.opts.update(opts)\n        \n        opt = dict([(k,self.opts[k]) for k in [\'headLen\', \'tipAngle\', \'baseAngle\', \'tailLen\', \'tailWidth\']])\n        tr = QtGui.QTransform()\n        tr.rotate(self.opts[\'angle\'])\n        self.path = tr.map(fn.makeArrowPath(**opt))\n\n        self.setPath(self.path)\n        \n        self.setPen(fn.mkPen(self.opts[\'pen\']))\n        self.setBrush(fn.mkBrush(self.opts[\'brush\']))\n        \n        if self.opts[\'pxMode\']:\n            self.setFlags(self.flags() | self.ItemIgnoresTransformations)\n        else:\n            self.setFlags(self.flags() & ~self.ItemIgnoresTransformations)\n\n\n    def paint(self, p, *args):\n        p.setRenderHint(QtGui.QPainter.Antialiasing)\n        QtGui.QGraphicsPathItem.paint(self, p, *args)\n        \n        #p.setPen(fn.mkPen(\'r\'))\n        #p.setBrush(fn.mkBrush(None))\n        #p.drawRect(self.boundingRect())\n\n    def shape(self):\n        #if not self.opts[\'pxMode\']:\n            #return QtGui.QGraphicsPathItem.shape(self)\n        return self.path\n    \n    ## dataBounds and pixelPadding methods are provided to ensure ViewBox can\n    ## properly auto-range \n    def dataBounds(self, ax, frac, orthoRange=None):\n        pw = 0\n        pen = self.pen()\n        if not pen.isCosmetic():\n            pw = pen.width() * 0.7072\n        if self.opts[\'pxMode\']:\n            return [0,0]\n        else:\n            br = self.boundingRect()\n            if ax == 0:\n                return [br.left()-pw, br.right()+pw]\n            else:\n                return [br.top()-pw, br.bottom()+pw]\n        \n    def pixelPadding(self):\n        pad = 0\n        if self.opts[\'pxMode\']:\n            br = self.boundingRect()\n            pad += (br.width()**2 + br.height()**2) ** 0.5\n        pen = self.pen()\n        if pen.isCosmetic():\n            pad += max(1, pen.width()) * 0.7072\n        return pad\n        \n        \n    \n'"
src/third_party/pyqtgraph/graphicsItems/AxisItem.py,20,"b'from ..Qt import QtGui, QtCore\nfrom ..python2_3 import asUnicode\nimport numpy as np\nfrom ..Point import Point\nfrom .. import debug as debug\nimport weakref\nfrom .. import functions as fn\nfrom .. import getConfigOption\nfrom .GraphicsWidget import GraphicsWidget\n\n__all__ = [\'AxisItem\']\nclass AxisItem(GraphicsWidget):\n    """"""\n    GraphicsItem showing a single plot axis with ticks, values, and label.\n    Can be configured to fit on any side of a plot, and can automatically synchronize its displayed scale with ViewBox items.\n    Ticks can be extended to draw a grid.\n    If maxTickLength is negative, ticks point into the plot. \n    """"""\n    \n    def __init__(self, orientation, pen=None, linkView=None, parent=None, maxTickLength=-5, showValues=True):\n        """"""\n        ==============  ===============================================================\n        **Arguments:**\n        orientation     one of \'left\', \'right\', \'top\', or \'bottom\'\n        maxTickLength   (px) maximum length of ticks to draw. Negative values draw\n                        into the plot, positive values draw outward.\n        linkView        (ViewBox) causes the range of values displayed in the axis\n                        to be linked to the visible range of a ViewBox.\n        showValues      (bool) Whether to display values adjacent to ticks \n        pen             (QPen) Pen used when drawing ticks.\n        ==============  ===============================================================\n        """"""\n        \n        GraphicsWidget.__init__(self, parent)\n        self.label = QtGui.QGraphicsTextItem(self)\n        self.picture = None\n        self.orientation = orientation\n        if orientation not in [\'left\', \'right\', \'top\', \'bottom\']:\n            raise Exception(""Orientation argument must be one of \'left\', \'right\', \'top\', or \'bottom\'."")\n        if orientation in [\'left\', \'right\']:\n            self.label.rotate(-90)\n            \n        self.style = {\n            \'tickTextOffset\': [5, 2],  ## (horizontal, vertical) spacing between text and axis \n            \'tickTextWidth\': 30,  ## space reserved for tick text\n            \'tickTextHeight\': 18, \n            \'autoExpandTextSpace\': True,  ## automatically expand text space if needed\n            \'tickFont\': None,\n            \'stopAxisAtTick\': (False, False),  ## whether axis is drawn to edge of box or to last tick \n            \'textFillLimits\': [  ## how much of the axis to fill up with tick text, maximally. \n                (0, 0.8),    ## never fill more than 80% of the axis\n                (2, 0.6),    ## If we already have 2 ticks with text, fill no more than 60% of the axis\n                (4, 0.4),    ## If we already have 4 ticks with text, fill no more than 40% of the axis\n                (6, 0.2),    ## If we already have 6 ticks with text, fill no more than 20% of the axis\n                ],\n            \'showValues\': showValues,\n            \'tickLength\': maxTickLength,\n            \'maxTickLevel\': 2,\n            \'maxTextLevel\': 2,\n        }\n        \n        self.textWidth = 30  ## Keeps track of maximum width / height of tick text \n        self.textHeight = 18\n        \n        # If the user specifies a width / height, remember that setting\n        # indefinitely.\n        self.fixedWidth = None\n        self.fixedHeight = None\n        \n        self.labelText = \'\'\n        self.labelUnits = \'\'\n        self.labelUnitPrefix=\'\'\n        self.labelStyle = {}\n        self.logMode = False\n        self.tickFont = None\n        \n        self._tickLevels = None  ## used to override the automatic ticking system with explicit ticks\n        self._tickSpacing = None  # used to override default tickSpacing method\n        self.scale = 1.0\n        self.autoSIPrefix = True\n        self.autoSIPrefixScale = 1.0\n        \n        self.setRange(0, 1)\n        \n        if pen is None:\n            self.setPen()\n        else:\n            self.setPen(pen)\n        \n        self._linkedView = None\n        if linkView is not None:\n            self.linkToView(linkView)\n        \n        self.showLabel(False)\n        \n        self.grid = False\n        #self.setCacheMode(self.DeviceCoordinateCache)\n\n    def setStyle(self, **kwds):\n        """"""\n        Set various style options.\n        \n        =================== =======================================================\n        Keyword Arguments:\n        tickLength          (int) The maximum length of ticks in pixels. \n                            Positive values point toward the text; negative \n                            values point away.\n        tickTextOffset      (int) reserved spacing between text and axis in px\n        tickTextWidth       (int) Horizontal space reserved for tick text in px\n        tickTextHeight      (int) Vertical space reserved for tick text in px\n        autoExpandTextSpace (bool) Automatically expand text space if the tick\n                            strings become too long.\n        tickFont            (QFont or None) Determines the font used for tick \n                            values. Use None for the default font.\n        stopAxisAtTick      (tuple: (bool min, bool max)) If True, the axis \n                            line is drawn only as far as the last tick. \n                            Otherwise, the line is drawn to the edge of the \n                            AxisItem boundary.\n        textFillLimits      (list of (tick #, % fill) tuples). This structure\n                            determines how the AxisItem decides how many ticks \n                            should have text appear next to them. Each tuple in\n                            the list specifies what fraction of the axis length\n                            may be occupied by text, given the number of ticks\n                            that already have text displayed. For example::\n                            \n                                [(0, 0.8), # Never fill more than 80% of the axis\n                                 (2, 0.6), # If we already have 2 ticks with text, \n                                           # fill no more than 60% of the axis\n                                 (4, 0.4), # If we already have 4 ticks with text, \n                                           # fill no more than 40% of the axis\n                                 (6, 0.2)] # If we already have 6 ticks with text, \n                                           # fill no more than 20% of the axis\n                                \n        showValues          (bool) indicates whether text is displayed adjacent\n                            to ticks.\n        =================== =======================================================\n        \n        Added in version 0.9.9\n        """"""\n        for kwd,value in kwds.items():\n            if kwd not in self.style:\n                raise NameError(""%s is not a valid style argument."" % kwd)\n            \n            if kwd in (\'tickLength\', \'tickTextOffset\', \'tickTextWidth\', \'tickTextHeight\'):\n                if not isinstance(value, int):\n                    raise ValueError(""Argument \'%s\' must be int"" % kwd)\n            \n            if kwd == \'tickTextOffset\':\n                if self.orientation in (\'left\', \'right\'):\n                    self.style[\'tickTextOffset\'][0] = value\n                else:\n                    self.style[\'tickTextOffset\'][1] = value\n            elif kwd == \'stopAxisAtTick\':\n                try:\n                    assert len(value) == 2 and isinstance(value[0], bool) and isinstance(value[1], bool)\n                except:\n                    raise ValueError(""Argument \'stopAxisAtTick\' must have type (bool, bool)"")\n                self.style[kwd] = value\n            else:\n                self.style[kwd] = value\n        \n        self.picture = None\n        self._adjustSize()\n        self.update()\n        \n    def close(self):\n        self.scene().removeItem(self.label)\n        self.label = None\n        self.scene().removeItem(self)\n        \n    def setGrid(self, grid):\n        """"""Set the alpha value (0-255) for the grid, or False to disable.\n        \n        When grid lines are enabled, the axis tick lines are extended to cover\n        the extent of the linked ViewBox, if any.\n        """"""\n        self.grid = grid\n        self.picture = None\n        self.prepareGeometryChange()\n        self.update()\n        \n    def setLogMode(self, log):\n        """"""\n        If *log* is True, then ticks are displayed on a logarithmic scale and values\n        are adjusted accordingly. (This is usually accessed by changing the log mode \n        of a :func:`PlotItem <pyqtgraph.PlotItem.setLogMode>`)\n        """"""\n        self.logMode = log\n        self.picture = None\n        self.update()\n        \n    def setTickFont(self, font):\n        self.tickFont = font\n        self.picture = None\n        self.prepareGeometryChange()\n        ## Need to re-allocate space depending on font size?\n        \n        self.update()\n        \n    def resizeEvent(self, ev=None):\n        #s = self.size()\n        \n        ## Set the position of the label\n        nudge = 5\n        br = self.label.boundingRect()\n        p = QtCore.QPointF(0, 0)\n        if self.orientation == \'left\':\n            p.setY(int(self.size().height()/2 + br.width()/2))\n            p.setX(-nudge)\n        elif self.orientation == \'right\':\n            p.setY(int(self.size().height()/2 + br.width()/2))\n            p.setX(int(self.size().width()-br.height()+nudge))\n        elif self.orientation == \'top\':\n            p.setY(-nudge)\n            p.setX(int(self.size().width()/2. - br.width()/2.))\n        elif self.orientation == \'bottom\':\n            p.setX(int(self.size().width()/2. - br.width()/2.))\n            p.setY(int(self.size().height()-br.height()+nudge))\n        self.label.setPos(p)\n        self.picture = None\n        \n    def showLabel(self, show=True):\n        """"""Show/hide the label text for this axis.""""""\n        #self.drawLabel = show\n        self.label.setVisible(show)\n        if self.orientation in [\'left\', \'right\']:\n            self._updateWidth()\n        else:\n            self._updateHeight()\n        if self.autoSIPrefix:\n            self.updateAutoSIPrefix()\n        \n    def setLabel(self, text=None, units=None, unitPrefix=None, **args):\n        """"""Set the text displayed adjacent to the axis.\n        \n        ==============  =============================================================\n        **Arguments:**\n        text            The text (excluding units) to display on the label for this\n                        axis.\n        units           The units for this axis. Units should generally be given\n                        without any scaling prefix (eg, \'V\' instead of \'mV\'). The\n                        scaling prefix will be automatically prepended based on the\n                        range of data displayed.\n        **args          All extra keyword arguments become CSS style options for\n                        the <span> tag which will surround the axis label and units.\n        ==============  =============================================================\n        \n        The final text generated for the label will look like::\n        \n            <span style=""...options..."">{text} (prefix{units})</span>\n            \n        Each extra keyword argument will become a CSS option in the above template. \n        For example, you can set the font size and color of the label::\n        \n            labelStyle = {\'color\': \'#FFF\', \'font-size\': \'14pt\'}\n            axis.setLabel(\'label text\', units=\'V\', **labelStyle)\n        \n        """"""\n        if text is not None:\n            self.labelText = text\n            self.showLabel()\n        if units is not None:\n            self.labelUnits = units\n            self.showLabel()\n        if unitPrefix is not None:\n            self.labelUnitPrefix = unitPrefix\n        if len(args) > 0:\n            self.labelStyle = args\n        self.label.setHtml(self.labelString())\n        self._adjustSize()\n        self.picture = None\n        self.update()\n            \n    def labelString(self):\n        if self.labelUnits == \'\':\n            if not self.autoSIPrefix or self.autoSIPrefixScale == 1.0:\n                units = \'\'\n            else:\n                units = asUnicode(\'(x%g)\') % (1.0/self.autoSIPrefixScale)\n        else:\n            #print repr(self.labelUnitPrefix), repr(self.labelUnits)\n            units = asUnicode(\'(%s%s)\') % (asUnicode(self.labelUnitPrefix), asUnicode(self.labelUnits))\n            \n        s = asUnicode(\'%s %s\') % (asUnicode(self.labelText), asUnicode(units))\n        \n        style = \';\'.join([\'%s: %s\' % (k, self.labelStyle[k]) for k in self.labelStyle])\n        \n        return asUnicode(""<span style=\'%s\'>%s</span>"") % (style, asUnicode(s))\n    \n    def _updateMaxTextSize(self, x):\n        ## Informs that the maximum tick size orthogonal to the axis has\n        ## changed; we use this to decide whether the item needs to be resized\n        ## to accomodate.\n        if self.orientation in [\'left\', \'right\']:\n            mx = max(self.textWidth, x)\n            if mx > self.textWidth or mx < self.textWidth-10:\n                self.textWidth = mx\n                if self.style[\'autoExpandTextSpace\'] is True:\n                    self._updateWidth()\n                    #return True  ## size has changed\n        else:\n            mx = max(self.textHeight, x)\n            if mx > self.textHeight or mx < self.textHeight-10:\n                self.textHeight = mx\n                if self.style[\'autoExpandTextSpace\'] is True:\n                    self._updateHeight()\n                    #return True  ## size has changed\n        \n    def _adjustSize(self):\n        if self.orientation in [\'left\', \'right\']:\n            self._updateWidth()\n        else:\n            self._updateHeight()\n    \n    def setHeight(self, h=None):\n        """"""Set the height of this axis reserved for ticks and tick labels.\n        The height of the axis label is automatically added.\n        \n        If *height* is None, then the value will be determined automatically\n        based on the size of the tick text.""""""\n        self.fixedHeight = h\n        self._updateHeight()\n        \n    def _updateHeight(self):\n        if not self.isVisible():\n            h = 0\n        else:\n            if self.fixedHeight is None:\n                if not self.style[\'showValues\']:\n                    h = 0\n                elif self.style[\'autoExpandTextSpace\'] is True:\n                    h = self.textHeight\n                else:\n                    h = self.style[\'tickTextHeight\']\n                h += self.style[\'tickTextOffset\'][1] if self.style[\'showValues\'] else 0\n                h += max(0, self.style[\'tickLength\'])\n                if self.label.isVisible():\n                    h += self.label.boundingRect().height() * 0.8\n            else:\n                h = self.fixedHeight\n        \n        self.setMaximumHeight(h)\n        self.setMinimumHeight(h)\n        self.picture = None\n        \n    def setWidth(self, w=None):\n        """"""Set the width of this axis reserved for ticks and tick labels.\n        The width of the axis label is automatically added.\n        \n        If *width* is None, then the value will be determined automatically\n        based on the size of the tick text.""""""\n        self.fixedWidth = w\n        self._updateWidth()\n        \n    def _updateWidth(self):\n        if not self.isVisible():\n            w = 0\n        else:\n            if self.fixedWidth is None:\n                if not self.style[\'showValues\']:\n                    w = 0\n                elif self.style[\'autoExpandTextSpace\'] is True:\n                    w = self.textWidth\n                else:\n                    w = self.style[\'tickTextWidth\']\n                w += self.style[\'tickTextOffset\'][0] if self.style[\'showValues\'] else 0\n                w += max(0, self.style[\'tickLength\'])\n                if self.label.isVisible():\n                    w += self.label.boundingRect().height() * 0.8  ## bounding rect is usually an overestimate\n            else:\n                w = self.fixedWidth\n        \n        self.setMaximumWidth(w)\n        self.setMinimumWidth(w)\n        self.picture = None\n        \n    def pen(self):\n        if self._pen is None:\n            return fn.mkPen(getConfigOption(\'foreground\'))\n        return fn.mkPen(self._pen)\n        \n    def setPen(self, *args, **kwargs):\n        """"""\n        Set the pen used for drawing text, axes, ticks, and grid lines.\n        If no arguments are given, the default foreground color will be used \n        (see :func:`setConfigOption <pyqtgraph.setConfigOption>`).\n        """"""\n        self.picture = None\n        if args or kwargs:\n            self._pen = fn.mkPen(*args, **kwargs)\n        else:\n            self._pen = fn.mkPen(getConfigOption(\'foreground\'))\n        self.labelStyle[\'color\'] = \'#\' + fn.colorStr(self._pen.color())[:6]\n        self.setLabel()\n        self.update()\n        \n    def setScale(self, scale=None):\n        """"""\n        Set the value scaling for this axis. \n        \n        Setting this value causes the axis to draw ticks and tick labels as if\n        the view coordinate system were scaled. By default, the axis scaling is \n        1.0.\n        """"""\n        # Deprecated usage, kept for backward compatibility\n        if scale is None:  \n            scale = 1.0\n            self.enableAutoSIPrefix(True)\n            \n        if scale != self.scale:\n            self.scale = scale\n            self.setLabel()\n            self.picture = None\n            self.update()\n        \n    def enableAutoSIPrefix(self, enable=True):\n        """"""\n        Enable (or disable) automatic SI prefix scaling on this axis. \n        \n        When enabled, this feature automatically determines the best SI prefix \n        to prepend to the label units, while ensuring that axis values are scaled\n        accordingly. \n        \n        For example, if the axis spans values from -0.1 to 0.1 and has units set \n        to \'V\' then the axis would display values -100 to 100\n        and the units would appear as \'mV\'\n        \n        This feature is enabled by default, and is only available when a suffix\n        (unit string) is provided to display on the label.\n        """"""\n        self.autoSIPrefix = enable\n        self.updateAutoSIPrefix()\n        \n    def updateAutoSIPrefix(self):\n        if self.label.isVisible():\n            (scale, prefix) = fn.siScale(max(abs(self.range[0]*self.scale), abs(self.range[1]*self.scale)))\n            if self.labelUnits == \'\' and prefix in [\'k\', \'m\']:  ## If we are not showing units, wait until 1e6 before scaling.\n                scale = 1.0\n                prefix = \'\'\n            self.setLabel(unitPrefix=prefix)\n        else:\n            scale = 1.0\n        \n        self.autoSIPrefixScale = scale\n        self.picture = None\n        self.update()\n        \n        \n    def setRange(self, mn, mx):\n        """"""Set the range of values displayed by the axis.\n        Usually this is handled automatically by linking the axis to a ViewBox with :func:`linkToView <pyqtgraph.AxisItem.linkToView>`""""""\n        if any(np.isinf((mn, mx))) or any(np.isnan((mn, mx))):\n            raise Exception(""Not setting range to [%s, %s]"" % (str(mn), str(mx)))\n        self.range = [mn, mx]\n        if self.autoSIPrefix:\n            self.updateAutoSIPrefix()\n        self.picture = None\n        self.update()\n        \n    def linkedView(self):\n        """"""Return the ViewBox this axis is linked to""""""\n        if self._linkedView is None:\n            return None\n        else:\n            return self._linkedView()\n        \n    def linkToView(self, view):\n        """"""Link this axis to a ViewBox, causing its displayed range to match the visible range of the view.""""""\n        oldView = self.linkedView()\n        self._linkedView = weakref.ref(view)\n        if self.orientation in [\'right\', \'left\']:\n            if oldView is not None:\n                oldView.sigYRangeChanged.disconnect(self.linkedViewChanged)\n            view.sigYRangeChanged.connect(self.linkedViewChanged)\n        else:\n            if oldView is not None:\n                oldView.sigXRangeChanged.disconnect(self.linkedViewChanged)\n            view.sigXRangeChanged.connect(self.linkedViewChanged)\n        \n        if oldView is not None:\n            oldView.sigResized.disconnect(self.linkedViewChanged)\n        view.sigResized.connect(self.linkedViewChanged)\n        \n    def linkedViewChanged(self, view, newRange=None):\n        if self.orientation in [\'right\', \'left\']:\n            if newRange is None:\n                newRange = view.viewRange()[1]\n            if view.yInverted():\n                self.setRange(*newRange[::-1])\n            else:\n                self.setRange(*newRange)\n        else:\n            if newRange is None:\n                newRange = view.viewRange()[0]\n            if view.xInverted():\n                self.setRange(*newRange[::-1])\n            else:\n                self.setRange(*newRange)\n        \n    def boundingRect(self):\n        linkedView = self.linkedView()\n        if linkedView is None or self.grid is False:\n            rect = self.mapRectFromParent(self.geometry())\n            ## extend rect if ticks go in negative direction\n            ## also extend to account for text that flows past the edges\n            tl = self.style[\'tickLength\']\n            if self.orientation == \'left\':\n                rect = rect.adjusted(0, -15, -min(0,tl), 15)\n            elif self.orientation == \'right\':\n                rect = rect.adjusted(min(0,tl), -15, 0, 15)\n            elif self.orientation == \'top\':\n                rect = rect.adjusted(-15, 0, 15, -min(0,tl))\n            elif self.orientation == \'bottom\':\n                rect = rect.adjusted(-15, min(0,tl), 15, 0)\n            return rect\n        else:\n            return self.mapRectFromParent(self.geometry()) | linkedView.mapRectToItem(self, linkedView.boundingRect())\n        \n    def paint(self, p, opt, widget):\n        profiler = debug.Profiler()\n        if self.picture is None:\n            try:\n                picture = QtGui.QPicture()\n                painter = QtGui.QPainter(picture)\n                specs = self.generateDrawSpecs(painter)\n                profiler(\'generate specs\')\n                if specs is not None:\n                    self.drawPicture(painter, *specs)\n                    profiler(\'draw picture\')\n            finally:\n                painter.end()\n            self.picture = picture\n        #p.setRenderHint(p.Antialiasing, False)   ## Sometimes we get a segfault here ???\n        #p.setRenderHint(p.TextAntialiasing, True)\n        self.picture.play(p)\n\n    def setTicks(self, ticks):\n        """"""Explicitly determine which ticks to display.\n        This overrides the behavior specified by tickSpacing(), tickValues(), and tickStrings()\n        The format for *ticks* looks like::\n\n            [\n                [ (majorTickValue1, majorTickString1), (majorTickValue2, majorTickString2), ... ],\n                [ (minorTickValue1, minorTickString1), (minorTickValue2, minorTickString2), ... ],\n                ...\n            ]\n        \n        If *ticks* is None, then the default tick system will be used instead.\n        """"""\n        self._tickLevels = ticks\n        self.picture = None\n        self.update()\n    \n    def setTickSpacing(self, major=None, minor=None, levels=None):\n        """"""\n        Explicitly determine the spacing of major and minor ticks. This \n        overrides the default behavior of the tickSpacing method, and disables\n        the effect of setTicks(). Arguments may be either *major* and *minor*, \n        or *levels* which is a list of (spacing, offset) tuples for each \n        tick level desired.\n        \n        If no arguments are given, then the default behavior of tickSpacing\n        is enabled.\n        \n        Examples::\n        \n            # two levels, all offsets = 0\n            axis.setTickSpacing(5, 1)\n            # three levels, all offsets = 0\n            axis.setTickSpacing([(3, 0), (1, 0), (0.25, 0)])\n            # reset to default\n            axis.setTickSpacing()\n        """"""\n        \n        if levels is None:\n            if major is None:\n                levels = None\n            else:\n                levels = [(major, 0), (minor, 0)]\n        self._tickSpacing = levels\n        self.picture = None\n        self.update()\n        \n\n    def tickSpacing(self, minVal, maxVal, size):\n        """"""Return values describing the desired spacing and offset of ticks.\n        \n        This method is called whenever the axis needs to be redrawn and is a \n        good method to override in subclasses that require control over tick locations.\n        \n        The return value must be a list of tuples, one for each set of ticks::\n        \n            [\n                (major tick spacing, offset),\n                (minor tick spacing, offset),\n                (sub-minor tick spacing, offset),\n                ...\n            ]\n        """"""\n        # First check for override tick spacing\n        if self._tickSpacing is not None:\n            return self._tickSpacing\n        \n        dif = abs(maxVal - minVal)\n        if dif == 0:\n            return []\n        \n        ## decide optimal minor tick spacing in pixels (this is just aesthetics)\n        optimalTickCount = max(2., np.log(size))\n        \n        ## optimal minor tick spacing \n        optimalSpacing = dif / optimalTickCount\n        \n        ## the largest power-of-10 spacing which is smaller than optimal\n        p10unit = 10 ** np.floor(np.log10(optimalSpacing))\n        \n        ## Determine major/minor tick spacings which flank the optimal spacing.\n        intervals = np.array([1., 2., 10., 20., 100.]) * p10unit\n        minorIndex = 0\n        while intervals[minorIndex+1] <= optimalSpacing:\n            minorIndex += 1\n            \n        levels = [\n            (intervals[minorIndex+2], 0),\n            (intervals[minorIndex+1], 0),\n            #(intervals[minorIndex], 0)    ## Pretty, but eats up CPU\n        ]\n        \n        if self.style[\'maxTickLevel\'] >= 2:\n            ## decide whether to include the last level of ticks\n            minSpacing = min(size / 20., 30.)\n            maxTickCount = size / minSpacing\n            if dif / intervals[minorIndex] <= maxTickCount:\n                levels.append((intervals[minorIndex], 0))\n            return levels\n        \n        \n        \n        ##### This does not work -- switching between 2/5 confuses the automatic text-level-selection\n        ### Determine major/minor tick spacings which flank the optimal spacing.\n        #intervals = np.array([1., 2., 5., 10., 20., 50., 100.]) * p10unit\n        #minorIndex = 0\n        #while intervals[minorIndex+1] <= optimalSpacing:\n            #minorIndex += 1\n            \n        ### make sure we never see 5 and 2 at the same time\n        #intIndexes = [\n            #[0,1,3],\n            #[0,2,3],\n            #[2,3,4],\n            #[3,4,6],\n            #[3,5,6],\n        #][minorIndex]\n        \n        #return [\n            #(intervals[intIndexes[2]], 0),\n            #(intervals[intIndexes[1]], 0),\n            #(intervals[intIndexes[0]], 0)\n        #]\n        \n    def tickValues(self, minVal, maxVal, size):\n        """"""\n        Return the values and spacing of ticks to draw::\n        \n            [  \n                (spacing, [major ticks]), \n                (spacing, [minor ticks]), \n                ... \n            ]\n        \n        By default, this method calls tickSpacing to determine the correct tick locations.\n        This is a good method to override in subclasses.\n        """"""\n        minVal, maxVal = sorted((minVal, maxVal))\n        \n\n        minVal *= self.scale  \n        maxVal *= self.scale\n        #size *= self.scale\n            \n        ticks = []\n        tickLevels = self.tickSpacing(minVal, maxVal, size)\n        allValues = np.array([])\n        for i in range(len(tickLevels)):\n            spacing, offset = tickLevels[i]\n            \n            ## determine starting tick\n            start = (np.ceil((minVal-offset) / spacing) * spacing) + offset\n            \n            ## determine number of ticks\n            num = int((maxVal-start) / spacing) + 1\n            values = (np.arange(num) * spacing + start) / self.scale\n            ## remove any ticks that were present in higher levels\n            ## we assume here that if the difference between a tick value and a previously seen tick value\n            ## is less than spacing/100, then they are \'equal\' and we can ignore the new tick.\n            values = list(filter(lambda x: all(np.abs(allValues-x) > spacing/self.scale*0.01), values))\n            allValues = np.concatenate([allValues, values])\n            ticks.append((spacing/self.scale, values))\n            \n        if self.logMode:\n            return self.logTickValues(minVal, maxVal, size, ticks)\n        \n        \n        #nticks = []\n        #for t in ticks:\n            #nvals = []\n            #for v in t[1]:\n                #nvals.append(v/self.scale)\n            #nticks.append((t[0]/self.scale,nvals))\n        #ticks = nticks\n            \n        return ticks\n    \n    def logTickValues(self, minVal, maxVal, size, stdTicks):\n        \n        ## start with the tick spacing given by tickValues().\n        ## Any level whose spacing is < 1 needs to be converted to log scale\n        \n        ticks = []\n        for (spacing, t) in stdTicks:\n            if spacing >= 1.0:\n                ticks.append((spacing, t))\n        \n        if len(ticks) < 3:\n            v1 = int(np.floor(minVal))\n            v2 = int(np.ceil(maxVal))\n            #major = list(range(v1+1, v2))\n            \n            minor = []\n            for v in range(v1, v2):\n                minor.extend(v + np.log10(np.arange(1, 10)))\n            minor = [x for x in minor if x>minVal and x<maxVal]\n            ticks.append((None, minor))\n        return ticks\n\n    def tickStrings(self, values, scale, spacing):\n        """"""Return the strings that should be placed next to ticks. This method is called \n        when redrawing the axis and is a good method to override in subclasses.\n        The method is called with a list of tick values, a scaling factor (see below), and the \n        spacing between ticks (this is required since, in some instances, there may be only \n        one tick and thus no other way to determine the tick spacing)\n        \n        The scale argument is used when the axis label is displaying units which may have an SI scaling prefix.\n        When determining the text to display, use value*scale to correctly account for this prefix.\n        For example, if the axis label\'s units are set to \'V\', then a tick value of 0.001 might\n        be accompanied by a scale value of 1000. This indicates that the label is displaying \'mV\', and \n        thus the tick should display 0.001 * 1000 = 1.\n        """"""\n        if self.logMode:\n            return self.logTickStrings(values, scale, spacing)\n        \n        places = max(0, np.ceil(-np.log10(spacing*scale)))\n        strings = []\n        for v in values:\n            vs = v * scale\n            if abs(vs) < .001 or abs(vs) >= 10000:\n                vstr = ""%g"" % vs\n            else:\n                vstr = (""%%0.%df"" % places) % vs\n            strings.append(vstr)\n        return strings\n        \n    def logTickStrings(self, values, scale, spacing):\n        return [""%0.1g""%x for x in 10 ** np.array(values).astype(float)]\n        \n    def generateDrawSpecs(self, p):\n        """"""\n        Calls tickValues() and tickStrings() to determine where and how ticks should\n        be drawn, then generates from this a set of drawing commands to be \n        interpreted by drawPicture().\n        """"""\n        profiler = debug.Profiler()\n\n        #bounds = self.boundingRect()\n        bounds = self.mapRectFromParent(self.geometry())\n        \n        linkedView = self.linkedView()\n        if linkedView is None or self.grid is False:\n            tickBounds = bounds\n        else:\n            tickBounds = linkedView.mapRectToItem(self, linkedView.boundingRect())\n        \n        if self.orientation == \'left\':\n            span = (bounds.topRight(), bounds.bottomRight())\n            tickStart = tickBounds.right()\n            tickStop = bounds.right()\n            tickDir = -1\n            axis = 0\n        elif self.orientation == \'right\':\n            span = (bounds.topLeft(), bounds.bottomLeft())\n            tickStart = tickBounds.left()\n            tickStop = bounds.left()\n            tickDir = 1\n            axis = 0\n        elif self.orientation == \'top\':\n            span = (bounds.bottomLeft(), bounds.bottomRight())\n            tickStart = tickBounds.bottom()\n            tickStop = bounds.bottom()\n            tickDir = -1\n            axis = 1\n        elif self.orientation == \'bottom\':\n            span = (bounds.topLeft(), bounds.topRight())\n            tickStart = tickBounds.top()\n            tickStop = bounds.top()\n            tickDir = 1\n            axis = 1\n        #print tickStart, tickStop, span\n        \n        ## determine size of this item in pixels\n        points = list(map(self.mapToDevice, span))\n        if None in points:\n            return\n        lengthInPixels = Point(points[1] - points[0]).length()\n        if lengthInPixels == 0:\n            return\n\n        # Determine major / minor / subminor axis ticks\n        if self._tickLevels is None:\n            tickLevels = self.tickValues(self.range[0], self.range[1], lengthInPixels)\n            tickStrings = None\n        else:\n            ## parse self.tickLevels into the formats returned by tickLevels() and tickStrings()\n            tickLevels = []\n            tickStrings = []\n            for level in self._tickLevels:\n                values = []\n                strings = []\n                tickLevels.append((None, values))\n                tickStrings.append(strings)\n                for val, strn in level:\n                    values.append(val)\n                    strings.append(strn)\n        \n        ## determine mapping between tick values and local coordinates\n        dif = self.range[1] - self.range[0]\n        if dif == 0:\n            xScale = 1\n            offset = 0\n        else:\n            if axis == 0:\n                xScale = -bounds.height() / dif\n                offset = self.range[0] * xScale - bounds.height()\n            else:\n                xScale = bounds.width() / dif\n                offset = self.range[0] * xScale\n            \n        xRange = [x * xScale - offset for x in self.range]\n        xMin = min(xRange)\n        xMax = max(xRange)\n        \n        profiler(\'init\')\n            \n        tickPositions = [] # remembers positions of previously drawn ticks\n        \n        ## compute coordinates to draw ticks\n        ## draw three different intervals, long ticks first\n        tickSpecs = []\n        for i in range(len(tickLevels)):\n            tickPositions.append([])\n            ticks = tickLevels[i][1]\n        \n            ## length of tick\n            tickLength = self.style[\'tickLength\'] / ((i*0.5)+1.0)\n                \n            lineAlpha = 255 / (i+1)\n            if self.grid is not False:\n                lineAlpha *= self.grid/255. * np.clip((0.05  * lengthInPixels / (len(ticks)+1)), 0., 1.)\n            \n            for v in ticks:\n                ## determine actual position to draw this tick\n                x = (v * xScale) - offset\n                if x < xMin or x > xMax:  ## last check to make sure no out-of-bounds ticks are drawn\n                    tickPositions[i].append(None)\n                    continue\n                tickPositions[i].append(x)\n                \n                p1 = [x, x]\n                p2 = [x, x]\n                p1[axis] = tickStart\n                p2[axis] = tickStop\n                if self.grid is False:\n                    p2[axis] += tickLength*tickDir\n                tickPen = self.pen()\n                color = tickPen.color()\n                color.setAlpha(lineAlpha)\n                tickPen.setColor(color)\n                tickSpecs.append((tickPen, Point(p1), Point(p2)))\n        profiler(\'compute ticks\')\n\n        \n        if self.style[\'stopAxisAtTick\'][0] is True:\n            stop = max(span[0].y(), min(map(min, tickPositions)))\n            if axis == 0:\n                span[0].setY(stop)\n            else:\n                span[0].setX(stop)\n        if self.style[\'stopAxisAtTick\'][1] is True:\n            stop = min(span[1].y(), max(map(max, tickPositions)))\n            if axis == 0:\n                span[1].setY(stop)\n            else:\n                span[1].setX(stop)\n        axisSpec = (self.pen(), span[0], span[1])\n\n        \n        textOffset = self.style[\'tickTextOffset\'][axis]  ## spacing between axis and text\n        #if self.style[\'autoExpandTextSpace\'] is True:\n            #textWidth = self.textWidth\n            #textHeight = self.textHeight\n        #else:\n            #textWidth = self.style[\'tickTextWidth\'] ## space allocated for horizontal text\n            #textHeight = self.style[\'tickTextHeight\'] ## space allocated for horizontal text\n            \n        textSize2 = 0\n        textRects = []\n        textSpecs = []  ## list of draw\n        \n        # If values are hidden, return early\n        if not self.style[\'showValues\']:\n            return (axisSpec, tickSpecs, textSpecs)\n            \n        for i in range(min(len(tickLevels), self.style[\'maxTextLevel\']+1)):\n            ## Get the list of strings to display for this level\n            if tickStrings is None:\n                spacing, values = tickLevels[i]\n                strings = self.tickStrings(values, self.autoSIPrefixScale * self.scale, spacing)\n            else:\n                strings = tickStrings[i]\n                \n            if len(strings) == 0:\n                continue\n            \n            ## ignore strings belonging to ticks that were previously ignored\n            for j in range(len(strings)):\n                if tickPositions[i][j] is None:\n                    strings[j] = None\n\n            ## Measure density of text; decide whether to draw this level\n            rects = []\n            for s in strings:\n                if s is None:\n                    rects.append(None)\n                else:\n                    br = p.boundingRect(QtCore.QRectF(0, 0, 100, 100), QtCore.Qt.AlignCenter, asUnicode(s))\n                    ## boundingRect is usually just a bit too large\n                    ## (but this probably depends on per-font metrics?)\n                    br.setHeight(br.height() * 0.8)\n                    \n                    rects.append(br)\n                    textRects.append(rects[-1])\n            \n            if len(textRects) > 0:\n                ## measure all text, make sure there\'s enough room\n                if axis == 0:\n                    textSize = np.sum([r.height() for r in textRects])\n                    textSize2 = np.max([r.width() for r in textRects])\n                else:\n                    textSize = np.sum([r.width() for r in textRects])\n                    textSize2 = np.max([r.height() for r in textRects])\n            else:\n                textSize = 0\n                textSize2 = 0\n\n            if i > 0:  ## always draw top level\n                ## If the strings are too crowded, stop drawing text now.\n                ## We use three different crowding limits based on the number\n                ## of texts drawn so far.\n                textFillRatio = float(textSize) / lengthInPixels\n                finished = False\n                for nTexts, limit in self.style[\'textFillLimits\']:\n                    if len(textSpecs) >= nTexts and textFillRatio >= limit:\n                        finished = True\n                        break\n                if finished:\n                    break\n            \n            #spacing, values = tickLevels[best]\n            #strings = self.tickStrings(values, self.scale, spacing)\n            # Determine exactly where tick text should be drawn\n            for j in range(len(strings)):\n                vstr = strings[j]\n                if vstr is None: ## this tick was ignored because it is out of bounds\n                    continue\n                vstr = asUnicode(vstr)\n                x = tickPositions[i][j]\n                #textRect = p.boundingRect(QtCore.QRectF(0, 0, 100, 100), QtCore.Qt.AlignCenter, vstr)\n                textRect = rects[j]\n                height = textRect.height()\n                width = textRect.width()\n                #self.textHeight = height\n                offset = max(0,self.style[\'tickLength\']) + textOffset\n                if self.orientation == \'left\':\n                    textFlags = QtCore.Qt.TextDontClip|QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter\n                    rect = QtCore.QRectF(tickStop-offset-width, x-(height/2), width, height)\n                elif self.orientation == \'right\':\n                    textFlags = QtCore.Qt.TextDontClip|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter\n                    rect = QtCore.QRectF(tickStop+offset, x-(height/2), width, height)\n                elif self.orientation == \'top\':\n                    textFlags = QtCore.Qt.TextDontClip|QtCore.Qt.AlignCenter|QtCore.Qt.AlignBottom\n                    rect = QtCore.QRectF(x-width/2., tickStop-offset-height, width, height)\n                elif self.orientation == \'bottom\':\n                    textFlags = QtCore.Qt.TextDontClip|QtCore.Qt.AlignCenter|QtCore.Qt.AlignTop\n                    rect = QtCore.QRectF(x-width/2., tickStop+offset, width, height)\n\n                #p.setPen(self.pen())\n                #p.drawText(rect, textFlags, vstr)\n                textSpecs.append((rect, textFlags, vstr))\n        profiler(\'compute text\')\n            \n        ## update max text size if needed.\n        self._updateMaxTextSize(textSize2)\n        \n        return (axisSpec, tickSpecs, textSpecs)\n    \n    def drawPicture(self, p, axisSpec, tickSpecs, textSpecs):\n        profiler = debug.Profiler()\n\n        p.setRenderHint(p.Antialiasing, False)\n        p.setRenderHint(p.TextAntialiasing, True)\n        \n        ## draw long line along axis\n        pen, p1, p2 = axisSpec\n        p.setPen(pen)\n        p.drawLine(p1, p2)\n        p.translate(0.5,0)  ## resolves some damn pixel ambiguity\n        \n        ## draw ticks\n        for pen, p1, p2 in tickSpecs:\n            p.setPen(pen)\n            p.drawLine(p1, p2)\n        profiler(\'draw ticks\')\n\n        ## Draw all text\n        if self.tickFont is not None:\n            p.setFont(self.tickFont)\n        p.setPen(self.pen())\n        for rect, flags, text in textSpecs:\n            p.drawText(rect, flags, text)\n            #p.drawRect(rect)\n        profiler(\'draw text\')\n\n    def show(self):\n        GraphicsWidget.show(self)\n        if self.orientation in [\'left\', \'right\']:\n            self._updateWidth()\n        else:\n            self._updateHeight()\n        \n    def hide(self):\n        GraphicsWidget.hide(self)\n        if self.orientation in [\'left\', \'right\']:\n            self._updateWidth()\n        else:\n            self._updateHeight()\n\n    def wheelEvent(self, ev):\n        if self.linkedView() is None: \n            return\n        if self.orientation in [\'left\', \'right\']:\n            self.linkedView().wheelEvent(ev, axis=1)\n        else:\n            self.linkedView().wheelEvent(ev, axis=0)\n        ev.accept()\n        \n    def mouseDragEvent(self, event):\n        if self.linkedView() is None: \n            return\n        if self.orientation in [\'left\', \'right\']:\n            return self.linkedView().mouseDragEvent(event, axis=1)\n        else:\n            return self.linkedView().mouseDragEvent(event, axis=0)\n        \n    def mouseClickEvent(self, event):\n        if self.linkedView() is None: \n            return\n        return self.linkedView().mouseClickEvent(event)\n'"
src/third_party/pyqtgraph/graphicsItems/BarGraphItem.py,7,"b'from ..Qt import QtGui, QtCore\nfrom .GraphicsObject import GraphicsObject\nfrom .. import getConfigOption\nfrom .. import functions as fn\nimport numpy as np\n\n\n__all__ = [\'BarGraphItem\']\n\nclass BarGraphItem(GraphicsObject):\n    def __init__(self, **opts):\n        """"""\n        Valid keyword options are:\n        x, x0, x1, y, y0, y1, width, height, pen, brush\n        \n        x specifies the x-position of the center of the bar.\n        x0, x1 specify left and right edges of the bar, respectively.\n        width specifies distance from x0 to x1.\n        You may specify any combination:\n            \n            x, width\n            x0, width\n            x1, width\n            x0, x1\n            \n        Likewise y, y0, y1, and height. \n        If only height is specified, then y0 will be set to 0\n        \n        Example uses:\n        \n            BarGraphItem(x=range(5), height=[1,5,2,4,3], width=0.5)\n            \n        \n        """"""\n        GraphicsObject.__init__(self)\n        self.opts = dict(\n            x=None,\n            y=None,\n            x0=None,\n            y0=None,\n            x1=None,\n            y1=None,\n            height=None,\n            width=None,\n            pen=None,\n            brush=None,\n            pens=None,\n            brushes=None,\n        )\n        self._shape = None\n        self.picture = None\n        self.setOpts(**opts)\n        \n    def setOpts(self, **opts):\n        self.opts.update(opts)\n        self.picture = None\n        self._shape = None\n        self.update()\n        self.informViewBoundsChanged()\n        \n    def drawPicture(self):\n        self.picture = QtGui.QPicture()\n        self._shape = QtGui.QPainterPath()\n        p = QtGui.QPainter(self.picture)\n        \n        pen = self.opts[\'pen\']\n        pens = self.opts[\'pens\']\n        \n        if pen is None and pens is None:\n            pen = getConfigOption(\'foreground\')\n        \n        brush = self.opts[\'brush\']\n        brushes = self.opts[\'brushes\']\n        if brush is None and brushes is None:\n            brush = (128, 128, 128)\n        \n        def asarray(x):\n            if x is None or np.isscalar(x) or isinstance(x, np.ndarray):\n                return x\n            return np.array(x)\n\n        \n        x = asarray(self.opts.get(\'x\'))\n        x0 = asarray(self.opts.get(\'x0\'))\n        x1 = asarray(self.opts.get(\'x1\'))\n        width = asarray(self.opts.get(\'width\'))\n        \n        if x0 is None:\n            if width is None:\n                raise Exception(\'must specify either x0 or width\')\n            if x1 is not None:\n                x0 = x1 - width\n            elif x is not None:\n                x0 = x - width/2.\n            else:\n                raise Exception(\'must specify at least one of x, x0, or x1\')\n        if width is None:\n            if x1 is None:\n                raise Exception(\'must specify either x1 or width\')\n            width = x1 - x0\n            \n        y = asarray(self.opts.get(\'y\'))\n        y0 = asarray(self.opts.get(\'y0\'))\n        y1 = asarray(self.opts.get(\'y1\'))\n        height = asarray(self.opts.get(\'height\'))\n\n        if y0 is None:\n            if height is None:\n                y0 = 0\n            elif y1 is not None:\n                y0 = y1 - height\n            elif y is not None:\n                y0 = y - height/2.\n            else:\n                y0 = 0\n        if height is None:\n            if y1 is None:\n                raise Exception(\'must specify either y1 or height\')\n            height = y1 - y0\n        \n        p.setPen(fn.mkPen(pen))\n        p.setBrush(fn.mkBrush(brush))\n        for i in range(len(x0 if not np.isscalar(x0) else y0)):\n            if pens is not None:\n                p.setPen(fn.mkPen(pens[i]))\n            if brushes is not None:\n                p.setBrush(fn.mkBrush(brushes[i]))\n                \n            if np.isscalar(x0):\n                x = x0\n            else:\n                x = x0[i]\n            if np.isscalar(y0):\n                y = y0\n            else:\n                y = y0[i]\n            if np.isscalar(width):\n                w = width\n            else:\n                w = width[i]\n            if np.isscalar(height):\n                h = height\n            else:\n                h = height[i]\n                \n                \n            rect = QtCore.QRectF(x, y, w, h)\n            p.drawRect(rect)\n            self._shape.addRect(rect)\n            \n        p.end()\n        self.prepareGeometryChange()\n        \n        \n    def paint(self, p, *args):\n        if self.picture is None:\n            self.drawPicture()\n        self.picture.play(p)\n            \n    def boundingRect(self):\n        if self.picture is None:\n            self.drawPicture()\n        return QtCore.QRectF(self.picture.boundingRect())\n    \n    def shape(self):\n        if self.picture is None:\n            self.drawPicture()\n        return self._shape\n'"
src/third_party/pyqtgraph/graphicsItems/ButtonItem.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .GraphicsObject import GraphicsObject\n\n__all__ = [\'ButtonItem\']\nclass ButtonItem(GraphicsObject):\n    """"""Button graphicsItem displaying an image.""""""\n    \n    clicked = QtCore.Signal(object)\n    \n    def __init__(self, imageFile=None, width=None, parentItem=None, pixmap=None):\n        self.enabled = True\n        GraphicsObject.__init__(self)\n        if imageFile is not None:\n            self.setImageFile(imageFile)\n        elif pixmap is not None:\n            self.setPixmap(pixmap)\n            \n        if width is not None:\n            s = float(width) / self.pixmap.width()\n            self.scale(s, s)\n        if parentItem is not None:\n            self.setParentItem(parentItem)\n        self.setOpacity(0.7)\n        \n    def setImageFile(self, imageFile):        \n        self.setPixmap(QtGui.QPixmap(imageFile))\n        \n    def setPixmap(self, pixmap):\n        self.pixmap = pixmap\n        self.update()\n        \n    def mouseClickEvent(self, ev):\n        if self.enabled:\n            self.clicked.emit(self)\n        \n    def mouseHoverEvent(self, ev):\n        if not self.enabled:\n            return\n        if ev.isEnter():\n            self.setOpacity(1.0)\n        else:\n            self.setOpacity(0.7)\n\n    def disable(self):\n        self.enabled = False\n        self.setOpacity(0.4)\n        \n    def enable(self):\n        self.enabled = True\n        self.setOpacity(0.7)\n        \n    def paint(self, p, *args):\n        p.setRenderHint(p.Antialiasing)\n        p.drawPixmap(0, 0, self.pixmap)\n        \n    def boundingRect(self):\n        return QtCore.QRectF(self.pixmap.rect())\n        \n'"
src/third_party/pyqtgraph/graphicsItems/CurvePoint.py,6,"b'from ..Qt import QtGui, QtCore\nfrom . import ArrowItem\nimport numpy as np\nfrom ..Point import Point\nimport weakref\nfrom .GraphicsObject import GraphicsObject\n\n__all__ = [\'CurvePoint\', \'CurveArrow\']\nclass CurvePoint(GraphicsObject):\n    """"""A GraphicsItem that sets its location to a point on a PlotCurveItem.\n    Also rotates to be tangent to the curve.\n    The position along the curve is a Qt property, and thus can be easily animated.\n    \n    Note: This class does not display anything; see CurveArrow for an applied example\n    """"""\n    \n    def __init__(self, curve, index=0, pos=None, rotate=True):\n        """"""Position can be set either as an index referring to the sample number or\n        the position 0.0 - 1.0\n        If *rotate* is True, then the item rotates to match the tangent of the curve.\n        """"""\n        \n        GraphicsObject.__init__(self)\n        #QObjectWorkaround.__init__(self)\n        self._rotate = rotate\n        self.curve = weakref.ref(curve)\n        self.setParentItem(curve)\n        self.setProperty(\'position\', 0.0)\n        self.setProperty(\'index\', 0)\n        \n        if hasattr(self, \'ItemHasNoContents\'):\n            self.setFlags(self.flags() | self.ItemHasNoContents)\n        \n        if pos is not None:\n            self.setPos(pos)\n        else:\n            self.setIndex(index)\n            \n    def setPos(self, pos):\n        self.setProperty(\'position\', float(pos))## cannot use numpy types here, MUST be python float.\n        \n    def setIndex(self, index):\n        self.setProperty(\'index\', int(index))  ## cannot use numpy types here, MUST be python int.\n        \n    def event(self, ev):\n        if not isinstance(ev, QtCore.QDynamicPropertyChangeEvent) or self.curve() is None:\n            return False\n            \n        if ev.propertyName() == \'index\':\n            index = self.property(\'index\')\n            if \'QVariant\' in repr(index):\n                index = index.toInt()[0]\n        elif ev.propertyName() == \'position\':\n            index = None\n        else:\n            return False\n            \n        (x, y) = self.curve().getData()\n        if index is None:\n            #print ev.propertyName(), self.property(\'position\').toDouble()[0], self.property(\'position\').typeName()\n            pos = self.property(\'position\')\n            if \'QVariant\' in repr(pos):   ## need to support 2 APIs  :(\n                pos = pos.toDouble()[0]\n            index = (len(x)-1) * np.clip(pos, 0.0, 1.0)\n            \n        if index != int(index):  ## interpolate floating-point values\n            i1 = int(index)\n            i2 = np.clip(i1+1, 0, len(x)-1)\n            s2 = index-i1\n            s1 = 1.0-s2\n            newPos = (x[i1]*s1+x[i2]*s2, y[i1]*s1+y[i2]*s2)\n        else:\n            index = int(index)\n            i1 = np.clip(index-1, 0, len(x)-1)\n            i2 = np.clip(index+1, 0, len(x)-1)\n            newPos = (x[index], y[index])\n            \n        p1 = self.parentItem().mapToScene(QtCore.QPointF(x[i1], y[i1]))\n        p2 = self.parentItem().mapToScene(QtCore.QPointF(x[i2], y[i2]))\n        ang = np.arctan2(p2.y()-p1.y(), p2.x()-p1.x()) ## returns radians\n        self.resetTransform()\n        if self._rotate:\n            self.rotate(180+ ang * 180 / np.pi) ## takes degrees\n        QtGui.QGraphicsItem.setPos(self, *newPos)\n        return True\n        \n    def boundingRect(self):\n        return QtCore.QRectF()\n        \n    def paint(self, *args):\n        pass\n    \n    def makeAnimation(self, prop=\'position\', start=0.0, end=1.0, duration=10000, loop=1):\n        # In Python 3, a bytes object needs to be used as a property name in\n        # QPropertyAnimation. PyQt stopped automatically encoding a str when a\n        # QByteArray was expected in v5.5 (see qbytearray.sip).\n        if not isinstance(prop, bytes):\n            prop = prop.encode(\'latin-1\')\n        anim = QtCore.QPropertyAnimation(self, prop)\n        anim.setDuration(duration)\n        anim.setStartValue(start)\n        anim.setEndValue(end)\n        anim.setLoopCount(loop)\n        return anim\n\n\nclass CurveArrow(CurvePoint):\n    """"""Provides an arrow that points to any specific sample on a PlotCurveItem.\n    Provides properties that can be animated.""""""\n    \n    def __init__(self, curve, index=0, pos=None, **opts):\n        CurvePoint.__init__(self, curve, index=index, pos=pos)\n        if opts.get(\'pxMode\', True):\n            opts[\'pxMode\'] = False\n            self.setFlags(self.flags() | self.ItemIgnoresTransformations)\n        opts[\'angle\'] = 0\n        self.arrow = ArrowItem.ArrowItem(**opts)\n        self.arrow.setParentItem(self)\n        \n    def setStyle(self, **opts):\n        return self.arrow.setStyle(**opts)\n        \n'"
src/third_party/pyqtgraph/graphicsItems/ErrorBarItem.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .GraphicsObject import GraphicsObject\nfrom .. import getConfigOption\nfrom .. import functions as fn\n\n__all__ = [\'ErrorBarItem\']\n\nclass ErrorBarItem(GraphicsObject):\n    def __init__(self, **opts):\n        """"""\n        All keyword arguments are passed to setData().\n        """"""\n        GraphicsObject.__init__(self)\n        self.opts = dict(\n            x=None,\n            y=None,\n            height=None,\n            width=None,\n            top=None,\n            bottom=None,\n            left=None,\n            right=None,\n            beam=None,\n            pen=None\n        )\n        self.setData(**opts)\n\n    def setData(self, **opts):\n        """"""\n        Update the data in the item. All arguments are optional.\n        \n        Valid keyword options are:\n        x, y, height, width, top, bottom, left, right, beam, pen\n        \n        * x and y must be numpy arrays specifying the coordinates of data points.\n        * height, width, top, bottom, left, right, and beam may be numpy arrays,\n          single values, or None to disable. All values should be positive.\n        * top, bottom, left, and right specify the lengths of bars extending\n          in each direction.\n        * If height is specified, it overrides top and bottom.\n        * If width is specified, it overrides left and right.\n        * beam specifies the width of the beam at the end of each bar.\n        * pen may be any single argument accepted by pg.mkPen().\n        \n        This method was added in version 0.9.9. For prior versions, use setOpts.\n        """"""\n        self.opts.update(opts)\n        self.path = None\n        self.update()\n        self.prepareGeometryChange()\n        self.informViewBoundsChanged()\n        \n    def setOpts(self, **opts):\n        # for backward compatibility\n        self.setData(**opts)\n        \n    def drawPath(self):\n        p = QtGui.QPainterPath()\n        \n        x, y = self.opts[\'x\'], self.opts[\'y\']\n        if x is None or y is None:\n            return\n        \n        beam = self.opts[\'beam\']\n        \n        \n        height, top, bottom = self.opts[\'height\'], self.opts[\'top\'], self.opts[\'bottom\']\n        if height is not None or top is not None or bottom is not None:\n            ## draw vertical error bars\n            if height is not None:\n                y1 = y - height/2.\n                y2 = y + height/2.\n            else:\n                if bottom is None:\n                    y1 = y\n                else:\n                    y1 = y - bottom\n                if top is None:\n                    y2 = y\n                else:\n                    y2 = y + top\n            \n            for i in range(len(x)):\n                p.moveTo(x[i], y1[i])\n                p.lineTo(x[i], y2[i])\n                \n            if beam is not None and beam > 0:\n                x1 = x - beam/2.\n                x2 = x + beam/2.\n                if height is not None or top is not None:\n                    for i in range(len(x)):\n                        p.moveTo(x1[i], y2[i])\n                        p.lineTo(x2[i], y2[i])\n                if height is not None or bottom is not None:\n                    for i in range(len(x)):\n                        p.moveTo(x1[i], y1[i])\n                        p.lineTo(x2[i], y1[i])\n        \n        width, right, left = self.opts[\'width\'], self.opts[\'right\'], self.opts[\'left\']\n        if width is not None or right is not None or left is not None:\n            ## draw vertical error bars\n            if width is not None:\n                x1 = x - width/2.\n                x2 = x + width/2.\n            else:\n                if left is None:\n                    x1 = x\n                else:\n                    x1 = x - left\n                if right is None:\n                    x2 = x\n                else:\n                    x2 = x + right\n            \n            for i in range(len(x)):\n                p.moveTo(x1[i], y[i])\n                p.lineTo(x2[i], y[i])\n                \n            if beam is not None and beam > 0:\n                y1 = y - beam/2.\n                y2 = y + beam/2.\n                if width is not None or right is not None:\n                    for i in range(len(x)):\n                        p.moveTo(x2[i], y1[i])\n                        p.lineTo(x2[i], y2[i])\n                if width is not None or left is not None:\n                    for i in range(len(x)):\n                        p.moveTo(x1[i], y1[i])\n                        p.lineTo(x1[i], y2[i])\n                    \n        self.path = p\n        self.prepareGeometryChange()\n        \n        \n    def paint(self, p, *args):\n        if self.path is None:\n            self.drawPath()\n        pen = self.opts[\'pen\']\n        if pen is None:\n            pen = getConfigOption(\'foreground\')\n        p.setPen(fn.mkPen(pen))\n        p.drawPath(self.path)\n            \n    def boundingRect(self):\n        if self.path is None:\n            self.drawPath()\n        return self.path.boundingRect()\n    \n        '"
src/third_party/pyqtgraph/graphicsItems/FillBetweenItem.py,0,"b'from ..Qt import QtGui\nfrom .. import functions as fn\nfrom .PlotDataItem import PlotDataItem\nfrom .PlotCurveItem import PlotCurveItem\n\nclass FillBetweenItem(QtGui.QGraphicsPathItem):\n    """"""\n    GraphicsItem filling the space between two PlotDataItems.\n    """"""\n    def __init__(self, curve1=None, curve2=None, brush=None, pen=None):\n        QtGui.QGraphicsPathItem.__init__(self)\n        self.curves = None\n        if curve1 is not None and curve2 is not None:\n            self.setCurves(curve1, curve2)\n        elif curve1 is not None or curve2 is not None:\n            raise Exception(""Must specify two curves to fill between."")\n\n        if brush is not None:\n            self.setBrush(brush)\n        self.setPen(pen)\n        self.updatePath()\n        \n    def setBrush(self, *args, **kwds):\n        QtGui.QGraphicsPathItem.setBrush(self, fn.mkBrush(*args, **kwds))\n        \n    def setPen(self, *args, **kwds):\n        QtGui.QGraphicsPathItem.setPen(self, fn.mkPen(*args, **kwds))\n\n    def setCurves(self, curve1, curve2):\n        """"""Set the curves to fill between.\n        \n        Arguments must be instances of PlotDataItem or PlotCurveItem.\n        \n        Added in version 0.9.9\n        """"""\n        if self.curves is not None:\n            for c in self.curves:\n                try:\n                    c.sigPlotChanged.disconnect(self.curveChanged)\n                except (TypeError, RuntimeError):\n                    pass\n\n        curves = [curve1, curve2]\n        for c in curves:\n            if not isinstance(c, PlotDataItem) and not isinstance(c, PlotCurveItem):\n                raise TypeError(""Curves must be PlotDataItem or PlotCurveItem."")\n        self.curves = curves\n        curve1.sigPlotChanged.connect(self.curveChanged)\n        curve2.sigPlotChanged.connect(self.curveChanged)\n        self.setZValue(min(curve1.zValue(), curve2.zValue())-1)\n        self.curveChanged()\n\n    def setBrush(self, *args, **kwds):\n        """"""Change the fill brush. Acceps the same arguments as pg.mkBrush()""""""\n        QtGui.QGraphicsPathItem.setBrush(self, fn.mkBrush(*args, **kwds))\n\n    def curveChanged(self):\n        self.updatePath()\n\n    def updatePath(self):\n        if self.curves is None:\n            self.setPath(QtGui.QPainterPath())\n            return\n        paths = []\n        for c in self.curves:\n            if isinstance(c, PlotDataItem):\n                paths.append(c.curve.getPath())\n            elif isinstance(c, PlotCurveItem):\n                paths.append(c.getPath())\n\n        path = QtGui.QPainterPath()\n        transform = QtGui.QTransform()\n        ps1 = paths[0].toSubpathPolygons(transform)\n        ps2 = paths[1].toReversed().toSubpathPolygons(transform)\n        ps2.reverse()\n        if len(ps1) == 0 or len(ps2) == 0:\n            self.setPath(QtGui.QPainterPath())\n            return\n        \n            \n        for p1, p2 in zip(ps1, ps2):\n            path.addPolygon(p1 + p2)\n        self.setPath(path)\n'"
src/third_party/pyqtgraph/graphicsItems/GradientEditorItem.py,3,"b'import weakref\nimport numpy as np\nfrom ..Qt import QtGui, QtCore\nfrom ..python2_3 import sortList\nfrom .. import functions as fn\nfrom .GraphicsObject import GraphicsObject\nfrom .GraphicsWidget import GraphicsWidget\nfrom ..widgets.SpinBox import SpinBox\nfrom ..pgcollections import OrderedDict\nfrom ..colormap import ColorMap\nfrom ..python2_3 import cmp\n\n\n__all__ = [\'TickSliderItem\', \'GradientEditorItem\']\n\nGradients = OrderedDict([\n    (\'thermal\', {\'ticks\': [(0.3333, (185, 0, 0, 255)), (0.6666, (255, 220, 0, 255)), (1, (255, 255, 255, 255)), (0, (0, 0, 0, 255))], \'mode\': \'rgb\'}),\n    (\'flame\', {\'ticks\': [(0.2, (7, 0, 220, 255)), (0.5, (236, 0, 134, 255)), (0.8, (246, 246, 0, 255)), (1.0, (255, 255, 255, 255)), (0.0, (0, 0, 0, 255))], \'mode\': \'rgb\'}),\n    (\'yellowy\', {\'ticks\': [(0.0, (0, 0, 0, 255)), (0.2328863796753704, (32, 0, 129, 255)), (0.8362738179251941, (255, 255, 0, 255)), (0.5257586450247, (115, 15, 255, 255)), (1.0, (255, 255, 255, 255))], \'mode\': \'rgb\'} ),\n    (\'bipolar\', {\'ticks\': [(0.0, (0, 255, 255, 255)), (1.0, (255, 255, 0, 255)), (0.5, (0, 0, 0, 255)), (0.25, (0, 0, 255, 255)), (0.75, (255, 0, 0, 255))], \'mode\': \'rgb\'}),\n    (\'spectrum\', {\'ticks\': [(1.0, (255, 0, 255, 255)), (0.0, (255, 0, 0, 255))], \'mode\': \'hsv\'}),\n    (\'cyclic\', {\'ticks\': [(0.0, (255, 0, 4, 255)), (1.0, (255, 0, 0, 255))], \'mode\': \'hsv\'}),\n    (\'greyclip\', {\'ticks\': [(0.0, (0, 0, 0, 255)), (0.99, (255, 255, 255, 255)), (1.0, (255, 0, 0, 255))], \'mode\': \'rgb\'}),\n    (\'grey\', {\'ticks\': [(0.0, (0, 0, 0, 255)), (1.0, (255, 255, 255, 255))], \'mode\': \'rgb\'}),\n    # Perceptually uniform sequential colormaps from Matplotlib 2.0\n    (\'viridis\', {\'ticks\': [(0.0, (68, 1, 84, 255)), (0.25, (58, 82, 139, 255)), (0.5, (32, 144, 140, 255)), (0.75, (94, 201, 97, 255)), (1.0, (253, 231, 36, 255))], \'mode\': \'rgb\'}),\n    (\'inferno\', {\'ticks\': [(0.0, (0, 0, 3, 255)), (0.25, (87, 15, 109, 255)), (0.5, (187, 55, 84, 255)), (0.75, (249, 142, 8, 255)), (1.0, (252, 254, 164, 255))], \'mode\': \'rgb\'}),\n    (\'plasma\', {\'ticks\': [(0.0, (12, 7, 134, 255)), (0.25, (126, 3, 167, 255)), (0.5, (203, 71, 119, 255)), (0.75, (248, 149, 64, 255)), (1.0, (239, 248, 33, 255))], \'mode\': \'rgb\'}),\n    (\'magma\', {\'ticks\': [(0.0, (0, 0, 3, 255)), (0.25, (80, 18, 123, 255)), (0.5, (182, 54, 121, 255)), (0.75, (251, 136, 97, 255)), (1.0, (251, 252, 191, 255))], \'mode\': \'rgb\'}),\n])\n\ndef addGradientListToDocstring():\n    """"""Decorator to add list of current pre-defined gradients to the end of a function docstring.""""""\n    def dec(fn):\n        if fn.__doc__ is not None:\n            fn.__doc__ = fn.__doc__ + str(Gradients.keys()).strip(\'[\').strip(\']\')\n        return fn\n    return dec\n\n\n\nclass TickSliderItem(GraphicsWidget):\n    ## public class\n    """"""**Bases:** :class:`GraphicsWidget <pyqtgraph.GraphicsWidget>`\n    \n    A rectangular item with tick marks along its length that can (optionally) be moved by the user.""""""\n        \n    def __init__(self, orientation=\'bottom\', allowAdd=True, **kargs):\n        """"""\n        ==============  =================================================================================\n        **Arguments:**\n        orientation     Set the orientation of the gradient. Options are: \'left\', \'right\'\n                        \'top\', and \'bottom\'.\n        allowAdd        Specifies whether ticks can be added to the item by the user.\n        tickPen         Default is white. Specifies the color of the outline of the ticks.\n                        Can be any of the valid arguments for :func:`mkPen <pyqtgraph.mkPen>`\n        ==============  =================================================================================\n        """"""\n        ## public\n        GraphicsWidget.__init__(self)\n        self.orientation = orientation\n        self.length = 100\n        self.tickSize = 15\n        self.ticks = {}\n        self.maxDim = 20\n        self.allowAdd = allowAdd\n        if \'tickPen\' in kargs:\n            self.tickPen = fn.mkPen(kargs[\'tickPen\'])\n        else:\n            self.tickPen = fn.mkPen(\'w\')\n            \n        self.orientations = {\n            \'left\': (90, 1, 1), \n            \'right\': (90, 1, 1), \n            \'top\': (0, 1, -1), \n            \'bottom\': (0, 1, 1)\n        }\n        \n        self.setOrientation(orientation)\n        #self.setFrameStyle(QtGui.QFrame.NoFrame | QtGui.QFrame.Plain)\n        #self.setBackgroundRole(QtGui.QPalette.NoRole)\n        #self.setMouseTracking(True)\n        \n    #def boundingRect(self):\n        #return self.mapRectFromParent(self.geometry()).normalized()\n        \n    #def shape(self):  ## No idea why this is necessary, but rotated items do not receive clicks otherwise.\n        #p = QtGui.QPainterPath()\n        #p.addRect(self.boundingRect())\n        #return p\n        \n    def paint(self, p, opt, widget):\n        #p.setPen(fn.mkPen(\'g\', width=3))\n        #p.drawRect(self.boundingRect())\n        return\n        \n    def keyPressEvent(self, ev):\n        ev.ignore()\n\n    def setMaxDim(self, mx=None):\n        if mx is None:\n            mx = self.maxDim\n        else:\n            self.maxDim = mx\n            \n        if self.orientation in [\'bottom\', \'top\']:\n            self.setFixedHeight(mx)\n            self.setMaximumWidth(16777215)\n        else:\n            self.setFixedWidth(mx)\n            self.setMaximumHeight(16777215)\n            \n    \n    def setOrientation(self, orientation):\n        ## public\n        """"""Set the orientation of the TickSliderItem.\n        \n        ==============  ===================================================================\n        **Arguments:**\n        orientation     Options are: \'left\', \'right\', \'top\', \'bottom\'\n                        The orientation option specifies which side of the slider the\n                        ticks are on, as well as whether the slider is vertical (\'right\'\n                        and \'left\') or horizontal (\'top\' and \'bottom\').\n        ==============  ===================================================================\n        """"""\n        self.orientation = orientation\n        self.setMaxDim()\n        self.resetTransform()\n        ort = orientation\n        if ort == \'top\':\n            transform = QtGui.QTransform.fromScale(1, -1)\n            transform.translate(0, -self.height())\n            self.setTransform(transform)\n        elif ort == \'left\':\n            transform = QtGui.QTransform()\n            transform.rotate(270)\n            transform.scale(1, -1)\n            transform.translate(-self.height(), -self.maxDim)\n            self.setTransform(transform)\n        elif ort == \'right\':\n            transform = QtGui.QTransform()\n            transform.rotate(270)\n            transform.translate(-self.height(), 0)\n            self.setTransform(transform)\n        elif ort != \'bottom\':\n            raise Exception(""%s is not a valid orientation. Options are \'left\', \'right\', \'top\', and \'bottom\'"" %str(ort))\n        \n        self.translate(self.tickSize/2., 0)\n    \n    def addTick(self, x, color=None, movable=True):\n        ## public\n        """"""\n        Add a tick to the item.\n        \n        ==============  ==================================================================\n        **Arguments:**\n        x               Position where tick should be added.\n        color           Color of added tick. If color is not specified, the color will be\n                        white.\n        movable         Specifies whether the tick is movable with the mouse.\n        ==============  ==================================================================\n        """"""        \n        \n        if color is None:\n            color = QtGui.QColor(255,255,255)\n        tick = Tick(self, [x*self.length, 0], color, movable, self.tickSize, pen=self.tickPen)\n        self.ticks[tick] = x\n        tick.setParentItem(self)\n        return tick\n    \n    def removeTick(self, tick):\n        ## public\n        """"""\n        Removes the specified tick.\n        """"""\n        del self.ticks[tick]\n        tick.setParentItem(None)\n        if self.scene() is not None:\n            self.scene().removeItem(tick)\n    \n    def tickMoved(self, tick, pos):\n        #print ""tick changed""\n        ## Correct position of tick if it has left bounds.\n        newX = min(max(0, pos.x()), self.length)\n        pos.setX(newX)\n        tick.setPos(pos)\n        self.ticks[tick] = float(newX) / self.length\n    \n    def tickMoveFinished(self, tick):\n        pass\n    \n    def tickClicked(self, tick, ev):\n        if ev.button() == QtCore.Qt.RightButton:\n            self.removeTick(tick)\n    \n    def widgetLength(self):\n        if self.orientation in [\'bottom\', \'top\']:\n            return self.width()\n        else:\n            return self.height()\n    \n    def resizeEvent(self, ev):\n        wlen = max(40, self.widgetLength())\n        self.setLength(wlen-self.tickSize-2)\n        self.setOrientation(self.orientation)\n        #bounds = self.scene().itemsBoundingRect()\n        #bounds.setLeft(min(-self.tickSize*0.5, bounds.left()))\n        #bounds.setRight(max(self.length + self.tickSize, bounds.right()))\n        #self.setSceneRect(bounds)\n        #self.fitInView(bounds, QtCore.Qt.KeepAspectRatio)\n        \n    def setLength(self, newLen):\n        #private\n        for t, x in list(self.ticks.items()):\n            t.setPos(x * newLen + 1, t.pos().y())\n        self.length = float(newLen)\n        \n    #def mousePressEvent(self, ev):\n        #QtGui.QGraphicsView.mousePressEvent(self, ev)\n        #self.ignoreRelease = False\n        #for i in self.items(ev.pos()):\n            #if isinstance(i, Tick):\n                #self.ignoreRelease = True\n                #break\n        ##if len(self.items(ev.pos())) > 0:  ## Let items handle their own clicks\n            ##self.ignoreRelease = True\n        \n    #def mouseReleaseEvent(self, ev):\n        #QtGui.QGraphicsView.mouseReleaseEvent(self, ev)\n        #if self.ignoreRelease:\n            #return\n            \n        #pos = self.mapToScene(ev.pos())\n            \n        #if ev.button() == QtCore.Qt.LeftButton and self.allowAdd:\n            #if pos.x() < 0 or pos.x() > self.length:\n                #return\n            #if pos.y() < 0 or pos.y() > self.tickSize:\n                #return\n            #pos.setX(min(max(pos.x(), 0), self.length))\n            #self.addTick(pos.x()/self.length)\n        #elif ev.button() == QtCore.Qt.RightButton:\n            #self.showMenu(ev)\n            \n    def mouseClickEvent(self, ev):\n        if ev.button() == QtCore.Qt.LeftButton and self.allowAdd:\n            pos = ev.pos()\n            if pos.x() < 0 or pos.x() > self.length:\n                return\n            if pos.y() < 0 or pos.y() > self.tickSize:\n                return\n            pos.setX(min(max(pos.x(), 0), self.length))\n            self.addTick(pos.x()/self.length)\n        elif ev.button() == QtCore.Qt.RightButton:\n            self.showMenu(ev)\n\n        #if  ev.button() == QtCore.Qt.RightButton:\n            #if self.moving:\n                #ev.accept()\n                #self.setPos(self.startPosition)\n                #self.moving = False\n                #self.sigMoving.emit(self)\n                #self.sigMoved.emit(self)\n            #else:\n                #pass\n                #self.view().tickClicked(self, ev)\n                ###remove\n\n    def hoverEvent(self, ev):\n        if (not ev.isExit()) and ev.acceptClicks(QtCore.Qt.LeftButton):\n            ev.acceptClicks(QtCore.Qt.RightButton)\n            ## show ghost tick\n            #self.currentPen = fn.mkPen(255, 0,0)\n        #else:\n            #self.currentPen = self.pen\n        #self.update()\n        \n    def showMenu(self, ev):\n        pass\n\n    def setTickColor(self, tick, color):\n        """"""Set the color of the specified tick.\n        \n        ==============  ==================================================================\n        **Arguments:**\n        tick            Can be either an integer corresponding to the index of the tick\n                        or a Tick object. Ex: if you had a slider with 3 ticks and you\n                        wanted to change the middle tick, the index would be 1.\n        color           The color to make the tick. Can be any argument that is valid for\n                        :func:`mkBrush <pyqtgraph.mkBrush>`\n        ==============  ==================================================================\n        """"""\n        tick = self.getTick(tick)\n        tick.color = color\n        tick.update()\n        #tick.setBrush(QtGui.QBrush(QtGui.QColor(tick.color)))\n\n    def setTickValue(self, tick, val):\n        ## public\n        """"""\n        Set the position (along the slider) of the tick.\n        \n        ==============   ==================================================================\n        **Arguments:**\n        tick             Can be either an integer corresponding to the index of the tick\n                         or a Tick object. Ex: if you had a slider with 3 ticks and you\n                         wanted to change the middle tick, the index would be 1.\n        val              The desired position of the tick. If val is < 0, position will be\n                         set to 0. If val is > 1, position will be set to 1.\n        ==============   ==================================================================\n        """"""\n        tick = self.getTick(tick)\n        val = min(max(0.0, val), 1.0)\n        x = val * self.length\n        pos = tick.pos()\n        pos.setX(x)\n        tick.setPos(pos)\n        self.ticks[tick] = val\n        self.updateGradient()\n        \n    def tickValue(self, tick):\n        ## public\n        """"""Return the value (from 0.0 to 1.0) of the specified tick.\n        \n        ==============  ==================================================================\n        **Arguments:**\n        tick            Can be either an integer corresponding to the index of the tick\n                        or a Tick object. Ex: if you had a slider with 3 ticks and you\n                        wanted the value of the middle tick, the index would be 1.\n        ==============  ==================================================================\n        """"""\n        tick = self.getTick(tick)\n        return self.ticks[tick]\n        \n    def getTick(self, tick):\n        ## public\n        """"""Return the Tick object at the specified index.\n        \n        ==============  ==================================================================\n        **Arguments:**\n        tick            An integer corresponding to the index of the desired tick. If the\n                        argument is not an integer it will be returned unchanged.\n        ==============  ==================================================================\n        """"""\n        if type(tick) is int:\n            tick = self.listTicks()[tick][0]\n        return tick\n\n    #def mouseMoveEvent(self, ev):\n        #QtGui.QGraphicsView.mouseMoveEvent(self, ev)\n\n    def listTicks(self):\n        """"""Return a sorted list of all the Tick objects on the slider.""""""\n        ## public\n        ticks = list(self.ticks.items())\n        sortList(ticks, lambda a,b: cmp(a[1], b[1]))  ## see pyqtgraph.python2_3.sortList\n        return ticks\n\n\nclass GradientEditorItem(TickSliderItem):\n    """"""\n    **Bases:** :class:`TickSliderItem <pyqtgraph.TickSliderItem>`\n    \n    An item that can be used to define a color gradient. Implements common pre-defined gradients that are \n    customizable by the user. :class: `GradientWidget <pyqtgraph.GradientWidget>` provides a widget\n    with a GradientEditorItem that can be added to a GUI. \n    \n    ================================ ===========================================================\n    **Signals:**\n    sigGradientChanged(self)         Signal is emitted anytime the gradient changes. The signal \n                                     is emitted in real time while ticks are being dragged or \n                                     colors are being changed.\n    sigGradientChangeFinished(self)  Signal is emitted when the gradient is finished changing.\n    ================================ ===========================================================    \n \n    """"""\n    \n    sigGradientChanged = QtCore.Signal(object)\n    sigGradientChangeFinished = QtCore.Signal(object)\n    \n    def __init__(self, *args, **kargs):\n        """"""\n        Create a new GradientEditorItem. \n        All arguments are passed to :func:`TickSliderItem.__init__ <pyqtgraph.TickSliderItem.__init__>`\n        \n        ===============  =================================================================================\n        **Arguments:**\n        orientation      Set the orientation of the gradient. Options are: \'left\', \'right\'\n                         \'top\', and \'bottom\'.\n        allowAdd         Default is True. Specifies whether ticks can be added to the item.\n        tickPen          Default is white. Specifies the color of the outline of the ticks.\n                         Can be any of the valid arguments for :func:`mkPen <pyqtgraph.mkPen>`\n        ===============  =================================================================================\n        """"""\n        self.currentTick = None\n        self.currentTickColor = None\n        self.rectSize = 15\n        self.gradRect = QtGui.QGraphicsRectItem(QtCore.QRectF(0, self.rectSize, 100, self.rectSize))\n        self.backgroundRect = QtGui.QGraphicsRectItem(QtCore.QRectF(0, -self.rectSize, 100, self.rectSize))\n        self.backgroundRect.setBrush(QtGui.QBrush(QtCore.Qt.DiagCrossPattern))\n        self.colorMode = \'rgb\'\n        \n        TickSliderItem.__init__(self, *args, **kargs)\n        \n        self.colorDialog = QtGui.QColorDialog()\n        self.colorDialog.setOption(QtGui.QColorDialog.ShowAlphaChannel, True)\n        self.colorDialog.setOption(QtGui.QColorDialog.DontUseNativeDialog, True)\n        \n        self.colorDialog.currentColorChanged.connect(self.currentColorChanged)\n        self.colorDialog.rejected.connect(self.currentColorRejected)\n        self.colorDialog.accepted.connect(self.currentColorAccepted)\n        \n        self.backgroundRect.setParentItem(self)\n        self.gradRect.setParentItem(self)\n        \n        self.setMaxDim(self.rectSize + self.tickSize)\n        \n        self.rgbAction = QtGui.QAction(\'RGB\', self)\n        self.rgbAction.setCheckable(True)\n        self.rgbAction.triggered.connect(lambda: self.setColorMode(\'rgb\'))\n        self.hsvAction = QtGui.QAction(\'HSV\', self)\n        self.hsvAction.setCheckable(True)\n        self.hsvAction.triggered.connect(lambda: self.setColorMode(\'hsv\'))\n            \n        self.menu = QtGui.QMenu()\n        \n        ## build context menu of gradients\n        l = self.length\n        self.length = 100\n        global Gradients\n        for g in Gradients:\n            px = QtGui.QPixmap(100, 15)\n            p = QtGui.QPainter(px)\n            self.restoreState(Gradients[g])\n            grad = self.getGradient()\n            brush = QtGui.QBrush(grad)\n            p.fillRect(QtCore.QRect(0, 0, 100, 15), brush)\n            p.end()\n            label = QtGui.QLabel()\n            label.setPixmap(px)\n            label.setContentsMargins(1, 1, 1, 1)\n            act = QtGui.QWidgetAction(self)\n            act.setDefaultWidget(label)\n            act.triggered.connect(self.contextMenuClicked)\n            act.name = g\n            self.menu.addAction(act)\n        self.length = l\n        self.menu.addSeparator()\n        self.menu.addAction(self.rgbAction)\n        self.menu.addAction(self.hsvAction)\n        \n        \n        for t in list(self.ticks.keys()):\n            self.removeTick(t)\n        self.addTick(0, QtGui.QColor(0,0,0), True)\n        self.addTick(1, QtGui.QColor(255,0,0), True)\n        self.setColorMode(\'rgb\')\n        self.updateGradient()\n    \n    def setOrientation(self, orientation):\n        ## public\n        """"""\n        Set the orientation of the GradientEditorItem. \n        \n        ==============  ===================================================================\n        **Arguments:**\n        orientation     Options are: \'left\', \'right\', \'top\', \'bottom\'\n                        The orientation option specifies which side of the gradient the\n                        ticks are on, as well as whether the gradient is vertical (\'right\'\n                        and \'left\') or horizontal (\'top\' and \'bottom\').\n        ==============  ===================================================================\n        """"""\n        TickSliderItem.setOrientation(self, orientation)\n        self.translate(0, self.rectSize)\n    \n    def showMenu(self, ev):\n        #private\n        self.menu.popup(ev.screenPos().toQPoint())\n    \n    def contextMenuClicked(self, b=None):\n        #private\n        #global Gradients\n        act = self.sender()\n        self.loadPreset(act.name)\n        \n    @addGradientListToDocstring()\n    def loadPreset(self, name):\n        """"""\n        Load a predefined gradient. Currently defined gradients are: \n        """"""## TODO: provide image with names of defined gradients\n        \n        #global Gradients\n        self.restoreState(Gradients[name])\n    \n    def setColorMode(self, cm):\n        """"""\n        Set the color mode for the gradient. Options are: \'hsv\', \'rgb\'\n        \n        """"""\n        \n        ## public\n        if cm not in [\'rgb\', \'hsv\']:\n            raise Exception(""Unknown color mode %s. Options are \'rgb\' and \'hsv\'."" % str(cm))\n        \n        try:\n            self.rgbAction.blockSignals(True)\n            self.hsvAction.blockSignals(True)\n            self.rgbAction.setChecked(cm == \'rgb\')\n            self.hsvAction.setChecked(cm == \'hsv\')\n        finally:\n            self.rgbAction.blockSignals(False)\n            self.hsvAction.blockSignals(False)\n        self.colorMode = cm\n        self.updateGradient()\n        \n    def colorMap(self):\n        """"""Return a ColorMap object representing the current state of the editor.""""""\n        if self.colorMode == \'hsv\':\n            raise NotImplementedError(\'hsv colormaps not yet supported\')\n        pos = []\n        color = []\n        for t,x in self.listTicks():\n            pos.append(x)\n            c = t.color\n            color.append([c.red(), c.green(), c.blue(), c.alpha()])\n        return ColorMap(np.array(pos), np.array(color, dtype=np.ubyte))\n        \n    def updateGradient(self):\n        #private\n        self.gradient = self.getGradient()\n        self.gradRect.setBrush(QtGui.QBrush(self.gradient))\n        self.sigGradientChanged.emit(self)\n        \n    def setLength(self, newLen):\n        #private (but maybe public)\n        TickSliderItem.setLength(self, newLen)\n        self.backgroundRect.setRect(1, -self.rectSize, newLen, self.rectSize)\n        self.gradRect.setRect(1, -self.rectSize, newLen, self.rectSize)\n        self.updateGradient()\n        \n    def currentColorChanged(self, color):\n        #private\n        if color.isValid() and self.currentTick is not None:\n            self.setTickColor(self.currentTick, color)\n            self.updateGradient()\n            \n    def currentColorRejected(self):\n        #private\n        self.setTickColor(self.currentTick, self.currentTickColor)\n        self.updateGradient()\n        \n    def currentColorAccepted(self):\n        self.sigGradientChangeFinished.emit(self)\n        \n    def tickClicked(self, tick, ev):\n        #private\n        if ev.button() == QtCore.Qt.LeftButton:\n            self.raiseColorDialog(tick)\n        elif ev.button() == QtCore.Qt.RightButton:\n            self.raiseTickContextMenu(tick, ev)\n            \n    def raiseColorDialog(self, tick):\n        if not tick.colorChangeAllowed:\n            return\n        self.currentTick = tick\n        self.currentTickColor = tick.color\n        self.colorDialog.setCurrentColor(tick.color)\n        self.colorDialog.open()\n        \n    def raiseTickContextMenu(self, tick, ev):\n        self.tickMenu = TickMenu(tick, self)\n        self.tickMenu.popup(ev.screenPos().toQPoint())\n    \n    def tickMoved(self, tick, pos):\n        #private\n        TickSliderItem.tickMoved(self, tick, pos)\n        self.updateGradient()\n\n    def tickMoveFinished(self, tick):\n        self.sigGradientChangeFinished.emit(self)\n    \n\n    def getGradient(self):\n        """"""Return a QLinearGradient object.""""""\n        g = QtGui.QLinearGradient(QtCore.QPointF(0,0), QtCore.QPointF(self.length,0))\n        if self.colorMode == \'rgb\':\n            ticks = self.listTicks()\n            g.setStops([(x, QtGui.QColor(t.color)) for t,x in ticks])\n        elif self.colorMode == \'hsv\':  ## HSV mode is approximated for display by interpolating 10 points between each stop\n            ticks = self.listTicks()\n            stops = []\n            stops.append((ticks[0][1], ticks[0][0].color))\n            for i in range(1,len(ticks)):\n                x1 = ticks[i-1][1]\n                x2 = ticks[i][1]\n                dx = (x2-x1) / 10.\n                for j in range(1,10):\n                    x = x1 + dx*j\n                    stops.append((x, self.getColor(x)))\n                stops.append((x2, self.getColor(x2)))\n            g.setStops(stops)\n        return g\n        \n    def getColor(self, x, toQColor=True):\n        """"""\n        Return a color for a given value.\n        \n        ==============  ==================================================================\n        **Arguments:**\n        x               Value (position on gradient) of requested color.\n        toQColor        If true, returns a QColor object, else returns a (r,g,b,a) tuple.\n        ==============  ==================================================================\n        """"""\n        ticks = self.listTicks()\n        if x <= ticks[0][1]:\n            c = ticks[0][0].color\n            if toQColor:\n                return QtGui.QColor(c)  # always copy colors before handing them out\n            else:\n                return (c.red(), c.green(), c.blue(), c.alpha())\n        if x >= ticks[-1][1]:\n            c = ticks[-1][0].color\n            if toQColor:\n                return QtGui.QColor(c)  # always copy colors before handing them out\n            else:\n                return (c.red(), c.green(), c.blue(), c.alpha())\n            \n        x2 = ticks[0][1]\n        for i in range(1,len(ticks)):\n            x1 = x2\n            x2 = ticks[i][1]\n            if x1 <= x and x2 >= x:\n                break\n                \n        dx = (x2-x1)\n        if dx == 0:\n            f = 0.\n        else:\n            f = (x-x1) / dx\n        c1 = ticks[i-1][0].color\n        c2 = ticks[i][0].color\n        if self.colorMode == \'rgb\':\n            r = c1.red() * (1.-f) + c2.red() * f\n            g = c1.green() * (1.-f) + c2.green() * f\n            b = c1.blue() * (1.-f) + c2.blue() * f\n            a = c1.alpha() * (1.-f) + c2.alpha() * f\n            if toQColor:\n                return QtGui.QColor(int(r), int(g), int(b), int(a))\n            else:\n                return (r,g,b,a)\n        elif self.colorMode == \'hsv\':\n            h1,s1,v1,_ = c1.getHsv()\n            h2,s2,v2,_ = c2.getHsv()\n            h = h1 * (1.-f) + h2 * f\n            s = s1 * (1.-f) + s2 * f\n            v = v1 * (1.-f) + v2 * f\n            c = QtGui.QColor()\n            c.setHsv(h,s,v)\n            if toQColor:\n                return c\n            else:\n                return (c.red(), c.green(), c.blue(), c.alpha())\n                    \n    def getLookupTable(self, nPts, alpha=None):\n        """"""\n        Return an RGB(A) lookup table (ndarray). \n        \n        ==============  ============================================================================\n        **Arguments:**\n        nPts            The number of points in the returned lookup table.\n        alpha           True, False, or None - Specifies whether or not alpha values are included\n                        in the table.If alpha is None, alpha will be automatically determined.\n        ==============  ============================================================================\n        """"""\n        if alpha is None:\n            alpha = self.usesAlpha()\n        if alpha:\n            table = np.empty((nPts,4), dtype=np.ubyte)\n        else:\n            table = np.empty((nPts,3), dtype=np.ubyte)\n            \n        for i in range(nPts):\n            x = float(i)/(nPts-1)\n            color = self.getColor(x, toQColor=False)\n            table[i] = color[:table.shape[1]]\n            \n        return table\n    \n    def usesAlpha(self):\n        """"""Return True if any ticks have an alpha < 255""""""\n        \n        ticks = self.listTicks()\n        for t in ticks:\n            if t[0].color.alpha() < 255:\n                return True\n            \n        return False\n            \n    def isLookupTrivial(self):\n        """"""Return True if the gradient has exactly two stops in it: black at 0.0 and white at 1.0""""""\n        ticks = self.listTicks()\n        if len(ticks) != 2:\n            return False\n        if ticks[0][1] != 0.0 or ticks[1][1] != 1.0:\n            return False\n        c1 = fn.colorTuple(ticks[0][0].color)\n        c2 = fn.colorTuple(ticks[1][0].color)\n        if c1 != (0,0,0,255) or c2 != (255,255,255,255):\n            return False\n        return True\n\n\n    def mouseReleaseEvent(self, ev):\n        #private\n        TickSliderItem.mouseReleaseEvent(self, ev)\n        self.updateGradient()\n        \n    def addTick(self, x, color=None, movable=True, finish=True):\n        """"""\n        Add a tick to the gradient. Return the tick.\n        \n        ==============  ==================================================================\n        **Arguments:**\n        x               Position where tick should be added.\n        color           Color of added tick. If color is not specified, the color will be\n                        the color of the gradient at the specified position.\n        movable         Specifies whether the tick is movable with the mouse.\n        ==============  ==================================================================\n        """"""\n        \n        \n        if color is None:\n            color = self.getColor(x)\n        t = TickSliderItem.addTick(self, x, color=color, movable=movable)\n        t.colorChangeAllowed = True\n        t.removeAllowed = True\n        \n        if finish:\n            self.sigGradientChangeFinished.emit(self)\n        return t\n\n\n    def removeTick(self, tick, finish=True):\n        TickSliderItem.removeTick(self, tick)\n        if finish:\n            self.updateGradient()\n            self.sigGradientChangeFinished.emit(self)\n        \n        \n    def saveState(self):\n        """"""\n        Return a dictionary with parameters for rebuilding the gradient. Keys will include:\n        \n           - \'mode\': hsv or rgb\n           - \'ticks\': a list of tuples (pos, (r,g,b,a))\n        """"""\n        ## public\n        ticks = []\n        for t in self.ticks:\n            c = t.color\n            ticks.append((self.ticks[t], (c.red(), c.green(), c.blue(), c.alpha())))\n        state = {\'mode\': self.colorMode, \'ticks\': ticks}\n        return state\n        \n    def restoreState(self, state):\n        """"""\n        Restore the gradient specified in state.\n        \n        ==============  ====================================================================\n        **Arguments:**\n        state           A dictionary with same structure as those returned by\n                        :func:`saveState <pyqtgraph.GradientEditorItem.saveState>`\n                      \n                        Keys must include:\n                      \n                            - \'mode\': hsv or rgb\n                            - \'ticks\': a list of tuples (pos, (r,g,b,a))\n        ==============  ====================================================================\n        """"""\n        ## public\n        self.setColorMode(state[\'mode\'])\n        for t in list(self.ticks.keys()):\n            self.removeTick(t, finish=False)\n        for t in state[\'ticks\']:\n            c = QtGui.QColor(*t[1])\n            self.addTick(t[0], c, finish=False)\n        self.updateGradient()\n        self.sigGradientChangeFinished.emit(self)\n        \n    def setColorMap(self, cm):\n        self.setColorMode(\'rgb\')\n        for t in list(self.ticks.keys()):\n            self.removeTick(t, finish=False)\n        colors = cm.getColors(mode=\'qcolor\')\n        for i in range(len(cm.pos)):\n            x = cm.pos[i]\n            c = colors[i]\n            self.addTick(x, c, finish=False)\n        self.updateGradient()\n        self.sigGradientChangeFinished.emit(self)\n\n\nclass Tick(QtGui.QGraphicsWidget):  ## NOTE: Making this a subclass of GraphicsObject instead results in\n                                    ## activating this bug: https://bugreports.qt-project.org/browse/PYSIDE-86\n    ## private class\n\n    # When making Tick a subclass of QtGui.QGraphicsObject as origin,\n    # ..GraphicsScene.items(self, *args) will get Tick object as a\n    # class of QtGui.QMultimediaWidgets.QGraphicsVideoItem in python2.7-PyQt5(5.4.0)\n\n    sigMoving = QtCore.Signal(object)\n    sigMoved = QtCore.Signal(object)\n    \n    def __init__(self, view, pos, color, movable=True, scale=10, pen=\'w\'):\n        self.movable = movable\n        self.moving = False\n        self.view = weakref.ref(view)\n        self.scale = scale\n        self.color = color\n        self.pen = fn.mkPen(pen)\n        self.hoverPen = fn.mkPen(255,255,0)\n        self.currentPen = self.pen\n        self.pg = QtGui.QPainterPath(QtCore.QPointF(0,0))\n        self.pg.lineTo(QtCore.QPointF(-scale/3**0.5, scale))\n        self.pg.lineTo(QtCore.QPointF(scale/3**0.5, scale))\n        self.pg.closeSubpath()\n        \n        QtGui.QGraphicsWidget.__init__(self)\n        self.setPos(pos[0], pos[1])\n        if self.movable:\n            self.setZValue(1)\n        else:\n            self.setZValue(0)\n\n    def boundingRect(self):\n        return self.pg.boundingRect()\n    \n    def shape(self):\n        return self.pg\n\n    def paint(self, p, *args):\n        p.setRenderHints(QtGui.QPainter.Antialiasing)\n        p.fillPath(self.pg, fn.mkBrush(self.color))\n        \n        p.setPen(self.currentPen)\n        p.drawPath(self.pg)\n\n\n    def mouseDragEvent(self, ev):\n        if self.movable and ev.button() == QtCore.Qt.LeftButton:\n            if ev.isStart():\n                self.moving = True\n                self.cursorOffset = self.pos() - self.mapToParent(ev.buttonDownPos())\n                self.startPosition = self.pos()\n            ev.accept()\n            \n            if not self.moving:\n                return\n                \n            newPos = self.cursorOffset + self.mapToParent(ev.pos())\n            newPos.setY(self.pos().y())\n            \n            self.setPos(newPos)\n            self.view().tickMoved(self, newPos)\n            self.sigMoving.emit(self)\n            if ev.isFinish():\n                self.moving = False\n                self.sigMoved.emit(self)\n                self.view().tickMoveFinished(self)\n\n    def mouseClickEvent(self, ev):\n        if  ev.button() == QtCore.Qt.RightButton and self.moving:\n            ev.accept()\n            self.setPos(self.startPosition)\n            self.view().tickMoved(self, self.startPosition)\n            self.moving = False\n            self.sigMoving.emit(self)\n            self.sigMoved.emit(self)\n        else:\n            self.view().tickClicked(self, ev)\n            ##remove\n\n    def hoverEvent(self, ev):\n        if (not ev.isExit()) and ev.acceptDrags(QtCore.Qt.LeftButton):\n            ev.acceptClicks(QtCore.Qt.LeftButton)\n            ev.acceptClicks(QtCore.Qt.RightButton)\n            self.currentPen = self.hoverPen\n        else:\n            self.currentPen = self.pen\n        self.update()\n        \n\nclass TickMenu(QtGui.QMenu):\n    \n    def __init__(self, tick, sliderItem):\n        QtGui.QMenu.__init__(self)\n        \n        self.tick = weakref.ref(tick)\n        self.sliderItem = weakref.ref(sliderItem)\n        \n        self.removeAct = self.addAction(""Remove Tick"", lambda: self.sliderItem().removeTick(tick))\n        if (not self.tick().removeAllowed) or len(self.sliderItem().ticks) < 3:\n            self.removeAct.setEnabled(False)\n            \n        positionMenu = self.addMenu(""Set Position"")\n        w = QtGui.QWidget()\n        l = QtGui.QGridLayout()\n        w.setLayout(l)\n        \n        value = sliderItem.tickValue(tick)\n        self.fracPosSpin = SpinBox()\n        self.fracPosSpin.setOpts(value=value, bounds=(0.0, 1.0), step=0.01, decimals=2)\n        #self.dataPosSpin = SpinBox(value=dataVal)\n        #self.dataPosSpin.setOpts(decimals=3, siPrefix=True)\n                \n        l.addWidget(QtGui.QLabel(""Position:""), 0,0)\n        l.addWidget(self.fracPosSpin, 0, 1)\n        #l.addWidget(QtGui.QLabel(""Position (data units):""), 1, 0)\n        #l.addWidget(self.dataPosSpin, 1,1)\n        \n        #if self.sliderItem().dataParent is None:\n        #    self.dataPosSpin.setEnabled(False)\n        \n        a = QtGui.QWidgetAction(self)\n        a.setDefaultWidget(w)\n        positionMenu.addAction(a)        \n        \n        self.fracPosSpin.sigValueChanging.connect(self.fractionalValueChanged)\n        #self.dataPosSpin.valueChanged.connect(self.dataValueChanged)\n        \n        colorAct = self.addAction(""Set Color"", lambda: self.sliderItem().raiseColorDialog(self.tick()))\n        if not self.tick().colorChangeAllowed:\n            colorAct.setEnabled(False)\n\n    def fractionalValueChanged(self, x):\n        self.sliderItem().setTickValue(self.tick(), self.fracPosSpin.value())\n        #if self.sliderItem().dataParent is not None:\n        #    self.dataPosSpin.blockSignals(True)\n        #    self.dataPosSpin.setValue(self.sliderItem().tickDataValue(self.tick()))\n        #    self.dataPosSpin.blockSignals(False)\n            \n    #def dataValueChanged(self, val):\n    #    self.sliderItem().setTickValue(self.tick(), val, dataUnits=True)\n    #    self.fracPosSpin.blockSignals(True)\n    #    self.fracPosSpin.setValue(self.sliderItem().tickValue(self.tick()))\n    #    self.fracPosSpin.blockSignals(False)\n\n'"
src/third_party/pyqtgraph/graphicsItems/GradientLegend.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .UIGraphicsItem import *\nfrom .. import functions as fn\n\n__all__ = [\'GradientLegend\']\n\nclass GradientLegend(UIGraphicsItem):\n    """"""\n    Draws a color gradient rectangle along with text labels denoting the value at specific \n    points along the gradient.\n    """"""\n    \n    def __init__(self, size, offset):\n        self.size = size\n        self.offset = offset\n        UIGraphicsItem.__init__(self)\n        self.setAcceptedMouseButtons(QtCore.Qt.NoButton)\n        self.brush = QtGui.QBrush(QtGui.QColor(200,0,0))\n        self.pen = QtGui.QPen(QtGui.QColor(0,0,0))\n        self.labels = {\'max\': 1, \'min\': 0}\n        self.gradient = QtGui.QLinearGradient()\n        self.gradient.setColorAt(0, QtGui.QColor(0,0,0))\n        self.gradient.setColorAt(1, QtGui.QColor(255,0,0))\n        \n    def setGradient(self, g):\n        self.gradient = g\n        self.update()\n        \n    def setIntColorScale(self, minVal, maxVal, *args, **kargs):\n        colors = [fn.intColor(i, maxVal-minVal, *args, **kargs) for i in range(minVal, maxVal)]\n        g = QtGui.QLinearGradient()\n        for i in range(len(colors)):\n            x = float(i)/len(colors)\n            g.setColorAt(x, colors[i])\n        self.setGradient(g)\n        if \'labels\' not in kargs:\n            self.setLabels({str(minVal/10.): 0, str(maxVal): 1})\n        else:\n            self.setLabels({kargs[\'labels\'][0]:0, kargs[\'labels\'][1]:1})\n        \n    def setLabels(self, l):\n        """"""Defines labels to appear next to the color scale. Accepts a dict of {text: value} pairs""""""\n        self.labels = l\n        self.update()\n        \n    def paint(self, p, opt, widget):\n        UIGraphicsItem.paint(self, p, opt, widget)\n        rect = self.boundingRect()   ## Boundaries of visible area in scene coords.\n        unit = self.pixelSize()       ## Size of one view pixel in scene coords.\n        if unit[0] is None:  \n            return\n        \n        ## determine max width of all labels\n        labelWidth = 0\n        labelHeight = 0\n        for k in self.labels:\n            b = p.boundingRect(QtCore.QRectF(0, 0, 0, 0), QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter, str(k))\n            labelWidth = max(labelWidth, b.width())\n            labelHeight = max(labelHeight, b.height())\n            \n        labelWidth *= unit[0]\n        labelHeight *= unit[1]\n        \n        textPadding = 2  # in px\n        \n        if self.offset[0] < 0:\n            x3 = rect.right() + unit[0] * self.offset[0]\n            x2 = x3 - labelWidth - unit[0]*textPadding*2\n            x1 = x2 - unit[0] * self.size[0]\n        else:\n            x1 = rect.left() + unit[0] * self.offset[0]\n            x2 = x1 + unit[0] * self.size[0]\n            x3 = x2 + labelWidth + unit[0]*textPadding*2\n        if self.offset[1] < 0:\n            y2 = rect.top() - unit[1] * self.offset[1]\n            y1 = y2 + unit[1] * self.size[1]\n        else:\n            y1 = rect.bottom() - unit[1] * self.offset[1]\n            y2 = y1 - unit[1] * self.size[1]\n        self.b = [x1,x2,x3,y1,y2,labelWidth]\n            \n        ## Draw background\n        p.setPen(self.pen)\n        p.setBrush(QtGui.QBrush(QtGui.QColor(255,255,255,100)))\n        rect = QtCore.QRectF(\n            QtCore.QPointF(x1 - unit[0]*textPadding, y1 + labelHeight/2 + unit[1]*textPadding), \n            QtCore.QPointF(x3, y2 - labelHeight/2 - unit[1]*textPadding)\n        )\n        p.drawRect(rect)\n        \n        \n        ## Have to scale painter so that text and gradients are correct size. Bleh.\n        p.scale(unit[0], unit[1])\n        \n        ## Draw color bar\n        self.gradient.setStart(0, y1/unit[1])\n        self.gradient.setFinalStop(0, y2/unit[1])\n        p.setBrush(self.gradient)\n        rect = QtCore.QRectF(\n            QtCore.QPointF(x1/unit[0], y1/unit[1]), \n            QtCore.QPointF(x2/unit[0], y2/unit[1])\n        )\n        p.drawRect(rect)\n        \n        \n        ## draw labels\n        p.setPen(QtGui.QPen(QtGui.QColor(0,0,0)))\n        tx = x2 + unit[0]*textPadding\n        lh = labelHeight/unit[1]\n        for k in self.labels:\n            y = y1 + self.labels[k] * (y2-y1)\n            p.drawText(QtCore.QRectF(tx/unit[0], y/unit[1] - lh/2.0, 1000, lh), QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter, str(k))\n        \n        \n'"
src/third_party/pyqtgraph/graphicsItems/GraphItem.py,2,"b'from .. import functions as fn\nfrom .GraphicsObject import GraphicsObject\nfrom .ScatterPlotItem import ScatterPlotItem\nfrom ..Qt import QtGui, QtCore\nimport numpy as np\nfrom .. import getConfigOption\n\n__all__ = [\'GraphItem\']\n\n\nclass GraphItem(GraphicsObject):\n    """"""A GraphItem displays graph information as\n    a set of nodes connected by lines (as in \'graph theory\', not \'graphics\'). \n    Useful for drawing networks, trees, etc.\n    """"""\n\n    def __init__(self, **kwds):\n        GraphicsObject.__init__(self)\n        self.scatter = ScatterPlotItem()\n        self.scatter.setParentItem(self)\n        self.adjacency = None\n        self.pos = None\n        self.picture = None\n        self.pen = \'default\'\n        self.setData(**kwds)\n        \n    def setData(self, **kwds):\n        """"""\n        Change the data displayed by the graph. \n        \n        ==============  =======================================================================\n        **Arguments:**\n        pos             (N,2) array of the positions of each node in the graph.\n        adj             (M,2) array of connection data. Each row contains indexes\n                        of two nodes that are connected.\n        pen             The pen to use when drawing lines between connected\n                        nodes. May be one of:\n                     \n                        * QPen\n                        * a single argument to pass to pg.mkPen\n                        * a record array of length M\n                          with fields (red, green, blue, alpha, width). Note\n                          that using this option may have a significant performance\n                          cost.\n                        * None (to disable connection drawing)\n                        * \'default\' to use the default foreground color.\n                     \n        symbolPen       The pen(s) used for drawing nodes.\n        symbolBrush     The brush(es) used for drawing nodes.\n        ``**opts``      All other keyword arguments are given to\n                        :func:`ScatterPlotItem.setData() <pyqtgraph.ScatterPlotItem.setData>`\n                        to affect the appearance of nodes (symbol, size, brush,\n                        etc.)\n        ==============  =======================================================================\n        """"""\n        if \'adj\' in kwds:\n            self.adjacency = kwds.pop(\'adj\')\n            if self.adjacency.dtype.kind not in \'iu\':\n                raise Exception(""adjacency array must have int or unsigned type."")\n            self._update()\n        if \'pos\' in kwds:\n            self.pos = kwds[\'pos\']\n            self._update()\n        if \'pen\' in kwds:\n            self.setPen(kwds.pop(\'pen\'))\n            self._update()\n            \n        if \'symbolPen\' in kwds:    \n            kwds[\'pen\'] = kwds.pop(\'symbolPen\')\n        if \'symbolBrush\' in kwds:    \n            kwds[\'brush\'] = kwds.pop(\'symbolBrush\')\n        self.scatter.setData(**kwds)\n        self.informViewBoundsChanged()\n\n    def _update(self):\n        self.picture = None\n        self.prepareGeometryChange()\n        self.update()\n\n    def setPen(self, *args, **kwargs):\n        """"""\n        Set the pen used to draw graph lines.\n        May be: \n        \n        * None to disable line drawing\n        * Record array with fields (red, green, blue, alpha, width)\n        * Any set of arguments and keyword arguments accepted by \n          :func:`mkPen <pyqtgraph.mkPen>`.\n        * \'default\' to use the default foreground color.\n        """"""\n        if len(args) == 1 and len(kwargs) == 0:\n            self.pen = args[0]\n        else:\n            self.pen = fn.mkPen(*args, **kwargs)\n        self.picture = None\n        self.update()\n\n    def generatePicture(self):\n        self.picture = QtGui.QPicture()\n        if self.pen is None or self.pos is None or self.adjacency is None:\n            return\n        \n        p = QtGui.QPainter(self.picture)\n        try:\n            pts = self.pos[self.adjacency]\n            pen = self.pen\n            if isinstance(pen, np.ndarray):\n                lastPen = None\n                for i in range(pts.shape[0]):\n                    pen = self.pen[i]\n                    if np.any(pen != lastPen):\n                        lastPen = pen\n                        if pen.dtype.fields is None:\n                            p.setPen(fn.mkPen(color=(pen[0], pen[1], pen[2], pen[3]), width=1))                            \n                        else:\n                            p.setPen(fn.mkPen(color=(pen[\'red\'], pen[\'green\'], pen[\'blue\'], pen[\'alpha\']), width=pen[\'width\']))\n                    p.drawLine(QtCore.QPointF(*pts[i][0]), QtCore.QPointF(*pts[i][1]))\n            else:\n                if pen == \'default\':\n                    pen = getConfigOption(\'foreground\')\n                p.setPen(fn.mkPen(pen))\n                pts = pts.reshape((pts.shape[0]*pts.shape[1], pts.shape[2]))\n                path = fn.arrayToQPath(x=pts[:,0], y=pts[:,1], connect=\'pairs\')\n                p.drawPath(path)\n        finally:\n            p.end()\n\n    def paint(self, p, *args):\n        if self.picture == None:\n            self.generatePicture()\n        if getConfigOption(\'antialias\') is True:\n            p.setRenderHint(p.Antialiasing)\n        self.picture.play(p)\n        \n    def boundingRect(self):\n        return self.scatter.boundingRect()\n        \n    def dataBounds(self, *args, **kwds):\n        return self.scatter.dataBounds(*args, **kwds)\n    \n    def pixelPadding(self):\n        return self.scatter.pixelPadding()\n        \n        \n        \n        \n\n'"
src/third_party/pyqtgraph/graphicsItems/GraphicsItem.py,0,"b'from ..Qt import QtGui, QtCore, isQObjectAlive\nfrom ..GraphicsScene import GraphicsScene\nfrom ..Point import Point\nfrom .. import functions as fn\nimport weakref\nimport operator\nfrom ..util.lru_cache import LRUCache\n\n\nclass GraphicsItem(object):\n    """"""\n    **Bases:** :class:`object`\n\n    Abstract class providing useful methods to GraphicsObject and GraphicsWidget.\n    (This is required because we cannot have multiple inheritance with QObject subclasses.)\n\n    A note about Qt\'s GraphicsView framework:\n\n    The GraphicsView system places a lot of emphasis on the notion that the graphics within the scene should be device independent--you should be able to take the same graphics and display them on screens of different resolutions, printers, export to SVG, etc. This is nice in principle, but causes me a lot of headache in practice. It means that I have to circumvent all the device-independent expectations any time I want to operate in pixel coordinates rather than arbitrary scene coordinates. A lot of the code in GraphicsItem is devoted to this task--keeping track of view widgets and device transforms, computing the size and shape of a pixel in local item coordinates, etc. Note that in item coordinates, a pixel does not have to be square or even rectangular, so just asking how to increase a bounding rect by 2px can be a rather complex task.\n    """"""\n    _pixelVectorGlobalCache = LRUCache(100, 70)\n    \n    def __init__(self, register=True):\n        if not hasattr(self, \'_qtBaseClass\'):\n            for b in self.__class__.__bases__:\n                if issubclass(b, QtGui.QGraphicsItem):\n                    self.__class__._qtBaseClass = b\n                    break\n        if not hasattr(self, \'_qtBaseClass\'):\n            raise Exception(\'Could not determine Qt base class for GraphicsItem: %s\' % str(self))\n        \n        self._pixelVectorCache = [None, None]\n        self._viewWidget = None\n        self._viewBox = None\n        self._connectedView = None\n        self._exportOpts = False   ## If False, not currently exporting. Otherwise, contains dict of export options.\n        if register:\n            GraphicsScene.registerObject(self)  ## workaround for pyqt bug in graphicsscene.items()\n                    \n    def getViewWidget(self):\n        """"""\n        Return the view widget for this item. \n        \n        If the scene has multiple views, only the first view is returned.\n        The return value is cached; clear the cached value with forgetViewWidget().\n        If the view has been deleted by Qt, return None.\n        """"""\n        if self._viewWidget is None:\n            scene = self.scene()\n            if scene is None:\n                return None\n            views = scene.views()\n            if len(views) < 1:\n                return None\n            self._viewWidget = weakref.ref(self.scene().views()[0])\n            \n        v = self._viewWidget()\n        if v is not None and not isQObjectAlive(v):\n            return None\n            \n        return v\n    \n    def forgetViewWidget(self):\n        self._viewWidget = None\n    \n    def getViewBox(self):\n        """"""\n        Return the first ViewBox or GraphicsView which bounds this item\'s visible space.\n        If this item is not contained within a ViewBox, then the GraphicsView is returned.\n        If the item is contained inside nested ViewBoxes, then the inner-most ViewBox is returned.\n        The result is cached; clear the cache with forgetViewBox()\n        """"""\n        if self._viewBox is None:\n            p = self\n            while True:\n                try:\n                    p = p.parentItem()\n                except RuntimeError:  ## sometimes happens as items are being removed from a scene and collected.\n                    return None\n                if p is None:\n                    vb = self.getViewWidget()\n                    if vb is None:\n                        return None\n                    else:\n                        self._viewBox = weakref.ref(vb)\n                        break\n                if hasattr(p, \'implements\') and p.implements(\'ViewBox\'):\n                    self._viewBox = weakref.ref(p)\n                    break\n        return self._viewBox()  ## If we made it this far, _viewBox is definitely not None\n\n    def forgetViewBox(self):\n        self._viewBox = None\n        \n    def deviceTransform(self, viewportTransform=None):\n        """"""\n        Return the transform that converts local item coordinates to device coordinates (usually pixels).\n        Extends deviceTransform to automatically determine the viewportTransform.\n        """"""\n        if self._exportOpts is not False and \'painter\' in self._exportOpts: ## currently exporting; device transform may be different.\n            return self._exportOpts[\'painter\'].deviceTransform() * self.sceneTransform()\n            \n        if viewportTransform is None:\n            view = self.getViewWidget()\n            if view is None:\n                return None\n            viewportTransform = view.viewportTransform()\n        dt = self._qtBaseClass.deviceTransform(self, viewportTransform)\n        \n        #xmag = abs(dt.m11())+abs(dt.m12())\n        #ymag = abs(dt.m21())+abs(dt.m22())\n        #if xmag * ymag == 0: \n        if dt.determinant() == 0:  ## occurs when deviceTransform is invalid because widget has not been displayed\n            return None\n        else:\n            return dt\n        \n    def viewTransform(self):\n        """"""Return the transform that maps from local coordinates to the item\'s ViewBox coordinates\n        If there is no ViewBox, return the scene transform.\n        Returns None if the item does not have a view.""""""\n        view = self.getViewBox()\n        if view is None:\n            return None\n        if hasattr(view, \'implements\') and view.implements(\'ViewBox\'):\n            tr = self.itemTransform(view.innerSceneItem())\n            if isinstance(tr, tuple):\n                tr = tr[0]   ## difference between pyside and pyqt\n            return tr\n        else:\n            return self.sceneTransform()\n            #return self.deviceTransform(view.viewportTransform())\n\n\n\n    def getBoundingParents(self):\n        """"""Return a list of parents to this item that have child clipping enabled.""""""\n        p = self\n        parents = []\n        while True:\n            p = p.parentItem()\n            if p is None:\n                break\n            if p.flags() & self.ItemClipsChildrenToShape:\n                parents.append(p)\n        return parents\n    \n    def viewRect(self):\n        """"""Return the visible bounds of this item\'s ViewBox or GraphicsWidget,\n        in the local coordinate system of the item.""""""\n        view = self.getViewBox()\n        if view is None:\n            return None\n        bounds = self.mapRectFromView(view.viewRect())\n        if bounds is None:\n            return None\n\n        bounds = bounds.normalized()\n        \n        ## nah.\n        #for p in self.getBoundingParents():\n            #bounds &= self.mapRectFromScene(p.sceneBoundingRect())\n            \n        return bounds\n        \n        \n        \n    def pixelVectors(self, direction=None):\n        """"""Return vectors in local coordinates representing the width and height of a view pixel.\n        If direction is specified, then return vectors parallel and orthogonal to it.\n        \n        Return (None, None) if pixel size is not yet defined (usually because the item has not yet been displayed)\n        or if pixel size is below floating-point precision limit.\n        """"""\n        \n        ## This is an expensive function that gets called very frequently.\n        ## We have two levels of cache to try speeding things up.\n        \n        dt = self.deviceTransform()\n        if dt is None:\n            return None, None\n            \n        ## Ignore translation. If the translation is much larger than the scale\n        ## (such as when looking at unix timestamps), we can get floating-point errors.\n        dt.setMatrix(dt.m11(), dt.m12(), 0, dt.m21(), dt.m22(), 0, 0, 0, 1)\n        \n        ## check local cache\n        if direction is None and dt == self._pixelVectorCache[0]:\n            return tuple(map(Point, self._pixelVectorCache[1]))  ## return a *copy*\n        \n        ## check global cache\n        #key = (dt.m11(), dt.m21(), dt.m31(), dt.m12(), dt.m22(), dt.m32(), dt.m31(), dt.m32())\n        key = (dt.m11(), dt.m21(), dt.m12(), dt.m22())\n        pv = self._pixelVectorGlobalCache.get(key, None)\n        if direction is None and pv is not None:\n            self._pixelVectorCache = [dt, pv]\n            return tuple(map(Point,pv))  ## return a *copy*\n        \n        \n        if direction is None:\n            direction = QtCore.QPointF(1, 0)  \n        if direction.manhattanLength() == 0:\n            raise Exception(""Cannot compute pixel length for 0-length vector."")\n            \n        ## attempt to re-scale direction vector to fit within the precision of the coordinate system\n        ## Here\'s the problem: we need to map the vector \'direction\' from the item to the device, via transform \'dt\'.\n        ## In some extreme cases, this mapping can fail unless the length of \'direction\' is cleverly chosen.\n        ## Example:\n        ##   dt = [ 1, 0,    2 \n        ##          0, 2, 1e20\n        ##          0, 0,    1 ]\n        ## Then we map the origin (0,0) and direction (0,1) and get:\n        ##    o\' = 2,1e20\n        ##    d\' = 2,1e20  <-- should be 1e20+2, but this can\'t be represented with a 32-bit float\n        ##    \n        ##    |o\' - d\'|  == 0    <-- this is the problem.\n        \n        ## Perhaps the easiest solution is to exclude the transformation column from dt. Does this cause any other problems?\n        \n        #if direction.x() == 0:\n            #r = abs(dt.m32())/(abs(dt.m12()) + abs(dt.m22()))\n            ##r = 1.0/(abs(dt.m12()) + abs(dt.m22()))\n        #elif direction.y() == 0:\n            #r = abs(dt.m31())/(abs(dt.m11()) + abs(dt.m21()))\n            ##r = 1.0/(abs(dt.m11()) + abs(dt.m21()))\n        #else:\n            #r = ((abs(dt.m32())/(abs(dt.m12()) + abs(dt.m22()))) * (abs(dt.m31())/(abs(dt.m11()) + abs(dt.m21()))))**0.5\n        #if r == 0:\n            #r = 1.  ## shouldn\'t need to do this; probably means the math above is wrong?\n        #directionr = direction * r\n        directionr = direction\n        \n        ## map direction vector onto device\n        #viewDir = Point(dt.map(directionr) - dt.map(Point(0,0)))\n        #mdirection = dt.map(directionr)\n        dirLine = QtCore.QLineF(QtCore.QPointF(0,0), directionr)\n        viewDir = dt.map(dirLine)\n        if viewDir.length() == 0:\n            return None, None   ##  pixel size cannot be represented on this scale\n           \n        ## get unit vector and orthogonal vector (length of pixel)\n        #orthoDir = Point(viewDir[1], -viewDir[0])  ## orthogonal to line in pixel-space\n        try:  \n            normView = viewDir.unitVector()\n            #normView = viewDir.norm()  ## direction of one pixel orthogonal to line\n            normOrtho = normView.normalVector()\n            #normOrtho = orthoDir.norm()\n        except:\n            raise Exception(""Invalid direction %s"" %directionr)\n            \n        ## map back to item \n        dti = fn.invertQTransform(dt)\n        #pv = Point(dti.map(normView)-dti.map(Point(0,0))), Point(dti.map(normOrtho)-dti.map(Point(0,0)))\n        pv = Point(dti.map(normView).p2()), Point(dti.map(normOrtho).p2())\n        self._pixelVectorCache[1] = pv\n        self._pixelVectorCache[0] = dt\n        self._pixelVectorGlobalCache[key] = pv\n        return self._pixelVectorCache[1]\n    \n        \n    def pixelLength(self, direction, ortho=False):\n        """"""Return the length of one pixel in the direction indicated (in local coordinates)\n        If ortho=True, then return the length of one pixel orthogonal to the direction indicated.\n        \n        Return None if pixel size is not yet defined (usually because the item has not yet been displayed).\n        """"""\n        normV, orthoV = self.pixelVectors(direction)\n        if normV == None or orthoV == None:\n            return None\n        if ortho:\n            return orthoV.length()\n        return normV.length()\n        \n\n    def pixelSize(self):\n        ## deprecated\n        v = self.pixelVectors()\n        if v == (None, None):\n            return None, None\n        return (v[0].x()**2+v[0].y()**2)**0.5, (v[1].x()**2+v[1].y()**2)**0.5\n\n    def pixelWidth(self):\n        ## deprecated\n        vt = self.deviceTransform()\n        if vt is None:\n            return 0\n        vt = fn.invertQTransform(vt)\n        return vt.map(QtCore.QLineF(0, 0, 1, 0)).length()\n        \n    def pixelHeight(self):\n        ## deprecated\n        vt = self.deviceTransform()\n        if vt is None:\n            return 0\n        vt = fn.invertQTransform(vt)\n        return vt.map(QtCore.QLineF(0, 0, 0, 1)).length()\n        #return Point(vt.map(QtCore.QPointF(0, 1))-vt.map(QtCore.QPointF(0, 0))).length()\n        \n        \n    def mapToDevice(self, obj):\n        """"""\n        Return *obj* mapped from local coordinates to device coordinates (pixels).\n        If there is no device mapping available, return None.\n        """"""\n        vt = self.deviceTransform()\n        if vt is None:\n            return None\n        return vt.map(obj)\n        \n    def mapFromDevice(self, obj):\n        """"""\n        Return *obj* mapped from device coordinates (pixels) to local coordinates.\n        If there is no device mapping available, return None.\n        """"""\n        vt = self.deviceTransform()\n        if vt is None:\n            return None\n        if isinstance(obj, QtCore.QPoint):\n            obj = QtCore.QPointF(obj)\n        vt = fn.invertQTransform(vt)\n        return vt.map(obj)\n\n    def mapRectToDevice(self, rect):\n        """"""\n        Return *rect* mapped from local coordinates to device coordinates (pixels).\n        If there is no device mapping available, return None.\n        """"""\n        vt = self.deviceTransform()\n        if vt is None:\n            return None\n        return vt.mapRect(rect)\n\n    def mapRectFromDevice(self, rect):\n        """"""\n        Return *rect* mapped from device coordinates (pixels) to local coordinates.\n        If there is no device mapping available, return None.\n        """"""\n        vt = self.deviceTransform()\n        if vt is None:\n            return None\n        vt = fn.invertQTransform(vt)\n        return vt.mapRect(rect)\n    \n    def mapToView(self, obj):\n        vt = self.viewTransform()\n        if vt is None:\n            return None\n        return vt.map(obj)\n        \n    def mapRectToView(self, obj):\n        vt = self.viewTransform()\n        if vt is None:\n            return None\n        return vt.mapRect(obj)\n        \n    def mapFromView(self, obj):\n        vt = self.viewTransform()\n        if vt is None:\n            return None\n        vt = fn.invertQTransform(vt)\n        return vt.map(obj)\n\n    def mapRectFromView(self, obj):\n        vt = self.viewTransform()\n        if vt is None:\n            return None\n        vt = fn.invertQTransform(vt)\n        return vt.mapRect(obj)\n\n    def pos(self):\n        return Point(self._qtBaseClass.pos(self))\n    \n    def viewPos(self):\n        return self.mapToView(self.mapFromParent(self.pos()))\n    \n    def parentItem(self):\n        ## PyQt bug -- some items are returned incorrectly.\n        return GraphicsScene.translateGraphicsItem(self._qtBaseClass.parentItem(self))\n        \n    def setParentItem(self, parent):\n        ## Workaround for Qt bug: https://bugreports.qt-project.org/browse/QTBUG-18616\n        if parent is not None:\n            pscene = parent.scene()\n            if pscene is not None and self.scene() is not pscene:\n                pscene.addItem(self)\n        return self._qtBaseClass.setParentItem(self, parent)\n    \n    def childItems(self):\n        ## PyQt bug -- some child items are returned incorrectly.\n        return list(map(GraphicsScene.translateGraphicsItem, self._qtBaseClass.childItems(self)))\n\n\n    def sceneTransform(self):\n        ## Qt bug: do no allow access to sceneTransform() until \n        ## the item has a scene.\n        \n        if self.scene() is None:\n            return self.transform()\n        else:\n            return self._qtBaseClass.sceneTransform(self)\n\n\n    def transformAngle(self, relativeItem=None):\n        """"""Return the rotation produced by this item\'s transform (this assumes there is no shear in the transform)\n        If relativeItem is given, then the angle is determined relative to that item.\n        """"""\n        if relativeItem is None:\n            relativeItem = self.parentItem()\n            \n\n        tr = self.itemTransform(relativeItem)\n        if isinstance(tr, tuple):  ## difference between pyside and pyqt\n            tr = tr[0]\n        #vec = tr.map(Point(1,0)) - tr.map(Point(0,0))\n        vec = tr.map(QtCore.QLineF(0,0,1,0))\n        #return Point(vec).angle(Point(1,0))\n        return vec.angleTo(QtCore.QLineF(vec.p1(), vec.p1()+QtCore.QPointF(1,0)))\n        \n    #def itemChange(self, change, value):\n        #ret = self._qtBaseClass.itemChange(self, change, value)\n        #if change == self.ItemParentHasChanged or change == self.ItemSceneHasChanged:\n            #print ""Item scene changed:"", self\n            #self.setChildScene(self)  ## This is bizarre.\n        #return ret\n\n    #def setChildScene(self, ch):\n        #scene = self.scene()\n        #for ch2 in ch.childItems():\n            #if ch2.scene() is not scene:\n                #print ""item"", ch2, ""has different scene:"", ch2.scene(), scene\n                #scene.addItem(ch2)\n                #QtGui.QApplication.processEvents()\n                #print ""   --> "", ch2.scene()\n            #self.setChildScene(ch2)\n\n    def parentChanged(self):\n        """"""Called when the item\'s parent has changed. \n        This method handles connecting / disconnecting from ViewBox signals\n        to make sure viewRangeChanged works properly. It should generally be \n        extended, not overridden.""""""\n        self._updateView()\n        \n\n    def _updateView(self):\n        ## called to see whether this item has a new view to connect to\n        ## NOTE: This is called from GraphicsObject.itemChange or GraphicsWidget.itemChange.\n\n        if not hasattr(self, \'_connectedView\'):\n            # Happens when Python is shutting down.\n            return\n\n        ## It is possible this item has moved to a different ViewBox or widget;\n        ## clear out previously determined references to these.\n        self.forgetViewBox()\n        self.forgetViewWidget()\n        \n        ## check for this item\'s current viewbox or view widget\n        view = self.getViewBox()\n        #if view is None:\n            ##print ""  no view""\n            #return\n\n        oldView = None\n        if self._connectedView is not None:\n            oldView = self._connectedView()\n            \n        if view is oldView:\n            #print ""  already have view"", view\n            return\n\n        ## disconnect from previous view\n        if oldView is not None:\n            for signal, slot in [(\'sigRangeChanged\', self.viewRangeChanged),\n                                 (\'sigDeviceRangeChanged\', self.viewRangeChanged), \n                                 (\'sigTransformChanged\', self.viewTransformChanged), \n                                 (\'sigDeviceTransformChanged\', self.viewTransformChanged)]:\n                try:\n                    getattr(oldView, signal).disconnect(slot)\n                except (TypeError, AttributeError, RuntimeError):\n                    # TypeError and RuntimeError are from pyqt and pyside, respectively\n                    pass\n            \n            self._connectedView = None\n\n        ## connect to new view\n        if view is not None:\n            #print ""connect:"", self, view\n            if hasattr(view, \'sigDeviceRangeChanged\'):\n                # connect signals from GraphicsView\n                view.sigDeviceRangeChanged.connect(self.viewRangeChanged)\n                view.sigDeviceTransformChanged.connect(self.viewTransformChanged)\n            else:\n                # connect signals from ViewBox\n                view.sigRangeChanged.connect(self.viewRangeChanged)\n                view.sigTransformChanged.connect(self.viewTransformChanged)\n            self._connectedView = weakref.ref(view)\n            self.viewRangeChanged()\n            self.viewTransformChanged()\n        \n        ## inform children that their view might have changed\n        self._replaceView(oldView)\n        \n        self.viewChanged(view, oldView)\n        \n    def viewChanged(self, view, oldView):\n        """"""Called when this item\'s view has changed\n        (ie, the item has been added to or removed from a ViewBox)""""""\n        pass\n        \n    def _replaceView(self, oldView, item=None):\n        if item is None:\n            item = self\n        for child in item.childItems():\n            if isinstance(child, GraphicsItem):\n                if child.getViewBox() is oldView:\n                    child._updateView()\n                        #self._replaceView(oldView, child)\n            else:\n                self._replaceView(oldView, child)\n        \n        \n\n    def viewRangeChanged(self):\n        """"""\n        Called whenever the view coordinates of the ViewBox containing this item have changed.\n        """"""\n        pass\n    \n    def viewTransformChanged(self):\n        """"""\n        Called whenever the transformation matrix of the view has changed.\n        (eg, the view range has changed or the view was resized)\n        """"""\n        pass\n    \n    #def prepareGeometryChange(self):\n        #self._qtBaseClass.prepareGeometryChange(self)\n        #self.informViewBoundsChanged()\n        \n    def informViewBoundsChanged(self):\n        """"""\n        Inform this item\'s container ViewBox that the bounds of this item have changed.\n        This is used by ViewBox to react if auto-range is enabled.\n        """"""\n        view = self.getViewBox()\n        if view is not None and hasattr(view, \'implements\') and view.implements(\'ViewBox\'):\n            view.itemBoundsChanged(self)  ## inform view so it can update its range if it wants\n    \n    def childrenShape(self):\n        """"""Return the union of the shapes of all descendants of this item in local coordinates.""""""\n        childs = self.allChildItems()\n        shapes = [self.mapFromItem(c, c.shape()) for c in self.allChildItems()]\n        return reduce(operator.add, shapes)\n    \n    def allChildItems(self, root=None):\n        """"""Return list of the entire item tree descending from this item.""""""\n        if root is None:\n            root = self\n        tree = []\n        for ch in root.childItems():\n            tree.append(ch)\n            tree.extend(self.allChildItems(ch))\n        return tree\n    \n    \n    def setExportMode(self, export, opts=None):\n        """"""\n        This method is called by exporters to inform items that they are being drawn for export\n        with a specific set of options. Items access these via self._exportOptions.\n        When exporting is complete, _exportOptions is set to False.\n        """"""\n        if opts is None:\n            opts = {}\n        if export:\n            self._exportOpts = opts\n            #if \'antialias\' not in opts:\n                #self._exportOpts[\'antialias\'] = True\n        else:\n            self._exportOpts = False\n    \n    #def update(self):\n        #self._qtBaseClass.update(self)\n        #print ""Update:"", self\n\n    def getContextMenus(self, event):\n        return [self.getMenu()] if hasattr(self, ""getMenu"") else []\n'"
src/third_party/pyqtgraph/graphicsItems/GraphicsLayout.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .. import functions as fn\nfrom .GraphicsWidget import GraphicsWidget\n## Must be imported at the end to avoid cyclic-dependency hell:\nfrom .ViewBox import ViewBox\nfrom .PlotItem import PlotItem\nfrom .LabelItem import LabelItem\n\n__all__ = [\'GraphicsLayout\']\nclass GraphicsLayout(GraphicsWidget):\n    """"""\n    Used for laying out GraphicsWidgets in a grid.\n    This is usually created automatically as part of a :class:`GraphicsWindow <pyqtgraph.GraphicsWindow>` or :class:`GraphicsLayoutWidget <pyqtgraph.GraphicsLayoutWidget>`.\n    """"""\n\n\n    def __init__(self, parent=None, border=None):\n        GraphicsWidget.__init__(self, parent)\n        if border is True:\n            border = (100,100,100)\n        self.border = border\n        self.layout = QtGui.QGraphicsGridLayout()\n        self.setLayout(self.layout)\n        self.items = {}  ## item: [(row, col), (row, col), ...]  lists all cells occupied by the item\n        self.rows = {}   ## row: {col1: item1, col2: item2, ...}    maps cell location to item\n        self.currentRow = 0\n        self.currentCol = 0\n        self.setSizePolicy(QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding))\n    \n    #def resizeEvent(self, ev):\n        #ret = GraphicsWidget.resizeEvent(self, ev)\n        #print self.pos(), self.mapToDevice(self.rect().topLeft())\n        #return ret\n\n    def setBorder(self, *args, **kwds):\n        """"""\n        Set the pen used to draw border between cells.\n        \n        See :func:`mkPen <pyqtgraph.mkPen>` for arguments.        \n        """"""\n        self.border = fn.mkPen(*args, **kwds)\n        self.update()\n    \n    def nextRow(self):\n        """"""Advance to next row for automatic item placement""""""\n        self.currentRow += 1\n        self.currentCol = -1\n        self.nextColumn()\n        \n    def nextColumn(self):\n        """"""Advance to next available column\n        (generally only for internal use--called by addItem)""""""\n        self.currentCol += 1\n        while self.getItem(self.currentRow, self.currentCol) is not None:\n            self.currentCol += 1\n        \n    def nextCol(self, *args, **kargs):\n        """"""Alias of nextColumn""""""\n        return self.nextColumn(*args, **kargs)\n        \n    def addPlot(self, row=None, col=None, rowspan=1, colspan=1, **kargs):\n        """"""\n        Create a PlotItem and place it in the next available cell (or in the cell specified)\n        All extra keyword arguments are passed to :func:`PlotItem.__init__ <pyqtgraph.PlotItem.__init__>`\n        Returns the created item.\n        """"""\n        plot = PlotItem(**kargs)\n        self.addItem(plot, row, col, rowspan, colspan)\n        return plot\n        \n    def addViewBox(self, row=None, col=None, rowspan=1, colspan=1, **kargs):\n        """"""\n        Create a ViewBox and place it in the next available cell (or in the cell specified)\n        All extra keyword arguments are passed to :func:`ViewBox.__init__ <pyqtgraph.ViewBox.__init__>`\n        Returns the created item.\n        """"""\n        vb = ViewBox(**kargs)\n        self.addItem(vb, row, col, rowspan, colspan)\n        return vb\n        \n    def addLabel(self, text=\' \', row=None, col=None, rowspan=1, colspan=1, **kargs):\n        """"""\n        Create a LabelItem with *text* and place it in the next available cell (or in the cell specified)\n        All extra keyword arguments are passed to :func:`LabelItem.__init__ <pyqtgraph.LabelItem.__init__>`\n        Returns the created item.\n        \n        To create a vertical label, use *angle* = -90.\n        """"""\n        text = LabelItem(text, **kargs)\n        self.addItem(text, row, col, rowspan, colspan)\n        return text\n        \n    def addLayout(self, row=None, col=None, rowspan=1, colspan=1, **kargs):\n        """"""\n        Create an empty GraphicsLayout and place it in the next available cell (or in the cell specified)\n        All extra keyword arguments are passed to :func:`GraphicsLayout.__init__ <pyqtgraph.GraphicsLayout.__init__>`\n        Returns the created item.\n        """"""\n        layout = GraphicsLayout(**kargs)\n        self.addItem(layout, row, col, rowspan, colspan)\n        return layout\n        \n    def addItem(self, item, row=None, col=None, rowspan=1, colspan=1):\n        """"""\n        Add an item to the layout and place it in the next available cell (or in the cell specified).\n        The item must be an instance of a QGraphicsWidget subclass.\n        """"""\n        if row is None:\n            row = self.currentRow\n        if col is None:\n            col = self.currentCol\n            \n        self.items[item] = []\n        for i in range(rowspan):\n            for j in range(colspan):\n                row2 = row + i\n                col2 = col + j\n                if row2 not in self.rows:\n                    self.rows[row2] = {}\n                self.rows[row2][col2] = item\n                self.items[item].append((row2, col2))\n        \n        self.layout.addItem(item, row, col, rowspan, colspan)\n        self.nextColumn()\n\n    def getItem(self, row, col):\n        """"""Return the item in (*row*, *col*). If the cell is empty, return None.""""""\n        return self.rows.get(row, {}).get(col, None)\n\n    def boundingRect(self):\n        return self.rect()\n        \n    def paint(self, p, *args):\n        if self.border is None:\n            return\n        p.setPen(fn.mkPen(self.border))\n        for i in self.items:\n            r = i.mapRectToParent(i.boundingRect())\n            p.drawRect(r)\n    \n    def itemIndex(self, item):\n        for i in range(self.layout.count()):\n            if self.layout.itemAt(i).graphicsItem() is item:\n                return i\n        raise Exception(""Could not determine index of item "" + str(item))\n    \n    def removeItem(self, item):\n        """"""Remove *item* from the layout.""""""\n        ind = self.itemIndex(item)\n        self.layout.removeAt(ind)\n        self.scene().removeItem(item)\n        \n        for r,c in self.items[item]:\n            del self.rows[r][c]\n        del self.items[item]\n        self.update()\n    \n    def clear(self):\n        items = []\n        for i in list(self.items.keys()):\n            self.removeItem(i)\n\n    def setContentsMargins(self, *args):\n        # Wrap calls to layout. This should happen automatically, but there\n        # seems to be a Qt bug:\n        # http://stackoverflow.com/questions/27092164/margins-in-pyqtgraphs-graphicslayout\n        self.layout.setContentsMargins(*args)\n\n    def setSpacing(self, *args):\n        self.layout.setSpacing(*args)\n    '"
src/third_party/pyqtgraph/graphicsItems/GraphicsObject.py,0,"b'from ..Qt import QtGui, QtCore, QT_LIB\nif QT_LIB in [\'PyQt4\', \'PyQt5\']:\n    import sip\nfrom .GraphicsItem import GraphicsItem\n\n__all__ = [\'GraphicsObject\']\nclass GraphicsObject(GraphicsItem, QtGui.QGraphicsObject):\n    """"""\n    **Bases:** :class:`GraphicsItem <pyqtgraph.graphicsItems.GraphicsItem>`, :class:`QtGui.QGraphicsObject`\n\n    Extension of QGraphicsObject with some useful methods (provided by :class:`GraphicsItem <pyqtgraph.graphicsItems.GraphicsItem>`)\n    """"""\n    _qtBaseClass = QtGui.QGraphicsObject\n    def __init__(self, *args):\n        self.__inform_view_on_changes = True\n        QtGui.QGraphicsObject.__init__(self, *args)\n        self.setFlag(self.ItemSendsGeometryChanges)\n        GraphicsItem.__init__(self)\n        \n    def itemChange(self, change, value):\n        ret = QtGui.QGraphicsObject.itemChange(self, change, value)\n        if change in [self.ItemParentHasChanged, self.ItemSceneHasChanged]:\n            self.parentChanged()\n        try:\n            inform_view_on_change = self.__inform_view_on_changes\n        except AttributeError:\n            # It\'s possible that the attribute was already collected when the itemChange happened\n            # (if it was triggered during the gc of the object).\n            pass\n        else:\n            if inform_view_on_change and change in [self.ItemPositionHasChanged, self.ItemTransformHasChanged]:\n                self.informViewBoundsChanged()\n            \n        ## workaround for pyqt bug:\n        ## http://www.riverbankcomputing.com/pipermail/pyqt/2012-August/031818.html\n        if QT_LIB in [\'PyQt4\', \'PyQt5\'] and change == self.ItemParentChange and isinstance(ret, QtGui.QGraphicsItem):\n            ret = sip.cast(ret, QtGui.QGraphicsItem)\n\n        return ret\n'"
src/third_party/pyqtgraph/graphicsItems/GraphicsWidget.py,0,"b'from ..Qt import QtGui, QtCore  \nfrom ..GraphicsScene import GraphicsScene\nfrom .GraphicsItem import GraphicsItem\n\n__all__ = [\'GraphicsWidget\']\n\nclass GraphicsWidget(GraphicsItem, QtGui.QGraphicsWidget):\n    \n    _qtBaseClass = QtGui.QGraphicsWidget\n    def __init__(self, *args, **kargs):\n        """"""\n        **Bases:** :class:`GraphicsItem <pyqtgraph.GraphicsItem>`, :class:`QtGui.QGraphicsWidget`\n        \n        Extends QGraphicsWidget with several helpful methods and workarounds for PyQt bugs. \n        Most of the extra functionality is inherited from :class:`GraphicsItem <pyqtgraph.GraphicsItem>`.\n        """"""\n        QtGui.QGraphicsWidget.__init__(self, *args, **kargs)\n        GraphicsItem.__init__(self)\n        \n        ## done by GraphicsItem init\n        #GraphicsScene.registerObject(self)  ## workaround for pyqt bug in graphicsscene.items()\n\n    # Removed due to https://bugreports.qt-project.org/browse/PYSIDE-86\n    #def itemChange(self, change, value):\n        ## BEWARE: Calling QGraphicsWidget.itemChange can lead to crashing!\n        ##ret = QtGui.QGraphicsWidget.itemChange(self, change, value)  ## segv occurs here\n        ## The default behavior is just to return the value argument, so we\'ll do that\n        ## without calling the original method.\n        #ret = value\n        #if change in [self.ItemParentHasChanged, self.ItemSceneHasChanged]:\n            #self._updateView()\n        #return ret\n\n    def setFixedHeight(self, h):\n        self.setMaximumHeight(h)\n        self.setMinimumHeight(h)\n\n    def setFixedWidth(self, h):\n        self.setMaximumWidth(h)\n        self.setMinimumWidth(h)\n        \n    def height(self):\n        return self.geometry().height()\n    \n    def width(self):\n        return self.geometry().width()\n\n    def boundingRect(self):\n        br = self.mapRectFromParent(self.geometry()).normalized()\n        #print ""bounds:"", br\n        return br\n        \n    def shape(self):  ## No idea why this is necessary, but rotated items do not receive clicks otherwise.\n        p = QtGui.QPainterPath()\n        p.addRect(self.boundingRect())\n        #print ""shape:"", p.boundingRect()\n        return p\n\n\n'"
src/third_party/pyqtgraph/graphicsItems/GraphicsWidgetAnchor.py,0,"b'from ..Qt import QtGui, QtCore\nfrom ..Point import Point\n\n\nclass GraphicsWidgetAnchor(object):\n    """"""\n    Class used to allow GraphicsWidgets to anchor to a specific position on their\n    parent. The item will be automatically repositioned if the parent is resized. \n    This is used, for example, to anchor a LegendItem to a corner of its parent \n    PlotItem.\n\n    """"""\n\n    def __init__(self):\n        self.__parent = None\n        self.__parentAnchor = None\n        self.__itemAnchor = None\n        self.__offset = (0,0)\n        if hasattr(self, \'geometryChanged\'):\n            self.geometryChanged.connect(self.__geometryChanged)\n\n    def anchor(self, itemPos, parentPos, offset=(0,0)):\n        """"""\n        Anchors the item at its local itemPos to the item\'s parent at parentPos.\n        Both positions are expressed in values relative to the size of the item or parent;\n        a value of 0 indicates left or top edge, while 1 indicates right or bottom edge.\n        \n        Optionally, offset may be specified to introduce an absolute offset. \n        \n        Example: anchor a box such that its upper-right corner is fixed 10px left\n        and 10px down from its parent\'s upper-right corner::\n        \n            box.anchor(itemPos=(1,0), parentPos=(1,0), offset=(-10,10))\n        """"""\n        parent = self.parentItem()\n        if parent is None:\n            raise Exception(""Cannot anchor; parent is not set."")\n        \n        if self.__parent is not parent:\n            if self.__parent is not None:\n                self.__parent.geometryChanged.disconnect(self.__geometryChanged)\n                \n            self.__parent = parent\n            parent.geometryChanged.connect(self.__geometryChanged)\n        \n        self.__itemAnchor = itemPos\n        self.__parentAnchor = parentPos\n        self.__offset = offset\n        self.__geometryChanged()\n    \n\n    def autoAnchor(self, pos, relative=True):\n        """"""\n        Set the position of this item relative to its parent by automatically \n        choosing appropriate anchor settings.\n        \n        If relative is True, one corner of the item will be anchored to \n        the appropriate location on the parent with no offset. The anchored\n        corner will be whichever is closest to the parent\'s boundary.\n        \n        If relative is False, one corner of the item will be anchored to the same\n        corner of the parent, with an absolute offset to achieve the correct\n        position. \n        """"""\n        pos = Point(pos)\n        br = self.mapRectToParent(self.boundingRect()).translated(pos - self.pos())\n        pbr = self.parentItem().boundingRect()\n        anchorPos = [0,0]\n        parentPos = Point()\n        itemPos = Point()\n        if abs(br.left() - pbr.left()) < abs(br.right() - pbr.right()):\n            anchorPos[0] = 0\n            parentPos[0] = pbr.left()\n            itemPos[0] = br.left()\n        else:\n            anchorPos[0] = 1\n            parentPos[0] = pbr.right()\n            itemPos[0] = br.right()\n\n        if abs(br.top() - pbr.top()) < abs(br.bottom() - pbr.bottom()):\n            anchorPos[1] = 0\n            parentPos[1] = pbr.top()\n            itemPos[1] = br.top()\n        else:\n            anchorPos[1] = 1\n            parentPos[1] = pbr.bottom()\n            itemPos[1] = br.bottom()\n        \n        if relative:\n            relPos = [(itemPos[0]-pbr.left()) / pbr.width(), (itemPos[1]-pbr.top()) / pbr.height()]\n            self.anchor(anchorPos, relPos)\n        else:\n            offset = itemPos - parentPos\n            self.anchor(anchorPos, anchorPos, offset)\n    \n    def __geometryChanged(self):\n        if self.__parent is None:\n            return\n        if self.__itemAnchor is None:\n            return\n            \n        o = self.mapToParent(Point(0,0))\n        a = self.boundingRect().bottomRight() * Point(self.__itemAnchor)\n        a = self.mapToParent(a)\n        p = self.__parent.boundingRect().bottomRight() * Point(self.__parentAnchor)\n        off = Point(self.__offset)\n        pos = p + (o-a) + off\n        self.setPos(pos)\n        \n        '"
src/third_party/pyqtgraph/graphicsItems/GridItem.py,8,"b'from ..Qt import QtGui, QtCore\nfrom .UIGraphicsItem import *\nimport numpy as np\nfrom ..Point import Point\nfrom .. import functions as fn\n\n__all__ = [\'GridItem\']\nclass GridItem(UIGraphicsItem):\n    """"""\n    **Bases:** :class:`UIGraphicsItem <pyqtgraph.UIGraphicsItem>`\n    \n    Displays a rectangular grid of lines indicating major divisions within a coordinate system.\n    Automatically determines what divisions to use.\n    """"""\n    \n    def __init__(self):\n        UIGraphicsItem.__init__(self)\n        #QtGui.QGraphicsItem.__init__(self, *args)\n        #self.setFlag(QtGui.QGraphicsItem.ItemClipsToShape)\n        #self.setCacheMode(QtGui.QGraphicsItem.DeviceCoordinateCache)\n        \n        self.picture = None\n        \n        \n    def viewRangeChanged(self):\n        UIGraphicsItem.viewRangeChanged(self)\n        self.picture = None\n        #UIGraphicsItem.viewRangeChanged(self)\n        #self.update()\n        \n    def paint(self, p, opt, widget):\n        #p.setPen(QtGui.QPen(QtGui.QColor(100, 100, 100)))\n        #p.drawRect(self.boundingRect())\n        #UIGraphicsItem.paint(self, p, opt, widget)\n        ### draw picture\n        if self.picture is None:\n            #print ""no pic, draw..""\n            self.generatePicture()\n        p.drawPicture(QtCore.QPointF(0, 0), self.picture)\n        #p.setPen(QtGui.QPen(QtGui.QColor(255,0,0)))\n        #p.drawLine(0, -100, 0, 100)\n        #p.drawLine(-100, 0, 100, 0)\n        #print ""drawing Grid.""\n        \n        \n    def generatePicture(self):\n        self.picture = QtGui.QPicture()\n        p = QtGui.QPainter()\n        p.begin(self.picture)\n        \n        dt = fn.invertQTransform(self.viewTransform())\n        vr = self.getViewWidget().rect()\n        unit = self.pixelWidth(), self.pixelHeight()\n        dim = [vr.width(), vr.height()]\n        lvr = self.boundingRect()\n        ul = np.array([lvr.left(), lvr.top()])\n        br = np.array([lvr.right(), lvr.bottom()])\n        \n        texts = []\n        \n        if ul[1] > br[1]:\n            x = ul[1]\n            ul[1] = br[1]\n            br[1] = x\n        for i in [2,1,0]:   ## Draw three different scales of grid\n            dist = br-ul\n            nlTarget = 10.**i\n            d = 10. ** np.floor(np.log10(abs(dist/nlTarget))+0.5)\n            ul1 = np.floor(ul / d) * d\n            br1 = np.ceil(br / d) * d\n            dist = br1-ul1\n            nl = (dist / d) + 0.5\n            #print ""level"", i\n            #print ""  dim"", dim\n            #print ""  dist"", dist\n            #print ""  d"", d\n            #print ""  nl"", nl\n            for ax in range(0,2):  ## Draw grid for both axes\n                ppl = dim[ax] / nl[ax]\n                c = np.clip(3.*(ppl-3), 0., 30.)\n                linePen = QtGui.QPen(QtGui.QColor(255, 255, 255, c)) \n                textPen = QtGui.QPen(QtGui.QColor(255, 255, 255, c*2)) \n                #linePen.setCosmetic(True)\n                #linePen.setWidth(1)\n                bx = (ax+1) % 2\n                for x in range(0, int(nl[ax])):\n                    linePen.setCosmetic(False)\n                    if ax == 0:\n                        linePen.setWidthF(self.pixelWidth())\n                        #print ""ax 0 height"", self.pixelHeight()\n                    else:\n                        linePen.setWidthF(self.pixelHeight())\n                        #print ""ax 1 width"", self.pixelWidth()\n                    p.setPen(linePen)\n                    p1 = np.array([0.,0.])\n                    p2 = np.array([0.,0.])\n                    p1[ax] = ul1[ax] + x * d[ax]\n                    p2[ax] = p1[ax]\n                    p1[bx] = ul[bx]\n                    p2[bx] = br[bx]\n                    ## don\'t draw lines that are out of bounds.\n                    if p1[ax] < min(ul[ax], br[ax]) or p1[ax] > max(ul[ax], br[ax]):\n                        continue\n                    p.drawLine(QtCore.QPointF(p1[0], p1[1]), QtCore.QPointF(p2[0], p2[1]))\n                    if i < 2:\n                        p.setPen(textPen)\n                        if ax == 0:\n                            x = p1[0] + unit[0]\n                            y = ul[1] + unit[1] * 8.\n                        else:\n                            x = ul[0] + unit[0]*3\n                            y = p1[1] + unit[1]\n                        texts.append((QtCore.QPointF(x, y), ""%g""%p1[ax]))\n        tr = self.deviceTransform()\n        #tr.scale(1.5, 1.5)\n        p.setWorldTransform(fn.invertQTransform(tr))\n        for t in texts:\n            x = tr.map(t[0]) + Point(0.5, 0.5)\n            p.drawText(x, t[1])\n        p.end()\n'"
src/third_party/pyqtgraph/graphicsItems/HistogramLUTItem.py,3,"b'""""""\nGraphicsWidget displaying an image histogram along with gradient editor. Can be used to adjust the appearance of images.\n""""""\n\n\nfrom ..Qt import QtGui, QtCore\nfrom .. import functions as fn\nfrom .GraphicsWidget import GraphicsWidget\nfrom .ViewBox import *\nfrom .GradientEditorItem import *\nfrom .LinearRegionItem import *\nfrom .PlotDataItem import *\nfrom .AxisItem import *\nfrom .GridItem import *\nfrom ..Point import Point\nfrom .. import functions as fn\nimport numpy as np\nfrom .. import debug as debug\n\nimport weakref\n\n__all__ = [\'HistogramLUTItem\']\n\n\nclass HistogramLUTItem(GraphicsWidget):\n    """"""\n    This is a graphicsWidget which provides controls for adjusting the display of an image.\n    \n    Includes:\n\n    - Image histogram \n    - Movable region over histogram to select black/white levels\n    - Gradient editor to define color lookup table for single-channel images\n    \n    Parameters\n    ----------\n    image : ImageItem or None\n        If *image* is provided, then the control will be automatically linked to\n        the image and changes to the control will be immediately reflected in\n        the image\'s appearance.\n    fillHistogram : bool\n        By default, the histogram is rendered with a fill.\n        For performance, set *fillHistogram* = False.    \n    rgbHistogram : bool\n        Sets whether the histogram is computed once over all channels of the\n        image, or once per channel.\n    levelMode : \'mono\' or \'rgba\'\n        If \'mono\', then only a single set of black/whilte level lines is drawn,\n        and the levels apply to all channels in the image. If \'rgba\', then one\n        set of levels is drawn for each channel.\n    """"""\n    \n    sigLookupTableChanged = QtCore.Signal(object)\n    sigLevelsChanged = QtCore.Signal(object)\n    sigLevelChangeFinished = QtCore.Signal(object)\n    \n    def __init__(self, image=None, fillHistogram=True, rgbHistogram=False, levelMode=\'mono\'):\n        GraphicsWidget.__init__(self)\n        self.lut = None\n        self.imageItem = lambda: None  # fake a dead weakref\n        self.levelMode = levelMode\n        self.rgbHistogram = rgbHistogram\n        \n        self.layout = QtGui.QGraphicsGridLayout()\n        self.setLayout(self.layout)\n        self.layout.setContentsMargins(1,1,1,1)\n        self.layout.setSpacing(0)\n        self.vb = ViewBox(parent=self)\n        self.vb.setMaximumWidth(152)\n        self.vb.setMinimumWidth(45)\n        self.vb.setMouseEnabled(x=False, y=True)\n        self.gradient = GradientEditorItem()\n        self.gradient.setOrientation(\'right\')\n        self.gradient.loadPreset(\'grey\')\n        self.regions = [\n            LinearRegionItem([0, 1], \'horizontal\', swapMode=\'block\'),\n            LinearRegionItem([0, 1], \'horizontal\', swapMode=\'block\', pen=\'r\',\n                             brush=fn.mkBrush((255, 50, 50, 50)), span=(0., 1/3.)),\n            LinearRegionItem([0, 1], \'horizontal\', swapMode=\'block\', pen=\'g\',\n                             brush=fn.mkBrush((50, 255, 50, 50)), span=(1/3., 2/3.)),\n            LinearRegionItem([0, 1], \'horizontal\', swapMode=\'block\', pen=\'b\',\n                             brush=fn.mkBrush((50, 50, 255, 80)), span=(2/3., 1.)),\n            LinearRegionItem([0, 1], \'horizontal\', swapMode=\'block\', pen=\'w\',\n                             brush=fn.mkBrush((255, 255, 255, 50)), span=(2/3., 1.))]\n        for region in self.regions:\n            region.setZValue(1000)\n            self.vb.addItem(region)\n            region.lines[0].addMarker(\'<|\', 0.5)\n            region.lines[1].addMarker(\'|>\', 0.5)\n            region.sigRegionChanged.connect(self.regionChanging)\n            region.sigRegionChangeFinished.connect(self.regionChanged)\n            \n        self.region = self.regions[0]  # for backward compatibility.\n        \n        self.axis = AxisItem(\'left\', linkView=self.vb, maxTickLength=-10, parent=self)\n        self.layout.addItem(self.axis, 0, 0)\n        self.layout.addItem(self.vb, 0, 1)\n        self.layout.addItem(self.gradient, 0, 2)\n        self.range = None\n        self.gradient.setFlag(self.gradient.ItemStacksBehindParent)\n        self.vb.setFlag(self.gradient.ItemStacksBehindParent)\n        \n        self.gradient.sigGradientChanged.connect(self.gradientChanged)\n        self.vb.sigRangeChanged.connect(self.viewRangeChanged)\n        add = QtGui.QPainter.CompositionMode_Plus\n        self.plots = [\n            PlotCurveItem(pen=(200, 200, 200, 100)),  # mono\n            PlotCurveItem(pen=(255, 0, 0, 100), compositionMode=add),  # r\n            PlotCurveItem(pen=(0, 255, 0, 100), compositionMode=add),  # g\n            PlotCurveItem(pen=(0, 0, 255, 100), compositionMode=add),  # b\n            PlotCurveItem(pen=(200, 200, 200, 100), compositionMode=add),  # a\n            ]\n        \n        self.plot = self.plots[0]  # for backward compatibility.\n        for plot in self.plots:\n            plot.rotate(90)\n            self.vb.addItem(plot)\n        \n        self.fillHistogram(fillHistogram)\n        self._showRegions()\n            \n        self.vb.addItem(self.plot)\n        self.autoHistogramRange()\n        \n        if image is not None:\n            self.setImageItem(image)\n        \n    def fillHistogram(self, fill=True, level=0.0, color=(100, 100, 200)):\n        colors = [color, (255, 0, 0, 50), (0, 255, 0, 50), (0, 0, 255, 50), (255, 255, 255, 50)]\n        for i,plot in enumerate(self.plots):\n            if fill:\n                plot.setFillLevel(level)\n                plot.setBrush(colors[i])\n            else:\n                plot.setFillLevel(None)\n        \n    def paint(self, p, *args):\n        if self.levelMode != \'mono\':\n            return\n        \n        pen = self.region.lines[0].pen\n        rgn = self.getLevels()\n        p1 = self.vb.mapFromViewToItem(self, Point(self.vb.viewRect().center().x(), rgn[0]))\n        p2 = self.vb.mapFromViewToItem(self, Point(self.vb.viewRect().center().x(), rgn[1]))\n        gradRect = self.gradient.mapRectToParent(self.gradient.gradRect.rect())\n        for pen in [fn.mkPen((0, 0, 0, 100), width=3), pen]:\n            p.setPen(pen)\n            p.drawLine(p1 + Point(0, 5), gradRect.bottomLeft())\n            p.drawLine(p2 - Point(0, 5), gradRect.topLeft())\n            p.drawLine(gradRect.topLeft(), gradRect.topRight())\n            p.drawLine(gradRect.bottomLeft(), gradRect.bottomRight())\n        \n    def setHistogramRange(self, mn, mx, padding=0.1):\n        """"""Set the Y range on the histogram plot. This disables auto-scaling.""""""\n        self.vb.enableAutoRange(self.vb.YAxis, False)\n        self.vb.setYRange(mn, mx, padding)\n        \n    def autoHistogramRange(self):\n        """"""Enable auto-scaling on the histogram plot.""""""\n        self.vb.enableAutoRange(self.vb.XYAxes)\n\n    def setImageItem(self, img):\n        """"""Set an ImageItem to have its levels and LUT automatically controlled\n        by this HistogramLUTItem.\n        """"""\n        self.imageItem = weakref.ref(img)\n        img.sigImageChanged.connect(self.imageChanged)\n        img.setLookupTable(self.getLookupTable)  ## send function pointer, not the result\n        self.regionChanged()\n        self.imageChanged(autoLevel=True)\n        \n    def viewRangeChanged(self):\n        self.update()\n    \n    def gradientChanged(self):\n        if self.imageItem() is not None:\n            if self.gradient.isLookupTrivial():\n                self.imageItem().setLookupTable(None) #lambda x: x.astype(np.uint8))\n            else:\n                self.imageItem().setLookupTable(self.getLookupTable)  ## send function pointer, not the result\n            \n        self.lut = None\n        self.sigLookupTableChanged.emit(self)\n\n    def getLookupTable(self, img=None, n=None, alpha=None):\n        """"""Return a lookup table from the color gradient defined by this \n        HistogramLUTItem.\n        """"""\n        if self.levelMode is not \'mono\':\n            return None\n        if n is None:\n            if img.dtype == np.uint8:\n                n = 256\n            else:\n                n = 512\n        if self.lut is None:\n            self.lut = self.gradient.getLookupTable(n, alpha=alpha)\n        return self.lut\n\n    def regionChanged(self):\n        if self.imageItem() is not None:\n            self.imageItem().setLevels(self.getLevels())\n        self.sigLevelChangeFinished.emit(self)\n\n    def regionChanging(self):\n        if self.imageItem() is not None:\n            self.imageItem().setLevels(self.getLevels())\n        self.sigLevelsChanged.emit(self)\n        self.update()\n\n    def imageChanged(self, autoLevel=False, autoRange=False):\n        if self.imageItem() is None:\n            return\n            \n        if self.levelMode == \'mono\':\n            for plt in self.plots[1:]:\n                plt.setVisible(False)\n            self.plots[0].setVisible(True)\n            # plot one histogram for all image data\n            profiler = debug.Profiler()\n            h = self.imageItem().getHistogram()\n            profiler(\'get histogram\')\n            if h[0] is None:\n                return\n            self.plot.setData(*h)\n            profiler(\'set plot\')\n            if autoLevel:\n                mn = h[0][0]\n                mx = h[0][-1]\n                self.region.setRegion([mn, mx])\n                profiler(\'set region\')\n            else:\n                mn, mx = self.imageItem().levels\n                self.region.setRegion([mn, mx])\n        else:\n            # plot one histogram for each channel\n            self.plots[0].setVisible(False)\n            ch = self.imageItem().getHistogram(perChannel=True)\n            if ch[0] is None:\n                return\n            for i in range(1, 5):\n                if len(ch) >= i:\n                    h = ch[i-1]\n                    self.plots[i].setVisible(True)\n                    self.plots[i].setData(*h)\n                    if autoLevel:\n                        mn = h[0][0]\n                        mx = h[0][-1]\n                        self.region[i].setRegion([mn, mx])\n                else:\n                    # hide channels not present in image data\n                    self.plots[i].setVisible(False)\n            # make sure we are displaying the correct number of channels\n            self._showRegions()\n            \n    def getLevels(self):\n        """"""Return the min and max levels.\n        \n        For rgba mode, this returns a list of the levels for each channel.\n        """"""\n        if self.levelMode == \'mono\':\n            return self.region.getRegion()\n        else:\n            nch = self.imageItem().channels()\n            if nch is None:\n                nch = 3\n            return [r.getRegion() for r in self.regions[1:nch+1]]\n        \n    def setLevels(self, min=None, max=None, rgba=None):\n        """"""Set the min/max (bright and dark) levels.\n        \n        Arguments may be *min* and *max* for single-channel data, or \n        *rgba* = [(rmin, rmax), ...] for multi-channel data.\n        """"""\n        if self.levelMode == \'mono\':\n            if min is None:\n                min, max = rgba[0]\n            assert None not in (min, max)\n            self.region.setRegion((min, max))\n        else:\n            if rgba is None:\n                raise TypeError(""Must specify rgba argument when levelMode != \'mono\'."")\n            for i, levels in enumerate(rgba):\n                self.regions[i+1].setRegion(levels)\n        \n    def setLevelMode(self, mode):\n        """""" Set the method of controlling the image levels offered to the user. \n        Options are \'mono\' or \'rgba\'.\n        """"""\n        assert mode in (\'mono\', \'rgba\')\n        \n        if mode == self.levelMode:\n            return\n        \n        oldLevels = self.getLevels()\n        self.levelMode = mode\n        self._showRegions()\n        \n        # do our best to preserve old levels\n        if mode == \'mono\':\n            levels = np.array(oldLevels).mean(axis=0)\n            self.setLevels(*levels)\n        else:\n            levels = [oldLevels] * 4\n            self.setLevels(rgba=levels)\n            \n        # force this because calling self.setLevels might not set the imageItem\n        # levels if there was no change to the region item\n        self.imageItem().setLevels(self.getLevels())\n        \n        self.imageChanged()\n        self.update()\n\n    def _showRegions(self):\n        for i in range(len(self.regions)):\n            self.regions[i].setVisible(False)\n            \n        if self.levelMode == \'rgba\':\n            imax = 4\n            if self.imageItem() is not None:\n                # Only show rgb channels if connected image lacks alpha.\n                nch = self.imageItem().channels()\n                if nch is None:\n                    nch = 3\n            xdif = 1.0 / nch\n            for i in range(1, nch+1):\n                self.regions[i].setVisible(True)\n                self.regions[i].setSpan((i-1) * xdif, i * xdif)\n            self.gradient.hide()\n        elif self.levelMode == \'mono\':\n            self.regions[0].setVisible(True)\n            self.gradient.show()\n        else:\n            raise ValueError(""Unknown level mode %r"" %  self.levelMode) \n    \n    def saveState(self):\n        return {\n            \'gradient\': self.gradient.saveState(),\n            \'levels\': self.getLevels(),\n            \'mode\': self.levelMode,\n        }\n    \n    def restoreState(self, state):\n        self.setLevelMode(state[\'mode\'])\n        self.gradient.restoreState(state[\'gradient\'])\n        self.setLevels(*state[\'levels\'])\n'"
src/third_party/pyqtgraph/graphicsItems/ImageItem.py,24,"b'from __future__ import division\n\nfrom ..Qt import QtGui, QtCore\nimport numpy as np\nimport collections\nfrom .. import functions as fn\nfrom .. import debug as debug\nfrom .GraphicsObject import GraphicsObject\nfrom ..Point import Point\nfrom .. import getConfigOption\n\n\n__all__ = [\'ImageItem\']\n\n\nclass ImageItem(GraphicsObject):\n    """"""\n    **Bases:** :class:`GraphicsObject <pyqtgraph.GraphicsObject>`\n    \n    GraphicsObject displaying an image. Optimized for rapid update (ie video display).\n    This item displays either a 2D numpy array (height, width) or\n    a 3D array (height, width, RGBa). This array is optionally scaled (see \n    :func:`setLevels <pyqtgraph.ImageItem.setLevels>`) and/or colored\n    with a lookup table (see :func:`setLookupTable <pyqtgraph.ImageItem.setLookupTable>`)\n    before being displayed.\n    \n    ImageItem is frequently used in conjunction with \n    :class:`HistogramLUTItem <pyqtgraph.HistogramLUTItem>` or \n    :class:`HistogramLUTWidget <pyqtgraph.HistogramLUTWidget>` to provide a GUI\n    for controlling the levels and lookup table used to display the image.\n    """"""\n    \n    sigImageChanged = QtCore.Signal()\n    sigRemoveRequested = QtCore.Signal(object)  # self; emitted when \'remove\' is selected from context menu\n    \n    def __init__(self, image=None, **kargs):\n        """"""\n        See :func:`setImage <pyqtgraph.ImageItem.setImage>` for all allowed initialization arguments.\n        """"""\n        GraphicsObject.__init__(self)\n        self.menu = None\n        self.image = None   ## original image data\n        self.qimage = None  ## rendered image for display\n        \n        self.paintMode = None\n        \n        self.levels = None  ## [min, max] or [[redMin, redMax], ...]\n        self.lut = None\n        self.autoDownsample = False\n        \n        self.axisOrder = getConfigOption(\'imageAxisOrder\')\n        \n        # In some cases, we use a modified lookup table to handle both rescaling\n        # and LUT more efficiently\n        self._effectiveLut = None\n        \n        self.drawKernel = None\n        self.border = None\n        self.removable = False\n        \n        if image is not None:\n            self.setImage(image, **kargs)\n        else:\n            self.setOpts(**kargs)\n\n    def setCompositionMode(self, mode):\n        """"""Change the composition mode of the item (see QPainter::CompositionMode\n        in the Qt documentation). This is useful when overlaying multiple ImageItems.\n        \n        ============================================  ============================================================\n        **Most common arguments:**\n        QtGui.QPainter.CompositionMode_SourceOver     Default; image replaces the background if it\n                                                      is opaque. Otherwise, it uses the alpha channel to blend\n                                                      the image with the background.\n        QtGui.QPainter.CompositionMode_Overlay        The image color is mixed with the background color to \n                                                      reflect the lightness or darkness of the background.\n        QtGui.QPainter.CompositionMode_Plus           Both the alpha and color of the image and background pixels \n                                                      are added together.\n        QtGui.QPainter.CompositionMode_Multiply       The output is the image color multiplied by the background.\n        ============================================  ============================================================\n        """"""\n        self.paintMode = mode\n        self.update()\n        \n    def setBorder(self, b):\n        self.border = fn.mkPen(b)\n        self.update()\n        \n    def width(self):\n        if self.image is None:\n            return None\n        axis = 0 if self.axisOrder == \'col-major\' else 1\n        return self.image.shape[axis]\n        \n    def height(self):\n        if self.image is None:\n            return None\n        axis = 1 if self.axisOrder == \'col-major\' else 0\n        return self.image.shape[axis]\n\n    def channels(self):\n        if self.image is None:\n            return None\n        return self.image.shape[2] if self.image.ndim == 3 else 1\n\n    def boundingRect(self):\n        if self.image is None:\n            return QtCore.QRectF(0., 0., 0., 0.)\n        return QtCore.QRectF(0., 0., float(self.width()), float(self.height()))\n\n    def setLevels(self, levels, update=True):\n        """"""\n        Set image scaling levels. Can be one of:\n        \n        * [blackLevel, whiteLevel]\n        * [[minRed, maxRed], [minGreen, maxGreen], [minBlue, maxBlue]]\n            \n        Only the first format is compatible with lookup tables. See :func:`makeARGB <pyqtgraph.makeARGB>`\n        for more details on how levels are applied.\n        """"""\n        if levels is not None:\n            levels = np.asarray(levels)\n        if not fn.eq(levels, self.levels):\n            self.levels = levels\n            self._effectiveLut = None\n            if update:\n                self.updateImage()\n        \n    def getLevels(self):\n        return self.levels\n        #return self.whiteLevel, self.blackLevel\n\n    def setLookupTable(self, lut, update=True):\n        """"""\n        Set the lookup table (numpy array) to use for this image. (see \n        :func:`makeARGB <pyqtgraph.makeARGB>` for more information on how this is used).\n        Optionally, lut can be a callable that accepts the current image as an \n        argument and returns the lookup table to use.\n        \n        Ordinarily, this table is supplied by a :class:`HistogramLUTItem <pyqtgraph.HistogramLUTItem>`\n        or :class:`GradientEditorItem <pyqtgraph.GradientEditorItem>`.\n        """"""\n        if lut is not self.lut:\n            self.lut = lut\n            self._effectiveLut = None\n            if update:\n                self.updateImage()\n\n    def setAutoDownsample(self, ads):\n        """"""\n        Set the automatic downsampling mode for this ImageItem.\n        \n        Added in version 0.9.9\n        """"""\n        self.autoDownsample = ads\n        self.qimage = None\n        self.update()\n\n    def setOpts(self, update=True, **kargs):\n        if \'axisOrder\' in kargs:\n            val = kargs[\'axisOrder\']\n            if val not in (\'row-major\', \'col-major\'):\n                raise ValueError(\'axisOrder must be either ""row-major"" or ""col-major""\')\n            self.axisOrder = val\n        if \'lut\' in kargs:\n            self.setLookupTable(kargs[\'lut\'], update=update)\n        if \'levels\' in kargs:\n            self.setLevels(kargs[\'levels\'], update=update)\n        #if \'clipLevel\' in kargs:\n            #self.setClipLevel(kargs[\'clipLevel\'])\n        if \'opacity\' in kargs:\n            self.setOpacity(kargs[\'opacity\'])\n        if \'compositionMode\' in kargs:\n            self.setCompositionMode(kargs[\'compositionMode\'])\n        if \'border\' in kargs:\n            self.setBorder(kargs[\'border\'])\n        if \'removable\' in kargs:\n            self.removable = kargs[\'removable\']\n            self.menu = None\n        if \'autoDownsample\' in kargs:\n            self.setAutoDownsample(kargs[\'autoDownsample\'])\n        if update:\n            self.update()\n\n    def setRect(self, rect):\n        """"""Scale and translate the image to fit within rect (must be a QRect or QRectF).""""""\n        self.resetTransform()\n        self.translate(rect.left(), rect.top())\n        self.scale(rect.width() / self.width(), rect.height() / self.height())\n\n    def clear(self):\n        self.image = None\n        self.prepareGeometryChange()\n        self.informViewBoundsChanged()\n        self.update()\n\n    def setImage(self, image=None, autoLevels=None, **kargs):\n        """"""\n        Update the image displayed by this item. For more information on how the image\n        is processed before displaying, see :func:`makeARGB <pyqtgraph.makeARGB>`\n        \n        =================  =========================================================================\n        **Arguments:**\n        image              (numpy array) Specifies the image data. May be 2D (width, height) or \n                           3D (width, height, RGBa). The array dtype must be integer or floating\n                           point of any bit depth. For 3D arrays, the third dimension must\n                           be of length 3 (RGB) or 4 (RGBA). See *notes* below.\n        autoLevels         (bool) If True, this forces the image to automatically select \n                           levels based on the maximum and minimum values in the data.\n                           By default, this argument is true unless the levels argument is\n                           given.\n        lut                (numpy array) The color lookup table to use when displaying the image.\n                           See :func:`setLookupTable <pyqtgraph.ImageItem.setLookupTable>`.\n        levels             (min, max) The minimum and maximum values to use when rescaling the image\n                           data. By default, this will be set to the minimum and maximum values \n                           in the image. If the image array has dtype uint8, no rescaling is necessary.\n        opacity            (float 0.0-1.0)\n        compositionMode    See :func:`setCompositionMode <pyqtgraph.ImageItem.setCompositionMode>`\n        border             Sets the pen used when drawing the image border. Default is None.\n        autoDownsample     (bool) If True, the image is automatically downsampled to match the\n                           screen resolution. This improves performance for large images and \n                           reduces aliasing. If autoDownsample is not specified, then ImageItem will\n                           choose whether to downsample the image based on its size.\n        =================  =========================================================================\n        \n        \n        **Notes:**        \n        \n        For backward compatibility, image data is assumed to be in column-major order (column, row).\n        However, most image data is stored in row-major order (row, column) and will need to be\n        transposed before calling setImage()::\n        \n            imageitem.setImage(imagedata.T)\n            \n        This requirement can be changed by calling ``image.setOpts(axisOrder=\'row-major\')`` or\n        by changing the ``imageAxisOrder`` :ref:`global configuration option <apiref_config>`.\n        \n        \n        """"""\n        profile = debug.Profiler()\n\n        gotNewData = False\n        if image is None:\n            if self.image is None:\n                return\n        else:\n            gotNewData = True\n            shapeChanged = (self.image is None or image.shape != self.image.shape)\n            image = image.view(np.ndarray)\n            if self.image is None or image.dtype != self.image.dtype:\n                self._effectiveLut = None\n            self.image = image\n            if self.image.shape[0] > 2**15-1 or self.image.shape[1] > 2**15-1:\n                if \'autoDownsample\' not in kargs:\n                    kargs[\'autoDownsample\'] = True\n            if shapeChanged:\n                self.prepareGeometryChange()\n                self.informViewBoundsChanged()\n\n        profile()\n\n        if autoLevels is None:\n            if \'levels\' in kargs:\n                autoLevels = False\n            else:\n                autoLevels = True\n        if autoLevels:\n            img = self.image\n            while img.size > 2**16:\n                img = img[::2, ::2]\n            mn, mx = np.nanmin(img), np.nanmax(img)\n            # mn and mx can still be NaN if the data is all-NaN\n            if mn == mx or np.isnan(mn) or np.isnan(mx):\n                mn = 0\n                mx = 255\n            kargs[\'levels\'] = [mn,mx]\n\n        profile()\n\n        self.setOpts(update=False, **kargs)\n\n        profile()\n\n        self.qimage = None\n        self.update()\n\n        profile()\n\n        if gotNewData:\n            self.sigImageChanged.emit()\n\n    def dataTransform(self):\n        """"""Return the transform that maps from this image\'s input array to its\n        local coordinate system.\n        \n        This transform corrects for the transposition that occurs when image data\n        is interpreted in row-major order.\n        """"""\n        # Might eventually need to account for downsampling / clipping here\n        tr = QtGui.QTransform()\n        if self.axisOrder == \'row-major\':\n            # transpose\n            tr.scale(1, -1)\n            tr.rotate(-90)\n        return tr\n\n    def inverseDataTransform(self):\n        """"""Return the transform that maps from this image\'s local coordinate\n        system to its input array.\n        \n        See dataTransform() for more information.\n        """"""\n        tr = QtGui.QTransform()\n        if self.axisOrder == \'row-major\':\n            # transpose\n            tr.scale(1, -1)\n            tr.rotate(-90)\n        return tr\n\n    def mapToData(self, obj):\n        tr = self.inverseDataTransform()\n        return tr.map(obj)\n\n    def mapFromData(self, obj):\n        tr = self.dataTransform()\n        return tr.map(obj)\n\n    def quickMinMax(self, targetSize=1e6):\n        """"""\n        Estimate the min/max values of the image data by subsampling.\n        """"""\n        data = self.image\n        while data.size > targetSize:\n            ax = np.argmax(data.shape)\n            sl = [slice(None)] * data.ndim\n            sl[ax] = slice(None, None, 2)\n            data = data[sl]\n        return np.nanmin(data), np.nanmax(data)\n\n    def updateImage(self, *args, **kargs):\n        ## used for re-rendering qimage from self.image.\n        \n        ## can we make any assumptions here that speed things up?\n        ## dtype, range, size are all the same?\n        defaults = {\n            \'autoLevels\': False,\n        }\n        defaults.update(kargs)\n        return self.setImage(*args, **defaults)\n\n    def render(self):\n        # Convert data to QImage for display.\n        \n        profile = debug.Profiler()\n        if self.image is None or self.image.size == 0:\n            return\n        \n        # Request a lookup table if this image has only one channel\n        if self.image.ndim == 2 or self.image.shape[2] == 1:\n            if isinstance(self.lut, collections.Callable):\n                lut = self.lut(self.image)\n            else:\n                lut = self.lut\n        else:\n            lut = None\n\n        if self.autoDownsample:\n            # reduce dimensions of image based on screen resolution\n            o = self.mapToDevice(QtCore.QPointF(0,0))\n            x = self.mapToDevice(QtCore.QPointF(1,0))\n            y = self.mapToDevice(QtCore.QPointF(0,1))\n\n            # Check if graphics view is too small to render anything\n            if o is None or x is None or y is None:\n                return\n\n            w = Point(x-o).length()\n            h = Point(y-o).length()\n            if w == 0 or h == 0:\n                self.qimage = None\n                return\n            xds = max(1, int(1.0 / w))\n            yds = max(1, int(1.0 / h))\n            axes = [1, 0] if self.axisOrder == \'row-major\' else [0, 1]\n            image = fn.downsample(self.image, xds, axis=axes[0])\n            image = fn.downsample(image, yds, axis=axes[1])\n            self._lastDownsample = (xds, yds)\n            \n            # Check if downsampling reduced the image size to zero due to inf values.\n            if image.size == 0:\n                return\n        else:\n            image = self.image\n\n        # if the image data is a small int, then we can combine levels + lut\n        # into a single lut for better performance\n        levels = self.levels\n        if levels is not None and levels.ndim == 1 and image.dtype in (np.ubyte, np.uint16):\n            if self._effectiveLut is None:\n                eflsize = 2**(image.itemsize*8)\n                ind = np.arange(eflsize)\n                minlev, maxlev = levels\n                levdiff = maxlev - minlev\n                levdiff = 1 if levdiff == 0 else levdiff  # don\'t allow division by 0\n                if lut is None:\n                    efflut = fn.rescaleData(ind, scale=255./levdiff, \n                                            offset=minlev, dtype=np.ubyte)\n                else:\n                    lutdtype = np.min_scalar_type(lut.shape[0]-1)\n                    efflut = fn.rescaleData(ind, scale=(lut.shape[0]-1)/levdiff,\n                                            offset=minlev, dtype=lutdtype, clip=(0, lut.shape[0]-1))\n                    efflut = lut[efflut]\n                \n                self._effectiveLut = efflut\n            lut = self._effectiveLut\n            levels = None\n        \n        # Convert single-channel image to 2D array\n        if image.ndim == 3 and image.shape[-1] == 1:\n            image = image[..., 0]\n        \n        # Assume images are in column-major order for backward compatibility\n        # (most images are in row-major order)\n        if self.axisOrder == \'col-major\':\n            image = image.transpose((1, 0, 2)[:image.ndim])\n        \n        argb, alpha = fn.makeARGB(image, lut=lut, levels=levels)\n        self.qimage = fn.makeQImage(argb, alpha, transpose=False)\n\n    def paint(self, p, *args):\n        profile = debug.Profiler()\n        if self.image is None:\n            return\n        if self.qimage is None:\n            self.render()\n            if self.qimage is None:\n                return\n            profile(\'render QImage\')\n        if self.paintMode is not None:\n            p.setCompositionMode(self.paintMode)\n            profile(\'set comp mode\')\n\n        shape = self.image.shape[:2] if self.axisOrder == \'col-major\' else self.image.shape[:2][::-1]\n        p.drawImage(QtCore.QRectF(0,0,*shape), self.qimage)\n        profile(\'p.drawImage\')\n        if self.border is not None:\n            p.setPen(self.border)\n            p.drawRect(self.boundingRect())\n\n    def save(self, fileName, *args):\n        """"""Save this image to file. Note that this saves the visible image (after scale/color changes), not the original data.""""""\n        if self.qimage is None:\n            self.render()\n        self.qimage.save(fileName, *args)\n\n    def getHistogram(self, bins=\'auto\', step=\'auto\', perChannel=False, targetImageSize=200, \n                     targetHistogramSize=500, **kwds):\n        """"""Returns x and y arrays containing the histogram values for the current image.\n        For an explanation of the return format, see numpy.histogram().\n        \n        The *step* argument causes pixels to be skipped when computing the histogram to save time.\n        If *step* is \'auto\', then a step is chosen such that the analyzed data has\n        dimensions roughly *targetImageSize* for each axis.\n        \n        The *bins* argument and any extra keyword arguments are passed to \n        np.histogram(). If *bins* is \'auto\', then a bin number is automatically\n        chosen based on the image characteristics:\n        \n        * Integer images will have approximately *targetHistogramSize* bins, \n          with each bin having an integer width.\n        * All other types will have *targetHistogramSize* bins.\n        \n        If *perChannel* is True, then the histogram is computed once per channel\n        and the output is a list of the results.\n        \n        This method is also used when automatically computing levels.\n        """"""\n        if self.image is None or self.image.size == 0:\n            return None, None\n        if step == \'auto\':\n            step = (max(1, int(np.ceil(self.image.shape[0] / targetImageSize))),\n                    max(1, int(np.ceil(self.image.shape[1] / targetImageSize))))\n        if np.isscalar(step):\n            step = (step, step)\n        stepData = self.image[::step[0], ::step[1]]\n        \n        if bins == \'auto\':\n            mn = np.nanmin(stepData)\n            mx = np.nanmax(stepData)\n            if np.isnan(mn) or np.isnan(mx):\n                # the data are all-nan\n                return None, None\n            if stepData.dtype.kind in ""ui"":\n                # For integer data, we select the bins carefully to avoid aliasing\n                step = np.ceil((mx-mn) / 500.)\n                bins = np.arange(mn, mx+1.01*step, step, dtype=np.int)\n            else:\n                # for float data, let numpy select the bins.\n                bins = np.linspace(mn, mx, 500)\n            \n            if len(bins) == 0:\n                bins = [mn, mx]\n\n        kwds[\'bins\'] = bins\n\n        if perChannel:\n            hist = []\n            for i in range(stepData.shape[-1]):\n                stepChan = stepData[..., i]\n                stepChan = stepChan[np.isfinite(stepChan)]\n                h = np.histogram(stepChan, **kwds)\n                hist.append((h[1][:-1], h[0]))\n            return hist\n        else:\n            stepData = stepData[np.isfinite(stepData)]\n            hist = np.histogram(stepData, **kwds)\n            return hist[1][:-1], hist[0]\n\n    def setPxMode(self, b):\n        """"""\n        Set whether the item ignores transformations and draws directly to screen pixels.\n        If True, the item will not inherit any scale or rotation transformations from its\n        parent items, but its position will be transformed as usual.\n        (see GraphicsItem::ItemIgnoresTransformations in the Qt documentation)\n        """"""\n        self.setFlag(self.ItemIgnoresTransformations, b)\n    \n    def setScaledMode(self):\n        self.setPxMode(False)\n\n    def getPixmap(self):\n        if self.qimage is None:\n            self.render()\n            if self.qimage is None:\n                return None\n        return QtGui.QPixmap.fromImage(self.qimage)\n    \n    def pixelSize(self):\n        """"""return scene-size of a single pixel in the image""""""\n        br = self.sceneBoundingRect()\n        if self.image is None:\n            return 1,1\n        return br.width()/self.width(), br.height()/self.height()\n    \n    def viewTransformChanged(self):\n        if self.autoDownsample:\n            self.qimage = None\n            self.update()\n\n    def mouseDragEvent(self, ev):\n        if ev.button() != QtCore.Qt.LeftButton:\n            ev.ignore()\n            return\n        elif self.drawKernel is not None:\n            ev.accept()\n            self.drawAt(ev.pos(), ev)\n\n    def mouseClickEvent(self, ev):\n        if ev.button() == QtCore.Qt.RightButton:\n            if self.raiseContextMenu(ev):\n                ev.accept()\n        if self.drawKernel is not None and ev.button() == QtCore.Qt.LeftButton:\n            self.drawAt(ev.pos(), ev)\n\n    def raiseContextMenu(self, ev):\n        menu = self.getMenu()\n        if menu is None:\n            return False\n        menu = self.scene().addParentContextMenus(self, menu, ev)\n        pos = ev.screenPos()\n        menu.popup(QtCore.QPoint(pos.x(), pos.y()))\n        return True\n\n    def getMenu(self):\n        if self.menu is None:\n            if not self.removable:\n                return None\n            self.menu = QtGui.QMenu()\n            self.menu.setTitle(""Image"")\n            remAct = QtGui.QAction(""Remove image"", self.menu)\n            remAct.triggered.connect(self.removeClicked)\n            self.menu.addAction(remAct)\n            self.menu.remAct = remAct\n        return self.menu\n        \n    def hoverEvent(self, ev):\n        if not ev.isExit() and self.drawKernel is not None and ev.acceptDrags(QtCore.Qt.LeftButton):\n            ev.acceptClicks(QtCore.Qt.LeftButton) ## we don\'t use the click, but we also don\'t want anyone else to use it.\n            ev.acceptClicks(QtCore.Qt.RightButton)\n        elif not ev.isExit() and self.removable:\n            ev.acceptClicks(QtCore.Qt.RightButton)  ## accept context menu clicks\n\n    def tabletEvent(self, ev):\n        pass\n        #print(ev.device())\n        #print(ev.pointerType())\n        #print(ev.pressure())\n    \n    def drawAt(self, pos, ev=None):\n        pos = [int(pos.x()), int(pos.y())]\n        dk = self.drawKernel\n        kc = self.drawKernelCenter\n        sx = [0,dk.shape[0]]\n        sy = [0,dk.shape[1]]\n        tx = [pos[0] - kc[0], pos[0] - kc[0]+ dk.shape[0]]\n        ty = [pos[1] - kc[1], pos[1] - kc[1]+ dk.shape[1]]\n        \n        for i in [0,1]:\n            dx1 = -min(0, tx[i])\n            dx2 = min(0, self.image.shape[0]-tx[i])\n            tx[i] += dx1+dx2\n            sx[i] += dx1+dx2\n\n            dy1 = -min(0, ty[i])\n            dy2 = min(0, self.image.shape[1]-ty[i])\n            ty[i] += dy1+dy2\n            sy[i] += dy1+dy2\n\n        ts = (slice(tx[0],tx[1]), slice(ty[0],ty[1]))\n        ss = (slice(sx[0],sx[1]), slice(sy[0],sy[1]))\n        mask = self.drawMask\n        src = dk\n        \n        if isinstance(self.drawMode, collections.Callable):\n            self.drawMode(dk, self.image, mask, ss, ts, ev)\n        else:\n            src = src[ss]\n            if self.drawMode == \'set\':\n                if mask is not None:\n                    mask = mask[ss]\n                    self.image[ts] = self.image[ts] * (1-mask) + src * mask\n                else:\n                    self.image[ts] = src\n            elif self.drawMode == \'add\':\n                self.image[ts] += src\n            else:\n                raise Exception(""Unknown draw mode \'%s\'"" % self.drawMode)\n            self.updateImage()\n        \n    def setDrawKernel(self, kernel=None, mask=None, center=(0,0), mode=\'set\'):\n        self.drawKernel = kernel\n        self.drawKernelCenter = center\n        self.drawMode = mode\n        self.drawMask = mask\n\n    def removeClicked(self):\n        ## Send remove event only after we have exited the menu event handler\n        self.removeTimer = QtCore.QTimer()\n        self.removeTimer.timeout.connect(self.emitRemoveRequested)\n        self.removeTimer.start(0)\n\n    def emitRemoveRequested(self):\n        self.removeTimer.timeout.disconnect(self.emitRemoveRequested)\n        self.sigRemoveRequested.emit(self)\n'"
src/third_party/pyqtgraph/graphicsItems/InfiniteLine.py,2,"b'from ..Qt import QtGui, QtCore\nfrom ..Point import Point\nfrom .GraphicsObject import GraphicsObject\nfrom .TextItem import TextItem\nfrom .ViewBox import ViewBox\nfrom .. import functions as fn\nimport numpy as np\nimport weakref\n\n\n__all__ = [\'InfiniteLine\', \'InfLineLabel\']\n\n\nclass InfiniteLine(GraphicsObject):\n    """"""\n    **Bases:** :class:`GraphicsObject <pyqtgraph.GraphicsObject>`\n\n    Displays a line of infinite length.\n    This line may be dragged to indicate a position in data coordinates.\n\n    =============================== ===================================================\n    **Signals:**\n    sigDragged(self)\n    sigPositionChangeFinished(self)\n    sigPositionChanged(self)\n    =============================== ===================================================\n    """"""\n\n    sigDragged = QtCore.Signal(object)\n    sigPositionChangeFinished = QtCore.Signal(object)\n    sigPositionChanged = QtCore.Signal(object)\n\n    def __init__(self, pos=None, angle=90, pen=None, movable=False, bounds=None,\n                 hoverPen=None, label=None, labelOpts=None, span=(0, 1), markers=None, \n                 name=None):\n        """"""\n        =============== ==================================================================\n        **Arguments:**\n        pos             Position of the line. This can be a QPointF or a single value for\n                        vertical/horizontal lines.\n        angle           Angle of line in degrees. 0 is horizontal, 90 is vertical.\n        pen             Pen to use when drawing line. Can be any arguments that are valid\n                        for :func:`mkPen <pyqtgraph.mkPen>`. Default pen is transparent\n                        yellow.\n        hoverPen        Pen to use when the mouse cursor hovers over the line. \n                        Only used when movable=True.\n        movable         If True, the line can be dragged to a new position by the user.\n        bounds          Optional [min, max] bounding values. Bounds are only valid if the\n                        line is vertical or horizontal.\n        hoverPen        Pen to use when drawing line when hovering over it. Can be any\n                        arguments that are valid for :func:`mkPen <pyqtgraph.mkPen>`.\n                        Default pen is red.\n        label           Text to be displayed in a label attached to the line, or\n                        None to show no label (default is None). May optionally\n                        include formatting strings to display the line value.\n        labelOpts       A dict of keyword arguments to use when constructing the\n                        text label. See :class:`InfLineLabel`.\n        span            Optional tuple (min, max) giving the range over the view to draw\n                        the line. For example, with a vertical line, use span=(0.5, 1)\n                        to draw only on the top half of the view.\n        markers         List of (marker, position, size) tuples, one per marker to display\n                        on the line. See the addMarker method.\n        name            Name of the item\n        =============== ==================================================================\n        """"""\n        self._boundingRect = None\n\n        self._name = name\n\n        GraphicsObject.__init__(self)\n\n        if bounds is None:              ## allowed value boundaries for orthogonal lines\n            self.maxRange = [None, None]\n        else:\n            self.maxRange = bounds\n        self.moving = False\n        self.setMovable(movable)\n        self.mouseHovering = False\n        self.p = [0, 0]\n        self.setAngle(angle)\n\n        if pos is None:\n            pos = Point(0,0)\n        self.setPos(pos)\n\n        if pen is None:\n            pen = (200, 200, 100)\n        self.setPen(pen)\n        \n        if hoverPen is None:\n            self.setHoverPen(color=(255,0,0), width=self.pen.width())\n        else:\n            self.setHoverPen(hoverPen)\n        \n        self.span = span\n        self.currentPen = self.pen\n\n        self.markers = []\n        self._maxMarkerSize = 0\n        if markers is not None:\n            for m in markers:\n                self.addMarker(*m)\n                \n        # Cache variables for managing bounds\n        self._endPoints = [0, 1] # \n        self._bounds = None\n        self._lastViewSize = None\n        \n        if label is not None:\n            labelOpts = {} if labelOpts is None else labelOpts\n            self.label = InfLineLabel(self, text=label, **labelOpts)\n\n    def setMovable(self, m):\n        """"""Set whether the line is movable by the user.""""""\n        self.movable = m\n        self.setAcceptHoverEvents(m)\n\n    def setBounds(self, bounds):\n        """"""Set the (minimum, maximum) allowable values when dragging.""""""\n        self.maxRange = bounds\n        self.setValue(self.value())\n        \n    def bounds(self):\n        """"""Return the (minimum, maximum) values allowed when dragging.\n        """"""\n        return self.maxRange[:]\n        \n    def setPen(self, *args, **kwargs):\n        """"""Set the pen for drawing the line. Allowable arguments are any that are valid\n        for :func:`mkPen <pyqtgraph.mkPen>`.""""""\n        self.pen = fn.mkPen(*args, **kwargs)\n        if not self.mouseHovering:\n            self.currentPen = self.pen\n            self.update()\n\n    def setHoverPen(self, *args, **kwargs):\n        """"""Set the pen for drawing the line while the mouse hovers over it.\n        Allowable arguments are any that are valid\n        for :func:`mkPen <pyqtgraph.mkPen>`.\n\n        If the line is not movable, then hovering is also disabled.\n\n        Added in version 0.9.9.""""""\n        # If user did not supply a width, then copy it from pen\n        widthSpecified = ((len(args) == 1 and \n                           (isinstance(args[0], QtGui.QPen) or\n                           (isinstance(args[0], dict) and \'width\' in args[0]))\n                          ) or \'width\' in kwargs)\n        self.hoverPen = fn.mkPen(*args, **kwargs)\n        if not widthSpecified:\n            self.hoverPen.setWidth(self.pen.width())\n            \n        if self.mouseHovering:\n            self.currentPen = self.hoverPen\n            self.update()\n        \n    def addMarker(self, marker, position=0.5, size=10.0):\n        """"""Add a marker to be displayed on the line. \n        \n        ============= =========================================================\n        **Arguments**\n        marker        String indicating the style of marker to add:\n                      \'<|\', \'|>\', \'>|\', \'|<\', \'<|>\', \'>|<\', \'^\', \'v\', \'o\'\n        position      Position (0.0-1.0) along the visible extent of the line\n                      to place the marker. Default is 0.5.\n        size          Size of the marker in pixels. Default is 10.0.\n        ============= =========================================================\n        """"""\n        path = QtGui.QPainterPath()\n        if marker == \'o\': \n            path.addEllipse(QtCore.QRectF(-0.5, -0.5, 1, 1))\n        if \'<|\' in marker:\n            p = QtGui.QPolygonF([Point(0.5, 0), Point(0, -0.5), Point(-0.5, 0)])\n            path.addPolygon(p)\n            path.closeSubpath()\n        if \'|>\' in marker:\n            p = QtGui.QPolygonF([Point(0.5, 0), Point(0, 0.5), Point(-0.5, 0)])\n            path.addPolygon(p)\n            path.closeSubpath()\n        if \'>|\' in marker:\n            p = QtGui.QPolygonF([Point(0.5, -0.5), Point(0, 0), Point(-0.5, -0.5)])\n            path.addPolygon(p)\n            path.closeSubpath()\n        if \'|<\' in marker:\n            p = QtGui.QPolygonF([Point(0.5, 0.5), Point(0, 0), Point(-0.5, 0.5)])\n            path.addPolygon(p)\n            path.closeSubpath()\n        if \'^\' in marker:\n            p = QtGui.QPolygonF([Point(0, -0.5), Point(0.5, 0), Point(0, 0.5)])\n            path.addPolygon(p)\n            path.closeSubpath()\n        if \'v\' in marker:\n            p = QtGui.QPolygonF([Point(0, -0.5), Point(-0.5, 0), Point(0, 0.5)])\n            path.addPolygon(p)\n            path.closeSubpath()\n        \n        self.markers.append((path, position, size))\n        self._maxMarkerSize = max([m[2] / 2. for m in self.markers])\n        self.update()\n\n    def clearMarkers(self):\n        """""" Remove all markers from this line.\n        """"""\n        self.markers = []\n        self._maxMarkerSize = 0\n        self.update()\n        \n    def setAngle(self, angle):\n        """"""\n        Takes angle argument in degrees.\n        0 is horizontal; 90 is vertical.\n\n        Note that the use of value() and setValue() changes if the line is\n        not vertical or horizontal.\n        """"""\n        self.angle = angle #((angle+45) % 180) - 45   ##  -45 <= angle < 135\n        self.resetTransform()\n        self.rotate(self.angle)\n        self.update()\n\n    def setPos(self, pos):\n\n        if type(pos) in [list, tuple]:\n            newPos = pos\n        elif isinstance(pos, QtCore.QPointF):\n            newPos = [pos.x(), pos.y()]\n        else:\n            if self.angle == 90:\n                newPos = [pos, 0]\n            elif self.angle == 0:\n                newPos = [0, pos]\n            else:\n                raise Exception(""Must specify 2D coordinate for non-orthogonal lines."")\n\n        ## check bounds (only works for orthogonal lines)\n        if self.angle == 90:\n            if self.maxRange[0] is not None:\n                newPos[0] = max(newPos[0], self.maxRange[0])\n            if self.maxRange[1] is not None:\n                newPos[0] = min(newPos[0], self.maxRange[1])\n        elif self.angle == 0:\n            if self.maxRange[0] is not None:\n                newPos[1] = max(newPos[1], self.maxRange[0])\n            if self.maxRange[1] is not None:\n                newPos[1] = min(newPos[1], self.maxRange[1])\n\n        if self.p != newPos:\n            self.p = newPos\n            self._invalidateCache()\n            GraphicsObject.setPos(self, Point(self.p))\n            self.sigPositionChanged.emit(self)\n\n    def getXPos(self):\n        return self.p[0]\n\n    def getYPos(self):\n        return self.p[1]\n\n    def getPos(self):\n        return self.p\n\n    def value(self):\n        """"""Return the value of the line. Will be a single number for horizontal and\n        vertical lines, and a list of [x,y] values for diagonal lines.""""""\n        if self.angle%180 == 0:\n            return self.getYPos()\n        elif self.angle%180 == 90:\n            return self.getXPos()\n        else:\n            return self.getPos()\n\n    def setValue(self, v):\n        """"""Set the position of the line. If line is horizontal or vertical, v can be\n        a single value. Otherwise, a 2D coordinate must be specified (list, tuple and\n        QPointF are all acceptable).""""""\n        self.setPos(v)\n\n    ## broken in 4.7\n    #def itemChange(self, change, val):\n        #if change in [self.ItemScenePositionHasChanged, self.ItemSceneHasChanged]:\n            #self.updateLine()\n            #print ""update"", change\n            #print self.getBoundingParents()\n        #else:\n            #print ""ignore"", change\n        #return GraphicsObject.itemChange(self, change, val)\n    \n    def setSpan(self, mn, mx):\n        if self.span != (mn, mx):\n            self.span = (mn, mx)\n            self.update()\n\n    def _invalidateCache(self):\n        self._boundingRect = None\n\n    def _computeBoundingRect(self):\n        #br = UIGraphicsItem.boundingRect(self)\n        vr = self.viewRect()  # bounds of containing ViewBox mapped to local coords.\n        if vr is None:\n            return QtCore.QRectF()\n        \n        ## add a 4-pixel radius around the line for mouse interaction.\n        \n        px = self.pixelLength(direction=Point(1,0), ortho=True)  ## get pixel length orthogonal to the line\n        if px is None:\n            px = 0\n        pw = max(self.pen.width() / 2, self.hoverPen.width() / 2)\n        w = max(4, self._maxMarkerSize + pw) + 1\n        w = w * px\n        br = QtCore.QRectF(vr)\n        br.setBottom(-w)\n        br.setTop(w)\n\n        length = br.width()\n        left = br.left() + length * self.span[0]\n        right = br.left() + length * self.span[1]\n        br.setLeft(left - w)\n        br.setRight(right + w)\n        br = br.normalized()\n        \n        vs = self.getViewBox().size()\n        \n        if self._bounds != br or self._lastViewSize != vs:\n            self._bounds = br\n            self._lastViewSize = vs\n            self.prepareGeometryChange()\n        \n        self._endPoints = (left, right)\n        self._lastViewRect = vr\n        \n        return self._bounds\n\n    def boundingRect(self):\n        if self._boundingRect is None:\n            self._boundingRect = self._computeBoundingRect()\n        return self._boundingRect\n\n    def paint(self, p, *args):\n        p.setRenderHint(p.Antialiasing)\n        \n        left, right = self._endPoints\n        pen = self.currentPen\n        pen.setJoinStyle(QtCore.Qt.MiterJoin)\n        p.setPen(pen)\n        p.drawLine(Point(left, 0), Point(right, 0))\n        \n        \n        if len(self.markers) == 0:\n            return\n        \n        # paint markers in native coordinate system\n        tr = p.transform()\n        p.resetTransform()\n        \n        start = tr.map(Point(left, 0))\n        end = tr.map(Point(right, 0))\n        up = tr.map(Point(left, 1))\n        dif = end - start\n        length = Point(dif).length()\n        angle = np.arctan2(dif.y(), dif.x()) * 180 / np.pi\n        \n        p.translate(start)\n        p.rotate(angle)\n        \n        up = up - start\n        det = up.x() * dif.y() - dif.x() * up.y()\n        p.scale(1, 1 if det > 0 else -1)\n        \n        p.setBrush(fn.mkBrush(self.currentPen.color()))\n        #p.setPen(fn.mkPen(None))\n        tr = p.transform()\n        for path, pos, size in self.markers:\n            p.setTransform(tr)\n            x = length * pos\n            p.translate(x, 0)\n            p.scale(size, size)\n            p.drawPath(path)\n        \n    def dataBounds(self, axis, frac=1.0, orthoRange=None):\n        if axis == 0:\n            return None   ## x axis should never be auto-scaled\n        else:\n            return (0,0)\n\n    def mouseDragEvent(self, ev):\n        if self.movable and ev.button() == QtCore.Qt.LeftButton:\n            if ev.isStart():\n                self.moving = True\n                self.cursorOffset = self.pos() - self.mapToParent(ev.buttonDownPos())\n                self.startPosition = self.pos()\n            ev.accept()\n\n            if not self.moving:\n                return\n\n            self.setPos(self.cursorOffset + self.mapToParent(ev.pos()))\n            self.sigDragged.emit(self)\n            if ev.isFinish():\n                self.moving = False\n                self.sigPositionChangeFinished.emit(self)\n\n    def mouseClickEvent(self, ev):\n        if self.moving and ev.button() == QtCore.Qt.RightButton:\n            ev.accept()\n            self.setPos(self.startPosition)\n            self.moving = False\n            self.sigDragged.emit(self)\n            self.sigPositionChangeFinished.emit(self)\n\n    def hoverEvent(self, ev):\n        if (not ev.isExit()) and self.movable and ev.acceptDrags(QtCore.Qt.LeftButton):\n            self.setMouseHover(True)\n        else:\n            self.setMouseHover(False)\n\n    def setMouseHover(self, hover):\n        ## Inform the item that the mouse is (not) hovering over it\n        if self.mouseHovering == hover:\n            return\n        self.mouseHovering = hover\n        if hover:\n            self.currentPen = self.hoverPen\n        else:\n            self.currentPen = self.pen\n        self.update()\n\n    def viewTransformChanged(self):\n        """"""\n        Called whenever the transformation matrix of the view has changed.\n        (eg, the view range has changed or the view was resized)\n        """"""\n        self._invalidateCache()\n        \n    def setName(self, name):\n        self._name = name\n\n    def name(self):\n        return self._name\n\n\nclass InfLineLabel(TextItem):\n    """"""\n    A TextItem that attaches itself to an InfiniteLine.\n    \n    This class extends TextItem with the following features:\n    \n    * Automatically positions adjacent to the line at a fixed position along\n      the line and within the view box.\n    * Automatically reformats text when the line value has changed.\n    * Can optionally be dragged to change its location along the line.\n    * Optionally aligns to its parent line.\n\n    =============== ==================================================================\n    **Arguments:**\n    line            The InfiniteLine to which this label will be attached.\n    text            String to display in the label. May contain a {value} formatting\n                    string to display the current value of the line.\n    movable         Bool; if True, then the label can be dragged along the line.\n    position        Relative position (0.0-1.0) within the view to position the label\n                    along the line.\n    anchors         List of (x,y) pairs giving the text anchor positions that should\n                    be used when the line is moved to one side of the view or the\n                    other. This allows text to switch to the opposite side of the line\n                    as it approaches the edge of the view. These are automatically\n                    selected for some common cases, but may be specified if the \n                    default values give unexpected results.\n    =============== ==================================================================\n    \n    All extra keyword arguments are passed to TextItem. A particularly useful\n    option here is to use `rotateAxis=(1, 0)`, which will cause the text to\n    be automatically rotated parallel to the line.\n    """"""\n    def __init__(self, line, text="""", movable=False, position=0.5, anchors=None, **kwds):\n        self.line = line\n        self.movable = movable\n        self.moving = False\n        self.orthoPos = position  # text will always be placed on the line at a position relative to view bounds\n        self.format = text\n        self.line.sigPositionChanged.connect(self.valueChanged)\n        self._endpoints = (None, None)\n        if anchors is None:\n            # automatically pick sensible anchors\n            rax = kwds.get(\'rotateAxis\', None)\n            if rax is not None:\n                if tuple(rax) == (1,0):\n                    anchors = [(0.5, 0), (0.5, 1)]\n                else:\n                    anchors = [(0, 0.5), (1, 0.5)]\n            else:\n                if line.angle % 180 == 0:\n                    anchors = [(0.5, 0), (0.5, 1)]\n                else:\n                    anchors = [(0, 0.5), (1, 0.5)]\n            \n        self.anchors = anchors\n        TextItem.__init__(self, **kwds)\n        self.setParentItem(line)\n        self.valueChanged()\n\n    def valueChanged(self):\n        if not self.isVisible():\n            return\n        value = self.line.value()\n        self.setText(self.format.format(value=value))\n        self.updatePosition()\n\n    def getEndpoints(self):\n        # calculate points where line intersects view box\n        # (in line coordinates)\n        if self._endpoints[0] is None:\n            lr = self.line.boundingRect()\n            pt1 = Point(lr.left(), 0)\n            pt2 = Point(lr.right(), 0)\n            \n            if self.line.angle % 90 != 0:\n                # more expensive to find text position for oblique lines.\n                view = self.getViewBox()\n                if not self.isVisible() or not isinstance(view, ViewBox):\n                    # not in a viewbox, skip update\n                    return (None, None)\n                p = QtGui.QPainterPath()\n                p.moveTo(pt1)\n                p.lineTo(pt2)\n                p = self.line.itemTransform(view)[0].map(p)\n                vr = QtGui.QPainterPath()\n                vr.addRect(view.boundingRect())\n                paths = vr.intersected(p).toSubpathPolygons(QtGui.QTransform())\n                if len(paths) > 0:\n                    l = list(paths[0])\n                    pt1 = self.line.mapFromItem(view, l[0])\n                    pt2 = self.line.mapFromItem(view, l[1])\n            self._endpoints = (pt1, pt2)\n        return self._endpoints\n    \n    def updatePosition(self):\n        # update text position to relative view location along line\n        self._endpoints = (None, None)\n        pt1, pt2 = self.getEndpoints()\n        if pt1 is None:\n            return\n        pt = pt2 * self.orthoPos + pt1 * (1-self.orthoPos)\n        self.setPos(pt)\n        \n        # update anchor to keep text visible as it nears the view box edge\n        vr = self.line.viewRect()\n        if vr is not None:\n            self.setAnchor(self.anchors[0 if vr.center().y() < 0 else 1])\n        \n    def setVisible(self, v):\n        TextItem.setVisible(self, v)\n        if v:\n            self.updateText()\n            self.updatePosition()\n            \n    def setMovable(self, m):\n        """"""Set whether this label is movable by dragging along the line.\n        """"""\n        self.movable = m\n        self.setAcceptHoverEvents(m)\n        \n    def setPosition(self, p):\n        """"""Set the relative position (0.0-1.0) of this label within the view box\n        and along the line. \n        \n        For horizontal (angle=0) and vertical (angle=90) lines, a value of 0.0\n        places the text at the bottom or left of the view, respectively. \n        """"""\n        self.orthoPos = p\n        self.updatePosition()\n        \n    def setFormat(self, text):\n        """"""Set the text format string for this label.\n        \n        May optionally contain ""{value}"" to include the lines current value\n        (the text will be reformatted whenever the line is moved).\n        """"""\n        self.format = text\n        self.valueChanged()\n        \n    def mouseDragEvent(self, ev):\n        if self.movable and ev.button() == QtCore.Qt.LeftButton:\n            if ev.isStart():\n                self._moving = True\n                self._cursorOffset = self._posToRel(ev.buttonDownPos())\n                self._startPosition = self.orthoPos\n            ev.accept()\n\n            if not self._moving:\n                return\n\n            rel = self._posToRel(ev.pos())\n            self.orthoPos = np.clip(self._startPosition + rel - self._cursorOffset, 0, 1)\n            self.updatePosition()\n            if ev.isFinish():\n                self._moving = False\n\n    def mouseClickEvent(self, ev):\n        if self.moving and ev.button() == QtCore.Qt.RightButton:\n            ev.accept()\n            self.orthoPos = self._startPosition\n            self.moving = False\n\n    def hoverEvent(self, ev):\n        if not ev.isExit() and self.movable:\n            ev.acceptDrags(QtCore.Qt.LeftButton)\n\n    def viewTransformChanged(self):\n        self.updatePosition()\n        TextItem.viewTransformChanged(self)\n\n    def _posToRel(self, pos):\n        # convert local position to relative position along line between view bounds\n        pt1, pt2 = self.getEndpoints()\n        if pt1 is None:\n            return 0\n        view = self.getViewBox()\n        pos = self.mapToParent(pos)\n        return (pos.x() - pt1.x()) / (pt2.x()-pt1.x())\n'"
src/third_party/pyqtgraph/graphicsItems/IsocurveItem.py,0,"b'from .. import getConfigOption\nfrom .GraphicsObject import *\nfrom .. import functions as fn\nfrom ..Qt import QtGui, QtCore\n\n\nclass IsocurveItem(GraphicsObject):\n    """"""\n    **Bases:** :class:`GraphicsObject <pyqtgraph.GraphicsObject>`\n    \n    Item displaying an isocurve of a 2D array. To align this item correctly with an \n    ImageItem, call ``isocurve.setParentItem(image)``.\n    """"""\n    def __init__(self, data=None, level=0, pen=\'w\', axisOrder=None):\n        """"""\n        Create a new isocurve item. \n        \n        ==============  ===============================================================\n        **Arguments:**\n        data            A 2-dimensional ndarray. Can be initialized as None, and set\n                        later using :func:`setData <pyqtgraph.IsocurveItem.setData>`\n        level           The cutoff value at which to draw the isocurve.\n        pen             The color of the curve item. Can be anything valid for\n                        :func:`mkPen <pyqtgraph.mkPen>`\n        axisOrder       May be either \'row-major\' or \'col-major\'. By default this uses\n                        the ``imageAxisOrder``\n                        :ref:`global configuration option <apiref_config>`.\n        ==============  ===============================================================\n        """"""\n        GraphicsObject.__init__(self)\n\n        self.level = level\n        self.data = None\n        self.path = None\n        self.axisOrder = getConfigOption(\'imageAxisOrder\') if axisOrder is None else axisOrder\n        self.setPen(pen)\n        self.setData(data, level)\n    \n    def setData(self, data, level=None):\n        """"""\n        Set the data/image to draw isocurves for.\n        \n        ==============  ========================================================================\n        **Arguments:**\n        data            A 2-dimensional ndarray.\n        level           The cutoff value at which to draw the curve. If level is not specified,\n                        the previously set level is used.\n        ==============  ========================================================================\n        """"""\n        if level is None:\n            level = self.level\n        self.level = level\n        self.data = data\n        self.path = None\n        self.prepareGeometryChange()\n        self.update()\n\n    def setLevel(self, level):\n        """"""Set the level at which the isocurve is drawn.""""""\n        self.level = level\n        self.path = None\n        self.prepareGeometryChange()\n        self.update()\n\n    def setPen(self, *args, **kwargs):\n        """"""Set the pen used to draw the isocurve. Arguments can be any that are valid \n        for :func:`mkPen <pyqtgraph.mkPen>`""""""\n        self.pen = fn.mkPen(*args, **kwargs)\n        self.update()\n\n    def setBrush(self, *args, **kwargs):\n        """"""Set the brush used to draw the isocurve. Arguments can be any that are valid \n        for :func:`mkBrush <pyqtgraph.mkBrush>`""""""\n        self.brush = fn.mkBrush(*args, **kwargs)\n        self.update()\n        \n    def updateLines(self, data, level):\n        self.setData(data, level)\n\n    def boundingRect(self):\n        if self.data is None:\n            return QtCore.QRectF()\n        if self.path is None:\n            self.generatePath()\n        return self.path.boundingRect()\n    \n    def generatePath(self):\n        if self.data is None:\n            self.path = None\n            return\n        \n        if self.axisOrder == \'row-major\':\n            data = self.data.T\n        else:\n            data = self.data\n        \n        lines = fn.isocurve(data, self.level, connected=True, extendToEdge=True)\n        self.path = QtGui.QPainterPath()\n        for line in lines:\n            self.path.moveTo(*line[0])\n            for p in line[1:]:\n                self.path.lineTo(*p)\n    \n    def paint(self, p, *args):\n        if self.data is None:\n            return\n        if self.path is None:\n            self.generatePath()\n        p.setPen(self.pen)\n        p.drawPath(self.path)\n    '"
src/third_party/pyqtgraph/graphicsItems/ItemGroup.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .GraphicsObject import GraphicsObject\n\n__all__ = [\'ItemGroup\']\nclass ItemGroup(GraphicsObject):\n    """"""\n    Replacement for QGraphicsItemGroup\n    """"""\n    \n    def __init__(self, *args):\n        GraphicsObject.__init__(self, *args)\n        if hasattr(self, ""ItemHasNoContents""):\n            self.setFlag(self.ItemHasNoContents)\n    \n    def boundingRect(self):\n        return QtCore.QRectF()\n        \n    def paint(self, *args):\n        pass\n    \n    def addItem(self, item):\n        item.setParentItem(self)\n\n'"
src/third_party/pyqtgraph/graphicsItems/LabelItem.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .. import functions as fn\nfrom .GraphicsWidget import GraphicsWidget\nfrom .GraphicsWidgetAnchor import GraphicsWidgetAnchor\nfrom .. import getConfigOption\n\n\n__all__ = [\'LabelItem\']\n\nclass LabelItem(GraphicsWidget, GraphicsWidgetAnchor):\n    """"""\n    GraphicsWidget displaying text.\n    Used mainly as axis labels, titles, etc.\n    \n    Note: To display text inside a scaled view (ViewBox, PlotWidget, etc) use TextItem\n    """"""\n    \n    \n    def __init__(self, text=\' \', parent=None, angle=0, **args):\n        GraphicsWidget.__init__(self, parent)\n        GraphicsWidgetAnchor.__init__(self)\n        self.item = QtGui.QGraphicsTextItem(self)\n        self.opts = {\n            \'color\': None,\n            \'justify\': \'center\'\n        }\n        self.opts.update(args)\n        self._sizeHint = {}\n        self.setText(text)\n        self.setAngle(angle)\n            \n    def setAttr(self, attr, value):\n        """"""Set default text properties. See setText() for accepted parameters.""""""\n        self.opts[attr] = value\n        \n    def setText(self, text, **args):\n        """"""Set the text and text properties in the label. Accepts optional arguments for auto-generating\n        a CSS style string:\n\n        ==================== ==============================\n        **Style Arguments:**\n        color                (str) example: \'CCFF00\'\n        size                 (str) example: \'8pt\'\n        bold                 (bool)\n        italic               (bool)\n        ==================== ==============================\n        """"""\n        self.text = text\n        opts = self.opts\n        for k in args:\n            opts[k] = args[k]\n        \n        optlist = []\n        \n        color = self.opts[\'color\']\n        if color is None:\n            color = getConfigOption(\'foreground\')\n        color = fn.mkColor(color)\n        optlist.append(\'color: #\' + fn.colorStr(color)[:6])\n        if \'size\' in opts:\n            optlist.append(\'font-size: \' + opts[\'size\'])\n        if \'bold\' in opts and opts[\'bold\'] in [True, False]:\n            optlist.append(\'font-weight: \' + {True:\'bold\', False:\'normal\'}[opts[\'bold\']])\n        if \'italic\' in opts and opts[\'italic\'] in [True, False]:\n            optlist.append(\'font-style: \' + {True:\'italic\', False:\'normal\'}[opts[\'italic\']])\n        full = ""<span style=\'%s\'>%s</span>"" % (\'; \'.join(optlist), text)\n        #print full\n        self.item.setHtml(full)\n        self.updateMin()\n        self.resizeEvent(None)\n        self.updateGeometry()\n        \n    def resizeEvent(self, ev):\n        #c1 = self.boundingRect().center()\n        #c2 = self.item.mapToParent(self.item.boundingRect().center()) # + self.item.pos()\n        #dif = c1 - c2\n        #self.item.moveBy(dif.x(), dif.y())\n        #print c1, c2, dif, self.item.pos()\n        self.item.setPos(0,0)\n        bounds = self.itemRect()\n        left = self.mapFromItem(self.item, QtCore.QPointF(0,0)) - self.mapFromItem(self.item, QtCore.QPointF(1,0))\n        rect = self.rect()\n        \n        if self.opts[\'justify\'] == \'left\':\n            if left.x() != 0:\n                bounds.moveLeft(rect.left())\n            if left.y() < 0:\n                bounds.moveTop(rect.top())\n            elif left.y() > 0:\n                bounds.moveBottom(rect.bottom())\n                \n        elif self.opts[\'justify\'] == \'center\':\n            bounds.moveCenter(rect.center())\n            #bounds = self.itemRect()\n            #self.item.setPos(self.width()/2. - bounds.width()/2., 0)\n        elif self.opts[\'justify\'] == \'right\':\n            if left.x() != 0:\n                bounds.moveRight(rect.right())\n            if left.y() < 0:\n                bounds.moveBottom(rect.bottom())\n            elif left.y() > 0:\n                bounds.moveTop(rect.top())\n            #bounds = self.itemRect()\n            #self.item.setPos(self.width() - bounds.width(), 0)\n            \n        self.item.setPos(bounds.topLeft() - self.itemRect().topLeft())\n        self.updateMin()\n        \n    def setAngle(self, angle):\n        self.angle = angle\n        self.item.resetTransform()\n        self.item.rotate(angle)\n        self.updateMin()\n        \n        \n    def updateMin(self):\n        bounds = self.itemRect()\n        self.setMinimumWidth(bounds.width())\n        self.setMinimumHeight(bounds.height())\n        \n        self._sizeHint = {\n            QtCore.Qt.MinimumSize: (bounds.width(), bounds.height()),\n            QtCore.Qt.PreferredSize: (bounds.width(), bounds.height()),\n            QtCore.Qt.MaximumSize: (-1, -1),  #bounds.width()*2, bounds.height()*2),\n            QtCore.Qt.MinimumDescent: (0, 0)  ##?? what is this?\n        }\n        self.updateGeometry()\n        \n    def sizeHint(self, hint, constraint):\n        if hint not in self._sizeHint:\n            return QtCore.QSizeF(0, 0)\n        return QtCore.QSizeF(*self._sizeHint[hint])\n        \n    def itemRect(self):\n        return self.item.mapRectToParent(self.item.boundingRect())\n        \n    #def paint(self, p, *args):\n        #p.setPen(fn.mkPen(\'r\'))\n        #p.drawRect(self.rect())\n        #p.setPen(fn.mkPen(\'g\'))\n        #p.drawRect(self.itemRect())\n        \n'"
src/third_party/pyqtgraph/graphicsItems/LegendItem.py,0,"b'from .GraphicsWidget import GraphicsWidget\nfrom .LabelItem import LabelItem\nfrom ..Qt import QtGui, QtCore\nfrom .. import functions as fn\nfrom ..Point import Point\nfrom .ScatterPlotItem import ScatterPlotItem, drawSymbol\nfrom .PlotDataItem import PlotDataItem\nfrom .GraphicsWidgetAnchor import GraphicsWidgetAnchor\n__all__ = [\'LegendItem\']\n\nclass LegendItem(GraphicsWidget, GraphicsWidgetAnchor):\n    """"""\n    Displays a legend used for describing the contents of a plot.\n    LegendItems are most commonly created by calling PlotItem.addLegend().\n\n    Note that this item should not be added directly to a PlotItem. Instead,\n    Make it a direct descendant of the PlotItem::\n\n        legend.setParentItem(plotItem)\n\n    """"""\n    def __init__(self, size=None, offset=None):\n        """"""\n        ==============  ===============================================================\n        **Arguments:**\n        size            Specifies the fixed size (width, height) of the legend. If\n                        this argument is omitted, the legend will autimatically resize\n                        to fit its contents.\n        offset          Specifies the offset position relative to the legend\'s parent.\n                        Positive values offset from the left or top; negative values\n                        offset from the right or bottom. If offset is None, the\n                        legend must be anchored manually by calling anchor() or\n                        positioned by calling setPos().\n        ==============  ===============================================================\n        \n        """"""\n        \n        \n        GraphicsWidget.__init__(self)\n        GraphicsWidgetAnchor.__init__(self)\n        self.setFlag(self.ItemIgnoresTransformations)\n        self.layout = QtGui.QGraphicsGridLayout()\n        self.setLayout(self.layout)\n        self.items = []\n        self.size = size\n        self.offset = offset\n        if size is not None:\n            self.setGeometry(QtCore.QRectF(0, 0, self.size[0], self.size[1]))\n        \n    def setParentItem(self, p):\n        ret = GraphicsWidget.setParentItem(self, p)\n        if self.offset is not None:\n            offset = Point(self.offset)\n            anchorx = 1 if offset[0] <= 0 else 0\n            anchory = 1 if offset[1] <= 0 else 0\n            anchor = (anchorx, anchory)\n            self.anchor(itemPos=anchor, parentPos=anchor, offset=offset)\n        return ret\n        \n    def addItem(self, item, name):\n        """"""\n        Add a new entry to the legend. \n\n        ==============  ========================================================\n        **Arguments:**\n        item            A PlotDataItem from which the line and point style\n                        of the item will be determined or an instance of\n                        ItemSample (or a subclass), allowing the item display\n                        to be customized.\n        title           The title to display for this item. Simple HTML allowed.\n        ==============  ========================================================\n        """"""\n        label = LabelItem(name)\n        if isinstance(item, ItemSample):\n            sample = item\n        else:\n            sample = ItemSample(item)        \n        row = self.layout.rowCount()\n        self.items.append((sample, label))\n        self.layout.addItem(sample, row, 0)\n        self.layout.addItem(label, row, 1)\n        self.updateSize()\n    \n    def removeItem(self, item):\n        """"""\n        Removes one item from the legend. \n\n        ==============  ========================================================\n        **Arguments:**\n        item            The item to remove or its name.\n        ==============  ========================================================\n        """"""\n        # Thanks, Ulrich!\n        # cycle for a match\n        for sample, label in self.items:\n            if sample.item is item or label.text == item:\n                self.items.remove( (sample, label) )    # remove from itemlist\n                self.layout.removeItem(sample)          # remove from layout\n                sample.close()                          # remove from drawing\n                self.layout.removeItem(label)\n                label.close()\n                self.updateSize()                       # redraq box\n\n    def updateSize(self):\n        if self.size is not None:\n            return\n            \n        height = 0\n        width = 0\n        #print(""-------"")\n        for sample, label in self.items:\n            height += max(sample.height(), label.height()) + 3\n            width = max(width, (sample.sizeHint(QtCore.Qt.MinimumSize, sample.size()).width() +\n                                label.sizeHint(QtCore.Qt.MinimumSize, label.size()).width()))\n            #print(width, height)\n        #print width, height\n        self.setGeometry(0, 0, width+25, height)\n    \n    def boundingRect(self):\n        return QtCore.QRectF(0, 0, self.width(), self.height())\n    \n    def paint(self, p, *args):\n        p.setPen(fn.mkPen(255,255,255,100))\n        p.setBrush(fn.mkBrush(100,100,100,50))\n        p.drawRect(self.boundingRect())\n\n    def hoverEvent(self, ev):\n        ev.acceptDrags(QtCore.Qt.LeftButton)\n        \n    def mouseDragEvent(self, ev):\n        if ev.button() == QtCore.Qt.LeftButton:\n            dpos = ev.pos() - ev.lastPos()\n            self.autoAnchor(self.pos() + dpos)\n\n\nclass ItemSample(GraphicsWidget):\n    """""" Class responsible for drawing a single item in a LegendItem (sans label).\n    \n    This may be subclassed to draw custom graphics in a Legend.\n    """"""\n    ## Todo: make this more generic; let each item decide how it should be represented.\n    def __init__(self, item):\n        GraphicsWidget.__init__(self)\n        self.item = item\n    \n    def boundingRect(self):\n        return QtCore.QRectF(0, 0, 20, 20)\n        \n    def paint(self, p, *args):\n        #p.setRenderHint(p.Antialiasing)  # only if the data is antialiased.\n        opts = self.item.opts\n        \n        if opts.get(\'fillLevel\',None) is not None and opts.get(\'fillBrush\',None) is not None:\n            p.setBrush(fn.mkBrush(opts[\'fillBrush\']))\n            p.setPen(fn.mkPen(None))\n            p.drawPolygon(QtGui.QPolygonF([QtCore.QPointF(2,18), QtCore.QPointF(18,2), QtCore.QPointF(18,18)]))\n        \n        if not isinstance(self.item, ScatterPlotItem):\n            p.setPen(fn.mkPen(opts[\'pen\']))\n            p.drawLine(2, 18, 18, 2)\n        \n        symbol = opts.get(\'symbol\', None)\n        if symbol is not None:\n            if isinstance(self.item, PlotDataItem):\n                opts = self.item.scatter.opts\n                \n            pen = fn.mkPen(opts[\'pen\'])\n            brush = fn.mkBrush(opts[\'brush\'])\n            size = opts[\'size\']\n            \n            p.translate(10,10)\n            path = drawSymbol(p, symbol, size, pen, brush)\n        \n        \n        \n        \n'"
src/third_party/pyqtgraph/graphicsItems/LinearRegionItem.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .GraphicsObject import GraphicsObject\nfrom .InfiniteLine import InfiniteLine\nfrom .. import functions as fn\nfrom .. import debug as debug\n\n__all__ = [\'LinearRegionItem\']\n\nclass LinearRegionItem(GraphicsObject):\n    """"""\n    **Bases:** :class:`GraphicsObject <pyqtgraph.GraphicsObject>`\n    \n    Used for marking a horizontal or vertical region in plots.\n    The region can be dragged and is bounded by lines which can be dragged individually.\n    \n    ===============================  =============================================================================\n    **Signals:**\n    sigRegionChangeFinished(self)    Emitted when the user has finished dragging the region (or one of its lines)\n                                     and when the region is changed programatically.\n    sigRegionChanged(self)           Emitted while the user is dragging the region (or one of its lines)\n                                     and when the region is changed programatically.\n    ===============================  =============================================================================\n    """"""\n    \n    sigRegionChangeFinished = QtCore.Signal(object)\n    sigRegionChanged = QtCore.Signal(object)\n    Vertical = 0\n    Horizontal = 1\n    _orientation_axis = {\n        Vertical: 0,\n        Horizontal: 1,\n        \'vertical\': 0,\n        \'horizontal\': 1,\n        }\n    \n    def __init__(self, values=(0, 1), orientation=\'vertical\', brush=None, pen=None,\n                 hoverBrush=None, hoverPen=None, movable=True, bounds=None, \n                 span=(0, 1), swapMode=\'sort\'):\n        """"""Create a new LinearRegionItem.\n        \n        ==============  =====================================================================\n        **Arguments:**\n        values          A list of the positions of the lines in the region. These are not\n                        limits; limits can be set by specifying bounds.\n        orientation     Options are \'vertical\' or \'horizontal\', indicating the \n                        The default is \'vertical\', indicating that the \n        brush           Defines the brush that fills the region. Can be any arguments that\n                        are valid for :func:`mkBrush <pyqtgraph.mkBrush>`. Default is\n                        transparent blue.\n        pen             The pen to use when drawing the lines that bound the region.\n        hoverBrush      The brush to use when the mouse is hovering over the region.\n        hoverPen        The pen to use when the mouse is hovering over the region.\n        movable         If True, the region and individual lines are movable by the user; if\n                        False, they are static.\n        bounds          Optional [min, max] bounding values for the region\n        span            Optional [min, max] giving the range over the view to draw\n                        the region. For example, with a vertical line, use span=(0.5, 1)\n                        to draw only on the top half of the view.\n        swapMode        Sets the behavior of the region when the lines are moved such that\n                        their order reverses:\n                        * ""block"" means the user cannot drag one line past the other\n                        * ""push"" causes both lines to be moved if one would cross the other\n                        * ""sort"" means that lines may trade places, but the output of\n                          getRegion always gives the line positions in ascending order.\n                        * None means that no attempt is made to handle swapped line \n                          positions.\n                        The default is ""sort"".\n        ==============  =====================================================================\n        """"""\n        \n        GraphicsObject.__init__(self)\n        self.orientation = orientation\n        self.bounds = QtCore.QRectF()\n        self.blockLineSignal = False\n        self.moving = False\n        self.mouseHovering = False\n        self.span = span\n        self.swapMode = swapMode\n        self._bounds = None\n        \n        # note LinearRegionItem.Horizontal and LinearRegionItem.Vertical\n        # are kept for backward compatibility.\n        lineKwds = dict(\n            movable=movable,\n            bounds=bounds,\n            span=span,\n            pen=pen,\n            hoverPen=hoverPen,\n            )\n            \n        if orientation in (\'horizontal\', LinearRegionItem.Horizontal):\n            self.lines = [\n                # rotate lines to 180 to preserve expected line orientation \n                # with respect to region. This ensures that placing a \'<|\' \n                # marker on lines[0] causes it to point left in vertical mode\n                # and down in horizontal mode. \n                InfiniteLine(QtCore.QPointF(0, values[0]), angle=0, **lineKwds), \n                InfiniteLine(QtCore.QPointF(0, values[1]), angle=0, **lineKwds)]\n            self.lines[0].scale(1, -1)\n            self.lines[1].scale(1, -1)\n        elif orientation in (\'vertical\', LinearRegionItem.Vertical):\n            self.lines = [\n                InfiniteLine(QtCore.QPointF(values[0], 0), angle=90, **lineKwds), \n                InfiniteLine(QtCore.QPointF(values[1], 0), angle=90, **lineKwds)]\n        else:\n            raise Exception(""Orientation must be \'vertical\' or \'horizontal\'."")\n        \n        for l in self.lines:\n            l.setParentItem(self)\n            l.sigPositionChangeFinished.connect(self.lineMoveFinished)\n        self.lines[0].sigPositionChanged.connect(lambda: self.lineMoved(0))\n        self.lines[1].sigPositionChanged.connect(lambda: self.lineMoved(1))\n            \n        if brush is None:\n            brush = QtGui.QBrush(QtGui.QColor(0, 0, 255, 50))\n        self.setBrush(brush)\n        \n        if hoverBrush is None:\n            c = self.brush.color()\n            c.setAlpha(min(c.alpha() * 2, 255))\n            hoverBrush = fn.mkBrush(c)\n        self.setHoverBrush(hoverBrush)\n        \n        self.setMovable(movable)\n        \n    def getRegion(self):\n        """"""Return the values at the edges of the region.""""""\n        r = (self.lines[0].value(), self.lines[1].value())\n        if self.swapMode == \'sort\':\n            return (min(r), max(r))\n        else:\n            return r\n\n    def setRegion(self, rgn):\n        """"""Set the values for the edges of the region.\n        \n        ==============   ==============================================\n        **Arguments:**\n        rgn              A list or tuple of the lower and upper values.\n        ==============   ==============================================\n        """"""\n        if self.lines[0].value() == rgn[0] and self.lines[1].value() == rgn[1]:\n            return\n        self.blockLineSignal = True\n        self.lines[0].setValue(rgn[0])\n        self.blockLineSignal = False\n        self.lines[1].setValue(rgn[1])\n        #self.blockLineSignal = False\n        self.lineMoved(0)\n        self.lineMoved(1)\n        self.lineMoveFinished()\n\n    def setBrush(self, *br, **kargs):\n        """"""Set the brush that fills the region. Can have any arguments that are valid\n        for :func:`mkBrush <pyqtgraph.mkBrush>`.\n        """"""\n        self.brush = fn.mkBrush(*br, **kargs)\n        self.currentBrush = self.brush\n\n    def setHoverBrush(self, *br, **kargs):\n        """"""Set the brush that fills the region when the mouse is hovering over.\n        Can have any arguments that are valid\n        for :func:`mkBrush <pyqtgraph.mkBrush>`.\n        """"""\n        self.hoverBrush = fn.mkBrush(*br, **kargs)\n\n    def setBounds(self, bounds):\n        """"""Optional [min, max] bounding values for the region. To have no bounds on the\n        region use [None, None].\n        Does not affect the current position of the region unless it is outside the new bounds. \n        See :func:`setRegion <pyqtgraph.LinearRegionItem.setRegion>` to set the position \n        of the region.""""""\n        for l in self.lines:\n            l.setBounds(bounds)\n        \n    def setMovable(self, m):\n        """"""Set lines to be movable by the user, or not. If lines are movable, they will \n        also accept HoverEvents.""""""\n        for l in self.lines:\n            l.setMovable(m)\n        self.movable = m\n        self.setAcceptHoverEvents(m)\n\n    def setSpan(self, mn, mx):\n        if self.span == (mn, mx):\n            return\n        self.span = (mn, mx)\n        self.lines[0].setSpan(mn, mx)\n        self.lines[1].setSpan(mn, mx)\n        self.update()\n\n    def boundingRect(self):\n        br = self.viewRect()  # bounds of containing ViewBox mapped to local coords.\n        \n        rng = self.getRegion()\n        if self.orientation in (\'vertical\', LinearRegionItem.Vertical):\n            br.setLeft(rng[0])\n            br.setRight(rng[1])\n            length = br.height()\n            br.setBottom(br.top() + length * self.span[1])\n            br.setTop(br.top() + length * self.span[0])\n        else:\n            br.setTop(rng[0])\n            br.setBottom(rng[1])\n            length = br.width()\n            br.setRight(br.left() + length * self.span[1])\n            br.setLeft(br.left() + length * self.span[0])\n\n        br = br.normalized()\n        \n        if self._bounds != br:\n            self._bounds = br\n            self.prepareGeometryChange()\n        \n        return br\n        \n    def paint(self, p, *args):\n        profiler = debug.Profiler()\n        p.setBrush(self.currentBrush)\n        p.setPen(fn.mkPen(None))\n        p.drawRect(self.boundingRect())\n\n    def dataBounds(self, axis, frac=1.0, orthoRange=None):\n        if axis == self._orientation_axis[self.orientation]:\n            return self.getRegion()\n        else:\n            return None\n\n    def lineMoved(self, i):\n        if self.blockLineSignal:\n            return\n\n        # lines swapped\n        if self.lines[0].value() > self.lines[1].value():\n            if self.swapMode == \'block\':\n                self.lines[i].setValue(self.lines[1-i].value())\n            elif self.swapMode == \'push\':\n                self.lines[1-i].setValue(self.lines[i].value())\n        \n        self.prepareGeometryChange()\n        self.sigRegionChanged.emit(self)\n            \n    def lineMoveFinished(self):\n        self.sigRegionChangeFinished.emit(self)\n\n    def mouseDragEvent(self, ev):\n        if not self.movable or int(ev.button() & QtCore.Qt.LeftButton) == 0:\n            return\n        ev.accept()\n        \n        if ev.isStart():\n            bdp = ev.buttonDownPos()\n            self.cursorOffsets = [l.pos() - bdp for l in self.lines]\n            self.startPositions = [l.pos() for l in self.lines]\n            self.moving = True\n            \n        if not self.moving:\n            return\n            \n        self.lines[0].blockSignals(True)  # only want to update once\n        for i, l in enumerate(self.lines):\n            l.setPos(self.cursorOffsets[i] + ev.pos())\n        self.lines[0].blockSignals(False)\n        self.prepareGeometryChange()\n        \n        if ev.isFinish():\n            self.moving = False\n            self.sigRegionChangeFinished.emit(self)\n        else:\n            self.sigRegionChanged.emit(self)\n            \n    def mouseClickEvent(self, ev):\n        if self.moving and ev.button() == QtCore.Qt.RightButton:\n            ev.accept()\n            for i, l in enumerate(self.lines):\n                l.setPos(self.startPositions[i])\n            self.moving = False\n            self.sigRegionChanged.emit(self)\n            self.sigRegionChangeFinished.emit(self)\n\n    def hoverEvent(self, ev):\n        if self.movable and (not ev.isExit()) and ev.acceptDrags(QtCore.Qt.LeftButton):\n            self.setMouseHover(True)\n        else:\n            self.setMouseHover(False)\n            \n    def setMouseHover(self, hover):\n        ## Inform the item that the mouse is(not) hovering over it\n        if self.mouseHovering == hover:\n            return\n        self.mouseHovering = hover\n        if hover:\n            self.currentBrush = self.hoverBrush\n        else:\n            self.currentBrush = self.brush\n        self.update()\n'"
src/third_party/pyqtgraph/graphicsItems/MultiPlotItem.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nMultiPlotItem.py -  Graphics item used for displaying an array of PlotItems\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n""""""\n\nfrom numpy import ndarray\nfrom . import GraphicsLayout\nfrom ..metaarray import *\n\n\n__all__ = [\'MultiPlotItem\']\nclass MultiPlotItem(GraphicsLayout.GraphicsLayout):\n    """"""\n    Automatically generates a grid of plots from a multi-dimensional array\n    """"""\n    def __init__(self, *args, **kwds):\n        GraphicsLayout.GraphicsLayout.__init__(self, *args, **kwds)\n        self.plots = []\n        \n\n    def plot(self, data):\n        #self.layout.clear()\n\n        if hasattr(data, \'implements\') and data.implements(\'MetaArray\'):\n            if data.ndim != 2:\n                raise Exception(""MultiPlot currently only accepts 2D MetaArray."")\n            ic = data.infoCopy()\n            ax = 0\n            for i in [0, 1]:\n                if \'cols\' in ic[i]:\n                    ax = i\n                    break\n            #print ""Plotting using axis %d as columns (%d plots)"" % (ax, data.shape[ax])\n            for i in range(data.shape[ax]):\n                pi = self.addPlot()\n                self.nextRow()\n                sl = [slice(None)] * 2\n                sl[ax] = i\n                pi.plot(data[tuple(sl)])\n                #self.layout.addItem(pi, i, 0)\n                self.plots.append((pi, i, 0))\n                info = ic[ax][\'cols\'][i]\n                title = info.get(\'title\', info.get(\'name\', None))\n                units = info.get(\'units\', None)\n                pi.setLabel(\'left\', text=title, units=units)\n            info = ic[1-ax]\n            title = info.get(\'title\', info.get(\'name\', None))\n            units = info.get(\'units\', None)\n            pi.setLabel(\'bottom\', text=title, units=units)\n        else:\n            raise Exception(""Data type %s not (yet?) supported for MultiPlot."" % type(data))\n\n    def close(self):\n        for p in self.plots:\n            p[0].close()\n        self.plots = None\n        self.clear()\n\n\n\n'"
src/third_party/pyqtgraph/graphicsItems/PlotCurveItem.py,18,"b'from ..Qt import QtGui, QtCore\ntry:\n    from ..Qt import QtOpenGL\n    HAVE_OPENGL = True\nexcept:\n    HAVE_OPENGL = False\n    \nimport numpy as np\nfrom .GraphicsObject import GraphicsObject\nfrom .. import functions as fn\nfrom ..Point import Point\nimport struct, sys\nfrom .. import getConfigOption\nfrom .. import debug\n\n__all__ = [\'PlotCurveItem\']\nclass PlotCurveItem(GraphicsObject):\n    \n    \n    """"""\n    Class representing a single plot curve. Instances of this class are created\n    automatically as part of PlotDataItem; these rarely need to be instantiated\n    directly.\n    \n    Features:\n    \n    - Fast data update\n    - Fill under curve\n    - Mouse interaction\n    \n    ====================  ===============================================\n    **Signals:**\n    sigPlotChanged(self)  Emitted when the data being plotted has changed\n    sigClicked(self)      Emitted when the curve is clicked\n    ====================  ===============================================\n    """"""\n    \n    sigPlotChanged = QtCore.Signal(object)\n    sigClicked = QtCore.Signal(object)\n    \n    def __init__(self, *args, **kargs):\n        """"""\n        Forwards all arguments to :func:`setData <pyqtgraph.PlotCurveItem.setData>`.\n        \n        Some extra arguments are accepted as well:\n        \n        ==============  =======================================================\n        **Arguments:**\n        parent          The parent GraphicsObject (optional)\n        clickable       If True, the item will emit sigClicked when it is \n                        clicked on. Defaults to False.\n        ==============  =======================================================\n        """"""\n        GraphicsObject.__init__(self, kargs.get(\'parent\', None))\n        self.clear()\n            \n        ## this is disastrous for performance.\n        #self.setCacheMode(QtGui.QGraphicsItem.DeviceCoordinateCache)\n        \n        self.metaData = {}\n        self.opts = {\n            \'pen\': fn.mkPen(\'w\'),\n            \'shadowPen\': None,\n            \'fillLevel\': None,\n            \'brush\': None,\n            \'stepMode\': False,\n            \'name\': None,\n            \'antialias\': getConfigOption(\'antialias\'),\n            \'connect\': \'all\',\n            \'mouseWidth\': 8, # width of shape responding to mouse click\n            \'compositionMode\': None,\n        }\n        self.setClickable(kargs.get(\'clickable\', False))\n        self.setData(*args, **kargs)\n        \n    def implements(self, interface=None):\n        ints = [\'plotData\']\n        if interface is None:\n            return ints\n        return interface in ints\n    \n    def name(self):\n        return self.opts.get(\'name\', None)\n    \n    def setClickable(self, s, width=None):\n        """"""Sets whether the item responds to mouse clicks.\n        \n        The *width* argument specifies the width in pixels orthogonal to the\n        curve that will respond to a mouse click.\n        """"""\n        self.clickable = s\n        if width is not None:\n            self.opts[\'mouseWidth\'] = width\n            self._mouseShape = None\n            self._boundingRect = None        \n        \n    def setCompositionMode(self, mode):\n        """"""Change the composition mode of the item (see QPainter::CompositionMode\n        in the Qt documentation). This is useful when overlaying multiple items.\n        \n        ============================================  ============================================================\n        **Most common arguments:**\n        QtGui.QPainter.CompositionMode_SourceOver     Default; image replaces the background if it\n                                                      is opaque. Otherwise, it uses the alpha channel to blend\n                                                      the image with the background.\n        QtGui.QPainter.CompositionMode_Overlay        The image color is mixed with the background color to \n                                                      reflect the lightness or darkness of the background.\n        QtGui.QPainter.CompositionMode_Plus           Both the alpha and color of the image and background pixels \n                                                      are added together.\n        QtGui.QPainter.CompositionMode_Multiply       The output is the image color multiplied by the background.\n        ============================================  ============================================================\n        """"""\n        self.opts[\'compositionMode\'] = mode\n        self.update()\n        \n    def getData(self):\n        return self.xData, self.yData\n        \n    def dataBounds(self, ax, frac=1.0, orthoRange=None):\n        ## Need this to run as fast as possible.\n        ## check cache first:\n        cache = self._boundsCache[ax]\n        if cache is not None and cache[0] == (frac, orthoRange):\n            return cache[1]\n        \n        (x, y) = self.getData()\n        if x is None or len(x) == 0:\n            return (None, None)\n            \n        if ax == 0:\n            d = x\n            d2 = y\n        elif ax == 1:\n            d = y\n            d2 = x\n\n        ## If an orthogonal range is specified, mask the data now\n        if orthoRange is not None:\n            mask = (d2 >= orthoRange[0]) * (d2 <= orthoRange[1])\n            d = d[mask]\n            #d2 = d2[mask]\n            \n        if len(d) == 0:\n            return (None, None)\n\n        ## Get min/max (or percentiles) of the requested data range\n        if frac >= 1.0:\n            # include complete data range\n            # first try faster nanmin/max function, then cut out infs if needed.\n            b = (np.nanmin(d), np.nanmax(d))\n            if any(np.isinf(b)):\n                mask = np.isfinite(d)\n                d = d[mask]\n                if len(d) == 0:\n                    return (None, None)\n                b = (d.min(), d.max())\n                \n        elif frac <= 0.0:\n            raise Exception(""Value for parameter \'frac\' must be > 0. (got %s)"" % str(frac))\n        else:\n            # include a percentile of data range\n            mask = np.isfinite(d)\n            d = d[mask]\n            b = np.percentile(d, [50 * (1 - frac), 50 * (1 + frac)])\n\n        ## adjust for fill level\n        if ax == 1 and self.opts[\'fillLevel\'] is not None:\n            b = (min(b[0], self.opts[\'fillLevel\']), max(b[1], self.opts[\'fillLevel\']))\n            \n        ## Add pen width only if it is non-cosmetic.\n        pen = self.opts[\'pen\']\n        spen = self.opts[\'shadowPen\']\n        if not pen.isCosmetic():\n            b = (b[0] - pen.widthF()*0.7072, b[1] + pen.widthF()*0.7072)\n        if spen is not None and not spen.isCosmetic() and spen.style() != QtCore.Qt.NoPen:\n            b = (b[0] - spen.widthF()*0.7072, b[1] + spen.widthF()*0.7072)\n            \n        self._boundsCache[ax] = [(frac, orthoRange), b]\n        return b\n            \n    def pixelPadding(self):\n        pen = self.opts[\'pen\']\n        spen = self.opts[\'shadowPen\']\n        w = 0\n        if pen.isCosmetic():\n            w += pen.widthF()*0.7072\n        if spen is not None and spen.isCosmetic() and spen.style() != QtCore.Qt.NoPen:\n            w = max(w, spen.widthF()*0.7072)\n        if self.clickable:\n            w = max(w, self.opts[\'mouseWidth\']//2 + 1)\n        return w\n\n    def boundingRect(self):\n        if self._boundingRect is None:\n            (xmn, xmx) = self.dataBounds(ax=0)\n            (ymn, ymx) = self.dataBounds(ax=1)\n            if xmn is None or ymn is None:\n                return QtCore.QRectF()\n            \n            px = py = 0.0\n            pxPad = self.pixelPadding()\n            if pxPad > 0:\n                # determine length of pixel in local x, y directions    \n                px, py = self.pixelVectors()\n                try:\n                    px = 0 if px is None else px.length()\n                except OverflowError:\n                    px = 0\n                try:\n                    py = 0 if py is None else py.length()\n                except OverflowError:\n                    py = 0\n                \n                # return bounds expanded by pixel size\n                px *= pxPad\n                py *= pxPad\n            #px += self._maxSpotWidth * 0.5\n            #py += self._maxSpotWidth * 0.5\n            self._boundingRect = QtCore.QRectF(xmn-px, ymn-py, (2*px)+xmx-xmn, (2*py)+ymx-ymn)\n            \n        return self._boundingRect\n    \n    def viewTransformChanged(self):\n        self.invalidateBounds()\n        self.prepareGeometryChange()\n        \n    #def boundingRect(self):\n        #if self._boundingRect is None:\n            #(x, y) = self.getData()\n            #if x is None or y is None or len(x) == 0 or len(y) == 0:\n                #return QtCore.QRectF()\n                \n                \n            #if self.opts[\'shadowPen\'] is not None:\n                #lineWidth = (max(self.opts[\'pen\'].width(), self.opts[\'shadowPen\'].width()) + 1)\n            #else:\n                #lineWidth = (self.opts[\'pen\'].width()+1)\n                \n            \n            #pixels = self.pixelVectors()\n            #if pixels == (None, None):\n                #pixels = [Point(0,0), Point(0,0)]\n                \n            #xmin = x.min()\n            #xmax = x.max()\n            #ymin = y.min()\n            #ymax = y.max()\n            \n            #if self.opts[\'fillLevel\'] is not None:\n                #ymin = min(ymin, self.opts[\'fillLevel\'])\n                #ymax = max(ymax, self.opts[\'fillLevel\'])\n                \n            #xmin -= pixels[0].x() * lineWidth\n            #xmax += pixels[0].x() * lineWidth\n            #ymin -= abs(pixels[1].y()) * lineWidth\n            #ymax += abs(pixels[1].y()) * lineWidth\n            \n            #self._boundingRect = QtCore.QRectF(xmin, ymin, xmax-xmin, ymax-ymin)\n        #return self._boundingRect\n\n        \n    def invalidateBounds(self):\n        self._boundingRect = None\n        self._boundsCache = [None, None]\n            \n    def setPen(self, *args, **kargs):\n        """"""Set the pen used to draw the curve.""""""\n        self.opts[\'pen\'] = fn.mkPen(*args, **kargs)\n        self.invalidateBounds()\n        self.update()\n        \n    def setShadowPen(self, *args, **kargs):\n        """"""Set the shadow pen used to draw behind tyhe primary pen.\n        This pen must have a larger width than the primary \n        pen to be visible.\n        """"""\n        self.opts[\'shadowPen\'] = fn.mkPen(*args, **kargs)\n        self.invalidateBounds()\n        self.update()\n\n    def setBrush(self, *args, **kargs):\n        """"""Set the brush used when filling the area under the curve""""""\n        self.opts[\'brush\'] = fn.mkBrush(*args, **kargs)\n        self.invalidateBounds()\n        self.update()\n        \n    def setFillLevel(self, level):\n        """"""Set the level filled to when filling under the curve""""""\n        self.opts[\'fillLevel\'] = level\n        self.fillPath = None\n        self.invalidateBounds()\n        self.update()\n\n    def setData(self, *args, **kargs):\n        """"""\n        =============== ========================================================\n        **Arguments:**\n        x, y            (numpy arrays) Data to show \n        pen             Pen to use when drawing. Any single argument accepted by\n                        :func:`mkPen <pyqtgraph.mkPen>` is allowed.\n        shadowPen       Pen for drawing behind the primary pen. Usually this\n                        is used to emphasize the curve by providing a \n                        high-contrast border. Any single argument accepted by\n                        :func:`mkPen <pyqtgraph.mkPen>` is allowed.\n        fillLevel       (float or None) Fill the area \'under\' the curve to\n                        *fillLevel*\n        brush           QBrush to use when filling. Any single argument accepted\n                        by :func:`mkBrush <pyqtgraph.mkBrush>` is allowed.\n        antialias       (bool) Whether to use antialiasing when drawing. This\n                        is disabled by default because it decreases performance.\n        stepMode        If True, two orthogonal lines are drawn for each sample\n                        as steps. This is commonly used when drawing histograms.\n                        Note that in this case, len(x) == len(y) + 1\n        connect         Argument specifying how vertexes should be connected\n                        by line segments. Default is ""all"", indicating full\n                        connection. ""pairs"" causes only even-numbered segments\n                        to be drawn. ""finite"" causes segments to be omitted if\n                        they are attached to nan or inf values. For any other\n                        connectivity, specify an array of boolean values.\n        compositionMode See :func:`setCompositionMode \n                        <pyqtgraph.PlotCurveItem.setCompositionMode>`.\n        =============== ========================================================\n        \n        If non-keyword arguments are used, they will be interpreted as\n        setData(y) for a single argument and setData(x, y) for two\n        arguments.\n        \n        \n        """"""\n        self.updateData(*args, **kargs)\n        \n    def updateData(self, *args, **kargs):\n        profiler = debug.Profiler()\n\n        if \'compositionMode\' in kargs:\n            self.setCompositionMode(kargs[\'compositionMode\'])\n\n        if len(args) == 1:\n            kargs[\'y\'] = args[0]\n        elif len(args) == 2:\n            kargs[\'x\'] = args[0]\n            kargs[\'y\'] = args[1]\n        \n        if \'y\' not in kargs or kargs[\'y\'] is None:\n            kargs[\'y\'] = np.array([])\n        if \'x\' not in kargs or kargs[\'x\'] is None:\n            kargs[\'x\'] = np.arange(len(kargs[\'y\']))\n            \n        for k in [\'x\', \'y\']:\n            data = kargs[k]\n            if isinstance(data, list):\n                data = np.array(data)\n                kargs[k] = data\n            if not isinstance(data, np.ndarray) or data.ndim > 1:\n                raise Exception(""Plot data must be 1D ndarray."")\n            if \'complex\' in str(data.dtype):\n                raise Exception(""Can not plot complex data types."")\n            \n        profiler(""data checks"")\n        \n        #self.setCacheMode(QtGui.QGraphicsItem.NoCache)  ## Disabling and re-enabling the cache works around a bug in Qt 4.6 causing the cached results to display incorrectly\n                                                        ##    Test this bug with test_PlotWidget and zoom in on the animated plot\n        self.invalidateBounds()\n        self.prepareGeometryChange()\n        self.informViewBoundsChanged()\n        self.yData = kargs[\'y\'].view(np.ndarray)\n        self.xData = kargs[\'x\'].view(np.ndarray)\n        \n        profiler(\'copy\')\n        \n        if \'stepMode\' in kargs:\n            self.opts[\'stepMode\'] = kargs[\'stepMode\']\n        \n        if self.opts[\'stepMode\'] is True:\n            if len(self.xData) != len(self.yData)+1:  ## allow difference of 1 for step mode plots\n                raise Exception(""len(X) must be len(Y)+1 since stepMode=True (got %s and %s)"" % (self.xData.shape, self.yData.shape))\n        else:\n            if self.xData.shape != self.yData.shape:  ## allow difference of 1 for step mode plots\n                raise Exception(""X and Y arrays must be the same shape--got %s and %s."" % (self.xData.shape, self.yData.shape))\n        \n        self.path = None\n        self.fillPath = None\n        self._mouseShape = None\n        #self.xDisp = self.yDisp = None\n        \n        if \'name\' in kargs:\n            self.opts[\'name\'] = kargs[\'name\']\n        if \'connect\' in kargs:\n            self.opts[\'connect\'] = kargs[\'connect\']\n        if \'pen\' in kargs:\n            self.setPen(kargs[\'pen\'])\n        if \'shadowPen\' in kargs:\n            self.setShadowPen(kargs[\'shadowPen\'])\n        if \'fillLevel\' in kargs:\n            self.setFillLevel(kargs[\'fillLevel\'])\n        if \'brush\' in kargs:\n            self.setBrush(kargs[\'brush\'])\n        if \'antialias\' in kargs:\n            self.opts[\'antialias\'] = kargs[\'antialias\']\n        \n        \n        profiler(\'set\')\n        self.update()\n        profiler(\'update\')\n        self.sigPlotChanged.emit(self)\n        profiler(\'emit\')\n        \n    def generatePath(self, x, y):\n        if self.opts[\'stepMode\']:\n            ## each value in the x/y arrays generates 2 points.\n            x2 = np.empty((len(x),2), dtype=x.dtype)\n            x2[:] = x[:,np.newaxis]\n            if self.opts[\'fillLevel\'] is None:\n                x = x2.reshape(x2.size)[1:-1]\n                y2 = np.empty((len(y),2), dtype=y.dtype)\n                y2[:] = y[:,np.newaxis]\n                y = y2.reshape(y2.size)\n            else:\n                ## If we have a fill level, add two extra points at either end\n                x = x2.reshape(x2.size)\n                y2 = np.empty((len(y)+2,2), dtype=y.dtype)\n                y2[1:-1] = y[:,np.newaxis]\n                y = y2.reshape(y2.size)[1:-1]\n                y[0] = self.opts[\'fillLevel\']\n                y[-1] = self.opts[\'fillLevel\']\n        \n        path = fn.arrayToQPath(x, y, connect=self.opts[\'connect\'])\n        \n        return path\n\n\n    def getPath(self):\n        if self.path is None:\n            x,y = self.getData()\n            if x is None or len(x) == 0 or y is None or len(y) == 0:\n                self.path = QtGui.QPainterPath()\n            else:\n                self.path = self.generatePath(*self.getData())\n            self.fillPath = None\n            self._mouseShape = None\n            \n        return self.path\n\n    @debug.warnOnException  ## raising an exception here causes crash\n    def paint(self, p, opt, widget):\n        profiler = debug.Profiler()\n        if self.xData is None or len(self.xData) == 0:\n            return\n        \n        if HAVE_OPENGL and getConfigOption(\'enableExperimental\') and isinstance(widget, QtOpenGL.QGLWidget):\n            self.paintGL(p, opt, widget)\n            return\n        \n        x = None\n        y = None\n        path = self.getPath()\n        profiler(\'generate path\')\n        \n        if self._exportOpts is not False:\n            aa = self._exportOpts.get(\'antialias\', True)\n        else:\n            aa = self.opts[\'antialias\']\n        \n        p.setRenderHint(p.Antialiasing, aa)\n        \n        cmode = self.opts[\'compositionMode\']\n        if cmode is not None:\n            p.setCompositionMode(cmode)\n            \n        if self.opts[\'brush\'] is not None and self.opts[\'fillLevel\'] is not None:\n            if self.fillPath is None:\n                if x is None:\n                    x,y = self.getData()\n                p2 = QtGui.QPainterPath(self.path)\n                p2.lineTo(x[-1], self.opts[\'fillLevel\'])\n                p2.lineTo(x[0], self.opts[\'fillLevel\'])\n                p2.lineTo(x[0], y[0])\n                p2.closeSubpath()\n                self.fillPath = p2\n                \n            profiler(\'generate fill path\')\n            p.fillPath(self.fillPath, self.opts[\'brush\'])\n            profiler(\'draw fill path\')\n            \n        sp = fn.mkPen(self.opts[\'shadowPen\'])\n        cp = fn.mkPen(self.opts[\'pen\'])\n \n        ## Copy pens and apply alpha adjustment\n        #sp = QtGui.QPen(self.opts[\'shadowPen\'])\n        #cp = QtGui.QPen(self.opts[\'pen\'])\n        #for pen in [sp, cp]:\n            #if pen is None:\n                #continue\n            #c = pen.color()\n            #c.setAlpha(c.alpha() * self.opts[\'alphaHint\'])\n            #pen.setColor(c)\n            ##pen.setCosmetic(True)\n            \n            \n            \n        if sp is not None and sp.style() != QtCore.Qt.NoPen:\n            p.setPen(sp)\n            p.drawPath(path)\n        p.setPen(cp)\n        p.drawPath(path)\n        profiler(\'drawPath\')\n        \n        #print ""Render hints:"", int(p.renderHints())\n        #p.setPen(QtGui.QPen(QtGui.QColor(255,0,0)))\n        #p.drawRect(self.boundingRect())\n        \n    def paintGL(self, p, opt, widget):\n        p.beginNativePainting()\n        import OpenGL.GL as gl\n        \n        ## set clipping viewport\n        view = self.getViewBox()\n        if view is not None:\n            rect = view.mapRectToItem(self, view.boundingRect())\n            #gl.glViewport(int(rect.x()), int(rect.y()), int(rect.width()), int(rect.height()))\n            \n            #gl.glTranslate(-rect.x(), -rect.y(), 0)\n            \n            gl.glEnable(gl.GL_STENCIL_TEST)\n            gl.glColorMask(gl.GL_FALSE, gl.GL_FALSE, gl.GL_FALSE, gl.GL_FALSE) # disable drawing to frame buffer\n            gl.glDepthMask(gl.GL_FALSE)  # disable drawing to depth buffer\n            gl.glStencilFunc(gl.GL_NEVER, 1, 0xFF)  \n            gl.glStencilOp(gl.GL_REPLACE, gl.GL_KEEP, gl.GL_KEEP)  \n            \n            ## draw stencil pattern\n            gl.glStencilMask(0xFF)\n            gl.glClear(gl.GL_STENCIL_BUFFER_BIT)\n            gl.glBegin(gl.GL_TRIANGLES)\n            gl.glVertex2f(rect.x(), rect.y())\n            gl.glVertex2f(rect.x()+rect.width(), rect.y())\n            gl.glVertex2f(rect.x(), rect.y()+rect.height())\n            gl.glVertex2f(rect.x()+rect.width(), rect.y()+rect.height())\n            gl.glVertex2f(rect.x()+rect.width(), rect.y())\n            gl.glVertex2f(rect.x(), rect.y()+rect.height())\n            gl.glEnd()\n                       \n            gl.glColorMask(gl.GL_TRUE, gl.GL_TRUE, gl.GL_TRUE, gl.GL_TRUE)\n            gl.glDepthMask(gl.GL_TRUE)\n            gl.glStencilMask(0x00)\n            gl.glStencilFunc(gl.GL_EQUAL, 1, 0xFF)\n            \n        try:\n            x, y = self.getData()\n            pos = np.empty((len(x), 2))\n            pos[:,0] = x\n            pos[:,1] = y\n            gl.glEnableClientState(gl.GL_VERTEX_ARRAY)\n            try:\n                gl.glVertexPointerf(pos)\n                pen = fn.mkPen(self.opts[\'pen\'])\n                color = pen.color()\n                gl.glColor4f(color.red()/255., color.green()/255., color.blue()/255., color.alpha()/255.)\n                width = pen.width()\n                if pen.isCosmetic() and width < 1:\n                    width = 1\n                gl.glPointSize(width)\n                gl.glEnable(gl.GL_LINE_SMOOTH)\n                gl.glEnable(gl.GL_BLEND)\n                gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n                gl.glHint(gl.GL_LINE_SMOOTH_HINT, gl.GL_NICEST)\n                gl.glDrawArrays(gl.GL_LINE_STRIP, 0, pos.size / pos.shape[-1])\n            finally:\n                gl.glDisableClientState(gl.GL_VERTEX_ARRAY)\n        finally:\n            p.endNativePainting()\n        \n    def clear(self):\n        self.xData = None  ## raw values\n        self.yData = None\n        self.xDisp = None  ## display values (after log / fft)\n        self.yDisp = None\n        self.path = None\n        self.fillPath = None\n        self._mouseShape = None\n        self._mouseBounds = None\n        self._boundsCache = [None, None]\n        #del self.xData, self.yData, self.xDisp, self.yDisp, self.path\n\n    def mouseShape(self):\n        """"""\n        Return a QPainterPath representing the clickable shape of the curve\n        \n        """"""\n        if self._mouseShape is None:\n            view = self.getViewBox()\n            if view is None:\n                return QtGui.QPainterPath()\n            stroker = QtGui.QPainterPathStroker()\n            path = self.getPath()\n            path = self.mapToItem(view, path)\n            stroker.setWidth(self.opts[\'mouseWidth\'])\n            mousePath = stroker.createStroke(path)\n            self._mouseShape = self.mapFromItem(view, mousePath)\n        return self._mouseShape\n        \n    def mouseClickEvent(self, ev):\n        if not self.clickable or ev.button() != QtCore.Qt.LeftButton:\n            return\n        if self.mouseShape().contains(ev.pos()):\n            ev.accept()\n            self.sigClicked.emit(self)\n            \n\n\nclass ROIPlotItem(PlotCurveItem):\n    """"""Plot curve that monitors an ROI and image for changes to automatically replot.""""""\n    def __init__(self, roi, data, img, axes=(0,1), xVals=None, color=None):\n        self.roi = roi\n        self.roiData = data\n        self.roiImg = img\n        self.axes = axes\n        self.xVals = xVals\n        PlotCurveItem.__init__(self, self.getRoiData(), x=self.xVals, color=color)\n        #roi.connect(roi, QtCore.SIGNAL(\'regionChanged\'), self.roiChangedEvent)\n        roi.sigRegionChanged.connect(self.roiChangedEvent)\n        #self.roiChangedEvent()\n        \n    def getRoiData(self):\n        d = self.roi.getArrayRegion(self.roiData, self.roiImg, axes=self.axes)\n        if d is None:\n            return\n        while d.ndim > 1:\n            d = d.mean(axis=1)\n        return d\n        \n    def roiChangedEvent(self):\n        d = self.getRoiData()\n        self.updateData(d, self.xVals)\n\n'"
src/third_party/pyqtgraph/graphicsItems/PlotDataItem.py,41,"b'import numpy as np\nfrom .. import metaarray as metaarray\nfrom ..Qt import QtCore\nfrom .GraphicsObject import GraphicsObject\nfrom .PlotCurveItem import PlotCurveItem\nfrom .ScatterPlotItem import ScatterPlotItem\nfrom .. import functions as fn\nfrom .. import debug as debug\nfrom .. import getConfigOption\n\n\nclass PlotDataItem(GraphicsObject):\n    """"""\n    **Bases:** :class:`GraphicsObject <pyqtgraph.GraphicsObject>`\n    \n    GraphicsItem for displaying plot curves, scatter plots, or both. \n    While it is possible to use :class:`PlotCurveItem <pyqtgraph.PlotCurveItem>` or\n    :class:`ScatterPlotItem <pyqtgraph.ScatterPlotItem>` individually, this class\n    provides a unified interface to both. Instances of :class:`PlotDataItem` are \n    usually created by plot() methods such as :func:`pyqtgraph.plot` and\n    :func:`PlotItem.plot() <pyqtgraph.PlotItem.plot>`.\n    \n    ============================== ==============================================\n    **Signals:**\n    sigPlotChanged(self)           Emitted when the data in this item is updated.  \n    sigClicked(self)               Emitted when the item is clicked.\n    sigPointsClicked(self, points) Emitted when a plot point is clicked\n                                   Sends the list of points under the mouse.\n    ============================== ==============================================\n    """"""\n    \n    sigPlotChanged = QtCore.Signal(object)\n    sigClicked = QtCore.Signal(object)\n    sigPointsClicked = QtCore.Signal(object, object)\n    \n    def __init__(self, *args, **kargs):\n        """"""\n        There are many different ways to create a PlotDataItem:\n        \n        **Data initialization arguments:** (x,y data only)\n        \n            =================================== ======================================\n            PlotDataItem(xValues, yValues)      x and y values may be any sequence (including ndarray) of real numbers\n            PlotDataItem(yValues)               y values only -- x will be automatically set to range(len(y))\n            PlotDataItem(x=xValues, y=yValues)  x and y given by keyword arguments\n            PlotDataItem(ndarray(Nx2))          numpy array with shape (N, 2) where x=data[:,0] and y=data[:,1]\n            =================================== ======================================\n        \n        **Data initialization arguments:** (x,y data AND may include spot style)\n        \n            ===========================   =========================================\n            PlotDataItem(recarray)        numpy array with dtype=[(\'x\', float), (\'y\', float), ...]\n            PlotDataItem(list-of-dicts)   [{\'x\': x, \'y\': y, ...},   ...] \n            PlotDataItem(dict-of-lists)   {\'x\': [...], \'y\': [...],  ...}           \n            PlotDataItem(MetaArray)       1D array of Y values with X sepecified as axis values \n                                          OR 2D array with a column \'y\' and extra columns as needed.\n            ===========================   =========================================\n        \n        **Line style keyword arguments:**\n\n            ==========   ==============================================================================\n            connect      Specifies how / whether vertexes should be connected. See\n                         :func:`arrayToQPath() <pyqtgraph.arrayToQPath>`\n            pen          Pen to use for drawing line between points.\n                         Default is solid grey, 1px width. Use None to disable line drawing.\n                         May be any single argument accepted by :func:`mkPen() <pyqtgraph.mkPen>`\n            shadowPen    Pen for secondary line to draw behind the primary line. disabled by default.\n                         May be any single argument accepted by :func:`mkPen() <pyqtgraph.mkPen>`\n            fillLevel    Fill the area between the curve and fillLevel\n            fillBrush    Fill to use when fillLevel is specified. \n                         May be any single argument accepted by :func:`mkBrush() <pyqtgraph.mkBrush>`\n            stepMode     If True, two orthogonal lines are drawn for each sample\n                         as steps. This is commonly used when drawing histograms.\n                         Note that in this case, `len(x) == len(y) + 1`\n                         (added in version 0.9.9)\n            ==========   ==============================================================================\n        \n        **Point style keyword arguments:**  (see :func:`ScatterPlotItem.setData() <pyqtgraph.ScatterPlotItem.setData>` for more information)\n        \n            ============   =====================================================\n            symbol         Symbol to use for drawing points OR list of symbols, \n                           one per point. Default is no symbol.\n                           Options are o, s, t, d, +, or any QPainterPath\n            symbolPen      Outline pen for drawing points OR list of pens, one \n                           per point. May be any single argument accepted by \n                           :func:`mkPen() <pyqtgraph.mkPen>`\n            symbolBrush    Brush for filling points OR list of brushes, one per \n                           point. May be any single argument accepted by \n                           :func:`mkBrush() <pyqtgraph.mkBrush>`\n            symbolSize     Diameter of symbols OR list of diameters.\n            pxMode         (bool) If True, then symbolSize is specified in \n                           pixels. If False, then symbolSize is \n                           specified in data coordinates.\n            ============   =====================================================\n        \n        **Optimization keyword arguments:**\n        \n            ================ =====================================================================\n            antialias        (bool) By default, antialiasing is disabled to improve performance.\n                             Note that in some cases (in particluar, when pxMode=True), points \n                             will be rendered antialiased even if this is set to False.\n            decimate         deprecated.\n            downsample       (int) Reduce the number of samples displayed by this value\n            downsampleMethod \'subsample\': Downsample by taking the first of N samples. \n                             This method is fastest and least accurate.\n                             \'mean\': Downsample by taking the mean of N samples.\n                             \'peak\': Downsample by drawing a saw wave that follows the min \n                             and max of the original data. This method produces the best \n                             visual representation of the data but is slower.\n            autoDownsample   (bool) If True, resample the data before plotting to avoid plotting\n                             multiple line segments per pixel. This can improve performance when\n                             viewing very high-density data, but increases the initial overhead \n                             and memory usage.\n            clipToView       (bool) If True, only plot data that is visible within the X range of\n                             the containing ViewBox. This can improve performance when plotting\n                             very large data sets where only a fraction of the data is visible\n                             at any time.\n            identical        *deprecated*\n            ================ =====================================================================\n        \n        **Meta-info keyword arguments:**\n        \n            ==========   ================================================\n            name         name of dataset. This would appear in a legend\n            ==========   ================================================\n        """"""\n        GraphicsObject.__init__(self)\n        self.setFlag(self.ItemHasNoContents)\n        self.xData = None\n        self.yData = None\n        self.xDisp = None\n        self.yDisp = None\n        #self.dataMask = None\n        #self.curves = []\n        #self.scatters = []\n        self.curve = PlotCurveItem()\n        self.scatter = ScatterPlotItem()\n        self.curve.setParentItem(self)\n        self.scatter.setParentItem(self)\n        \n        self.curve.sigClicked.connect(self.curveClicked)\n        self.scatter.sigClicked.connect(self.scatterClicked)\n        \n        \n        #self.clear()\n        self.opts = {\n            \'connect\': \'all\',\n            \n            \'fftMode\': False,\n            \'logMode\': [False, False],\n            \'alphaHint\': 1.0,\n            \'alphaMode\': False,\n            \n            \'pen\': (200,200,200),\n            \'shadowPen\': None,\n            \'fillLevel\': None,\n            \'fillBrush\': None,\n            \'stepMode\': None, \n            \n            \'symbol\': None,\n            \'symbolSize\': 10,\n            \'symbolPen\': (200,200,200),\n            \'symbolBrush\': (50, 50, 150),\n            \'pxMode\': True,\n            \n            \'antialias\': getConfigOption(\'antialias\'),\n            \'pointMode\': None,\n            \n            \'downsample\': 1,\n            \'autoDownsample\': False,\n            \'downsampleMethod\': \'peak\',\n            \'autoDownsampleFactor\': 5.,  # draw ~5 samples per pixel\n            \'clipToView\': False,\n            \n            \'data\': None,\n        }\n        self.setData(*args, **kargs)\n    \n    def implements(self, interface=None):\n        ints = [\'plotData\']\n        if interface is None:\n            return ints\n        return interface in ints\n    \n    def name(self):\n        return self.opts.get(\'name\', None)\n    \n    def boundingRect(self):\n        return QtCore.QRectF()  ## let child items handle this\n\n    def setAlpha(self, alpha, auto):\n        if self.opts[\'alphaHint\'] == alpha and self.opts[\'alphaMode\'] == auto:\n            return\n        self.opts[\'alphaHint\'] = alpha\n        self.opts[\'alphaMode\'] = auto\n        self.setOpacity(alpha)\n        #self.update()\n        \n    def setFftMode(self, mode):\n        if self.opts[\'fftMode\'] == mode:\n            return\n        self.opts[\'fftMode\'] = mode\n        self.xDisp = self.yDisp = None\n        self.xClean = self.yClean = None\n        self.updateItems()\n        self.informViewBoundsChanged()\n    \n    def setLogMode(self, xMode, yMode):\n        if self.opts[\'logMode\'] == [xMode, yMode]:\n            return\n        self.opts[\'logMode\'] = [xMode, yMode]\n        self.xDisp = self.yDisp = None\n        self.xClean = self.yClean = None\n        self.updateItems()\n        self.informViewBoundsChanged()\n    \n    def setPointMode(self, mode):\n        if self.opts[\'pointMode\'] == mode:\n            return\n        self.opts[\'pointMode\'] = mode\n        self.update()\n        \n    def setPen(self, *args, **kargs):\n        """"""\n        | Sets the pen used to draw lines between points.\n        | *pen* can be a QPen or any argument accepted by :func:`pyqtgraph.mkPen() <pyqtgraph.mkPen>`\n        """"""\n        pen = fn.mkPen(*args, **kargs)\n        self.opts[\'pen\'] = pen\n        #self.curve.setPen(pen)\n        #for c in self.curves:\n            #c.setPen(pen)\n        #self.update()\n        self.updateItems()\n        \n    def setShadowPen(self, *args, **kargs):\n        """"""\n        | Sets the shadow pen used to draw lines between points (this is for enhancing contrast or \n          emphacizing data). \n        | This line is drawn behind the primary pen (see :func:`setPen() <pyqtgraph.PlotDataItem.setPen>`)\n          and should generally be assigned greater width than the primary pen.\n        | *pen* can be a QPen or any argument accepted by :func:`pyqtgraph.mkPen() <pyqtgraph.mkPen>`\n        """"""\n        pen = fn.mkPen(*args, **kargs)\n        self.opts[\'shadowPen\'] = pen\n        #for c in self.curves:\n            #c.setPen(pen)\n        #self.update()\n        self.updateItems()\n        \n    def setFillBrush(self, *args, **kargs):\n        brush = fn.mkBrush(*args, **kargs)\n        if self.opts[\'fillBrush\'] == brush:\n            return\n        self.opts[\'fillBrush\'] = brush\n        self.updateItems()\n        \n    def setBrush(self, *args, **kargs):\n        return self.setFillBrush(*args, **kargs)\n    \n    def setFillLevel(self, level):\n        if self.opts[\'fillLevel\'] == level:\n            return\n        self.opts[\'fillLevel\'] = level\n        self.updateItems()\n\n    def setSymbol(self, symbol):\n        if self.opts[\'symbol\'] == symbol:\n            return\n        self.opts[\'symbol\'] = symbol\n        #self.scatter.setSymbol(symbol)\n        self.updateItems()\n        \n    def setSymbolPen(self, *args, **kargs):\n        pen = fn.mkPen(*args, **kargs)\n        if self.opts[\'symbolPen\'] == pen:\n            return\n        self.opts[\'symbolPen\'] = pen\n        #self.scatter.setSymbolPen(pen)\n        self.updateItems()\n        \n    \n    \n    def setSymbolBrush(self, *args, **kargs):\n        brush = fn.mkBrush(*args, **kargs)\n        if self.opts[\'symbolBrush\'] == brush:\n            return\n        self.opts[\'symbolBrush\'] = brush\n        #self.scatter.setSymbolBrush(brush)\n        self.updateItems()\n    \n    \n    def setSymbolSize(self, size):\n        if self.opts[\'symbolSize\'] == size:\n            return\n        self.opts[\'symbolSize\'] = size\n        #self.scatter.setSymbolSize(symbolSize)\n        self.updateItems()\n\n    def setDownsampling(self, ds=None, auto=None, method=None):\n        """"""\n        Set the downsampling mode of this item. Downsampling reduces the number\n        of samples drawn to increase performance. \n        \n        ==============  =================================================================\n        **Arguments:**\n        ds              (int) Reduce visible plot samples by this factor. To disable,\n                        set ds=1.\n        auto            (bool) If True, automatically pick *ds* based on visible range\n        mode            \'subsample\': Downsample by taking the first of N samples.\n                        This method is fastest and least accurate.\n                        \'mean\': Downsample by taking the mean of N samples.\n                        \'peak\': Downsample by drawing a saw wave that follows the min\n                        and max of the original data. This method produces the best\n                        visual representation of the data but is slower.\n        ==============  =================================================================\n        """"""\n        changed = False\n        if ds is not None:\n            if self.opts[\'downsample\'] != ds:\n                changed = True\n                self.opts[\'downsample\'] = ds\n                \n        if auto is not None and self.opts[\'autoDownsample\'] != auto:\n            self.opts[\'autoDownsample\'] = auto\n            changed = True\n                \n        if method is not None:\n            if self.opts[\'downsampleMethod\'] != method:\n                changed = True\n                self.opts[\'downsampleMethod\'] = method\n        \n        if changed:\n            self.xDisp = self.yDisp = None\n            self.updateItems()\n        \n    def setClipToView(self, clip):\n        if self.opts[\'clipToView\'] == clip:\n            return\n        self.opts[\'clipToView\'] = clip\n        self.xDisp = self.yDisp = None\n        self.updateItems()\n        \n        \n    def setData(self, *args, **kargs):\n        """"""\n        Clear any data displayed by this item and display new data.\n        See :func:`__init__() <pyqtgraph.PlotDataItem.__init__>` for details; it accepts the same arguments.\n        """"""\n        #self.clear()\n        profiler = debug.Profiler()\n        y = None\n        x = None\n        if len(args) == 1:\n            data = args[0]\n            dt = dataType(data)\n            if dt == \'empty\':\n                pass\n            elif dt == \'listOfValues\':\n                y = np.array(data)\n            elif dt == \'Nx2array\':\n                x = data[:,0]\n                y = data[:,1]\n            elif dt == \'recarray\' or dt == \'dictOfLists\':\n                if \'x\' in data:\n                    x = np.array(data[\'x\'])\n                if \'y\' in data:\n                    y = np.array(data[\'y\'])\n            elif dt ==  \'listOfDicts\':\n                if \'x\' in data[0]:\n                    x = np.array([d.get(\'x\',None) for d in data])\n                if \'y\' in data[0]:\n                    y = np.array([d.get(\'y\',None) for d in data])\n                for k in [\'data\', \'symbolSize\', \'symbolPen\', \'symbolBrush\', \'symbolShape\']:\n                    if k in data:\n                        kargs[k] = [d.get(k, None) for d in data]\n            elif dt == \'MetaArray\':\n                y = data.view(np.ndarray)\n                x = data.xvals(0).view(np.ndarray)\n            else:\n                raise Exception(\'Invalid data type %s\' % type(data))\n            \n        elif len(args) == 2:\n            seq = (\'listOfValues\', \'MetaArray\', \'empty\')\n            dtyp = dataType(args[0]), dataType(args[1])\n            if dtyp[0] not in seq or dtyp[1] not in seq:\n                raise Exception(\'When passing two unnamed arguments, both must be a list or array of values. (got %s, %s)\' % (str(type(args[0])), str(type(args[1]))))\n            if not isinstance(args[0], np.ndarray):\n                #x = np.array(args[0])\n                if dtyp[0] == \'MetaArray\':\n                    x = args[0].asarray()\n                else:\n                    x = np.array(args[0])\n            else:\n                x = args[0].view(np.ndarray)\n            if not isinstance(args[1], np.ndarray):\n                #y = np.array(args[1])\n                if dtyp[1] == \'MetaArray\':\n                    y = args[1].asarray()\n                else:\n                    y = np.array(args[1])\n            else:\n                y = args[1].view(np.ndarray)\n            \n        if \'x\' in kargs:\n            x = kargs[\'x\']\n        if \'y\' in kargs:\n            y = kargs[\'y\']\n\n        profiler(\'interpret data\')\n        ## pull in all style arguments. \n        ## Use self.opts to fill in anything not present in kargs.\n        \n        if \'name\' in kargs:\n            self.opts[\'name\'] = kargs[\'name\']\n        if \'connect\' in kargs:\n            self.opts[\'connect\'] = kargs[\'connect\']\n\n        ## if symbol pen/brush are given with no symbol, then assume symbol is \'o\'\n        \n        if \'symbol\' not in kargs and (\'symbolPen\' in kargs or \'symbolBrush\' in kargs or \'symbolSize\' in kargs):\n            kargs[\'symbol\'] = \'o\'\n            \n        if \'brush\' in kargs:\n            kargs[\'fillBrush\'] = kargs[\'brush\']\n            \n        for k in list(self.opts.keys()):\n            if k in kargs:\n                self.opts[k] = kargs[k]\n                \n        #curveArgs = {}\n        #for k in [\'pen\', \'shadowPen\', \'fillLevel\', \'brush\']:\n            #if k in kargs:\n                #self.opts[k] = kargs[k]\n            #curveArgs[k] = self.opts[k]\n            \n        #scatterArgs = {}\n        #for k,v in [(\'symbolPen\',\'pen\'), (\'symbolBrush\',\'brush\'), (\'symbol\',\'symbol\')]:\n            #if k in kargs:\n                #self.opts[k] = kargs[k]\n            #scatterArgs[v] = self.opts[k]\n        \n\n        if y is None:\n            self.updateItems()\n            profiler(\'update items\')\n            return\n        if y is not None and x is None:\n            x = np.arange(len(y))\n        \n        if isinstance(x, list):\n            x = np.array(x)\n        if isinstance(y, list):\n            y = np.array(y)\n        \n        self.xData = x.view(np.ndarray)  ## one last check to make sure there are no MetaArrays getting by\n        self.yData = y.view(np.ndarray)\n        self.xClean = self.yClean = None\n        self.xDisp = None\n        self.yDisp = None\n        profiler(\'set data\')\n        \n        self.updateItems()\n        profiler(\'update items\')\n        \n        self.informViewBoundsChanged()\n        #view = self.getViewBox()\n        #if view is not None:\n            #view.itemBoundsChanged(self)  ## inform view so it can update its range if it wants\n        \n        self.sigPlotChanged.emit(self)\n        profiler(\'emit\')\n\n    def updateItems(self):\n        \n        curveArgs = {}\n        for k,v in [(\'pen\',\'pen\'), (\'shadowPen\',\'shadowPen\'), (\'fillLevel\',\'fillLevel\'), (\'fillBrush\', \'brush\'), (\'antialias\', \'antialias\'), (\'connect\', \'connect\'), (\'stepMode\', \'stepMode\')]:\n            curveArgs[v] = self.opts[k]\n        \n        scatterArgs = {}\n        for k,v in [(\'symbolPen\',\'pen\'), (\'symbolBrush\',\'brush\'), (\'symbol\',\'symbol\'), (\'symbolSize\', \'size\'), (\'data\', \'data\'), (\'pxMode\', \'pxMode\'), (\'antialias\', \'antialias\')]:\n            if k in self.opts:\n                scatterArgs[v] = self.opts[k]\n        \n        x,y = self.getData()\n        #scatterArgs[\'mask\'] = self.dataMask\n        \n        if curveArgs[\'pen\'] is not None or (curveArgs[\'brush\'] is not None and curveArgs[\'fillLevel\'] is not None):\n            self.curve.setData(x=x, y=y, **curveArgs)\n            self.curve.show()\n        else:\n            self.curve.hide()\n        \n        if scatterArgs[\'symbol\'] is not None:\n            \n            if self.opts.get(\'stepMode\', False) is True:\n                x = 0.5 * (x[:-1] + x[1:])                \n            self.scatter.setData(x=x, y=y, **scatterArgs)\n            self.scatter.show()\n        else:\n            self.scatter.hide()\n\n\n    def getData(self):\n        if self.xData is None:\n            return (None, None)\n        \n        if self.xDisp is None:\n            x = self.xData\n            y = self.yData\n            \n            if self.opts[\'fftMode\']:\n                x,y = self._fourierTransform(x, y)\n                # Ignore the first bin for fft data if we have a logx scale\n                if self.opts[\'logMode\'][0]:\n                    x=x[1:]\n                    y=y[1:]                \n            if self.opts[\'logMode\'][0]:\n                x = np.log10(x)\n            if self.opts[\'logMode\'][1]:\n                y = np.log10(y)\n                    \n            ds = self.opts[\'downsample\']\n            if not isinstance(ds, int):\n                ds = 1\n                \n            if self.opts[\'autoDownsample\']:\n                # this option presumes that x-values have uniform spacing\n                range = self.viewRect()\n                if range is not None and len(x) > 1:\n                    dx = float(x[-1]-x[0]) / (len(x)-1)\n                    if dx != 0.0:\n                        x0 = (range.left()-x[0]) / dx\n                        x1 = (range.right()-x[0]) / dx\n                        width = self.getViewBox().width()\n                        if width != 0.0:\n                            ds = int(max(1, int((x1-x0) / (width*self.opts[\'autoDownsampleFactor\']))))\n                        ## downsampling is expensive; delay until after clipping.\n            \n            if self.opts[\'clipToView\']:\n                view = self.getViewBox()\n                if view is None or not view.autoRangeEnabled()[0]:\n                    # this option presumes that x-values have uniform spacing\n                    range = self.viewRect()\n                    if range is not None and len(x) > 1:\n                        dx = float(x[-1]-x[0]) / (len(x)-1)\n                        # clip to visible region extended by downsampling value\n                        x0 = np.clip(int((range.left()-x[0])/dx)-1*ds , 0, len(x)-1)\n                        x1 = np.clip(int((range.right()-x[0])/dx)+2*ds , 0, len(x)-1)\n                        x = x[x0:x1]\n                        y = y[x0:x1]\n                    \n            if ds > 1:\n                if self.opts[\'downsampleMethod\'] == \'subsample\':\n                    x = x[::ds]\n                    y = y[::ds]\n                elif self.opts[\'downsampleMethod\'] == \'mean\':\n                    n = len(x) // ds\n                    x = x[:n*ds:ds]\n                    y = y[:n*ds].reshape(n,ds).mean(axis=1)\n                elif self.opts[\'downsampleMethod\'] == \'peak\':\n                    n = len(x) // ds\n                    x1 = np.empty((n,2))\n                    x1[:] = x[:n*ds:ds,np.newaxis]\n                    x = x1.reshape(n*2)\n                    y1 = np.empty((n,2))\n                    y2 = y[:n*ds].reshape((n, ds))\n                    y1[:,0] = y2.max(axis=1)\n                    y1[:,1] = y2.min(axis=1)\n                    y = y1.reshape(n*2)\n                \n                    \n            self.xDisp = x\n            self.yDisp = y\n        return self.xDisp, self.yDisp\n\n    def dataBounds(self, ax, frac=1.0, orthoRange=None):\n        """"""\n        Returns the range occupied by the data (along a specific axis) in this item.\n        This method is called by ViewBox when auto-scaling.\n\n        =============== =============================================================\n        **Arguments:**\n        ax              (0 or 1) the axis for which to return this item\'s data range\n        frac            (float 0.0-1.0) Specifies what fraction of the total data \n                        range to return. By default, the entire range is returned.\n                        This allows the ViewBox to ignore large spikes in the data\n                        when auto-scaling.\n        orthoRange      ([min,max] or None) Specifies that only the data within the\n                        given range (orthogonal to *ax*) should me measured when \n                        returning the data range. (For example, a ViewBox might ask\n                        what is the y-range of all data with x-values between min\n                        and max)\n        =============== =============================================================\n        """"""\n        \n        range = [None, None]\n        if self.curve.isVisible():\n            range = self.curve.dataBounds(ax, frac, orthoRange)\n        elif self.scatter.isVisible():\n            r2 = self.scatter.dataBounds(ax, frac, orthoRange)\n            range = [\n                r2[0] if range[0] is None else (range[0] if r2[0] is None else min(r2[0], range[0])),\n                r2[1] if range[1] is None else (range[1] if r2[1] is None else min(r2[1], range[1]))\n                ]\n        return range\n    \n    def pixelPadding(self):\n        """"""\n        Return the size in pixels that this item may draw beyond the values returned by dataBounds().\n        This method is called by ViewBox when auto-scaling.\n        """"""\n        pad = 0\n        if self.curve.isVisible():\n            pad = max(pad, self.curve.pixelPadding())\n        elif self.scatter.isVisible():\n            pad = max(pad, self.scatter.pixelPadding())\n        return pad\n        \n\n    def clear(self):\n        #for i in self.curves+self.scatters:\n            #if i.scene() is not None:\n                #i.scene().removeItem(i)\n        #self.curves = []\n        #self.scatters = []\n        self.xData = None\n        self.yData = None\n        #self.xClean = None\n        #self.yClean = None\n        self.xDisp = None\n        self.yDisp = None\n        self.curve.setData([])\n        self.scatter.setData([])\n            \n    def appendData(self, *args, **kargs):\n        pass\n    \n    def curveClicked(self):\n        self.sigClicked.emit(self)\n        \n    def scatterClicked(self, plt, points):\n        self.sigClicked.emit(self)\n        self.sigPointsClicked.emit(self, points)\n    \n    def viewRangeChanged(self):\n        # view range has changed; re-plot if needed\n        if self.opts[\'clipToView\'] or self.opts[\'autoDownsample\']:\n            self.xDisp = self.yDisp = None\n            self.updateItems()\n            \n    def _fourierTransform(self, x, y):\n        ## Perform fourier transform. If x values are not sampled uniformly,\n        ## then use np.interp to resample before taking fft.\n        dx = np.diff(x)\n        uniform = not np.any(np.abs(dx-dx[0]) > (abs(dx[0]) / 1000.))\n        if not uniform:\n            x2 = np.linspace(x[0], x[-1], len(x))\n            y = np.interp(x2, x, y)\n            x = x2\n        n = y.size\n        f = np.fft.rfft(y) / n\n        d = float(x[-1]-x[0]) / (len(x)-1)\n        x = np.fft.rfftfreq(n, d)\n        y = np.abs(f)\n        return x, y\n    \ndef dataType(obj):\n    if hasattr(obj, \'__len__\') and len(obj) == 0:\n        return \'empty\'\n    if isinstance(obj, dict):\n        return \'dictOfLists\'\n    elif isSequence(obj):\n        first = obj[0]\n        \n        if (hasattr(obj, \'implements\') and obj.implements(\'MetaArray\')):\n            return \'MetaArray\'\n        elif isinstance(obj, np.ndarray):\n            if obj.ndim == 1:\n                if obj.dtype.names is None:\n                    return \'listOfValues\'\n                else:\n                    return \'recarray\'\n            elif obj.ndim == 2 and obj.dtype.names is None and obj.shape[1] == 2:\n                return \'Nx2array\'\n            else:\n                raise Exception(\'array shape must be (N,) or (N,2); got %s instead\' % str(obj.shape))\n        elif isinstance(first, dict):\n            return \'listOfDicts\'\n        else:\n            return \'listOfValues\'\n        \n        \ndef isSequence(obj):\n    return hasattr(obj, \'__iter__\') or isinstance(obj, np.ndarray) or (hasattr(obj, \'implements\') and obj.implements(\'MetaArray\'))\n    \n            \n            \n#class TableData:\n    #""""""\n    #Class for presenting multiple forms of tabular data through a consistent interface.\n    #May contain:\n        #- numpy record array\n        #- list-of-dicts (all dicts are _not_ required to have the same keys)\n        #- dict-of-lists\n        #- dict (single record)\n               #Note: if all the values in this record are lists, it will be interpreted as multiple records\n        \n    #Data can be accessed and modified by column, by row, or by value\n        #data[columnName]\n        #data[rowId]\n        #data[columnName, rowId] = value\n        #data[columnName] = [value, value, ...]\n        #data[rowId] = {columnName: value, ...}\n    #""""""\n    \n    #def __init__(self, data):\n        #self.data = data\n        #if isinstance(data, np.ndarray):\n            #self.mode = \'array\'\n        #elif isinstance(data, list):\n            #self.mode = \'list\'\n        #elif isinstance(data, dict):\n            #types = set(map(type, data.values()))\n            ### dict may be a dict-of-lists or a single record\n            #types -= set([list, np.ndarray]) ## if dict contains any non-sequence values, it is probably a single record.\n            #if len(types) != 0:\n                #self.data = [self.data]\n                #self.mode = \'list\'\n            #else:\n                #self.mode = \'dict\'\n        #elif isinstance(data, TableData):\n            #self.data = data.data\n            #self.mode = data.mode\n        #else:\n            #raise TypeError(type(data))\n        \n        #for fn in [\'__getitem__\', \'__setitem__\']:\n            #setattr(self, fn, getattr(self, \'_TableData\'+fn+self.mode))\n        \n    #def originalData(self):\n        #return self.data\n    \n    #def toArray(self):\n        #if self.mode == \'array\':\n            #return self.data\n        #if len(self) < 1:\n            ##return np.array([])  ## need to return empty array *with correct columns*, but this is very difficult, so just return None\n            #return None\n        #rec1 = self[0]\n        #dtype = functions.suggestRecordDType(rec1)\n        ##print rec1, dtype\n        #arr = np.empty(len(self), dtype=dtype)\n        #arr[0] = tuple(rec1.values())\n        #for i in xrange(1, len(self)):\n            #arr[i] = tuple(self[i].values())\n        #return arr\n            \n    #def __getitem__array(self, arg):\n        #if isinstance(arg, tuple):\n            #return self.data[arg[0]][arg[1]]\n        #else:\n            #return self.data[arg]\n            \n    #def __getitem__list(self, arg):\n        #if isinstance(arg, basestring):\n            #return [d.get(arg, None) for d in self.data]\n        #elif isinstance(arg, int):\n            #return self.data[arg]\n        #elif isinstance(arg, tuple):\n            #arg = self._orderArgs(arg)\n            #return self.data[arg[0]][arg[1]]\n        #else:\n            #raise TypeError(type(arg))\n        \n    #def __getitem__dict(self, arg):\n        #if isinstance(arg, basestring):\n            #return self.data[arg]\n        #elif isinstance(arg, int):\n            #return dict([(k, v[arg]) for k, v in self.data.items()])\n        #elif isinstance(arg, tuple):\n            #arg = self._orderArgs(arg)\n            #return self.data[arg[1]][arg[0]]\n        #else:\n            #raise TypeError(type(arg))\n\n    #def __setitem__array(self, arg, val):\n        #if isinstance(arg, tuple):\n            #self.data[arg[0]][arg[1]] = val\n        #else:\n            #self.data[arg] = val\n\n    #def __setitem__list(self, arg, val):\n        #if isinstance(arg, basestring):\n            #if len(val) != len(self.data):\n                #raise Exception(""Values (%d) and data set (%d) are not the same length."" % (len(val), len(self.data)))\n            #for i, rec in enumerate(self.data):\n                #rec[arg] = val[i]\n        #elif isinstance(arg, int):\n            #self.data[arg] = val\n        #elif isinstance(arg, tuple):\n            #arg = self._orderArgs(arg)\n            #self.data[arg[0]][arg[1]] = val\n        #else:\n            #raise TypeError(type(arg))\n        \n    #def __setitem__dict(self, arg, val):\n        #if isinstance(arg, basestring):\n            #if len(val) != len(self.data[arg]):\n                #raise Exception(""Values (%d) and data set (%d) are not the same length."" % (len(val), len(self.data[arg])))\n            #self.data[arg] = val\n        #elif isinstance(arg, int):\n            #for k in self.data:\n                #self.data[k][arg] = val[k]\n        #elif isinstance(arg, tuple):\n            #arg = self._orderArgs(arg)\n            #self.data[arg[1]][arg[0]] = val\n        #else:\n            #raise TypeError(type(arg))\n\n    #def _orderArgs(self, args):\n        ### return args in (int, str) order\n        #if isinstance(args[0], basestring):\n            #return (args[1], args[0])\n        #else:\n            #return args\n        \n    #def __iter__(self):\n        #for i in xrange(len(self)):\n            #yield self[i]\n\n    #def __len__(self):\n        #if self.mode == \'array\' or self.mode == \'list\':\n            #return len(self.data)\n        #else:\n            #return max(map(len, self.data.values()))\n\n    #def columnNames(self):\n        #""""""returns column names in no particular order""""""\n        #if self.mode == \'array\':\n            #return self.data.dtype.names\n        #elif self.mode == \'list\':\n            #names = set()\n            #for row in self.data:\n                #names.update(row.keys())\n            #return list(names)\n        #elif self.mode == \'dict\':\n            #return self.data.keys()\n            \n    #def keys(self):\n        #return self.columnNames()\n'"
src/third_party/pyqtgraph/graphicsItems/ROI.py,14,"b'# -*- coding: utf-8 -*-\n""""""\nROI.py -  Interactive graphics items for GraphicsView (ROI widgets)\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n\nImplements a series of graphics items which display movable/scalable/rotatable shapes\nfor use as region-of-interest markers. ROI class automatically handles extraction \nof array data from ImageItems.\n\nThe ROI class is meant to serve as the base for more specific types; see several examples\nof how to build an ROI at the bottom of the file.\n""""""\n\nfrom ..Qt import QtCore, QtGui\nimport numpy as np\n#from numpy.linalg import norm\nfrom ..Point import *\nfrom ..SRTTransform import SRTTransform\nfrom math import cos, sin\nfrom .. import functions as fn\nfrom .GraphicsObject import GraphicsObject\nfrom .UIGraphicsItem import UIGraphicsItem\nfrom .. import getConfigOption\n\n__all__ = [\n    \'ROI\', \n    \'TestROI\', \'RectROI\', \'EllipseROI\', \'CircleROI\', \'PolygonROI\', \n    \'LineROI\', \'MultiLineROI\', \'MultiRectROI\', \'LineSegmentROI\', \'PolyLineROI\', \n    \'CrosshairROI\',\n]\n\n\ndef rectStr(r):\n    return ""[%f, %f] + [%f, %f]"" % (r.x(), r.y(), r.width(), r.height())\n\nclass ROI(GraphicsObject):\n    """"""\n    Generic region-of-interest widget.\n    \n    Can be used for implementing many types of selection box with \n    rotate/translate/scale handles.\n    ROIs can be customized to have a variety of shapes (by subclassing or using\n    any of the built-in subclasses) and any combination of draggable handles\n    that allow the user to manipulate the ROI.\n\n    Default mouse interaction:\n\n    * Left drag moves the ROI\n    * Left drag + Ctrl moves the ROI with position snapping\n    * Left drag + Alt rotates the ROI\n    * Left drag + Alt + Ctrl rotates the ROI with angle snapping\n    * Left drag + Shift scales the ROI\n    * Left drag + Shift + Ctrl scales the ROI with size snapping\n\n    In addition to the above interaction modes, it is possible to attach any\n    number of handles to the ROI that can be dragged to change the ROI in\n    various ways (see the ROI.add____Handle methods).\n\n\n    ================ ===========================================================\n    **Arguments**\n    pos              (length-2 sequence) Indicates the position of the ROI\'s \n                     origin. For most ROIs, this is the lower-left corner of\n                     its bounding rectangle.\n    size             (length-2 sequence) Indicates the width and height of the \n                     ROI.\n    angle            (float) The rotation of the ROI in degrees. Default is 0.\n    invertible       (bool) If True, the user may resize the ROI to have \n                     negative width or height (assuming the ROI has scale\n                     handles). Default is False.\n    maxBounds        (QRect, QRectF, or None) Specifies boundaries that the ROI \n                     cannot be dragged outside of by the user. Default is None.\n    snapSize         (float) The spacing of snap positions used when *scaleSnap*\n                     or *translateSnap* are enabled. Default is 1.0.\n    scaleSnap        (bool) If True, the width and height of the ROI are forced\n                     to be integer multiples of *snapSize* when being resized\n                     by the user. Default is False.\n    translateSnap    (bool) If True, the x and y positions of the ROI are forced\n                     to be integer multiples of *snapSize* when being resized\n                     by the user. Default is False.\n    rotateSnap       (bool) If True, the ROI angle is forced to a multiple of \n                     the ROI\'s snap angle (default is 15 degrees) when rotated\n                     by the user. Default is False.\n    parent           (QGraphicsItem) The graphics item parent of this ROI. It\n                     is generally not necessary to specify the parent.\n    pen              (QPen or argument to pg.mkPen) The pen to use when drawing\n                     the shape of the ROI.\n    movable          (bool) If True, the ROI can be moved by dragging anywhere \n                     inside the ROI. Default is True.\n    rotatable        (bool) If True, the ROI can be rotated by mouse drag + ALT\n    resizable        (bool) If True, the ROI can be resized by mouse drag + \n                     SHIFT\n    removable        (bool) If True, the ROI will be given a context menu with\n                     an option to remove the ROI. The ROI emits\n                     sigRemoveRequested when this menu action is selected.\n                     Default is False.\n    ================ ===========================================================\n    \n    \n    \n    ======================= ====================================================\n    **Signals**\n    sigRegionChangeFinished Emitted when the user stops dragging the ROI (or\n                            one of its handles) or if the ROI is changed\n                            programatically.\n    sigRegionChangeStarted  Emitted when the user starts dragging the ROI (or\n                            one of its handles).\n    sigRegionChanged        Emitted any time the position of the ROI changes,\n                            including while it is being dragged by the user.\n    sigHoverEvent           Emitted when the mouse hovers over the ROI.\n    sigClicked              Emitted when the user clicks on the ROI.\n                            Note that clicking is disabled by default to prevent\n                            stealing clicks from objects behind the ROI. To \n                            enable clicking, call \n                            roi.setAcceptedMouseButtons(QtCore.Qt.LeftButton). \n                            See QtGui.QGraphicsItem documentation for more \n                            details.\n    sigRemoveRequested      Emitted when the user selects \'remove\' from the \n                            ROI\'s context menu (if available).\n    ======================= ====================================================\n    """"""\n    \n    sigRegionChangeFinished = QtCore.Signal(object)\n    sigRegionChangeStarted = QtCore.Signal(object)\n    sigRegionChanged = QtCore.Signal(object)\n    sigHoverEvent = QtCore.Signal(object)\n    sigClicked = QtCore.Signal(object, object)\n    sigRemoveRequested = QtCore.Signal(object)\n    \n    def __init__(self, pos, size=Point(1, 1), angle=0.0, invertible=False, maxBounds=None, \n                 snapSize=1.0, scaleSnap=False, translateSnap=False, rotateSnap=False, \n                 parent=None, pen=None, movable=True, rotatable=True, resizable=True, \n                 removable=False):\n        GraphicsObject.__init__(self, parent)\n        self.setAcceptedMouseButtons(QtCore.Qt.NoButton)\n        pos = Point(pos)\n        size = Point(size)\n        self.aspectLocked = False\n        self.translatable = movable\n        self.rotatable = rotatable\n        self.resizable = resizable\n        self.removable = removable\n        self.menu = None\n        \n        self.freeHandleMoved = False ## keep track of whether free handles have moved since last change signal was emitted.\n        self.mouseHovering = False\n        if pen is None:\n            pen = (255, 255, 255)\n        self.setPen(pen)\n        \n        self.handlePen = QtGui.QPen(QtGui.QColor(150, 255, 255))\n        self.handles = []\n        self.state = {\'pos\': Point(0,0), \'size\': Point(1,1), \'angle\': 0}  ## angle is in degrees for ease of Qt integration\n        self.lastState = None\n        self.setPos(pos)\n        self.setAngle(angle)\n        self.setSize(size)\n        self.setZValue(10)\n        self.isMoving = False\n        \n        self.handleSize = 5\n        self.invertible = invertible\n        self.maxBounds = maxBounds\n        \n        self.snapSize = snapSize\n        self.translateSnap = translateSnap\n        self.rotateSnap = rotateSnap\n        self.rotateSnapAngle = 15.0\n        self.scaleSnap = scaleSnap\n        self.scaleSnapSize = snapSize\n\n        # Implement mouse handling in a separate class to allow easier customization\n        self.mouseDragHandler = MouseDragHandler(self)\n    \n    def getState(self):\n        return self.stateCopy()\n\n    def stateCopy(self):\n        sc = {}\n        sc[\'pos\'] = Point(self.state[\'pos\'])\n        sc[\'size\'] = Point(self.state[\'size\'])\n        sc[\'angle\'] = self.state[\'angle\']\n        return sc\n        \n    def saveState(self):\n        """"""Return the state of the widget in a format suitable for storing to \n        disk. (Points are converted to tuple)\n        \n        Combined with setState(), this allows ROIs to be easily saved and \n        restored.""""""\n        state = {}\n        state[\'pos\'] = tuple(self.state[\'pos\'])\n        state[\'size\'] = tuple(self.state[\'size\'])\n        state[\'angle\'] = self.state[\'angle\']\n        return state\n    \n    def setState(self, state, update=True):\n        """"""\n        Set the state of the ROI from a structure generated by saveState() or\n        getState().\n        """"""\n        self.setPos(state[\'pos\'], update=False)\n        self.setSize(state[\'size\'], update=False)\n        self.setAngle(state[\'angle\'], update=update)\n    \n    def setZValue(self, z):\n        QtGui.QGraphicsItem.setZValue(self, z)\n        for h in self.handles:\n            h[\'item\'].setZValue(z+1)\n        \n    def parentBounds(self):\n        """"""\n        Return the bounding rectangle of this ROI in the coordinate system\n        of its parent.        \n        """"""\n        return self.mapToParent(self.boundingRect()).boundingRect()\n\n    def setPen(self, *args, **kwargs):\n        """"""\n        Set the pen to use when drawing the ROI shape.\n        For arguments, see :func:`mkPen <pyqtgraph.mkPen>`.\n        """"""\n        self.pen = fn.mkPen(*args, **kwargs)\n        self.currentPen = self.pen\n        self.update()\n        \n    def size(self):\n        """"""Return the size (w,h) of the ROI.""""""\n        return self.getState()[\'size\']\n        \n    def pos(self):\n        """"""Return the position (x,y) of the ROI\'s origin. \n        For most ROIs, this will be the lower-left corner.""""""\n        return self.getState()[\'pos\']\n        \n    def angle(self):\n        """"""Return the angle of the ROI in degrees.""""""\n        return self.getState()[\'angle\']\n        \n    def setPos(self, pos, y=None, update=True, finish=True):\n        """"""Set the position of the ROI (in the parent\'s coordinate system).\n        \n        Accepts either separate (x, y) arguments or a single :class:`Point` or\n        ``QPointF`` argument. \n        \n        By default, this method causes both ``sigRegionChanged`` and\n        ``sigRegionChangeFinished`` to be emitted. If *finish* is False, then\n        ``sigRegionChangeFinished`` will not be emitted. You can then use \n        stateChangeFinished() to cause the signal to be emitted after a series\n        of state changes.\n        \n        If *update* is False, the state change will be remembered but not processed and no signals \n        will be emitted. You can then use stateChanged() to complete the state change. This allows\n        multiple change functions to be called sequentially while minimizing processing overhead\n        and repeated signals. Setting ``update=False`` also forces ``finish=False``.\n        """"""\n        if update not in (True, False):\n            raise TypeError(""update argument must be bool"")\n        \n        if y is None:\n            pos = Point(pos)\n        else:\n            # avoid ambiguity where update is provided as a positional argument\n            if isinstance(y, bool):\n                raise TypeError(""Positional arguments to setPos() must be numerical."")\n            pos = Point(pos, y)\n\n        self.state[\'pos\'] = pos\n        QtGui.QGraphicsItem.setPos(self, pos)\n        if update:\n            self.stateChanged(finish=finish)\n        \n    def setSize(self, size, center=None, centerLocal=None, snap=False, update=True, finish=True):\n        """"""\n        Set the ROI\'s size.\n        \n        =============== ==========================================================================\n        **Arguments**\n        size            (Point | QPointF | sequence) The final size of the ROI\n        center          (None | Point) Optional center point around which the ROI is scaled,\n                        expressed as [0-1, 0-1] over the size of the ROI.\n        centerLocal     (None | Point) Same as *center*, but the position is expressed in the\n                        local coordinate system of the ROI\n        snap            (bool) If True, the final size is snapped to the nearest increment (see\n                        ROI.scaleSnapSize)\n        update          (bool) See setPos()\n        finish          (bool) See setPos()\n        =============== ==========================================================================\n        """"""\n        if update not in (True, False):\n            raise TypeError(""update argument must be bool"")\n        size = Point(size)\n        if snap:\n            size[0] = round(size[0] / self.scaleSnapSize) * self.scaleSnapSize\n            size[1] = round(size[1] / self.scaleSnapSize) * self.scaleSnapSize\n\n        if centerLocal is not None:\n            oldSize = Point(self.state[\'size\'])\n            oldSize[0] = 1 if oldSize[0] == 0 else oldSize[0]\n            oldSize[1] = 1 if oldSize[1] == 0 else oldSize[1]\n            center = Point(centerLocal) / oldSize\n\n        if center is not None:\n            center = Point(center)\n            c = self.mapToParent(Point(center) * self.state[\'size\'])\n            c1 = self.mapToParent(Point(center) * size)\n            newPos = self.state[\'pos\'] + c - c1\n            self.setPos(newPos, update=False, finish=False)\n        \n        self.prepareGeometryChange()\n        self.state[\'size\'] = size\n        if update:\n            self.stateChanged(finish=finish)\n\n    def setAngle(self, angle, center=None, centerLocal=None, snap=False, update=True, finish=True):\n        """"""\n        Set the ROI\'s rotation angle.\n        \n        =============== ==========================================================================\n        **Arguments**\n        angle           (float) The final ROI angle in degrees\n        center          (None | Point) Optional center point around which the ROI is rotated,\n                        expressed as [0-1, 0-1] over the size of the ROI.\n        centerLocal     (None | Point) Same as *center*, but the position is expressed in the\n                        local coordinate system of the ROI\n        snap            (bool) If True, the final ROI angle is snapped to the nearest increment\n                        (default is 15 degrees; see ROI.rotateSnapAngle)\n        update          (bool) See setPos()\n        finish          (bool) See setPos()\n        =============== ==========================================================================\n        """"""\n        if update not in (True, False):\n            raise TypeError(""update argument must be bool"")\n\n        if snap is True:\n            angle = round(angle / self.rotateSnapAngle) * self.rotateSnapAngle\n        \n        self.state[\'angle\'] = angle\n        tr = QtGui.QTransform()  # note: only rotation is contained in the transform\n        tr.rotate(angle)\n        if center is not None:\n            centerLocal = Point(center) * self.state[\'size\']\n        if centerLocal is not None:\n            centerLocal = Point(centerLocal)\n            # rotate to new angle, keeping a specific point anchored as the center of rotation\n            cc = self.mapToParent(centerLocal) - (tr.map(centerLocal) + self.state[\'pos\'])\n            self.translate(cc, update=False)\n\n        self.setTransform(tr)\n        if update:\n            self.stateChanged(finish=finish)\n        \n    def scale(self, s, center=None, centerLocal=None, snap=False, update=True, finish=True):\n        """"""\n        Resize the ROI by scaling relative to *center*.\n        See setPos() for an explanation of the *update* and *finish* arguments.\n        """"""\n        newSize = self.state[\'size\'] * s\n        self.setSize(newSize, center=center, centerLocal=centerLocal, snap=snap, update=update, finish=finish)\n   \n    def translate(self, *args, **kargs):\n        """"""\n        Move the ROI to a new position.\n        Accepts either (x, y, snap) or ([x,y], snap) as arguments\n        If the ROI is bounded and the move would exceed boundaries, then the ROI\n        is moved to the nearest acceptable position instead.\n        \n        *snap* can be:\n        \n        =============== ==========================================================================\n        None (default)  use self.translateSnap and self.snapSize to determine whether/how to snap\n        False           do not snap\n        Point(w,h)      snap to rectangular grid with spacing (w,h)\n        True            snap using self.snapSize (and ignoring self.translateSnap)\n        =============== ==========================================================================\n           \n        Also accepts *update* and *finish* arguments (see setPos() for a description of these).\n        """"""\n\n        if len(args) == 1:\n            pt = args[0]\n        else:\n            pt = args\n            \n        newState = self.stateCopy()\n        newState[\'pos\'] = newState[\'pos\'] + pt\n        \n        snap = kargs.get(\'snap\', None)\n        if snap is None:\n            snap = self.translateSnap\n        if snap is not False:\n            newState[\'pos\'] = self.getSnapPosition(newState[\'pos\'], snap=snap)\n        \n        if self.maxBounds is not None:\n            r = self.stateRect(newState)\n            d = Point(0,0)\n            if self.maxBounds.left() > r.left():\n                d[0] = self.maxBounds.left() - r.left()\n            elif self.maxBounds.right() < r.right():\n                d[0] = self.maxBounds.right() - r.right()\n            if self.maxBounds.top() > r.top():\n                d[1] = self.maxBounds.top() - r.top()\n            elif self.maxBounds.bottom() < r.bottom():\n                d[1] = self.maxBounds.bottom() - r.bottom()\n            newState[\'pos\'] += d\n        \n        update = kargs.get(\'update\', True)\n        finish = kargs.get(\'finish\', True)\n        self.setPos(newState[\'pos\'], update=update, finish=finish)\n\n    def rotate(self, angle, center=None, snap=False, update=True, finish=True):\n        """"""\n        Rotate the ROI by *angle* degrees. \n        \n        =============== ==========================================================================\n        **Arguments**\n        angle           (float) The angle in degrees to rotate\n        center          (None | Point) Optional center point around which the ROI is rotated, in\n                        the local coordinate system of the ROI\n        snap            (bool) If True, the final ROI angle is snapped to the nearest increment\n                        (default is 15 degrees; see ROI.rotateSnapAngle)\n        update          (bool) See setPos()\n        finish          (bool) See setPos()\n        =============== ==========================================================================\n        """"""\n        self.setAngle(self.angle()+angle, center=center, snap=snap, update=update, finish=finish)\n\n    def handleMoveStarted(self):\n        self.preMoveState = self.getState()\n    \n    def addTranslateHandle(self, pos, axes=None, item=None, name=None, index=None):\n        """"""\n        Add a new translation handle to the ROI. Dragging the handle will move \n        the entire ROI without changing its angle or shape. \n        \n        Note that, by default, ROIs may be moved by dragging anywhere inside the\n        ROI. However, for larger ROIs it may be desirable to disable this and\n        instead provide one or more translation handles.\n        \n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle \n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are \n                            identified by name when calling \n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        return self.addHandle({\'name\': name, \'type\': \'t\', \'pos\': pos, \'item\': item}, index=index)\n    \n    def addFreeHandle(self, pos=None, axes=None, item=None, name=None, index=None):\n        """"""\n        Add a new free handle to the ROI. Dragging free handles has no effect\n        on the position or shape of the ROI. \n        \n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle \n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are \n                            identified by name when calling \n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        if pos is not None:\n            pos = Point(pos)\n        return self.addHandle({\'name\': name, \'type\': \'f\', \'pos\': pos, \'item\': item}, index=index)\n    \n    def addScaleHandle(self, pos, center, axes=None, item=None, name=None, lockAspect=False, index=None):\n        """"""\n        Add a new scale handle to the ROI. Dragging a scale handle allows the\n        user to change the height and/or width of the ROI.\n        \n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle \n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        center              (length-2 sequence) The center point around which \n                            scaling takes place. If the center point has the\n                            same x or y value as the handle position, then \n                            scaling will be disabled for that axis.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are \n                            identified by name when calling \n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        center = Point(center)\n        info = {\'name\': name, \'type\': \'s\', \'center\': center, \'pos\': pos, \'item\': item, \'lockAspect\': lockAspect}\n        if pos.x() == center.x():\n            info[\'xoff\'] = True\n        if pos.y() == center.y():\n            info[\'yoff\'] = True\n        return self.addHandle(info, index=index)\n    \n    def addRotateHandle(self, pos, center, item=None, name=None, index=None):\n        """"""\n        Add a new rotation handle to the ROI. Dragging a rotation handle allows \n        the user to change the angle of the ROI.\n        \n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle \n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        center              (length-2 sequence) The center point around which \n                            rotation takes place.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are \n                            identified by name when calling \n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        center = Point(center)\n        return self.addHandle({\'name\': name, \'type\': \'r\', \'center\': center, \'pos\': pos, \'item\': item}, index=index)\n    \n    def addScaleRotateHandle(self, pos, center, item=None, name=None, index=None):\n        """"""\n        Add a new scale+rotation handle to the ROI. When dragging a handle of \n        this type, the user can simultaneously rotate the ROI around an \n        arbitrary center point as well as scale the ROI by dragging the handle\n        toward or away from the center point.\n        \n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle \n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        center              (length-2 sequence) The center point around which \n                            scaling and rotation take place.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are \n                            identified by name when calling \n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        center = Point(center)\n        if pos[0] != center[0] and pos[1] != center[1]:\n            raise Exception(""Scale/rotate handles must have either the same x or y coordinate as their center point."")\n        return self.addHandle({\'name\': name, \'type\': \'sr\', \'center\': center, \'pos\': pos, \'item\': item}, index=index)\n    \n    def addRotateFreeHandle(self, pos, center, axes=None, item=None, name=None, index=None):\n        """"""\n        Add a new rotation+free handle to the ROI. When dragging a handle of \n        this type, the user can rotate the ROI around an \n        arbitrary center point, while moving toward or away from the center \n        point has no effect on the shape of the ROI.\n        \n        =================== ====================================================\n        **Arguments**\n        pos                 (length-2 sequence) The position of the handle \n                            relative to the shape of the ROI. A value of (0,0)\n                            indicates the origin, whereas (1, 1) indicates the\n                            upper-right corner, regardless of the ROI\'s size.\n        center              (length-2 sequence) The center point around which \n                            rotation takes place.\n        item                The Handle instance to add. If None, a new handle\n                            will be created.\n        name                The name of this handle (optional). Handles are \n                            identified by name when calling \n                            getLocalHandlePositions and getSceneHandlePositions.\n        =================== ====================================================\n        """"""\n        pos = Point(pos)\n        center = Point(center)\n        return self.addHandle({\'name\': name, \'type\': \'rf\', \'center\': center, \'pos\': pos, \'item\': item}, index=index)\n    \n    def addHandle(self, info, index=None):\n        ## If a Handle was not supplied, create it now\n        if \'item\' not in info or info[\'item\'] is None:\n            h = Handle(self.handleSize, typ=info[\'type\'], pen=self.handlePen, parent=self)\n            h.setPos(info[\'pos\'] * self.state[\'size\'])\n            info[\'item\'] = h\n        else:\n            h = info[\'item\']\n            if info[\'pos\'] is None:\n                info[\'pos\'] = h.pos()\n            \n        ## connect the handle to this ROI\n        #iid = len(self.handles)\n        h.connectROI(self)\n        if index is None:\n            self.handles.append(info)\n        else:\n            self.handles.insert(index, info)\n        \n        h.setZValue(self.zValue()+1)\n        self.stateChanged()\n        return h\n    \n    def indexOfHandle(self, handle):\n        """"""\n        Return the index of *handle* in the list of this ROI\'s handles.\n        """"""\n        if isinstance(handle, Handle):\n            index = [i for i, info in enumerate(self.handles) if info[\'item\'] is handle]    \n            if len(index) == 0:\n                raise Exception(""Cannot return handle index; not attached to this ROI"")\n            return index[0]\n        else:\n            return handle\n        \n    def removeHandle(self, handle):\n        """"""Remove a handle from this ROI. Argument may be either a Handle \n        instance or the integer index of the handle.""""""\n        index = self.indexOfHandle(handle)\n            \n        handle = self.handles[index][\'item\']\n        self.handles.pop(index)\n        handle.disconnectROI(self)\n        if len(handle.rois) == 0:\n            self.scene().removeItem(handle)\n        self.stateChanged()\n    \n    def replaceHandle(self, oldHandle, newHandle):\n        """"""Replace one handle in the ROI for another. This is useful when \n        connecting multiple ROIs together.\n        \n        *oldHandle* may be a Handle instance or the index of a handle to be\n        replaced.""""""\n        index = self.indexOfHandle(oldHandle)\n        info = self.handles[index]\n        self.removeHandle(index)\n        info[\'item\'] = newHandle\n        info[\'pos\'] = newHandle.pos()\n        self.addHandle(info, index=index)\n        \n    def checkRemoveHandle(self, handle):\n        ## This is used when displaying a Handle\'s context menu to determine\n        ## whether removing is allowed. \n        ## Subclasses may wish to override this to disable the menu entry.\n        ## Note: by default, handles are not user-removable even if this method returns True.\n        return True\n        \n    def getLocalHandlePositions(self, index=None):\n        """"""Returns the position of handles in the ROI\'s coordinate system.\n        \n        The format returned is a list of (name, pos) tuples.\n        """"""\n        if index == None:\n            positions = []\n            for h in self.handles:\n                positions.append((h[\'name\'], h[\'pos\']))\n            return positions\n        else:\n            return (self.handles[index][\'name\'], self.handles[index][\'pos\'])\n            \n    def getSceneHandlePositions(self, index=None):\n        """"""Returns the position of handles in the scene coordinate system.\n        \n        The format returned is a list of (name, pos) tuples.\n        """"""\n        if index == None:\n            positions = []\n            for h in self.handles:\n                positions.append((h[\'name\'], h[\'item\'].scenePos()))\n            return positions\n        else:\n            return (self.handles[index][\'name\'], self.handles[index][\'item\'].scenePos())\n        \n    def getHandles(self):\n        """"""\n        Return a list of this ROI\'s Handles.\n        """"""\n        return [h[\'item\'] for h in self.handles]\n    \n    def mapSceneToParent(self, pt):\n        return self.mapToParent(self.mapFromScene(pt))\n\n    def setSelected(self, s):\n        QtGui.QGraphicsItem.setSelected(self, s)\n        #print ""select"", self, s\n        if s:\n            for h in self.handles:\n                h[\'item\'].show()\n        else:\n            for h in self.handles:\n                h[\'item\'].hide()\n\n    def hoverEvent(self, ev):\n        hover = False\n        if not ev.isExit():\n            if self.translatable and ev.acceptDrags(QtCore.Qt.LeftButton):\n                hover=True\n                \n            for btn in [QtCore.Qt.LeftButton, QtCore.Qt.RightButton, QtCore.Qt.MidButton]:\n                if int(self.acceptedMouseButtons() & btn) > 0 and ev.acceptClicks(btn):\n                    hover=True\n            if self.contextMenuEnabled():\n                ev.acceptClicks(QtCore.Qt.RightButton)\n                \n        if hover:\n            self.setMouseHover(True)\n            self.sigHoverEvent.emit(self)\n            ev.acceptClicks(QtCore.Qt.LeftButton)  ## If the ROI is hilighted, we should accept all clicks to avoid confusion.\n            ev.acceptClicks(QtCore.Qt.RightButton)\n            ev.acceptClicks(QtCore.Qt.MidButton)\n        else:\n            self.setMouseHover(False)\n\n    def setMouseHover(self, hover):\n        ## Inform the ROI that the mouse is(not) hovering over it\n        if self.mouseHovering == hover:\n            return\n        self.mouseHovering = hover\n        self._updateHoverColor()\n        \n    def _updateHoverColor(self):\n        pen = self._makePen()\n        if self.currentPen != pen:\n            self.currentPen = pen\n            self.update()\n        \n    def _makePen(self):\n        # Generate the pen color for this ROI based on its current state.\n        if self.mouseHovering:\n            return fn.mkPen(255, 255, 0)\n        else:\n            return self.pen\n\n    def contextMenuEnabled(self):\n        return self.removable\n    \n    def raiseContextMenu(self, ev):\n        if not self.contextMenuEnabled():\n            return\n        menu = self.getMenu()\n        menu = self.scene().addParentContextMenus(self, menu, ev)\n        pos = ev.screenPos()\n        menu.popup(QtCore.QPoint(pos.x(), pos.y()))\n\n    def getMenu(self):\n        if self.menu is None:\n            self.menu = QtGui.QMenu()\n            self.menu.setTitle(""ROI"")\n            remAct = QtGui.QAction(""Remove ROI"", self.menu)\n            remAct.triggered.connect(self.removeClicked)\n            self.menu.addAction(remAct)\n            self.menu.remAct = remAct\n        return self.menu\n\n    def removeClicked(self):\n        ## Send remove event only after we have exited the menu event handler\n        QtCore.QTimer.singleShot(0, lambda: self.sigRemoveRequested.emit(self))\n        \n    def mouseDragEvent(self, ev):\n        self.mouseDragHandler.mouseDragEvent(ev)\n\n    def mouseClickEvent(self, ev):\n        if ev.button() == QtCore.Qt.RightButton and self.isMoving:\n            ev.accept()\n            self.cancelMove()\n        if ev.button() == QtCore.Qt.RightButton and self.contextMenuEnabled():\n            self.raiseContextMenu(ev)\n            ev.accept()\n        elif int(ev.button() & self.acceptedMouseButtons()) > 0:\n            ev.accept()\n            self.sigClicked.emit(self, ev)\n        else:\n            ev.ignore()\n\n    def _moveStarted(self):\n        self.isMoving = True\n        self.preMoveState = self.getState()\n        self.sigRegionChangeStarted.emit(self)\n\n    def _moveFinished(self):\n        if self.isMoving:\n            self.stateChangeFinished()\n        self.isMoving = False\n\n    def cancelMove(self):\n        self.isMoving = False\n        self.setState(self.preMoveState)\n\n    def checkPointMove(self, handle, pos, modifiers):\n        """"""When handles move, they must ask the ROI if the move is acceptable.\n        By default, this always returns True. Subclasses may wish override.\n        """"""\n        return True\n\n    def movePoint(self, handle, pos, modifiers=QtCore.Qt.KeyboardModifier(), finish=True, coords=\'parent\'):\n        ## called by Handles when they are moved. \n        ## pos is the new position of the handle in scene coords, as requested by the handle.\n        \n        newState = self.stateCopy()\n        index = self.indexOfHandle(handle)\n        h = self.handles[index]\n        p0 = self.mapToParent(h[\'pos\'] * self.state[\'size\'])\n        p1 = Point(pos)\n        \n        if coords == \'parent\':\n            pass\n        elif coords == \'scene\':\n            p1 = self.mapSceneToParent(p1)\n        else:\n            raise Exception(""New point location must be given in either \'parent\' or \'scene\' coordinates."")\n\n        ## Handles with a \'center\' need to know their local position relative to the center point (lp0, lp1)\n        if \'center\' in h:\n            c = h[\'center\']\n            cs = c * self.state[\'size\']\n            lp0 = self.mapFromParent(p0) - cs\n            lp1 = self.mapFromParent(p1) - cs\n        \n        if h[\'type\'] == \'t\':\n            snap = True if (modifiers & QtCore.Qt.ControlModifier) else None\n            self.translate(p1-p0, snap=snap, update=False)\n        \n        elif h[\'type\'] == \'f\':\n            newPos = self.mapFromParent(p1)\n            h[\'item\'].setPos(newPos)\n            h[\'pos\'] = newPos\n            self.freeHandleMoved = True\n            \n        elif h[\'type\'] == \'s\':\n            ## If a handle and its center have the same x or y value, we can\'t scale across that axis.\n            if h[\'center\'][0] == h[\'pos\'][0]:\n                lp1[0] = 0\n            if h[\'center\'][1] == h[\'pos\'][1]:\n                lp1[1] = 0\n            \n            ## snap \n            if self.scaleSnap or (modifiers & QtCore.Qt.ControlModifier):\n                lp1[0] = round(lp1[0] / self.scaleSnapSize) * self.scaleSnapSize\n                lp1[1] = round(lp1[1] / self.scaleSnapSize) * self.scaleSnapSize\n                \n            ## preserve aspect ratio (this can override snapping)\n            if h[\'lockAspect\'] or (modifiers & QtCore.Qt.AltModifier):\n                #arv = Point(self.preMoveState[\'size\']) - \n                lp1 = lp1.proj(lp0)\n            \n            ## determine scale factors and new size of ROI\n            hs = h[\'pos\'] - c\n            if hs[0] == 0:\n                hs[0] = 1\n            if hs[1] == 0:\n                hs[1] = 1\n            newSize = lp1 / hs\n            \n            ## Perform some corrections and limit checks\n            if newSize[0] == 0:\n                newSize[0] = newState[\'size\'][0]\n            if newSize[1] == 0:\n                newSize[1] = newState[\'size\'][1]\n            if not self.invertible:\n                if newSize[0] < 0:\n                    newSize[0] = newState[\'size\'][0]\n                if newSize[1] < 0:\n                    newSize[1] = newState[\'size\'][1]\n            if self.aspectLocked:\n                newSize[0] = newSize[1]\n            \n            ## Move ROI so the center point occupies the same scene location after the scale\n            s0 = c * self.state[\'size\']\n            s1 = c * newSize\n            cc = self.mapToParent(s0 - s1) - self.mapToParent(Point(0, 0))\n            \n            ## update state, do more boundary checks\n            newState[\'size\'] = newSize\n            newState[\'pos\'] = newState[\'pos\'] + cc\n            if self.maxBounds is not None:\n                r = self.stateRect(newState)\n                if not self.maxBounds.contains(r):\n                    return\n            \n            self.setPos(newState[\'pos\'], update=False)\n            self.setSize(newState[\'size\'], update=False)\n        \n        elif h[\'type\'] in [\'r\', \'rf\']:\n            if h[\'type\'] == \'rf\':\n                self.freeHandleMoved = True\n            \n            if not self.rotatable:\n                return\n            ## If the handle is directly over its center point, we can\'t compute an angle.\n            try:\n                if lp1.length() == 0 or lp0.length() == 0:\n                    return\n            except OverflowError:\n                return\n            \n            ## determine new rotation angle, constrained if necessary\n            ang = newState[\'angle\'] - lp0.angle(lp1)\n            if ang is None:  ## this should never happen..\n                return\n            if self.rotateSnap or (modifiers & QtCore.Qt.ControlModifier):\n                ang = round(ang / self.rotateSnapAngle) * self.rotateSnapAngle\n            \n            ## create rotation transform\n            tr = QtGui.QTransform()\n            tr.rotate(ang)\n            \n            ## move ROI so that center point remains stationary after rotate\n            cc = self.mapToParent(cs) - (tr.map(cs) + self.state[\'pos\'])\n            newState[\'angle\'] = ang\n            newState[\'pos\'] = newState[\'pos\'] + cc\n            \n            ## check boundaries, update\n            if self.maxBounds is not None:\n                r = self.stateRect(newState)\n                if not self.maxBounds.contains(r):\n                    return\n            self.setPos(newState[\'pos\'], update=False)\n            self.setAngle(ang, update=False)\n            \n            ## If this is a free-rotate handle, its distance from the center may change.\n            \n            if h[\'type\'] == \'rf\':\n                h[\'item\'].setPos(self.mapFromScene(p1))  ## changes ROI coordinates of handle\n                \n        elif h[\'type\'] == \'sr\':\n            if h[\'center\'][0] == h[\'pos\'][0]:\n                scaleAxis = 1\n                nonScaleAxis=0\n            else:\n                scaleAxis = 0\n                nonScaleAxis=1\n            \n            try:\n                if lp1.length() == 0 or lp0.length() == 0:\n                    return\n            except OverflowError:\n                return\n            \n            ang = newState[\'angle\'] - lp0.angle(lp1)\n            if ang is None:\n                return\n            if self.rotateSnap or (modifiers & QtCore.Qt.ControlModifier):\n                ang = round(ang / self.rotateSnapAngle) * self.rotateSnapAngle\n            \n            hs = abs(h[\'pos\'][scaleAxis] - c[scaleAxis])\n            newState[\'size\'][scaleAxis] = lp1.length() / hs\n            #if self.scaleSnap or (modifiers & QtCore.Qt.ControlModifier):\n            if self.scaleSnap:  ## use CTRL only for angular snap here.\n                newState[\'size\'][scaleAxis] = round(newState[\'size\'][scaleAxis] / self.snapSize) * self.snapSize\n            if newState[\'size\'][scaleAxis] == 0:\n                newState[\'size\'][scaleAxis] = 1\n            if self.aspectLocked:\n                newState[\'size\'][nonScaleAxis] = newState[\'size\'][scaleAxis]\n                \n            c1 = c * newState[\'size\']\n            tr = QtGui.QTransform()\n            tr.rotate(ang)\n            \n            cc = self.mapToParent(cs) - (tr.map(c1) + self.state[\'pos\'])\n            newState[\'angle\'] = ang\n            newState[\'pos\'] = newState[\'pos\'] + cc\n            if self.maxBounds is not None:\n                r = self.stateRect(newState)\n                if not self.maxBounds.contains(r):\n                    return\n            \n            self.setState(newState, update=False)\n        \n        self.stateChanged(finish=finish)\n    \n    def stateChanged(self, finish=True):\n        """"""Process changes to the state of the ROI.\n        If there are any changes, then the positions of handles are updated accordingly\n        and sigRegionChanged is emitted. If finish is True, then \n        sigRegionChangeFinished will also be emitted.""""""\n        \n        changed = False\n        if self.lastState is None:\n            changed = True\n        else:\n            state = self.getState()\n            for k in list(state.keys()):\n                if state[k] != self.lastState[k]:\n                    changed = True\n        \n        self.prepareGeometryChange()\n        if changed:\n            ## Move all handles to match the current configuration of the ROI\n            for h in self.handles:\n                if h[\'item\'] in self.childItems():\n                    p = h[\'pos\']\n                    h[\'item\'].setPos(h[\'pos\'] * self.state[\'size\'])\n                    \n            self.update()\n            self.sigRegionChanged.emit(self)\n        elif self.freeHandleMoved:\n            self.sigRegionChanged.emit(self)\n            \n        self.freeHandleMoved = False\n        self.lastState = self.getState()\n            \n        if finish:\n            self.stateChangeFinished()\n            self.informViewBoundsChanged()\n    \n    def stateChangeFinished(self):\n        self.sigRegionChangeFinished.emit(self)\n    \n    def stateRect(self, state):\n        r = QtCore.QRectF(0, 0, state[\'size\'][0], state[\'size\'][1])\n        tr = QtGui.QTransform()\n        tr.rotate(-state[\'angle\'])\n        r = tr.mapRect(r)\n        return r.adjusted(state[\'pos\'][0], state[\'pos\'][1], state[\'pos\'][0], state[\'pos\'][1])\n    \n    def getSnapPosition(self, pos, snap=None):\n        ## Given that pos has been requested, return the nearest snap-to position\n        ## optionally, snap may be passed in to specify a rectangular snap grid.\n        ## override this function for more interesting snap functionality..\n        \n        if snap is None or snap is True:\n            if self.snapSize is None:\n                return pos\n            snap = Point(self.snapSize, self.snapSize)\n        \n        return Point(\n            round(pos[0] / snap[0]) * snap[0],\n            round(pos[1] / snap[1]) * snap[1]\n        )\n    \n    def boundingRect(self):\n        return QtCore.QRectF(0, 0, self.state[\'size\'][0], self.state[\'size\'][1]).normalized()\n\n    def paint(self, p, opt, widget):\n        # Note: don\'t use self.boundingRect here, because subclasses may need to redefine it.\n        r = QtCore.QRectF(0, 0, self.state[\'size\'][0], self.state[\'size\'][1]).normalized()\n        \n        p.setRenderHint(QtGui.QPainter.Antialiasing)\n        p.setPen(self.currentPen)\n        p.translate(r.left(), r.top())\n        p.scale(r.width(), r.height())\n        p.drawRect(0, 0, 1, 1)\n\n    def getArraySlice(self, data, img, axes=(0,1), returnSlice=True):\n        """"""Return a tuple of slice objects that can be used to slice the region\n        from *data* that is covered by the bounding rectangle of this ROI.\n        Also returns the transform that maps the ROI into data coordinates.\n        \n        If returnSlice is set to False, the function returns a pair of tuples with the values that would have \n        been used to generate the slice objects. ((ax0Start, ax0Stop), (ax1Start, ax1Stop))\n        \n        If the slice cannot be computed (usually because the scene/transforms are not properly\n        constructed yet), then the method returns None.\n        """"""\n        ## Determine shape of array along ROI axes\n        dShape = (data.shape[axes[0]], data.shape[axes[1]])\n        \n        ## Determine transform that maps ROI bounding box to image coordinates\n        try:\n            tr = self.sceneTransform() * fn.invertQTransform(img.sceneTransform())\n        except np.linalg.linalg.LinAlgError:\n            return None\n            \n        ## Modify transform to scale from image coords to data coords\n        axisOrder = img.axisOrder\n        if axisOrder == \'row-major\':\n            tr.scale(float(dShape[1]) / img.width(), float(dShape[0]) / img.height())\n        else:\n            tr.scale(float(dShape[0]) / img.width(), float(dShape[1]) / img.height())\n        \n        ## Transform ROI bounds into data bounds\n        dataBounds = tr.mapRect(self.boundingRect())\n        \n        ## Intersect transformed ROI bounds with data bounds\n        if axisOrder == \'row-major\':\n            intBounds = dataBounds.intersected(QtCore.QRectF(0, 0, dShape[1], dShape[0]))\n        else:\n            intBounds = dataBounds.intersected(QtCore.QRectF(0, 0, dShape[0], dShape[1]))\n        \n        ## Determine index values to use when referencing the array. \n        bounds = (\n            (int(min(intBounds.left(), intBounds.right())), int(1+max(intBounds.left(), intBounds.right()))),\n            (int(min(intBounds.bottom(), intBounds.top())), int(1+max(intBounds.bottom(), intBounds.top())))\n        )\n        if axisOrder == \'row-major\':\n            bounds = bounds[::-1]\n        \n        if returnSlice:\n            ## Create slice objects\n            sl = [slice(None)] * data.ndim\n            sl[axes[0]] = slice(*bounds[0])\n            sl[axes[1]] = slice(*bounds[1])\n            return tuple(sl), tr\n        else:\n            return bounds, tr\n\n    def getArrayRegion(self, data, img, axes=(0,1), returnMappedCoords=False, **kwds):\n        """"""Use the position and orientation of this ROI relative to an imageItem \n        to pull a slice from an array.\n        \n        =================== ====================================================\n        **Arguments**\n        data                The array to slice from. Note that this array does\n                            *not* have to be the same data that is represented\n                            in *img*.\n        img                 (ImageItem or other suitable QGraphicsItem)\n                            Used to determine the relationship between the \n                            ROI and the boundaries of *data*.\n        axes                (length-2 tuple) Specifies the axes in *data* that\n                            correspond to the (x, y) axes of *img*. If the\n                            image\'s axis order is set to\n                            \'row-major\', then the axes are instead specified in\n                            (y, x) order.\n        returnMappedCoords  (bool) If True, the array slice is returned along\n                            with a corresponding array of coordinates that were\n                            used to extract data from the original array.\n        \\**kwds             All keyword arguments are passed to \n                            :func:`affineSlice <pyqtgraph.affineSlice>`.\n        =================== ====================================================\n        \n        This method uses :func:`affineSlice <pyqtgraph.affineSlice>` to generate\n        the slice from *data* and uses :func:`getAffineSliceParams <pyqtgraph.ROI.getAffineSliceParams>`\n        to determine the parameters to pass to :func:`affineSlice <pyqtgraph.affineSlice>`.\n        \n        If *returnMappedCoords* is True, then the method returns a tuple (result, coords) \n        such that coords is the set of coordinates used to interpolate values from the original\n        data, mapped into the parent coordinate system of the image. This is useful, when slicing\n        data from images that have been transformed, for determining the location of each value\n        in the sliced data.\n        \n        All extra keyword arguments are passed to :func:`affineSlice <pyqtgraph.affineSlice>`.\n        """"""\n        # this is a hidden argument for internal use\n        fromBR = kwds.pop(\'fromBoundingRect\', False)\n        \n        shape, vectors, origin = self.getAffineSliceParams(data, img, axes, fromBoundingRect=fromBR)\n        if not returnMappedCoords:\n            rgn = fn.affineSlice(data, shape=shape, vectors=vectors, origin=origin, axes=axes, **kwds)\n            return rgn\n        else:\n            kwds[\'returnCoords\'] = True\n            result, coords = fn.affineSlice(data, shape=shape, vectors=vectors, origin=origin, axes=axes, **kwds)\n            \n            ### map coordinates and return\n            mapped = fn.transformCoordinates(img.transform(), coords)\n            return result, mapped\n\n    def getAffineSliceParams(self, data, img, axes=(0,1), fromBoundingRect=False):\n        """"""\n        Returns the parameters needed to use :func:`affineSlice <pyqtgraph.affineSlice>`\n        (shape, vectors, origin) to extract a subset of *data* using this ROI \n        and *img* to specify the subset.\n        \n        If *fromBoundingRect* is True, then the ROI\'s bounding rectangle is used\n        rather than the shape of the ROI.\n        \n        See :func:`getArrayRegion <pyqtgraph.ROI.getArrayRegion>` for more information.\n        """"""\n        if self.scene() is not img.scene():\n            raise Exception(""ROI and target item must be members of the same scene."")\n        \n        origin = img.mapToData(self.mapToItem(img, QtCore.QPointF(0, 0)))\n        \n        ## vx and vy point in the directions of the slice axes, but must be scaled properly\n        vx = img.mapToData(self.mapToItem(img, QtCore.QPointF(1, 0))) - origin\n        vy = img.mapToData(self.mapToItem(img, QtCore.QPointF(0, 1))) - origin\n        \n        lvx = np.sqrt(vx.x()**2 + vx.y()**2)\n        lvy = np.sqrt(vy.x()**2 + vy.y()**2)\n        ##img.width is number of pixels, not width of item.\n        ##need pxWidth and pxHeight instead of pxLen ?\n        sx = 1.0 / lvx\n        sy = 1.0 / lvy\n        \n        vectors = ((vx.x()*sx, vx.y()*sx), (vy.x()*sy, vy.y()*sy))\n        if fromBoundingRect is True:\n            shape = self.boundingRect().width(), self.boundingRect().height()\n            origin = img.mapToData(self.mapToItem(img, self.boundingRect().topLeft()))\n            origin = (origin.x(), origin.y())\n        else:\n            shape = self.state[\'size\']\n            origin = (origin.x(), origin.y())\n        \n        shape = [abs(shape[0]/sx), abs(shape[1]/sy)]\n        \n        if img.axisOrder == \'row-major\':\n            # transpose output\n            vectors = vectors[::-1]\n            shape = shape[::-1]\n\n        return shape, vectors, origin\n\n    def renderShapeMask(self, width, height):\n        """"""Return an array of 0.0-1.0 into which the shape of the item has been drawn.\n        \n        This can be used to mask array selections.\n        """"""\n        if width == 0 or height == 0:\n            return np.empty((width, height), dtype=float)\n        \n        im = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32)\n        im.fill(0x0)\n        p = QtGui.QPainter(im)\n        p.setPen(fn.mkPen(None))\n        p.setBrush(fn.mkBrush(\'w\'))\n        shape = self.shape()\n        bounds = shape.boundingRect()\n        p.scale(im.width() / bounds.width(), im.height() / bounds.height())\n        p.translate(-bounds.topLeft())\n        p.drawPath(shape)\n        p.end()\n        mask = fn.imageToArray(im, transpose=True)[:,:,0].astype(float) / 255.\n        return mask\n        \n    def getGlobalTransform(self, relativeTo=None):\n        """"""Return global transformation (rotation angle+translation) required to move \n        from relative state to current state. If relative state isn\'t specified,\n        then we use the state of the ROI when mouse is pressed.""""""\n        if relativeTo == None:\n            relativeTo = self.preMoveState\n        st = self.getState()\n        \n        ## this is only allowed because we will be comparing the two \n        relativeTo[\'scale\'] = relativeTo[\'size\']\n        st[\'scale\'] = st[\'size\']\n        \n        t1 = SRTTransform(relativeTo)\n        t2 = SRTTransform(st)\n        return t2/t1\n\n    def applyGlobalTransform(self, tr):\n        st = self.getState()\n        \n        st[\'scale\'] = st[\'size\']\n        st = SRTTransform(st)\n        st = (st * tr).saveState()\n        st[\'size\'] = st[\'scale\']\n        self.setState(st)\n\n\nclass Handle(UIGraphicsItem):\n    """"""\n    Handle represents a single user-interactable point attached to an ROI. They\n    are usually created by a call to one of the ROI.add___Handle() methods.\n    \n    Handles are represented as a square, diamond, or circle, and are drawn with \n    fixed pixel size regardless of the scaling of the view they are displayed in.\n    \n    Handles may be dragged to change the position, size, orientation, or other\n    properties of the ROI they are attached to.\n    """"""\n    types = {   ## defines number of sides, start angle for each handle type\n        \'t\': (4, np.pi/4),\n        \'f\': (4, np.pi/4), \n        \'s\': (4, 0),\n        \'r\': (12, 0),\n        \'sr\': (12, 0),\n        \'rf\': (12, 0),\n    }\n\n    sigClicked = QtCore.Signal(object, object)   # self, event\n    sigRemoveRequested = QtCore.Signal(object)   # self\n    \n    def __init__(self, radius, typ=None, pen=(200, 200, 220), parent=None, deletable=False):\n        self.rois = []\n        self.radius = radius\n        self.typ = typ\n        self.pen = fn.mkPen(pen)\n        self.currentPen = self.pen\n        self.pen.setWidth(0)\n        self.pen.setCosmetic(True)\n        self.isMoving = False\n        self.sides, self.startAng = self.types[typ]\n        self.buildPath()\n        self._shape = None\n        self.menu = self.buildMenu()\n        \n        UIGraphicsItem.__init__(self, parent=parent)\n        self.setAcceptedMouseButtons(QtCore.Qt.NoButton)\n        self.deletable = deletable\n        if deletable:\n            self.setAcceptedMouseButtons(QtCore.Qt.RightButton)        \n        self.setZValue(11)\n            \n    def connectROI(self, roi):\n        ### roi is the ""parent"" roi, i is the index of the handle in roi.handles\n        self.rois.append(roi)\n        \n    def disconnectROI(self, roi):\n        self.rois.remove(roi)\n            \n    def setDeletable(self, b):\n        self.deletable = b\n        if b:\n            self.setAcceptedMouseButtons(self.acceptedMouseButtons() | QtCore.Qt.RightButton)\n        else:\n            self.setAcceptedMouseButtons(self.acceptedMouseButtons() & ~QtCore.Qt.RightButton)\n            \n    def removeClicked(self):\n        self.sigRemoveRequested.emit(self)\n\n    def hoverEvent(self, ev):\n        hover = False\n        if not ev.isExit():\n            if ev.acceptDrags(QtCore.Qt.LeftButton):\n                hover=True\n            for btn in [QtCore.Qt.LeftButton, QtCore.Qt.RightButton, QtCore.Qt.MidButton]:\n                if int(self.acceptedMouseButtons() & btn) > 0 and ev.acceptClicks(btn):\n                    hover=True\n                    \n        if hover:\n            self.currentPen = fn.mkPen(255, 255,0)\n        else:\n            self.currentPen = self.pen\n        self.update()\n\n    def mouseClickEvent(self, ev):\n        ## right-click cancels drag\n        if ev.button() == QtCore.Qt.RightButton and self.isMoving:\n            self.isMoving = False  ## prevents any further motion\n            self.movePoint(self.startPos, finish=True)\n            ev.accept()\n        elif int(ev.button() & self.acceptedMouseButtons()) > 0:\n            ev.accept()\n            if ev.button() == QtCore.Qt.RightButton and self.deletable:\n                self.raiseContextMenu(ev)\n            self.sigClicked.emit(self, ev)\n        else:\n            ev.ignore()        \n                \n    def buildMenu(self):\n        menu = QtGui.QMenu()\n        menu.setTitle(""Handle"")\n        self.removeAction = menu.addAction(""Remove handle"", self.removeClicked) \n        return menu\n        \n    def getMenu(self):\n        return self.menu\n\n    def raiseContextMenu(self, ev):\n        menu = self.scene().addParentContextMenus(self, self.getMenu(), ev)\n        \n        ## Make sure it is still ok to remove this handle\n        removeAllowed = all([r.checkRemoveHandle(self) for r in self.rois])\n        self.removeAction.setEnabled(removeAllowed)\n        pos = ev.screenPos()\n        menu.popup(QtCore.QPoint(pos.x(), pos.y()))    \n\n    def mouseDragEvent(self, ev):\n        if ev.button() != QtCore.Qt.LeftButton:\n            return\n        ev.accept()\n        \n        ## Inform ROIs that a drag is happening \n        ##  note: the ROI is informed that the handle has moved using ROI.movePoint\n        ##  this is for other (more nefarious) purposes.\n        #for r in self.roi:\n            #r[0].pointDragEvent(r[1], ev)\n            \n        if ev.isFinish():\n            if self.isMoving:\n                for r in self.rois:\n                    r.stateChangeFinished()\n            self.isMoving = False\n        elif ev.isStart():\n            for r in self.rois:\n                r.handleMoveStarted()\n            self.isMoving = True\n            self.startPos = self.scenePos()\n            self.cursorOffset = self.scenePos() - ev.buttonDownScenePos()\n            \n        if self.isMoving:  ## note: isMoving may become False in mid-drag due to right-click.\n            pos = ev.scenePos() + self.cursorOffset\n            self.movePoint(pos, ev.modifiers(), finish=False)\n\n    def movePoint(self, pos, modifiers=QtCore.Qt.KeyboardModifier(), finish=True):\n        for r in self.rois:\n            if not r.checkPointMove(self, pos, modifiers):\n                return\n        #print ""point moved; inform %d ROIs"" % len(self.roi)\n        # A handle can be used by multiple ROIs; tell each to update its handle position\n        for r in self.rois:\n            r.movePoint(self, pos, modifiers, finish=finish, coords=\'scene\')\n        \n    def buildPath(self):\n        size = self.radius\n        self.path = QtGui.QPainterPath()\n        ang = self.startAng\n        dt = 2*np.pi / self.sides\n        for i in range(0, self.sides+1):\n            x = size * cos(ang)\n            y = size * sin(ang)\n            ang += dt\n            if i == 0:\n                self.path.moveTo(x, y)\n            else:\n                self.path.lineTo(x, y)            \n            \n    def paint(self, p, opt, widget):\n        p.setRenderHints(p.Antialiasing, True)\n        p.setPen(self.currentPen)\n        \n        p.drawPath(self.shape())\n            \n    def shape(self):\n        if self._shape is None:\n            s = self.generateShape()\n            if s is None:\n                return self.path\n            self._shape = s\n            self.prepareGeometryChange()  ## beware--this can cause the view to adjust, which would immediately invalidate the shape.\n        return self._shape\n    \n    def boundingRect(self):\n        s1 = self.shape()\n        return self.shape().boundingRect()\n            \n    def generateShape(self):\n        dt = self.deviceTransform()\n        \n        if dt is None:\n            self._shape = self.path\n            return None\n        \n        v = dt.map(QtCore.QPointF(1, 0)) - dt.map(QtCore.QPointF(0, 0))\n        va = np.arctan2(v.y(), v.x())\n        \n        dti = fn.invertQTransform(dt)\n        devPos = dt.map(QtCore.QPointF(0,0))\n        tr = QtGui.QTransform()\n        tr.translate(devPos.x(), devPos.y())\n        tr.rotate(va * 180. / 3.1415926)\n        \n        return dti.map(tr.map(self.path))\n        \n    def viewTransformChanged(self):\n        GraphicsObject.viewTransformChanged(self)\n        self._shape = None  ## invalidate shape, recompute later if requested.\n        self.update()\n\n\nclass MouseDragHandler(object):\n    """"""Implements default mouse drag behavior for ROI (not for ROI handles).\n    """"""\n    def __init__(self, roi):\n        self.roi = roi\n        self.dragMode = None\n        self.startState = None\n        self.snapModifier = QtCore.Qt.ControlModifier\n        self.translateModifier = QtCore.Qt.NoModifier\n        self.rotateModifier = QtCore.Qt.AltModifier\n        self.scaleModifier = QtCore.Qt.ShiftModifier\n        self.rotateSpeed = 0.5\n        self.scaleSpeed = 1.01\n\n    def mouseDragEvent(self, ev):\n        roi = self.roi\n\n        if ev.isStart():\n            if ev.button() == QtCore.Qt.LeftButton:\n                roi.setSelected(True)\n                mods = ev.modifiers() & ~self.snapModifier\n                if roi.translatable and mods == self.translateModifier:\n                    self.dragMode = \'translate\'\n                elif roi.rotatable and mods == self.rotateModifier:\n                    self.dragMode = \'rotate\'\n                elif roi.resizable and mods == self.scaleModifier:\n                    self.dragMode = \'scale\'\n                else:\n                    self.dragMode = None\n                \n                if self.dragMode is not None:\n                    roi._moveStarted()\n                    self.startPos = roi.mapToParent(ev.buttonDownPos())\n                    self.startState = roi.saveState()\n                    self.cursorOffset = roi.pos() - self.startPos\n                    ev.accept()\n                else:\n                    ev.ignore()\n            else:\n                self.dragMode = None\n                ev.ignore()\n\n\n        if ev.isFinish() and self.dragMode is not None:\n            roi._moveFinished()\n            return\n\n        # roi.isMoving becomes False if the move was cancelled by right-click\n        if not roi.isMoving or self.dragMode is None:\n            return\n\n        snap = True if (ev.modifiers() & self.snapModifier) else None\n        pos = roi.mapToParent(ev.pos())\n        if self.dragMode == \'translate\':\n            newPos = pos + self.cursorOffset\n            roi.translate(newPos - roi.pos(), snap=snap, finish=False)\n        elif self.dragMode == \'rotate\':\n            diff = self.rotateSpeed * (ev.scenePos() - ev.buttonDownScenePos()).x()\n            angle = self.startState[\'angle\'] - diff\n            roi.setAngle(angle, centerLocal=ev.buttonDownPos(), snap=snap, finish=False)\n        elif self.dragMode == \'scale\':\n            diff = self.scaleSpeed ** -(ev.scenePos() - ev.buttonDownScenePos()).y()\n            roi.setSize(Point(self.startState[\'size\']) * diff, centerLocal=ev.buttonDownPos(), snap=snap, finish=False)\n\n\nclass TestROI(ROI):\n    def __init__(self, pos, size, **args):\n        ROI.__init__(self, pos, size, **args)\n        self.addTranslateHandle([0.5, 0.5])\n        self.addScaleHandle([1, 1], [0, 0])\n        self.addScaleHandle([0, 0], [1, 1])\n        self.addScaleRotateHandle([1, 0.5], [0.5, 0.5])\n        self.addScaleHandle([0.5, 1], [0.5, 0.5])\n        self.addRotateHandle([1, 0], [0, 0])\n        self.addRotateHandle([0, 1], [1, 1])\n\n\nclass RectROI(ROI):\n    """"""\n    Rectangular ROI subclass with a single scale handle at the top-right corner.\n    \n    ============== =============================================================\n    **Arguments**\n    pos            (length-2 sequence) The position of the ROI origin.\n                   See ROI().\n    size           (length-2 sequence) The size of the ROI. See ROI().\n    centered       (bool) If True, scale handles affect the ROI relative to its\n                   center, rather than its origin.\n    sideScalers    (bool) If True, extra scale handles are added at the top and \n                   right edges.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n    \n    """"""\n    def __init__(self, pos, size, centered=False, sideScalers=False, **args):\n        ROI.__init__(self, pos, size, **args)\n        if centered:\n            center = [0.5, 0.5]\n        else:\n            center = [0, 0]\n            \n        self.addScaleHandle([1, 1], center)\n        if sideScalers:\n            self.addScaleHandle([1, 0.5], [center[0], 0.5])\n            self.addScaleHandle([0.5, 1], [0.5, center[1]])\n\nclass LineROI(ROI):\n    """"""\n    Rectangular ROI subclass with scale-rotate handles on either side. This\n    allows the ROI to be positioned as if moving the ends of a line segment.\n    A third handle controls the width of the ROI orthogonal to its ""line"" axis.\n    \n    ============== =============================================================\n    **Arguments**\n    pos1           (length-2 sequence) The position of the center of the ROI\'s\n                   left edge.\n    pos2           (length-2 sequence) The position of the center of the ROI\'s\n                   right edge.\n    width          (float) The width of the ROI.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n    \n    """"""\n    def __init__(self, pos1, pos2, width, **args):\n        pos1 = Point(pos1)\n        pos2 = Point(pos2)\n        d = pos2-pos1\n        l = d.length()\n        ang = Point(1, 0).angle(d)\n        ra = ang * np.pi / 180.\n        c = Point(-width/2. * sin(ra), -width/2. * cos(ra))\n        pos1 = pos1 + c\n        \n        ROI.__init__(self, pos1, size=Point(l, width), angle=ang, **args)\n        self.addScaleRotateHandle([0, 0.5], [1, 0.5])\n        self.addScaleRotateHandle([1, 0.5], [0, 0.5])\n        self.addScaleHandle([0.5, 1], [0.5, 0.5])\n        \n\n        \nclass MultiRectROI(QtGui.QGraphicsObject):\n    """"""\n    Chain of rectangular ROIs connected by handles. \n    \n    This is generally used to mark a curved path through \n    an image similarly to PolyLineROI. It differs in that each segment\n    of the chain is rectangular instead of linear and thus has width.\n    \n    ============== =============================================================\n    **Arguments**\n    points         (list of length-2 sequences) The list of points in the path.\n    width          (float) The width of the ROIs orthogonal to the path.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n    """"""\n    sigRegionChangeFinished = QtCore.Signal(object)\n    sigRegionChangeStarted = QtCore.Signal(object)\n    sigRegionChanged = QtCore.Signal(object)\n    \n    def __init__(self, points, width, pen=None, **args):\n        QtGui.QGraphicsObject.__init__(self)\n        self.pen = pen\n        self.roiArgs = args\n        self.lines = []\n        if len(points) < 2:\n            raise Exception(""Must start with at least 2 points"")\n        \n        ## create first segment\n        self.addSegment(points[1], connectTo=points[0], scaleHandle=True)\n        \n        ## create remaining segments\n        for p in points[2:]:\n            self.addSegment(p)\n        \n        \n    def paint(self, *args):\n        pass\n    \n    def boundingRect(self):\n        return QtCore.QRectF()\n        \n    def roiChangedEvent(self):\n        w = self.lines[0].state[\'size\'][1]\n        for l in self.lines[1:]:\n            w0 = l.state[\'size\'][1]\n            if w == w0:\n                continue\n            l.scale([1.0, w/w0], center=[0.5,0.5])\n        self.sigRegionChanged.emit(self)\n            \n    def roiChangeStartedEvent(self):\n        self.sigRegionChangeStarted.emit(self)\n        \n    def roiChangeFinishedEvent(self):\n        self.sigRegionChangeFinished.emit(self)\n        \n    def getHandlePositions(self):\n        """"""Return the positions of all handles in local coordinates.""""""\n        pos = [self.mapFromScene(self.lines[0].getHandles()[0].scenePos())]\n        for l in self.lines:\n            pos.append(self.mapFromScene(l.getHandles()[1].scenePos()))\n        return pos\n        \n    def getArrayRegion(self, arr, img=None, axes=(0,1), **kwds):\n        rgns = []\n        for l in self.lines:\n            rgn = l.getArrayRegion(arr, img, axes=axes, **kwds)\n            if rgn is None:\n                continue\n            rgns.append(rgn)\n            #print l.state[\'size\']\n            \n        ## make sure orthogonal axis is the same size\n        ## (sometimes fp errors cause differences)\n        if img.axisOrder == \'row-major\':\n            axes = axes[::-1]\n        ms = min([r.shape[axes[1]] for r in rgns])\n        sl = [slice(None)] * rgns[0].ndim\n        sl[axes[1]] = slice(0,ms)\n        rgns = [r[sl] for r in rgns]\n        #print [r.shape for r in rgns], axes\n        \n        return np.concatenate(rgns, axis=axes[0])\n        \n    def addSegment(self, pos=(0,0), scaleHandle=False, connectTo=None):\n        """"""\n        Add a new segment to the ROI connecting from the previous endpoint to *pos*.\n        (pos is specified in the parent coordinate system of the MultiRectROI)\n        """"""\n        \n        ## by default, connect to the previous endpoint\n        if connectTo is None:\n            connectTo = self.lines[-1].getHandles()[1]\n            \n        ## create new ROI\n        newRoi = ROI((0,0), [1, 5], parent=self, pen=self.pen, **self.roiArgs)\n        self.lines.append(newRoi)\n        \n        ## Add first SR handle\n        if isinstance(connectTo, Handle):\n            self.lines[-1].addScaleRotateHandle([0, 0.5], [1, 0.5], item=connectTo)\n            newRoi.movePoint(connectTo, connectTo.scenePos(), coords=\'scene\')\n        else:\n            h = self.lines[-1].addScaleRotateHandle([0, 0.5], [1, 0.5])\n            newRoi.movePoint(h, connectTo, coords=\'scene\')\n            \n        ## add second SR handle\n        h = self.lines[-1].addScaleRotateHandle([1, 0.5], [0, 0.5]) \n        newRoi.movePoint(h, pos)\n        \n        ## optionally add scale handle (this MUST come after the two SR handles)\n        if scaleHandle:\n            newRoi.addScaleHandle([0.5, 1], [0.5, 0.5])\n            \n        newRoi.translatable = False \n        newRoi.sigRegionChanged.connect(self.roiChangedEvent) \n        newRoi.sigRegionChangeStarted.connect(self.roiChangeStartedEvent) \n        newRoi.sigRegionChangeFinished.connect(self.roiChangeFinishedEvent)\n        self.sigRegionChanged.emit(self) \n    \n\n    def removeSegment(self, index=-1): \n        """"""Remove a segment from the ROI.""""""\n        roi = self.lines[index]\n        self.lines.pop(index)\n        self.scene().removeItem(roi)\n        roi.sigRegionChanged.disconnect(self.roiChangedEvent) \n        roi.sigRegionChangeStarted.disconnect(self.roiChangeStartedEvent) \n        roi.sigRegionChangeFinished.disconnect(self.roiChangeFinishedEvent)\n        \n        self.sigRegionChanged.emit(self)\n        \n        \nclass MultiLineROI(MultiRectROI):\n    def __init__(self, *args, **kwds):\n        MultiRectROI.__init__(self, *args, **kwds)\n        print(""Warning: MultiLineROI has been renamed to MultiRectROI. (and MultiLineROI may be redefined in the future)"")\n\n        \nclass EllipseROI(ROI):\n    """"""\n    Elliptical ROI subclass with one scale handle and one rotation handle.\n    \n    \n    ============== =============================================================\n    **Arguments**\n    pos            (length-2 sequence) The position of the ROI\'s origin.\n    size           (length-2 sequence) The size of the ROI\'s bounding rectangle.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n    \n    """"""\n    def __init__(self, pos, size, **args):\n        self.path = None\n        ROI.__init__(self, pos, size, **args)\n        self.sigRegionChanged.connect(self._clearPath)\n        self._addHandles()\n        \n    def _addHandles(self):\n        self.addRotateHandle([1.0, 0.5], [0.5, 0.5])\n        self.addScaleHandle([0.5*2.**-0.5 + 0.5, 0.5*2.**-0.5 + 0.5], [0.5, 0.5])\n            \n    def _clearPath(self):\n        self.path = None\n        \n    def paint(self, p, opt, widget):\n        r = self.boundingRect()\n        p.setRenderHint(QtGui.QPainter.Antialiasing)\n        p.setPen(self.currentPen)\n        \n        p.scale(r.width(), r.height())## workaround for GL bug\n        r = QtCore.QRectF(r.x()/r.width(), r.y()/r.height(), 1,1)\n        \n        p.drawEllipse(r)\n        \n    def getArrayRegion(self, arr, img=None, axes=(0, 1), **kwds):\n        """"""\n        Return the result of ROI.getArrayRegion() masked by the elliptical shape\n        of the ROI. Regions outside the ellipse are set to 0.\n        """"""\n        # Note: we could use the same method as used by PolyLineROI, but this\n        # implementation produces a nicer mask.\n        arr = ROI.getArrayRegion(self, arr, img, axes, **kwds)\n        if arr is None or arr.shape[axes[0]] == 0 or arr.shape[axes[1]] == 0:\n            return arr\n        w = arr.shape[axes[0]]\n        h = arr.shape[axes[1]]\n\n        ## generate an ellipsoidal mask\n        mask = np.fromfunction(lambda x,y: (((x+0.5)/(w/2.)-1)**2+ ((y+0.5)/(h/2.)-1)**2)**0.5 < 1, (w, h))\n        \n        # reshape to match array axes\n        if axes[0] > axes[1]:\n            mask = mask.T\n        shape = [(n if i in axes else 1) for i,n in enumerate(arr.shape)]\n        mask = mask.reshape(shape)\n        \n        return arr * mask\n    \n    def shape(self):\n        if self.path is None:\n            path = QtGui.QPainterPath()\n            \n            # Note: Qt has a bug where very small ellipses (radius <0.001) do\n            # not correctly intersect with mouse position (upper-left and \n            # lower-right quadrants are not clickable).\n            #path.addEllipse(self.boundingRect())\n            \n            # Workaround: manually draw the path.\n            br = self.boundingRect()\n            center = br.center()\n            r1 = br.width() / 2.\n            r2 = br.height() / 2.\n            theta = np.linspace(0, 2*np.pi, 24)\n            x = center.x() + r1 * np.cos(theta)\n            y = center.y() + r2 * np.sin(theta)\n            path.moveTo(x[0], y[0])\n            for i in range(1, len(x)):\n                path.lineTo(x[i], y[i])\n            self.path = path\n        \n        return self.path\n        \n        \nclass CircleROI(EllipseROI):\n    """"""\n    Circular ROI subclass. Behaves exactly as EllipseROI, but may only be scaled\n    proportionally to maintain its aspect ratio.\n    \n    ============== =============================================================\n    **Arguments**\n    pos            (length-2 sequence) The position of the ROI\'s origin.\n    size           (length-2 sequence) The size of the ROI\'s bounding rectangle.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n    \n    """"""\n    def __init__(self, pos, size=None, radius=None, **args):\n        if size is None:\n            if radius is None:\n                raise TypeError(""Must provide either size or radius."")\n            size = (radius*2, radius*2)\n        EllipseROI.__init__(self, pos, size, **args)\n        self.aspectLocked = True\n        \n    def _addHandles(self):\n        self.addScaleHandle([0.5*2.**-0.5 + 0.5, 0.5*2.**-0.5 + 0.5], [0.5, 0.5])\n\n\nclass PolygonROI(ROI):\n    ## deprecated. Use PloyLineROI instead.\n    \n    def __init__(self, positions, pos=None, **args):\n        if pos is None:\n            pos = [0,0]\n        ROI.__init__(self, pos, [1,1], **args)\n        for p in positions:\n            self.addFreeHandle(p)\n        self.setZValue(1000)\n        print(""Warning: PolygonROI is deprecated. Use PolyLineROI instead."")\n            \n    def listPoints(self):\n        return [p[\'item\'].pos() for p in self.handles]\n            \n    def paint(self, p, *args):\n        p.setRenderHint(QtGui.QPainter.Antialiasing)\n        p.setPen(self.currentPen)\n        for i in range(len(self.handles)):\n            h1 = self.handles[i][\'item\'].pos()\n            h2 = self.handles[i-1][\'item\'].pos()\n            p.drawLine(h1, h2)\n        \n    def boundingRect(self):\n        r = QtCore.QRectF()\n        for h in self.handles:\n            r |= self.mapFromItem(h[\'item\'], h[\'item\'].boundingRect()).boundingRect()   ## |= gives the union of the two QRectFs\n        return r\n    \n    def shape(self):\n        p = QtGui.QPainterPath()\n        p.moveTo(self.handles[0][\'item\'].pos())\n        for i in range(len(self.handles)):\n            p.lineTo(self.handles[i][\'item\'].pos())\n        return p\n    \n    def stateCopy(self):\n        sc = {}\n        sc[\'pos\'] = Point(self.state[\'pos\'])\n        sc[\'size\'] = Point(self.state[\'size\'])\n        sc[\'angle\'] = self.state[\'angle\']\n        return sc\n\n    \nclass PolyLineROI(ROI):\n    """"""\n    Container class for multiple connected LineSegmentROIs.\n    \n    This class allows the user to draw paths of multiple line segments.\n    \n    ============== =============================================================\n    **Arguments**\n    positions      (list of length-2 sequences) The list of points in the path.\n                   Note that, unlike the handle positions specified in other\n                   ROIs, these positions must be expressed in the normal\n                   coordinate system of the ROI, rather than (0 to 1) relative\n                   to the size of the ROI.\n    closed         (bool) if True, an extra LineSegmentROI is added connecting \n                   the beginning and end points.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n    \n    """"""\n    def __init__(self, positions, closed=False, pos=None, **args):\n        \n        if pos is None:\n            pos = [0,0]\n            \n        self.closed = closed\n        self.segments = []\n        ROI.__init__(self, pos, size=[1,1], **args)\n        \n        self.setPoints(positions)\n\n    def setPoints(self, points, closed=None):\n        """"""\n        Set the complete sequence of points displayed by this ROI.\n        \n        ============= =========================================================\n        **Arguments**\n        points        List of (x,y) tuples specifying handle locations to set.\n        closed        If bool, then this will set whether the ROI is closed \n                      (the last point is connected to the first point). If\n                      None, then the closed mode is left unchanged.\n        ============= =========================================================\n        \n        """"""\n        if closed is not None:\n            self.closed = closed\n        \n        self.clearPoints()\n        \n        for p in points:\n            self.addFreeHandle(p)\n        \n        start = -1 if self.closed else 0\n        for i in range(start, len(self.handles)-1):\n            self.addSegment(self.handles[i][\'item\'], self.handles[i+1][\'item\'])\n        \n    def clearPoints(self):\n        """"""\n        Remove all handles and segments.\n        """"""\n        while len(self.handles) > 0:\n            self.removeHandle(self.handles[0][\'item\'])\n    \n    def getState(self):\n        state = ROI.getState(self)\n        state[\'closed\'] = self.closed\n        state[\'points\'] = [Point(h.pos()) for h in self.getHandles()]\n        return state\n\n    def saveState(self):\n        state = ROI.saveState(self)\n        state[\'closed\'] = self.closed\n        state[\'points\'] = [tuple(h.pos()) for h in self.getHandles()]\n        return state\n\n    def setState(self, state):\n        ROI.setState(self, state)\n        self.setPoints(state[\'points\'], closed=state[\'closed\'])\n        \n    def addSegment(self, h1, h2, index=None):\n        seg = _PolyLineSegment(handles=(h1, h2), pen=self.pen, parent=self, movable=False)\n        if index is None:\n            self.segments.append(seg)\n        else:\n            self.segments.insert(index, seg)\n        seg.sigClicked.connect(self.segmentClicked)\n        seg.setAcceptedMouseButtons(QtCore.Qt.LeftButton)\n        seg.setZValue(self.zValue()+1)\n        for h in seg.handles:\n            h[\'item\'].setDeletable(True)\n            h[\'item\'].setAcceptedMouseButtons(h[\'item\'].acceptedMouseButtons() | QtCore.Qt.LeftButton) ## have these handles take left clicks too, so that handles cannot be added on top of other handles\n        \n    def setMouseHover(self, hover):\n        ## Inform all the ROI\'s segments that the mouse is(not) hovering over it\n        ROI.setMouseHover(self, hover)\n        for s in self.segments:\n            s.setParentHover(hover)\n          \n    def addHandle(self, info, index=None):\n        h = ROI.addHandle(self, info, index=index)\n        h.sigRemoveRequested.connect(self.removeHandle)\n        self.stateChanged(finish=True)\n        return h\n        \n    def segmentClicked(self, segment, ev=None, pos=None): ## pos should be in this item\'s coordinate system\n        if ev != None:\n            pos = segment.mapToParent(ev.pos())\n        elif pos != None:\n            pos = pos\n        else:\n            raise Exception(""Either an event or a position must be given."")\n        h1 = segment.handles[0][\'item\']\n        h2 = segment.handles[1][\'item\']\n        \n        i = self.segments.index(segment)\n        h3 = self.addFreeHandle(pos, index=self.indexOfHandle(h2))\n        self.addSegment(h3, h2, index=i+1)\n        segment.replaceHandle(h2, h3)\n        \n    def removeHandle(self, handle, updateSegments=True):\n        ROI.removeHandle(self, handle)\n        handle.sigRemoveRequested.disconnect(self.removeHandle)\n        \n        if not updateSegments:\n            return\n        segments = handle.rois[:]\n        \n        if len(segments) == 1:\n            self.removeSegment(segments[0])\n        elif len(segments) > 1:\n            handles = [h[\'item\'] for h in segments[1].handles]\n            handles.remove(handle)\n            segments[0].replaceHandle(handle, handles[0])\n            self.removeSegment(segments[1])\n        self.stateChanged(finish=True)\n        \n    def removeSegment(self, seg):\n        for handle in seg.handles[:]:\n            seg.removeHandle(handle[\'item\'])\n        self.segments.remove(seg)\n        seg.sigClicked.disconnect(self.segmentClicked)\n        self.scene().removeItem(seg)\n        \n    def checkRemoveHandle(self, h):\n        ## called when a handle is about to display its context menu\n        if self.closed:\n            return len(self.handles) > 3\n        else:\n            return len(self.handles) > 2\n        \n    def paint(self, p, *args):\n        pass\n    \n    def boundingRect(self):\n        return self.shape().boundingRect()\n\n    def shape(self):\n        p = QtGui.QPainterPath()\n        if len(self.handles) == 0:\n            return p\n        p.moveTo(self.handles[0][\'item\'].pos())\n        for i in range(len(self.handles)):\n            p.lineTo(self.handles[i][\'item\'].pos())\n        p.lineTo(self.handles[0][\'item\'].pos())\n        return p\n\n    def getArrayRegion(self, data, img, axes=(0,1), **kwds):\n        """"""\n        Return the result of ROI.getArrayRegion(), masked by the shape of the \n        ROI. Values outside the ROI shape are set to 0.\n        """"""\n        br = self.boundingRect()\n        if br.width() > 1000:\n            raise Exception()\n        sliced = ROI.getArrayRegion(self, data, img, axes=axes, fromBoundingRect=True, **kwds)\n        \n        if img.axisOrder == \'col-major\':\n            mask = self.renderShapeMask(sliced.shape[axes[0]], sliced.shape[axes[1]])\n        else:\n            mask = self.renderShapeMask(sliced.shape[axes[1]], sliced.shape[axes[0]])\n            mask = mask.T\n            \n        # reshape mask to ensure it is applied to the correct data axes\n        shape = [1] * data.ndim\n        shape[axes[0]] = sliced.shape[axes[0]]\n        shape[axes[1]] = sliced.shape[axes[1]]\n        mask = mask.reshape(shape)\n\n        return sliced * mask\n\n    def setPen(self, *args, **kwds):\n        ROI.setPen(self, *args, **kwds)\n        for seg in self.segments:\n            seg.setPen(*args, **kwds)\n\n\n\nclass LineSegmentROI(ROI):\n    """"""\n    ROI subclass with two freely-moving handles defining a line.\n    \n    ============== =============================================================\n    **Arguments**\n    positions      (list of two length-2 sequences) The endpoints of the line \n                   segment. Note that, unlike the handle positions specified in \n                   other ROIs, these positions must be expressed in the normal\n                   coordinate system of the ROI, rather than (0 to 1) relative\n                   to the size of the ROI.\n    \\**args        All extra keyword arguments are passed to ROI()\n    ============== =============================================================\n    """"""\n    \n    def __init__(self, positions=(None, None), pos=None, handles=(None,None), **args):\n        if pos is None:\n            pos = [0,0]\n            \n        ROI.__init__(self, pos, [1,1], **args)\n        if len(positions) > 2:\n            raise Exception(""LineSegmentROI must be defined by exactly 2 positions. For more points, use PolyLineROI."")\n        \n        for i, p in enumerate(positions):\n            self.addFreeHandle(p, item=handles[i])\n            \n    @property\n    def endpoints(self):\n        # must not be cached because self.handles may change.\n        return [h[\'item\'] for h in self.handles]\n        \n    def listPoints(self):\n        return [p[\'item\'].pos() for p in self.handles]\n            \n    def paint(self, p, *args):\n        p.setRenderHint(QtGui.QPainter.Antialiasing)\n        p.setPen(self.currentPen)\n        h1 = self.endpoints[0].pos()\n        h2 = self.endpoints[1].pos()\n        p.drawLine(h1, h2)\n        \n    def boundingRect(self):\n        return self.shape().boundingRect()\n    \n    def shape(self):\n        p = QtGui.QPainterPath()\n    \n        h1 = self.endpoints[0].pos()\n        h2 = self.endpoints[1].pos()\n        dh = h2-h1\n        if dh.length() == 0:\n            return p\n        pxv = self.pixelVectors(dh)[1]\n        if pxv is None:\n            return p\n            \n        pxv *= 4\n        \n        p.moveTo(h1+pxv)\n        p.lineTo(h2+pxv)\n        p.lineTo(h2-pxv)\n        p.lineTo(h1-pxv)\n        p.lineTo(h1+pxv)\n      \n        return p\n    \n    def getArrayRegion(self, data, img, axes=(0,1), order=1, returnMappedCoords=False, **kwds):\n        """"""\n        Use the position of this ROI relative to an imageItem to pull a slice \n        from an array.\n        \n        Since this pulls 1D data from a 2D coordinate system, the return value \n        will have ndim = data.ndim-1\n        \n        See ROI.getArrayRegion() for a description of the arguments.\n        """"""\n        imgPts = [self.mapToItem(img, h.pos()) for h in self.endpoints]\n        rgns = []\n        coords = []\n\n        d = Point(imgPts[1] - imgPts[0])\n        o = Point(imgPts[0])\n        rgn = fn.affineSlice(data, shape=(int(d.length()),), vectors=[Point(d.norm())], origin=o, axes=axes, order=order, returnCoords=returnMappedCoords, **kwds)\n\n        return rgn\n        \n\nclass _PolyLineSegment(LineSegmentROI):\n    # Used internally by PolyLineROI\n    def __init__(self, *args, **kwds):\n        self._parentHovering = False\n        LineSegmentROI.__init__(self, *args, **kwds)\n        \n    def setParentHover(self, hover):\n        # set independently of own hover state\n        if self._parentHovering != hover:\n            self._parentHovering = hover\n            self._updateHoverColor()\n        \n    def _makePen(self):\n        if self.mouseHovering or self._parentHovering:\n            return fn.mkPen(255, 255, 0)\n        else:\n            return self.pen\n        \n    def hoverEvent(self, ev):\n        # accept drags even though we discard them to prevent competition with parent ROI\n        # (unless parent ROI is not movable)\n        if self.parentItem().translatable:\n            ev.acceptDrags(QtCore.Qt.LeftButton)\n        return LineSegmentROI.hoverEvent(self, ev)\n\n\nclass CrosshairROI(ROI):\n    """"""A crosshair ROI whose position is at the center of the crosshairs. By default, it is scalable, rotatable and translatable.""""""\n    \n    def __init__(self, pos=None, size=None, **kargs):\n        if size == None:\n            size=[1,1]\n        if pos == None:\n            pos = [0,0]\n        self._shape = None\n        ROI.__init__(self, pos, size, **kargs)\n        \n        self.sigRegionChanged.connect(self.invalidate)\n        self.addScaleRotateHandle(Point(1, 0), Point(0, 0))\n        self.aspectLocked = True\n\n    def invalidate(self):\n        self._shape = None\n        self.prepareGeometryChange()\n        \n    def boundingRect(self):\n        return self.shape().boundingRect()\n    \n    def shape(self):\n        if self._shape is None:\n            radius = self.getState()[\'size\'][1]\n            p = QtGui.QPainterPath()\n            p.moveTo(Point(0, -radius))\n            p.lineTo(Point(0, radius))\n            p.moveTo(Point(-radius, 0))\n            p.lineTo(Point(radius, 0))\n            p = self.mapToDevice(p)\n            stroker = QtGui.QPainterPathStroker()\n            stroker.setWidth(10)\n            outline = stroker.createStroke(p)\n            self._shape = self.mapFromDevice(outline)\n        \n        return self._shape\n    \n    def paint(self, p, *args):\n        radius = self.getState()[\'size\'][1]\n        p.setRenderHint(QtGui.QPainter.Antialiasing)\n        p.setPen(self.currentPen)\n        \n        p.drawLine(Point(0, -radius), Point(0, radius))\n        p.drawLine(Point(-radius, 0), Point(radius, 0))\n        \n        \nclass RulerROI(LineSegmentROI):\n    def paint(self, p, *args):\n        LineSegmentROI.paint(self, p, *args)\n        h1 = self.handles[0][\'item\'].pos()\n        h2 = self.handles[1][\'item\'].pos()\n        p1 = p.transform().map(h1)\n        p2 = p.transform().map(h2)\n\n        vec = Point(h2) - Point(h1)\n        length = vec.length()\n        angle = vec.angle(Point(1, 0))\n\n        pvec = p2 - p1\n        pvecT = Point(pvec.y(), -pvec.x())\n        pos = 0.5 * (p1 + p2) + pvecT * 40 / pvecT.length()\n\n        p.resetTransform()\n\n        txt = fn.siFormat(length, suffix=\'m\') + \'\\n%0.1f deg\' % angle\n        p.drawText(QtCore.QRectF(pos.x()-50, pos.y()-50, 100, 100), QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter, txt)\n\n    def boundingRect(self):\n        r = LineSegmentROI.boundingRect(self)\n        pxl = self.pixelLength(Point([1, 0]))\n        if pxl is None:\n            return r\n        pxw = 50 * pxl\n        return r.adjusted(-50, -50, 50, 50)\n'"
src/third_party/pyqtgraph/graphicsItems/ScaleBar.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .GraphicsObject import *\nfrom .GraphicsWidgetAnchor import *\nfrom .TextItem import TextItem\nimport numpy as np\nfrom .. import functions as fn\nfrom .. import getConfigOption\nfrom ..Point import Point\n\n__all__ = [\'ScaleBar\']\n\nclass ScaleBar(GraphicsObject, GraphicsWidgetAnchor):\n    """"""\n    Displays a rectangular bar to indicate the relative scale of objects on the view.\n    """"""\n    def __init__(self, size, width=5, brush=None, pen=None, suffix=\'m\', offset=None):\n        GraphicsObject.__init__(self)\n        GraphicsWidgetAnchor.__init__(self)\n        self.setFlag(self.ItemHasNoContents)\n        self.setAcceptedMouseButtons(QtCore.Qt.NoButton)\n        \n        if brush is None:\n            brush = getConfigOption(\'foreground\')\n        self.brush = fn.mkBrush(brush)\n        self.pen = fn.mkPen(pen)\n        self._width = width\n        self.size = size\n        if offset == None:\n            offset = (0,0)\n        self.offset = offset\n        \n        self.bar = QtGui.QGraphicsRectItem()\n        self.bar.setPen(self.pen)\n        self.bar.setBrush(self.brush)\n        self.bar.setParentItem(self)\n        \n        self.text = TextItem(text=fn.siFormat(size, suffix=suffix), anchor=(0.5,1))\n        self.text.setParentItem(self)\n\n    def parentChanged(self):\n        view = self.parentItem()\n        if view is None:\n            return\n        view.sigRangeChanged.connect(self.updateBar)\n        self.updateBar()\n        \n        \n    def updateBar(self):\n        view = self.parentItem()\n        if view is None:\n            return\n        p1 = view.mapFromViewToItem(self, QtCore.QPointF(0,0))\n        p2 = view.mapFromViewToItem(self, QtCore.QPointF(self.size,0))\n        w = (p2-p1).x()\n        self.bar.setRect(QtCore.QRectF(-w, 0, w, self._width))\n        self.text.setPos(-w/2., 0)\n\n    def boundingRect(self):\n        return QtCore.QRectF()\n\n    def setParentItem(self, p):\n        ret = GraphicsObject.setParentItem(self, p)\n        if self.offset is not None:\n            offset = Point(self.offset)\n            anchorx = 1 if offset[0] <= 0 else 0\n            anchory = 1 if offset[1] <= 0 else 0\n            anchor = (anchorx, anchory)\n            self.anchor(itemPos=anchor, parentPos=anchor, offset=offset)\n        return ret\n\n\n'"
src/third_party/pyqtgraph/graphicsItems/ScatterPlotItem.py,29,"b'from itertools import starmap, repeat\ntry:\n    from itertools import imap\nexcept ImportError:\n    imap = map\nimport numpy as np\nimport weakref\nfrom ..Qt import QtGui, QtCore, QT_LIB\nfrom ..Point import Point\nfrom .. import functions as fn\nfrom .GraphicsItem import GraphicsItem\nfrom .GraphicsObject import GraphicsObject\nfrom .. import getConfigOption\nfrom ..pgcollections import OrderedDict\nfrom .. import debug\nfrom ..python2_3 import basestring\n\n__all__ = [\'ScatterPlotItem\', \'SpotItem\']\n\n\n## Build all symbol paths\nSymbols = OrderedDict([(name, QtGui.QPainterPath()) for name in [\'o\', \'s\', \'t\', \'t1\', \'t2\', \'t3\',\'d\', \'+\', \'x\', \'p\', \'h\', \'star\']])\nSymbols[\'o\'].addEllipse(QtCore.QRectF(-0.5, -0.5, 1, 1))\nSymbols[\'s\'].addRect(QtCore.QRectF(-0.5, -0.5, 1, 1))\ncoords = {\n    \'t\': [(-0.5, -0.5), (0, 0.5), (0.5, -0.5)],\n    \'t1\': [(-0.5, 0.5), (0, -0.5), (0.5, 0.5)],\n    \'t2\': [(-0.5, -0.5), (-0.5, 0.5), (0.5, 0)],\n    \'t3\': [(0.5, 0.5), (0.5, -0.5), (-0.5, 0)],\n    \'d\': [(0., -0.5), (-0.4, 0.), (0, 0.5), (0.4, 0)],\n    \'+\': [\n        (-0.5, -0.05), (-0.5, 0.05), (-0.05, 0.05), (-0.05, 0.5),\n        (0.05, 0.5), (0.05, 0.05), (0.5, 0.05), (0.5, -0.05),\n        (0.05, -0.05), (0.05, -0.5), (-0.05, -0.5), (-0.05, -0.05)\n    ],\n    \'p\': [(0, -0.5), (-0.4755, -0.1545), (-0.2939, 0.4045),\n          (0.2939, 0.4045), (0.4755, -0.1545)],\n    \'h\': [(0.433, 0.25), (0., 0.5), (-0.433, 0.25), (-0.433, -0.25),\n          (0, -0.5), (0.433, -0.25)],\n    \'star\': [(0, -0.5), (-0.1123, -0.1545), (-0.4755, -0.1545),\n             (-0.1816, 0.059), (-0.2939, 0.4045), (0, 0.1910),\n             (0.2939, 0.4045), (0.1816, 0.059), (0.4755, -0.1545),\n             (0.1123, -0.1545)]\n}\nfor k, c in coords.items():\n    Symbols[k].moveTo(*c[0])\n    for x,y in c[1:]:\n        Symbols[k].lineTo(x, y)\n    Symbols[k].closeSubpath()\ntr = QtGui.QTransform()\ntr.rotate(45)\nSymbols[\'x\'] = tr.map(Symbols[\'+\'])\n\n\ndef drawSymbol(painter, symbol, size, pen, brush):\n    if symbol is None:\n        return\n    painter.scale(size, size)\n    painter.setPen(pen)\n    painter.setBrush(brush)\n    if isinstance(symbol, basestring):\n        symbol = Symbols[symbol]\n    if np.isscalar(symbol):\n        symbol = list(Symbols.values())[symbol % len(Symbols)]\n    painter.drawPath(symbol)\n\n\ndef renderSymbol(symbol, size, pen, brush, device=None):\n    """"""\n    Render a symbol specification to QImage.\n    Symbol may be either a QPainterPath or one of the keys in the Symbols dict.\n    If *device* is None, a new QPixmap will be returned. Otherwise,\n    the symbol will be rendered into the device specified (See QPainter documentation\n    for more information).\n    """"""\n    ## Render a spot with the given parameters to a pixmap\n    penPxWidth = max(np.ceil(pen.widthF()), 1)\n    if device is None:\n        device = QtGui.QImage(int(size+penPxWidth), int(size+penPxWidth), QtGui.QImage.Format_ARGB32)\n        device.fill(0)\n    p = QtGui.QPainter(device)\n    try:\n        p.setRenderHint(p.Antialiasing)\n        p.translate(device.width()*0.5, device.height()*0.5)\n        drawSymbol(p, symbol, size, pen, brush)\n    finally:\n        p.end()\n    return device\n\ndef makeSymbolPixmap(size, pen, brush, symbol):\n    ## deprecated\n    img = renderSymbol(symbol, size, pen, brush)\n    return QtGui.QPixmap(img)\n\nclass SymbolAtlas(object):\n    """"""\n    Used to efficiently construct a single QPixmap containing all rendered symbols\n    for a ScatterPlotItem. This is required for fragment rendering.\n\n    Use example:\n        atlas = SymbolAtlas()\n        sc1 = atlas.getSymbolCoords(\'o\', 5, QPen(..), QBrush(..))\n        sc2 = atlas.getSymbolCoords(\'t\', 10, QPen(..), QBrush(..))\n        pm = atlas.getAtlas()\n\n    """"""\n    def __init__(self):\n        # symbol key : QRect(...) coordinates where symbol can be found in atlas.\n        # note that the coordinate list will always be the same list object as\n        # long as the symbol is in the atlas, but the coordinates may\n        # change if the atlas is rebuilt.\n        # weak value; if all external refs to this list disappear,\n        # the symbol will be forgotten.\n        self.symbolMap = weakref.WeakValueDictionary()\n\n        self.atlasData = None # numpy array of atlas image\n        self.atlas = None     # atlas as QPixmap\n        self.atlasValid = False\n        self.max_width=0\n\n    def getSymbolCoords(self, opts):\n        """"""\n        Given a list of spot records, return an object representing the coordinates of that symbol within the atlas\n        """"""\n        sourceRect = np.empty(len(opts), dtype=object)\n        keyi = None\n        sourceRecti = None\n        for i, rec in enumerate(opts):\n            key = (id(rec[3]), rec[2], id(rec[4]), id(rec[5]))   # TODO: use string indexes?\n            if key == keyi:\n                sourceRect[i] = sourceRecti\n            else:\n                try:\n                    sourceRect[i] = self.symbolMap[key]\n                except KeyError:\n                    newRectSrc = QtCore.QRectF()\n                    newRectSrc.pen = rec[\'pen\']\n                    newRectSrc.brush = rec[\'brush\']\n                    newRectSrc.symbol = rec[3]\n                    self.symbolMap[key] = newRectSrc\n                    self.atlasValid = False\n                    sourceRect[i] = newRectSrc\n                    keyi = key\n                    sourceRecti = newRectSrc\n        return sourceRect\n\n    def buildAtlas(self):\n        # get rendered array for all symbols, keep track of avg/max width\n        rendered = {}\n        avgWidth = 0.0\n        maxWidth = 0\n        images = []\n        for key, sourceRect in self.symbolMap.items():\n            if sourceRect.width() == 0:\n                img = renderSymbol(sourceRect.symbol, key[1], sourceRect.pen, sourceRect.brush)\n                images.append(img)  ## we only need this to prevent the images being garbage collected immediately\n                arr = fn.imageToArray(img, copy=False, transpose=False)\n            else:\n                (y,x,h,w) = sourceRect.getRect()\n                arr = self.atlasData[int(x):int(x+w), int(y):int(y+w)]\n            rendered[key] = arr\n            w = arr.shape[0]\n            avgWidth += w\n            maxWidth = max(maxWidth, w)\n\n        nSymbols = len(rendered)\n        if nSymbols > 0:\n            avgWidth /= nSymbols\n            width = max(maxWidth, avgWidth * (nSymbols**0.5))\n        else:\n            avgWidth = 0\n            width = 0\n\n        # sort symbols by height\n        symbols = sorted(rendered.keys(), key=lambda x: rendered[x].shape[1], reverse=True)\n\n        self.atlasRows = []\n\n        x = width\n        y = 0\n        rowheight = 0\n        for key in symbols:\n            arr = rendered[key]\n            w,h = arr.shape[:2]\n            if x+w > width:\n                y += rowheight\n                x = 0\n                rowheight = h\n                self.atlasRows.append([y, rowheight, 0])\n            self.symbolMap[key].setRect(y, x, h, w)\n            x += w\n            self.atlasRows[-1][2] = x\n        height = y + rowheight\n\n        self.atlasData = np.zeros((int(width), int(height), 4), dtype=np.ubyte)\n        for key in symbols:\n            y, x, h, w = self.symbolMap[key].getRect()\n            self.atlasData[int(x):int(x+w), int(y):int(y+h)] = rendered[key]\n        self.atlas = None\n        self.atlasValid = True\n        self.max_width = maxWidth\n\n    def getAtlas(self):\n        if not self.atlasValid:\n            self.buildAtlas()\n        if self.atlas is None:\n            if len(self.atlasData) == 0:\n                return QtGui.QPixmap(0,0)\n            img = fn.makeQImage(self.atlasData, copy=False, transpose=False)\n            self.atlas = QtGui.QPixmap(img)\n        return self.atlas\n\n\n\n\nclass ScatterPlotItem(GraphicsObject):\n    """"""\n    Displays a set of x/y points. Instances of this class are created\n    automatically as part of PlotDataItem; these rarely need to be instantiated\n    directly.\n\n    The size, shape, pen, and fill brush may be set for each point individually\n    or for all points.\n\n\n    ========================  ===============================================\n    **Signals:**\n    sigPlotChanged(self)      Emitted when the data being plotted has changed\n    sigClicked(self, points)  Emitted when the curve is clicked. Sends a list\n                              of all the points under the mouse pointer.\n    ========================  ===============================================\n\n    """"""\n    #sigPointClicked = QtCore.Signal(object, object)\n    sigClicked = QtCore.Signal(object, object)  ## self, points\n    sigPlotChanged = QtCore.Signal(object)\n    def __init__(self, *args, **kargs):\n        """"""\n        Accepts the same arguments as setData()\n        """"""\n        profiler = debug.Profiler()\n        GraphicsObject.__init__(self)\n\n        self.picture = None   # QPicture used for rendering when pxmode==False\n        self.fragmentAtlas = SymbolAtlas()\n\n        self.data = np.empty(0, dtype=[(\'x\', float), (\'y\', float), (\'size\', float), (\'symbol\', object), (\'pen\', object), (\'brush\', object), (\'data\', object), (\'item\', object), (\'sourceRect\', object), (\'targetRect\', object), (\'width\', float)])\n        self.bounds = [None, None]  ## caches data bounds\n        self._maxSpotWidth = 0      ## maximum size of the scale-variant portion of all spots\n        self._maxSpotPxWidth = 0    ## maximum size of the scale-invariant portion of all spots\n        self.opts = {\n            \'pxMode\': True,\n            \'useCache\': True,  ## If useCache is False, symbols are re-drawn on every paint.\n            \'antialias\': getConfigOption(\'antialias\'),\n            \'compositionMode\': None,\n            \'name\': None,\n        }\n\n        self.setPen(fn.mkPen(getConfigOption(\'foreground\')), update=False)\n        self.setBrush(fn.mkBrush(100,100,150), update=False)\n        self.setSymbol(\'o\', update=False)\n        self.setSize(7, update=False)\n        profiler()\n        self.setData(*args, **kargs)\n        profiler(\'setData\')\n\n        #self.setCacheMode(self.DeviceCoordinateCache)\n\n    def setData(self, *args, **kargs):\n        """"""\n        **Ordered Arguments:**\n\n        * If there is only one unnamed argument, it will be interpreted like the \'spots\' argument.\n        * If there are two unnamed arguments, they will be interpreted as sequences of x and y values.\n\n        ====================== ===============================================================================================\n        **Keyword Arguments:**\n        *spots*                Optional list of dicts. Each dict specifies parameters for a single spot:\n                               {\'pos\': (x,y), \'size\', \'pen\', \'brush\', \'symbol\'}. This is just an alternate method\n                               of passing in data for the corresponding arguments.\n        *x*,*y*                1D arrays of x,y values.\n        *pos*                  2D structure of x,y pairs (such as Nx2 array or list of tuples)\n        *pxMode*               If True, spots are always the same size regardless of scaling, and size is given in px.\n                               Otherwise, size is in scene coordinates and the spots scale with the view.\n                               Default is True\n        *symbol*               can be one (or a list) of:\n                               * \'o\'  circle (default)\n                               * \'s\'  square\n                               * \'t\'  triangle\n                               * \'d\'  diamond\n                               * \'+\'  plus\n                               * any QPainterPath to specify custom symbol shapes. To properly obey the position and size,\n                               custom symbols should be centered at (0,0) and width and height of 1.0. Note that it is also\n                               possible to \'install\' custom shapes by setting ScatterPlotItem.Symbols[key] = shape.\n        *pen*                  The pen (or list of pens) to use for drawing spot outlines.\n        *brush*                The brush (or list of brushes) to use for filling spots.\n        *size*                 The size (or list of sizes) of spots. If *pxMode* is True, this value is in pixels. Otherwise,\n                               it is in the item\'s local coordinate system.\n        *data*                 a list of python objects used to uniquely identify each spot.\n        *identical*            *Deprecated*. This functionality is handled automatically now.\n        *antialias*            Whether to draw symbols with antialiasing. Note that if pxMode is True, symbols are\n                               always rendered with antialiasing (since the rendered symbols can be cached, this\n                               incurs very little performance cost)\n        *compositionMode*      If specified, this sets the composition mode used when drawing the\n                               scatter plot (see QPainter::CompositionMode in the Qt documentation).\n        *name*                 The name of this item. Names are used for automatically\n                               generating LegendItem entries and by some exporters.\n        ====================== ===============================================================================================\n        """"""\n        oldData = self.data  ## this causes cached pixmaps to be preserved while new data is registered.\n        self.clear()  ## clear out all old data\n        self.addPoints(*args, **kargs)\n\n    def addPoints(self, *args, **kargs):\n        """"""\n        Add new points to the scatter plot.\n        Arguments are the same as setData()\n        """"""\n\n        ## deal with non-keyword arguments\n        if len(args) == 1:\n            kargs[\'spots\'] = args[0]\n        elif len(args) == 2:\n            kargs[\'x\'] = args[0]\n            kargs[\'y\'] = args[1]\n        elif len(args) > 2:\n            raise Exception(\'Only accepts up to two non-keyword arguments.\')\n\n        ## convert \'pos\' argument to \'x\' and \'y\'\n        if \'pos\' in kargs:\n            pos = kargs[\'pos\']\n            if isinstance(pos, np.ndarray):\n                kargs[\'x\'] = pos[:,0]\n                kargs[\'y\'] = pos[:,1]\n            else:\n                x = []\n                y = []\n                for p in pos:\n                    if isinstance(p, QtCore.QPointF):\n                        x.append(p.x())\n                        y.append(p.y())\n                    else:\n                        x.append(p[0])\n                        y.append(p[1])\n                kargs[\'x\'] = x\n                kargs[\'y\'] = y\n\n        ## determine how many spots we have\n        if \'spots\' in kargs:\n            numPts = len(kargs[\'spots\'])\n        elif \'y\' in kargs and kargs[\'y\'] is not None:\n            numPts = len(kargs[\'y\'])\n        else:\n            kargs[\'x\'] = []\n            kargs[\'y\'] = []\n            numPts = 0\n\n        ## Extend record array\n        oldData = self.data\n        self.data = np.empty(len(oldData)+numPts, dtype=self.data.dtype)\n        ## note that np.empty initializes object fields to None and string fields to \'\'\n\n        self.data[:len(oldData)] = oldData\n        #for i in range(len(oldData)):\n            #oldData[i][\'item\']._data = self.data[i]  ## Make sure items have proper reference to new array\n\n        newData = self.data[len(oldData):]\n        newData[\'size\'] = -1  ## indicates to use default size\n\n        if \'spots\' in kargs:\n            spots = kargs[\'spots\']\n            for i in range(len(spots)):\n                spot = spots[i]\n                for k in spot:\n                    if k == \'pos\':\n                        pos = spot[k]\n                        if isinstance(pos, QtCore.QPointF):\n                            x,y = pos.x(), pos.y()\n                        else:\n                            x,y = pos[0], pos[1]\n                        newData[i][\'x\'] = x\n                        newData[i][\'y\'] = y\n                    elif k == \'pen\':\n                        newData[i][k] = fn.mkPen(spot[k])\n                    elif k == \'brush\':\n                        newData[i][k] = fn.mkBrush(spot[k])\n                    elif k in [\'x\', \'y\', \'size\', \'symbol\', \'brush\', \'data\']:\n                        newData[i][k] = spot[k]\n                    else:\n                        raise Exception(""Unknown spot parameter: %s"" % k)\n        elif \'y\' in kargs:\n            newData[\'x\'] = kargs[\'x\']\n            newData[\'y\'] = kargs[\'y\']\n\n        if \'pxMode\' in kargs:\n            self.setPxMode(kargs[\'pxMode\'])\n        if \'antialias\' in kargs:\n            self.opts[\'antialias\'] = kargs[\'antialias\']\n\n        ## Set any extra parameters provided in keyword arguments\n        for k in [\'pen\', \'brush\', \'symbol\', \'size\']:\n            if k in kargs:\n                setMethod = getattr(self, \'set\' + k[0].upper() + k[1:])\n                setMethod(kargs[k], update=False, dataSet=newData, mask=kargs.get(\'mask\', None))\n\n        if \'data\' in kargs:\n            self.setPointData(kargs[\'data\'], dataSet=newData)\n\n        self.prepareGeometryChange()\n        self.informViewBoundsChanged()\n        self.bounds = [None, None]\n        self.invalidate()\n        self.updateSpots(newData)\n        self.sigPlotChanged.emit(self)\n\n    def invalidate(self):\n        ## clear any cached drawing state\n        self.picture = None\n        self.update()\n\n    def getData(self):\n        return self.data[\'x\'], self.data[\'y\']\n\n    def setPoints(self, *args, **kargs):\n        ##Deprecated; use setData\n        return self.setData(*args, **kargs)\n\n    def implements(self, interface=None):\n        ints = [\'plotData\']\n        if interface is None:\n            return ints\n        return interface in ints\n\n    def name(self):\n        return self.opts.get(\'name\', None)\n\n    def setPen(self, *args, **kargs):\n        """"""Set the pen(s) used to draw the outline around each spot.\n        If a list or array is provided, then the pen for each spot will be set separately.\n        Otherwise, the arguments are passed to pg.mkPen and used as the default pen for\n        all spots which do not have a pen explicitly set.""""""\n        update = kargs.pop(\'update\', True)\n        dataSet = kargs.pop(\'dataSet\', self.data)\n\n        if len(args) == 1 and (isinstance(args[0], np.ndarray) or isinstance(args[0], list)):\n            pens = args[0]\n            if \'mask\' in kargs and kargs[\'mask\'] is not None:\n                pens = pens[kargs[\'mask\']]\n            if len(pens) != len(dataSet):\n                raise Exception(""Number of pens does not match number of points (%d != %d)"" % (len(pens), len(dataSet)))\n            dataSet[\'pen\'] = pens\n        else:\n            self.opts[\'pen\'] = fn.mkPen(*args, **kargs)\n\n        dataSet[\'sourceRect\'] = None\n        if update:\n            self.updateSpots(dataSet)\n\n    def setBrush(self, *args, **kargs):\n        """"""Set the brush(es) used to fill the interior of each spot.\n        If a list or array is provided, then the brush for each spot will be set separately.\n        Otherwise, the arguments are passed to pg.mkBrush and used as the default brush for\n        all spots which do not have a brush explicitly set.""""""\n        update = kargs.pop(\'update\', True)\n        dataSet = kargs.pop(\'dataSet\', self.data)\n\n        if len(args) == 1 and (isinstance(args[0], np.ndarray) or isinstance(args[0], list)):\n            brushes = args[0]\n            if \'mask\' in kargs and kargs[\'mask\'] is not None:\n                brushes = brushes[kargs[\'mask\']]\n            if len(brushes) != len(dataSet):\n                raise Exception(""Number of brushes does not match number of points (%d != %d)"" % (len(brushes), len(dataSet)))\n            dataSet[\'brush\'] = brushes\n        else:\n            self.opts[\'brush\'] = fn.mkBrush(*args, **kargs)\n            #self._spotPixmap = None\n\n        dataSet[\'sourceRect\'] = None\n        if update:\n            self.updateSpots(dataSet)\n\n    def setSymbol(self, symbol, update=True, dataSet=None, mask=None):\n        """"""Set the symbol(s) used to draw each spot.\n        If a list or array is provided, then the symbol for each spot will be set separately.\n        Otherwise, the argument will be used as the default symbol for\n        all spots which do not have a symbol explicitly set.""""""\n        if dataSet is None:\n            dataSet = self.data\n\n        if isinstance(symbol, np.ndarray) or isinstance(symbol, list):\n            symbols = symbol\n            if mask is not None:\n                symbols = symbols[mask]\n            if len(symbols) != len(dataSet):\n                raise Exception(""Number of symbols does not match number of points (%d != %d)"" % (len(symbols), len(dataSet)))\n            dataSet[\'symbol\'] = symbols\n        else:\n            self.opts[\'symbol\'] = symbol\n            self._spotPixmap = None\n\n        dataSet[\'sourceRect\'] = None\n        if update:\n            self.updateSpots(dataSet)\n\n    def setSize(self, size, update=True, dataSet=None, mask=None):\n        """"""Set the size(s) used to draw each spot.\n        If a list or array is provided, then the size for each spot will be set separately.\n        Otherwise, the argument will be used as the default size for\n        all spots which do not have a size explicitly set.""""""\n        if dataSet is None:\n            dataSet = self.data\n\n        if isinstance(size, np.ndarray) or isinstance(size, list):\n            sizes = size\n            if mask is not None:\n                sizes = sizes[mask]\n            if len(sizes) != len(dataSet):\n                raise Exception(""Number of sizes does not match number of points (%d != %d)"" % (len(sizes), len(dataSet)))\n            dataSet[\'size\'] = sizes\n        else:\n            self.opts[\'size\'] = size\n            self._spotPixmap = None\n\n        dataSet[\'sourceRect\'] = None\n        if update:\n            self.updateSpots(dataSet)\n\n    def setPointData(self, data, dataSet=None, mask=None):\n        if dataSet is None:\n            dataSet = self.data\n\n        if isinstance(data, np.ndarray) or isinstance(data, list):\n            if mask is not None:\n                data = data[mask]\n            if len(data) != len(dataSet):\n                raise Exception(""Length of meta data does not match number of points (%d != %d)"" % (len(data), len(dataSet)))\n\n        ## Bug: If data is a numpy record array, then items from that array must be copied to dataSet one at a time.\n        ## (otherwise they are converted to tuples and thus lose their field names.\n        if isinstance(data, np.ndarray) and (data.dtype.fields is not None)and len(data.dtype.fields) > 1:\n            for i, rec in enumerate(data):\n                dataSet[\'data\'][i] = rec\n        else:\n            dataSet[\'data\'] = data\n\n    def setPxMode(self, mode):\n        if self.opts[\'pxMode\'] == mode:\n            return\n\n        self.opts[\'pxMode\'] = mode\n        self.invalidate()\n\n    def updateSpots(self, dataSet=None):\n        if dataSet is None:\n            dataSet = self.data\n\n        invalidate = False\n        if self.opts[\'pxMode\']:\n            mask = np.equal(dataSet[\'sourceRect\'], None)\n            if np.any(mask):\n                invalidate = True\n                opts = self.getSpotOpts(dataSet[mask])\n                sourceRect = self.fragmentAtlas.getSymbolCoords(opts)\n                dataSet[\'sourceRect\'][mask] = sourceRect\n\n            self.fragmentAtlas.getAtlas() # generate atlas so source widths are available.\n\n            dataSet[\'width\'] = np.array(list(imap(QtCore.QRectF.width, dataSet[\'sourceRect\'])))/2\n            dataSet[\'targetRect\'] = None\n            self._maxSpotPxWidth = self.fragmentAtlas.max_width\n        else:\n            self._maxSpotWidth = 0\n            self._maxSpotPxWidth = 0\n            self.measureSpotSizes(dataSet)\n\n        if invalidate:\n            self.invalidate()\n\n    def getSpotOpts(self, recs, scale=1.0):\n        if recs.ndim == 0:\n            rec = recs\n            symbol = rec[\'symbol\']\n            if symbol is None:\n                symbol = self.opts[\'symbol\']\n            size = rec[\'size\']\n            if size < 0:\n                size = self.opts[\'size\']\n            pen = rec[\'pen\']\n            if pen is None:\n                pen = self.opts[\'pen\']\n            brush = rec[\'brush\']\n            if brush is None:\n                brush = self.opts[\'brush\']\n            return (symbol, size*scale, fn.mkPen(pen), fn.mkBrush(brush))\n        else:\n            recs = recs.copy()\n            recs[\'symbol\'][np.equal(recs[\'symbol\'], None)] = self.opts[\'symbol\']\n            recs[\'size\'][np.equal(recs[\'size\'], -1)] = self.opts[\'size\']\n            recs[\'size\'] *= scale\n            recs[\'pen\'][np.equal(recs[\'pen\'], None)] = fn.mkPen(self.opts[\'pen\'])\n            recs[\'brush\'][np.equal(recs[\'brush\'], None)] = fn.mkBrush(self.opts[\'brush\'])\n            return recs\n\n\n\n    def measureSpotSizes(self, dataSet):\n        for rec in dataSet:\n            ## keep track of the maximum spot size and pixel size\n            symbol, size, pen, brush = self.getSpotOpts(rec)\n            width = 0\n            pxWidth = 0\n            if self.opts[\'pxMode\']:\n                pxWidth = size + pen.widthF()\n            else:\n                width = size\n                if pen.isCosmetic():\n                    pxWidth += pen.widthF()\n                else:\n                    width += pen.widthF()\n            self._maxSpotWidth = max(self._maxSpotWidth, width)\n            self._maxSpotPxWidth = max(self._maxSpotPxWidth, pxWidth)\n        self.bounds = [None, None]\n\n\n    def clear(self):\n        """"""Remove all spots from the scatter plot""""""\n        #self.clearItems()\n        self.data = np.empty(0, dtype=self.data.dtype)\n        self.bounds = [None, None]\n        self.invalidate()\n\n    def dataBounds(self, ax, frac=1.0, orthoRange=None):\n        if frac >= 1.0 and orthoRange is None and self.bounds[ax] is not None:\n            return self.bounds[ax]\n\n        #self.prepareGeometryChange()\n        if self.data is None or len(self.data) == 0:\n            return (None, None)\n\n        if ax == 0:\n            d = self.data[\'x\']\n            d2 = self.data[\'y\']\n        elif ax == 1:\n            d = self.data[\'y\']\n            d2 = self.data[\'x\']\n\n        if orthoRange is not None:\n            mask = (d2 >= orthoRange[0]) * (d2 <= orthoRange[1])\n            d = d[mask]\n            d2 = d2[mask]\n\n            if d.size == 0:\n                return (None, None)\n\n        if frac >= 1.0:\n            self.bounds[ax] = (np.nanmin(d) - self._maxSpotWidth*0.7072, np.nanmax(d) + self._maxSpotWidth*0.7072)\n            return self.bounds[ax]\n        elif frac <= 0.0:\n            raise Exception(""Value for parameter \'frac\' must be > 0. (got %s)"" % str(frac))\n        else:\n            mask = np.isfinite(d)\n            d = d[mask]\n            return np.percentile(d, [50 * (1 - frac), 50 * (1 + frac)])\n\n    def pixelPadding(self):\n        return self._maxSpotPxWidth*0.7072\n\n    def boundingRect(self):\n        (xmn, xmx) = self.dataBounds(ax=0)\n        (ymn, ymx) = self.dataBounds(ax=1)\n        if xmn is None or xmx is None:\n            xmn = 0\n            xmx = 0\n        if ymn is None or ymx is None:\n            ymn = 0\n            ymx = 0\n\n        px = py = 0.0\n        pxPad = self.pixelPadding()\n        if pxPad > 0:\n            # determine length of pixel in local x, y directions\n            px, py = self.pixelVectors()\n            try:\n                px = 0 if px is None else px.length()\n            except OverflowError:\n                px = 0\n            try:\n                py = 0 if py is None else py.length()\n            except OverflowError:\n                py = 0\n\n            # return bounds expanded by pixel size\n            px *= pxPad\n            py *= pxPad\n        return QtCore.QRectF(xmn-px, ymn-py, (2*px)+xmx-xmn, (2*py)+ymx-ymn)\n\n    def viewTransformChanged(self):\n        self.prepareGeometryChange()\n        GraphicsObject.viewTransformChanged(self)\n        self.bounds = [None, None]\n        self.data[\'targetRect\'] = None\n\n    def setExportMode(self, *args, **kwds):\n        GraphicsObject.setExportMode(self, *args, **kwds)\n        self.invalidate()\n\n    def mapPointsToDevice(self, pts):\n        # Map point locations to device\n        tr = self.deviceTransform()\n        if tr is None:\n            return None\n\n        pts = fn.transformCoordinates(tr, pts)\n        pts -= self.data[\'width\']\n        pts = np.clip(pts, -2**30, 2**30) ## prevent Qt segmentation fault.\n\n        return pts\n\n    def getViewMask(self, pts):\n        # Return bool mask indicating all points that are within viewbox\n        # pts is expressed in *device coordiantes*\n        vb = self.getViewBox()\n        if vb is None:\n            return None\n        viewBounds = vb.mapRectToDevice(vb.boundingRect())\n        w = self.data[\'width\']\n        mask = ((pts[0] + w > viewBounds.left()) &\n                (pts[0] - w < viewBounds.right()) &\n                (pts[1] + w > viewBounds.top()) &\n                (pts[1] - w < viewBounds.bottom())) ## remove out of view points\n        return mask\n\n    @debug.warnOnException  ## raising an exception here causes crash\n    def paint(self, p, *args):\n        cmode = self.opts.get(\'compositionMode\', None)\n        if cmode is not None:\n            p.setCompositionMode(cmode)\n        #p.setPen(fn.mkPen(\'r\'))\n        #p.drawRect(self.boundingRect())\n\n        if self._exportOpts is not False:\n            aa = self._exportOpts.get(\'antialias\', True)\n            scale = self._exportOpts.get(\'resolutionScale\', 1.0)  ## exporting to image; pixel resolution may have changed\n        else:\n            aa = self.opts[\'antialias\']\n            scale = 1.0\n\n        if self.opts[\'pxMode\'] is True:\n            p.resetTransform()\n\n            # Map point coordinates to device\n            pts = np.vstack([self.data[\'x\'], self.data[\'y\']])\n            pts = self.mapPointsToDevice(pts)\n            if pts is None:\n                return\n\n            # Cull points that are outside view\n            viewMask = self.getViewMask(pts)\n\n            if self.opts[\'useCache\'] and self._exportOpts is False:\n                # Draw symbols from pre-rendered atlas\n                atlas = self.fragmentAtlas.getAtlas()\n\n                # Update targetRects if necessary\n                updateMask = viewMask & np.equal(self.data[\'targetRect\'], None)\n                if np.any(updateMask):\n                    updatePts = pts[:,updateMask]\n                    width = self.data[updateMask][\'width\']*2\n                    self.data[\'targetRect\'][updateMask] = list(imap(QtCore.QRectF, updatePts[0,:], updatePts[1,:], width, width))\n\n                data = self.data[viewMask]\n                if QT_LIB == \'PyQt4\':\n                    p.drawPixmapFragments(data[\'targetRect\'].tolist(), data[\'sourceRect\'].tolist(), atlas)\n                else:\n                    list(imap(p.drawPixmap, data[\'targetRect\'], repeat(atlas), data[\'sourceRect\']))\n            else:\n                # render each symbol individually\n                p.setRenderHint(p.Antialiasing, aa)\n\n                data = self.data[viewMask]\n                pts = pts[:,viewMask]\n                for i, rec in enumerate(data):\n                    p.resetTransform()\n                    p.translate(pts[0,i] + rec[\'width\'], pts[1,i] + rec[\'width\'])\n                    drawSymbol(p, *self.getSpotOpts(rec, scale))\n        else:\n            if self.picture is None:\n                self.picture = QtGui.QPicture()\n                p2 = QtGui.QPainter(self.picture)\n                for rec in self.data:\n                    if scale != 1.0:\n                        rec = rec.copy()\n                        rec[\'size\'] *= scale\n                    p2.resetTransform()\n                    p2.translate(rec[\'x\'], rec[\'y\'])\n                    drawSymbol(p2, *self.getSpotOpts(rec, scale))\n                p2.end()\n\n            p.setRenderHint(p.Antialiasing, aa)\n            self.picture.play(p)\n\n    def points(self):\n        for i,rec in enumerate(self.data):\n            if rec[\'item\'] is None:\n                rec[\'item\'] = SpotItem(rec, self, i)\n        return self.data[\'item\']\n\n    def pointsAt(self, pos):\n        x = pos.x()\n        y = pos.y()\n        pw = self.pixelWidth()\n        ph = self.pixelHeight()\n        pts = []\n        for s in self.points():\n            sp = s.pos()\n            ss = s.size()\n            sx = sp.x()\n            sy = sp.y()\n            s2x = s2y = ss * 0.5\n            if self.opts[\'pxMode\']:\n                s2x *= pw\n                s2y *= ph\n            if x > sx-s2x and x < sx+s2x and y > sy-s2y and y < sy+s2y:\n                pts.append(s)\n                #print ""HIT:"", x, y, sx, sy, s2x, s2y\n            #else:\n                #print ""No hit:"", (x, y), (sx, sy)\n                #print ""       "", (sx-s2x, sy-s2y), (sx+s2x, sy+s2y)\n        return pts[::-1]\n\n\n    def mouseClickEvent(self, ev):\n        if ev.button() == QtCore.Qt.LeftButton:\n            pts = self.pointsAt(ev.pos())\n            if len(pts) > 0:\n                self.ptsClicked = pts\n                self.sigClicked.emit(self, self.ptsClicked)\n                ev.accept()\n            else:\n                #print ""no spots""\n                ev.ignore()\n        else:\n            ev.ignore()\n\n\nclass SpotItem(object):\n    """"""\n    Class referring to individual spots in a scatter plot.\n    These can be retrieved by calling ScatterPlotItem.points() or\n    by connecting to the ScatterPlotItem\'s click signals.\n    """"""\n\n    def __init__(self, data, plot, index):\n        self._data = data\n        self._index = index\n        # SpotItems are kept in plot.data[""items""] numpy object array which\n        # does not support cyclic garbage collection (numpy issue 6581).\n        # Keeping a strong ref to plot here would leak the cycle\n        self.__plot_ref = weakref.ref(plot)\n\n    @property\n    def _plot(self):\n        return self.__plot_ref()\n\n    def data(self):\n        """"""Return the user data associated with this spot.""""""\n        return self._data[\'data\']\n\n    def index(self):\n        """"""Return the index of this point as given in the scatter plot data.""""""\n        return self._index\n\n    def size(self):\n        """"""Return the size of this spot.\n        If the spot has no explicit size set, then return the ScatterPlotItem\'s default size instead.""""""\n        if self._data[\'size\'] == -1:\n            return self._plot.opts[\'size\']\n        else:\n            return self._data[\'size\']\n\n    def pos(self):\n        return Point(self._data[\'x\'], self._data[\'y\'])\n\n    def viewPos(self):\n        return self._plot.mapToView(self.pos())\n\n    def setSize(self, size):\n        """"""Set the size of this spot.\n        If the size is set to -1, then the ScatterPlotItem\'s default size\n        will be used instead.""""""\n        self._data[\'size\'] = size\n        self.updateItem()\n\n    def symbol(self):\n        """"""Return the symbol of this spot.\n        If the spot has no explicit symbol set, then return the ScatterPlotItem\'s default symbol instead.\n        """"""\n        symbol = self._data[\'symbol\']\n        if symbol is None:\n            symbol = self._plot.opts[\'symbol\']\n        try:\n            n = int(symbol)\n            symbol = list(Symbols.keys())[n % len(Symbols)]\n        except:\n            pass\n        return symbol\n\n    def setSymbol(self, symbol):\n        """"""Set the symbol for this spot.\n        If the symbol is set to \'\', then the ScatterPlotItem\'s default symbol will be used instead.""""""\n        self._data[\'symbol\'] = symbol\n        self.updateItem()\n\n    def pen(self):\n        pen = self._data[\'pen\']\n        if pen is None:\n            pen = self._plot.opts[\'pen\']\n        return fn.mkPen(pen)\n\n    def setPen(self, *args, **kargs):\n        """"""Set the outline pen for this spot""""""\n        pen = fn.mkPen(*args, **kargs)\n        self._data[\'pen\'] = pen\n        self.updateItem()\n\n    def resetPen(self):\n        """"""Remove the pen set for this spot; the scatter plot\'s default pen will be used instead.""""""\n        self._data[\'pen\'] = None  ## Note this is NOT the same as calling setPen(None)\n        self.updateItem()\n\n    def brush(self):\n        brush = self._data[\'brush\']\n        if brush is None:\n            brush = self._plot.opts[\'brush\']\n        return fn.mkBrush(brush)\n\n    def setBrush(self, *args, **kargs):\n        """"""Set the fill brush for this spot""""""\n        brush = fn.mkBrush(*args, **kargs)\n        self._data[\'brush\'] = brush\n        self.updateItem()\n\n    def resetBrush(self):\n        """"""Remove the brush set for this spot; the scatter plot\'s default brush will be used instead.""""""\n        self._data[\'brush\'] = None  ## Note this is NOT the same as calling setBrush(None)\n        self.updateItem()\n\n    def setData(self, data):\n        """"""Set the user-data associated with this spot""""""\n        self._data[\'data\'] = data\n\n    def updateItem(self):\n        self._data[\'sourceRect\'] = None\n        self._plot.updateSpots(self._data.reshape(1))\n        self._plot.invalidate()\n'"
src/third_party/pyqtgraph/graphicsItems/TargetItem.py,4,"b'from ..Qt import QtGui, QtCore\nimport numpy as np\nfrom ..Point import Point\nfrom .. import functions as fn\nfrom .GraphicsObject import GraphicsObject\nfrom .TextItem import TextItem\n\n\nclass TargetItem(GraphicsObject):\n    """"""Draws a draggable target symbol (circle plus crosshair).\n\n    The size of TargetItem will remain fixed on screen even as the view is zoomed.\n    Includes an optional text label.\n    """"""\n    sigDragged = QtCore.Signal(object)\n\n    def __init__(self, movable=True, radii=(5, 10, 10), pen=(255, 255, 0), brush=(0, 0, 255, 100)):\n        GraphicsObject.__init__(self)\n        self._bounds = None\n        self._radii = radii\n        self._picture = None\n        self.movable = movable\n        self.moving = False\n        self.label = None\n        self.labelAngle = 0\n        self.pen = fn.mkPen(pen)\n        self.brush = fn.mkBrush(brush)\n\n    def setLabel(self, label):\n        if label is None:\n            if self.label is not None:\n                self.label.scene().removeItem(self.label)\n                self.label = None\n        else:\n            if self.label is None:\n                self.label = TextItem()\n                self.label.setParentItem(self)\n            self.label.setText(label)\n            self._updateLabel()\n\n    def setLabelAngle(self, angle):\n        self.labelAngle = angle\n        self._updateLabel()\n\n    def boundingRect(self):\n        if self._picture is None:\n            self._drawPicture()\n        return self._bounds\n    \n    def dataBounds(self, axis, frac=1.0, orthoRange=None):\n        return [0, 0]\n\n    def viewTransformChanged(self):\n        self._picture = None\n        self.prepareGeometryChange()\n        self._updateLabel()\n\n    def _updateLabel(self):\n        if self.label is None:\n            return\n\n        # find an optimal location for text at the given angle\n        angle = self.labelAngle * np.pi / 180.\n        lbr = self.label.boundingRect()\n        center = lbr.center()\n        a = abs(np.sin(angle) * lbr.height()*0.5)\n        b = abs(np.cos(angle) * lbr.width()*0.5)\n        r = max(self._radii) + 2 + max(a, b)\n        pos = self.mapFromScene(self.mapToScene(QtCore.QPointF(0, 0)) + r * QtCore.QPointF(np.cos(angle), -np.sin(angle)) - center)\n        self.label.setPos(pos)\n\n    def paint(self, p, *args):\n        if self._picture is None:\n            self._drawPicture()\n        self._picture.play(p)\n\n    def _drawPicture(self):\n        self._picture = QtGui.QPicture()\n        p = QtGui.QPainter(self._picture)\n        p.setRenderHint(p.Antialiasing)\n        \n        # Note: could do this with self.pixelLength, but this is faster.\n        o = self.mapToScene(QtCore.QPointF(0, 0))\n        px = abs(1.0 / (self.mapToScene(QtCore.QPointF(1, 0)) - o).x())\n        py = abs(1.0 / (self.mapToScene(QtCore.QPointF(0, 1)) - o).y())\n        \n        r, w, h = self._radii\n        w = w * px\n        h = h * py\n        rx = r * px\n        ry = r * py\n        rect = QtCore.QRectF(-rx, -ry, rx*2, ry*2)\n        p.setPen(self.pen)\n        p.setBrush(self.brush)\n        p.drawEllipse(rect)\n        p.drawLine(Point(-w, 0), Point(w, 0))\n        p.drawLine(Point(0, -h), Point(0, h))\n        p.end()\n        \n        bx = max(w, rx)\n        by = max(h, ry)\n        self._bounds = QtCore.QRectF(-bx, -by, bx*2, by*2)\n\n    def mouseDragEvent(self, ev):\n        if not self.movable:\n            return\n        if ev.button() == QtCore.Qt.LeftButton:\n            if ev.isStart():\n                self.moving = True\n                self.cursorOffset = self.pos() - self.mapToParent(ev.buttonDownPos())\n                self.startPosition = self.pos()\n            ev.accept()\n            \n            if not self.moving:\n                return\n                \n            self.setPos(self.cursorOffset + self.mapToParent(ev.pos()))\n            if ev.isFinish():\n                self.moving = False\n                self.sigDragged.emit(self)\n\n    def hoverEvent(self, ev):\n        if self.movable:\n            ev.acceptDrags(QtCore.Qt.LeftButton)\n\n'"
src/third_party/pyqtgraph/graphicsItems/TextItem.py,1,"b'import numpy as np\nfrom ..Qt import QtCore, QtGui\nfrom ..Point import Point\nfrom .. import functions as fn\nfrom .GraphicsObject import GraphicsObject\n\n\nclass TextItem(GraphicsObject):\n    """"""\n    GraphicsItem displaying unscaled text (the text will always appear normal even inside a scaled ViewBox). \n    """"""\n    def __init__(self, text=\'\', color=(200,200,200), html=None, anchor=(0,0),\n                 border=None, fill=None, angle=0, rotateAxis=None):\n        """"""\n        ==============  =================================================================================\n        **Arguments:**\n        *text*          The text to display\n        *color*         The color of the text (any format accepted by pg.mkColor)\n        *html*          If specified, this overrides both *text* and *color*\n        *anchor*        A QPointF or (x,y) sequence indicating what region of the text box will\n                        be anchored to the item\'s position. A value of (0,0) sets the upper-left corner\n                        of the text box to be at the position specified by setPos(), while a value of (1,1)\n                        sets the lower-right corner.\n        *border*        A pen to use when drawing the border\n        *fill*          A brush to use when filling within the border\n        *angle*         Angle in degrees to rotate text. Default is 0; text will be displayed upright.\n        *rotateAxis*    If None, then a text angle of 0 always points along the +x axis of the scene.\n                        If a QPointF or (x,y) sequence is given, then it represents a vector direction\n                        in the parent\'s coordinate system that the 0-degree line will be aligned to. This\n                        Allows text to follow both the position and orientation of its parent while still\n                        discarding any scale and shear factors.\n        ==============  =================================================================================\n\n\n        The effects of the `rotateAxis` and `angle` arguments are added independently. So for example:\n\n        * rotateAxis=None, angle=0 -> normal horizontal text\n        * rotateAxis=None, angle=90 -> normal vertical text\n        * rotateAxis=(1, 0), angle=0 -> text aligned with x axis of its parent\n        * rotateAxis=(0, 1), angle=0 -> text aligned with y axis of its parent\n        * rotateAxis=(1, 0), angle=90 -> text orthogonal to x axis of its parent        \n        """"""\n                     \n        self.anchor = Point(anchor)\n        self.rotateAxis = None if rotateAxis is None else Point(rotateAxis)\n        #self.angle = 0\n        GraphicsObject.__init__(self)\n        self.textItem = QtGui.QGraphicsTextItem()\n        self.textItem.setParentItem(self)\n        self._lastTransform = None\n        self._lastScene = None\n        self._bounds = QtCore.QRectF()\n        if html is None:\n            self.setColor(color)\n            self.setText(text)\n        else:\n            self.setHtml(html)\n        self.fill = fn.mkBrush(fill)\n        self.border = fn.mkPen(border)\n        self.setAngle(angle)\n\n    def setText(self, text, color=None):\n        """"""\n        Set the text of this item. \n        \n        This method sets the plain text of the item; see also setHtml().\n        """"""\n        if color is not None:\n            self.setColor(color)\n        self.textItem.setPlainText(text)\n        self.updateTextPos()\n        \n    def setPlainText(self, *args):\n        """"""\n        Set the plain text to be rendered by this item. \n        \n        See QtGui.QGraphicsTextItem.setPlainText().\n        """"""\n        self.textItem.setPlainText(*args)\n        self.updateTextPos()\n        \n    def setHtml(self, *args):\n        """"""\n        Set the HTML code to be rendered by this item. \n        \n        See QtGui.QGraphicsTextItem.setHtml().\n        """"""\n        self.textItem.setHtml(*args)\n        self.updateTextPos()\n        \n    def setTextWidth(self, *args):\n        """"""\n        Set the width of the text.\n        \n        If the text requires more space than the width limit, then it will be\n        wrapped into multiple lines.\n        \n        See QtGui.QGraphicsTextItem.setTextWidth().\n        """"""\n        self.textItem.setTextWidth(*args)\n        self.updateTextPos()\n        \n    def setFont(self, *args):\n        """"""\n        Set the font for this text. \n        \n        See QtGui.QGraphicsTextItem.setFont().\n        """"""\n        self.textItem.setFont(*args)\n        self.updateTextPos()\n        \n    def setAngle(self, angle):\n        self.angle = angle\n        self.updateTransform()\n        \n    def setAnchor(self, anchor):\n        self.anchor = Point(anchor)\n        self.updateTextPos()\n\n    def setColor(self, color):\n        """"""\n        Set the color for this text.\n        \n        See QtGui.QGraphicsItem.setDefaultTextColor().\n        """"""\n        self.color = fn.mkColor(color)\n        self.textItem.setDefaultTextColor(self.color)\n        \n    def updateTextPos(self):\n        # update text position to obey anchor\n        r = self.textItem.boundingRect()\n        tl = self.textItem.mapToParent(r.topLeft())\n        br = self.textItem.mapToParent(r.bottomRight())\n        offset = (br - tl) * self.anchor\n        self.textItem.setPos(-offset)\n        \n        ### Needed to maintain font size when rendering to image with increased resolution\n        #self.textItem.resetTransform()\n        ##self.textItem.rotate(self.angle)\n        #if self._exportOpts is not False and \'resolutionScale\' in self._exportOpts:\n            #s = self._exportOpts[\'resolutionScale\']\n            #self.textItem.scale(s, s)\n        \n    def boundingRect(self):\n        return self.textItem.mapToParent(self.textItem.boundingRect()).boundingRect()\n\n    def viewTransformChanged(self):\n        # called whenever view transform has changed.\n        # Do this here to avoid double-updates when view changes.\n        self.updateTransform()\n        \n    def paint(self, p, *args):\n        # this is not ideal because it requires the transform to be updated at every draw.\n        # ideally, we would have a sceneTransformChanged event to react to..\n        s = self.scene()\n        ls = self._lastScene\n        if s is not ls:\n            if ls is not None:\n                ls.sigPrepareForPaint.disconnect(self.updateTransform)\n            self._lastScene = s\n            if s is not None:\n                s.sigPrepareForPaint.connect(self.updateTransform)\n            self.updateTransform()\n            p.setTransform(self.sceneTransform())\n        \n        if self.border.style() != QtCore.Qt.NoPen or self.fill.style() != QtCore.Qt.NoBrush:\n            p.setPen(self.border)\n            p.setBrush(self.fill)\n            p.setRenderHint(p.Antialiasing, True)\n            p.drawPolygon(self.textItem.mapToParent(self.textItem.boundingRect()))\n        \n    def updateTransform(self):\n        # update transform such that this item has the correct orientation\n        # and scaling relative to the scene, but inherits its position from its\n        # parent.\n        # This is similar to setting ItemIgnoresTransformations = True, but \n        # does not break mouse interaction and collision detection.\n        p = self.parentItem()\n        if p is None:\n            pt = QtGui.QTransform()\n        else:\n            pt = p.sceneTransform()\n        \n        if pt == self._lastTransform:\n            return\n\n        t = pt.inverted()[0]\n        # reset translation\n        t.setMatrix(t.m11(), t.m12(), t.m13(), t.m21(), t.m22(), t.m23(), 0, 0, t.m33())\n        \n        # apply rotation\n        angle = -self.angle\n        if self.rotateAxis is not None:\n            d = pt.map(self.rotateAxis) - pt.map(Point(0, 0))\n            a = np.arctan2(d.y(), d.x()) * 180 / np.pi\n            angle += a\n        t.rotate(angle)\n        \n        self.setTransform(t)\n        \n        self._lastTransform = pt\n        \n        self.updateTextPos()\n'"
src/third_party/pyqtgraph/graphicsItems/UIGraphicsItem.py,0,"b'from ..Qt import QtGui, QtCore, QT_LIB\nimport weakref\nfrom .GraphicsObject import GraphicsObject\nif QT_LIB in [\'PyQt4\', \'PyQt5\']:\n    import sip\n\n__all__ = [\'UIGraphicsItem\']\nclass UIGraphicsItem(GraphicsObject):\n    """"""\n    Base class for graphics items with boundaries relative to a GraphicsView or ViewBox.\n    The purpose of this class is to allow the creation of GraphicsItems which live inside \n    a scalable view, but whose boundaries will always stay fixed relative to the view\'s boundaries.\n    For example: GridItem, InfiniteLine\n    \n    The view can be specified on initialization or it can be automatically detected when the item is painted.\n    \n    NOTE: Only the item\'s boundingRect is affected; the item is not transformed in any way. Use viewRangeChanged\n    to respond to changes in the view.\n    """"""\n    \n    #sigViewChanged = QtCore.Signal(object)  ## emitted whenever the viewport coords have changed\n    \n    def __init__(self, bounds=None, parent=None):\n        """"""\n        ============== =============================================================================\n        **Arguments:**\n        bounds         QRectF with coordinates relative to view box. The default is QRectF(0,0,1,1),\n                       which means the item will have the same bounds as the view.\n        ============== =============================================================================\n        """"""\n        GraphicsObject.__init__(self, parent)\n        self.setFlag(self.ItemSendsScenePositionChanges)\n            \n        if bounds is None:\n            self._bounds = QtCore.QRectF(0, 0, 1, 1)\n        else:\n            self._bounds = bounds\n            \n        self._boundingRect = None\n        self._updateView()\n        \n    def paint(self, *args):\n        ## check for a new view object every time we paint.\n        #self.updateView()\n        pass\n    \n    def itemChange(self, change, value):\n        ret = GraphicsObject.itemChange(self, change, value)\n            \n        ## workaround for pyqt bug:\n        ## http://www.riverbankcomputing.com/pipermail/pyqt/2012-August/031818.html\n        if QT_LIB in [\'PyQt4\', \'PyQt5\'] and change == self.ItemParentChange and isinstance(ret, QtGui.QGraphicsItem):\n            ret = sip.cast(ret, QtGui.QGraphicsItem)\n        \n        if change == self.ItemScenePositionHasChanged:\n            self.setNewBounds()\n        return ret\n    \n    #def updateView(self):\n        ### called to see whether this item has a new view to connect to\n        \n        ### check for this item\'s current viewbox or view widget\n        #view = self.getViewBox()\n        #if view is None:\n            ##print ""  no view""\n            #return\n            \n        #if self._connectedView is not None and view is self._connectedView():\n            ##print ""  already have view"", view\n            #return\n            \n        ### disconnect from previous view\n        #if self._connectedView is not None:\n            #cv = self._connectedView()\n            #if cv is not None:\n                ##print ""disconnect:"", self\n                #cv.sigRangeChanged.disconnect(self.viewRangeChanged)\n            \n        ### connect to new view\n        ##print ""connect:"", self\n        #view.sigRangeChanged.connect(self.viewRangeChanged)\n        #self._connectedView = weakref.ref(view)\n        #self.setNewBounds()\n\n    def boundingRect(self):\n        if self._boundingRect is None:\n            br = self.viewRect()\n            if br is None:\n                return QtCore.QRectF()\n            else:\n                self._boundingRect = br\n        return QtCore.QRectF(self._boundingRect)\n    \n    def dataBounds(self, axis, frac=1.0, orthoRange=None):\n        """"""Called by ViewBox for determining the auto-range bounds.\n        By default, UIGraphicsItems are excluded from autoRange.""""""\n        return None\n\n    def viewRangeChanged(self):\n        """"""Called when the view widget/viewbox is resized/rescaled""""""\n        self.setNewBounds()\n        self.update()\n        \n    def setNewBounds(self):\n        """"""Update the item\'s bounding rect to match the viewport""""""\n        self._boundingRect = None  ## invalidate bounding rect, regenerate later if needed.\n        self.prepareGeometryChange()\n\n\n    def setPos(self, *args):\n        GraphicsObject.setPos(self, *args)\n        self.setNewBounds()\n        \n    def mouseShape(self):\n        """"""Return the shape of this item after expanding by 2 pixels""""""\n        shape = self.shape()\n        ds = self.mapToDevice(shape)\n        stroker = QtGui.QPainterPathStroker()\n        stroker.setWidh(2)\n        ds2 = stroker.createStroke(ds).united(ds)\n        return self.mapFromDevice(ds2)\n        \n        \n        \n'"
src/third_party/pyqtgraph/graphicsItems/VTickGroup.py,0,"b'if __name__ == \'__main__\':\n    import os, sys\n    path = os.path.abspath(os.path.dirname(__file__))\n    sys.path.insert(0, os.path.join(path, \'..\', \'..\'))\n\nfrom ..Qt import QtGui, QtCore\nfrom .. import functions as fn\nimport weakref\nfrom .UIGraphicsItem import UIGraphicsItem\n\n__all__ = [\'VTickGroup\']\nclass VTickGroup(UIGraphicsItem):\n    """"""\n    **Bases:** :class:`UIGraphicsItem <pyqtgraph.UIGraphicsItem>`\n    \n    Draws a set of tick marks which always occupy the same vertical range of the view,\n    but have x coordinates relative to the data within the view.\n    \n    """"""\n    def __init__(self, xvals=None, yrange=None, pen=None):\n        """"""\n        ==============  ===================================================================\n        **Arguments:**\n        xvals           A list of x values (in data coordinates) at which to draw ticks.\n        yrange          A list of [low, high] limits for the tick. 0 is the bottom of\n                        the view, 1 is the top. [0.8, 1] would draw ticks in the top\n                        fifth of the view.\n        pen             The pen to use for drawing ticks. Default is grey. Can be specified\n                        as any argument valid for :func:`mkPen<pyqtgraph.mkPen>`\n        ==============  ===================================================================\n        """"""\n        if yrange is None:\n            yrange = [0, 1]\n        if xvals is None:\n            xvals = []\n            \n        UIGraphicsItem.__init__(self)\n            \n        if pen is None:\n            pen = (200, 200, 200)\n            \n        self.path = QtGui.QGraphicsPathItem()\n        \n        self.ticks = []\n        self.xvals = []\n        self.yrange = [0,1]\n        self.setPen(pen)\n        self.setYRange(yrange)\n        self.setXVals(xvals)\n        \n    def setPen(self, *args, **kwargs):\n        """"""Set the pen to use for drawing ticks. Can be specified as any arguments valid\n        for :func:`mkPen<pyqtgraph.mkPen>`""""""        \n        self.pen = fn.mkPen(*args, **kwargs)\n\n    def setXVals(self, vals):\n        """"""Set the x values for the ticks. \n        \n        ==============   =====================================================================\n        **Arguments:**\n        vals             A list of x values (in data/plot coordinates) at which to draw ticks.\n        ==============   =====================================================================\n        """"""\n        self.xvals = vals\n        self.rebuildTicks()\n        #self.valid = False\n        \n    def setYRange(self, vals):\n        """"""Set the y range [low, high] that the ticks are drawn on. 0 is the bottom of \n        the view, 1 is the top.""""""\n        self.yrange = vals\n        self.rebuildTicks()\n        \n    def dataBounds(self, *args, **kargs):\n        return None  ## item should never affect view autoscaling\n            \n    def yRange(self):\n        return self.yrange\n            \n    def rebuildTicks(self):\n        self.path = QtGui.QPainterPath()\n        yrange = self.yRange()\n        for x in self.xvals:\n            self.path.moveTo(x, 0.)\n            self.path.lineTo(x, 1.)\n        \n    def paint(self, p, *args):\n        UIGraphicsItem.paint(self, p, *args)\n        \n        br = self.boundingRect()\n        h = br.height()\n        br.setY(br.y() + self.yrange[0] * h)\n        br.setHeight((self.yrange[1] - self.yrange[0]) * h)\n        p.translate(0, br.y())\n        p.scale(1.0, br.height())\n        p.setPen(self.pen)\n        p.drawPath(self.path)\n\n    '"
src/third_party/pyqtgraph/graphicsItems/__init__.py,0,"b""### just import everything from sub-modules\n\n#import os\n\n#d = os.path.split(__file__)[0]\n#files = []\n#for f in os.listdir(d):\n    #if os.path.isdir(os.path.join(d, f)):\n        #files.append(f)\n    #elif f[-3:] == '.py' and f != '__init__.py':\n        #files.append(f[:-3])\n    \n#for modName in files:\n    #mod = __import__(modName, globals(), locals(), fromlist=['*'])\n    #if hasattr(mod, '__all__'):\n        #names = mod.__all__\n    #else:\n        #names = [n for n in dir(mod) if n[0] != '_']\n    #for k in names:\n        ##print modName, k\n        #globals()[k] = getattr(mod, k)\n"""
src/third_party/pyqtgraph/imageview/ImageView.py,11,"b'# -*- coding: utf-8 -*-\n""""""\nImageView.py -  Widget for basic image dispay and analysis\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n\nWidget used for displaying 2D or 3D data. Features:\n  - float or int (including 16-bit int) image display via ImageItem\n  - zoom/pan via GraphicsView\n  - black/white level controls\n  - time slider for 3D data sets\n  - ROI plotting\n  - Image normalization through a variety of methods\n""""""\nimport os, sys\nimport numpy as np\n\nfrom ..Qt import QtCore, QtGui, QT_LIB\nif QT_LIB == \'PySide\':\n    from .ImageViewTemplate_pyside import *\nelif QT_LIB == \'PySide2\':\n    from .ImageViewTemplate_pyside2 import *\nelif QT_LIB == \'PyQt5\':\n    from .ImageViewTemplate_pyqt5 import *\nelse:\n    from .ImageViewTemplate_pyqt import *\n\nfrom ..graphicsItems.ImageItem import *\nfrom ..graphicsItems.ROI import *\nfrom ..graphicsItems.LinearRegionItem import *\nfrom ..graphicsItems.InfiniteLine import *\nfrom ..graphicsItems.ViewBox import *\nfrom ..graphicsItems.VTickGroup import VTickGroup\nfrom ..graphicsItems.GradientEditorItem import addGradientListToDocstring\nfrom .. import ptime as ptime\nfrom .. import debug as debug\nfrom ..SignalProxy import SignalProxy\nfrom .. import getConfigOption\n\ntry:\n    from bottleneck import nanmin, nanmax\nexcept ImportError:\n    from numpy import nanmin, nanmax\n\n\nclass PlotROI(ROI):\n    def __init__(self, size):\n        ROI.__init__(self, pos=[0,0], size=size) #, scaleSnap=True, translateSnap=True)\n        self.addScaleHandle([1, 1], [0, 0])\n        self.addRotateHandle([0, 0], [0.5, 0.5])\n\n\nclass ImageView(QtGui.QWidget):\n    """"""\n    Widget used for display and analysis of image data.\n    Implements many features:\n\n    * Displays 2D and 3D image data. For 3D data, a z-axis\n      slider is displayed allowing the user to select which frame is displayed.\n    * Displays histogram of image data with movable region defining the dark/light levels\n    * Editable gradient provides a color lookup table\n    * Frame slider may also be moved using left/right arrow keys as well as pgup, pgdn, home, and end.\n    * Basic analysis features including:\n\n        * ROI and embedded plot for measuring image values across frames\n        * Image normalization / background subtraction\n\n    Basic Usage::\n\n        imv = pg.ImageView()\n        imv.show()\n        imv.setImage(data)\n\n    **Keyboard interaction**\n\n    * left/right arrows step forward/backward 1 frame when pressed,\n      seek at 20fps when held.\n    * up/down arrows seek at 100fps\n    * pgup/pgdn seek at 1000fps\n    * home/end seek immediately to the first/last frame\n    * space begins playing frames. If time values (in seconds) are given\n      for each frame, then playback is in realtime.\n    """"""\n    sigTimeChanged = QtCore.Signal(object, object)\n    sigProcessingChanged = QtCore.Signal(object)\n\n    def __init__(self, parent=None, name=""ImageView"", view=None, imageItem=None,\n                 levelMode=\'mono\', *args):\n        """"""\n        By default, this class creates an :class:`ImageItem <pyqtgraph.ImageItem>` to display image data\n        and a :class:`ViewBox <pyqtgraph.ViewBox>` to contain the ImageItem.\n\n        ============= =========================================================\n        **Arguments**\n        parent        (QWidget) Specifies the parent widget to which\n                      this ImageView will belong. If None, then the ImageView\n                      is created with no parent.\n        name          (str) The name used to register both the internal ViewBox\n                      and the PlotItem used to display ROI data. See the *name*\n                      argument to :func:`ViewBox.__init__()\n                      <pyqtgraph.ViewBox.__init__>`.\n        view          (ViewBox or PlotItem) If specified, this will be used\n                      as the display area that contains the displayed image.\n                      Any :class:`ViewBox <pyqtgraph.ViewBox>`,\n                      :class:`PlotItem <pyqtgraph.PlotItem>`, or other\n                      compatible object is acceptable.\n        imageItem     (ImageItem) If specified, this object will be used to\n                      display the image. Must be an instance of ImageItem\n                      or other compatible object.\n        levelMode     See the *levelMode* argument to\n                      :func:`HistogramLUTItem.__init__()\n                      <pyqtgraph.HistogramLUTItem.__init__>`\n        ============= =========================================================\n\n        Note: to display axis ticks inside the ImageView, instantiate it\n        with a PlotItem instance as its view::\n\n            pg.ImageView(view=pg.PlotItem())\n        """"""\n        QtGui.QWidget.__init__(self, parent, *args)\n        self._imageLevels = None  # [(min, max), ...] per channel image metrics\n        self.levelMin = None    # min / max levels across all channels\n        self.levelMax = None\n\n        self.name = name\n        self.image = None\n        self.axes = {}\n        self.imageDisp = None\n        self.ui = Ui_Form()\n        self.ui.setupUi(self)\n        self.scene = self.ui.graphicsView.scene()\n        self.ui.histogram.setLevelMode(levelMode)\n\n        self.ignoreTimeLine = False\n\n        if view is None:\n            self.view = ViewBox()\n        else:\n            self.view = view\n        self.ui.graphicsView.setCentralItem(self.view)\n        self.view.setAspectLocked(True)\n        self.view.invertY()\n\n        if imageItem is None:\n            self.imageItem = ImageItem()\n        else:\n            self.imageItem = imageItem\n        self.view.addItem(self.imageItem)\n        self.currentIndex = 0\n\n        self.ui.histogram.setImageItem(self.imageItem)\n\n        self.menu = None\n\n        self.ui.normGroup.hide()\n\n        self.roi = PlotROI(10)\n        self.roi.setZValue(20)\n        self.view.addItem(self.roi)\n        self.roi.hide()\n        self.normRoi = PlotROI(10)\n        self.normRoi.setPen(\'y\')\n        self.normRoi.setZValue(20)\n        self.view.addItem(self.normRoi)\n        self.normRoi.hide()\n        self.roiCurves = []\n        self.timeLine = InfiniteLine(0, movable=True, markers=[(\'^\', 0), (\'v\', 1)])\n        self.timeLine.setPen((255, 255, 0, 200))\n        self.timeLine.setZValue(1)\n        self.ui.roiPlot.addItem(self.timeLine)\n        self.ui.splitter.setSizes([self.height()-35, 35])\n        self.ui.roiPlot.hideAxis(\'left\')\n        self.frameTicks = VTickGroup(yrange=[0.8, 1], pen=0.4)\n        self.ui.roiPlot.addItem(self.frameTicks, ignoreBounds=True)\n\n        self.keysPressed = {}\n        self.playTimer = QtCore.QTimer()\n        self.playRate = 0\n        self.lastPlayTime = 0\n\n        self.normRgn = LinearRegionItem()\n        self.normRgn.setZValue(0)\n        self.ui.roiPlot.addItem(self.normRgn)\n        self.normRgn.hide()\n\n        ## wrap functions from view box\n        for fn in [\'addItem\', \'removeItem\']:\n            setattr(self, fn, getattr(self.view, fn))\n\n        ## wrap functions from histogram\n        for fn in [\'setHistogramRange\', \'autoHistogramRange\', \'getLookupTable\', \'getLevels\']:\n            setattr(self, fn, getattr(self.ui.histogram, fn))\n\n        self.timeLine.sigPositionChanged.connect(self.timeLineChanged)\n        self.ui.roiBtn.clicked.connect(self.roiClicked)\n        self.roi.sigRegionChanged.connect(self.roiChanged)\n        #self.ui.normBtn.toggled.connect(self.normToggled)\n        self.ui.menuBtn.clicked.connect(self.menuClicked)\n        self.ui.normDivideRadio.clicked.connect(self.normRadioChanged)\n        self.ui.normSubtractRadio.clicked.connect(self.normRadioChanged)\n        self.ui.normOffRadio.clicked.connect(self.normRadioChanged)\n        self.ui.normROICheck.clicked.connect(self.updateNorm)\n        self.ui.normFrameCheck.clicked.connect(self.updateNorm)\n        self.ui.normTimeRangeCheck.clicked.connect(self.updateNorm)\n        self.playTimer.timeout.connect(self.timeout)\n\n        self.normProxy = SignalProxy(self.normRgn.sigRegionChanged, slot=self.updateNorm)\n        self.normRoi.sigRegionChangeFinished.connect(self.updateNorm)\n\n        self.ui.roiPlot.registerPlot(self.name + \'_ROI\')\n        self.view.register(self.name)\n\n        self.noRepeatKeys = [QtCore.Qt.Key_Right, QtCore.Qt.Key_Left, QtCore.Qt.Key_Up, QtCore.Qt.Key_Down, QtCore.Qt.Key_PageUp, QtCore.Qt.Key_PageDown]\n\n        self.roiClicked() ## initialize roi plot to correct shape / visibility\n\n    def setImage(self, img, autoRange=True, autoLevels=True, levels=None, axes=None, xvals=None, pos=None, scale=None, transform=None, autoHistogramRange=True, levelMode=None):\n        """"""\n        Set the image to be displayed in the widget.\n\n        ================== ===========================================================================\n        **Arguments:**\n        img                (numpy array) the image to be displayed. See :func:`ImageItem.setImage` and\n                           *notes* below.\n        xvals              (numpy array) 1D array of z-axis values corresponding to the first axis\n                           in a 3D image. For video, this array should contain the time of each\n                           frame.\n        autoRange          (bool) whether to scale/pan the view to fit the image.\n        autoLevels         (bool) whether to update the white/black levels to fit the image.\n        levels             (min, max); the white and black level values to use.\n        axes               Dictionary indicating the interpretation for each axis.\n                           This is only needed to override the default guess. Format is::\n\n                               {\'t\':0, \'x\':1, \'y\':2, \'c\':3};\n\n        pos                Change the position of the displayed image\n        scale              Change the scale of the displayed image\n        transform          Set the transform of the displayed image. This option overrides *pos*\n                           and *scale*.\n        autoHistogramRange If True, the histogram y-range is automatically scaled to fit the\n                           image data.\n        levelMode          If specified, this sets the user interaction mode for setting image\n                           levels. Options are \'mono\', which provides a single level control for\n                           all image channels, and \'rgb\' or \'rgba\', which provide individual\n                           controls for each channel.\n        ================== ===========================================================================\n\n        **Notes:**\n\n        For backward compatibility, image data is assumed to be in column-major order (column, row).\n        However, most image data is stored in row-major order (row, column) and will need to be\n        transposed before calling setImage()::\n\n            imageview.setImage(imagedata.T)\n\n        This requirement can be changed by the ``imageAxisOrder``\n        :ref:`global configuration option <apiref_config>`.\n\n        """"""\n        profiler = debug.Profiler()\n\n        if hasattr(img, \'implements\') and img.implements(\'MetaArray\'):\n            img = img.asarray()\n\n        if not isinstance(img, np.ndarray):\n            required = [\'dtype\', \'max\', \'min\', \'ndim\', \'shape\', \'size\']\n            if not all([hasattr(img, attr) for attr in required]):\n                raise TypeError(""Image must be NumPy array or any object ""\n                                ""that provides compatible attributes/methods:\\n""\n                                ""  %s"" % str(required))\n\n        self.image = img\n        self.imageDisp = None\n        if levelMode is not None:\n            self.ui.histogram.setLevelMode(levelMode)\n\n        profiler()\n\n        if axes is None:\n            x,y = (0, 1) if self.imageItem.axisOrder == \'col-major\' else (1, 0)\n\n            if img.ndim == 2:\n                self.axes = {\'t\': None, \'x\': x, \'y\': y, \'c\': None}\n            elif img.ndim == 3:\n                # Ambiguous case; make a guess\n                if img.shape[2] <= 4:\n                    self.axes = {\'t\': None, \'x\': x, \'y\': y, \'c\': 2}\n                else:\n                    self.axes = {\'t\': 0, \'x\': x+1, \'y\': y+1, \'c\': None}\n            elif img.ndim == 4:\n                # Even more ambiguous; just assume the default\n                self.axes = {\'t\': 0, \'x\': x+1, \'y\': y+1, \'c\': 3}\n            else:\n                raise Exception(""Can not interpret image with dimensions %s"" % (str(img.shape)))\n        elif isinstance(axes, dict):\n            self.axes = axes.copy()\n        elif isinstance(axes, list) or isinstance(axes, tuple):\n            self.axes = {}\n            for i in range(len(axes)):\n                self.axes[axes[i]] = i\n        else:\n            raise Exception(""Can not interpret axis specification %s. Must be like {\'t\': 2, \'x\': 0, \'y\': 1} or (\'t\', \'x\', \'y\', \'c\')"" % (str(axes)))\n\n        for x in [\'t\', \'x\', \'y\', \'c\']:\n            self.axes[x] = self.axes.get(x, None)\n        axes = self.axes\n\n        if xvals is not None:\n            self.tVals = xvals\n        elif axes[\'t\'] is not None:\n            if hasattr(img, \'xvals\'):\n                try:\n                    self.tVals = img.xvals(axes[\'t\'])\n                except:\n                    self.tVals = np.arange(img.shape[axes[\'t\']])\n            else:\n                self.tVals = np.arange(img.shape[axes[\'t\']])\n\n        profiler()\n\n        self.currentIndex = 0\n        self.updateImage(autoHistogramRange=autoHistogramRange)\n        if levels is None and autoLevels:\n            self.autoLevels()\n        if levels is not None:  ## this does nothing since getProcessedImage sets these values again.\n            self.setLevels(*levels)\n\n        if self.ui.roiBtn.isChecked():\n            self.roiChanged()\n\n        profiler()\n\n        if self.axes[\'t\'] is not None:\n            self.ui.roiPlot.setXRange(self.tVals.min(), self.tVals.max())\n            self.frameTicks.setXVals(self.tVals)\n            self.timeLine.setValue(0)\n            if len(self.tVals) > 1:\n                start = self.tVals.min()\n                stop = self.tVals.max() + abs(self.tVals[-1] - self.tVals[0]) * 0.02\n            elif len(self.tVals) == 1:\n                start = self.tVals[0] - 0.5\n                stop = self.tVals[0] + 0.5\n            else:\n                start = 0\n                stop = 1\n            for s in [self.timeLine, self.normRgn]:\n                s.setBounds([start, stop])\n\n        profiler()\n\n        self.imageItem.resetTransform()\n        if scale is not None:\n            self.imageItem.scale(*scale)\n        if pos is not None:\n            self.imageItem.setPos(*pos)\n        if transform is not None:\n            self.imageItem.setTransform(transform)\n\n        profiler()\n\n        if autoRange:\n            self.autoRange()\n        self.roiClicked()\n\n        profiler()\n\n    def clear(self):\n        self.image = None\n        self.imageItem.clear()\n\n    def play(self, rate):\n        """"""Begin automatically stepping frames forward at the given rate (in fps).\n        This can also be accessed by pressing the spacebar.""""""\n        #print ""play:"", rate\n        self.playRate = rate\n        if rate == 0:\n            self.playTimer.stop()\n            return\n\n        self.lastPlayTime = ptime.time()\n        if not self.playTimer.isActive():\n            self.playTimer.start(16)\n\n    def autoLevels(self):\n        """"""Set the min/max intensity levels automatically to match the image data.""""""\n        self.setLevels(rgba=self._imageLevels)\n\n    def setLevels(self, *args, **kwds):\n        """"""Set the min/max (bright and dark) levels.\n\n        See :func:`HistogramLUTItem.setLevels <pyqtgraph.HistogramLUTItem.setLevels>`.\n        """"""\n        self.ui.histogram.setLevels(*args, **kwds)\n\n    def autoRange(self):\n        """"""Auto scale and pan the view around the image such that the image fills the view.""""""\n        image = self.getProcessedImage()\n        self.view.autoRange()\n\n    def getProcessedImage(self):\n        """"""Returns the image data after it has been processed by any normalization options in use.\n        """"""\n        if self.imageDisp is None:\n            image = self.normalize(self.image)\n            self.imageDisp = image\n            self._imageLevels = self.quickMinMax(self.imageDisp)\n            self.levelMin = min([level[0] for level in self._imageLevels])\n            self.levelMax = max([level[1] for level in self._imageLevels])\n\n        return self.imageDisp\n\n    def close(self):\n        """"""Closes the widget nicely, making sure to clear the graphics scene and release memory.""""""\n        self.ui.roiPlot.close()\n        self.ui.graphicsView.close()\n        self.scene.clear()\n        del self.image\n        del self.imageDisp\n        super(ImageView, self).close()\n        self.setParent(None)\n\n    def keyPressEvent(self, ev):\n        #print ev.key()\n        if ev.key() == QtCore.Qt.Key_Space:\n            if self.playRate == 0:\n                fps = (self.getProcessedImage().shape[0]-1) / (self.tVals[-1] - self.tVals[0])\n                self.play(fps)\n                #print fps\n            else:\n                self.play(0)\n            ev.accept()\n        elif ev.key() == QtCore.Qt.Key_Home:\n            self.setCurrentIndex(0)\n            self.play(0)\n            ev.accept()\n        elif ev.key() == QtCore.Qt.Key_End:\n            self.setCurrentIndex(self.getProcessedImage().shape[0]-1)\n            self.play(0)\n            ev.accept()\n        elif ev.key() in self.noRepeatKeys:\n            ev.accept()\n            if ev.isAutoRepeat():\n                return\n            self.keysPressed[ev.key()] = 1\n            self.evalKeyState()\n        else:\n            QtGui.QWidget.keyPressEvent(self, ev)\n\n    def keyReleaseEvent(self, ev):\n        if ev.key() in [QtCore.Qt.Key_Space, QtCore.Qt.Key_Home, QtCore.Qt.Key_End]:\n            ev.accept()\n        elif ev.key() in self.noRepeatKeys:\n            ev.accept()\n            if ev.isAutoRepeat():\n                return\n            try:\n                del self.keysPressed[ev.key()]\n            except:\n                self.keysPressed = {}\n            self.evalKeyState()\n        else:\n            QtGui.QWidget.keyReleaseEvent(self, ev)\n\n    def evalKeyState(self):\n        if len(self.keysPressed) == 1:\n            key = list(self.keysPressed.keys())[0]\n            if key == QtCore.Qt.Key_Right:\n                self.play(20)\n                self.jumpFrames(1)\n                self.lastPlayTime = ptime.time() + 0.2  ## 2ms wait before start\n                                                        ## This happens *after* jumpFrames, since it might take longer than 2ms\n            elif key == QtCore.Qt.Key_Left:\n                self.play(-20)\n                self.jumpFrames(-1)\n                self.lastPlayTime = ptime.time() + 0.2\n            elif key == QtCore.Qt.Key_Up:\n                self.play(-100)\n            elif key == QtCore.Qt.Key_Down:\n                self.play(100)\n            elif key == QtCore.Qt.Key_PageUp:\n                self.play(-1000)\n            elif key == QtCore.Qt.Key_PageDown:\n                self.play(1000)\n        else:\n            self.play(0)\n\n    def timeout(self):\n        now = ptime.time()\n        dt = now - self.lastPlayTime\n        if dt < 0:\n            return\n        n = int(self.playRate * dt)\n        if n != 0:\n            self.lastPlayTime += (float(n)/self.playRate)\n            if self.currentIndex+n > self.image.shape[self.axes[\'t\']]:\n                self.play(0)\n            self.jumpFrames(n)\n\n    def setCurrentIndex(self, ind):\n        """"""Set the currently displayed frame index.""""""\n        self.currentIndex = np.clip(ind, 0, self.getProcessedImage().shape[self.axes[\'t\']]-1)\n        self.updateImage()\n        self.ignoreTimeLine = True\n        self.timeLine.setValue(self.tVals[self.currentIndex])\n        self.ignoreTimeLine = False\n\n    def jumpFrames(self, n):\n        """"""Move video frame ahead n frames (may be negative)""""""\n        if self.axes[\'t\'] is not None:\n            self.setCurrentIndex(self.currentIndex + n)\n\n    def normRadioChanged(self):\n        self.imageDisp = None\n        self.updateImage()\n        self.autoLevels()\n        self.roiChanged()\n        self.sigProcessingChanged.emit(self)\n\n    def updateNorm(self):\n        if self.ui.normTimeRangeCheck.isChecked():\n            self.normRgn.show()\n        else:\n            self.normRgn.hide()\n\n        if self.ui.normROICheck.isChecked():\n            self.normRoi.show()\n        else:\n            self.normRoi.hide()\n\n        if not self.ui.normOffRadio.isChecked():\n            self.imageDisp = None\n            self.updateImage()\n            self.autoLevels()\n            self.roiChanged()\n            self.sigProcessingChanged.emit(self)\n\n    def normToggled(self, b):\n        self.ui.normGroup.setVisible(b)\n        self.normRoi.setVisible(b and self.ui.normROICheck.isChecked())\n        self.normRgn.setVisible(b and self.ui.normTimeRangeCheck.isChecked())\n\n    def hasTimeAxis(self):\n        return \'t\' in self.axes and self.axes[\'t\'] is not None\n\n    def roiClicked(self):\n        showRoiPlot = False\n        if self.ui.roiBtn.isChecked():\n            showRoiPlot = True\n            self.roi.show()\n            #self.ui.roiPlot.show()\n            self.ui.roiPlot.setMouseEnabled(True, True)\n            self.ui.splitter.setSizes([self.height()*0.6, self.height()*0.4])\n            for c in self.roiCurves:\n                c.show()\n            self.roiChanged()\n            self.ui.roiPlot.showAxis(\'left\')\n        else:\n            self.roi.hide()\n            self.ui.roiPlot.setMouseEnabled(False, False)\n            for c in self.roiCurves:\n                c.hide()\n            self.ui.roiPlot.hideAxis(\'left\')\n\n        if self.hasTimeAxis():\n            showRoiPlot = True\n            mn = self.tVals.min()\n            mx = self.tVals.max()\n            self.ui.roiPlot.setXRange(mn, mx, padding=0.01)\n            self.timeLine.show()\n            self.timeLine.setBounds([mn, mx])\n            self.ui.roiPlot.show()\n            if not self.ui.roiBtn.isChecked():\n                self.ui.splitter.setSizes([self.height()-35, 35])\n        else:\n            self.timeLine.hide()\n            #self.ui.roiPlot.hide()\n\n        self.ui.roiPlot.setVisible(showRoiPlot)\n\n    def roiChanged(self):\n        if self.image is None:\n            return\n\n        image = self.getProcessedImage()\n\n        # Extract image data from ROI\n        axes = (self.axes[\'x\'], self.axes[\'y\'])\n\n        data, coords = self.roi.getArrayRegion(image.view(np.ndarray), self.imageItem, axes, returnMappedCoords=True)\n        if data is None:\n            return\n\n        # Convert extracted data into 1D plot data\n        if self.axes[\'t\'] is None:\n            # Average across y-axis of ROI\n            data = data.mean(axis=axes[1])\n            coords = coords[:,:,0] - coords[:,0:1,0]\n            xvals = (coords**2).sum(axis=0) ** 0.5\n        else:\n            # Average data within entire ROI for each frame\n            data = data.mean(axis=max(axes)).mean(axis=min(axes))\n            xvals = self.tVals\n\n        # Handle multi-channel data\n        if data.ndim == 1:\n            plots = [(xvals, data, \'w\')]\n        if data.ndim == 2:\n            if data.shape[1] == 1:\n                colors = \'w\'\n            else:\n                colors = \'rgbw\'\n            plots = []\n            for i in range(data.shape[1]):\n                d = data[:,i]\n                plots.append((xvals, d, colors[i]))\n\n        # Update plot line(s)\n        while len(plots) < len(self.roiCurves):\n            c = self.roiCurves.pop()\n            c.scene().removeItem(c)\n        while len(plots) > len(self.roiCurves):\n            self.roiCurves.append(self.ui.roiPlot.plot())\n        for i in range(len(plots)):\n            x, y, p = plots[i]\n            self.roiCurves[i].setData(x, y, pen=p)\n\n    def quickMinMax(self, data):\n        """"""\n        Estimate the min/max values of *data* by subsampling.\n        Returns [(min, max), ...] with one item per channel\n        """"""\n        while data.size > 1e6:\n            ax = np.argmax(data.shape)\n            sl = [slice(None)] * data.ndim\n            sl[ax] = slice(None, None, 2)\n            data = data[tuple(sl)]\n\n        cax = self.axes[\'c\']\n        if cax is None:\n            if data.size == 0:\n                return [(0, 0)]\n            return [(float(nanmin(data)), float(nanmax(data)))]\n        else:\n            if data.size == 0:\n                return [(0, 0)] * data.shape[-1]\n            return [(float(nanmin(data.take(i, axis=cax))),\n                     float(nanmax(data.take(i, axis=cax)))) for i in range(data.shape[-1])]\n\n    def normalize(self, image):\n        """"""\n        Process *image* using the normalization options configured in the\n        control panel.\n\n        This can be repurposed to process any data through the same filter.\n        """"""\n        if self.ui.normOffRadio.isChecked():\n            return image\n\n        div = self.ui.normDivideRadio.isChecked()\n        norm = image.view(np.ndarray).copy()\n        #if div:\n            #norm = ones(image.shape)\n        #else:\n            #norm = zeros(image.shape)\n        if div:\n            norm = norm.astype(np.float32)\n\n        if self.ui.normTimeRangeCheck.isChecked() and image.ndim == 3:\n            (sind, start) = self.timeIndex(self.normRgn.lines[0])\n            (eind, end) = self.timeIndex(self.normRgn.lines[1])\n            #print start, end, sind, eind\n            n = image[sind:eind+1].mean(axis=0)\n            n.shape = (1,) + n.shape\n            if div:\n                norm /= n\n            else:\n                norm -= n\n\n        if self.ui.normFrameCheck.isChecked() and image.ndim == 3:\n            n = image.mean(axis=1).mean(axis=1)\n            n.shape = n.shape + (1, 1)\n            if div:\n                norm /= n\n            else:\n                norm -= n\n\n        if self.ui.normROICheck.isChecked() and image.ndim == 3:\n            n = self.normRoi.getArrayRegion(norm, self.imageItem, (1, 2)).mean(axis=1).mean(axis=1)\n            n = n[:,np.newaxis,np.newaxis]\n            #print start, end, sind, eind\n            if div:\n                norm /= n\n            else:\n                norm -= n\n\n        return norm\n\n    def timeLineChanged(self):\n        #(ind, time) = self.timeIndex(self.ui.timeSlider)\n        if self.ignoreTimeLine:\n            return\n        self.play(0)\n        (ind, time) = self.timeIndex(self.timeLine)\n        if ind != self.currentIndex:\n            self.currentIndex = ind\n            self.updateImage()\n        #self.timeLine.setPos(time)\n        #self.emit(QtCore.SIGNAL(\'timeChanged\'), ind, time)\n        self.sigTimeChanged.emit(ind, time)\n\n    def updateImage(self, autoHistogramRange=True):\n        ## Redraw image on screen\n        if self.image is None:\n            return\n\n        image = self.getProcessedImage()\n\n        if autoHistogramRange:\n            self.ui.histogram.setHistogramRange(self.levelMin, self.levelMax)\n\n        # Transpose image into order expected by ImageItem\n        if self.imageItem.axisOrder == \'col-major\':\n            axorder = [\'t\', \'x\', \'y\', \'c\']\n        else:\n            axorder = [\'t\', \'y\', \'x\', \'c\']\n        axorder = [self.axes[ax] for ax in axorder if self.axes[ax] is not None]\n        image = image.transpose(axorder)\n\n        # Select time index\n        if self.axes[\'t\'] is not None:\n            self.ui.roiPlot.show()\n            image = image[self.currentIndex]\n\n        self.imageItem.updateImage(image)\n\n\n    def timeIndex(self, slider):\n        ## Return the time and frame index indicated by a slider\n        if self.image is None:\n            return (0,0)\n\n        t = slider.value()\n\n        xv = self.tVals\n        if xv is None:\n            ind = int(t)\n        else:\n            if len(xv) < 2:\n                return (0,0)\n            totTime = xv[-1] + (xv[-1]-xv[-2])\n            inds = np.argwhere(xv < t)\n            if len(inds) < 1:\n                return (0,t)\n            ind = inds[-1,0]\n        return ind, t\n\n    def getView(self):\n        """"""Return the ViewBox (or other compatible object) which displays the ImageItem""""""\n        return self.view\n\n    def getImageItem(self):\n        """"""Return the ImageItem for this ImageView.""""""\n        return self.imageItem\n\n    def getRoiPlot(self):\n        """"""Return the ROI PlotWidget for this ImageView""""""\n        return self.ui.roiPlot\n\n    def getHistogramWidget(self):\n        """"""Return the HistogramLUTWidget for this ImageView""""""\n        return self.ui.histogram\n\n    def export(self, fileName):\n        """"""\n        Export data from the ImageView to a file, or to a stack of files if\n        the data is 3D. Saving an image stack will result in index numbers\n        being added to the file name. Images are saved as they would appear\n        onscreen, with levels and lookup table applied.\n        """"""\n        img = self.getProcessedImage()\n        if self.hasTimeAxis():\n            base, ext = os.path.splitext(fileName)\n            fmt = ""%%s%%0%dd%%s"" % int(np.log10(img.shape[0])+1)\n            for i in range(img.shape[0]):\n                self.imageItem.setImage(img[i], autoLevels=False)\n                self.imageItem.save(fmt % (base, i, ext))\n            self.updateImage()\n        else:\n            self.imageItem.save(fileName)\n\n    def exportClicked(self):\n        fileName = QtGui.QFileDialog.getSaveFileName()\n        if isinstance(fileName, tuple):\n            fileName = fileName[0]  # Qt4/5 API difference\n        if fileName == \'\':\n            return\n        self.export(str(fileName))\n\n    def buildMenu(self):\n        self.menu = QtGui.QMenu()\n        self.normAction = QtGui.QAction(""Normalization"", self.menu)\n        self.normAction.setCheckable(True)\n        self.normAction.toggled.connect(self.normToggled)\n        self.menu.addAction(self.normAction)\n        self.exportAction = QtGui.QAction(""Export"", self.menu)\n        self.exportAction.triggered.connect(self.exportClicked)\n        self.menu.addAction(self.exportAction)\n\n    def menuClicked(self):\n        if self.menu is None:\n            self.buildMenu()\n        self.menu.popup(QtGui.QCursor.pos())\n\n    def setColorMap(self, colormap):\n        """"""Set the color map.\n\n        ============= =========================================================\n        **Arguments**\n        colormap      (A ColorMap() instance) The ColorMap to use for coloring\n                      images.\n        ============= =========================================================\n        """"""\n        self.ui.histogram.gradient.setColorMap(colormap)\n\n    @addGradientListToDocstring()\n    def setPredefinedGradient(self, name):\n        """"""Set one of the gradients defined in :class:`GradientEditorItem <pyqtgraph.graphicsItems.GradientEditorItem>`.\n        Currently available gradients are:\n        """"""\n        self.ui.histogram.gradient.loadPreset(name)\n'"
src/third_party/pyqtgraph/imageview/ImageViewTemplate_pyqt.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'ImageViewTemplate.ui\'\n#\n# Created: Thu May  1 15:20:40 2014\n#      by: PyQt4 UI code generator 4.10.4\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom ..Qt import QtCore, QtGui\n\ntry:\n    _fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n    def _fromUtf8(s):\n        return s\n\ntry:\n    _encoding = QtGui.QApplication.UnicodeUTF8\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig, _encoding)\nexcept AttributeError:\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig)\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(""Form""))\n        Form.resize(726, 588)\n        self.gridLayout_3 = QtGui.QGridLayout(Form)\n        self.gridLayout_3.setMargin(0)\n        self.gridLayout_3.setSpacing(0)\n        self.gridLayout_3.setObjectName(_fromUtf8(""gridLayout_3""))\n        self.splitter = QtGui.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Vertical)\n        self.splitter.setObjectName(_fromUtf8(""splitter""))\n        self.layoutWidget = QtGui.QWidget(self.splitter)\n        self.layoutWidget.setObjectName(_fromUtf8(""layoutWidget""))\n        self.gridLayout = QtGui.QGridLayout(self.layoutWidget)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setMargin(0)\n        self.gridLayout.setObjectName(_fromUtf8(""gridLayout""))\n        self.graphicsView = GraphicsView(self.layoutWidget)\n        self.graphicsView.setObjectName(_fromUtf8(""graphicsView""))\n        self.gridLayout.addWidget(self.graphicsView, 0, 0, 2, 1)\n        self.histogram = HistogramLUTWidget(self.layoutWidget)\n        self.histogram.setObjectName(_fromUtf8(""histogram""))\n        self.gridLayout.addWidget(self.histogram, 0, 1, 1, 2)\n        self.roiBtn = QtGui.QPushButton(self.layoutWidget)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.roiBtn.sizePolicy().hasHeightForWidth())\n        self.roiBtn.setSizePolicy(sizePolicy)\n        self.roiBtn.setCheckable(True)\n        self.roiBtn.setObjectName(_fromUtf8(""roiBtn""))\n        self.gridLayout.addWidget(self.roiBtn, 1, 1, 1, 1)\n        self.menuBtn = QtGui.QPushButton(self.layoutWidget)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.menuBtn.sizePolicy().hasHeightForWidth())\n        self.menuBtn.setSizePolicy(sizePolicy)\n        self.menuBtn.setObjectName(_fromUtf8(""menuBtn""))\n        self.gridLayout.addWidget(self.menuBtn, 1, 2, 1, 1)\n        self.roiPlot = PlotWidget(self.splitter)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.roiPlot.sizePolicy().hasHeightForWidth())\n        self.roiPlot.setSizePolicy(sizePolicy)\n        self.roiPlot.setMinimumSize(QtCore.QSize(0, 40))\n        self.roiPlot.setObjectName(_fromUtf8(""roiPlot""))\n        self.gridLayout_3.addWidget(self.splitter, 0, 0, 1, 1)\n        self.normGroup = QtGui.QGroupBox(Form)\n        self.normGroup.setObjectName(_fromUtf8(""normGroup""))\n        self.gridLayout_2 = QtGui.QGridLayout(self.normGroup)\n        self.gridLayout_2.setMargin(0)\n        self.gridLayout_2.setSpacing(0)\n        self.gridLayout_2.setObjectName(_fromUtf8(""gridLayout_2""))\n        self.normSubtractRadio = QtGui.QRadioButton(self.normGroup)\n        self.normSubtractRadio.setObjectName(_fromUtf8(""normSubtractRadio""))\n        self.gridLayout_2.addWidget(self.normSubtractRadio, 0, 2, 1, 1)\n        self.normDivideRadio = QtGui.QRadioButton(self.normGroup)\n        self.normDivideRadio.setChecked(False)\n        self.normDivideRadio.setObjectName(_fromUtf8(""normDivideRadio""))\n        self.gridLayout_2.addWidget(self.normDivideRadio, 0, 1, 1, 1)\n        self.label_5 = QtGui.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.label_5.setFont(font)\n        self.label_5.setObjectName(_fromUtf8(""label_5""))\n        self.gridLayout_2.addWidget(self.label_5, 0, 0, 1, 1)\n        self.label_3 = QtGui.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.label_3.setFont(font)\n        self.label_3.setObjectName(_fromUtf8(""label_3""))\n        self.gridLayout_2.addWidget(self.label_3, 1, 0, 1, 1)\n        self.label_4 = QtGui.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.label_4.setFont(font)\n        self.label_4.setObjectName(_fromUtf8(""label_4""))\n        self.gridLayout_2.addWidget(self.label_4, 2, 0, 1, 1)\n        self.normROICheck = QtGui.QCheckBox(self.normGroup)\n        self.normROICheck.setObjectName(_fromUtf8(""normROICheck""))\n        self.gridLayout_2.addWidget(self.normROICheck, 1, 1, 1, 1)\n        self.normXBlurSpin = QtGui.QDoubleSpinBox(self.normGroup)\n        self.normXBlurSpin.setObjectName(_fromUtf8(""normXBlurSpin""))\n        self.gridLayout_2.addWidget(self.normXBlurSpin, 2, 2, 1, 1)\n        self.label_8 = QtGui.QLabel(self.normGroup)\n        self.label_8.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_8.setObjectName(_fromUtf8(""label_8""))\n        self.gridLayout_2.addWidget(self.label_8, 2, 1, 1, 1)\n        self.label_9 = QtGui.QLabel(self.normGroup)\n        self.label_9.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_9.setObjectName(_fromUtf8(""label_9""))\n        self.gridLayout_2.addWidget(self.label_9, 2, 3, 1, 1)\n        self.normYBlurSpin = QtGui.QDoubleSpinBox(self.normGroup)\n        self.normYBlurSpin.setObjectName(_fromUtf8(""normYBlurSpin""))\n        self.gridLayout_2.addWidget(self.normYBlurSpin, 2, 4, 1, 1)\n        self.label_10 = QtGui.QLabel(self.normGroup)\n        self.label_10.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_10.setObjectName(_fromUtf8(""label_10""))\n        self.gridLayout_2.addWidget(self.label_10, 2, 5, 1, 1)\n        self.normOffRadio = QtGui.QRadioButton(self.normGroup)\n        self.normOffRadio.setChecked(True)\n        self.normOffRadio.setObjectName(_fromUtf8(""normOffRadio""))\n        self.gridLayout_2.addWidget(self.normOffRadio, 0, 3, 1, 1)\n        self.normTimeRangeCheck = QtGui.QCheckBox(self.normGroup)\n        self.normTimeRangeCheck.setObjectName(_fromUtf8(""normTimeRangeCheck""))\n        self.gridLayout_2.addWidget(self.normTimeRangeCheck, 1, 3, 1, 1)\n        self.normFrameCheck = QtGui.QCheckBox(self.normGroup)\n        self.normFrameCheck.setObjectName(_fromUtf8(""normFrameCheck""))\n        self.gridLayout_2.addWidget(self.normFrameCheck, 1, 2, 1, 1)\n        self.normTBlurSpin = QtGui.QDoubleSpinBox(self.normGroup)\n        self.normTBlurSpin.setObjectName(_fromUtf8(""normTBlurSpin""))\n        self.gridLayout_2.addWidget(self.normTBlurSpin, 2, 6, 1, 1)\n        self.gridLayout_3.addWidget(self.normGroup, 1, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(_translate(""Form"", ""Form"", None))\n        self.roiBtn.setText(_translate(""Form"", ""ROI"", None))\n        self.menuBtn.setText(_translate(""Form"", ""Menu"", None))\n        self.normGroup.setTitle(_translate(""Form"", ""Normalization"", None))\n        self.normSubtractRadio.setText(_translate(""Form"", ""Subtract"", None))\n        self.normDivideRadio.setText(_translate(""Form"", ""Divide"", None))\n        self.label_5.setText(_translate(""Form"", ""Operation:"", None))\n        self.label_3.setText(_translate(""Form"", ""Mean:"", None))\n        self.label_4.setText(_translate(""Form"", ""Blur:"", None))\n        self.normROICheck.setText(_translate(""Form"", ""ROI"", None))\n        self.label_8.setText(_translate(""Form"", ""X"", None))\n        self.label_9.setText(_translate(""Form"", ""Y"", None))\n        self.label_10.setText(_translate(""Form"", ""T"", None))\n        self.normOffRadio.setText(_translate(""Form"", ""Off"", None))\n        self.normTimeRangeCheck.setText(_translate(""Form"", ""Time range"", None))\n        self.normFrameCheck.setText(_translate(""Form"", ""Frame"", None))\n\nfrom ..widgets.HistogramLUTWidget import HistogramLUTWidget\nfrom ..widgets.GraphicsView import GraphicsView\nfrom ..widgets.PlotWidget import PlotWidget\n'"
src/third_party/pyqtgraph/imageview/ImageViewTemplate_pyqt5.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/imageview/ImageViewTemplate.ui\'\n#\n# Created: Wed Mar 26 15:09:28 2014\n#      by: PyQt5 UI code generator 5.0.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(726, 588)\n        self.gridLayout_3 = QtWidgets.QGridLayout(Form)\n        self.gridLayout_3.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_3.setSpacing(0)\n        self.gridLayout_3.setObjectName(""gridLayout_3"")\n        self.splitter = QtWidgets.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Vertical)\n        self.splitter.setObjectName(""splitter"")\n        self.layoutWidget = QtWidgets.QWidget(self.splitter)\n        self.layoutWidget.setObjectName(""layoutWidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.layoutWidget)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.graphicsView = GraphicsView(self.layoutWidget)\n        self.graphicsView.setObjectName(""graphicsView"")\n        self.gridLayout.addWidget(self.graphicsView, 0, 0, 2, 1)\n        self.histogram = HistogramLUTWidget(self.layoutWidget)\n        self.histogram.setObjectName(""histogram"")\n        self.gridLayout.addWidget(self.histogram, 0, 1, 1, 2)\n        self.roiBtn = QtWidgets.QPushButton(self.layoutWidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.roiBtn.sizePolicy().hasHeightForWidth())\n        self.roiBtn.setSizePolicy(sizePolicy)\n        self.roiBtn.setCheckable(True)\n        self.roiBtn.setObjectName(""roiBtn"")\n        self.gridLayout.addWidget(self.roiBtn, 1, 1, 1, 1)\n        self.menuBtn = QtWidgets.QPushButton(self.layoutWidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.menuBtn.sizePolicy().hasHeightForWidth())\n        self.menuBtn.setSizePolicy(sizePolicy)\n        self.menuBtn.setCheckable(True)\n        self.menuBtn.setObjectName(""menuBtn"")\n        self.gridLayout.addWidget(self.menuBtn, 1, 2, 1, 1)\n        self.roiPlot = PlotWidget(self.splitter)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.roiPlot.sizePolicy().hasHeightForWidth())\n        self.roiPlot.setSizePolicy(sizePolicy)\n        self.roiPlot.setMinimumSize(QtCore.QSize(0, 40))\n        self.roiPlot.setObjectName(""roiPlot"")\n        self.gridLayout_3.addWidget(self.splitter, 0, 0, 1, 1)\n        self.normGroup = QtWidgets.QGroupBox(Form)\n        self.normGroup.setObjectName(""normGroup"")\n        self.gridLayout_2 = QtWidgets.QGridLayout(self.normGroup)\n        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_2.setSpacing(0)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.normSubtractRadio = QtWidgets.QRadioButton(self.normGroup)\n        self.normSubtractRadio.setObjectName(""normSubtractRadio"")\n        self.gridLayout_2.addWidget(self.normSubtractRadio, 0, 2, 1, 1)\n        self.normDivideRadio = QtWidgets.QRadioButton(self.normGroup)\n        self.normDivideRadio.setChecked(False)\n        self.normDivideRadio.setObjectName(""normDivideRadio"")\n        self.gridLayout_2.addWidget(self.normDivideRadio, 0, 1, 1, 1)\n        self.label_5 = QtWidgets.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.label_5.setFont(font)\n        self.label_5.setObjectName(""label_5"")\n        self.gridLayout_2.addWidget(self.label_5, 0, 0, 1, 1)\n        self.label_3 = QtWidgets.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.label_3.setFont(font)\n        self.label_3.setObjectName(""label_3"")\n        self.gridLayout_2.addWidget(self.label_3, 1, 0, 1, 1)\n        self.label_4 = QtWidgets.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.label_4.setFont(font)\n        self.label_4.setObjectName(""label_4"")\n        self.gridLayout_2.addWidget(self.label_4, 2, 0, 1, 1)\n        self.normROICheck = QtWidgets.QCheckBox(self.normGroup)\n        self.normROICheck.setObjectName(""normROICheck"")\n        self.gridLayout_2.addWidget(self.normROICheck, 1, 1, 1, 1)\n        self.normXBlurSpin = QtWidgets.QDoubleSpinBox(self.normGroup)\n        self.normXBlurSpin.setObjectName(""normXBlurSpin"")\n        self.gridLayout_2.addWidget(self.normXBlurSpin, 2, 2, 1, 1)\n        self.label_8 = QtWidgets.QLabel(self.normGroup)\n        self.label_8.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_8.setObjectName(""label_8"")\n        self.gridLayout_2.addWidget(self.label_8, 2, 1, 1, 1)\n        self.label_9 = QtWidgets.QLabel(self.normGroup)\n        self.label_9.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_9.setObjectName(""label_9"")\n        self.gridLayout_2.addWidget(self.label_9, 2, 3, 1, 1)\n        self.normYBlurSpin = QtWidgets.QDoubleSpinBox(self.normGroup)\n        self.normYBlurSpin.setObjectName(""normYBlurSpin"")\n        self.gridLayout_2.addWidget(self.normYBlurSpin, 2, 4, 1, 1)\n        self.label_10 = QtWidgets.QLabel(self.normGroup)\n        self.label_10.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_10.setObjectName(""label_10"")\n        self.gridLayout_2.addWidget(self.label_10, 2, 5, 1, 1)\n        self.normOffRadio = QtWidgets.QRadioButton(self.normGroup)\n        self.normOffRadio.setChecked(True)\n        self.normOffRadio.setObjectName(""normOffRadio"")\n        self.gridLayout_2.addWidget(self.normOffRadio, 0, 3, 1, 1)\n        self.normTimeRangeCheck = QtWidgets.QCheckBox(self.normGroup)\n        self.normTimeRangeCheck.setObjectName(""normTimeRangeCheck"")\n        self.gridLayout_2.addWidget(self.normTimeRangeCheck, 1, 3, 1, 1)\n        self.normFrameCheck = QtWidgets.QCheckBox(self.normGroup)\n        self.normFrameCheck.setObjectName(""normFrameCheck"")\n        self.gridLayout_2.addWidget(self.normFrameCheck, 1, 2, 1, 1)\n        self.normTBlurSpin = QtWidgets.QDoubleSpinBox(self.normGroup)\n        self.normTBlurSpin.setObjectName(""normTBlurSpin"")\n        self.gridLayout_2.addWidget(self.normTBlurSpin, 2, 6, 1, 1)\n        self.gridLayout_3.addWidget(self.normGroup, 1, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Form""))\n        self.roiBtn.setText(_translate(""Form"", ""ROI""))\n        self.menuBtn.setText(_translate(""Form"", ""Norm""))\n        self.normGroup.setTitle(_translate(""Form"", ""Normalization""))\n        self.normSubtractRadio.setText(_translate(""Form"", ""Subtract""))\n        self.normDivideRadio.setText(_translate(""Form"", ""Divide""))\n        self.label_5.setText(_translate(""Form"", ""Operation:""))\n        self.label_3.setText(_translate(""Form"", ""Mean:""))\n        self.label_4.setText(_translate(""Form"", ""Blur:""))\n        self.normROICheck.setText(_translate(""Form"", ""ROI""))\n        self.label_8.setText(_translate(""Form"", ""X""))\n        self.label_9.setText(_translate(""Form"", ""Y""))\n        self.label_10.setText(_translate(""Form"", ""T""))\n        self.normOffRadio.setText(_translate(""Form"", ""Off""))\n        self.normTimeRangeCheck.setText(_translate(""Form"", ""Time range""))\n        self.normFrameCheck.setText(_translate(""Form"", ""Frame""))\n\nfrom ..widgets.HistogramLUTWidget import HistogramLUTWidget\nfrom ..widgets.PlotWidget import PlotWidget\nfrom ..widgets.GraphicsView import GraphicsView\n'"
src/third_party/pyqtgraph/imageview/ImageViewTemplate_pyside.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'ImageViewTemplate.ui\'\n#\n# Created: Thu May  1 15:20:42 2014\n#      by: pyside-uic 0.2.15 running on PySide 1.2.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide import QtCore, QtGui\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(726, 588)\n        self.gridLayout_3 = QtGui.QGridLayout(Form)\n        self.gridLayout_3.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_3.setSpacing(0)\n        self.gridLayout_3.setObjectName(""gridLayout_3"")\n        self.splitter = QtGui.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Vertical)\n        self.splitter.setObjectName(""splitter"")\n        self.layoutWidget = QtGui.QWidget(self.splitter)\n        self.layoutWidget.setObjectName(""layoutWidget"")\n        self.gridLayout = QtGui.QGridLayout(self.layoutWidget)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.graphicsView = GraphicsView(self.layoutWidget)\n        self.graphicsView.setObjectName(""graphicsView"")\n        self.gridLayout.addWidget(self.graphicsView, 0, 0, 2, 1)\n        self.histogram = HistogramLUTWidget(self.layoutWidget)\n        self.histogram.setObjectName(""histogram"")\n        self.gridLayout.addWidget(self.histogram, 0, 1, 1, 2)\n        self.roiBtn = QtGui.QPushButton(self.layoutWidget)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.roiBtn.sizePolicy().hasHeightForWidth())\n        self.roiBtn.setSizePolicy(sizePolicy)\n        self.roiBtn.setCheckable(True)\n        self.roiBtn.setObjectName(""roiBtn"")\n        self.gridLayout.addWidget(self.roiBtn, 1, 1, 1, 1)\n        self.menuBtn = QtGui.QPushButton(self.layoutWidget)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.menuBtn.sizePolicy().hasHeightForWidth())\n        self.menuBtn.setSizePolicy(sizePolicy)\n        self.menuBtn.setObjectName(""menuBtn"")\n        self.gridLayout.addWidget(self.menuBtn, 1, 2, 1, 1)\n        self.roiPlot = PlotWidget(self.splitter)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.roiPlot.sizePolicy().hasHeightForWidth())\n        self.roiPlot.setSizePolicy(sizePolicy)\n        self.roiPlot.setMinimumSize(QtCore.QSize(0, 40))\n        self.roiPlot.setObjectName(""roiPlot"")\n        self.gridLayout_3.addWidget(self.splitter, 0, 0, 1, 1)\n        self.normGroup = QtGui.QGroupBox(Form)\n        self.normGroup.setObjectName(""normGroup"")\n        self.gridLayout_2 = QtGui.QGridLayout(self.normGroup)\n        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_2.setSpacing(0)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.normSubtractRadio = QtGui.QRadioButton(self.normGroup)\n        self.normSubtractRadio.setObjectName(""normSubtractRadio"")\n        self.gridLayout_2.addWidget(self.normSubtractRadio, 0, 2, 1, 1)\n        self.normDivideRadio = QtGui.QRadioButton(self.normGroup)\n        self.normDivideRadio.setChecked(False)\n        self.normDivideRadio.setObjectName(""normDivideRadio"")\n        self.gridLayout_2.addWidget(self.normDivideRadio, 0, 1, 1, 1)\n        self.label_5 = QtGui.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.label_5.setFont(font)\n        self.label_5.setObjectName(""label_5"")\n        self.gridLayout_2.addWidget(self.label_5, 0, 0, 1, 1)\n        self.label_3 = QtGui.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.label_3.setFont(font)\n        self.label_3.setObjectName(""label_3"")\n        self.gridLayout_2.addWidget(self.label_3, 1, 0, 1, 1)\n        self.label_4 = QtGui.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.label_4.setFont(font)\n        self.label_4.setObjectName(""label_4"")\n        self.gridLayout_2.addWidget(self.label_4, 2, 0, 1, 1)\n        self.normROICheck = QtGui.QCheckBox(self.normGroup)\n        self.normROICheck.setObjectName(""normROICheck"")\n        self.gridLayout_2.addWidget(self.normROICheck, 1, 1, 1, 1)\n        self.normXBlurSpin = QtGui.QDoubleSpinBox(self.normGroup)\n        self.normXBlurSpin.setObjectName(""normXBlurSpin"")\n        self.gridLayout_2.addWidget(self.normXBlurSpin, 2, 2, 1, 1)\n        self.label_8 = QtGui.QLabel(self.normGroup)\n        self.label_8.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_8.setObjectName(""label_8"")\n        self.gridLayout_2.addWidget(self.label_8, 2, 1, 1, 1)\n        self.label_9 = QtGui.QLabel(self.normGroup)\n        self.label_9.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_9.setObjectName(""label_9"")\n        self.gridLayout_2.addWidget(self.label_9, 2, 3, 1, 1)\n        self.normYBlurSpin = QtGui.QDoubleSpinBox(self.normGroup)\n        self.normYBlurSpin.setObjectName(""normYBlurSpin"")\n        self.gridLayout_2.addWidget(self.normYBlurSpin, 2, 4, 1, 1)\n        self.label_10 = QtGui.QLabel(self.normGroup)\n        self.label_10.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_10.setObjectName(""label_10"")\n        self.gridLayout_2.addWidget(self.label_10, 2, 5, 1, 1)\n        self.normOffRadio = QtGui.QRadioButton(self.normGroup)\n        self.normOffRadio.setChecked(True)\n        self.normOffRadio.setObjectName(""normOffRadio"")\n        self.gridLayout_2.addWidget(self.normOffRadio, 0, 3, 1, 1)\n        self.normTimeRangeCheck = QtGui.QCheckBox(self.normGroup)\n        self.normTimeRangeCheck.setObjectName(""normTimeRangeCheck"")\n        self.gridLayout_2.addWidget(self.normTimeRangeCheck, 1, 3, 1, 1)\n        self.normFrameCheck = QtGui.QCheckBox(self.normGroup)\n        self.normFrameCheck.setObjectName(""normFrameCheck"")\n        self.gridLayout_2.addWidget(self.normFrameCheck, 1, 2, 1, 1)\n        self.normTBlurSpin = QtGui.QDoubleSpinBox(self.normGroup)\n        self.normTBlurSpin.setObjectName(""normTBlurSpin"")\n        self.gridLayout_2.addWidget(self.normTBlurSpin, 2, 6, 1, 1)\n        self.gridLayout_3.addWidget(self.normGroup, 1, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtGui.QApplication.translate(""Form"", ""Form"", None, QtGui.QApplication.UnicodeUTF8))\n        self.roiBtn.setText(QtGui.QApplication.translate(""Form"", ""ROI"", None, QtGui.QApplication.UnicodeUTF8))\n        self.menuBtn.setText(QtGui.QApplication.translate(""Form"", ""Menu"", None, QtGui.QApplication.UnicodeUTF8))\n        self.normGroup.setTitle(QtGui.QApplication.translate(""Form"", ""Normalization"", None, QtGui.QApplication.UnicodeUTF8))\n        self.normSubtractRadio.setText(QtGui.QApplication.translate(""Form"", ""Subtract"", None, QtGui.QApplication.UnicodeUTF8))\n        self.normDivideRadio.setText(QtGui.QApplication.translate(""Form"", ""Divide"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label_5.setText(QtGui.QApplication.translate(""Form"", ""Operation:"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label_3.setText(QtGui.QApplication.translate(""Form"", ""Mean:"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label_4.setText(QtGui.QApplication.translate(""Form"", ""Blur:"", None, QtGui.QApplication.UnicodeUTF8))\n        self.normROICheck.setText(QtGui.QApplication.translate(""Form"", ""ROI"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label_8.setText(QtGui.QApplication.translate(""Form"", ""X"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label_9.setText(QtGui.QApplication.translate(""Form"", ""Y"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label_10.setText(QtGui.QApplication.translate(""Form"", ""T"", None, QtGui.QApplication.UnicodeUTF8))\n        self.normOffRadio.setText(QtGui.QApplication.translate(""Form"", ""Off"", None, QtGui.QApplication.UnicodeUTF8))\n        self.normTimeRangeCheck.setText(QtGui.QApplication.translate(""Form"", ""Time range"", None, QtGui.QApplication.UnicodeUTF8))\n        self.normFrameCheck.setText(QtGui.QApplication.translate(""Form"", ""Frame"", None, QtGui.QApplication.UnicodeUTF8))\n\nfrom ..widgets.HistogramLUTWidget import HistogramLUTWidget\nfrom ..widgets.GraphicsView import GraphicsView\nfrom ..widgets.PlotWidget import PlotWidget\n'"
src/third_party/pyqtgraph/imageview/ImageViewTemplate_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'ImageViewTemplate.ui\'\n#\n# Created: Sun Sep 18 19:17:41 2016\n#      by: pyside2-uic  running on PySide2 2.0.0~alpha0\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide2 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(726, 588)\n        self.gridLayout_3 = QtWidgets.QGridLayout(Form)\n        self.gridLayout_3.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_3.setSpacing(0)\n        self.gridLayout_3.setObjectName(""gridLayout_3"")\n        self.splitter = QtWidgets.QSplitter(Form)\n        self.splitter.setOrientation(QtCore.Qt.Vertical)\n        self.splitter.setObjectName(""splitter"")\n        self.layoutWidget = QtWidgets.QWidget(self.splitter)\n        self.layoutWidget.setObjectName(""layoutWidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.layoutWidget)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.graphicsView = GraphicsView(self.layoutWidget)\n        self.graphicsView.setObjectName(""graphicsView"")\n        self.gridLayout.addWidget(self.graphicsView, 0, 0, 2, 1)\n        self.histogram = HistogramLUTWidget(self.layoutWidget)\n        self.histogram.setObjectName(""histogram"")\n        self.gridLayout.addWidget(self.histogram, 0, 1, 1, 2)\n        self.roiBtn = QtWidgets.QPushButton(self.layoutWidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.roiBtn.sizePolicy().hasHeightForWidth())\n        self.roiBtn.setSizePolicy(sizePolicy)\n        self.roiBtn.setCheckable(True)\n        self.roiBtn.setObjectName(""roiBtn"")\n        self.gridLayout.addWidget(self.roiBtn, 1, 1, 1, 1)\n        self.menuBtn = QtWidgets.QPushButton(self.layoutWidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(1)\n        sizePolicy.setHeightForWidth(self.menuBtn.sizePolicy().hasHeightForWidth())\n        self.menuBtn.setSizePolicy(sizePolicy)\n        self.menuBtn.setObjectName(""menuBtn"")\n        self.gridLayout.addWidget(self.menuBtn, 1, 2, 1, 1)\n        self.roiPlot = PlotWidget(self.splitter)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.roiPlot.sizePolicy().hasHeightForWidth())\n        self.roiPlot.setSizePolicy(sizePolicy)\n        self.roiPlot.setMinimumSize(QtCore.QSize(0, 40))\n        self.roiPlot.setObjectName(""roiPlot"")\n        self.gridLayout_3.addWidget(self.splitter, 0, 0, 1, 1)\n        self.normGroup = QtWidgets.QGroupBox(Form)\n        self.normGroup.setObjectName(""normGroup"")\n        self.gridLayout_2 = QtWidgets.QGridLayout(self.normGroup)\n        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_2.setSpacing(0)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.normSubtractRadio = QtWidgets.QRadioButton(self.normGroup)\n        self.normSubtractRadio.setObjectName(""normSubtractRadio"")\n        self.gridLayout_2.addWidget(self.normSubtractRadio, 0, 2, 1, 1)\n        self.normDivideRadio = QtWidgets.QRadioButton(self.normGroup)\n        self.normDivideRadio.setChecked(False)\n        self.normDivideRadio.setObjectName(""normDivideRadio"")\n        self.gridLayout_2.addWidget(self.normDivideRadio, 0, 1, 1, 1)\n        self.label_5 = QtWidgets.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.label_5.setFont(font)\n        self.label_5.setObjectName(""label_5"")\n        self.gridLayout_2.addWidget(self.label_5, 0, 0, 1, 1)\n        self.label_3 = QtWidgets.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.label_3.setFont(font)\n        self.label_3.setObjectName(""label_3"")\n        self.gridLayout_2.addWidget(self.label_3, 1, 0, 1, 1)\n        self.label_4 = QtWidgets.QLabel(self.normGroup)\n        font = QtGui.QFont()\n        font.setWeight(75)\n        font.setBold(True)\n        self.label_4.setFont(font)\n        self.label_4.setObjectName(""label_4"")\n        self.gridLayout_2.addWidget(self.label_4, 2, 0, 1, 1)\n        self.normROICheck = QtWidgets.QCheckBox(self.normGroup)\n        self.normROICheck.setObjectName(""normROICheck"")\n        self.gridLayout_2.addWidget(self.normROICheck, 1, 1, 1, 1)\n        self.normXBlurSpin = QtWidgets.QDoubleSpinBox(self.normGroup)\n        self.normXBlurSpin.setObjectName(""normXBlurSpin"")\n        self.gridLayout_2.addWidget(self.normXBlurSpin, 2, 2, 1, 1)\n        self.label_8 = QtWidgets.QLabel(self.normGroup)\n        self.label_8.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_8.setObjectName(""label_8"")\n        self.gridLayout_2.addWidget(self.label_8, 2, 1, 1, 1)\n        self.label_9 = QtWidgets.QLabel(self.normGroup)\n        self.label_9.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_9.setObjectName(""label_9"")\n        self.gridLayout_2.addWidget(self.label_9, 2, 3, 1, 1)\n        self.normYBlurSpin = QtWidgets.QDoubleSpinBox(self.normGroup)\n        self.normYBlurSpin.setObjectName(""normYBlurSpin"")\n        self.gridLayout_2.addWidget(self.normYBlurSpin, 2, 4, 1, 1)\n        self.label_10 = QtWidgets.QLabel(self.normGroup)\n        self.label_10.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.label_10.setObjectName(""label_10"")\n        self.gridLayout_2.addWidget(self.label_10, 2, 5, 1, 1)\n        self.normOffRadio = QtWidgets.QRadioButton(self.normGroup)\n        self.normOffRadio.setChecked(True)\n        self.normOffRadio.setObjectName(""normOffRadio"")\n        self.gridLayout_2.addWidget(self.normOffRadio, 0, 3, 1, 1)\n        self.normTimeRangeCheck = QtWidgets.QCheckBox(self.normGroup)\n        self.normTimeRangeCheck.setObjectName(""normTimeRangeCheck"")\n        self.gridLayout_2.addWidget(self.normTimeRangeCheck, 1, 3, 1, 1)\n        self.normFrameCheck = QtWidgets.QCheckBox(self.normGroup)\n        self.normFrameCheck.setObjectName(""normFrameCheck"")\n        self.gridLayout_2.addWidget(self.normFrameCheck, 1, 2, 1, 1)\n        self.normTBlurSpin = QtWidgets.QDoubleSpinBox(self.normGroup)\n        self.normTBlurSpin.setObjectName(""normTBlurSpin"")\n        self.gridLayout_2.addWidget(self.normTBlurSpin, 2, 6, 1, 1)\n        self.gridLayout_3.addWidget(self.normGroup, 1, 0, 1, 1)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtWidgets.QApplication.translate(""Form"", ""Form"", None, -1))\n        self.roiBtn.setText(QtWidgets.QApplication.translate(""Form"", ""ROI"", None, -1))\n        self.menuBtn.setText(QtWidgets.QApplication.translate(""Form"", ""Menu"", None, -1))\n        self.normGroup.setTitle(QtWidgets.QApplication.translate(""Form"", ""Normalization"", None, -1))\n        self.normSubtractRadio.setText(QtWidgets.QApplication.translate(""Form"", ""Subtract"", None, -1))\n        self.normDivideRadio.setText(QtWidgets.QApplication.translate(""Form"", ""Divide"", None, -1))\n        self.label_5.setText(QtWidgets.QApplication.translate(""Form"", ""Operation:"", None, -1))\n        self.label_3.setText(QtWidgets.QApplication.translate(""Form"", ""Mean:"", None, -1))\n        self.label_4.setText(QtWidgets.QApplication.translate(""Form"", ""Blur:"", None, -1))\n        self.normROICheck.setText(QtWidgets.QApplication.translate(""Form"", ""ROI"", None, -1))\n        self.label_8.setText(QtWidgets.QApplication.translate(""Form"", ""X"", None, -1))\n        self.label_9.setText(QtWidgets.QApplication.translate(""Form"", ""Y"", None, -1))\n        self.label_10.setText(QtWidgets.QApplication.translate(""Form"", ""T"", None, -1))\n        self.normOffRadio.setText(QtWidgets.QApplication.translate(""Form"", ""Off"", None, -1))\n        self.normTimeRangeCheck.setText(QtWidgets.QApplication.translate(""Form"", ""Time range"", None, -1))\n        self.normFrameCheck.setText(QtWidgets.QApplication.translate(""Form"", ""Frame"", None, -1))\n\nfrom ..widgets.HistogramLUTWidget import HistogramLUTWidget\nfrom ..widgets.PlotWidget import PlotWidget\nfrom ..widgets.GraphicsView import GraphicsView\n'"
src/third_party/pyqtgraph/imageview/__init__.py,0,"b'""""""\nWidget used for display and analysis of 2D and 3D image data.\nIncludes ROI plotting over time and image normalization.\n""""""\n\nfrom .ImageView import ImageView\n'"
src/third_party/pyqtgraph/metaarray/MetaArray.py,43,"b'# -*- coding: utf-8 -*-\n""""""\nMetaArray.py -  Class encapsulating ndarray with meta data\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n\nMetaArray is an array class based on numpy.ndarray that allows storage of per-axis meta data\nsuch as axis values, names, units, column names, etc. It also enables several\nnew methods for slicing and indexing the array based on this meta data. \nMore info at http://www.scipy.org/Cookbook/MetaArray\n""""""\n\nimport types, copy, threading, os, re\nimport pickle\nfrom functools import reduce\nimport numpy as np\nfrom ..python2_3 import basestring\n#import traceback\n\n## By default, the library will use HDF5 when writing files.\n## This can be overridden by setting USE_HDF5 = False\nUSE_HDF5 = True\ntry:\n    import h5py\n    HAVE_HDF5 = True\nexcept:\n    USE_HDF5 = False\n    HAVE_HDF5 = False\n\n\ndef axis(name=None, cols=None, values=None, units=None):\n    """"""Convenience function for generating axis descriptions when defining MetaArrays""""""\n    ax = {}\n    cNameOrder = [\'name\', \'units\', \'title\']\n    if name is not None:\n        ax[\'name\'] = name\n    if values is not None:\n        ax[\'values\'] = values\n    if units is not None:\n        ax[\'units\'] = units\n    if cols is not None:\n        ax[\'cols\'] = []\n        for c in cols:\n            if type(c) != list and type(c) != tuple:\n                c = [c]\n            col = {}\n            for i in range(0,len(c)):\n                col[cNameOrder[i]] = c[i]\n            ax[\'cols\'].append(col)\n    return ax\n\nclass sliceGenerator(object):\n    """"""Just a compact way to generate tuples of slice objects.""""""\n    def __getitem__(self, arg):\n        return arg\n    def __getslice__(self, arg):\n        return arg\nSLICER = sliceGenerator()\n    \n\nclass MetaArray(object):\n    """"""N-dimensional array with meta data such as axis titles, units, and column names.\n  \n    May be initialized with a file name, a tuple representing the dimensions of the array,\n    or any arguments that could be passed on to numpy.array()\n  \n    The info argument sets the metadata for the entire array. It is composed of a list\n    of axis descriptions where each axis may have a name, title, units, and a list of column \n    descriptions. An additional dict at the end of the axis list may specify parameters\n    that apply to values in the entire array.\n  \n    For example:\n        A 2D array of altitude values for a topographical map might look like\n            info=[\n        {\'name\': \'lat\', \'title\': \'Lattitude\'}, \n        {\'name\': \'lon\', \'title\': \'Longitude\'}, \n        {\'title\': \'Altitude\', \'units\': \'m\'}\n      ]\n        In this case, every value in the array represents the altitude in feet at the lat, lon\n        position represented by the array index. All of the following return the \n        value at lat=10, lon=5:\n            array[10, 5]\n            array[\'lon\':5, \'lat\':10]\n            array[\'lat\':10][5]\n        Now suppose we want to combine this data with another array of equal dimensions that\n        represents the average rainfall for each location. We could easily store these as two \n        separate arrays or combine them into a 3D array with this description:\n            info=[\n        {\'name\': \'vals\', \'cols\': [\n          {\'name\': \'altitude\', \'units\': \'m\'}, \n          {\'name\': \'rainfall\', \'units\': \'cm/year\'}\n        ]},\n        {\'name\': \'lat\', \'title\': \'Lattitude\'}, \n        {\'name\': \'lon\', \'title\': \'Longitude\'}\n      ]\n        We can now access the altitude values with array[0] or array[\'altitude\'], and the\n        rainfall values with array[1] or array[\'rainfall\']. All of the following return\n        the rainfall value at lat=10, lon=5:\n            array[1, 10, 5]\n            array[\'lon\':5, \'lat\':10, \'val\': \'rainfall\']\n            array[\'rainfall\', \'lon\':5, \'lat\':10]\n        Notice that in the second example, there is no need for an extra (4th) axis description\n        since the actual values are described (name and units) in the column info for the first axis.\n    """"""\n  \n    version = \'2\'\n\n    # Default hdf5 compression to use when writing\n    #   \'gzip\' is widely available and somewhat slow\n    #   \'lzf\' is faster, but generally not available outside h5py\n    #   \'szip\' is also faster, but lacks write support on windows\n    # (so by default, we use no compression)\n    # May also be a tuple (filter, opts), such as (\'gzip\', 3)\n    defaultCompression = None\n    \n    ## Types allowed as axis or column names\n    nameTypes = [basestring, tuple]\n    @staticmethod\n    def isNameType(var):\n        return any([isinstance(var, t) for t in MetaArray.nameTypes])\n        \n        \n    ## methods to wrap from embedded ndarray / HDF5 \n    wrapMethods = set([\'__eq__\', \'__ne__\', \'__le__\', \'__lt__\', \'__ge__\', \'__gt__\'])\n  \n    def __init__(self, data=None, info=None, dtype=None, file=None, copy=False, **kwargs):\n        object.__init__(self)\n        #self._infoOwned = False\n        self._isHDF = False\n        \n        if file is not None:\n            self._data = None\n            self.readFile(file, **kwargs)\n            if kwargs.get(""readAllData"", True) and self._data is None:\n                raise Exception(""File read failed: %s"" % file)\n        else:\n            self._info = info\n            if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n                self._info = data._info\n                self._data = data.asarray()\n            elif isinstance(data, tuple):  ## create empty array with specified shape\n                self._data = np.empty(data, dtype=dtype)\n            else:\n                self._data = np.array(data, dtype=dtype, copy=copy)\n\n        ## run sanity checks on info structure\n        self.checkInfo()\n    \n    def checkInfo(self):\n        info = self._info\n        if info is None:\n            if self._data is None:\n                return\n            else:\n                self._info = [{} for i in range(self.ndim + 1)]\n                return\n        else:\n            try:\n                info = list(info)\n            except:\n                raise Exception(""Info must be a list of axis specifications"")\n            if len(info) < self.ndim+1:\n                info.extend([{}]*(self.ndim+1-len(info)))\n            elif len(info) > self.ndim+1:\n                raise Exception(""Info parameter must be list of length ndim+1 or less."")\n            for i in range(len(info)):\n                if not isinstance(info[i], dict):\n                    if info[i] is None:\n                        info[i] = {}\n                    else:\n                        raise Exception(""Axis specification must be Dict or None"")\n                if i < self.ndim and \'values\' in info[i]:\n                    if type(info[i][\'values\']) is list:\n                        info[i][\'values\'] = np.array(info[i][\'values\'])\n                    elif type(info[i][\'values\']) is not np.ndarray:\n                        raise Exception(""Axis values must be specified as list or ndarray"")\n                    if info[i][\'values\'].ndim != 1 or info[i][\'values\'].shape[0] != self.shape[i]:\n                        raise Exception(""Values array for axis %d has incorrect shape. (given %s, but should be %s)"" %\n                                        (i, str(info[i][\'values\'].shape), str((self.shape[i],))))\n                if i < self.ndim and \'cols\' in info[i]:\n                    if not isinstance(info[i][\'cols\'], list):\n                        info[i][\'cols\'] = list(info[i][\'cols\'])\n                    if len(info[i][\'cols\']) != self.shape[i]:\n                        raise Exception(\'Length of column list for axis %d does not match data. (given %d, but should be %d)\' %\n                                        (i, len(info[i][\'cols\']), self.shape[i]))\n            self._info = info\n\n    def implements(self, name=None):\n        ## Rather than isinstance(obj, MetaArray) use object.implements(\'MetaArray\')\n        if name is None:\n            return [\'MetaArray\']\n        else:\n            return name == \'MetaArray\'\n    \n    #def __array_finalize__(self,obj):\n        ### array_finalize is called every time a MetaArray is created \n        ### (whereas __new__ is not necessarily called every time)\n        \n        ### obj is the object from which this array was generated (for example, when slicing or view()ing)\n        \n        ## We use the getattr method to set a default if \'obj\' doesn\'t have the \'info\' attribute\n        ##print ""Create new MA from object"", str(type(obj))\n        ##import traceback\n        ##traceback.print_stack()\n        ##print ""finalize"", type(self), type(obj)\n        #if not hasattr(self, \'_info\'):\n            ##if isinstance(obj, MetaArray):\n                ##print ""  copy info:"", obj._info\n            #self._info = getattr(obj, \'_info\', [{}]*(obj.ndim+1))\n            #self._infoOwned = False  ## Do not make changes to _info until it is copied at least once\n        ##print ""  self info:"", self._info\n      \n        ## We could have checked first whether self._info was already defined:\n        ##if not hasattr(self, \'info\'):\n        ##    self._info = getattr(obj, \'info\', {})\n    \n  \n    def __getitem__(self, ind):\n        #print ""getitem:"", ind\n        \n        ## should catch scalar requests as early as possible to speed things up (?)\n        \n        nInd = self._interpretIndexes(ind)\n        \n        #a = np.ndarray.__getitem__(self, nInd)\n        a = self._data[nInd]\n        if len(nInd) == self.ndim:\n            if np.all([not isinstance(ind, slice) for ind in nInd]):  ## no slices; we have requested a single value from the array\n                return a\n        #if type(a) != type(self._data) and not isinstance(a, np.ndarray):  ## indexing returned single value\n            #return a\n        \n        ## indexing returned a sub-array; generate new info array to go with it\n        #print ""   new MA:"", type(a), a.shape\n        info = []\n        extraInfo = self._info[-1].copy()\n        for i in range(0, len(nInd)):   ## iterate over all axes\n            #print ""   axis"", i\n            if type(nInd[i]) in [slice, list] or isinstance(nInd[i], np.ndarray):  ## If the axis is sliced, keep the info but chop if necessary\n                #print ""      slice axis"", i, nInd[i]\n                #a._info[i] = self._axisSlice(i, nInd[i])\n                #print ""         info:"", a._info[i]\n                info.append(self._axisSlice(i, nInd[i]))\n            else: ## If the axis is indexed, then move the information from that single index to the last info dictionary\n                #print ""indexed:"", i, nInd[i], type(nInd[i])\n                newInfo = self._axisSlice(i, nInd[i])\n                name = None\n                colName = None\n                for k in newInfo:\n                    if k == \'cols\':\n                        if \'cols\' not in extraInfo:\n                            extraInfo[\'cols\'] = []\n                        extraInfo[\'cols\'].append(newInfo[k])\n                        if \'units\' in newInfo[k]:\n                            extraInfo[\'units\'] = newInfo[k][\'units\']\n                        if \'name\' in newInfo[k]:\n                            colName = newInfo[k][\'name\']\n                    elif k == \'name\':\n                        name = newInfo[k]\n                    else:\n                        if k not in extraInfo:\n                            extraInfo[k] = newInfo[k]\n                        extraInfo[k] = newInfo[k]\n                if \'name\' not in extraInfo:\n                    if name is None:\n                        if colName is not None:\n                            extraInfo[\'name\'] = colName\n                    else:\n                        if colName is not None:\n                            extraInfo[\'name\'] = str(name) + \': \' + str(colName)\n                        else:\n                            extraInfo[\'name\'] = name\n                        \n                        \n                #print ""Lost info:"", newInfo\n                #a._info[i] = None\n                #if \'name\' in newInfo:\n                    #a._info[-1][newInfo[\'name\']] = newInfo\n        info.append(extraInfo)\n        \n        #self._infoOwned = False\n        #while None in a._info:\n            #a._info.remove(None)\n        return MetaArray(a, info=info)\n  \n    @property\n    def ndim(self):\n        return len(self.shape)  ## hdf5 objects do not have ndim property.\n            \n    @property\n    def shape(self):\n        return self._data.shape\n        \n    @property\n    def dtype(self):\n        return self._data.dtype\n        \n    def __len__(self):\n        return len(self._data)\n        \n    def __getslice__(self, *args):\n        return self.__getitem__(slice(*args))\n  \n    def __setitem__(self, ind, val):\n        nInd = self._interpretIndexes(ind)\n        try:\n            self._data[nInd] = val\n        except:\n            print(self, nInd, val)\n            raise\n        \n    def __getattr__(self, attr):\n        if attr in self.wrapMethods:\n            return getattr(self._data, attr)\n        else:\n            raise AttributeError(attr)\n            #return lambda *args, **kwargs: MetaArray(getattr(a.view(ndarray), attr)(*args, **kwargs)\n        \n    def __eq__(self, b):\n        return self._binop(\'__eq__\', b)\n        \n    def __ne__(self, b):\n        return self._binop(\'__ne__\', b)\n        #if isinstance(b, MetaArray):\n            #b = b.asarray()\n        #return self.asarray() != b\n        \n    def __sub__(self, b):\n        return self._binop(\'__sub__\', b)\n        #if isinstance(b, MetaArray):\n            #b = b.asarray()\n        #return MetaArray(self.asarray() - b, info=self.infoCopy())\n\n    def __add__(self, b):\n        return self._binop(\'__add__\', b)\n\n    def __mul__(self, b):\n        return self._binop(\'__mul__\', b)\n        \n    def __div__(self, b):\n        return self._binop(\'__div__\', b)\n        \n    def __truediv__(self, b):\n        return self._binop(\'__truediv__\', b)\n        \n    def _binop(self, op, b):\n        if isinstance(b, MetaArray):\n            b = b.asarray()\n        a = self.asarray()\n        c = getattr(a, op)(b)\n        if c.shape != a.shape:\n            raise Exception(""Binary operators with MetaArray must return an array of the same shape (this shape is %s, result shape was %s)"" % (a.shape, c.shape))\n        return MetaArray(c, info=self.infoCopy())\n        \n    def asarray(self):\n        if isinstance(self._data, np.ndarray):\n            return self._data\n        else:\n            return np.array(self._data)\n            \n    def __array__(self):\n        ## supports np.array(metaarray_instance) \n        return self.asarray()\n            \n    def view(self, typ):\n        ## deprecated; kept for backward compatibility\n        if typ is np.ndarray:\n            return self.asarray()\n        else:\n            raise Exception(\'invalid view type: %s\' % str(typ))\n  \n    def axisValues(self, axis):\n        """"""Return the list of values for an axis""""""\n        ax = self._interpretAxis(axis)\n        if \'values\' in self._info[ax]:\n            return self._info[ax][\'values\']\n        else:\n            raise Exception(\'Array axis %s (%d) has no associated values.\' % (str(axis), ax))\n  \n    def xvals(self, axis):\n        """"""Synonym for axisValues()""""""\n        return self.axisValues(axis)\n        \n    def axisHasValues(self, axis):\n        ax = self._interpretAxis(axis)\n        return \'values\' in self._info[ax]\n        \n    def axisHasColumns(self, axis):\n        ax = self._interpretAxis(axis)\n        return \'cols\' in self._info[ax]\n  \n    def axisUnits(self, axis):\n        """"""Return the units for axis""""""\n        ax = self._info[self._interpretAxis(axis)]\n        if \'units\' in ax:\n            return ax[\'units\']\n        \n    def hasColumn(self, axis, col):\n        ax = self._info[self._interpretAxis(axis)]\n        if \'cols\' in ax:\n            for c in ax[\'cols\']:\n                if c[\'name\'] == col:\n                    return True\n        return False\n        \n    def listColumns(self, axis=None):\n        """"""Return a list of column names for axis. If axis is not specified, then return a dict of {axisName: (column names), ...}.""""""\n        if axis is None:\n            ret = {}\n            for i in range(self.ndim):\n                if \'cols\' in self._info[i]:\n                    cols = [c[\'name\'] for c in self._info[i][\'cols\']]\n                else:\n                    cols = []\n                ret[self.axisName(i)] = cols\n            return ret\n        else:\n            axis = self._interpretAxis(axis)\n            return [c[\'name\'] for c in self._info[axis][\'cols\']]\n        \n    def columnName(self, axis, col):\n        ax = self._info[self._interpretAxis(axis)]\n        return ax[\'cols\'][col][\'name\']\n        \n    def axisName(self, n):\n        return self._info[n].get(\'name\', n)\n        \n    def columnUnits(self, axis, column):\n        """"""Return the units for column in axis""""""\n        ax = self._info[self._interpretAxis(axis)]\n        if \'cols\' in ax:\n            for c in ax[\'cols\']:\n                if c[\'name\'] == column:\n                    return c[\'units\']\n            raise Exception(""Axis %s has no column named %s"" % (str(axis), str(column)))\n        else:\n            raise Exception(""Axis %s has no column definitions"" % str(axis))\n  \n    def rowsort(self, axis, key=0):\n        """"""Return this object with all records sorted along axis using key as the index to the values to compare. Does not yet modify meta info.""""""\n        ## make sure _info is copied locally before modifying it!\n    \n        keyList = self[key]\n        order = keyList.argsort()\n        if type(axis) == int:\n            ind = [slice(None)]*axis\n            ind.append(order)\n        elif isinstance(axis, basestring):\n            ind = (slice(axis, order),)\n        return self[tuple(ind)]\n  \n    def append(self, val, axis):\n        """"""Return this object with val appended along axis. Does not yet combine meta info.""""""\n        ## make sure _info is copied locally before modifying it!\n    \n        s = list(self.shape)\n        axis = self._interpretAxis(axis)\n        s[axis] += 1\n        n = MetaArray(tuple(s), info=self._info, dtype=self.dtype)\n        ind = [slice(None)]*self.ndim\n        ind[axis] = slice(None,-1)\n        n[tuple(ind)] = self\n        ind[axis] = -1\n        n[tuple(ind)] = val\n        return n\n  \n    def extend(self, val, axis):\n        """"""Return the concatenation along axis of this object and val. Does not yet combine meta info.""""""\n        ## make sure _info is copied locally before modifying it!\n    \n        axis = self._interpretAxis(axis)\n        return MetaArray(np.concatenate(self, val, axis), info=self._info)\n  \n    def infoCopy(self, axis=None):\n        """"""Return a deep copy of the axis meta info for this object""""""\n        if axis is None:\n            return copy.deepcopy(self._info)\n        else:\n            return copy.deepcopy(self._info[self._interpretAxis(axis)])\n  \n    def copy(self):\n        return MetaArray(self._data.copy(), info=self.infoCopy())\n  \n  \n    def _interpretIndexes(self, ind):\n        #print ""interpret"", ind\n        if not isinstance(ind, tuple):\n            ## a list of slices should be interpreted as a tuple of slices.\n            if isinstance(ind, list) and len(ind) > 0 and isinstance(ind[0], slice):\n                ind = tuple(ind)\n            ## everything else can just be converted to a length-1 tuple\n            else:\n                ind = (ind,)\n                \n        nInd = [slice(None)]*self.ndim\n        numOk = True  ## Named indices not started yet; numbered sill ok\n        for i in range(0,len(ind)):\n            (axis, index, isNamed) = self._interpretIndex(ind[i], i, numOk)\n            #try:\n            nInd[axis] = index\n            #except:\n                #print ""ndim:"", self.ndim\n                #print ""axis:"", axis\n                #print ""index spec:"", ind[i]\n                #print ""index num:"", index\n                #raise\n            if isNamed:\n                numOk = False\n        return tuple(nInd)\n      \n    def _interpretAxis(self, axis):\n        if isinstance(axis, basestring) or isinstance(axis, tuple):\n            return self._getAxis(axis)\n        else:\n            return axis\n  \n    def _interpretIndex(self, ind, pos, numOk):\n        #print ""Interpreting index"", ind, pos, numOk\n        \n        ## should probably check for int first to speed things up..\n        if type(ind) is int:\n            if not numOk:\n                raise Exception(""string and integer indexes may not follow named indexes"")\n            #print ""  normal numerical index""\n            return (pos, ind, False)\n        if MetaArray.isNameType(ind):\n            if not numOk:\n                raise Exception(""string and integer indexes may not follow named indexes"")\n            #print ""  String index, column is "", self._getIndex(pos, ind)\n            return (pos, self._getIndex(pos, ind), False)\n        elif type(ind) is slice:\n            #print ""  Slice index""\n            if MetaArray.isNameType(ind.start) or MetaArray.isNameType(ind.stop):  ## Not an actual slice!\n                #print ""    ..not a real slice""\n                axis = self._interpretAxis(ind.start)\n                #print ""    axis is"", axis\n                \n                ## x[Axis:Column]\n                if MetaArray.isNameType(ind.stop):\n                    #print ""    column name, column is "", self._getIndex(axis, ind.stop)\n                    index = self._getIndex(axis, ind.stop)\n                    \n                ## x[Axis:min:max]\n                elif (isinstance(ind.stop, float) or isinstance(ind.step, float)) and (\'values\' in self._info[axis]):\n                    #print ""    axis value range""\n                    if ind.stop is None:\n                        mask = self.xvals(axis) < ind.step\n                    elif ind.step is None:\n                        mask = self.xvals(axis) >= ind.stop\n                    else:\n                        mask = (self.xvals(axis) >= ind.stop) * (self.xvals(axis) < ind.step)\n                    ##print ""mask:"", mask\n                    index = mask\n                    \n                ## x[Axis:columnIndex]\n                elif isinstance(ind.stop, int) or isinstance(ind.step, int):\n                    #print ""    normal slice after named axis""\n                    if ind.step is None:\n                        index = ind.stop\n                    else:\n                        index = slice(ind.stop, ind.step)\n                    \n                ## x[Axis: [list]]\n                elif type(ind.stop) is list:\n                    #print ""    list of indexes from named axis""\n                    index = []\n                    for i in ind.stop:\n                        if type(i) is int:\n                            index.append(i)\n                        elif MetaArray.isNameType(i):\n                            index.append(self._getIndex(axis, i))\n                        else:\n                            ## unrecognized type, try just passing on to array\n                            index = ind.stop\n                            break\n                \n                else:\n                    #print ""    other type.. forward on to array for handling"", type(ind.stop)\n                    index = ind.stop\n                #print ""Axis %s (%s) : %s"" % (ind.start, str(axis), str(type(index)))\n                #if type(index) is np.ndarray:\n                    #print ""    "", index.shape\n                return (axis, index, True)\n            else:\n                #print ""  Looks like a real slice, passing on to array""\n                return (pos, ind, False)\n        elif type(ind) is list:\n            #print ""  List index., interpreting each element individually""\n            indList = [self._interpretIndex(i, pos, numOk)[1] for i in ind]\n            return (pos, indList, False)\n        else:\n            if not numOk:\n                raise Exception(""string and integer indexes may not follow named indexes"")\n            #print ""  normal numerical index""\n            return (pos, ind, False)\n  \n    def _getAxis(self, name):\n        for i in range(0, len(self._info)):\n            axis = self._info[i]\n            if \'name\' in axis and axis[\'name\'] == name:\n                return i\n        raise Exception(""No axis named %s.\\n  info=%s"" % (name, self._info))\n  \n    def _getIndex(self, axis, name):\n        ax = self._info[axis]\n        if ax is not None and \'cols\' in ax:\n            for i in range(0, len(ax[\'cols\'])):\n                if \'name\' in ax[\'cols\'][i] and ax[\'cols\'][i][\'name\'] == name:\n                    return i\n        raise Exception(""Axis %d has no column named %s.\\n  info=%s"" % (axis, name, self._info))\n  \n    def _axisCopy(self, i):\n        return copy.deepcopy(self._info[i])\n  \n    def _axisSlice(self, i, cols):\n        #print ""axisSlice"", i, cols\n        if \'cols\' in self._info[i] or \'values\' in self._info[i]:\n            ax = self._axisCopy(i)\n            if \'cols\' in ax:\n                #print ""  slicing columns.."", array(ax[\'cols\']), cols\n                sl = np.array(ax[\'cols\'])[cols]\n                if isinstance(sl, np.ndarray):\n                    sl = list(sl)\n                ax[\'cols\'] = sl\n                #print ""  result:"", ax[\'cols\']\n            if \'values\' in ax:\n                ax[\'values\'] = np.array(ax[\'values\'])[cols]\n        else:\n            ax = self._info[i]\n        #print ""     "", ax\n        return ax\n  \n    def prettyInfo(self):\n        s = \'\'\n        titles = []\n        maxl = 0\n        for i in range(len(self._info)-1):\n            ax = self._info[i]\n            axs = \'\'\n            if \'name\' in ax:\n                axs += \'""%s""\' % str(ax[\'name\'])\n            else:\n                axs += ""%d"" % i\n            if \'units\' in ax:\n                axs += "" (%s)"" % str(ax[\'units\'])\n            titles.append(axs)\n            if len(axs) > maxl:\n                maxl = len(axs)\n        \n        for i in range(min(self.ndim, len(self._info) - 1)):\n            ax = self._info[i]\n            axs = titles[i]\n            axs += \'%s[%d] :\' % (\' \' * (maxl - len(axs) + 5 - len(str(self.shape[i]))), self.shape[i])\n            if \'values\' in ax:\n                if self.shape[i] > 0:\n                    v0 = ax[\'values\'][0]\n                    axs += ""  values: [%g"" % (v0)\n                    if self.shape[i] > 1:\n                        v1 = ax[\'values\'][-1]\n                        axs += "" ... %g] (step %g)"" % (v1, (v1 - v0) / (self.shape[i] - 1))\n                    else:\n                        axs += ""]""\n                else:\n                    axs += ""  values: []""\n            if \'cols\' in ax:\n                axs += "" columns: ""\n                colstrs = []\n                for c in range(len(ax[\'cols\'])):\n                    col = ax[\'cols\'][c]\n                    cs = str(col.get(\'name\', c))\n                    if \'units\' in col:\n                        cs += "" (%s)"" % col[\'units\']\n                    colstrs.append(cs)\n                axs += \'[\' + \', \'.join(colstrs) + \']\'\n            s += axs + ""\\n""\n        s += str(self._info[-1])\n        return s\n  \n    def __repr__(self):\n        return ""%s\\n-----------------------------------------------\\n%s"" % (self.view(np.ndarray).__repr__(), self.prettyInfo())\n\n    def __str__(self):\n        return self.__repr__()\n\n\n    def axisCollapsingFn(self, fn, axis=None, *args, **kargs):\n        #arr = self.view(np.ndarray)\n        fn = getattr(self._data, fn)\n        if axis is None:\n            return fn(axis, *args, **kargs)\n        else:\n            info = self.infoCopy()\n            axis = self._interpretAxis(axis)\n            info.pop(axis)\n            return MetaArray(fn(axis, *args, **kargs), info=info)\n\n    def mean(self, axis=None, *args, **kargs):\n        return self.axisCollapsingFn(\'mean\', axis, *args, **kargs)\n            \n\n    def min(self, axis=None, *args, **kargs):\n        return self.axisCollapsingFn(\'min\', axis, *args, **kargs)\n\n    def max(self, axis=None, *args, **kargs):\n        return self.axisCollapsingFn(\'max\', axis, *args, **kargs)\n\n    def transpose(self, *args):\n        if len(args) == 1 and hasattr(args[0], \'__iter__\'):\n            order = args[0]\n        else:\n            order = args\n        \n        order = [self._interpretAxis(ax) for ax in order]\n        infoOrder = order  + list(range(len(order), len(self._info)))\n        info = [self._info[i] for i in infoOrder]\n        order = order + list(range(len(order), self.ndim))\n        \n        try:\n            if self._isHDF:\n                return MetaArray(np.array(self._data).transpose(order), info=info)\n            else:\n                return MetaArray(self._data.transpose(order), info=info)\n        except:\n            print(order)\n            raise\n\n    #### File I/O Routines\n    def readFile(self, filename, **kwargs):\n        """"""Load the data and meta info stored in *filename*\n        Different arguments are allowed depending on the type of file.\n        For HDF5 files:\n        \n            *writable* (bool) if True, then any modifications to data in the array will be stored to disk.\n            *readAllData* (bool) if True, then all data in the array is immediately read from disk\n                          and the file is closed (this is the default for files < 500MB). Otherwise, the file will\n                          be left open and data will be read only as requested (this is \n                          the default for files >= 500MB).\n        \n        \n        """"""\n        ## decide which read function to use\n        with open(filename, \'rb\') as fd:\n            magic = fd.read(8)\n            if magic == \'\\x89HDF\\r\\n\\x1a\\n\':\n                fd.close()\n                self._readHDF5(filename, **kwargs)\n                self._isHDF = True\n            else:\n                fd.seek(0)\n                meta = MetaArray._readMeta(fd)\n                if not kwargs.get(""readAllData"", True):\n                    self._data = np.empty(meta[\'shape\'], dtype=meta[\'type\'])\n                if \'version\' in meta:\n                    ver = meta[\'version\']\n                else:\n                    ver = 1\n                rFuncName = \'_readData%s\' % str(ver)\n                if not hasattr(MetaArray, rFuncName):\n                    raise Exception(""This MetaArray library does not support array version \'%s\'"" % ver)\n                rFunc = getattr(self, rFuncName)\n                rFunc(fd, meta, **kwargs)\n                self._isHDF = False\n\n    @staticmethod\n    def _readMeta(fd):\n        """"""Read meta array from the top of a file. Read lines until a blank line is reached.\n        This function should ideally work for ALL versions of MetaArray.\n        """"""\n        meta = \'\'\n        ## Read meta information until the first blank line\n        while True:\n            line = fd.readline().strip()\n            if line == \'\':\n                break\n            meta += line\n        ret = eval(meta)\n        #print ret\n        return ret\n\n    def _readData1(self, fd, meta, mmap=False, **kwds):\n        ## Read array data from the file descriptor for MetaArray v1 files\n        ## read in axis values for any axis that specifies a length\n        frameSize = 1\n        for ax in meta[\'info\']:\n            if \'values_len\' in ax:\n                ax[\'values\'] = np.fromstring(fd.read(ax[\'values_len\']), dtype=ax[\'values_type\'])\n                frameSize *= ax[\'values_len\']\n                del ax[\'values_len\']\n                del ax[\'values_type\']\n        self._info = meta[\'info\']\n        if not kwds.get(""readAllData"", True):\n            return\n        ## the remaining data is the actual array\n        if mmap:\n            subarr = np.memmap(fd, dtype=meta[\'type\'], mode=\'r\', shape=meta[\'shape\'])\n        else:\n            subarr = np.fromstring(fd.read(), dtype=meta[\'type\'])\n            subarr.shape = meta[\'shape\']\n        self._data = subarr\n            \n    def _readData2(self, fd, meta, mmap=False, subset=None, **kwds):\n        ## read in axis values\n        dynAxis = None\n        frameSize = 1\n        ## read in axis values for any axis that specifies a length\n        for i in range(len(meta[\'info\'])):\n            ax = meta[\'info\'][i]\n            if \'values_len\' in ax:\n                if ax[\'values_len\'] == \'dynamic\':\n                    if dynAxis is not None:\n                        raise Exception(""MetaArray has more than one dynamic axis! (this is not allowed)"")\n                    dynAxis = i\n                else:\n                    ax[\'values\'] = np.fromstring(fd.read(ax[\'values_len\']), dtype=ax[\'values_type\'])\n                    frameSize *= ax[\'values_len\']\n                    del ax[\'values_len\']\n                    del ax[\'values_type\']\n        self._info = meta[\'info\']\n        if not kwds.get(""readAllData"", True):\n            return\n\n        ## No axes are dynamic, just read the entire array in at once\n        if dynAxis is None:\n            #if rewriteDynamic is not None:\n                #raise Exception("""")\n            if meta[\'type\'] == \'object\':\n                if mmap:\n                    raise Exception(\'memmap not supported for arrays with dtype=object\')\n                subarr = pickle.loads(fd.read())\n            else:\n                if mmap:\n                    subarr = np.memmap(fd, dtype=meta[\'type\'], mode=\'r\', shape=meta[\'shape\'])\n                else:\n                    subarr = np.fromstring(fd.read(), dtype=meta[\'type\'])\n            #subarr = subarr.view(subtype)\n            subarr.shape = meta[\'shape\']\n            #subarr._info = meta[\'info\']\n        ## One axis is dynamic, read in a frame at a time\n        else:\n            if mmap:\n                raise Exception(\'memmap not supported for non-contiguous arrays. Use rewriteContiguous() to convert.\')\n            ax = meta[\'info\'][dynAxis]\n            xVals = []\n            frames = []\n            frameShape = list(meta[\'shape\'])\n            frameShape[dynAxis] = 1\n            frameSize = reduce(lambda a,b: a*b, frameShape)\n            n = 0\n            while True:\n                ## Extract one non-blank line\n                while True:\n                    line = fd.readline()\n                    if line != \'\\n\':\n                        break\n                if line == \'\':\n                    break\n                    \n                ## evaluate line\n                inf = eval(line)\n                \n                ## read data block\n                #print ""read %d bytes as %s"" % (inf[\'len\'], meta[\'type\'])\n                if meta[\'type\'] == \'object\':\n                    data = pickle.loads(fd.read(inf[\'len\']))\n                else:\n                    data = np.fromstring(fd.read(inf[\'len\']), dtype=meta[\'type\'])\n                \n                if data.size != frameSize * inf[\'numFrames\']:\n                    #print data.size, frameSize, inf[\'numFrames\']\n                    raise Exception(""Wrong frame size in MetaArray file! (frame %d)"" % n)\n                    \n                ## read in data block\n                shape = list(frameShape)\n                shape[dynAxis] = inf[\'numFrames\']\n                data.shape = shape\n                if subset is not None:\n                    dSlice = subset[dynAxis]\n                    if dSlice.start is None:\n                        dStart = 0\n                    else:\n                        dStart = max(0, dSlice.start - n)\n                    if dSlice.stop is None:\n                        dStop = data.shape[dynAxis]\n                    else:\n                        dStop = min(data.shape[dynAxis], dSlice.stop - n)\n                    newSubset = list(subset[:])\n                    newSubset[dynAxis] = slice(dStart, dStop)\n                    if dStop > dStart:\n                        #print n, data.shape, "" => "", newSubset, data[tuple(newSubset)].shape\n                        frames.append(data[tuple(newSubset)].copy())\n                else:\n                    #data = data[subset].copy()  ## what\'s this for??\n                    frames.append(data)\n                \n                n += inf[\'numFrames\']\n                if \'xVals\' in inf:\n                    xVals.extend(inf[\'xVals\'])\n            subarr = np.concatenate(frames, axis=dynAxis)\n            if len(xVals)> 0:\n                ax[\'values\'] = np.array(xVals, dtype=ax[\'values_type\'])\n            del ax[\'values_len\']\n            del ax[\'values_type\']\n        #subarr = subarr.view(subtype)\n        #subarr._info = meta[\'info\']\n        self._info = meta[\'info\']\n        self._data = subarr\n        #raise Exception()  ## stress-testing\n        #return subarr\n\n    def _readHDF5(self, fileName, readAllData=None, writable=False, **kargs):\n        if \'close\' in kargs and readAllData is None: ## for backward compatibility\n            readAllData = kargs[\'close\']\n       \n        if readAllData is True and writable is True:\n            raise Exception(""Incompatible arguments: readAllData=True and writable=True"")\n        \n        if not HAVE_HDF5:\n            try:\n                assert writable==False\n                assert readAllData != False\n                self._readHDF5Remote(fileName)\n                return\n            except:\n                raise Exception(""The file \'%s\' is HDF5-formatted, but the HDF5 library (h5py) was not found."" % fileName)\n        \n        ## by default, readAllData=True for files < 500MB\n        if readAllData is None:\n            size = os.stat(fileName).st_size\n            readAllData = (size < 500e6)\n        \n        if writable is True:\n            mode = \'r+\'\n        else:\n            mode = \'r\'\n        f = h5py.File(fileName, mode)\n        \n        ver = f.attrs[\'MetaArray\']\n        if ver > MetaArray.version:\n            print(""Warning: This file was written with MetaArray version %s, but you are using version %s. (Will attempt to read anyway)"" % (str(ver), str(MetaArray.version)))\n        meta = MetaArray.readHDF5Meta(f[\'info\'])\n        self._info = meta\n        \n        if writable or not readAllData:  ## read all data, convert to ndarray, close file\n            self._data = f[\'data\']\n            self._openFile = f\n        else:\n            self._data = f[\'data\'][:]\n            f.close()\n            \n    def _readHDF5Remote(self, fileName):\n        ## Used to read HDF5 files via remote process.\n        ## This is needed in the case that HDF5 is not importable due to the use of python-dbg.\n        proc = getattr(MetaArray, \'_hdf5Process\', None)\n        \n        if proc == False:\n            raise Exception(\'remote read failed\')\n        if proc == None:\n            from .. import multiprocess as mp\n            #print ""new process""\n            proc = mp.Process(executable=\'/usr/bin/python\')\n            proc.setProxyOptions(deferGetattr=True)\n            MetaArray._hdf5Process = proc\n            MetaArray._h5py_metaarray = proc._import(\'pyqtgraph.metaarray\')\n        ma = MetaArray._h5py_metaarray.MetaArray(file=fileName)\n        self._data = ma.asarray()._getValue()\n        self._info = ma._info._getValue()\n        #print MetaArray._hdf5Process\n        #import inspect\n        #print MetaArray, id(MetaArray), inspect.getmodule(MetaArray)\n        \n        \n\n    @staticmethod\n    def mapHDF5Array(data, writable=False):\n        off = data.id.get_offset()\n        if writable:\n            mode = \'r+\'\n        else:\n            mode = \'r\'\n        if off is None:\n            raise Exception(""This dataset uses chunked storage; it can not be memory-mapped. (store using mappable=True)"")\n        return np.memmap(filename=data.file.filename, offset=off, dtype=data.dtype, shape=data.shape, mode=mode)\n        \n\n\n\n    @staticmethod\n    def readHDF5Meta(root, mmap=False):\n        data = {}\n        \n        ## Pull list of values from attributes and child objects\n        for k in root.attrs:\n            val = root.attrs[k]\n            if isinstance(val, basestring):  ## strings need to be re-evaluated to their original types\n                try:\n                    val = eval(val)\n                except:\n                    raise Exception(\'Can not evaluate string: ""%s""\' % val)\n            data[k] = val\n        for k in root:\n            obj = root[k]\n            if isinstance(obj, h5py.highlevel.Group):\n                val = MetaArray.readHDF5Meta(obj)\n            elif isinstance(obj, h5py.highlevel.Dataset):\n                if mmap:\n                    val = MetaArray.mapHDF5Array(obj)\n                else:\n                    val = obj[:]\n            else:\n                raise Exception(""Don\'t know what to do with type \'%s\'"" % str(type(obj)))\n            data[k] = val\n        \n        typ = root.attrs[\'_metaType_\']\n        del data[\'_metaType_\']\n        \n        if typ == \'dict\':\n            return data\n        elif typ == \'list\' or typ == \'tuple\':\n            d2 = [None]*len(data)\n            for k in data:\n                d2[int(k)] = data[k]\n            if typ == \'tuple\':\n                d2 = tuple(d2)\n            return d2\n        else:\n            raise Exception(""Don\'t understand metaType \'%s\'"" % typ)\n        \n\n    def write(self, fileName, **opts):\n        """"""Write this object to a file. The object can be restored by calling MetaArray(file=fileName)\n        opts:\n            appendAxis: the name (or index) of the appendable axis. Allows the array to grow.\n            appendKeys: a list of keys (other than ""values"") for metadata to append to on the appendable axis.\n            compression: None, \'gzip\' (good compression), \'lzf\' (fast compression), etc.\n            chunks: bool or tuple specifying chunk shape\n        """"""\n        \n        if USE_HDF5 and HAVE_HDF5:\n            return self.writeHDF5(fileName, **opts)\n        else:\n            return self.writeMa(fileName, **opts)\n\n    def writeMeta(self, fileName):\n        """"""Used to re-write meta info to the given file.\n        This feature is only available for HDF5 files.""""""\n        f = h5py.File(fileName, \'r+\')\n        if f.attrs[\'MetaArray\'] != MetaArray.version:\n            raise Exception(""The file %s was created with a different version of MetaArray. Will not modify."" % fileName)\n        del f[\'info\']\n        \n        self.writeHDF5Meta(f, \'info\', self._info)\n        f.close()\n\n\n    def writeHDF5(self, fileName, **opts):\n        ## default options for writing datasets\n        comp = self.defaultCompression\n        if isinstance(comp, tuple):\n            comp, copts = comp\n        else:\n            copts = None\n\n        dsOpts = {  \n            \'compression\': comp,\n            \'chunks\': True,\n        }\n        if copts is not None:\n            dsOpts[\'compression_opts\'] = copts\n        \n        ## if there is an appendable axis, then we can guess the desired chunk shape (optimized for appending)\n        appAxis = opts.get(\'appendAxis\', None)\n        if appAxis is not None:\n            appAxis = self._interpretAxis(appAxis)\n            cs = [min(100000, x) for x in self.shape]\n            cs[appAxis] = 1\n            dsOpts[\'chunks\'] = tuple(cs)\n            \n        ## if there are columns, then we can guess a different chunk shape\n        ## (read one column at a time)\n        else:\n            cs = [min(100000, x) for x in self.shape]\n            for i in range(self.ndim):\n                if \'cols\' in self._info[i]:\n                    cs[i] = 1\n            dsOpts[\'chunks\'] = tuple(cs)\n        \n        ## update options if they were passed in\n        for k in dsOpts:\n            if k in opts:\n                dsOpts[k] = opts[k]\n        \n        \n        ## If mappable is in options, it disables chunking/compression\n        if opts.get(\'mappable\', False):\n            dsOpts = {\n                \'chunks\': None,\n                \'compression\': None\n            }\n            \n        ## set maximum shape to allow expansion along appendAxis\n        append = False\n        if appAxis is not None:\n            maxShape = list(self.shape)\n            ax = self._interpretAxis(appAxis)\n            maxShape[ax] = None\n            if os.path.exists(fileName):\n                append = True\n            dsOpts[\'maxshape\'] = tuple(maxShape)\n        else:\n            dsOpts[\'maxshape\'] = None\n            \n        if append:\n            f = h5py.File(fileName, \'r+\')\n            if f.attrs[\'MetaArray\'] != MetaArray.version:\n                raise Exception(""The file %s was created with a different version of MetaArray. Will not modify."" % fileName)\n            \n            ## resize data and write in new values\n            data = f[\'data\']\n            shape = list(data.shape)\n            shape[ax] += self.shape[ax]\n            data.resize(tuple(shape))\n            sl = [slice(None)] * len(data.shape)\n            sl[ax] = slice(-self.shape[ax], None)\n            data[tuple(sl)] = self.view(np.ndarray)\n            \n            ## add axis values if they are present.\n            axKeys = [""values""]\n            axKeys.extend(opts.get(""appendKeys"", []))\n            axInfo = f[\'info\'][str(ax)]\n            for key in axKeys:\n                if key in axInfo:\n                    v = axInfo[key]\n                    v2 = self._info[ax][key]\n                    shape = list(v.shape)\n                    shape[0] += v2.shape[0]\n                    v.resize(shape)\n                    v[-v2.shape[0]:] = v2\n                else:\n                    raise TypeError(\'Cannot append to axis info key ""%s""; this key is not present in the target file.\' % key)\n            f.close()\n        else:\n            f = h5py.File(fileName, \'w\')\n            f.attrs[\'MetaArray\'] = MetaArray.version\n            #print dsOpts\n            f.create_dataset(\'data\', data=self.view(np.ndarray), **dsOpts)\n            \n            ## dsOpts is used when storing meta data whenever an array is encountered\n            ## however, \'chunks\' will no longer be valid for these arrays if it specifies a chunk shape.\n            ## \'maxshape\' is right-out.\n            if isinstance(dsOpts[\'chunks\'], tuple):\n                dsOpts[\'chunks\'] = True\n                if \'maxshape\' in dsOpts:\n                    del dsOpts[\'maxshape\']\n            self.writeHDF5Meta(f, \'info\', self._info, **dsOpts)\n            f.close()\n\n    def writeHDF5Meta(self, root, name, data, **dsOpts):\n        if isinstance(data, np.ndarray):\n            dsOpts[\'maxshape\'] = (None,) + data.shape[1:]\n            root.create_dataset(name, data=data, **dsOpts)\n        elif isinstance(data, list) or isinstance(data, tuple):\n            gr = root.create_group(name)\n            if isinstance(data, list):\n                gr.attrs[\'_metaType_\'] = \'list\'\n            else:\n                gr.attrs[\'_metaType_\'] = \'tuple\'\n            #n = int(np.log10(len(data))) + 1\n            for i in range(len(data)):\n                self.writeHDF5Meta(gr, str(i), data[i], **dsOpts)\n        elif isinstance(data, dict):\n            gr = root.create_group(name)\n            gr.attrs[\'_metaType_\'] = \'dict\'\n            for k, v in data.items():\n                self.writeHDF5Meta(gr, k, v, **dsOpts)\n        elif isinstance(data, int) or isinstance(data, float) or isinstance(data, np.integer) or isinstance(data, np.floating):\n            root.attrs[name] = data\n        else:\n            try:   ## strings, bools, None are stored as repr() strings\n                root.attrs[name] = repr(data)\n            except:\n                print(""Can not store meta data of type \'%s\' in HDF5. (key is \'%s\')"" % (str(type(data)), str(name)))\n                raise \n\n        \n    def writeMa(self, fileName, appendAxis=None, newFile=False):\n        """"""Write an old-style .ma file""""""\n        meta = {\'shape\':self.shape, \'type\':str(self.dtype), \'info\':self.infoCopy(), \'version\':MetaArray.version}\n        axstrs = []\n        \n        ## copy out axis values for dynamic axis if requested\n        if appendAxis is not None:\n            if MetaArray.isNameType(appendAxis):\n                appendAxis = self._interpretAxis(appendAxis)\n            \n            \n            ax = meta[\'info\'][appendAxis]\n            ax[\'values_len\'] = \'dynamic\'\n            if \'values\' in ax:\n                ax[\'values_type\'] = str(ax[\'values\'].dtype)\n                dynXVals = ax[\'values\']\n                del ax[\'values\']\n            else:\n                dynXVals = None\n                \n        ## Generate axis data string, modify axis info so we know how to read it back in later\n        for ax in meta[\'info\']:\n            if \'values\' in ax:\n                axstrs.append(ax[\'values\'].tostring())\n                ax[\'values_len\'] = len(axstrs[-1])\n                ax[\'values_type\'] = str(ax[\'values\'].dtype)\n                del ax[\'values\']\n                \n        ## Decide whether to output the meta block for a new file\n        if not newFile:\n            ## If the file does not exist or its size is 0, then we must write the header\n            newFile = (not os.path.exists(fileName))  or  (os.stat(fileName).st_size == 0)\n        \n        ## write data to file\n        if appendAxis is None or newFile:\n            fd = open(fileName, \'wb\')\n            fd.write(str(meta) + \'\\n\\n\')\n            for ax in axstrs:\n                fd.write(ax)\n        else:\n            fd = open(fileName, \'ab\')\n        \n        if self.dtype != object:\n            dataStr = self.view(np.ndarray).tostring()\n        else:\n            dataStr = pickle.dumps(self.view(np.ndarray))\n        #print self.size, len(dataStr), self.dtype\n        if appendAxis is not None:\n            frameInfo = {\'len\':len(dataStr), \'numFrames\':self.shape[appendAxis]}\n            if dynXVals is not None:\n                frameInfo[\'xVals\'] = list(dynXVals)\n            fd.write(\'\\n\'+str(frameInfo)+\'\\n\')\n        fd.write(dataStr)\n        fd.close()\n        \n    def writeCsv(self, fileName=None):\n        """"""Write 2D array to CSV file or return the string if no filename is given""""""\n        if self.ndim > 2:\n            raise Exception(""CSV Export is only for 2D arrays"")\n        if fileName is not None:\n            file = open(fileName, \'w\')\n        ret = \'\'\n        if \'cols\' in self._info[0]:\n            s = \',\'.join([x[\'name\'] for x in self._info[0][\'cols\']]) + \'\\n\'\n            if fileName is not None:\n                file.write(s)\n            else:\n                ret += s\n        for row in range(0, self.shape[1]):\n            s = \',\'.join([""%g"" % x for x in self[:, row]]) + \'\\n\'\n            if fileName is not None:\n                file.write(s)\n            else:\n                ret += s\n        if fileName is not None:\n            file.close()\n        else:\n            return ret\n        \n\n\n#class H5MetaList():\n    \n\n#def rewriteContiguous(fileName, newName):\n    #""""""Rewrite a dynamic array file as contiguous""""""\n    #def _readData2(fd, meta, subtype, mmap):\n        ### read in axis values\n        #dynAxis = None\n        #frameSize = 1\n        ### read in axis values for any axis that specifies a length\n        #for i in range(len(meta[\'info\'])):\n            #ax = meta[\'info\'][i]\n            #if ax.has_key(\'values_len\'):\n                #if ax[\'values_len\'] == \'dynamic\':\n                    #if dynAxis is not None:\n                        #raise Exception(""MetaArray has more than one dynamic axis! (this is not allowed)"")\n                    #dynAxis = i\n                #else:\n                    #ax[\'values\'] = fromstring(fd.read(ax[\'values_len\']), dtype=ax[\'values_type\'])\n                    #frameSize *= ax[\'values_len\']\n                    #del ax[\'values_len\']\n                    #del ax[\'values_type\']\n                    \n        ### No axes are dynamic, just read the entire array in at once\n        #if dynAxis is None:\n            #raise Exception(\'Array has no dynamic axes.\')\n        ### One axis is dynamic, read in a frame at a time\n        #else:\n            #if mmap:\n                #raise Exception(\'memmap not supported for non-contiguous arrays. Use rewriteContiguous() to convert.\')\n            #ax = meta[\'info\'][dynAxis]\n            #xVals = []\n            #frames = []\n            #frameShape = list(meta[\'shape\'])\n            #frameShape[dynAxis] = 1\n            #frameSize = reduce(lambda a,b: a*b, frameShape)\n            #n = 0\n            #while True:\n                ### Extract one non-blank line\n                #while True:\n                    #line = fd.readline()\n                    #if line != \'\\n\':\n                        #break\n                #if line == \'\':\n                    #break\n                    \n                ### evaluate line\n                #inf = eval(line)\n                \n                ### read data block\n                ##print ""read %d bytes as %s"" % (inf[\'len\'], meta[\'type\'])\n                #if meta[\'type\'] == \'object\':\n                    #data = pickle.loads(fd.read(inf[\'len\']))\n                #else:\n                    #data = fromstring(fd.read(inf[\'len\']), dtype=meta[\'type\'])\n                \n                #if data.size != frameSize * inf[\'numFrames\']:\n                    ##print data.size, frameSize, inf[\'numFrames\']\n                    #raise Exception(""Wrong frame size in MetaArray file! (frame %d)"" % n)\n                    \n                ### read in data block\n                #shape = list(frameShape)\n                #shape[dynAxis] = inf[\'numFrames\']\n                #data.shape = shape\n                #frames.append(data)\n                \n                #n += inf[\'numFrames\']\n                #if \'xVals\' in inf:\n                    #xVals.extend(inf[\'xVals\'])\n            #subarr = np.concatenate(frames, axis=dynAxis)\n            #if len(xVals)> 0:\n                #ax[\'values\'] = array(xVals, dtype=ax[\'values_type\'])\n            #del ax[\'values_len\']\n            #del ax[\'values_type\']\n        #subarr = subarr.view(subtype)\n        #subarr._info = meta[\'info\']\n        #return subarr\n    \n\n\n  \n  \nif __name__ == \'__main__\':\n    ## Create an array with every option possible\n    \n    arr = np.zeros((2, 5, 3, 5), dtype=int)\n    for i in range(arr.shape[0]):\n        for j in range(arr.shape[1]):\n            for k in range(arr.shape[2]):\n                for l in range(arr.shape[3]):\n                    arr[i,j,k,l] = (i+1)*1000 + (j+1)*100 + (k+1)*10 + (l+1)\n        \n    info = [\n        axis(\'Axis1\'), \n        axis(\'Axis2\', values=[1,2,3,4,5]), \n        axis(\'Axis3\', cols=[\n            (\'Ax3Col1\'),\n            (\'Ax3Col2\', \'mV\', \'Axis3 Column2\'),\n            ((\'Ax3\',\'Col3\'), \'A\', \'Axis3 Column3\')]),\n        {\'name\': \'Axis4\', \'values\': np.array([1.1, 1.2, 1.3, 1.4, 1.5]), \'units\': \'s\'},\n        {\'extra\': \'info\'}\n    ]\n    \n    ma = MetaArray(arr, info=info)\n    \n    print(""====  Original Array ======="")\n    print(ma)\n    print(""\\n\\n"")\n    \n    #### Tests follow:\n    \n    \n    #### Index/slice tests: check that all values and meta info are correct after slice\n    print(""\\n -- normal integer indexing\\n"")\n    \n    print(""\\n  ma[1]"")\n    print(ma[1])\n    \n    print(""\\n  ma[1, 2:4]"")\n    print(ma[1, 2:4])\n    \n    print(""\\n  ma[1, 1:5:2]"")\n    print(ma[1, 1:5:2])\n    \n    print(""\\n -- named axis indexing\\n"")\n    \n    print(""\\n  ma[\'Axis2\':3]"")\n    print(ma[\'Axis2\':3])\n    \n    print(""\\n  ma[\'Axis2\':3:5]"")\n    print(ma[\'Axis2\':3:5])\n    \n    print(""\\n  ma[1, \'Axis2\':3]"")\n    print(ma[1, \'Axis2\':3])\n    \n    print(""\\n  ma[:, \'Axis2\':3]"")\n    print(ma[:, \'Axis2\':3])\n    \n    print(""\\n  ma[\'Axis2\':3, \'Axis4\':0:2]"")\n    print(ma[\'Axis2\':3, \'Axis4\':0:2])\n    \n    \n    print(""\\n -- column name indexing\\n"")\n    \n    print(""\\n  ma[\'Axis3\':\'Ax3Col1\']"")\n    print(ma[\'Axis3\':\'Ax3Col1\'])\n    \n    print(""\\n  ma[\'Axis3\':(\'Ax3\',\'Col3\')]"")\n    print(ma[\'Axis3\':(\'Ax3\',\'Col3\')])\n    \n    print(""\\n  ma[:, :, \'Ax3Col2\']"")\n    print(ma[:, :, \'Ax3Col2\'])\n    \n    print(""\\n  ma[:, :, (\'Ax3\',\'Col3\')]"")\n    print(ma[:, :, (\'Ax3\',\'Col3\')])\n    \n    \n    print(""\\n -- axis value range indexing\\n"")\n    \n    print(""\\n  ma[\'Axis2\':1.5:4.5]"")\n    print(ma[\'Axis2\':1.5:4.5])\n    \n    print(""\\n  ma[\'Axis4\':1.15:1.45]"")\n    print(ma[\'Axis4\':1.15:1.45])\n    \n    print(""\\n  ma[\'Axis4\':1.15:1.25]"")\n    print(ma[\'Axis4\':1.15:1.25])\n    \n    \n    \n    print(""\\n -- list indexing\\n"")\n    \n    print(""\\n  ma[:, [0,2,4]]"")\n    print(ma[:, [0,2,4]])\n    \n    print(""\\n  ma[\'Axis4\':[0,2,4]]"")\n    print(ma[\'Axis4\':[0,2,4]])\n    \n    print(""\\n  ma[\'Axis3\':[0, (\'Ax3\',\'Col3\')]]"")\n    print(ma[\'Axis3\':[0, (\'Ax3\',\'Col3\')]])\n    \n    \n    \n    print(""\\n -- boolean indexing\\n"")\n    \n    print(""\\n  ma[:, array([True, True, False, True, False])]"")\n    print(ma[:, np.array([True, True, False, True, False])])\n    \n    print(""\\n  ma[\'Axis4\':array([True, False, False, False])]"")\n    print(ma[\'Axis4\':np.array([True, False, False, False])])\n    \n    \n    \n    \n    \n    #### Array operations \n    #  - Concatenate\n    #  - Append\n    #  - Extend\n    #  - Rowsort\n    \n    \n    \n    \n    #### File I/O tests\n    \n    print(""\\n================  File I/O Tests  ===================\\n"")\n    import tempfile\n    tf = tempfile.mktemp()\n    tf = \'test.ma\'\n    # write whole array\n    \n    print(""\\n  -- write/read test"")\n    ma.write(tf)\n    ma2 = MetaArray(file=tf)\n    \n    #print ma2\n    print(""\\nArrays are equivalent:"", (ma == ma2).all())\n    #print ""Meta info is equivalent:"", ma.infoCopy() == ma2.infoCopy()\n    os.remove(tf)\n    \n    # CSV write\n    \n    # append mode\n    \n    \n    print(""\\n================append test (%s)==============="" % tf)\n    ma[\'Axis2\':0:2].write(tf, appendAxis=\'Axis2\')\n    for i in range(2,ma.shape[1]):\n        ma[\'Axis2\':[i]].write(tf, appendAxis=\'Axis2\')\n    \n    ma2 = MetaArray(file=tf)\n    \n    #print ma2\n    print(""\\nArrays are equivalent:"", (ma == ma2).all())\n    #print ""Meta info is equivalent:"", ma.infoCopy() == ma2.infoCopy()\n    \n    os.remove(tf)    \n    \n    \n    \n    ## memmap test\n    print(""\\n==========Memmap test============"")\n    ma.write(tf, mappable=True)\n    ma2 = MetaArray(file=tf, mmap=True)\n    print(""\\nArrays are equivalent:"", (ma == ma2).all())\n    os.remove(tf)    \n    \n'"
src/third_party/pyqtgraph/metaarray/__init__.py,0,b'from .MetaArray import *\n'
src/third_party/pyqtgraph/multiprocess/__init__.py,0,"b'""""""\nMultiprocessing utility library\n(parallelization done the way I like it)\n\nLuke Campagnola\n2012.06.10\n\nThis library provides:\n\n  - simple mechanism for starting a new python interpreter process that can be controlled from the original process\n    (this allows, for example, displaying and manipulating plots in a remote process\n    while the parent process is free to do other work)\n  - proxy system that allows objects hosted in the remote process to be used as if they were local\n  - Qt signal connection between processes\n  - very simple in-line parallelization (fork only; does not work on windows) for number-crunching\n\nTODO:\n    allow remote processes to serve as rendering engines that pass pixmaps back to the parent process for display\n    (RemoteGraphicsView class)\n""""""\n\nfrom .processes import *\nfrom .parallelizer import Parallelize, CanceledError\nfrom .remoteproxy import proxy, ClosedError, NoResultError\n'"
src/third_party/pyqtgraph/multiprocess/bootstrap.py,0,"b'""""""For starting up remote processes""""""\nimport sys, pickle, os\n\nif __name__ == \'__main__\':\n    if hasattr(os, \'setpgrp\'):\n        os.setpgrp()  ## prevents signals (notably keyboard interrupt) being forwarded from parent to this process\n    if sys.version[0] == \'3\':\n        #name, port, authkey, ppid, targetStr, path, pyside = pickle.load(sys.stdin.buffer)\n        opts = pickle.load(sys.stdin.buffer)\n    else:\n        #name, port, authkey, ppid, targetStr, path, pyside = pickle.load(sys.stdin)\n        opts = pickle.load(sys.stdin)\n    #print ""key:"",  \' \'.join([str(ord(x)) for x in authkey])\n    path = opts.pop(\'path\', None)\n    if path is not None:\n        if isinstance(path, str):\n            # if string, just insert this into the path\n            sys.path.insert(0, path)\n        else:\n            # if list, then replace the entire sys.path\n            ## modify sys.path in place--no idea who already has a reference to the existing list.\n            while len(sys.path) > 0:\n                sys.path.pop()\n            sys.path.extend(path)\n\n    pyqtapis = opts.pop(\'pyqtapis\', None)\n    if pyqtapis is not None:\n        import sip\n        for k,v in pyqtapis.items():\n            sip.setapi(k, v)\n        \n    qt_lib = opts.pop(\'qt_lib\', None)\n    if qt_lib == \'PySide\':\n        import PySide\n    elif qt_lib == \'PySide2\':\n        import PySide2\n    elif qt_lib == \'PyQt5\':\n        import PyQt5        \n    \n    targetStr = opts.pop(\'targetStr\')\n    try:\n        target = pickle.loads(targetStr)  ## unpickling the target should import everything we need\n    except:\n        print(""Current sys.path:"", sys.path)\n        raise\n    target(**opts)  ## Send all other options to the target function\n    sys.exit(0)\n'"
src/third_party/pyqtgraph/multiprocess/parallelizer.py,0,"b'import os, sys, time, multiprocessing, re\nfrom .processes import ForkedProcess\nfrom .remoteproxy import ClosedError\nfrom ..python2_3 import basestring, xrange\n\n\nclass CanceledError(Exception):\n    """"""Raised when the progress dialog is canceled during a processing operation.""""""\n    pass\n\nclass Parallelize(object):\n    """"""\n    Class for ultra-simple inline parallelization on multi-core CPUs\n    \n    Example::\n    \n        ## Here is the serial (single-process) task:\n        \n        tasks = [1, 2, 4, 8]\n        results = []\n        for task in tasks:\n            result = processTask(task)\n            results.append(result)\n        print(results)\n        \n        \n        ## Here is the parallelized version:\n        \n        tasks = [1, 2, 4, 8]\n        results = []\n        with Parallelize(tasks, workers=4, results=results) as tasker:\n            for task in tasker:\n                result = processTask(task)\n                tasker.results.append(result)\n        print(results)\n        \n        \n    The only major caveat is that *result* in the example above must be picklable,\n    since it is automatically sent via pipe back to the parent process.\n    """"""\n\n    def __init__(self, tasks=None, workers=None, block=True, progressDialog=None, randomReseed=True, **kwds):\n        """"""\n        ===============  ===================================================================\n        **Arguments:**\n        tasks            list of objects to be processed (Parallelize will determine how to \n                         distribute the tasks). If unspecified, then each worker will receive\n                         a single task with a unique id number.\n        workers          number of worker processes or None to use number of CPUs in the \n                         system\n        progressDialog   optional dict of arguments for ProgressDialog\n                         to update while tasks are processed\n        randomReseed     If True, each forked process will reseed its random number generator\n                         to ensure independent results. Works with the built-in random\n                         and numpy.random.\n        kwds             objects to be shared by proxy with child processes (they will \n                         appear as attributes of the tasker)\n        ===============  ===================================================================\n        """"""\n        \n        ## Generate progress dialog. \n        ## Note that we want to avoid letting forked child processes play with progress dialogs..\n        self.showProgress = False\n        if progressDialog is not None:\n            self.showProgress = True\n            if isinstance(progressDialog, basestring):\n                progressDialog = {\'labelText\': progressDialog}\n            from ..widgets.ProgressDialog import ProgressDialog\n            self.progressDlg = ProgressDialog(**progressDialog)\n        \n        if workers is None:\n            workers = self.suggestedWorkerCount()\n        if not hasattr(os, \'fork\'):\n            workers = 1\n        self.workers = workers\n        if tasks is None:\n            tasks = range(workers)\n        self.tasks = list(tasks)\n        self.reseed = randomReseed\n        self.kwds = kwds.copy()\n        self.kwds[\'_taskStarted\'] = self._taskStarted\n        \n    def __enter__(self):\n        self.proc = None\n        if self.workers == 1: \n            return self.runSerial()\n        else:\n            return self.runParallel()\n    \n    def __exit__(self, *exc_info):\n        \n        if self.proc is not None:  ## worker \n            exceptOccurred = exc_info[0] is not None ## hit an exception during processing.\n                \n            try:\n                if exceptOccurred:\n                    sys.excepthook(*exc_info)\n            finally:\n                #print os.getpid(), \'exit\'\n                os._exit(1 if exceptOccurred else 0)\n                \n        else:  ## parent\n            if self.showProgress:\n                try:\n                    self.progressDlg.__exit__(None, None, None)\n                except Exception:\n                    pass\n\n    def runSerial(self):\n        if self.showProgress:\n            self.progressDlg.__enter__()\n            self.progressDlg.setMaximum(len(self.tasks))\n        self.progress = {os.getpid(): []}\n        return Tasker(self, None, self.tasks, self.kwds)\n\n    \n    def runParallel(self):\n        self.childs = []\n        \n        ## break up tasks into one set per worker\n        workers = self.workers\n        chunks = [[] for i in xrange(workers)]\n        i = 0\n        for i in range(len(self.tasks)):\n            chunks[i%workers].append(self.tasks[i])\n        \n        ## fork and assign tasks to each worker\n        for i in range(workers):\n            proc = ForkedProcess(target=None, preProxy=self.kwds, randomReseed=self.reseed)\n            if not proc.isParent:\n                self.proc = proc\n                return Tasker(self, proc, chunks[i], proc.forkedProxies)\n            else:\n                self.childs.append(proc)\n        \n        ## Keep track of the progress of each worker independently.\n        self.progress = dict([(ch.childPid, []) for ch in self.childs])\n        ## for each child process, self.progress[pid] is a list\n        ## of task indexes. The last index is the task currently being\n        ## processed; all others are finished.\n            \n            \n        try:\n            if self.showProgress:\n                self.progressDlg.__enter__()\n                self.progressDlg.setMaximum(len(self.tasks))\n            ## process events from workers until all have exited.\n                \n            activeChilds = self.childs[:]\n            self.exitCodes = []\n            pollInterval = 0.01\n            while len(activeChilds) > 0:\n                waitingChildren = 0\n                rem = []\n                for ch in activeChilds:\n                    try:\n                        n = ch.processRequests()\n                        if n > 0:\n                            waitingChildren += 1\n                    except ClosedError:\n                        #print ch.childPid, \'process finished\'\n                        rem.append(ch)\n                        if self.showProgress:\n                            self.progressDlg += 1\n                #print ""remove:"", [ch.childPid for ch in rem]\n                for ch in rem:\n                    activeChilds.remove(ch)\n                    while True:\n                        try:\n                            pid, exitcode = os.waitpid(ch.childPid, 0)\n                            self.exitCodes.append(exitcode)\n                            break\n                        except OSError as ex:\n                            if ex.errno == 4:  ## If we get this error, just try again\n                                continue\n                                #print ""Ignored system call interruption""\n                            else:\n                                raise\n                    \n                    #print [ch.childPid for ch in activeChilds]\n                    \n                if self.showProgress and self.progressDlg.wasCanceled():\n                    for ch in activeChilds:\n                        ch.kill()\n                    raise CanceledError()\n                    \n                ## adjust polling interval--prefer to get exactly 1 event per poll cycle.\n                if waitingChildren > 1:\n                    pollInterval *= 0.7\n                elif waitingChildren == 0:\n                    pollInterval /= 0.7\n                pollInterval = max(min(pollInterval, 0.5), 0.0005) ## but keep it within reasonable limits\n                \n                time.sleep(pollInterval)\n        finally:\n            if self.showProgress:\n                self.progressDlg.__exit__(None, None, None)\n            for ch in self.childs:\n                ch.join()\n        if len(self.exitCodes) < len(self.childs):\n            raise Exception(""Parallelizer started %d processes but only received exit codes from %d."" % (len(self.childs), len(self.exitCodes)))\n        for code in self.exitCodes:\n            if code != 0:\n                raise Exception(""Error occurred in parallel-executed subprocess (console output may have more information)."")\n        return []  ## no tasks for parent process.\n    \n    \n    @staticmethod\n    def suggestedWorkerCount():\n        if \'linux\' in sys.platform:\n            ## I think we can do a little better here..\n            ## cpu_count does not consider that there is little extra benefit to using hyperthreaded cores.\n            try:\n                cores = {}\n                pid = None\n                \n                for line in open(\'/proc/cpuinfo\'):\n                    m = re.match(r\'physical id\\s+:\\s+(\\d+)\', line)\n                    if m is not None:\n                        pid = m.groups()[0]\n                    m = re.match(r\'cpu cores\\s+:\\s+(\\d+)\', line)\n                    if m is not None:\n                        cores[pid] = int(m.groups()[0])\n                return sum(cores.values())\n            except:\n                return multiprocessing.cpu_count()\n                \n        else:\n            return multiprocessing.cpu_count()\n        \n    def _taskStarted(self, pid, i, **kwds):\n        ## called remotely by tasker to indicate it has started working on task i\n        #print pid, \'reported starting task\', i\n        if self.showProgress:\n            if len(self.progress[pid]) > 0:\n                self.progressDlg += 1\n            if pid == os.getpid():  ## single-worker process\n                if self.progressDlg.wasCanceled():\n                    raise CanceledError()\n        self.progress[pid].append(i)\n    \n    \nclass Tasker(object):\n    def __init__(self, parallelizer, process, tasks, kwds):\n        self.proc = process\n        self.par = parallelizer\n        self.tasks = tasks\n        for k, v in kwds.items():\n            setattr(self, k, v)\n        \n    def __iter__(self):\n        ## we could fix this up such that tasks are retrieved from the parent process one at a time..\n        for i, task in enumerate(self.tasks):\n            self.index = i\n            #print os.getpid(), \'starting task\', i\n            self._taskStarted(os.getpid(), i, _callSync=\'off\')\n            yield task\n        if self.proc is not None:\n            #print os.getpid(), \'no more tasks\'\n            self.proc.close()\n    \n    def process(self):\n        """"""\n        Process requests from parent.\n        Usually it is not necessary to call this unless you would like to \n        receive messages (such as exit requests) during an iteration.\n        """"""\n        if self.proc is not None:\n            self.proc.processRequests()\n    \n    def numWorkers(self):\n        """"""\n        Return the number of parallel workers\n        """"""\n        return self.par.workers\n    \n#class Parallelizer:\n    #""""""\n    #Use::\n    \n        #p = Parallelizer()\n        #with p(4) as i:\n            #p.finish(do_work(i))\n        #print p.results()\n    \n    #""""""\n    #def __init__(self):\n        #pass\n\n    #def __call__(self, n):\n        #self.replies = []\n        #self.conn = None  ## indicates this is the parent process\n        #return Session(self, n)\n            \n    #def finish(self, data):\n        #if self.conn is None:\n            #self.replies.append((self.i, data))\n        #else:\n            ##print ""send"", self.i, data\n            #self.conn.send((self.i, data))\n            #os._exit(0)\n            \n    #def result(self):\n        #print self.replies\n        \n#class Session:\n    #def __init__(self, par, n):\n        #self.par = par\n        #self.n = n\n        \n    #def __enter__(self):\n        #self.childs = []\n        #for i in range(1, self.n):\n            #c1, c2 = multiprocessing.Pipe()\n            #pid = os.fork()\n            #if pid == 0:  ## child\n                #self.par.i = i\n                #self.par.conn = c2\n                #self.childs = None\n                #c1.close()\n                #return i\n            #else:\n                #self.childs.append(c1)\n                #c2.close()\n        #self.par.i = 0\n        #return 0\n            \n        \n        \n    #def __exit__(self, *exc_info):\n        #if exc_info[0] is not None:\n            #sys.excepthook(*exc_info)\n        #if self.childs is not None:\n            #self.par.replies.extend([conn.recv() for conn in self.childs])\n        #else:\n            #self.par.finish(None)\n        \n'"
src/third_party/pyqtgraph/multiprocess/processes.py,0,"b'import subprocess, atexit, os, sys, time, random, socket, signal, inspect\nimport multiprocessing.connection\ntry:\n    import cPickle as pickle\nexcept ImportError:\n    import pickle\n\nfrom .remoteproxy import RemoteEventHandler, ClosedError, NoResultError, LocalObjectProxy, ObjectProxy\nfrom ..Qt import QT_LIB\nfrom ..util import cprint  # color printing for debugging\n\n\n__all__ = [\'Process\', \'QtProcess\', \'ForkedProcess\', \'ClosedError\', \'NoResultError\']\n\nclass Process(RemoteEventHandler):\n    """"""\n    Bases: RemoteEventHandler\n    \n    This class is used to spawn and control a new python interpreter.\n    It uses subprocess.Popen to start the new process and communicates with it\n    using multiprocessing.Connection objects over a network socket.\n    \n    By default, the remote process will immediately enter an event-processing\n    loop that carries out requests send from the parent process.\n    \n    Remote control works mainly through proxy objects::\n    \n        proc = Process()              ## starts process, returns handle\n        rsys = proc._import(\'sys\')    ## asks remote process to import \'sys\', returns\n                                      ## a proxy which references the imported module\n        rsys.stdout.write(\'hello\\n\')  ## This message will be printed from the remote \n                                      ## process. Proxy objects can usually be used\n                                      ## exactly as regular objects are.\n        proc.close()                  ## Request the remote process shut down\n    \n    Requests made via proxy objects may be synchronous or asynchronous and may\n    return objects either by proxy or by value (if they are picklable). See\n    ProxyObject for more information.\n    """"""\n    _process_count = 1  # just used for assigning colors to each process for debugging\n\n    def __init__(self, name=None, target=None, executable=None, copySysPath=True, debug=False, timeout=20, wrapStdout=None, pyqtapis=None):\n        """"""\n        ==============  =============================================================\n        **Arguments:**\n        name            Optional name for this process used when printing messages\n                        from the remote process.\n        target          Optional function to call after starting remote process.\n                        By default, this is startEventLoop(), which causes the remote\n                        process to handle requests from the parent process until it\n                        is asked to quit. If you wish to specify a different target,\n                        it must be picklable (bound methods are not).\n        copySysPath     If True, copy the contents of sys.path to the remote process.\n                        If False, then only the path required to import pyqtgraph is\n                        added.\n        debug           If True, print detailed information about communication\n                        with the child process.\n        wrapStdout      If True (default on windows) then stdout and stderr from the\n                        child process will be caught by the parent process and\n                        forwarded to its stdout/stderr. This provides a workaround\n                        for a python bug: http://bugs.python.org/issue3905\n                        but has the side effect that child output is significantly\n                        delayed relative to the parent output.\n        pyqtapis        Optional dictionary of PyQt API version numbers to set before\n                        importing pyqtgraph in the remote process.\n        ==============  =============================================================\n        """"""\n        if target is None:\n            target = startEventLoop\n        if name is None:\n            name = str(self)\n        if executable is None:\n            executable = sys.executable\n        self.debug = 7 if debug is True else False  # 7 causes printing in white\n        \n        ## random authentication key\n        authkey = os.urandom(20)\n\n        ## Windows seems to have a hard time with hmac \n        if sys.platform.startswith(\'win\'):\n            authkey = None\n\n        #print ""key:"", \' \'.join([str(ord(x)) for x in authkey])\n        ## Listen for connection from remote process (and find free port number)\n        l = multiprocessing.connection.Listener((\'localhost\', 0), authkey=authkey)\n        port = l.address[1]\n\n        ## start remote process, instruct it to run target function\n        if copySysPath:\n            sysPath = sys.path\n        else:\n            # what path do we need to make target importable?\n            mod = inspect.getmodule(target)\n            modroot = sys.modules[mod.__name__.split(\'.\')[0]]\n            sysPath = os.path.abspath(os.path.join(os.path.dirname(modroot.__file__), \'..\'))\n        bootstrap = os.path.abspath(os.path.join(os.path.dirname(__file__), \'bootstrap.py\'))\n        self.debugMsg(\'Starting child process (%s %s)\' % (executable, bootstrap))\n\n        # Decide on printing color for this process\n        if debug:\n            procDebug = (Process._process_count%6) + 1  # pick a color for this process to print in\n            Process._process_count += 1\n        else:\n            procDebug = False\n        \n        if wrapStdout is None:\n            wrapStdout = sys.platform.startswith(\'win\')\n\n        if wrapStdout:\n            ## note: we need all three streams to have their own PIPE due to this bug:\n            ## http://bugs.python.org/issue3905\n            stdout = subprocess.PIPE\n            stderr = subprocess.PIPE\n            self.proc = subprocess.Popen((executable, bootstrap), stdin=subprocess.PIPE, stdout=stdout, stderr=stderr)\n            ## to circumvent the bug and still make the output visible, we use \n            ## background threads to pass data from pipes to stdout/stderr\n            self._stdoutForwarder = FileForwarder(self.proc.stdout, ""stdout"", procDebug)\n            self._stderrForwarder = FileForwarder(self.proc.stderr, ""stderr"", procDebug)\n        else:\n            self.proc = subprocess.Popen((executable, bootstrap), stdin=subprocess.PIPE)\n\n        targetStr = pickle.dumps(target)  ## double-pickle target so that child has a chance to \n                                          ## set its sys.path properly before unpickling the target\n        pid = os.getpid() # we must send pid to child because windows does not have getppid\n        \n        ## Send everything the remote process needs to start correctly\n        data = dict(\n            name=name+\'_child\', \n            port=port, \n            authkey=authkey, \n            ppid=pid, \n            targetStr=targetStr, \n            path=sysPath, \n            qt_lib=QT_LIB,\n            debug=procDebug,\n            pyqtapis=pyqtapis,\n            )\n        pickle.dump(data, self.proc.stdin)\n        self.proc.stdin.close()\n        \n        ## open connection for remote process\n        self.debugMsg(\'Listening for child process on port %d, authkey=%s..\' % (port, repr(authkey)))\n        while True:\n            try:\n                conn = l.accept()\n                break\n            except IOError as err:\n                if err.errno == 4:  # interrupted; try again\n                    continue\n                else:\n                    raise\n\n        RemoteEventHandler.__init__(self, conn, name+\'_parent\', pid=self.proc.pid, debug=self.debug)\n        self.debugMsg(\'Connected to child process.\')\n        \n        atexit.register(self.join)\n\n        \n    def join(self, timeout=10):\n        self.debugMsg(\'Joining child process..\')\n        if self.proc.poll() is None:\n            self.close()\n            start = time.time()\n            while self.proc.poll() is None:\n                if timeout is not None and time.time() - start > timeout:\n                    raise Exception(\'Timed out waiting for remote process to end.\')\n                time.sleep(0.05)\n        self.conn.close()\n        self.debugMsg(\'Child process exited. (%d)\' % self.proc.returncode)\n\n    def debugMsg(self, msg, *args):\n        if hasattr(self, \'_stdoutForwarder\'):\n            ## Lock output from subprocess to make sure we do not get line collisions\n            with self._stdoutForwarder.lock:\n                with self._stderrForwarder.lock:\n                    RemoteEventHandler.debugMsg(self, msg, *args)\n        else:\n            RemoteEventHandler.debugMsg(self, msg, *args)\n\n        \ndef startEventLoop(name, port, authkey, ppid, debug=False):\n    if debug:\n        import os\n        cprint.cout(debug, \'[%d] connecting to server at port localhost:%d, authkey=%s..\\n\' \n                    % (os.getpid(), port, repr(authkey)), -1)\n    conn = multiprocessing.connection.Client((\'localhost\', int(port)), authkey=authkey)\n    if debug:\n        cprint.cout(debug, \'[%d] connected; starting remote proxy.\\n\' % os.getpid(), -1)\n    global HANDLER\n    #ppid = 0 if not hasattr(os, \'getppid\') else os.getppid()\n    HANDLER = RemoteEventHandler(conn, name, ppid, debug=debug)\n    while True:\n        try:\n            HANDLER.processRequests()  # exception raised when the loop should exit\n            time.sleep(0.01)\n        except ClosedError:\n            HANDLER.debugMsg(\'Exiting server loop.\')\n            sys.exit(0)\n\n\nclass ForkedProcess(RemoteEventHandler):\n    """"""\n    ForkedProcess is a substitute for Process that uses os.fork() to generate a new process.\n    This is much faster than starting a completely new interpreter and child processes\n    automatically have a copy of the entire program state from before the fork. This\n    makes it an appealing approach when parallelizing expensive computations. (see\n    also Parallelizer)\n    \n    However, fork() comes with some caveats and limitations:\n\n    - fork() is not available on Windows.\n    - It is not possible to have a QApplication in both parent and child process\n      (unless both QApplications are created _after_ the call to fork())\n      Attempts by the forked process to access Qt GUI elements created by the parent\n      will most likely cause the child to crash.\n    - Likewise, database connections are unlikely to function correctly in a forked child.\n    - Threads are not copied by fork(); the new process \n      will have only one thread that starts wherever fork() was called in the parent process.\n    - Forked processes are unceremoniously terminated when join() is called; they are not \n      given any opportunity to clean up. (This prevents them calling any cleanup code that\n      was only intended to be used by the parent process)\n    - Normally when fork()ing, open file handles are shared with the parent process, \n      which is potentially dangerous. ForkedProcess is careful to close all file handles \n      that are not explicitly needed--stdout, stderr, and a single pipe to the parent \n      process.\n      \n    """"""\n    \n    def __init__(self, name=None, target=0, preProxy=None, randomReseed=True):\n        """"""\n        When initializing, an optional target may be given. \n        If no target is specified, self.eventLoop will be used.\n        If None is given, no target will be called (and it will be up \n        to the caller to properly shut down the forked process)\n        \n        preProxy may be a dict of values that will appear as ObjectProxy\n        in the remote process (but do not need to be sent explicitly since \n        they are available immediately before the call to fork().\n        Proxies will be availabe as self.proxies[name].\n        \n        If randomReseed is True, the built-in random and numpy.random generators\n        will be reseeded in the child process.\n        """"""\n        self.hasJoined = False\n        if target == 0:\n            target = self.eventLoop\n        if name is None:\n            name = str(self)\n        \n        conn, remoteConn = multiprocessing.Pipe()\n        \n        proxyIDs = {}\n        if preProxy is not None:\n            for k, v in preProxy.items():\n                proxyId = LocalObjectProxy.registerObject(v)\n                proxyIDs[k] = proxyId\n        \n        ppid = os.getpid()  # write this down now; windows doesn\'t have getppid\n        pid = os.fork()\n        if pid == 0:\n            self.isParent = False\n            ## We are now in the forked process; need to be extra careful what we touch while here.\n            ##   - no reading/writing file handles/sockets owned by parent process (stdout is ok)\n            ##   - don\'t touch QtGui or QApplication at all; these are landmines.\n            ##   - don\'t let the process call exit handlers\n            \n            os.setpgrp()  ## prevents signals (notably keyboard interrupt) being forwarded from parent to this process\n            \n            ## close all file handles we do not want shared with parent\n            conn.close()\n            sys.stdin.close()  ## otherwise we screw with interactive prompts.\n            fid = remoteConn.fileno()\n            os.closerange(3, fid)\n            os.closerange(fid+1, 4096) ## just guessing on the maximum descriptor count..\n            \n            ## Override any custom exception hooks\n            def excepthook(*args):\n                import traceback\n                traceback.print_exception(*args)\n            sys.excepthook = excepthook \n            \n            ## Make it harder to access QApplication instance\n            for qtlib in (\'PyQt4\', \'PySide\', \'PyQt5\'):\n                if qtlib in sys.modules:\n                    sys.modules[qtlib+\'.QtGui\'].QApplication = None\n                    sys.modules.pop(qtlib+\'.QtGui\', None)\n                    sys.modules.pop(qtlib+\'.QtCore\', None)\n            \n            ## sabotage atexit callbacks\n            atexit._exithandlers = []\n            atexit.register(lambda: os._exit(0))\n            \n            if randomReseed:\n                if \'numpy.random\' in sys.modules:\n                    sys.modules[\'numpy.random\'].seed(os.getpid() ^ int(time.time()*10000%10000))\n                if \'random\' in sys.modules:\n                    sys.modules[\'random\'].seed(os.getpid() ^ int(time.time()*10000%10000))\n            \n            #ppid = 0 if not hasattr(os, \'getppid\') else os.getppid()\n            RemoteEventHandler.__init__(self, remoteConn, name+\'_child\', pid=ppid)\n            \n            self.forkedProxies = {}\n            for name, proxyId in proxyIDs.items():\n                self.forkedProxies[name] = ObjectProxy(ppid, proxyId=proxyId, typeStr=repr(preProxy[name]))\n            \n            if target is not None:\n                target()\n                \n        else:\n            self.isParent = True\n            self.childPid = pid\n            remoteConn.close()\n            RemoteEventHandler.handlers = {}  ## don\'t want to inherit any of this from the parent.\n            \n            RemoteEventHandler.__init__(self, conn, name+\'_parent\', pid=pid)\n            atexit.register(self.join)\n        \n        \n    def eventLoop(self):\n        while True:\n            try:\n                self.processRequests()  # exception raised when the loop should exit\n                time.sleep(0.01)\n            except ClosedError:\n                break\n            except:\n                print(""Error occurred in forked event loop:"")\n                sys.excepthook(*sys.exc_info())\n        sys.exit(0)\n        \n    def join(self, timeout=10):\n        if self.hasJoined:\n            return\n        #os.kill(pid, 9)  \n        try:\n            self.close(callSync=\'sync\', timeout=timeout, noCleanup=True)  ## ask the child process to exit and require that it return a confirmation.\n        except IOError:  ## probably remote process has already quit\n            pass  \n        \n        try:\n            os.waitpid(self.childPid, 0)\n        except OSError:  ## probably remote process has already quit\n            pass\n        \n        self.conn.close()  # don\'t leak file handles!\n        self.hasJoined = True\n\n    def kill(self):\n        """"""Immediately kill the forked remote process. \n        This is generally safe because forked processes are already\n        expected to _avoid_ any cleanup at exit.""""""\n        os.kill(self.childPid, signal.SIGKILL)\n        self.hasJoined = True\n        \n        \n\n##Special set of subclasses that implement a Qt event loop instead.\n        \nclass RemoteQtEventHandler(RemoteEventHandler):\n    def __init__(self, *args, **kwds):\n        RemoteEventHandler.__init__(self, *args, **kwds)\n        \n    def startEventTimer(self):\n        from ..Qt import QtGui, QtCore\n        self.timer = QtCore.QTimer()\n        self.timer.timeout.connect(self.processRequests)\n        self.timer.start(10)\n    \n    def processRequests(self):\n        try:\n            RemoteEventHandler.processRequests(self)\n        except ClosedError:\n            from ..Qt import QtGui, QtCore\n            QtGui.QApplication.instance().quit()\n            self.timer.stop()\n            #raise SystemExit\n\nclass QtProcess(Process):\n    """"""\n    QtProcess is essentially the same as Process, with two major differences:\n    \n    - The remote process starts by running startQtEventLoop() which creates a \n      QApplication in the remote process and uses a QTimer to trigger\n      remote event processing. This allows the remote process to have its own \n      GUI.\n    - A QTimer is also started on the parent process which polls for requests\n      from the child process. This allows Qt signals emitted within the child \n      process to invoke slots on the parent process and vice-versa. This can \n      be disabled using processRequests=False in the constructor.\n      \n    Example::\n    \n        proc = QtProcess()            \n        rQtGui = proc._import(\'PyQt4.QtGui\')\n        btn = rQtGui.QPushButton(\'button on child process\')\n        btn.show()\n        \n        def slot():\n            print(\'slot invoked on parent process\')\n        btn.clicked.connect(proxy(slot))   # be sure to send a proxy of the slot\n    """"""\n    \n    def __init__(self, **kwds):\n        if \'target\' not in kwds:\n            kwds[\'target\'] = startQtEventLoop\n        from ..Qt import QtGui  ## avoid module-level import to keep bootstrap snappy.\n        self._processRequests = kwds.pop(\'processRequests\', True)\n        if self._processRequests and QtGui.QApplication.instance() is None:\n            raise Exception(""Must create QApplication before starting QtProcess, or use QtProcess(processRequests=False)"")\n        Process.__init__(self, **kwds)\n        self.startEventTimer()\n        \n    def startEventTimer(self):\n        from ..Qt import QtCore  ## avoid module-level import to keep bootstrap snappy.\n        self.timer = QtCore.QTimer()\n        if self._processRequests:\n            self.startRequestProcessing()\n    \n    def startRequestProcessing(self, interval=0.01):\n        """"""Start listening for requests coming from the child process.\n        This allows signals to be connected from the child process to the parent.\n        """"""\n        self.timer.timeout.connect(self.processRequests)\n        self.timer.start(interval*1000)\n        \n    def stopRequestProcessing(self):\n        self.timer.stop()\n    \n    def processRequests(self):\n        try:\n            Process.processRequests(self)\n        except ClosedError:\n            self.timer.stop()\n    \ndef startQtEventLoop(name, port, authkey, ppid, debug=False):\n    if debug:\n        import os\n        cprint.cout(debug, \'[%d] connecting to server at port localhost:%d, authkey=%s..\\n\' % (os.getpid(), port, repr(authkey)), -1)\n    conn = multiprocessing.connection.Client((\'localhost\', int(port)), authkey=authkey)\n    if debug:\n        cprint.cout(debug, \'[%d] connected; starting remote proxy.\\n\' % os.getpid(), -1)\n    from ..Qt import QtGui, QtCore\n    app = QtGui.QApplication.instance()\n    #print app\n    if app is None:\n        app = QtGui.QApplication([])\n        app.setQuitOnLastWindowClosed(False)  ## generally we want the event loop to stay open \n                                              ## until it is explicitly closed by the parent process.\n    \n    global HANDLER\n    HANDLER = RemoteQtEventHandler(conn, name, ppid, debug=debug)\n    HANDLER.startEventTimer()\n    app.exec_()\n\nimport threading\nclass FileForwarder(threading.Thread):\n    """"""\n    Background thread that forwards data from one pipe to another. \n    This is used to catch data from stdout/stderr of the child process\n    and print it back out to stdout/stderr. We need this because this\n    bug: http://bugs.python.org/issue3905  _requires_ us to catch\n    stdout/stderr.\n\n    *output* may be a file or \'stdout\' or \'stderr\'. In the latter cases,\n    sys.stdout/stderr are retrieved once for every line that is output,\n    which ensures that the correct behavior is achieved even if \n    sys.stdout/stderr are replaced at runtime.\n    """"""\n    def __init__(self, input, output, color):\n        threading.Thread.__init__(self)\n        self.input = input\n        self.output = output\n        self.lock = threading.Lock()\n        self.daemon = True\n        self.color = color\n        self.start()\n\n    def run(self):\n        if self.output == \'stdout\' and self.color is not False:\n            while True:\n                line = self.input.readline()\n                with self.lock:\n                    cprint.cout(self.color, line, -1)\n        elif self.output == \'stderr\' and self.color is not False:\n            while True:\n                line = self.input.readline()\n                with self.lock:\n                    cprint.cerr(self.color, line, -1)\n        else:\n            if isinstance(self.output, str):\n                self.output = getattr(sys, self.output)\n            while True:\n                line = self.input.readline()\n                with self.lock:\n                    self.output.write(line)\n'"
src/third_party/pyqtgraph/multiprocess/remoteproxy.py,8,"b'import os, time, sys, traceback, weakref\nimport numpy as np\nimport threading\ntry:\n    import __builtin__ as builtins\n    import cPickle as pickle\nexcept ImportError:\n    import builtins\n    import pickle\n\n# color printing for debugging\nfrom ..util import cprint\n\nclass ClosedError(Exception):\n    """"""Raised when an event handler receives a request to close the connection\n    or discovers that the connection has been closed.""""""\n    pass\n\nclass NoResultError(Exception):\n    """"""Raised when a request for the return value of a remote call fails\n    because the call has not yet returned.""""""\n    pass\n\n    \nclass RemoteEventHandler(object):\n    """"""\n    This class handles communication between two processes. One instance is present on \n    each process and listens for communication from the other process. This enables\n    (amongst other things) ObjectProxy instances to look up their attributes and call \n    their methods.\n    \n    This class is responsible for carrying out actions on behalf of the remote process.\n    Each instance holds one end of a Connection which allows python\n    objects to be passed between processes.\n    \n    For the most common operations, see _import(), close(), and transfer()\n    \n    To handle and respond to incoming requests, RemoteEventHandler requires that its\n    processRequests method is called repeatedly (this is usually handled by the Process\n    classes defined in multiprocess.processes).\n    \n    \n    \n    \n    """"""\n    handlers = {}   ## maps {process ID : handler}. This allows unpickler to determine which process\n                    ## an object proxy belongs to\n                         \n    def __init__(self, connection, name, pid, debug=False):\n        self.debug = debug\n        self.conn = connection\n        self.name = name\n        self.results = {} ## reqId: (status, result); cache of request results received from the remote process\n                          ## status is either \'result\' or \'error\'\n                          ##   if \'error\', then result will be (exception, formatted exceprion)\n                          ##   where exception may be None if it could not be passed through the Connection.\n        self.resultLock = threading.RLock()\n                          \n        self.proxies = {} ## maps {weakref(proxy): proxyId}; used to inform the remote process when a proxy has been deleted.\n        self.proxyLock = threading.RLock()\n        \n        ## attributes that affect the behavior of the proxy. \n        ## See ObjectProxy._setProxyOptions for description\n        self.proxyOptions = {\n            \'callSync\': \'sync\',      ## \'sync\', \'async\', \'off\'\n            \'timeout\': 10,           ## float\n            \'returnType\': \'auto\',    ## \'proxy\', \'value\', \'auto\'\n            \'autoProxy\': False,      ## bool\n            \'deferGetattr\': False,   ## True, False\n            \'noProxyTypes\': [ type(None), str, int, float, tuple, list, dict, LocalObjectProxy, ObjectProxy ],\n        }\n        if int(sys.version[0]) < 3:\n            self.proxyOptions[\'noProxyTypes\'].append(unicode)\n        else:\n            self.proxyOptions[\'noProxyTypes\'].append(bytes)\n        \n        self.optsLock = threading.RLock()\n        \n        self.nextRequestId = 0\n        self.exited = False\n        \n        # Mutexes to help prevent issues when multiple threads access the same RemoteEventHandler\n        self.processLock = threading.RLock()\n        self.sendLock = threading.RLock()\n        \n        RemoteEventHandler.handlers[pid] = self  ## register this handler as the one communicating with pid\n    \n    @classmethod\n    def getHandler(cls, pid):\n        try:\n            return cls.handlers[pid]\n        except:\n            print(pid, cls.handlers)\n            raise\n    \n    def debugMsg(self, msg, *args):\n        if not self.debug:\n            return\n        cprint.cout(self.debug, ""[%d] %s\\n"" % (os.getpid(), str(msg)%args), -1) \n    \n    def getProxyOption(self, opt):\n        with self.optsLock:\n            return self.proxyOptions[opt]\n        \n    def setProxyOptions(self, **kwds):\n        """"""\n        Set the default behavior options for object proxies.\n        See ObjectProxy._setProxyOptions for more info.\n        """"""\n        with self.optsLock:\n            self.proxyOptions.update(kwds)\n    \n    def processRequests(self):\n        """"""Process all pending requests from the pipe, return\n        after no more events are immediately available. (non-blocking)\n        Returns the number of events processed.\n        """"""\n        with self.processLock:\n            \n            if self.exited:\n                self.debugMsg(\'  processRequests: exited already; raise ClosedError.\')\n                raise ClosedError()\n            \n            numProcessed = 0\n            \n            while self.conn.poll():\n                #try:\n                    #poll = self.conn.poll()\n                    #if not poll:\n                        #break\n                #except IOError:  # this can happen if the remote process dies.\n                                ## might it also happen in other circumstances?\n                    #raise ClosedError()\n                        \n                try:\n                    self.handleRequest()\n                    numProcessed += 1\n                except ClosedError:\n                    self.debugMsg(\'processRequests: got ClosedError from handleRequest; setting exited=True.\')\n                    self.exited = True\n                    raise\n                #except IOError as err:  ## let handleRequest take care of this.\n                    #self.debugMsg(\'  got IOError from handleRequest; try again.\')\n                    #if err.errno == 4:  ## interrupted system call; try again\n                        #continue\n                    #else:\n                        #raise\n                except:\n                    print(""Error in process %s"" % self.name)\n                    sys.excepthook(*sys.exc_info())\n                    \n            if numProcessed > 0:\n                self.debugMsg(\'processRequests: finished %d requests\', numProcessed)\n            return numProcessed\n    \n    def handleRequest(self):\n        """"""Handle a single request from the remote process. \n        Blocks until a request is available.""""""\n        result = None\n        while True:\n            try:\n                ## args, kwds are double-pickled to ensure this recv() call never fails                \n                cmd, reqId, nByteMsgs, optStr = self.conn.recv() \n                break\n            except EOFError:\n                self.debugMsg(\'  handleRequest: got EOFError from recv; raise ClosedError.\')\n                ## remote process has shut down; end event loop\n                raise ClosedError()\n            except IOError as err:\n                if err.errno == 4:  ## interrupted system call; try again\n                    self.debugMsg(\'  handleRequest: got IOError 4 from recv; try again.\')\n                    continue\n                else:\n                    self.debugMsg(\'  handleRequest: got IOError %d from recv (%s); raise ClosedError.\', err.errno, err.strerror)\n                    raise ClosedError()\n        \n        self.debugMsg(""  handleRequest: received %s %s"", cmd, reqId)\n            \n        ## read byte messages following the main request\n        byteData = []\n        if nByteMsgs > 0:\n            self.debugMsg(""    handleRequest: reading %d byte messages"", nByteMsgs)\n        for i in range(nByteMsgs):\n            while True:\n                try:\n                    byteData.append(self.conn.recv_bytes())\n                    break\n                except EOFError:\n                    self.debugMsg(""    handleRequest: got EOF while reading byte messages; raise ClosedError."")\n                    raise ClosedError()\n                except IOError as err:\n                    if err.errno == 4:\n                        self.debugMsg(""    handleRequest: got IOError 4 while reading byte messages; try again."")\n                        continue\n                    else:\n                        self.debugMsg(""    handleRequest: got IOError while reading byte messages; raise ClosedError."")\n                        raise ClosedError()\n            \n        \n        try:\n            if cmd == \'result\' or cmd == \'error\':\n                resultId = reqId\n                reqId = None  ## prevents attempt to return information from this request\n                              ## (this is already a return from a previous request)\n            \n            opts = pickle.loads(optStr)\n            self.debugMsg(""    handleRequest: id=%s opts=%s"", reqId, opts)\n            #print os.getpid(), ""received request:"", cmd, reqId, opts\n            returnType = opts.get(\'returnType\', \'auto\')\n            \n            if cmd == \'result\':\n                with self.resultLock:\n                    self.results[resultId] = (\'result\', opts[\'result\'])\n            elif cmd == \'error\':\n                with self.resultLock:\n                    self.results[resultId] = (\'error\', (opts[\'exception\'], opts[\'excString\']))\n            elif cmd == \'getObjAttr\':\n                result = getattr(opts[\'obj\'], opts[\'attr\'])\n            elif cmd == \'callObj\':\n                obj = opts[\'obj\']\n                fnargs = opts[\'args\']\n                fnkwds = opts[\'kwds\']\n                \n                ## If arrays were sent as byte messages, they must be re-inserted into the \n                ## arguments\n                if len(byteData) > 0:\n                    for i,arg in enumerate(fnargs):\n                        if isinstance(arg, tuple) and len(arg) > 0 and arg[0] == \'__byte_message__\':\n                            ind = arg[1]\n                            dtype, shape = arg[2]\n                            fnargs[i] = np.fromstring(byteData[ind], dtype=dtype).reshape(shape)\n                    for k,arg in fnkwds.items():\n                        if isinstance(arg, tuple) and len(arg) > 0 and arg[0] == \'__byte_message__\':\n                            ind = arg[1]\n                            dtype, shape = arg[2]\n                            fnkwds[k] = np.fromstring(byteData[ind], dtype=dtype).reshape(shape)\n                \n                if len(fnkwds) == 0:  ## need to do this because some functions do not allow keyword arguments.\n                    try:\n                        result = obj(*fnargs)\n                    except:\n                        print(""Failed to call object %s: %d, %s"" % (obj, len(fnargs), fnargs[1:]))\n                        raise\n                else:\n                    result = obj(*fnargs, **fnkwds)\n                    \n            elif cmd == \'getObjValue\':\n                result = opts[\'obj\']  ## has already been unpickled into its local value\n                returnType = \'value\'\n            elif cmd == \'transfer\':\n                result = opts[\'obj\']\n                returnType = \'proxy\'\n            elif cmd == \'transferArray\':\n                ## read array data from next message:\n                result = np.fromstring(byteData[0], dtype=opts[\'dtype\']).reshape(opts[\'shape\'])\n                returnType = \'proxy\'\n            elif cmd == \'import\':\n                name = opts[\'module\']\n                fromlist = opts.get(\'fromlist\', [])\n                mod = builtins.__import__(name, fromlist=fromlist)\n                \n                if len(fromlist) == 0:\n                    parts = name.lstrip(\'.\').split(\'.\')\n                    result = mod\n                    for part in parts[1:]:\n                        result = getattr(result, part)\n                else:\n                    result = map(mod.__getattr__, fromlist)\n                \n            elif cmd == \'del\':\n                LocalObjectProxy.releaseProxyId(opts[\'proxyId\'])\n                #del self.proxiedObjects[opts[\'objId\']]\n                \n            elif cmd == \'close\':\n                if reqId is not None:\n                    result = True\n                    returnType = \'value\'\n                    \n            exc = None\n        except:\n            exc = sys.exc_info()\n\n            \n            \n        if reqId is not None:\n            if exc is None:\n                self.debugMsg(""    handleRequest: sending return value for %d: %s"", reqId, result) \n                #print ""returnValue:"", returnValue, result\n                if returnType == \'auto\':\n                    with self.optsLock:\n                        noProxyTypes = self.proxyOptions[\'noProxyTypes\']\n                    result = self.autoProxy(result, noProxyTypes)\n                elif returnType == \'proxy\':\n                    result = LocalObjectProxy(result)\n                \n                try:\n                    self.replyResult(reqId, result)\n                except:\n                    sys.excepthook(*sys.exc_info())\n                    self.replyError(reqId, *sys.exc_info())\n            else:\n                self.debugMsg(""    handleRequest: returning exception for %d"", reqId) \n                self.replyError(reqId, *exc)\n                    \n        elif exc is not None:\n            sys.excepthook(*exc)\n    \n        if cmd == \'close\':\n            if opts.get(\'noCleanup\', False) is True:\n                os._exit(0)  ## exit immediately, do not pass GO, do not collect $200.\n                             ## (more importantly, do not call any code that would\n                             ## normally be invoked at exit)\n            else:\n                raise ClosedError()\n        \n    \n    \n    def replyResult(self, reqId, result):\n        self.send(request=\'result\', reqId=reqId, callSync=\'off\', opts=dict(result=result))\n    \n    def replyError(self, reqId, *exc):\n        print(""error: %s %s %s"" % (self.name, str(reqId), str(exc[1])))\n        excStr = traceback.format_exception(*exc)\n        try:\n            self.send(request=\'error\', reqId=reqId, callSync=\'off\', opts=dict(exception=exc[1], excString=excStr))\n        except:\n            self.send(request=\'error\', reqId=reqId, callSync=\'off\', opts=dict(exception=None, excString=excStr))\n    \n    def send(self, request, opts=None, reqId=None, callSync=\'sync\', timeout=10, returnType=None, byteData=None, **kwds):\n        """"""Send a request or return packet to the remote process.\n        Generally it is not necessary to call this method directly; it is for internal use.\n        (The docstring has information that is nevertheless useful to the programmer\n        as it describes the internal protocol used to communicate between processes)\n        \n        ==============  ====================================================================\n        **Arguments:**\n        request         String describing the type of request being sent (see below)\n        reqId           Integer uniquely linking a result back to the request that generated\n                        it. (most requests leave this blank)\n        callSync        \'sync\':  return the actual result of the request\n                        \'async\': return a Request object which can be used to look up the\n                                result later\n                        \'off\':   return no result\n        timeout         Time in seconds to wait for a response when callSync==\'sync\'\n        opts            Extra arguments sent to the remote process that determine the way\n                        the request will be handled (see below)\n        returnType      \'proxy\', \'value\', or \'auto\'\n        byteData        If specified, this is a list of objects to be sent as byte messages\n                        to the remote process.\n                        This is used to send large arrays without the cost of pickling.\n        ==============  ====================================================================\n        \n        Description of request strings and options allowed for each:\n        \n        =============  =============  ========================================================\n        request        option         description\n        -------------  -------------  --------------------------------------------------------\n        getObjAttr                    Request the remote process return (proxy to) an\n                                      attribute of an object.\n                       obj            reference to object whose attribute should be \n                                      returned\n                       attr           string name of attribute to return\n                       returnValue    bool or \'auto\' indicating whether to return a proxy or\n                                      the actual value. \n                       \n        callObj                       Request the remote process call a function or \n                                      method. If a request ID is given, then the call\'s\n                                      return value will be sent back (or information\n                                      about the error that occurred while running the\n                                      function)\n                       obj            the (reference to) object to call\n                       args           tuple of arguments to pass to callable\n                       kwds           dict of keyword arguments to pass to callable\n                       returnValue    bool or \'auto\' indicating whether to return a proxy or\n                                      the actual value. \n                       \n        getObjValue                   Request the remote process return the value of\n                                      a proxied object (must be picklable)\n                       obj            reference to object whose value should be returned\n                       \n        transfer                      Copy an object to the remote process and request\n                                      it return a proxy for the new object.\n                       obj            The object to transfer.\n                       \n        import                        Request the remote process import new symbols\n                                      and return proxy(ies) to the imported objects\n                       module         the string name of the module to import\n                       fromlist       optional list of string names to import from module\n                       \n        del                           Inform the remote process that a proxy has been \n                                      released (thus the remote process may be able to \n                                      release the original object)\n                       proxyId        id of proxy which is no longer referenced by \n                                      remote host\n                                      \n        close                         Instruct the remote process to stop its event loop\n                                      and exit. Optionally, this request may return a \n                                      confirmation.\n            \n        result                        Inform the remote process that its request has \n                                      been processed                        \n                       result         return value of a request\n                       \n        error                         Inform the remote process that its request failed\n                       exception      the Exception that was raised (or None if the \n                                      exception could not be pickled)\n                       excString      string-formatted version of the exception and \n                                      traceback\n        =============  =====================================================================\n        """"""\n        if self.exited:\n            self.debugMsg(\'  send: exited already; raise ClosedError.\')\n            raise ClosedError()\n        \n        with self.sendLock:\n            #if len(kwds) > 0:\n                #print ""Warning: send() ignored args:"", kwds\n                \n            if opts is None:\n                opts = {}\n            \n            assert callSync in [\'off\', \'sync\', \'async\'], \'callSync must be one of ""off"", ""sync"", or ""async"" (got %r)\' % callSync\n            if reqId is None:\n                if callSync != \'off\': ## requested return value; use the next available request ID\n                    reqId = self.nextRequestId\n                    self.nextRequestId += 1\n            else:\n                ## If requestId is provided, this _must_ be a response to a previously received request.\n                assert request in [\'result\', \'error\']\n            \n            if returnType is not None:\n                opts[\'returnType\'] = returnType\n                \n            #print os.getpid(), ""send request:"", request, reqId, opts\n            \n            ## double-pickle args to ensure that at least status and request ID get through\n            try:\n                optStr = pickle.dumps(opts)\n            except:\n                print(""====  Error pickling this object:  ===="")\n                print(opts)\n                print(""======================================="")\n                raise\n            \n            nByteMsgs = 0\n            if byteData is not None:\n                nByteMsgs = len(byteData)\n                \n            ## Send primary request\n            request = (request, reqId, nByteMsgs, optStr)\n            self.debugMsg(\'send request: cmd=%s nByteMsgs=%d id=%s opts=%s\', request[0], nByteMsgs, reqId, opts)\n            self.conn.send(request)\n            \n            ## follow up by sending byte messages\n            if byteData is not None:\n                for obj in byteData:  ## Remote process _must_ be prepared to read the same number of byte messages!\n                    self.conn.send_bytes(obj)\n                self.debugMsg(\'  sent %d byte messages\', len(byteData))\n            \n            self.debugMsg(\'  call sync: %s\', callSync)\n            if callSync == \'off\':\n                return\n            \n        req = Request(self, reqId, description=str(request), timeout=timeout)\n        if callSync == \'async\':\n            return req\n            \n        if callSync == \'sync\':\n            return req.result()\n        \n    def close(self, callSync=\'off\', noCleanup=False, **kwds):\n        try:\n            self.send(request=\'close\', opts=dict(noCleanup=noCleanup), callSync=callSync, **kwds)\n            self.exited = True\n        except ClosedError:\n            pass\n    \n    def getResult(self, reqId):\n        ## raises NoResultError if the result is not available yet\n        #print self.results.keys(), os.getpid()\n        with self.resultLock:\n            haveResult = reqId in self.results\n        \n        if not haveResult:\n            try:\n                self.processRequests()\n            except ClosedError:  ## even if remote connection has closed, we may have \n                                 ## received new data during this call to processRequests()\n                pass\n        \n        with self.resultLock:\n            if reqId not in self.results:\n                raise NoResultError()\n            status, result = self.results.pop(reqId)\n        \n        if status == \'result\': \n            return result\n        elif status == \'error\':\n            #print \'\'.join(result)\n            exc, excStr = result\n            if exc is not None:\n                print(""===== Remote process raised exception on request: ====="")\n                print(\'\'.join(excStr))\n                print(""===== Local Traceback to request follows: ====="")\n                raise exc\n            else:\n                print(\'\'.join(excStr))\n                raise Exception(""Error getting result. See above for exception from remote process."")\n                \n        else:\n            raise Exception(""Internal error."")\n    \n    def _import(self, mod, **kwds):\n        """"""\n        Request the remote process import a module (or symbols from a module)\n        and return the proxied results. Uses built-in __import__() function, but \n        adds a bit more processing:\n        \n            _import(\'module\')  =>  returns module\n            _import(\'module.submodule\')  =>  returns submodule \n                                             (note this differs from behavior of __import__)\n            _import(\'module\', fromlist=[name1, name2, ...])  =>  returns [module.name1, module.name2, ...]\n                                             (this also differs from behavior of __import__)\n            \n        """"""\n        return self.send(request=\'import\', callSync=\'sync\', opts=dict(module=mod), **kwds)\n        \n    def getObjAttr(self, obj, attr, **kwds):\n        return self.send(request=\'getObjAttr\', opts=dict(obj=obj, attr=attr), **kwds)\n        \n    def getObjValue(self, obj, **kwds):\n        return self.send(request=\'getObjValue\', opts=dict(obj=obj), **kwds)\n        \n    def callObj(self, obj, args, kwds, **opts):\n        opts = opts.copy()\n        args = list(args)\n        \n        ## Decide whether to send arguments by value or by proxy\n        with self.optsLock:\n            noProxyTypes = opts.pop(\'noProxyTypes\', None)\n            if noProxyTypes is None:\n                noProxyTypes = self.proxyOptions[\'noProxyTypes\']\n                \n            autoProxy = opts.pop(\'autoProxy\', self.proxyOptions[\'autoProxy\'])\n        \n        if autoProxy is True:\n            args = [self.autoProxy(v, noProxyTypes) for v in args]\n            for k, v in kwds.items():\n                opts[k] = self.autoProxy(v, noProxyTypes)\n        \n        byteMsgs = []\n        \n        ## If there are arrays in the arguments, send those as byte messages.\n        ## We do this because pickling arrays is too expensive.\n        for i,arg in enumerate(args):\n            if arg.__class__ == np.ndarray:\n                args[i] = (""__byte_message__"", len(byteMsgs), (arg.dtype, arg.shape))\n                byteMsgs.append(arg)\n        for k,v in kwds.items():\n            if v.__class__ == np.ndarray:\n                kwds[k] = (""__byte_message__"", len(byteMsgs), (v.dtype, v.shape))\n                byteMsgs.append(v)\n        \n        return self.send(request=\'callObj\', opts=dict(obj=obj, args=args, kwds=kwds), byteData=byteMsgs, **opts)\n\n    def registerProxy(self, proxy):\n        with self.proxyLock:\n            ref = weakref.ref(proxy, self.deleteProxy)\n            self.proxies[ref] = proxy._proxyId\n    \n    def deleteProxy(self, ref):\n        if self.send is None:\n            # this can happen during shutdown\n            return\n\n        with self.proxyLock:\n            proxyId = self.proxies.pop(ref)\n            \n        try:\n            self.send(request=\'del\', opts=dict(proxyId=proxyId), callSync=\'off\')\n        except ClosedError:  ## if remote process has closed down, there is no need to send delete requests anymore\n            pass\n\n    def transfer(self, obj, **kwds):\n        """"""\n        Transfer an object by value to the remote host (the object must be picklable) \n        and return a proxy for the new remote object.\n        """"""\n        if obj.__class__ is np.ndarray:\n            opts = {\'dtype\': obj.dtype, \'shape\': obj.shape}\n            return self.send(request=\'transferArray\', opts=opts, byteData=[obj], **kwds)            \n        else:\n            return self.send(request=\'transfer\', opts=dict(obj=obj), **kwds)\n        \n    def autoProxy(self, obj, noProxyTypes):\n        ## Return object wrapped in LocalObjectProxy _unless_ its type is in noProxyTypes.\n        for typ in noProxyTypes:\n            if isinstance(obj, typ):\n                return obj\n        return LocalObjectProxy(obj)\n        \n        \nclass Request(object):\n    """"""\n    Request objects are returned when calling an ObjectProxy in asynchronous mode\n    or if a synchronous call has timed out. Use hasResult() to ask whether\n    the result of the call has been returned yet. Use result() to get\n    the returned value.\n    """"""\n    def __init__(self, process, reqId, description=None, timeout=10):\n        self.proc = process\n        self.description = description\n        self.reqId = reqId\n        self.gotResult = False\n        self._result = None\n        self.timeout = timeout\n        \n    def result(self, block=True, timeout=None):\n        """"""\n        Return the result for this request. \n        \n        If block is True, wait until the result has arrived or *timeout* seconds passes.\n        If the timeout is reached, raise NoResultError. (use timeout=None to disable)\n        If block is False, raise NoResultError immediately if the result has not arrived yet.\n        \n        If the process\'s connection has closed before the result arrives, raise ClosedError.\n        """"""\n        \n        if self.gotResult:\n            return self._result\n            \n        if timeout is None:\n            timeout = self.timeout \n        \n        if block:\n            start = time.time()\n            while not self.hasResult():\n                if self.proc.exited:\n                    raise ClosedError()\n                time.sleep(0.005)\n                if timeout >= 0 and time.time() - start > timeout:\n                    print(""Request timed out: %s"" % self.description)\n                    import traceback\n                    traceback.print_stack()\n                    raise NoResultError()\n            return self._result\n        else:\n            self._result = self.proc.getResult(self.reqId)  ## raises NoResultError if result is not available yet\n            self.gotResult = True\n            return self._result\n        \n    def hasResult(self):\n        """"""Returns True if the result for this request has arrived.""""""\n        try:\n            self.result(block=False)\n        except NoResultError:\n            pass\n        \n        return self.gotResult\n\nclass LocalObjectProxy(object):\n    """"""\n    Used for wrapping local objects to ensure that they are send by proxy to a remote host.\n    Note that \'proxy\' is just a shorter alias for LocalObjectProxy.\n    \n    For example::\n    \n        data = [1,2,3,4,5]\n        remotePlot.plot(data)         ## by default, lists are pickled and sent by value\n        remotePlot.plot(proxy(data))  ## force the object to be sent by proxy\n    \n    """"""\n    nextProxyId = 0\n    proxiedObjects = {}  ## maps {proxyId: object}\n    \n    \n    @classmethod\n    def registerObject(cls, obj):\n        ## assign it a unique ID so we can keep a reference to the local object\n        \n        pid = cls.nextProxyId\n        cls.nextProxyId += 1\n        cls.proxiedObjects[pid] = obj\n        #print ""register:"", cls.proxiedObjects\n        return pid\n    \n    @classmethod\n    def lookupProxyId(cls, pid):\n        return cls.proxiedObjects[pid]\n    \n    @classmethod\n    def releaseProxyId(cls, pid):\n        del cls.proxiedObjects[pid]\n        #print ""release:"", cls.proxiedObjects \n    \n    def __init__(self, obj, **opts):\n        """"""\n        Create a \'local\' proxy object that, when sent to a remote host,\n        will appear as a normal ObjectProxy to *obj*. \n        Any extra keyword arguments are passed to proxy._setProxyOptions()\n        on the remote side.\n        """"""\n        self.processId = os.getpid()\n        #self.objectId = id(obj)\n        self.typeStr = repr(obj)\n        #self.handler = handler\n        self.obj = obj\n        self.opts = opts\n        \n    def __reduce__(self):\n        ## a proxy is being pickled and sent to a remote process.\n        ## every time this happens, a new proxy will be generated in the remote process,\n        ## so we keep a new ID so we can track when each is released.\n        pid = LocalObjectProxy.registerObject(self.obj)\n        return (unpickleObjectProxy, (self.processId, pid, self.typeStr, None, self.opts))\n        \n## alias\nproxy = LocalObjectProxy\n\ndef unpickleObjectProxy(processId, proxyId, typeStr, attributes=None, opts=None):\n    if processId == os.getpid():\n        obj = LocalObjectProxy.lookupProxyId(proxyId)\n        if attributes is not None:\n            for attr in attributes:\n                obj = getattr(obj, attr)\n        return obj\n    else:\n        proxy = ObjectProxy(processId, proxyId=proxyId, typeStr=typeStr)\n        if opts is not None:\n            proxy._setProxyOptions(**opts)\n        return proxy\n    \nclass ObjectProxy(object):\n    """"""\n    Proxy to an object stored by the remote process. Proxies are created\n    by calling Process._import(), Process.transfer(), or by requesting/calling\n    attributes on existing proxy objects.\n    \n    For the most part, this object can be used exactly as if it\n    were a local object::\n    \n        rsys = proc._import(\'sys\')   # returns proxy to sys module on remote process\n        rsys.stdout                  # proxy to remote sys.stdout\n        rsys.stdout.write            # proxy to remote sys.stdout.write\n        rsys.stdout.write(\'hello\')   # calls sys.stdout.write(\'hello\') on remote machine\n                                     # and returns the result (None)\n    \n    When calling a proxy to a remote function, the call can be made synchronous\n    (result of call is returned immediately), asynchronous (result is returned later),\n    or return can be disabled entirely::\n    \n        ros = proc._import(\'os\')\n        \n        ## synchronous call; result is returned immediately\n        pid = ros.getpid()\n        \n        ## asynchronous call\n        request = ros.getpid(_callSync=\'async\')\n        while not request.hasResult():\n            time.sleep(0.01)\n        pid = request.result()\n        \n        ## disable return when we know it isn\'t needed\n        rsys.stdout.write(\'hello\', _callSync=\'off\')\n    \n    Additionally, values returned from a remote function call are automatically\n    returned either by value (must be picklable) or by proxy. \n    This behavior can be forced::\n    \n        rnp = proc._import(\'numpy\')\n        arrProxy = rnp.array([1,2,3,4], _returnType=\'proxy\')\n        arrValue = rnp.array([1,2,3,4], _returnType=\'value\')\n    \n    The default callSync and returnType behaviors (as well as others) can be set \n    for each proxy individually using ObjectProxy._setProxyOptions() or globally using \n    proc.setProxyOptions(). \n    \n    """"""\n    def __init__(self, processId, proxyId, typeStr=\'\', parent=None):\n        object.__init__(self)\n        ## can\'t set attributes directly because setattr is overridden.\n        self.__dict__[\'_processId\'] = processId\n        self.__dict__[\'_typeStr\'] = typeStr\n        self.__dict__[\'_proxyId\'] = proxyId\n        self.__dict__[\'_attributes\'] = ()\n        ## attributes that affect the behavior of the proxy. \n        ## in all cases, a value of None causes the proxy to ask\n        ## its parent event handler to make the decision\n        self.__dict__[\'_proxyOptions\'] = {\n            \'callSync\': None,      ## \'sync\', \'async\', None \n            \'timeout\': None,       ## float, None\n            \'returnType\': None,    ## \'proxy\', \'value\', \'auto\', None\n            \'deferGetattr\': None,  ## True, False, None\n            \'noProxyTypes\': None,  ## list of types to send by value instead of by proxy\n            \'autoProxy\': None,\n        }\n        \n        self.__dict__[\'_handler\'] = RemoteEventHandler.getHandler(processId)\n        self.__dict__[\'_handler\'].registerProxy(self)  ## handler will watch proxy; inform remote process when the proxy is deleted.\n    \n    def _setProxyOptions(self, **kwds):\n        """"""\n        Change the behavior of this proxy. For all options, a value of None\n        will cause the proxy to instead use the default behavior defined\n        by its parent Process.\n        \n        Options are:\n        \n        =============  =============================================================\n        callSync       \'sync\', \'async\', \'off\', or None. \n                       If \'async\', then calling methods will return a Request object\n                       which can be used to inquire later about the result of the \n                       method call.\n                       If \'sync\', then calling a method\n                       will block until the remote process has returned its result\n                       or the timeout has elapsed (in this case, a Request object\n                       is returned instead).\n                       If \'off\', then the remote process is instructed _not_ to \n                       reply and the method call will return None immediately.\n        returnType     \'auto\', \'proxy\', \'value\', or None. \n                       If \'proxy\', then the value returned when calling a method\n                       will be a proxy to the object on the remote process.\n                       If \'value\', then attempt to pickle the returned object and\n                       send it back.\n                       If \'auto\', then the decision is made by consulting the\n                       \'noProxyTypes\' option.\n        autoProxy      bool or None. If True, arguments to __call__ are \n                       automatically converted to proxy unless their type is \n                       listed in noProxyTypes (see below). If False, arguments\n                       are left untouched. Use proxy(obj) to manually convert\n                       arguments before sending. \n        timeout        float or None. Length of time to wait during synchronous \n                       requests before returning a Request object instead.\n        deferGetattr   True, False, or None. \n                       If False, all attribute requests will be sent to the remote \n                       process immediately and will block until a response is\n                       received (or timeout has elapsed).\n                       If True, requesting an attribute from the proxy returns a\n                       new proxy immediately. The remote process is _not_ contacted\n                       to make this request. This is faster, but it is possible to \n                       request an attribute that does not exist on the proxied\n                       object. In this case, AttributeError will not be raised\n                       until an attempt is made to look up the attribute on the\n                       remote process.\n        noProxyTypes   List of object types that should _not_ be proxied when\n                       sent to the remote process.\n        =============  =============================================================\n        """"""\n        for k in kwds:\n            if k not in self._proxyOptions:\n                raise KeyError(""Unrecognized proxy option \'%s\'"" % k)\n        self._proxyOptions.update(kwds)\n    \n    def _getValue(self):\n        """"""\n        Return the value of the proxied object\n        (the remote object must be picklable)\n        """"""\n        return self._handler.getObjValue(self)\n        \n    def _getProxyOption(self, opt):\n        val = self._proxyOptions[opt]\n        if val is None:\n            return self._handler.getProxyOption(opt)\n        return val\n    \n    def _getProxyOptions(self):\n        return dict([(k, self._getProxyOption(k)) for k in self._proxyOptions])\n    \n    def __reduce__(self):\n        return (unpickleObjectProxy, (self._processId, self._proxyId, self._typeStr, self._attributes))\n    \n    def __repr__(self):\n        #objRepr = self.__getattr__(\'__repr__\')(callSync=\'value\')\n        return ""<ObjectProxy for process %d, object 0x%x: %s >"" % (self._processId, self._proxyId, self._typeStr)\n        \n        \n    def __getattr__(self, attr, **kwds):\n        """"""\n        Calls __getattr__ on the remote object and returns the attribute\n        by value or by proxy depending on the options set (see\n        ObjectProxy._setProxyOptions and RemoteEventHandler.setProxyOptions)\n        \n        If the option \'deferGetattr\' is True for this proxy, then a new proxy object\n        is returned _without_ asking the remote object whether the named attribute exists.\n        This can save time when making multiple chained attribute requests,\n        but may also defer a possible AttributeError until later, making\n        them more difficult to debug.\n        """"""\n        opts = self._getProxyOptions()\n        for k in opts:\n            if \'_\'+k in kwds:\n                opts[k] = kwds.pop(\'_\'+k)\n        if opts[\'deferGetattr\'] is True:\n            return self._deferredAttr(attr)\n        else:\n            #opts = self._getProxyOptions()\n            return self._handler.getObjAttr(self, attr, **opts)\n    \n    def _deferredAttr(self, attr):\n        return DeferredObjectProxy(self, attr)\n    \n    def __call__(self, *args, **kwds):\n        """"""\n        Attempts to call the proxied object from the remote process.\n        Accepts extra keyword arguments:\n        \n            _callSync    \'off\', \'sync\', or \'async\'\n            _returnType   \'value\', \'proxy\', or \'auto\'\n        \n        If the remote call raises an exception on the remote process,\n        it will be re-raised on the local process.\n        \n        """"""\n        opts = self._getProxyOptions()\n        for k in opts:\n            if \'_\'+k in kwds:\n                opts[k] = kwds.pop(\'_\'+k)\n        return self._handler.callObj(obj=self, args=args, kwds=kwds, **opts)\n    \n    \n    ## Explicitly proxy special methods. Is there a better way to do this??\n    \n    def _getSpecialAttr(self, attr):\n        ## this just gives us an easy way to change the behavior of the special methods\n        return self._deferredAttr(attr)\n    \n    def __getitem__(self, *args):\n        return self._getSpecialAttr(\'__getitem__\')(*args)\n    \n    def __setitem__(self, *args):\n        return self._getSpecialAttr(\'__setitem__\')(*args, _callSync=\'off\')\n        \n    def __setattr__(self, *args):\n        return self._getSpecialAttr(\'__setattr__\')(*args, _callSync=\'off\')\n        \n    def __str__(self, *args):\n        return self._getSpecialAttr(\'__str__\')(*args, _returnType=\'value\')\n        \n    def __len__(self, *args):\n        return self._getSpecialAttr(\'__len__\')(*args)\n    \n    def __add__(self, *args):\n        return self._getSpecialAttr(\'__add__\')(*args)\n    \n    def __sub__(self, *args):\n        return self._getSpecialAttr(\'__sub__\')(*args)\n        \n    def __div__(self, *args):\n        return self._getSpecialAttr(\'__div__\')(*args)\n        \n    def __truediv__(self, *args):\n        return self._getSpecialAttr(\'__truediv__\')(*args)\n        \n    def __floordiv__(self, *args):\n        return self._getSpecialAttr(\'__floordiv__\')(*args)\n        \n    def __mul__(self, *args):\n        return self._getSpecialAttr(\'__mul__\')(*args)\n        \n    def __pow__(self, *args):\n        return self._getSpecialAttr(\'__pow__\')(*args)\n        \n    def __iadd__(self, *args):\n        return self._getSpecialAttr(\'__iadd__\')(*args, _callSync=\'off\')\n    \n    def __isub__(self, *args):\n        return self._getSpecialAttr(\'__isub__\')(*args, _callSync=\'off\')\n        \n    def __idiv__(self, *args):\n        return self._getSpecialAttr(\'__idiv__\')(*args, _callSync=\'off\')\n        \n    def __itruediv__(self, *args):\n        return self._getSpecialAttr(\'__itruediv__\')(*args, _callSync=\'off\')\n        \n    def __ifloordiv__(self, *args):\n        return self._getSpecialAttr(\'__ifloordiv__\')(*args, _callSync=\'off\')\n        \n    def __imul__(self, *args):\n        return self._getSpecialAttr(\'__imul__\')(*args, _callSync=\'off\')\n        \n    def __ipow__(self, *args):\n        return self._getSpecialAttr(\'__ipow__\')(*args, _callSync=\'off\')\n        \n    def __rshift__(self, *args):\n        return self._getSpecialAttr(\'__rshift__\')(*args)\n        \n    def __lshift__(self, *args):\n        return self._getSpecialAttr(\'__lshift__\')(*args)\n        \n    def __irshift__(self, *args):\n        return self._getSpecialAttr(\'__irshift__\')(*args, _callSync=\'off\')\n        \n    def __ilshift__(self, *args):\n        return self._getSpecialAttr(\'__ilshift__\')(*args, _callSync=\'off\')\n        \n    def __eq__(self, *args):\n        return self._getSpecialAttr(\'__eq__\')(*args)\n    \n    def __ne__(self, *args):\n        return self._getSpecialAttr(\'__ne__\')(*args)\n        \n    def __lt__(self, *args):\n        return self._getSpecialAttr(\'__lt__\')(*args)\n    \n    def __gt__(self, *args):\n        return self._getSpecialAttr(\'__gt__\')(*args)\n        \n    def __le__(self, *args):\n        return self._getSpecialAttr(\'__le__\')(*args)\n    \n    def __ge__(self, *args):\n        return self._getSpecialAttr(\'__ge__\')(*args)\n        \n    def __and__(self, *args):\n        return self._getSpecialAttr(\'__and__\')(*args)\n        \n    def __or__(self, *args):\n        return self._getSpecialAttr(\'__or__\')(*args)\n        \n    def __xor__(self, *args):\n        return self._getSpecialAttr(\'__xor__\')(*args)\n        \n    def __iand__(self, *args):\n        return self._getSpecialAttr(\'__iand__\')(*args, _callSync=\'off\')\n        \n    def __ior__(self, *args):\n        return self._getSpecialAttr(\'__ior__\')(*args, _callSync=\'off\')\n        \n    def __ixor__(self, *args):\n        return self._getSpecialAttr(\'__ixor__\')(*args, _callSync=\'off\')\n        \n    def __mod__(self, *args):\n        return self._getSpecialAttr(\'__mod__\')(*args)\n        \n    def __radd__(self, *args):\n        return self._getSpecialAttr(\'__radd__\')(*args)\n    \n    def __rsub__(self, *args):\n        return self._getSpecialAttr(\'__rsub__\')(*args)\n        \n    def __rdiv__(self, *args):\n        return self._getSpecialAttr(\'__rdiv__\')(*args)\n        \n    def __rfloordiv__(self, *args):\n        return self._getSpecialAttr(\'__rfloordiv__\')(*args)\n        \n    def __rtruediv__(self, *args):\n        return self._getSpecialAttr(\'__rtruediv__\')(*args)\n        \n    def __rmul__(self, *args):\n        return self._getSpecialAttr(\'__rmul__\')(*args)\n        \n    def __rpow__(self, *args):\n        return self._getSpecialAttr(\'__rpow__\')(*args)\n        \n    def __rrshift__(self, *args):\n        return self._getSpecialAttr(\'__rrshift__\')(*args)\n        \n    def __rlshift__(self, *args):\n        return self._getSpecialAttr(\'__rlshift__\')(*args)\n        \n    def __rand__(self, *args):\n        return self._getSpecialAttr(\'__rand__\')(*args)\n        \n    def __ror__(self, *args):\n        return self._getSpecialAttr(\'__ror__\')(*args)\n        \n    def __rxor__(self, *args):\n        return self._getSpecialAttr(\'__ror__\')(*args)\n        \n    def __rmod__(self, *args):\n        return self._getSpecialAttr(\'__rmod__\')(*args)\n        \n    def __hash__(self):\n        ## Required for python3 since __eq__ is defined.\n        return id(self)\n        \nclass DeferredObjectProxy(ObjectProxy):\n    """"""\n    This class represents an attribute (or sub-attribute) of a proxied object.\n    It is used to speed up attribute requests. Take the following scenario::\n    \n        rsys = proc._import(\'sys\')\n        rsys.stdout.write(\'hello\')\n        \n    For this simple example, a total of 4 synchronous requests are made to \n    the remote process: \n    \n    1) import sys\n    2) getattr(sys, \'stdout\')\n    3) getattr(stdout, \'write\')\n    4) write(\'hello\')\n    \n    This takes a lot longer than running the equivalent code locally. To\n    speed things up, we can \'defer\' the two attribute lookups so they are\n    only carried out when neccessary::\n    \n        rsys = proc._import(\'sys\')\n        rsys._setProxyOptions(deferGetattr=True)\n        rsys.stdout.write(\'hello\')\n        \n    This example only makes two requests to the remote process; the two \n    attribute lookups immediately return DeferredObjectProxy instances \n    immediately without contacting the remote process. When the call \n    to write() is made, all attribute requests are processed at the same time.\n    \n    Note that if the attributes requested do not exist on the remote object, \n    making the call to write() will raise an AttributeError.\n    """"""\n    def __init__(self, parentProxy, attribute):\n        ## can\'t set attributes directly because setattr is overridden.\n        for k in [\'_processId\', \'_typeStr\', \'_proxyId\', \'_handler\']:\n            self.__dict__[k] = getattr(parentProxy, k)\n        self.__dict__[\'_parent\'] = parentProxy  ## make sure parent stays alive\n        self.__dict__[\'_attributes\'] = parentProxy._attributes + (attribute,)\n        self.__dict__[\'_proxyOptions\'] = parentProxy._proxyOptions.copy()\n    \n    def __repr__(self):\n        return ObjectProxy.__repr__(self) + \'.\' + \'.\'.join(self._attributes)\n    \n    def _undefer(self):\n        """"""\n        Return a non-deferred ObjectProxy referencing the same object\n        """"""\n        return self._parent.__getattr__(self._attributes[-1], _deferGetattr=False)\n\n'"
src/third_party/pyqtgraph/opengl/GLGraphicsItem.py,0,"b'from OpenGL.GL import *\nfrom OpenGL import GL\nfrom ..Qt import QtGui, QtCore\nfrom .. import Transform3D\nfrom ..python2_3 import basestring\n\n\nGLOptions = {\n    \'opaque\': {\n        GL_DEPTH_TEST: True,\n        GL_BLEND: False,\n        GL_ALPHA_TEST: False,\n        GL_CULL_FACE: False,\n    },\n    \'translucent\': {\n        GL_DEPTH_TEST: True,\n        GL_BLEND: True,\n        GL_ALPHA_TEST: False,\n        GL_CULL_FACE: False,\n        \'glBlendFunc\': (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA),\n    },\n    \'additive\': {\n        GL_DEPTH_TEST: False,\n        GL_BLEND: True,\n        GL_ALPHA_TEST: False,\n        GL_CULL_FACE: False,\n        \'glBlendFunc\': (GL_SRC_ALPHA, GL_ONE),\n    },\n}    \n\n\nclass GLGraphicsItem(QtCore.QObject):\n    _nextId = 0\n    \n    def __init__(self, parentItem=None):\n        QtCore.QObject.__init__(self)\n        self._id = GLGraphicsItem._nextId\n        GLGraphicsItem._nextId += 1\n        \n        self.__parent = None\n        self.__view = None\n        self.__children = set()\n        self.__transform = Transform3D()\n        self.__visible = True\n        self.setParentItem(parentItem)\n        self.setDepthValue(0)\n        self.__glOpts = {}\n        \n    def setParentItem(self, item):\n        """"""Set this item\'s parent in the scenegraph hierarchy.""""""\n        if self.__parent is not None:\n            self.__parent.__children.remove(self)\n        if item is not None:\n            item.__children.add(self)\n        self.__parent = item\n        \n        if self.__parent is not None and self.view() is not self.__parent.view():\n            if self.view() is not None:\n                self.view().removeItem(self)\n            self.__parent.view().addItem(self)\n    \n    def setGLOptions(self, opts):\n        """"""\n        Set the OpenGL state options to use immediately before drawing this item.\n        (Note that subclasses must call setupGLState before painting for this to work)\n        \n        The simplest way to invoke this method is to pass in the name of\n        a predefined set of options (see the GLOptions variable):\n        \n        ============= ======================================================\n        opaque        Enables depth testing and disables blending\n        translucent   Enables depth testing and blending\n                      Elements must be drawn sorted back-to-front for\n                      translucency to work correctly.\n        additive      Disables depth testing, enables blending.\n                      Colors are added together, so sorting is not required.\n        ============= ======================================================\n        \n        It is also possible to specify any arbitrary settings as a dictionary. \n        This may consist of {\'functionName\': (args...)} pairs where functionName must \n        be a callable attribute of OpenGL.GL, or {GL_STATE_VAR: bool} pairs \n        which will be interpreted as calls to glEnable or glDisable(GL_STATE_VAR).\n        \n        For example::\n            \n            {\n                GL_ALPHA_TEST: True,\n                GL_CULL_FACE: False,\n                \'glBlendFunc\': (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA),\n            }\n            \n        \n        """"""\n        if isinstance(opts, basestring):\n            opts = GLOptions[opts]\n        self.__glOpts = opts.copy()\n        self.update()\n        \n    def updateGLOptions(self, opts):\n        """"""\n        Modify the OpenGL state options to use immediately before drawing this item.\n        *opts* must be a dictionary as specified by setGLOptions.\n        Values may also be None, in which case the key will be ignored.\n        """"""\n        self.__glOpts.update(opts)\n        \n    \n    def parentItem(self):\n        """"""Return a this item\'s parent in the scenegraph hierarchy.""""""\n        return self.__parent\n        \n    def childItems(self):\n        """"""Return a list of this item\'s children in the scenegraph hierarchy.""""""\n        return list(self.__children)\n        \n    def _setView(self, v):\n        self.__view = v\n        \n    def view(self):\n        return self.__view\n        \n    def setDepthValue(self, value):\n        """"""\n        Sets the depth value of this item. Default is 0.\n        This controls the order in which items are drawn--those with a greater depth value will be drawn later.\n        Items with negative depth values are drawn before their parent.\n        (This is analogous to QGraphicsItem.zValue)\n        The depthValue does NOT affect the position of the item or the values it imparts to the GL depth buffer.\n        """"""\n        self.__depthValue = value\n        \n    def depthValue(self):\n        """"""Return the depth value of this item. See setDepthValue for more information.""""""\n        return self.__depthValue\n        \n    def setTransform(self, tr):\n        """"""Set the local transform for this object.\n        Must be a :class:`Transform3D <pyqtgraph.Transform3D>` instance. This transform\n        determines how the local coordinate system of the item is mapped to the coordinate\n        system of its parent.""""""\n        self.__transform = Transform3D(tr)\n        self.update()\n        \n    def resetTransform(self):\n        """"""Reset this item\'s transform to an identity transformation.""""""\n        self.__transform.setToIdentity()\n        self.update()\n        \n    def applyTransform(self, tr, local):\n        """"""\n        Multiply this object\'s transform by *tr*. \n        If local is True, then *tr* is multiplied on the right of the current transform::\n        \n            newTransform = transform * tr\n            \n        If local is False, then *tr* is instead multiplied on the left::\n        \n            newTransform = tr * transform\n        """"""\n        if local:\n            self.setTransform(self.transform() * tr)\n        else:\n            self.setTransform(tr * self.transform())\n        \n    def transform(self):\n        """"""Return this item\'s transform object.""""""\n        return self.__transform\n        \n    def viewTransform(self):\n        """"""Return the transform mapping this item\'s local coordinate system to the \n        view coordinate system.""""""\n        tr = self.__transform\n        p = self\n        while True:\n            p = p.parentItem()\n            if p is None:\n                break\n            tr = p.transform() * tr\n        return Transform3D(tr)\n        \n    def translate(self, dx, dy, dz, local=False):\n        """"""\n        Translate the object by (*dx*, *dy*, *dz*) in its parent\'s coordinate system.\n        If *local* is True, then translation takes place in local coordinates.\n        """"""\n        tr = Transform3D()\n        tr.translate(dx, dy, dz)\n        self.applyTransform(tr, local=local)\n        \n    def rotate(self, angle, x, y, z, local=False):\n        """"""\n        Rotate the object around the axis specified by (x,y,z).\n        *angle* is in degrees.\n        \n        """"""\n        tr = Transform3D()\n        tr.rotate(angle, x, y, z)\n        self.applyTransform(tr, local=local)\n    \n    def scale(self, x, y, z, local=True):\n        """"""\n        Scale the object by (*dx*, *dy*, *dz*) in its local coordinate system.\n        If *local* is False, then scale takes place in the parent\'s coordinates.\n        """"""\n        tr = Transform3D()\n        tr.scale(x, y, z)\n        self.applyTransform(tr, local=local)\n    \n    \n    def hide(self):\n        """"""Hide this item. \n        This is equivalent to setVisible(False).""""""\n        self.setVisible(False)\n        \n    def show(self):\n        """"""Make this item visible if it was previously hidden.\n        This is equivalent to setVisible(True).""""""\n        self.setVisible(True)\n    \n    def setVisible(self, vis):\n        """"""Set the visibility of this item.""""""\n        self.__visible = vis\n        self.update()\n        \n    def visible(self):\n        """"""Return True if the item is currently set to be visible.\n        Note that this does not guarantee that the item actually appears in the\n        view, as it may be obscured or outside of the current view area.""""""\n        return self.__visible\n    \n    \n    def initializeGL(self):\n        """"""\n        Called after an item is added to a GLViewWidget. \n        The widget\'s GL context is made current before this method is called.\n        (So this would be an appropriate time to generate lists, upload textures, etc.)\n        """"""\n        pass\n    \n    def setupGLState(self):\n        """"""\n        This method is responsible for preparing the GL state options needed to render \n        this item (blending, depth testing, etc). The method is called immediately before painting the item.\n        """"""\n        for k,v in self.__glOpts.items():\n            if v is None:\n                continue\n            if isinstance(k, basestring):\n                func = getattr(GL, k)\n                func(*v)\n            else:\n                if v is True:\n                    glEnable(k)\n                else:\n                    glDisable(k)\n    \n    def paint(self):\n        """"""\n        Called by the GLViewWidget to draw this item.\n        It is the responsibility of the item to set up its own modelview matrix,\n        but the caller will take care of pushing/popping.\n        """"""\n        self.setupGLState()\n        \n    def update(self):\n        """"""\n        Indicates that this item needs to be redrawn, and schedules an update \n        with the view it is displayed in.\n        """"""\n        v = self.view()\n        if v is None:\n            return\n        v.update()\n        \n    def mapToParent(self, point):\n        tr = self.transform()\n        if tr is None:\n            return point\n        return tr.map(point)\n        \n    def mapFromParent(self, point):\n        tr = self.transform()\n        if tr is None:\n            return point\n        return tr.inverted()[0].map(point)\n        \n    def mapToView(self, point):\n        tr = self.viewTransform()\n        if tr is None:\n            return point\n        return tr.map(point)\n        \n    def mapFromView(self, point):\n        tr = self.viewTransform()\n        if tr is None:\n            return point\n        return tr.inverted()[0].map(point)\n        \n        \n        '"
src/third_party/pyqtgraph/opengl/GLViewWidget.py,26,"b'from ..Qt import QtCore, QtGui, QtOpenGL, QT_LIB\nfrom OpenGL.GL import *\nimport OpenGL.GL.framebufferobjects as glfbo\nimport numpy as np\nfrom .. import Vector\nfrom .. import functions as fn\n\n##Vector = QtGui.QVector3D\n\nShareWidget = None\n\nclass GLViewWidget(QtOpenGL.QGLWidget):\n    """"""\n    Basic widget for displaying 3D data\n        - Rotation/scale controls\n        - Axis/grid display\n        - Export options\n\n\n    High-DPI displays: Qt5 should automatically detect the correct resolution.\n    For Qt4, specify the ``devicePixelRatio`` argument when initializing the\n    widget (usually this value is 1-2).\n    """"""\n    \n    def __init__(self, parent=None, devicePixelRatio=None):\n        global ShareWidget\n\n        if ShareWidget is None:\n            ## create a dummy widget to allow sharing objects (textures, shaders, etc) between views\n            ShareWidget = QtOpenGL.QGLWidget()\n            \n        QtOpenGL.QGLWidget.__init__(self, parent, ShareWidget)\n        \n        self.setFocusPolicy(QtCore.Qt.ClickFocus)\n        \n        self.opts = {\n            \'center\': Vector(0,0,0),  ## will always appear at the center of the widget\n            \'distance\': 10.0,         ## distance of camera from center\n            \'fov\':  60,               ## horizontal field of view in degrees\n            \'elevation\':  30,         ## camera\'s angle of elevation in degrees\n            \'azimuth\': 45,            ## camera\'s azimuthal angle in degrees \n                                      ## (rotation around z-axis 0 points along x-axis)\n            \'viewport\': None,         ## glViewport params; None == whole widget\n            \'devicePixelRatio\': devicePixelRatio,\n        }\n        self.setBackgroundColor(\'k\')\n        self.items = []\n        self.noRepeatKeys = [QtCore.Qt.Key_Right, QtCore.Qt.Key_Left, QtCore.Qt.Key_Up, QtCore.Qt.Key_Down, QtCore.Qt.Key_PageUp, QtCore.Qt.Key_PageDown]\n        self.keysPressed = {}\n        self.keyTimer = QtCore.QTimer()\n        self.keyTimer.timeout.connect(self.evalKeyState)\n        \n        self.makeCurrent()\n\n    def addItem(self, item):\n        self.items.append(item)\n        if hasattr(item, \'initializeGL\'):\n            self.makeCurrent()\n            try:\n                item.initializeGL()\n            except:\n                self.checkOpenGLVersion(\'Error while adding item %s to GLViewWidget.\' % str(item))\n                \n        item._setView(self)\n        #print ""set view"", item, self, item.view()\n        self.update()\n        \n    def removeItem(self, item):\n        self.items.remove(item)\n        item._setView(None)\n        self.update()\n        \n        \n    def initializeGL(self):\n        self.resizeGL(self.width(), self.height())\n        \n    def setBackgroundColor(self, *args, **kwds):\n        """"""\n        Set the background color of the widget. Accepts the same arguments as\n        pg.mkColor() and pg.glColor().\n        """"""\n        self.opts[\'bgcolor\'] = fn.glColor(*args, **kwds)\n        self.update()\n        \n    def getViewport(self):\n        vp = self.opts[\'viewport\']\n        dpr = self.devicePixelRatio()\n        if vp is None:\n            return (0, 0, int(self.width() * dpr), int(self.height() * dpr))\n        else:\n            return tuple([int(x * dpr) for x in vp])\n        \n    def devicePixelRatio(self):\n        dpr = self.opts[\'devicePixelRatio\']\n        if dpr is not None:\n            return dpr\n        \n        if hasattr(QtOpenGL.QGLWidget, \'devicePixelRatio\'):\n            return QtOpenGL.QGLWidget.devicePixelRatio(self)\n        else:\n            return 1.0\n        \n    def resizeGL(self, w, h):\n        pass\n        #glViewport(*self.getViewport())\n        #self.update()\n\n    def setProjection(self, region=None):\n        m = self.projectionMatrix(region)\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        a = np.array(m.copyDataTo()).reshape((4,4))\n        glMultMatrixf(a.transpose())\n\n    def projectionMatrix(self, region=None):\n        if region is None:\n            dpr = self.devicePixelRatio()\n            region = (0, 0, self.width() * dpr, self.height() * dpr)\n        \n        x0, y0, w, h = self.getViewport()\n        dist = self.opts[\'distance\']\n        fov = self.opts[\'fov\']\n        nearClip = dist * 0.001\n        farClip = dist * 1000.\n\n        r = nearClip * np.tan(fov * 0.5 * np.pi / 180.)\n        t = r * h / w\n\n        ## Note that X0 and width in these equations must be the values used in viewport\n        left  = r * ((region[0]-x0) * (2.0/w) - 1)\n        right = r * ((region[0]+region[2]-x0) * (2.0/w) - 1)\n        bottom = t * ((region[1]-y0) * (2.0/h) - 1)\n        top    = t * ((region[1]+region[3]-y0) * (2.0/h) - 1)\n\n        tr = QtGui.QMatrix4x4()\n        tr.frustum(left, right, bottom, top, nearClip, farClip)\n        return tr\n        \n    def setModelview(self):\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n        m = self.viewMatrix()\n        a = np.array(m.copyDataTo()).reshape((4,4))\n        glMultMatrixf(a.transpose())\n        \n    def viewMatrix(self):\n        tr = QtGui.QMatrix4x4()\n        tr.translate( 0.0, 0.0, -self.opts[\'distance\'])\n        tr.rotate(self.opts[\'elevation\']-90, 1, 0, 0)\n        tr.rotate(self.opts[\'azimuth\']+90, 0, 0, -1)\n        center = self.opts[\'center\']\n        tr.translate(-center.x(), -center.y(), -center.z())\n        return tr\n\n    def itemsAt(self, region=None):\n        """"""\n        Return a list of the items displayed in the region (x, y, w, h)\n        relative to the widget.        \n        """"""\n        region = (region[0], self.height()-(region[1]+region[3]), region[2], region[3])\n        \n        #buf = np.zeros(100000, dtype=np.uint)\n        buf = glSelectBuffer(100000)\n        try:\n            glRenderMode(GL_SELECT)\n            glInitNames()\n            glPushName(0)\n            self._itemNames = {}\n            self.paintGL(region=region, useItemNames=True)\n            \n        finally:\n            hits = glRenderMode(GL_RENDER)\n            \n        items = [(h.near, h.names[0]) for h in hits]\n        items.sort(key=lambda i: i[0])\n        return [self._itemNames[i[1]] for i in items]\n    \n    def paintGL(self, region=None, viewport=None, useItemNames=False):\n        """"""\n        viewport specifies the arguments to glViewport. If None, then we use self.opts[\'viewport\']\n        region specifies the sub-region of self.opts[\'viewport\'] that should be rendered.\n        Note that we may use viewport != self.opts[\'viewport\'] when exporting.\n        """"""\n        if viewport is None:\n            glViewport(*self.getViewport())\n        else:\n            glViewport(*viewport)\n        self.setProjection(region=region)\n        self.setModelview()\n        bgcolor = self.opts[\'bgcolor\']\n        glClearColor(*bgcolor)\n        glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT )\n        self.drawItemTree(useItemNames=useItemNames)\n        \n    def drawItemTree(self, item=None, useItemNames=False):\n        if item is None:\n            items = [x for x in self.items if x.parentItem() is None]\n        else:\n            items = item.childItems()\n            items.append(item)\n        items.sort(key=lambda a: a.depthValue())\n        for i in items:\n            if not i.visible():\n                continue\n            if i is item:\n                try:\n                    glPushAttrib(GL_ALL_ATTRIB_BITS)\n                    if useItemNames:\n                        glLoadName(i._id)\n                        self._itemNames[i._id] = i\n                    i.paint()\n                except:\n                    from .. import debug\n                    debug.printExc()\n                    msg = ""Error while drawing item %s."" % str(item)\n                    ver = glGetString(GL_VERSION)\n                    if ver is not None:\n                        ver = ver.split()[0]\n                        if int(ver.split(b\'.\')[0]) < 2:\n                            print(msg + "" The original exception is printed above; however, pyqtgraph requires OpenGL version 2.0 or greater for many of its 3D features and your OpenGL version is %s. Installing updated display drivers may resolve this issue."" % ver)\n                        else:\n                            print(msg)\n                    \n                finally:\n                    glPopAttrib()\n            else:\n                glMatrixMode(GL_MODELVIEW)\n                glPushMatrix()\n                try:\n                    tr = i.transform()\n                    a = np.array(tr.copyDataTo()).reshape((4,4))\n                    glMultMatrixf(a.transpose())\n                    self.drawItemTree(i, useItemNames=useItemNames)\n                finally:\n                    glMatrixMode(GL_MODELVIEW)\n                    glPopMatrix()\n            \n    def setCameraPosition(self, pos=None, distance=None, elevation=None, azimuth=None):\n        if distance is not None:\n            self.opts[\'distance\'] = distance\n        if elevation is not None:\n            self.opts[\'elevation\'] = elevation\n        if azimuth is not None:\n            self.opts[\'azimuth\'] = azimuth\n        self.update()\n        \n    def cameraPosition(self):\n        """"""Return current position of camera based on center, dist, elevation, and azimuth""""""\n        center = self.opts[\'center\']\n        dist = self.opts[\'distance\']\n        elev = self.opts[\'elevation\'] * np.pi/180.\n        azim = self.opts[\'azimuth\'] * np.pi/180.\n        \n        pos = Vector(\n            center.x() + dist * np.cos(elev) * np.cos(azim),\n            center.y() + dist * np.cos(elev) * np.sin(azim),\n            center.z() + dist * np.sin(elev)\n        )\n        \n        return pos\n\n    def orbit(self, azim, elev):\n        """"""Orbits the camera around the center position. *azim* and *elev* are given in degrees.""""""\n        self.opts[\'azimuth\'] += azim\n        self.opts[\'elevation\'] = np.clip(self.opts[\'elevation\'] + elev, -90, 90)\n        self.update()\n        \n    def pan(self, dx, dy, dz, relative=\'global\'):\n        """"""\n        Moves the center (look-at) position while holding the camera in place. \n        \n        ==============  =======================================================\n        **Arguments:**\n        *dx*            Distance to pan in x direction\n        *dy*            Distance to pan in y direction\n        *dx*            Distance to pan in z direction\n        *relative*      String that determines the direction of dx,dy,dz. \n                        If ""global"", then the global coordinate system is used.\n                        If ""view"", then the z axis is aligned with the view\n                        direction, and x and y axes are inthe plane of the\n                        view: +x points right, +y points up. \n                        If ""view-upright"", then x is in the global xy plane and\n                        points to the right side of the view, y is in the\n                        global xy plane and orthogonal to x, and z points in\n                        the global z direction.\n        ==============  =======================================================\n        \n        Distances are scaled roughly such that a value of 1.0 moves\n        by one pixel on screen.\n        \n        Prior to version 0.11, *relative* was expected to be either True (x-aligned) or\n        False (global). These values are deprecated but still recognized.\n        """"""\n        # for backward compatibility:\n        relative = {True: ""view-upright"", False: ""global""}.get(relative, relative)\n        \n        if relative == \'global\':\n            self.opts[\'center\'] += QtGui.QVector3D(dx, dy, dz)\n        elif relative == \'view-upright\':\n            cPos = self.cameraPosition()\n            cVec = self.opts[\'center\'] - cPos\n            dist = cVec.length()  ## distance from camera to center\n            xDist = dist * 2. * np.tan(0.5 * self.opts[\'fov\'] * np.pi / 180.)  ## approx. width of view at distance of center point\n            xScale = xDist / self.width()\n            zVec = QtGui.QVector3D(0,0,1)\n            xVec = QtGui.QVector3D.crossProduct(zVec, cVec).normalized()\n            yVec = QtGui.QVector3D.crossProduct(xVec, zVec).normalized()\n            self.opts[\'center\'] = self.opts[\'center\'] + xVec * xScale * dx + yVec * xScale * dy + zVec * xScale * dz\n        elif relative == \'view\':\n            # pan in plane of camera\n            elev = np.radians(self.opts[\'elevation\'])\n            azim = np.radians(self.opts[\'azimuth\'])\n            fov = np.radians(self.opts[\'fov\'])\n            dist = (self.opts[\'center\'] - self.cameraPosition()).length()\n            fov_factor = np.tan(fov / 2) * 2\n            scale_factor = dist * fov_factor / self.width()\n            z = scale_factor * np.cos(elev) * dy\n            x = scale_factor * (np.sin(azim) * dx - np.sin(elev) * np.cos(azim) * dy)\n            y = scale_factor * (np.cos(azim) * dx + np.sin(elev) * np.sin(azim) * dy)\n            self.opts[\'center\'] += QtGui.QVector3D(x, -y, z)\n        else:\n            raise ValueError(""relative argument must be global, view, or view-upright"")\n        \n        self.update()\n        \n    def pixelSize(self, pos):\n        """"""\n        Return the approximate size of a screen pixel at the location pos\n        Pos may be a Vector or an (N,3) array of locations\n        """"""\n        cam = self.cameraPosition()\n        if isinstance(pos, np.ndarray):\n            cam = np.array(cam).reshape((1,)*(pos.ndim-1)+(3,))\n            dist = ((pos-cam)**2).sum(axis=-1)**0.5\n        else:\n            dist = (pos-cam).length()\n        xDist = dist * 2. * np.tan(0.5 * self.opts[\'fov\'] * np.pi / 180.)\n        return xDist / self.width()\n        \n    def mousePressEvent(self, ev):\n        self.mousePos = ev.pos()\n        \n    def mouseMoveEvent(self, ev):\n        diff = ev.pos() - self.mousePos\n        self.mousePos = ev.pos()\n        \n        if ev.buttons() == QtCore.Qt.LeftButton:\n            if (ev.modifiers() & QtCore.Qt.ControlModifier):\n                self.pan(diff.x(), diff.y(), 0, relative=\'view\')\n            else:\n                self.orbit(-diff.x(), diff.y())\n        elif ev.buttons() == QtCore.Qt.MidButton:\n            if (ev.modifiers() & QtCore.Qt.ControlModifier):\n                self.pan(diff.x(), 0, diff.y(), relative=\'view-upright\')\n            else:\n                self.pan(diff.x(), diff.y(), 0, relative=\'view-upright\')\n        \n    def mouseReleaseEvent(self, ev):\n        pass\n        # Example item selection code:\n        #region = (ev.pos().x()-5, ev.pos().y()-5, 10, 10)\n        #print(self.itemsAt(region))\n        \n        ## debugging code: draw the picking region\n        #glViewport(*self.getViewport())\n        #glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT )\n        #region = (region[0], self.height()-(region[1]+region[3]), region[2], region[3])\n        #self.paintGL(region=region)\n        #self.swapBuffers()\n        \n        \n    def wheelEvent(self, ev):\n        delta = 0\n        if QT_LIB in [\'PyQt4\', \'PySide\']:\n            delta = ev.delta()\n        else:\n            delta = ev.angleDelta().x()\n            if delta == 0:\n                delta = ev.angleDelta().y()\n        if (ev.modifiers() & QtCore.Qt.ControlModifier):\n            self.opts[\'fov\'] *= 0.999**delta\n        else:\n            self.opts[\'distance\'] *= 0.999**delta\n        self.update()\n\n    def keyPressEvent(self, ev):\n        if ev.key() in self.noRepeatKeys:\n            ev.accept()\n            if ev.isAutoRepeat():\n                return\n            self.keysPressed[ev.key()] = 1\n            self.evalKeyState()\n      \n    def keyReleaseEvent(self, ev):\n        if ev.key() in self.noRepeatKeys:\n            ev.accept()\n            if ev.isAutoRepeat():\n                return\n            try:\n                del self.keysPressed[ev.key()]\n            except:\n                self.keysPressed = {}\n            self.evalKeyState()\n        \n    def evalKeyState(self):\n        speed = 2.0\n        if len(self.keysPressed) > 0:\n            for key in self.keysPressed:\n                if key == QtCore.Qt.Key_Right:\n                    self.orbit(azim=-speed, elev=0)\n                elif key == QtCore.Qt.Key_Left:\n                    self.orbit(azim=speed, elev=0)\n                elif key == QtCore.Qt.Key_Up:\n                    self.orbit(azim=0, elev=-speed)\n                elif key == QtCore.Qt.Key_Down:\n                    self.orbit(azim=0, elev=speed)\n                elif key == QtCore.Qt.Key_PageUp:\n                    pass\n                elif key == QtCore.Qt.Key_PageDown:\n                    pass\n                self.keyTimer.start(16)\n        else:\n            self.keyTimer.stop()\n\n    def checkOpenGLVersion(self, msg):\n        ## Only to be called from within exception handler.\n        ver = glGetString(GL_VERSION).split()[0]\n        if int(ver.split(\'.\')[0]) < 2:\n            from .. import debug\n            pyqtgraph.debug.printExc()\n            raise Exception(msg + "" The original exception is printed above; however, pyqtgraph requires OpenGL version 2.0 or greater for many of its 3D features and your OpenGL version is %s. Installing updated display drivers may resolve this issue."" % ver)\n        else:\n            raise\n            \n    def readQImage(self):\n        """"""\n        Read the current buffer pixels out as a QImage.\n        """"""\n        w = self.width()\n        h = self.height()\n        self.repaint()\n        pixels = np.empty((h, w, 4), dtype=np.ubyte)\n        pixels[:] = 128\n        pixels[...,0] = 50\n        pixels[...,3] = 255\n        \n        glReadPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, pixels)\n        \n        # swap B,R channels for Qt\n        tmp = pixels[...,0].copy()\n        pixels[...,0] = pixels[...,2]\n        pixels[...,2] = tmp\n        pixels = pixels[::-1] # flip vertical\n        \n        img = fn.makeQImage(pixels, transpose=False)\n        return img\n        \n    def renderToArray(self, size, format=GL_BGRA, type=GL_UNSIGNED_BYTE, textureSize=1024, padding=256):\n        w,h = map(int, size)\n        \n        self.makeCurrent()\n        tex = None\n        fb = None\n        try:\n            output = np.empty((w, h, 4), dtype=np.ubyte)\n            fb = glfbo.glGenFramebuffers(1)\n            glfbo.glBindFramebuffer(glfbo.GL_FRAMEBUFFER, fb )\n            \n            glEnable(GL_TEXTURE_2D)\n            tex = glGenTextures(1)\n            glBindTexture(GL_TEXTURE_2D, tex)\n            texwidth = textureSize\n            data = np.zeros((texwidth,texwidth,4), dtype=np.ubyte)\n            \n            ## Test texture dimensions first\n            glTexImage2D(GL_PROXY_TEXTURE_2D, 0, GL_RGBA, texwidth, texwidth, 0, GL_RGBA, GL_UNSIGNED_BYTE, None)\n            if glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, 0, GL_TEXTURE_WIDTH) == 0:\n                raise Exception(""OpenGL failed to create 2D texture (%dx%d); too large for this hardware."" % shape[:2])\n            ## create teture\n            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texwidth, texwidth, 0, GL_RGBA, GL_UNSIGNED_BYTE, data.transpose((1,0,2)))\n            \n            self.opts[\'viewport\'] = (0, 0, w, h)  # viewport is the complete image; this ensures that paintGL(region=...) \n                                                  # is interpreted correctly.\n            p2 = 2 * padding\n            for x in range(-padding, w-padding, texwidth-p2):\n                for y in range(-padding, h-padding, texwidth-p2):\n                    x2 = min(x+texwidth, w+padding)\n                    y2 = min(y+texwidth, h+padding)\n                    w2 = x2-x\n                    h2 = y2-y\n                    \n                    ## render to texture\n                    glfbo.glFramebufferTexture2D(glfbo.GL_FRAMEBUFFER, glfbo.GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0)\n                    \n                    self.paintGL(region=(x, h-y-h2, w2, h2), viewport=(0, 0, w2, h2))  # only render sub-region\n                    glBindTexture(GL_TEXTURE_2D, tex) # fixes issue #366\n                    \n                    ## read texture back to array\n                    data = glGetTexImage(GL_TEXTURE_2D, 0, format, type)\n                    data = np.fromstring(data, dtype=np.ubyte).reshape(texwidth,texwidth,4).transpose(1,0,2)[:, ::-1]\n                    output[x+padding:x2-padding, y+padding:y2-padding] = data[padding:w2-padding, -(h2-padding):-padding]\n                    \n        finally:\n            self.opts[\'viewport\'] = None\n            glfbo.glBindFramebuffer(glfbo.GL_FRAMEBUFFER, 0)\n            glBindTexture(GL_TEXTURE_2D, 0)\n            if tex is not None:\n                glDeleteTextures([tex])\n            if fb is not None:\n                glfbo.glDeleteFramebuffers([fb])\n            \n        return output\n        \n        \n        \n'"
src/third_party/pyqtgraph/opengl/MeshData.py,34,"b'import numpy as np\nfrom ..Qt import QtGui\nfrom .. import functions as fn\nfrom ..python2_3 import xrange\n\n\nclass MeshData(object):\n    """"""\n    Class for storing and operating on 3D mesh data. May contain:\n    \n    - list of vertex locations\n    - list of edges\n    - list of triangles\n    - colors per vertex, edge, or tri\n    - normals per vertex or tri\n    \n    This class handles conversion between the standard [list of vertexes, list of faces]\n    format (suitable for use with glDrawElements) and \'indexed\' [list of vertexes] format\n    (suitable for use with glDrawArrays). It will automatically compute face normal\n    vectors as well as averaged vertex normal vectors. \n    \n    The class attempts to be as efficient as possible in caching conversion results and\n    avoiding unnecessary conversions.\n    """"""\n\n    def __init__(self, vertexes=None, faces=None, edges=None, vertexColors=None, faceColors=None):\n        """"""\n        ==============  =====================================================\n        **Arguments:**\n        vertexes        (Nv, 3) array of vertex coordinates.\n                        If faces is not specified, then this will instead be\n                        interpreted as (Nf, 3, 3) array of coordinates.\n        faces           (Nf, 3) array of indexes into the vertex array.\n        edges           [not available yet]\n        vertexColors    (Nv, 4) array of vertex colors.\n                        If faces is not specified, then this will instead be\n                        interpreted as (Nf, 3, 4) array of colors.\n        faceColors      (Nf, 4) array of face colors.\n        ==============  =====================================================\n        \n        All arguments are optional.\n        """"""\n        self._vertexes = None  # (Nv,3) array of vertex coordinates\n        self._vertexesIndexedByFaces = None   #  (Nf, 3, 3) array of vertex coordinates\n        self._vertexesIndexedByEdges = None   #  (Ne, 2, 3) array of vertex coordinates\n        \n        ## mappings between vertexes, faces, and edges\n        self._faces = None   # Nx3 array of indexes into self._vertexes specifying three vertexes for each face\n        self._edges = None   # Nx2 array of indexes into self._vertexes specifying two vertexes per edge\n        self._vertexFaces = None  ## maps vertex ID to a list of face IDs (inverse mapping of _faces)\n        self._vertexEdges = None  ## maps vertex ID to a list of edge IDs (inverse mapping of _edges)\n        \n        ## Per-vertex data\n        self._vertexNormals = None                # (Nv, 3) array of normals, one per vertex\n        self._vertexNormalsIndexedByFaces = None  # (Nf, 3, 3) array of normals\n        self._vertexColors = None                 # (Nv, 3) array of colors\n        self._vertexColorsIndexedByFaces = None   # (Nf, 3, 4) array of colors\n        self._vertexColorsIndexedByEdges = None   # (Nf, 2, 4) array of colors\n        \n        ## Per-face data\n        self._faceNormals = None                # (Nf, 3) array of face normals\n        self._faceNormalsIndexedByFaces = None  # (Nf, 3, 3) array of face normals\n        self._faceColors = None                 # (Nf, 4) array of face colors\n        self._faceColorsIndexedByFaces = None   # (Nf, 3, 4) array of face colors\n        self._faceColorsIndexedByEdges = None   # (Ne, 2, 4) array of face colors\n        \n        ## Per-edge data\n        self._edgeColors = None                # (Ne, 4) array of edge colors\n        self._edgeColorsIndexedByEdges = None  # (Ne, 2, 4) array of edge colors\n        #self._meshColor = (1, 1, 1, 0.1)  # default color to use if no face/edge/vertex colors are given\n        \n        \n        \n        if vertexes is not None:\n            if faces is None:\n                self.setVertexes(vertexes, indexed=\'faces\')\n                if vertexColors is not None:\n                    self.setVertexColors(vertexColors, indexed=\'faces\')\n                if faceColors is not None:\n                    self.setFaceColors(faceColors, indexed=\'faces\')\n            else:\n                self.setVertexes(vertexes)\n                self.setFaces(faces)\n                if vertexColors is not None:\n                    self.setVertexColors(vertexColors)\n                if faceColors is not None:\n                    self.setFaceColors(faceColors)\n            \n    def faces(self):\n        """"""Return an array (Nf, 3) of vertex indexes, three per triangular face in the mesh.\n        \n        If faces have not been computed for this mesh, the function returns None.\n        """"""\n        return self._faces\n    \n    def edges(self):\n        """"""Return an array (Nf, 3) of vertex indexes, two per edge in the mesh.""""""\n        if self._edges is None:\n            self._computeEdges()\n        return self._edges\n        \n    def setFaces(self, faces):\n        """"""Set the (Nf, 3) array of faces. Each rown in the array contains\n        three indexes into the vertex array, specifying the three corners \n        of a triangular face.""""""\n        self._faces = faces\n        self._edges = None\n        self._vertexFaces = None\n        self._vertexesIndexedByFaces = None\n        self.resetNormals()\n        self._vertexColorsIndexedByFaces = None\n        self._faceColorsIndexedByFaces = None\n    \n    def vertexes(self, indexed=None):\n        """"""Return an array (N,3) of the positions of vertexes in the mesh. \n        By default, each unique vertex appears only once in the array.\n        If indexed is \'faces\', then the array will instead contain three vertexes\n        per face in the mesh (and a single vertex may appear more than once in the array).""""""\n        if indexed is None:\n            if self._vertexes is None and self._vertexesIndexedByFaces is not None:\n                self._computeUnindexedVertexes()\n            return self._vertexes\n        elif indexed == \'faces\':\n            if self._vertexesIndexedByFaces is None and self._vertexes is not None:\n                self._vertexesIndexedByFaces = self._vertexes[self.faces()]\n            return self._vertexesIndexedByFaces\n        else:\n            raise Exception(""Invalid indexing mode. Accepts: None, \'faces\'"")\n        \n    def setVertexes(self, verts=None, indexed=None, resetNormals=True):\n        """"""\n        Set the array (Nv, 3) of vertex coordinates.\n        If indexed==\'faces\', then the data must have shape (Nf, 3, 3) and is\n        assumed to be already indexed as a list of faces.\n        This will cause any pre-existing normal vectors to be cleared\n        unless resetNormals=False.\n        """"""\n        if indexed is None:\n            if verts is not None:\n                self._vertexes = verts\n            self._vertexesIndexedByFaces = None\n        elif indexed==\'faces\':\n            self._vertexes = None\n            if verts is not None:\n                self._vertexesIndexedByFaces = verts\n        else:\n            raise Exception(""Invalid indexing mode. Accepts: None, \'faces\'"")\n        \n        if resetNormals:\n            self.resetNormals()\n    \n    def resetNormals(self):\n        self._vertexNormals = None\n        self._vertexNormalsIndexedByFaces = None\n        self._faceNormals = None\n        self._faceNormalsIndexedByFaces = None\n        \n    def hasFaceIndexedData(self):\n        """"""Return True if this object already has vertex positions indexed by face""""""\n        return self._vertexesIndexedByFaces is not None\n    \n    def hasEdgeIndexedData(self):\n        return self._vertexesIndexedByEdges is not None\n    \n    def hasVertexColor(self):\n        """"""Return True if this data set has vertex color information""""""\n        for v in (self._vertexColors, self._vertexColorsIndexedByFaces, self._vertexColorsIndexedByEdges):\n            if v is not None:\n                return True\n        return False\n        \n    def hasFaceColor(self):\n        """"""Return True if this data set has face color information""""""\n        for v in (self._faceColors, self._faceColorsIndexedByFaces, self._faceColorsIndexedByEdges):\n            if v is not None:\n                return True\n        return False\n    \n    def faceNormals(self, indexed=None):\n        """"""\n        Return an array (Nf, 3) of normal vectors for each face.\n        If indexed=\'faces\', then instead return an indexed array\n        (Nf, 3, 3)  (this is just the same array with each vector\n        copied three times).\n        """"""\n        if self._faceNormals is None:\n            v = self.vertexes(indexed=\'faces\')\n            self._faceNormals = np.cross(v[:,1]-v[:,0], v[:,2]-v[:,0])\n        \n        if indexed is None:\n            return self._faceNormals\n        elif indexed == \'faces\':\n            if self._faceNormalsIndexedByFaces is None:\n                norms = np.empty((self._faceNormals.shape[0], 3, 3))\n                norms[:] = self._faceNormals[:,np.newaxis,:]\n                self._faceNormalsIndexedByFaces = norms\n            return self._faceNormalsIndexedByFaces\n        else:\n            raise Exception(""Invalid indexing mode. Accepts: None, \'faces\'"")\n        \n    def vertexNormals(self, indexed=None):\n        """"""\n        Return an array of normal vectors.\n        By default, the array will be (N, 3) with one entry per unique vertex in the mesh.\n        If indexed is \'faces\', then the array will contain three normal vectors per face\n        (and some vertexes may be repeated).\n        """"""\n        if self._vertexNormals is None:\n            faceNorms = self.faceNormals()\n            vertFaces = self.vertexFaces()\n            self._vertexNormals = np.empty(self._vertexes.shape, dtype=float)\n            for vindex in xrange(self._vertexes.shape[0]):\n                faces = vertFaces[vindex]\n                if len(faces) == 0:\n                    self._vertexNormals[vindex] = (0,0,0)\n                    continue\n                norms = faceNorms[faces]  ## get all face normals\n                norm = norms.sum(axis=0)       ## sum normals\n                norm /= (norm**2).sum()**0.5  ## and re-normalize\n                self._vertexNormals[vindex] = norm\n                \n        if indexed is None:\n            return self._vertexNormals\n        elif indexed == \'faces\':\n            return self._vertexNormals[self.faces()]\n        else:\n            raise Exception(""Invalid indexing mode. Accepts: None, \'faces\'"")\n        \n    def vertexColors(self, indexed=None):\n        """"""\n        Return an array (Nv, 4) of vertex colors.\n        If indexed==\'faces\', then instead return an indexed array\n        (Nf, 3, 4). \n        """"""\n        if indexed is None:\n            return self._vertexColors\n        elif indexed == \'faces\':\n            if self._vertexColorsIndexedByFaces is None:\n                self._vertexColorsIndexedByFaces = self._vertexColors[self.faces()]\n            return self._vertexColorsIndexedByFaces\n        else:\n            raise Exception(""Invalid indexing mode. Accepts: None, \'faces\'"")\n        \n    def setVertexColors(self, colors, indexed=None):\n        """"""\n        Set the vertex color array (Nv, 4).\n        If indexed==\'faces\', then the array will be interpreted\n        as indexed and should have shape (Nf, 3, 4)\n        """"""\n        if indexed is None:\n            self._vertexColors = colors\n            self._vertexColorsIndexedByFaces = None\n        elif indexed == \'faces\':\n            self._vertexColors = None\n            self._vertexColorsIndexedByFaces = colors\n        else:\n            raise Exception(""Invalid indexing mode. Accepts: None, \'faces\'"")\n        \n    def faceColors(self, indexed=None):\n        """"""\n        Return an array (Nf, 4) of face colors.\n        If indexed==\'faces\', then instead return an indexed array\n        (Nf, 3, 4)  (note this is just the same array with each color\n        repeated three times). \n        """"""\n        if indexed is None:\n            return self._faceColors\n        elif indexed == \'faces\':\n            if self._faceColorsIndexedByFaces is None and self._faceColors is not None:\n                Nf = self._faceColors.shape[0]\n                self._faceColorsIndexedByFaces = np.empty((Nf, 3, 4), dtype=self._faceColors.dtype)\n                self._faceColorsIndexedByFaces[:] = self._faceColors.reshape(Nf, 1, 4)\n            return self._faceColorsIndexedByFaces\n        else:\n            raise Exception(""Invalid indexing mode. Accepts: None, \'faces\'"")\n        \n    def setFaceColors(self, colors, indexed=None):\n        """"""\n        Set the face color array (Nf, 4).\n        If indexed==\'faces\', then the array will be interpreted\n        as indexed and should have shape (Nf, 3, 4)\n        """"""\n        if indexed is None:\n            self._faceColors = colors\n            self._faceColorsIndexedByFaces = None\n        elif indexed == \'faces\':\n            self._faceColors = None\n            self._faceColorsIndexedByFaces = colors\n        else:\n            raise Exception(""Invalid indexing mode. Accepts: None, \'faces\'"")\n        \n    def faceCount(self):\n        """"""\n        Return the number of faces in the mesh.\n        """"""\n        if self._faces is not None:\n            return self._faces.shape[0]\n        elif self._vertexesIndexedByFaces is not None:\n            return self._vertexesIndexedByFaces.shape[0]\n        \n    def edgeColors(self):\n        return self._edgeColors\n        \n    #def _setIndexedFaces(self, faces, vertexColors=None, faceColors=None):\n        #self._vertexesIndexedByFaces = faces\n        #self._vertexColorsIndexedByFaces = vertexColors\n        #self._faceColorsIndexedByFaces = faceColors\n        \n    def _computeUnindexedVertexes(self):\n        ## Given (Nv, 3, 3) array of vertexes-indexed-by-face, convert backward to unindexed vertexes\n        ## This is done by collapsing into a list of \'unique\' vertexes (difference < 1e-14) \n        \n        ## I think generally this should be discouraged..\n        faces = self._vertexesIndexedByFaces\n        verts = {}  ## used to remember the index of each vertex position\n        self._faces = np.empty(faces.shape[:2], dtype=np.uint)\n        self._vertexes = []\n        self._vertexFaces = []\n        self._faceNormals = None\n        self._vertexNormals = None\n        for i in xrange(faces.shape[0]):\n            face = faces[i]\n            inds = []\n            for j in range(face.shape[0]):\n                pt = face[j]\n                pt2 = tuple([round(x*1e14) for x in pt])  ## quantize to be sure that nearly-identical points will be merged\n                index = verts.get(pt2, None)\n                if index is None:\n                    #self._vertexes.append(QtGui.QVector3D(*pt))\n                    self._vertexes.append(pt)\n                    self._vertexFaces.append([])\n                    index = len(self._vertexes)-1\n                    verts[pt2] = index\n                self._vertexFaces[index].append(i)  # keep track of which vertexes belong to which faces\n                self._faces[i,j] = index\n        self._vertexes = np.array(self._vertexes, dtype=float)\n    \n    #def _setUnindexedFaces(self, faces, vertexes, vertexColors=None, faceColors=None):\n        #self._vertexes = vertexes #[QtGui.QVector3D(*v) for v in vertexes]\n        #self._faces = faces.astype(np.uint)\n        #self._edges = None\n        #self._vertexFaces = None\n        #self._faceNormals = None\n        #self._vertexNormals = None\n        #self._vertexColors = vertexColors\n        #self._faceColors = faceColors\n\n    def vertexFaces(self):\n        """"""\n        Return list mapping each vertex index to a list of face indexes that use the vertex.\n        """"""\n        if self._vertexFaces is None:\n            self._vertexFaces = [[] for i in xrange(len(self.vertexes()))]\n            for i in xrange(self._faces.shape[0]):\n                face = self._faces[i]\n                for ind in face:\n                    self._vertexFaces[ind].append(i)\n        return self._vertexFaces\n        \n    #def reverseNormals(self):\n        #""""""\n        #Reverses the direction of all normal vectors.\n        #""""""\n        #pass\n        \n    #def generateEdgesFromFaces(self):\n        #""""""\n        #Generate a set of edges by listing all the edges of faces and removing any duplicates.\n        #Useful for displaying wireframe meshes.\n        #""""""\n        #pass\n        \n    def _computeEdges(self):\n        if not self.hasFaceIndexedData:\n            ## generate self._edges from self._faces\n            nf = len(self._faces)\n            edges = np.empty(nf*3, dtype=[(\'i\', np.uint, 2)])\n            edges[\'i\'][0:nf] = self._faces[:,:2]\n            edges[\'i\'][nf:2*nf] = self._faces[:,1:3]\n            edges[\'i\'][-nf:,0] = self._faces[:,2]\n            edges[\'i\'][-nf:,1] = self._faces[:,0]\n            \n            # sort per-edge\n            mask = edges[\'i\'][:,0] > edges[\'i\'][:,1]\n            edges[\'i\'][mask] = edges[\'i\'][mask][:,::-1]\n            \n            # remove duplicate entries\n            self._edges = np.unique(edges)[\'i\']\n            #print self._edges\n        elif self._vertexesIndexedByFaces is not None:\n            verts = self._vertexesIndexedByFaces\n            edges = np.empty((verts.shape[0], 3, 2), dtype=np.uint)\n            nf = verts.shape[0]\n            edges[:,0,0] = np.arange(nf) * 3\n            edges[:,0,1] = edges[:,0,0] + 1\n            edges[:,1,0] = edges[:,0,1]\n            edges[:,1,1] = edges[:,1,0] + 1\n            edges[:,2,0] = edges[:,1,1]\n            edges[:,2,1] = edges[:,0,0]\n            self._edges = edges\n        else:\n            raise Exception(""MeshData cannot generate edges--no faces in this data."")\n        \n        \n    def save(self):\n        """"""Serialize this mesh to a string appropriate for disk storage""""""\n        import pickle\n        if self._faces is not None:\n            names = [\'_vertexes\', \'_faces\']\n        else:\n            names = [\'_vertexesIndexedByFaces\']\n            \n        if self._vertexColors is not None:\n            names.append(\'_vertexColors\')\n        elif self._vertexColorsIndexedByFaces is not None:\n            names.append(\'_vertexColorsIndexedByFaces\')\n            \n        if self._faceColors is not None:\n            names.append(\'_faceColors\')\n        elif self._faceColorsIndexedByFaces is not None:\n            names.append(\'_faceColorsIndexedByFaces\')\n            \n        state = dict([(n,getattr(self, n)) for n in names])\n        return pickle.dumps(state)\n        \n    def restore(self, state):\n        """"""Restore the state of a mesh previously saved using save()""""""\n        import pickle\n        state = pickle.loads(state)\n        for k in state:\n            if isinstance(state[k], list):\n                if isinstance(state[k][0], QtGui.QVector3D):\n                    state[k] = [[v.x(), v.y(), v.z()] for v in state[k]]\n                state[k] = np.array(state[k])\n            setattr(self, k, state[k])\n\n\n\n    @staticmethod\n    def sphere(rows, cols, radius=1.0, offset=True):\n        """"""\n        Return a MeshData instance with vertexes and faces computed\n        for a spherical surface.\n        """"""\n        verts = np.empty((rows+1, cols, 3), dtype=float)\n        \n        ## compute vertexes\n        phi = (np.arange(rows+1) * np.pi / rows).reshape(rows+1, 1)\n        s = radius * np.sin(phi)\n        verts[...,2] = radius * np.cos(phi)\n        th = ((np.arange(cols) * 2 * np.pi / cols).reshape(1, cols)) \n        if offset:\n            th = th + ((np.pi / cols) * np.arange(rows+1).reshape(rows+1,1))  ## rotate each row by 1/2 column\n        verts[...,0] = s * np.cos(th)\n        verts[...,1] = s * np.sin(th)\n        verts = verts.reshape((rows+1)*cols, 3)[cols-1:-(cols-1)]  ## remove redundant vertexes from top and bottom\n        \n        ## compute faces\n        faces = np.empty((rows*cols*2, 3), dtype=np.uint)\n        rowtemplate1 = ((np.arange(cols).reshape(cols, 1) + np.array([[0, 1, 0]])) % cols) + np.array([[0, 0, cols]])\n        rowtemplate2 = ((np.arange(cols).reshape(cols, 1) + np.array([[0, 1, 1]])) % cols) + np.array([[cols, 0, cols]])\n        for row in range(rows):\n            start = row * cols * 2 \n            faces[start:start+cols] = rowtemplate1 + row * cols\n            faces[start+cols:start+(cols*2)] = rowtemplate2 + row * cols\n        faces = faces[cols:-cols]  ## cut off zero-area triangles at top and bottom\n        \n        ## adjust for redundant vertexes that were removed from top and bottom\n        vmin = cols-1\n        faces[faces<vmin] = vmin\n        faces -= vmin  \n        vmax = verts.shape[0]-1\n        faces[faces>vmax] = vmax\n        \n        return MeshData(vertexes=verts, faces=faces)\n        \n    @staticmethod\n    def cylinder(rows, cols, radius=[1.0, 1.0], length=1.0, offset=False):\n        """"""\n        Return a MeshData instance with vertexes and faces computed\n        for a cylindrical surface.\n        The cylinder may be tapered with different radii at each end (truncated cone)\n        """"""\n        verts = np.empty((rows+1, cols, 3), dtype=float)\n        if isinstance(radius, int):\n            radius = [radius, radius] # convert to list\n        ## compute vertexes\n        th = np.linspace(2 * np.pi, (2 * np.pi)/cols, cols).reshape(1, cols)\n        r = np.linspace(radius[0],radius[1],num=rows+1, endpoint=True).reshape(rows+1, 1) # radius as a function of z\n        verts[...,2] = np.linspace(0, length, num=rows+1, endpoint=True).reshape(rows+1, 1) # z\n        if offset:\n            th = th + ((np.pi / cols) * np.arange(rows+1).reshape(rows+1,1))  ## rotate each row by 1/2 column\n        verts[...,0] = r * np.cos(th) # x = r cos(th)\n        verts[...,1] = r * np.sin(th) # y = r sin(th)\n        verts = verts.reshape((rows+1)*cols, 3) # just reshape: no redundant vertices...\n        ## compute faces\n        faces = np.empty((rows*cols*2, 3), dtype=np.uint)\n        rowtemplate1 = ((np.arange(cols).reshape(cols, 1) + np.array([[0, 1, 0]])) % cols) + np.array([[0, 0, cols]])\n        rowtemplate2 = ((np.arange(cols).reshape(cols, 1) + np.array([[0, 1, 1]])) % cols) + np.array([[cols, 0, cols]])\n        for row in range(rows):\n            start = row * cols * 2 \n            faces[start:start+cols] = rowtemplate1 + row * cols\n            faces[start+cols:start+(cols*2)] = rowtemplate2 + row * cols\n        \n        return MeshData(vertexes=verts, faces=faces)\n        \n'"
src/third_party/pyqtgraph/opengl/__init__.py,0,"b""from .GLViewWidget import GLViewWidget\n\n## dynamic imports cause too many problems.\n#from .. import importAll\n#importAll('items', globals(), locals())\n\nfrom .items.GLGridItem import * \nfrom .items.GLBarGraphItem import * \nfrom .items.GLScatterPlotItem import *                                                                                                                      \nfrom .items.GLMeshItem import *                                                                                                                             \nfrom .items.GLLinePlotItem import *                                                                                                                         \nfrom .items.GLAxisItem import *                                                                                                                             \nfrom .items.GLImageItem import *                                                                                                                            \nfrom .items.GLSurfacePlotItem import *                                                                                                                      \nfrom .items.GLBoxItem import *                                                                                                                              \nfrom .items.GLVolumeItem import *                                                                                                                           \n\nfrom .MeshData import MeshData\n## for backward compatibility:\n#MeshData.MeshData = MeshData  ## breaks autodoc.\n\nfrom . import shaders\n"""
src/third_party/pyqtgraph/opengl/glInfo.py,0,"b'from ..Qt import QtCore, QtGui, QtOpenGL\nfrom OpenGL.GL import *\napp = QtGui.QApplication([])\n\nclass GLTest(QtOpenGL.QGLWidget):\n    def __init__(self):\n        QtOpenGL.QGLWidget.__init__(self)\n        self.makeCurrent()\n        print(""GL version:"" + glGetString(GL_VERSION))\n        print(""MAX_TEXTURE_SIZE: %d"" % glGetIntegerv(GL_MAX_TEXTURE_SIZE))\n        print(""MAX_3D_TEXTURE_SIZE: %d"" % glGetIntegerv(GL_MAX_3D_TEXTURE_SIZE))\n        print(""Extensions: "" + glGetString(GL_EXTENSIONS))\n\nGLTest()\n\n\n'"
src/third_party/pyqtgraph/opengl/shaders.py,0,"b'try:\n    from OpenGL import NullFunctionError\nexcept ImportError:\n    from OpenGL.error import NullFunctionError\nfrom OpenGL.GL import *\nfrom OpenGL.GL import shaders\nimport re\n\n## For centralizing and managing vertex/fragment shader programs.\n\ndef initShaders():\n    global Shaders\n    Shaders = [\n        ShaderProgram(None, []),\n        \n        ## increases fragment alpha as the normal turns orthogonal to the view\n        ## this is useful for viewing shells that enclose a volume (such as isosurfaces)\n        ShaderProgram(\'balloon\', [\n            VertexShader(""""""\n                varying vec3 normal;\n                void main() {\n                    // compute here for use in fragment shader\n                    normal = normalize(gl_NormalMatrix * gl_Normal);\n                    gl_FrontColor = gl_Color;\n                    gl_BackColor = gl_Color;\n                    gl_Position = ftransform();\n                }\n            """"""),\n            FragmentShader(""""""\n                varying vec3 normal;\n                void main() {\n                    vec4 color = gl_Color;\n                    color.w = min(color.w + 2.0 * color.w * pow(normal.x*normal.x + normal.y*normal.y, 5.0), 1.0);\n                    gl_FragColor = color;\n                }\n            """""")\n        ]),\n        \n        ## colors fragments based on face normals relative to view\n        ## This means that the colors will change depending on how the view is rotated\n        ShaderProgram(\'viewNormalColor\', [   \n            VertexShader(""""""\n                varying vec3 normal;\n                void main() {\n                    // compute here for use in fragment shader\n                    normal = normalize(gl_NormalMatrix * gl_Normal);\n                    gl_FrontColor = gl_Color;\n                    gl_BackColor = gl_Color;\n                    gl_Position = ftransform();\n                }\n            """"""),\n            FragmentShader(""""""\n                varying vec3 normal;\n                void main() {\n                    vec4 color = gl_Color;\n                    color.x = (normal.x + 1.0) * 0.5;\n                    color.y = (normal.y + 1.0) * 0.5;\n                    color.z = (normal.z + 1.0) * 0.5;\n                    gl_FragColor = color;\n                }\n            """""")\n        ]),\n        \n        ## colors fragments based on absolute face normals.\n        ShaderProgram(\'normalColor\', [   \n            VertexShader(""""""\n                varying vec3 normal;\n                void main() {\n                    // compute here for use in fragment shader\n                    normal = normalize(gl_Normal);\n                    gl_FrontColor = gl_Color;\n                    gl_BackColor = gl_Color;\n                    gl_Position = ftransform();\n                }\n            """"""),\n            FragmentShader(""""""\n                varying vec3 normal;\n                void main() {\n                    vec4 color = gl_Color;\n                    color.x = (normal.x + 1.0) * 0.5;\n                    color.y = (normal.y + 1.0) * 0.5;\n                    color.z = (normal.z + 1.0) * 0.5;\n                    gl_FragColor = color;\n                }\n            """""")\n        ]),\n        \n        ## very simple simulation of lighting. \n        ## The light source position is always relative to the camera.\n        ShaderProgram(\'shaded\', [   \n            VertexShader(""""""\n                varying vec3 normal;\n                void main() {\n                    // compute here for use in fragment shader\n                    normal = normalize(gl_NormalMatrix * gl_Normal);\n                    gl_FrontColor = gl_Color;\n                    gl_BackColor = gl_Color;\n                    gl_Position = ftransform();\n                }\n            """"""),\n            FragmentShader(""""""\n                varying vec3 normal;\n                void main() {\n                    float p = dot(normal, normalize(vec3(1.0, -1.0, -1.0)));\n                    p = p < 0. ? 0. : p * 0.8;\n                    vec4 color = gl_Color;\n                    color.x = color.x * (0.2 + p);\n                    color.y = color.y * (0.2 + p);\n                    color.z = color.z * (0.2 + p);\n                    gl_FragColor = color;\n                }\n            """""")\n        ]),\n        \n        ## colors get brighter near edges of object\n        ShaderProgram(\'edgeHilight\', [   \n            VertexShader(""""""\n                varying vec3 normal;\n                void main() {\n                    // compute here for use in fragment shader\n                    normal = normalize(gl_NormalMatrix * gl_Normal);\n                    gl_FrontColor = gl_Color;\n                    gl_BackColor = gl_Color;\n                    gl_Position = ftransform();\n                }\n            """"""),\n            FragmentShader(""""""\n                varying vec3 normal;\n                void main() {\n                    vec4 color = gl_Color;\n                    float s = pow(normal.x*normal.x + normal.y*normal.y, 2.0);\n                    color.x = color.x + s * (1.0-color.x);\n                    color.y = color.y + s * (1.0-color.y);\n                    color.z = color.z + s * (1.0-color.z);\n                    gl_FragColor = color;\n                }\n            """""")\n        ]),\n        \n        ## colors fragments by z-value.\n        ## This is useful for coloring surface plots by height.\n        ## This shader uses a uniform called ""colorMap"" to determine how to map the colors:\n        ##    red   = pow(z * colorMap[0] + colorMap[1], colorMap[2])\n        ##    green = pow(z * colorMap[3] + colorMap[4], colorMap[5])\n        ##    blue  = pow(z * colorMap[6] + colorMap[7], colorMap[8])\n        ## (set the values like this: shader[\'uniformMap\'] = array([...])\n        ShaderProgram(\'heightColor\', [\n            VertexShader(""""""\n                varying vec4 pos;\n                void main() {\n                    gl_FrontColor = gl_Color;\n                    gl_BackColor = gl_Color;\n                    pos = gl_Vertex;\n                    gl_Position = ftransform();\n                }\n            """"""),\n            FragmentShader(""""""\n                uniform float colorMap[9];\n                varying vec4 pos;\n                //out vec4 gl_FragColor;   // only needed for later glsl versions\n                //in vec4 gl_Color;\n                void main() {\n                    vec4 color = gl_Color;\n                    color.x = colorMap[0] * (pos.z + colorMap[1]);\n                    if (colorMap[2] != 1.0)\n                        color.x = pow(color.x, colorMap[2]);\n                    color.x = color.x < 0. ? 0. : (color.x > 1. ? 1. : color.x);\n                    \n                    color.y = colorMap[3] * (pos.z + colorMap[4]);\n                    if (colorMap[5] != 1.0)\n                        color.y = pow(color.y, colorMap[5]);\n                    color.y = color.y < 0. ? 0. : (color.y > 1. ? 1. : color.y);\n                    \n                    color.z = colorMap[6] * (pos.z + colorMap[7]);\n                    if (colorMap[8] != 1.0)\n                        color.z = pow(color.z, colorMap[8]);\n                    color.z = color.z < 0. ? 0. : (color.z > 1. ? 1. : color.z);\n                    \n                    color.w = 1.0;\n                    gl_FragColor = color;\n                }\n            """"""),\n        ], uniforms={\'colorMap\': [1, 1, 1, 1, 0.5, 1, 1, 0, 1]}),\n        ShaderProgram(\'pointSprite\', [   ## allows specifying point size using normal.x\n            ## See:\n            ##\n            ##  http://stackoverflow.com/questions/9609423/applying-part-of-a-texture-sprite-sheet-texture-map-to-a-point-sprite-in-ios\n            ##  http://stackoverflow.com/questions/3497068/textured-points-in-opengl-es-2-0\n            ##\n            ##\n            VertexShader(""""""\n                void main() {\n                    gl_FrontColor=gl_Color;\n                    gl_PointSize = gl_Normal.x;\n                    gl_Position = ftransform();\n                } \n            """"""),\n            #FragmentShader(""""""\n                ##version 120\n                #uniform sampler2D texture;\n                #void main ( )\n                #{\n                    #gl_FragColor = texture2D(texture, gl_PointCoord) * gl_Color;\n                #}\n            #"""""")\n        ]),\n    ]\n\n\nCompiledShaderPrograms = {}\n    \ndef getShaderProgram(name):\n    return ShaderProgram.names[name]\n\nclass Shader(object):\n    def __init__(self, shaderType, code):\n        self.shaderType = shaderType\n        self.code = code\n        self.compiled = None\n        \n    def shader(self):\n        if self.compiled is None:\n            try:\n                self.compiled = shaders.compileShader(self.code, self.shaderType)\n            except NullFunctionError:\n                raise Exception(""This OpenGL implementation does not support shader programs; many OpenGL features in pyqtgraph will not work."")\n            except RuntimeError as exc:\n                ## Format compile errors a bit more nicely\n                if len(exc.args) == 3:\n                    err, code, typ = exc.args\n                    if not err.startswith(\'Shader compile failure\'):\n                        raise\n                    code = code[0].decode(\'utf_8\').split(\'\\n\')\n                    err, c, msgs = err.partition(\':\')\n                    err = err + \'\\n\'\n                    msgs = re.sub(\'b\\\'\',\'\',msgs)\n                    msgs = re.sub(\'\\\'$\',\'\',msgs)\n                    msgs = re.sub(\'\\\\\\\\n\',\'\\n\',msgs)\n                    msgs = msgs.split(\'\\n\')\n                    errNums = [()] * len(code)\n                    for i, msg in enumerate(msgs):\n                        msg = msg.strip()\n                        if msg == \'\':\n                            continue\n                        m = re.match(r\'(\\d+\\:)?\\d+\\((\\d+)\\)\', msg)\n                        if m is not None:\n                            line = int(m.groups()[1])\n                            errNums[line-1] = errNums[line-1] + (str(i+1),)\n                            #code[line-1] = \'%d\\t%s\' % (i+1, code[line-1])\n                        err = err + ""%d %s\\n"" % (i+1, msg)\n                    errNums = [\',\'.join(n) for n in errNums]\n                    maxlen = max(map(len, errNums))\n                    code = [errNums[i] + "" ""*(maxlen-len(errNums[i])) + line for i, line in enumerate(code)]\n                    err = err + \'\\n\'.join(code)\n                    raise Exception(err)\n                else:\n                    raise\n        return self.compiled\n\nclass VertexShader(Shader):\n    def __init__(self, code):\n        Shader.__init__(self, GL_VERTEX_SHADER, code)\n        \nclass FragmentShader(Shader):\n    def __init__(self, code):\n        Shader.__init__(self, GL_FRAGMENT_SHADER, code)\n        \n        \n        \n\nclass ShaderProgram(object):\n    names = {}\n    \n    def __init__(self, name, shaders, uniforms=None):\n        self.name = name\n        ShaderProgram.names[name] = self\n        self.shaders = shaders\n        self.prog = None\n        self.blockData = {}\n        self.uniformData = {}\n        \n        ## parse extra options from the shader definition\n        if uniforms is not None:\n            for k,v in uniforms.items():\n                self[k] = v\n        \n    def setBlockData(self, blockName, data):\n        if data is None:\n            del self.blockData[blockName]\n        else:\n            self.blockData[blockName] = data\n\n    def setUniformData(self, uniformName, data):\n        if data is None:\n            del self.uniformData[uniformName]\n        else:\n            self.uniformData[uniformName] = data\n            \n    def __setitem__(self, item, val):\n        self.setUniformData(item, val)\n        \n    def __delitem__(self, item):\n        self.setUniformData(item, None)\n\n    def program(self):\n        if self.prog is None:\n            try:\n                compiled = [s.shader() for s in self.shaders]  ## compile all shaders\n                self.prog = shaders.compileProgram(*compiled)  ## compile program\n            except:\n                self.prog = -1\n                raise\n        return self.prog\n        \n    def __enter__(self):\n        if len(self.shaders) > 0 and self.program() != -1:\n            glUseProgram(self.program())\n            \n            try:\n                ## load uniform values into program\n                for uniformName, data in self.uniformData.items():\n                    loc = self.uniform(uniformName)\n                    if loc == -1:\n                        raise Exception(\'Could not find uniform variable ""%s""\' % uniformName)\n                    glUniform1fv(loc, len(data), data)\n                    \n                ### bind buffer data to program blocks\n                #if len(self.blockData) > 0:\n                    #bindPoint = 1\n                    #for blockName, data in self.blockData.items():\n                        ### Program should have a uniform block declared:\n                        ### \n                        ### layout (std140) uniform blockName {\n                        ###     vec4 diffuse;\n                        ### };\n                        \n                        ### pick any-old binding point. (there are a limited number of these per-program\n                        #bindPoint = 1\n                        \n                        ### get the block index for a uniform variable in the shader\n                        #blockIndex = glGetUniformBlockIndex(self.program(), blockName)\n                        \n                        ### give the shader block a binding point\n                        #glUniformBlockBinding(self.program(), blockIndex, bindPoint)\n                        \n                        ### create a buffer\n                        #buf = glGenBuffers(1)\n                        #glBindBuffer(GL_UNIFORM_BUFFER, buf)\n                        #glBufferData(GL_UNIFORM_BUFFER, size, data, GL_DYNAMIC_DRAW)\n                        ### also possible to use glBufferSubData to fill parts of the buffer\n                        \n                        ### bind buffer to the same binding point\n                        #glBindBufferBase(GL_UNIFORM_BUFFER, bindPoint, buf)\n            except:\n                glUseProgram(0)\n                raise\n                    \n            \n        \n    def __exit__(self, *args):\n        if len(self.shaders) > 0:\n            glUseProgram(0)\n        \n    def uniform(self, name):\n        """"""Return the location integer for a uniform variable in this program""""""\n        return glGetUniformLocation(self.program(), name.encode(\'utf_8\'))\n\n    #def uniformBlockInfo(self, blockName):\n        #blockIndex = glGetUniformBlockIndex(self.program(), blockName)\n        #count = glGetActiveUniformBlockiv(self.program(), blockIndex, GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS)\n        #indices = []\n        #for i in range(count):\n            #indices.append(glGetActiveUniformBlockiv(self.program(), blockIndex, GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES))\n        \nclass HeightColorShader(ShaderProgram):\n    def __enter__(self):\n        ## Program should have a uniform block declared:\n        ## \n        ## layout (std140) uniform blockName {\n        ##     vec4 diffuse;\n        ##     vec4 ambient;\n        ## };\n        \n        ## pick any-old binding point. (there are a limited number of these per-program\n        bindPoint = 1\n        \n        ## get the block index for a uniform variable in the shader\n        blockIndex = glGetUniformBlockIndex(self.program(), ""blockName"")\n        \n        ## give the shader block a binding point\n        glUniformBlockBinding(self.program(), blockIndex, bindPoint)\n        \n        ## create a buffer\n        buf = glGenBuffers(1)\n        glBindBuffer(GL_UNIFORM_BUFFER, buf)\n        glBufferData(GL_UNIFORM_BUFFER, size, data, GL_DYNAMIC_DRAW)\n        ## also possible to use glBufferSubData to fill parts of the buffer\n        \n        ## bind buffer to the same binding point\n        glBindBufferBase(GL_UNIFORM_BUFFER, bindPoint, buf)\n        \ninitShaders()\n'"
src/third_party/pyqtgraph/parametertree/Parameter.py,0,"b'from ..Qt import QtGui, QtCore\nimport os, weakref, re\nfrom ..pgcollections import OrderedDict\nfrom ..python2_3 import asUnicode, basestring\nfrom .ParameterItem import ParameterItem\n\nPARAM_TYPES = {}\nPARAM_NAMES = {}\n\ndef registerParameterType(name, cls, override=False):\n    global PARAM_TYPES\n    if name in PARAM_TYPES and not override:\n        raise Exception(""Parameter type \'%s\' already exists (use override=True to replace)"" % name)\n    PARAM_TYPES[name] = cls\n    PARAM_NAMES[cls] = name\n\ndef __reload__(old):\n    PARAM_TYPES.update(old.get(\'PARAM_TYPES\', {}))\n    PARAM_NAMES.update(old.get(\'PARAM_NAMES\', {}))\n\nclass Parameter(QtCore.QObject):\n    """"""\n    A Parameter is the basic unit of data in a parameter tree. Each parameter has\n    a name, a type, a value, and several other properties that modify the behavior of the \n    Parameter. Parameters may have parent / child / sibling relationships to construct\n    organized hierarchies. Parameters generally do not have any inherent GUI or visual\n    interpretation; instead they manage ParameterItem instances which take care of\n    display and user interaction.\n    \n    Note: It is fairly uncommon to use the Parameter class directly; mostly you \n    will use subclasses which provide specialized type and data handling. The static\n    pethod Parameter.create(...) is an easy way to generate instances of these subclasses.\n       \n    For more Parameter types, see ParameterTree.parameterTypes module.\n    \n    ===================================  =========================================================\n    **Signals:**\n    sigStateChanged(self, change, info)  Emitted when anything changes about this parameter at \n                                         all.\n                                         The second argument is a string indicating what changed \n                                         (\'value\', \'childAdded\', etc..)\n                                         The third argument can be any extra information about \n                                         the change\n    sigTreeStateChanged(self, changes)   Emitted when any child in the tree changes state\n                                         (but only if monitorChildren() is called)\n                                         the format of *changes* is [(param, change, info), ...]\n    sigValueChanged(self, value)         Emitted when value is finished changing\n    sigValueChanging(self, value)        Emitted immediately for all value changes, \n                                         including during editing.\n    sigChildAdded(self, child, index)    Emitted when a child is added\n    sigChildRemoved(self, child)         Emitted when a child is removed\n    sigRemoved(self)                     Emitted when this parameter is removed\n    sigParentChanged(self, parent)       Emitted when this parameter\'s parent has changed\n    sigLimitsChanged(self, limits)       Emitted when this parameter\'s limits have changed\n    sigDefaultChanged(self, default)     Emitted when this parameter\'s default value has changed\n    sigNameChanged(self, name)           Emitted when this parameter\'s name has changed\n    sigOptionsChanged(self, opts)        Emitted when any of this parameter\'s options have changed\n    ===================================  =========================================================\n    """"""\n    ## name, type, limits, etc.\n    ## can also carry UI hints (slider vs spinbox, etc.)\n    \n    sigValueChanged = QtCore.Signal(object, object)  ## self, value   emitted when value is finished being edited\n    sigValueChanging = QtCore.Signal(object, object)  ## self, value  emitted as value is being edited\n    \n    sigChildAdded = QtCore.Signal(object, object, object)  ## self, child, index\n    sigChildRemoved = QtCore.Signal(object, object)  ## self, child\n    sigRemoved = QtCore.Signal(object) ## self\n    sigParentChanged = QtCore.Signal(object, object)  ## self, parent\n    sigLimitsChanged = QtCore.Signal(object, object)  ## self, limits\n    sigDefaultChanged = QtCore.Signal(object, object)  ## self, default\n    sigNameChanged = QtCore.Signal(object, object)  ## self, name\n    sigOptionsChanged = QtCore.Signal(object, object)  ## self, {opt:val, ...}\n    \n    ## Emitted when anything changes about this parameter at all.\n    ## The second argument is a string indicating what changed (\'value\', \'childAdded\', etc..)\n    ## The third argument can be any extra information about the change\n    sigStateChanged = QtCore.Signal(object, object, object) ## self, change, info\n    \n    ## emitted when any child in the tree changes state\n    ## (but only if monitorChildren() is called)\n    sigTreeStateChanged = QtCore.Signal(object, object)  # self, changes\n                                                         # changes = [(param, change, info), ...]\n    \n    # bad planning.\n    #def __new__(cls, *args, **opts):\n        #try:\n            #cls = PARAM_TYPES[opts[\'type\']]\n        #except KeyError:\n            #pass\n        #return QtCore.QObject.__new__(cls, *args, **opts)\n    \n    @staticmethod\n    def create(**opts):\n        """"""\n        Static method that creates a new Parameter (or subclass) instance using \n        opts[\'type\'] to select the appropriate class.\n        \n        All options are passed directly to the new Parameter\'s __init__ method.\n        Use registerParameterType() to add new class types.\n        """"""\n        typ = opts.get(\'type\', None)\n        if typ is None:\n            cls = Parameter\n        else:\n            cls = PARAM_TYPES[opts[\'type\']]\n        return cls(**opts)\n    \n    def __init__(self, **opts):\n        """"""\n        Initialize a Parameter object. Although it is rare to directly create a\n        Parameter instance, the options available to this method are also allowed\n        by most Parameter subclasses.\n        \n        =======================      =========================================================\n        **Keyword Arguments:**\n        name                         The name to give this Parameter. This is the name that\n                                     will appear in the left-most column of a ParameterTree\n                                     for this Parameter.\n        value                        The value to initially assign to this Parameter.\n        default                      The default value for this Parameter (most Parameters\n                                     provide an option to \'reset to default\').\n        children                     A list of children for this Parameter. Children\n                                     may be given either as a Parameter instance or as a\n                                     dictionary to pass to Parameter.create(). In this way,\n                                     it is possible to specify complex hierarchies of\n                                     Parameters from a single nested data structure.\n        readonly                     If True, the user will not be allowed to edit this\n                                     Parameter. (default=False)\n        enabled                      If False, any widget(s) for this parameter will appear\n                                     disabled. (default=True)\n        visible                      If False, the Parameter will not appear when displayed\n                                     in a ParameterTree. (default=True)\n        renamable                    If True, the user may rename this Parameter.\n                                     (default=False)\n        removable                    If True, the user may remove this Parameter.\n                                     (default=False)\n        expanded                     If True, the Parameter will appear expanded when\n                                     displayed in a ParameterTree (its children will be\n                                     visible). (default=True)\n        title                        (str or None) If specified, then the parameter will be \n                                     displayed to the user using this string as its name. \n                                     However, the parameter will still be referred to \n                                     internally using the *name* specified above. Note that\n                                     this option is not compatible with renamable=True.\n                                     (default=None; added in version 0.9.9)\n        =======================      =========================================================\n        """"""\n        \n        \n        QtCore.QObject.__init__(self)\n        \n        self.opts = {\n            \'type\': None,\n            \'readonly\': False,\n            \'visible\': True,\n            \'enabled\': True,\n            \'renamable\': False,\n            \'removable\': False,\n            \'strictNaming\': False,  # forces name to be usable as a python variable\n            \'expanded\': True,\n            \'title\': None,\n            #\'limits\': None,  ## This is a bad plan--each parameter type may have a different data type for limits.\n        }\n        value = opts.get(\'value\', None)\n        name = opts.get(\'name\', None)\n        self.opts.update(opts)\n        self.opts[\'value\'] = None  # will be set later.\n        self.opts[\'name\'] = None\n        \n        self.childs = []\n        self.names = {}   ## map name:child\n        self.items = weakref.WeakKeyDictionary()  ## keeps track of tree items representing this parameter\n        self._parent = None\n        self.treeStateChanges = []  ## cache of tree state changes to be delivered on next emit\n        self.blockTreeChangeEmit = 0\n        #self.monitoringChildren = False  ## prevent calling monitorChildren more than once\n        \n        if not isinstance(name, basestring):\n            raise Exception(""Parameter must have a string name specified in opts."")\n        self.setName(name)\n        \n        self.addChildren(self.opts.pop(\'children\', []))\n        \n        self.opts[\'value\'] = None\n        if value is not None:\n            self.setValue(value)\n\n        if \'default\' not in self.opts:\n            self.opts[\'default\'] = None\n            self.setDefault(self.opts[\'value\'])\n    \n        ## Connect all state changed signals to the general sigStateChanged\n        self.sigValueChanged.connect(lambda param, data: self.emitStateChanged(\'value\', data))\n        self.sigChildAdded.connect(lambda param, *data: self.emitStateChanged(\'childAdded\', data))\n        self.sigChildRemoved.connect(lambda param, data: self.emitStateChanged(\'childRemoved\', data))\n        self.sigParentChanged.connect(lambda param, data: self.emitStateChanged(\'parent\', data))\n        self.sigLimitsChanged.connect(lambda param, data: self.emitStateChanged(\'limits\', data))\n        self.sigDefaultChanged.connect(lambda param, data: self.emitStateChanged(\'default\', data))\n        self.sigNameChanged.connect(lambda param, data: self.emitStateChanged(\'name\', data))\n        self.sigOptionsChanged.connect(lambda param, data: self.emitStateChanged(\'options\', data))\n        \n        #self.watchParam(self)  ## emit treechange signals if our own state changes\n        \n    def name(self):\n        """"""Return the name of this Parameter.""""""\n        return self.opts[\'name\']\n\n    def setName(self, name):\n        """"""Attempt to change the name of this parameter; return the actual name. \n        (The parameter may reject the name change or automatically pick a different name)""""""\n        if self.opts[\'strictNaming\']:\n            if len(name) < 1 or re.search(r\'\\W\', name) or re.match(r\'\\d\', name[0]):\n                raise Exception(""Parameter name \'%s\' is invalid. (Must contain only alphanumeric and underscore characters and may not start with a number)"" % name)\n        parent = self.parent()\n        if parent is not None:\n            name = parent._renameChild(self, name)  ## first ask parent if it\'s ok to rename\n        if self.opts[\'name\'] != name:\n            self.opts[\'name\'] = name\n            self.sigNameChanged.emit(self, name)\n        return name\n\n    def type(self):\n        """"""Return the type string for this Parameter.""""""\n        return self.opts[\'type\']\n        \n    def isType(self, typ):\n        """"""\n        Return True if this parameter type matches the name *typ*.\n        This can occur either of two ways:\n        \n        - If self.type() == *typ*\n        - If this parameter\'s class is registered with the name *typ*\n        """"""\n        if self.type() == typ:\n            return True\n        global PARAM_TYPES\n        cls = PARAM_TYPES.get(typ, None)\n        if cls is None:\n            raise Exception(""Type name \'%s\' is not registered."" % str(typ))\n        return self.__class__ is cls\n        \n    def childPath(self, child):\n        """"""\n        Return the path of parameter names from self to child.\n        If child is not a (grand)child of self, return None.\n        """"""\n        path = []\n        while child is not self:\n            path.insert(0, child.name())\n            child = child.parent()\n            if child is None:\n                return None\n        return path\n\n    def setValue(self, value, blockSignal=None):\n        """"""\n        Set the value of this Parameter; return the actual value that was set.\n        (this may be different from the value that was requested)\n        """"""\n        try:\n            if blockSignal is not None:\n                self.sigValueChanged.disconnect(blockSignal)\n            value = self._interpretValue(value)\n            if self.opts[\'value\'] == value:\n                return value\n            self.opts[\'value\'] = value\n            self.sigValueChanged.emit(self, value)\n        finally:\n            if blockSignal is not None:\n                self.sigValueChanged.connect(blockSignal)\n            \n        return value\n\n    def _interpretValue(self, v):\n        return v\n\n    def value(self):\n        """"""\n        Return the value of this Parameter.\n        """"""\n        return self.opts[\'value\']\n\n    def getValues(self):\n        """"""Return a tree of all values that are children of this parameter""""""\n        vals = OrderedDict()\n        for ch in self:\n            vals[ch.name()] = (ch.value(), ch.getValues())\n        return vals\n    \n    def saveState(self, filter=None):\n        """"""\n        Return a structure representing the entire state of the parameter tree.\n        The tree state may be restored from this structure using restoreState().\n\n        If *filter* is set to \'user\', then only user-settable data will be included in the\n        returned state.\n        """"""\n        if filter is None:\n            state = self.opts.copy()\n            if state[\'type\'] is None:\n                global PARAM_NAMES\n                state[\'type\'] = PARAM_NAMES.get(type(self), None)\n        elif filter == \'user\':\n            state = {\'value\': self.value()}\n        else:\n            raise ValueError(""Unrecognized filter argument: \'%s\'"" % filter)\n\n        ch = OrderedDict([(ch.name(), ch.saveState(filter=filter)) for ch in self])\n        if len(ch) > 0:\n            state[\'children\'] = ch\n        return state\n\n    def restoreState(self, state, recursive=True, addChildren=True, removeChildren=True, blockSignals=True):\n        """"""\n        Restore the state of this parameter and its children from a structure generated using saveState()\n        If recursive is True, then attempt to restore the state of child parameters as well.\n        If addChildren is True, then any children which are referenced in the state object will be\n        created if they do not already exist.\n        If removeChildren is True, then any children which are not referenced in the state object will \n        be removed.\n        If blockSignals is True, no signals will be emitted until the tree has been completely restored. \n        This prevents signal handlers from responding to a partially-rebuilt network.\n        """"""\n        state = state.copy()\n        childState = state.pop(\'children\', [])\n        \n        ## list of children may be stored either as list or dict.\n        if isinstance(childState, dict):\n            cs = []\n            for k,v in childState.items():\n                cs.append(v.copy())\n                cs[-1].setdefault(\'name\', k)\n            childState = cs\n        \n        if blockSignals:\n            self.blockTreeChangeSignal()\n            \n        try:\n            self.setOpts(**state)\n            \n            if not recursive:\n                return\n            \n            ptr = 0  ## pointer to first child that has not been restored yet\n            foundChilds = set()\n            #print ""=============="", self.name()\n            \n            for ch in childState:\n                name = ch[\'name\']\n                #typ = ch.get(\'type\', None)\n                #print(\'child: %s, %s\' % (self.name()+\'.\'+name, typ))\n                \n                ## First, see if there is already a child with this name\n                gotChild = False\n                for i, ch2 in enumerate(self.childs[ptr:]):\n                    #print ""  "", ch2.name(), ch2.type()\n                    if ch2.name() != name: # or not ch2.isType(typ):\n                        continue\n                    gotChild = True\n                    #print ""    found it""\n                    if i != 0:  ## move parameter to next position\n                        #self.removeChild(ch2)\n                        self.insertChild(ptr, ch2)\n                        #print ""  moved to position"", ptr\n                    ch2.restoreState(ch, recursive=recursive, addChildren=addChildren, removeChildren=removeChildren)\n                    foundChilds.add(ch2)\n                    \n                    break\n                \n                if not gotChild:\n                    if not addChildren:\n                        #print ""  ignored child""\n                        continue\n                    #print ""    created new""\n                    ch2 = Parameter.create(**ch)\n                    self.insertChild(ptr, ch2)\n                    foundChilds.add(ch2)\n                    \n                ptr += 1\n                \n            if removeChildren:\n                for ch in self.childs[:]:\n                    if ch not in foundChilds:\n                        #print ""  remove:"", ch\n                        self.removeChild(ch)\n        finally:\n            if blockSignals:\n                self.unblockTreeChangeSignal()\n            \n            \n        \n    def defaultValue(self):\n        """"""Return the default value for this parameter.""""""\n        return self.opts[\'default\']\n        \n    def setDefault(self, val):\n        """"""Set the default value for this parameter.""""""\n        if self.opts[\'default\'] == val:\n            return\n        self.opts[\'default\'] = val\n        self.sigDefaultChanged.emit(self, val)\n\n    def setToDefault(self):\n        """"""Set this parameter\'s value to the default.""""""\n        if self.hasDefault():\n            self.setValue(self.defaultValue())\n\n    def hasDefault(self):\n        """"""Returns True if this parameter has a default value.""""""\n        return \'default\' in self.opts\n        \n    def valueIsDefault(self):\n        """"""Returns True if this parameter\'s value is equal to the default value.""""""\n        return self.value() == self.defaultValue()\n        \n    def setLimits(self, limits):\n        """"""Set limits on the acceptable values for this parameter. \n        The format of limits depends on the type of the parameter and\n        some parameters do not make use of limits at all.""""""\n        if \'limits\' in self.opts and self.opts[\'limits\'] == limits:\n            return\n        self.opts[\'limits\'] = limits\n        self.sigLimitsChanged.emit(self, limits)\n        return limits\n\n    def writable(self):\n        """"""\n        Returns True if this parameter\'s value can be changed by the user.\n        Note that the value of the parameter can *always* be changed by\n        calling setValue().\n        """"""\n        return not self.readonly()\n\n    def setWritable(self, writable=True):\n        """"""Set whether this Parameter should be editable by the user. (This is \n        exactly the opposite of setReadonly).""""""\n        self.setOpts(readonly=not writable)\n        \n    def readonly(self):\n        """"""\n        Return True if this parameter is read-only. (this is the opposite of writable())\n        """"""\n        return self.opts.get(\'readonly\', False)\n        \n    def setReadonly(self, readonly=True):\n        """"""Set whether this Parameter\'s value may be edited by the user\n        (this is the opposite of setWritable()).""""""\n        self.setOpts(readonly=readonly)\n        \n    def setOpts(self, **opts):\n        """"""\n        Set any arbitrary options on this parameter.\n        The exact behavior of this function will depend on the parameter type, but\n        most parameters will accept a common set of options: value, name, limits,\n        default, readonly, removable, renamable, visible, enabled, and expanded.\n        \n        See :func:`Parameter.__init__ <pyqtgraph.parametertree.Parameter.__init__>`\n        for more information on default options.\n        """"""\n        changed = OrderedDict()\n        for k in opts:\n            if k == \'value\':\n                self.setValue(opts[k])\n            elif k == \'name\':\n                self.setName(opts[k])\n            elif k == \'limits\':\n                self.setLimits(opts[k])\n            elif k == \'default\':\n                self.setDefault(opts[k])\n            elif k not in self.opts or self.opts[k] != opts[k]:\n                self.opts[k] = opts[k]\n                changed[k] = opts[k]\n                \n        if len(changed) > 0:\n            self.sigOptionsChanged.emit(self, changed)\n        \n    def emitStateChanged(self, changeDesc, data):\n        ## Emits stateChanged signal and \n        ## requests emission of new treeStateChanged signal\n        self.sigStateChanged.emit(self, changeDesc, data)\n        #self.treeStateChanged(self, changeDesc, data)\n        self.treeStateChanges.append((self, changeDesc, data))\n        self.emitTreeChanges()\n\n    def makeTreeItem(self, depth):\n        """"""\n        Return a TreeWidgetItem suitable for displaying/controlling the content of \n        this parameter. This is called automatically when a ParameterTree attempts\n        to display this Parameter.\n        Most subclasses will want to override this function.\n        """"""\n        if hasattr(self, \'itemClass\'):\n            #print ""Param:"", self, ""Make item from itemClass:"", self.itemClass\n            return self.itemClass(self, depth)\n        else:\n            return ParameterItem(self, depth=depth)\n\n\n    def addChild(self, child, autoIncrementName=None):\n        """"""\n        Add another parameter to the end of this parameter\'s child list.\n        \n        See insertChild() for a description of the *autoIncrementName* \n        argument.\n        """"""\n        return self.insertChild(len(self.childs), child, autoIncrementName=autoIncrementName)\n\n    def addChildren(self, children):\n        """"""\n        Add a list or dict of children to this parameter. This method calls\n        addChild once for each value in *children*.\n        """"""\n        ## If children was specified as dict, then assume keys are the names.\n        if isinstance(children, dict):\n            ch2 = []\n            for name, opts in children.items():\n                if isinstance(opts, dict) and \'name\' not in opts:\n                    opts = opts.copy()\n                    opts[\'name\'] = name\n                ch2.append(opts)\n            children = ch2\n        \n        for chOpts in children:\n            #print self, ""Add child:"", type(chOpts), id(chOpts)\n            self.addChild(chOpts)\n        \n        \n    def insertChild(self, pos, child, autoIncrementName=None):\n        """"""\n        Insert a new child at pos.\n        If pos is a Parameter, then insert at the position of that Parameter.\n        If child is a dict, then a parameter is constructed using\n        :func:`Parameter.create <pyqtgraph.parametertree.Parameter.create>`.\n        \n        By default, the child\'s \'autoIncrementName\' option determines whether\n        the name will be adjusted to avoid prior name collisions. This \n        behavior may be overridden by specifying the *autoIncrementName* \n        argument. This argument was added in version 0.9.9.\n        """"""\n        if isinstance(child, dict):\n            child = Parameter.create(**child)\n        \n        name = child.name()\n        if name in self.names and child is not self.names[name]:\n            if autoIncrementName is True or (autoIncrementName is None and child.opts.get(\'autoIncrementName\', False)):\n                name = self.incrementName(name)\n                child.setName(name)\n            else:\n                raise Exception(""Already have child named %s"" % str(name))\n        if isinstance(pos, Parameter):\n            pos = self.childs.index(pos)\n            \n        with self.treeChangeBlocker():\n            if child.parent() is not None:\n                child.remove()\n                \n            self.names[name] = child\n            self.childs.insert(pos, child)\n            \n            child.parentChanged(self)\n            self.sigChildAdded.emit(self, child, pos)\n            child.sigTreeStateChanged.connect(self.treeStateChanged)\n        return child\n        \n    def removeChild(self, child):\n        """"""Remove a child parameter.""""""\n        name = child.name()\n        if name not in self.names or self.names[name] is not child:\n            raise Exception(""Parameter %s is not my child; can\'t remove."" % str(child))\n        del self.names[name]\n        self.childs.pop(self.childs.index(child))\n        child.parentChanged(None)\n        self.sigChildRemoved.emit(self, child)\n        try:\n            child.sigTreeStateChanged.disconnect(self.treeStateChanged)\n        except (TypeError, RuntimeError):  ## already disconnected\n            pass\n\n    def clearChildren(self):\n        """"""Remove all child parameters.""""""\n        for ch in self.childs[:]:\n            self.removeChild(ch)\n\n    def children(self):  \n        """"""Return a list of this parameter\'s children.\n        Warning: this overrides QObject.children\n        """"""\n        return self.childs[:]\n    \n    def hasChildren(self):\n        """"""Return True if this Parameter has children.""""""\n        return len(self.childs) > 0\n\n    def parentChanged(self, parent):\n        """"""This method is called when the parameter\'s parent has changed.\n        It may be useful to extend this method in subclasses.""""""\n        self._parent = parent\n        self.sigParentChanged.emit(self, parent)\n        \n    def parent(self):\n        """"""Return the parent of this parameter.""""""\n        return self._parent\n        \n    def remove(self):\n        """"""Remove this parameter from its parent\'s child list""""""\n        parent = self.parent()\n        if parent is None:\n            raise Exception(""Cannot remove; no parent."")\n        parent.removeChild(self)\n        self.sigRemoved.emit(self)\n\n    def incrementName(self, name):\n        ## return an unused name by adding a number to the name given\n        base, num = re.match(\'(.*)(\\d*)\', name).groups()\n        numLen = len(num)\n        if numLen == 0:\n            num = 2\n            numLen = 1\n        else:\n            num = int(num)\n        while True:\n            newName = base + (""%%0%dd""%numLen) % num\n            if newName not in self.names:\n                return newName\n            num += 1\n\n    def __iter__(self):\n        for ch in self.childs:\n            yield ch\n\n    def __getitem__(self, names):\n        """"""Get the value of a child parameter. The name may also be a tuple giving\n        the path to a sub-parameter::\n        \n            value = param[(\'child\', \'grandchild\')]\n        """"""\n        if not isinstance(names, tuple):\n            names = (names,)\n        return self.param(*names).value()\n\n    def __setitem__(self, names, value):\n        """"""Set the value of a child parameter. The name may also be a tuple giving\n        the path to a sub-parameter::\n        \n            param[(\'child\', \'grandchild\')] = value\n        """"""\n        if isinstance(names, basestring):\n            names = (names,)\n        return self.param(*names).setValue(value)\n\n    def child(self, *names):\n        """"""Return a child parameter. \n        Accepts the name of the child or a tuple (path, to, child)\n\n        Added in version 0.9.9. Earlier versions used the \'param\' method, which is still\n        implemented for backward compatibility.\n        """"""\n        try:\n            param = self.names[names[0]]\n        except KeyError:\n            raise KeyError(""Parameter %s has no child named %s"" % (self.name(), names[0]))\n        \n        if len(names) > 1:\n            return param.child(*names[1:])\n        else:\n            return param\n\n    def param(self, *names):\n        # for backward compatibility.\n        return self.child(*names)\n\n    def __repr__(self):\n        return asUnicode(""<%s \'%s\' at 0x%x>"") % (self.__class__.__name__, self.name(), id(self))\n       \n    def __getattr__(self, attr):\n        ## Leaving this undocumented because I might like to remove it in the future..\n        #print type(self), attr\n        \n        if \'names\' not in self.__dict__:\n            raise AttributeError(attr)\n        if attr in self.names:\n            import traceback\n            traceback.print_stack()\n            print(""Warning: Use of Parameter.subParam is deprecated. Use Parameter.param(name) instead."")\n            return self.param(attr)\n        else:\n            raise AttributeError(attr)\n       \n    def _renameChild(self, child, name):\n        ## Only to be called from Parameter.rename\n        if name in self.names:\n            return child.name()\n        self.names[name] = child\n        del self.names[child.name()]\n        return name\n\n    def registerItem(self, item):\n        self.items[item] = None\n        \n    def hide(self):\n        """"""Hide this parameter. It and its children will no longer be visible in any ParameterTree\n        widgets it is connected to.""""""\n        self.show(False)\n        \n    def show(self, s=True):\n        """"""Show this parameter. """"""\n        self.opts[\'visible\'] = s\n        self.sigOptionsChanged.emit(self, {\'visible\': s})\n\n\n    def treeChangeBlocker(self):\n        """"""\n        Return an object that can be used to temporarily block and accumulate\n        sigTreeStateChanged signals. This is meant to be used when numerous changes are \n        about to be made to the tree and only one change signal should be\n        emitted at the end.\n        \n        Example::\n\n            with param.treeChangeBlocker():\n                param.addChild(...)\n                param.removeChild(...)\n                param.setValue(...)\n        """"""\n        return SignalBlocker(self.blockTreeChangeSignal, self.unblockTreeChangeSignal)\n\n    def blockTreeChangeSignal(self):\n        """"""\n        Used to temporarily block and accumulate tree change signals.\n        *You must remember to unblock*, so it is advisable to use treeChangeBlocker() instead.\n        """"""\n        self.blockTreeChangeEmit += 1\n\n    def unblockTreeChangeSignal(self):\n        """"""Unblocks enission of sigTreeStateChanged and flushes the changes out through a single signal.""""""\n        self.blockTreeChangeEmit -= 1\n        self.emitTreeChanges()\n        \n        \n    def treeStateChanged(self, param, changes):\n        """"""\n        Called when the state of any sub-parameter has changed. \n        \n        ==============  ================================================================\n        **Arguments:**\n        param           The immediate child whose tree state has changed.\n                        note that the change may have originated from a grandchild.\n        changes         List of tuples describing all changes that have been made\n                        in this event: (param, changeDescr, data)\n        ==============  ================================================================\n                     \n        This function can be extended to react to tree state changes.\n        """"""\n        self.treeStateChanges.extend(changes)\n        self.emitTreeChanges()\n    \n    def emitTreeChanges(self):\n        if self.blockTreeChangeEmit == 0:\n            changes = self.treeStateChanges\n            self.treeStateChanges = []\n            if len(changes) > 0:\n                self.sigTreeStateChanged.emit(self, changes)\n\n\nclass SignalBlocker(object):\n    def __init__(self, enterFn, exitFn):\n        self.enterFn = enterFn\n        self.exitFn = exitFn\n        \n    def __enter__(self):\n        self.enterFn()\n        \n    def __exit__(self, exc_type, exc_value, tb):\n        self.exitFn()\n    \n    \n    \n'"
src/third_party/pyqtgraph/parametertree/ParameterItem.py,0,"b'from ..Qt import QtGui, QtCore\nfrom ..python2_3 import asUnicode\nimport os, weakref, re\n\nclass ParameterItem(QtGui.QTreeWidgetItem):\n    """"""\n    Abstract ParameterTree item. \n    Used to represent the state of a Parameter from within a ParameterTree.\n    \n    - Sets first column of item to name\n    - generates context menu if item is renamable or removable\n    - handles child added / removed events\n    - provides virtual functions for handling changes from parameter\n    \n    For more ParameterItem types, see ParameterTree.parameterTypes module.\n    """"""\n    \n    def __init__(self, param, depth=0):\n        title = param.opts.get(\'title\', None)\n        if title is None:\n            title = param.name()\n        QtGui.QTreeWidgetItem.__init__(self, [title, \'\'])\n\n        self.param = param\n        self.param.registerItem(self)  ## let parameter know this item is connected to it (for debugging)\n        self.depth = depth\n        \n        param.sigValueChanged.connect(self.valueChanged)\n        param.sigChildAdded.connect(self.childAdded)\n        param.sigChildRemoved.connect(self.childRemoved)\n        param.sigNameChanged.connect(self.nameChanged)\n        param.sigLimitsChanged.connect(self.limitsChanged)\n        param.sigDefaultChanged.connect(self.defaultChanged)\n        param.sigOptionsChanged.connect(self.optsChanged)\n        param.sigParentChanged.connect(self.parentChanged)\n        \n        opts = param.opts\n        \n        ## Generate context menu for renaming/removing parameter\n        self.contextMenu = QtGui.QMenu()\n        self.contextMenu.addSeparator()\n        flags = QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled\n        if opts.get(\'renamable\', False):\n            if param.opts.get(\'title\', None) is not None:\n                raise Exception(""Cannot make parameter with both title != None and renamable == True."")\n            flags |= QtCore.Qt.ItemIsEditable\n            self.contextMenu.addAction(\'Rename\').triggered.connect(self.editName)\n        if opts.get(\'removable\', False):\n            self.contextMenu.addAction(""Remove"").triggered.connect(self.requestRemove)\n        \n        ## handle movable / dropEnabled options\n        if opts.get(\'movable\', False):\n            flags |= QtCore.Qt.ItemIsDragEnabled\n        if opts.get(\'dropEnabled\', False):\n            flags |= QtCore.Qt.ItemIsDropEnabled\n        self.setFlags(flags)\n        \n        ## flag used internally during name editing\n        self.ignoreNameColumnChange = False\n    \n    \n    def valueChanged(self, param, val):\n        ## called when the parameter\'s value has changed\n        pass\n    \n    def isFocusable(self):\n        """"""Return True if this item should be included in the tab-focus order""""""\n        return False\n        \n    def setFocus(self):\n        """"""Give input focus to this item.\n        Can be reimplemented to display editor widgets, etc.\n        """"""\n        pass\n    \n    def focusNext(self, forward=True):\n        """"""Give focus to the next (or previous) focusable item in the parameter tree""""""\n        self.treeWidget().focusNext(self, forward=forward)\n        \n    \n    def treeWidgetChanged(self):\n        """"""Called when this item is added or removed from a tree.\n        Expansion, visibility, and column widgets must all be configured AFTER \n        the item is added to a tree, not during __init__.\n        """"""\n        self.setHidden(not self.param.opts.get(\'visible\', True))\n        self.setExpanded(self.param.opts.get(\'expanded\', True))\n        \n    def childAdded(self, param, child, pos):\n        item = child.makeTreeItem(depth=self.depth+1)\n        self.insertChild(pos, item)\n        item.treeWidgetChanged()\n        \n        for i, ch in enumerate(child):\n            item.childAdded(child, ch, i)\n        \n    def childRemoved(self, param, child):\n        for i in range(self.childCount()):\n            item = self.child(i)\n            if item.param is child:\n                self.takeChild(i)\n                break\n                \n    def parentChanged(self, param, parent):\n        ## called when the parameter\'s parent has changed.\n        pass\n                \n    def contextMenuEvent(self, ev):\n        if not self.param.opts.get(\'removable\', False) and not self.param.opts.get(\'renamable\', False):\n            return\n            \n        self.contextMenu.popup(ev.globalPos())\n        \n    def columnChangedEvent(self, col):\n        """"""Called when the text in a column has been edited (or otherwise changed).\n        By default, we only use changes to column 0 to rename the parameter.\n        """"""\n        if col == 0  and (self.param.opts.get(\'title\', None) is None):\n            if self.ignoreNameColumnChange:\n                return\n            try:\n                newName = self.param.setName(asUnicode(self.text(col)))\n            except Exception:\n                self.setText(0, self.param.name())\n                raise\n                \n            try:\n                self.ignoreNameColumnChange = True\n                self.nameChanged(self, newName)  ## If the parameter rejects the name change, we need to set it back.\n            finally:\n                self.ignoreNameColumnChange = False\n                \n    def nameChanged(self, param, name):\n        ## called when the parameter\'s name has changed.\n        if self.param.opts.get(\'title\', None) is None:\n            self.setText(0, name)\n    \n    def limitsChanged(self, param, limits):\n        """"""Called when the parameter\'s limits have changed""""""\n        pass\n    \n    def defaultChanged(self, param, default):\n        """"""Called when the parameter\'s default value has changed""""""\n        pass\n\n    def optsChanged(self, param, opts):\n        """"""Called when any options are changed that are not\n        name, value, default, or limits""""""\n        #print opts\n        if \'visible\' in opts:\n            self.setHidden(not opts[\'visible\'])\n        \n    def editName(self):\n        self.treeWidget().editItem(self, 0)\n        \n    def selected(self, sel):\n        """"""Called when this item has been selected (sel=True) OR deselected (sel=False)""""""\n        pass\n\n    def requestRemove(self):\n        ## called when remove is selected from the context menu.\n        ## we need to delay removal until the action is complete\n        ## since destroying the menu in mid-action will cause a crash.\n        QtCore.QTimer.singleShot(0, self.param.remove)\n\n    ## for python 3 support, we need to redefine hash and eq methods.\n    def __hash__(self):\n        return id(self)\n\n    def __eq__(self, x):\n        return x is self\n'"
src/third_party/pyqtgraph/parametertree/ParameterSystem.py,0,"b'from .parameterTypes import GroupParameter\nfrom .. import functions as fn\nfrom .SystemSolver import SystemSolver\n\n\nclass ParameterSystem(GroupParameter):\n    """"""\n    ParameterSystem is a subclass of GroupParameter that manages a tree of \n    sub-parameters with a set of interdependencies--changing any one parameter\n    may affect other parameters in the system.\n    \n    See parametertree/SystemSolver for more information.\n    \n    NOTE: This API is experimental and may change substantially across minor \n    version numbers. \n    """"""\n    def __init__(self, *args, **kwds):\n        GroupParameter.__init__(self, *args, **kwds)\n        self._system = None\n        self._fixParams = []  # all auto-generated \'fixed\' params\n        sys = kwds.pop(\'system\', None)\n        if sys is not None:\n            self.setSystem(sys)\n        self._ignoreChange = [] # params whose changes should be ignored temporarily\n        self.sigTreeStateChanged.connect(self.updateSystem)\n        \n    def setSystem(self, sys):\n        self._system = sys\n        \n        # auto-generate defaults to match child parameters\n        defaults = {}\n        vals = {}\n        for param in self:\n            name = param.name()\n            constraints = \'\'\n            if hasattr(sys, \'_\' + name):\n                constraints += \'n\'\n                \n            if not param.readonly():\n                constraints += \'f\'\n                if \'n\' in constraints:\n                    ch = param.addChild(dict(name=\'fixed\', type=\'bool\', value=False))\n                    self._fixParams.append(ch)\n                    param.setReadonly(True)\n                    param.setOpts(expanded=False)\n                else:\n                    vals[name] = param.value()\n                    ch = param.addChild(dict(name=\'fixed\', type=\'bool\', value=True, readonly=True))\n                    #self._fixParams.append(ch)\n                \n            defaults[name] = [None, param.type(), None, constraints]\n        \n        sys.defaultState.update(defaults)\n        sys.reset()\n        for name, value in vals.items():\n            setattr(sys, name, value)\n        \n        self.updateAllParams()\n    \n    def updateSystem(self, param, changes):\n        changes = [ch for ch in changes if ch[0] not in self._ignoreChange]\n        \n        #resets = [ch[0] for ch in changes if ch[1] == \'setToDefault\']\n        sets = [ch[0] for ch in changes if ch[1] == \'value\']\n        #for param in resets:\n            #setattr(self._system, param.name(), None)\n\n        for param in sets:\n            #if param in resets:\n                #continue\n            \n            #if param in self._fixParams:\n                #param.parent().setWritable(param.value())\n            #else:\n            if param in self._fixParams:\n                parent = param.parent()\n                if param.value():\n                    setattr(self._system, parent.name(), parent.value())\n                else:\n                    setattr(self._system, parent.name(), None)\n            else:\n                setattr(self._system, param.name(), param.value())\n            \n        self.updateAllParams()\n    \n    def updateAllParams(self):\n        try:\n            self.sigTreeStateChanged.disconnect(self.updateSystem)\n            for name, state in self._system._vars.items():\n                param = self.child(name)\n                try:\n                    v = getattr(self._system, name)\n                    if self._system._vars[name][2] is None:\n                        self.updateParamState(self.child(name), \'autoSet\')\n                        param.setValue(v)\n                    else:\n                        self.updateParamState(self.child(name), \'fixed\')\n                except RuntimeError:\n                    self.updateParamState(param, \'autoUnset\')\n        finally:\n            self.sigTreeStateChanged.connect(self.updateSystem)\n                \n    def updateParamState(self, param, state):\n        if state == \'autoSet\':\n            bg = fn.mkBrush((200, 255, 200, 255))\n            bold = False\n            readonly = True\n        elif state == \'autoUnset\':\n            bg = fn.mkBrush(None)\n            bold = False\n            readonly = False\n        elif state == \'fixed\':\n            bg = fn.mkBrush(\'y\')\n            bold = True\n            readonly = False\n            \n        param.setReadonly(readonly)\n        \n        #for item in param.items:\n            #item.setBackground(0, bg)\n            #f = item.font(0)\n            #f.setWeight(f.Bold if bold else f.Normal)\n            #item.setFont(0, f)\n            \n            \n            \n\n'"
src/third_party/pyqtgraph/parametertree/ParameterTree.py,0,"b'from ..Qt import QtCore, QtGui\nfrom ..widgets.TreeWidget import TreeWidget\nimport os, weakref, re\nfrom .ParameterItem import ParameterItem\n#import functions as fn\n        \n            \n\nclass ParameterTree(TreeWidget):\n    """"""Widget used to display or control data from a hierarchy of Parameters""""""\n    \n    def __init__(self, parent=None, showHeader=True):\n        """"""\n        ============== ========================================================\n        **Arguments:**\n        parent         (QWidget) An optional parent widget\n        showHeader     (bool) If True, then the QTreeView header is displayed.\n        ============== ========================================================\n        """"""\n        TreeWidget.__init__(self, parent)\n        self.setVerticalScrollMode(self.ScrollPerPixel)\n        self.setHorizontalScrollMode(self.ScrollPerPixel)\n        self.setAnimated(False)\n        self.setColumnCount(2)\n        self.setHeaderLabels([""Parameter"", ""Value""])\n        self.setAlternatingRowColors(True)\n        self.paramSet = None\n        self.header().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n        self.setHeaderHidden(not showHeader)\n        self.itemChanged.connect(self.itemChangedEvent)\n        self.lastSel = None\n        self.setRootIsDecorated(False)\n        \n    def setParameters(self, param, showTop=True):\n        """"""\n        Set the top-level :class:`Parameter <pyqtgraph.parametertree.Parameter>`\n        to be displayed in this ParameterTree.\n\n        If *showTop* is False, then the top-level parameter is hidden and only \n        its children will be visible. This is a convenience method equivalent \n        to::\n        \n            tree.clear()\n            tree.addParameters(param, showTop)\n        """"""\n        self.clear()\n        self.addParameters(param, showTop=showTop)\n        \n    def addParameters(self, param, root=None, depth=0, showTop=True):\n        """"""\n        Adds one top-level :class:`Parameter <pyqtgraph.parametertree.Parameter>`\n        to the view. \n        \n        ============== ==========================================================\n        **Arguments:** \n        param          The :class:`Parameter <pyqtgraph.parametertree.Parameter>` \n                       to add.\n        root           The item within the tree to which *param* should be added.\n                       By default, *param* is added as a top-level item.\n        showTop        If False, then *param* will be hidden, and only its \n                       children will be visible in the tree.\n        ============== ==========================================================\n        """"""\n        item = param.makeTreeItem(depth=depth)\n        if root is None:\n            root = self.invisibleRootItem()\n            ## Hide top-level item\n            if not showTop:\n                item.setText(0, \'\')\n                item.setSizeHint(0, QtCore.QSize(1,1))\n                item.setSizeHint(1, QtCore.QSize(1,1))\n                depth -= 1\n        root.addChild(item)\n        item.treeWidgetChanged()\n            \n        for ch in param:\n            self.addParameters(ch, root=item, depth=depth+1)\n\n    def clear(self):\n        """"""\n        Remove all parameters from the tree.        \n        """"""\n        self.invisibleRootItem().takeChildren()        \n            \n    def focusNext(self, item, forward=True):\n        """"""Give input focus to the next (or previous) item after *item*\n        """"""\n        while True:\n            parent = item.parent()\n            if parent is None:\n                return\n            nextItem = self.nextFocusableChild(parent, item, forward=forward)\n            if nextItem is not None:\n                nextItem.setFocus()\n                self.setCurrentItem(nextItem)\n                return\n            item = parent\n\n    def focusPrevious(self, item):\n        self.focusNext(item, forward=False)\n\n    def nextFocusableChild(self, root, startItem=None, forward=True):\n        if startItem is None:\n            if forward:\n                index = 0\n            else:\n                index = root.childCount()-1\n        else:\n            if forward:\n                index = root.indexOfChild(startItem) + 1\n            else:\n                index = root.indexOfChild(startItem) - 1\n            \n        if forward:\n            inds = list(range(index, root.childCount()))\n        else:\n            inds = list(range(index, -1, -1))\n            \n        for i in inds:\n            item = root.child(i)\n            if hasattr(item, \'isFocusable\') and item.isFocusable():\n                return item\n            else:\n                item = self.nextFocusableChild(item, forward=forward)\n                if item is not None:\n                    return item\n        return None\n\n    def contextMenuEvent(self, ev):\n        item = self.currentItem()\n        if hasattr(item, \'contextMenuEvent\'):\n            item.contextMenuEvent(ev)\n            \n    def itemChangedEvent(self, item, col):\n        if hasattr(item, \'columnChangedEvent\'):\n            item.columnChangedEvent(col)\n            \n    def selectionChanged(self, *args):\n        sel = self.selectedItems()\n        if len(sel) != 1:\n            sel = None\n        if self.lastSel is not None and isinstance(self.lastSel, ParameterItem):\n            self.lastSel.selected(False)\n        if sel is None:\n            self.lastSel = None\n            return\n        self.lastSel = sel[0]\n        if hasattr(sel[0], \'selected\'):\n            sel[0].selected(True)\n        return TreeWidget.selectionChanged(self, *args)\n        \n    def wheelEvent(self, ev):\n        self.clearSelection()\n        return TreeWidget.wheelEvent(self, ev)\n'"
src/third_party/pyqtgraph/parametertree/SystemSolver.py,6,"b'from ..pgcollections import OrderedDict\nimport numpy as np\nimport copy\n\n\nclass SystemSolver(object):\n    """"""\n    This abstract class is used to formalize and manage user interaction with a \n    complex system of equations (related to ""constraint satisfaction problems"").\n    It is often the case that devices must be controlled\n    through a large number of free variables, and interactions between these \n    variables make the system difficult to manage and conceptualize as a user\n    interface. This class does _not_ attempt to numerically solve the system\n    of equations. Rather, it provides a framework for subdividing the system\n    into manageable pieces and specifying closed-form solutions to these small \n    pieces.\n    \n    For an example, see the simple Camera class below.\n    \n    Theory of operation: Conceptualize the system as 1) a set of variables\n    whose values may be either user-specified or automatically generated, and \n    2) a set of functions that define *how* each variable should be generated. \n    When a variable is accessed (as an instance attribute), the solver first\n    checks to see if it already has a value (either user-supplied, or cached\n    from a previous calculation). If it does not, then the solver calls a \n    method on itself (the method must be named `_variableName`) that will\n    either return the calculated value (which usually involves acccessing\n    other variables in the system), or raise RuntimeError if it is unable to\n    calculate the value (usually because the user has not provided sufficient\n    input to fully constrain the system). \n    \n    Each method that calculates a variable value may include multiple \n    try/except blocks, so that if one method generates a RuntimeError, it may \n    fall back on others. \n    In this way, the system may be solved by recursively searching the tree of \n    possible relationships between variables. This allows the user flexibility\n    in deciding which variables are the most important to specify, while \n    avoiding the apparent combinatorial explosion of calculation pathways\n    that must be considered by the developer.\n    \n    Solved values are cached for efficiency, and automatically cleared when \n    a state change invalidates the cache. The rules for this are simple: any\n    time a value is set, it invalidates the cache *unless* the previous value\n    was None (which indicates that no other variable has yet requested that \n    value). More complex cache management may be defined in subclasses.\n    \n    \n    Subclasses must define:\n    \n    1) The *defaultState* class attribute: This is a dict containing a \n       description of the variables in the system--their default values,\n       data types, and the ways they can be constrained. The format is::\n       \n           { name: [value, type, constraint, allowed_constraints], ...}\n       \n       * *value* is the default value. May be None if it has not been specified\n         yet.\n       * *type* may be float, int, bool, np.ndarray, ...\n       * *constraint* may be None, single value, or (min, max)\n            * None indicates that the value is not constrained--it may be \n              automatically generated if the value is requested.\n       * *allowed_constraints* is a string composed of (n)one, (f)ixed, and (r)ange. \n       \n       Note: do not put mutable objects inside defaultState!\n       \n    2) For each variable that may be automatically determined, a method must \n       be defined with the name `_variableName`. This method may either return\n       the \n    """"""\n\n    defaultState = OrderedDict()\n\n    def __init__(self):\n        self.__dict__[\'_vars\'] = OrderedDict()\n        self.__dict__[\'_currentGets\'] = set()\n        self.reset()\n        \n    def copy(self):\n        sys = type(self)()\n        sys.__dict__[\'_vars\'] = copy.deepcopy(self.__dict__[\'_vars\'])\n        sys.__dict__[\'_currentGets\'] = copy.deepcopy(self.__dict__[\'_currentGets\'])\n        return sys\n\n    def reset(self):\n        """"""\n        Reset all variables in the solver to their default state.\n        """"""\n        self._currentGets.clear()\n        for k in self.defaultState:\n            self._vars[k] = self.defaultState[k][:]\n\n    def __getattr__(self, name):\n        if name in self._vars:\n            return self.get(name)\n        raise AttributeError(name)\n    \n    def __setattr__(self, name, value):\n        """"""\n        Set the value of a state variable. \n        If None is given for the value, then the constraint will also be set to None.\n        If a tuple is given for a scalar variable, then the tuple is used as a range constraint instead of a value.\n        Otherwise, the constraint is set to \'fixed\'.\n        \n        """"""\n        # First check this is a valid attribute\n        if name in self._vars:\n            if value is None:\n                self.set(name, value, None)\n            elif isinstance(value, tuple) and self._vars[name][1] is not np.ndarray:\n                self.set(name, None, value)\n            else:\n                self.set(name, value, \'fixed\')\n        else:\n            # also allow setting any other pre-existing attribute\n            if hasattr(self, name):\n                object.__setattr__(self, name, value)\n            else:\n                raise AttributeError(name)\n        \n    def get(self, name):\n        """"""\n        Return the value for parameter *name*. \n        \n        If the value has not been specified, then attempt to compute it from\n        other interacting parameters.\n        \n        If no value can be determined, then raise RuntimeError.\n        """"""\n        if name in self._currentGets:\n                raise RuntimeError(""Cyclic dependency while calculating \'%s\'."" % name)\n        self._currentGets.add(name)\n        try:\n            v = self._vars[name][0]\n            if v is None:\n                cfunc = getattr(self, \'_\' + name, None)\n                if cfunc is None:\n                    v = None\n                else:\n                    v = cfunc()\n                if v is None:\n                    raise RuntimeError(""Parameter \'%s\' is not specified."" % name)\n                v = self.set(name, v)\n        finally:\n            self._currentGets.remove(name)\n        \n        return v\n    \n    def set(self, name, value=None, constraint=True):\n        """"""\n        Set a variable *name* to *value*. The actual set value is returned (in\n        some cases, the value may be cast into another type).\n        \n        If *value* is None, then the value is left to be determined in the \n        future. At any time, the value may be re-assigned arbitrarily unless\n        a constraint is given.\n        \n        If *constraint* is True (the default), then supplying a value that \n        violates a previously specified constraint will raise an exception.\n        \n        If *constraint* is \'fixed\', then the value is set (if provided) and\n        the variable will not be updated automatically in the future.\n\n        If *constraint* is a tuple, then the value is constrained to be within the \n        given (min, max). Either constraint may be None to disable \n        it. In some cases, a constraint cannot be satisfied automatically,\n        and the user will be forced to resolve the constraint manually.\n        \n        If *constraint* is None, then any constraints are removed for the variable.\n        """"""\n        var = self._vars[name]\n        if constraint is None:\n            if \'n\' not in var[3]:\n                raise TypeError(""Empty constraints not allowed for \'%s\'"" % name)\n            var[2] = constraint\n        elif constraint == \'fixed\':\n            if \'f\' not in var[3]:\n                raise TypeError(""Fixed constraints not allowed for \'%s\'"" % name)\n            # This is nice, but not reliable because sometimes there is 1 DOF but we set 2\n            # values simultaneously. \n            # if var[2] is None:\n            #     try:\n            #         self.get(name)\n            #         # has already been computed by the system; adding a fixed constraint\n            #         # would overspecify the system.\n            #         raise ValueError(""Cannot fix parameter \'%s\'; system would become overconstrained."" % name)\n            #     except RuntimeError:\n            #         pass\n            var[2] = constraint\n        elif isinstance(constraint, tuple):\n            if \'r\' not in var[3]:\n                raise TypeError(""Range constraints not allowed for \'%s\'"" % name)\n            assert len(constraint) == 2\n            var[2] = constraint\n        elif constraint is not True:\n            raise TypeError(""constraint must be None, True, \'fixed\', or tuple. (got %s)"" % constraint)\n        \n        # type checking / massaging\n        if var[1] is np.ndarray and value is not None:\n            value = np.array(value, dtype=float)\n        elif var[1] in (int, float, tuple) and value is not None:\n            value = var[1](value)\n            \n        # constraint checks\n        if constraint is True and not self.check_constraint(name, value):\n            raise ValueError(""Setting %s = %s violates constraint %s"" % (name, value, var[2]))\n\n        # invalidate other dependent values\n        if var[0] is not None or value is None:\n            # todo: we can make this more clever..(and might need to) \n            # we just know that a value of None cannot have dependencies\n            # (because if anyone else had asked for this value, it wouldn\'t be \n            # None anymore)\n            self.resetUnfixed()\n            \n        var[0] = value\n        return value\n    \n    def check_constraint(self, name, value):\n        c = self._vars[name][2]\n        if c is None or value is None:\n            return True\n        if isinstance(c, tuple):\n            return ((c[0] is None or c[0] <= value) and\n                    (c[1] is None or c[1] >= value))\n        else:\n            return value == c\n    \n    def saveState(self):\n        """"""\n        Return a serializable description of the solver\'s current state.\n        """"""\n        state = OrderedDict()\n        for name, var in self._vars.items():\n            state[name] = (var[0], var[2])\n        return state\n    \n    def restoreState(self, state):\n        """"""\n        Restore the state of all values and constraints in the solver.\n        """"""\n        self.reset()\n        for name, var in state.items():\n            self.set(name, var[0], var[1])\n    \n    def resetUnfixed(self):\n        """"""\n        For any variable that does not have a fixed value, reset\n        its value to None.\n        """"""\n        for var in self._vars.values():\n            if var[2] != \'fixed\':\n                var[0] = None\n                \n    def solve(self):\n        for k in self._vars:\n            getattr(self, k)\n                \n    def checkOverconstraint(self):\n        """"""Check whether the system is overconstrained. If so, return the name of\n        the first overconstrained parameter.\n\n        Overconstraints occur when any fixed parameter can be successfully computed by the system.\n        (Ideally, all parameters are either fixed by the user or constrained by the\n        system, but never both).\n        """"""\n        for k,v in self._vars.items():\n            if v[2] == \'fixed\' and \'n\' in v[3]:\n                oldval = v[:]\n                self.set(k, None, None)\n                try:\n                    self.get(k)\n                    return k\n                except RuntimeError:\n                    pass\n                finally:\n                    self._vars[k] = oldval\n\n        return False\n\n\n\n\n    def __repr__(self):\n        state = OrderedDict()\n        for name, var in self._vars.items():\n            if var[2] == \'fixed\':\n                state[name] = var[0]\n        state = \', \'.join([""%s=%s"" % (n, v) for n,v in state.items()])\n        return ""<%s %s>"" % (self.__class__.__name__, state)\n\n\n\n\n\nif __name__ == \'__main__\':\n    \n    class Camera(SystemSolver):\n        """"""\n        Consider a simple SLR camera. The variables we will consider that \n        affect the camera\'s behavior while acquiring a photo are aperture, shutter speed,\n        ISO, and flash (of course there are many more, but let\'s keep the example simple).\n\n        In rare cases, the user wants to manually specify each of these variables and\n        no more work needs to be done to take the photo. More often, the user wants to\n        specify more interesting constraints like depth of field, overall exposure, \n        or maximum allowed ISO value.\n\n        If we add a simple light meter measurement into this system and an \'exposure\'\n        variable that indicates the desired exposure (0 is ""perfect"", -1 is one stop \n        darker, etc), then the system of equations governing the camera behavior would\n        have the following variables:\n\n            aperture, shutter, iso, flash, exposure, light meter\n\n        The first four variables are the ""outputs"" of the system (they directly drive \n        the camera), the last is a constant (the camera itself cannot affect the \n        reading on the light meter), and \'exposure\' specifies a desired relationship \n        between other variables in the system.\n\n        So the question is: how can I formalize a system like this as a user interface?\n        Typical cameras have a fairly limited approach: provide the user with a list\n        of modes, each of which defines a particular set of constraints. For example:\n\n            manual: user provides aperture, shutter, iso, and flash\n            aperture priority: user provides aperture and exposure, camera selects\n                            iso, shutter, and flash automatically\n            shutter priority: user provides shutter and exposure, camera selects\n                            iso, aperture, and flash\n            program: user specifies exposure, camera selects all other variables\n                    automatically\n            action: camera selects all variables while attempting to maximize \n                    shutter speed\n            portrait: camera selects all variables while attempting to minimize \n                    aperture\n\n        A more general approach might allow the user to provide more explicit \n        constraints on each variable (for example: I want a shutter speed of 1/30 or \n        slower, an ISO no greater than 400, an exposure between -1 and 1, and the \n        smallest aperture possible given all other constraints) and have the camera \n        solve the system of equations, with a warning if no solution is found. This\n        is exactly what we will implement in this example class.\n        """"""\n\n        defaultState = OrderedDict([\n            # Field stop aperture\n            (\'aperture\', [None, float, None, \'nf\']),\n            # Duration that shutter is held open. \n            (\'shutter\', [None, float, None, \'nf\']),\n            # ISO (sensitivity) value. 100, 200, 400, 800, 1600.. \n            (\'iso\', [None, int, None, \'nf\']),\n            \n            # Flash is a value indicating the brightness of the flash. A table\n            # is used to decide on ""balanced"" settings for each flash level:\n            #   0: no flash\n            #   1: s=1/60,  a=2.0, iso=100\n            #   2: s=1/60,  a=4.0, iso=100   ..and so on..\n            (\'flash\', [None, float, None, \'nf\']),\n            \n            # exposure is a value indicating how many stops brighter (+1) or\n            # darker (-1) the photographer would like the photo to appear from\n            # the \'balanced\' settings indicated by the light meter (see below).\n            (\'exposure\', [None, float, None, \'f\']),\n            \n            # Let\'s define this as an external light meter (not affected by \n            # aperture) with logarithmic output. We arbitrarily choose the\n            # following settings as ""well balanced"" for each light meter value:\n            #   -1: s=1/60,  a=2.0, iso=100\n            #    0: s=1/60,  a=4.0, iso=100\n            #    1: s=1/120, a=4.0, iso=100    ..and so on..\n            # Note that the only allowed constraint mode is (f)ixed, since the\n            # camera never _computes_ the light meter value, it only reads it.\n            (\'lightMeter\', [None, float, None, \'f\']),  \n            \n            # Indicates the camera\'s final decision on how it thinks the photo will \n            # look, given the chosen settings. This value is _only_ determined\n            # automatically.\n            (\'balance\', [None, float, None, \'n\']),\n            ])\n        \n        def _aperture(self):\n            """"""\n            Determine aperture automatically under a variety of conditions.\n            """"""\n            iso = self.iso\n            exp = self.exposure\n            light = self.lightMeter\n            \n            try:\n                # shutter-priority mode\n                sh = self.shutter   # this raises RuntimeError if shutter has not\n                                   # been specified\n                ap = 4.0 * (sh / (1./60.)) * (iso / 100.) * (2 ** exp) * (2 ** light)\n                ap = np.clip(ap, 2.0, 16.0)\n            except RuntimeError:\n                # program mode; we can select a suitable shutter\n                # value at the same time.\n                sh = (1./60.)\n                raise\n            \n            \n            \n            return ap\n\n        def _balance(self):\n            iso = self.iso\n            light = self.lightMeter\n            sh = self.shutter\n            ap = self.aperture\n            fl = self.flash\n            \n            bal = (4.0 / ap) * (sh / (1./60.)) * (iso / 100.) * (2 ** light)\n            return np.log2(bal)\n    \n    camera = Camera()\n    \n    camera.iso = 100\n    camera.exposure = 0\n    camera.lightMeter = 2\n    camera.shutter = 1./60.\n    camera.flash = 0\n    \n    camera.solve()\n    print(camera.saveState())\n    \n'"
src/third_party/pyqtgraph/parametertree/__init__.py,0,"b'from .Parameter import Parameter, registerParameterType\nfrom .ParameterTree import ParameterTree\nfrom .ParameterItem import ParameterItem\nfrom .ParameterSystem import ParameterSystem, SystemSolver\nfrom . import parameterTypes as types'"
src/third_party/pyqtgraph/parametertree/parameterTypes.py,0,"b'from ..Qt import QtCore, QtGui\nfrom ..python2_3 import asUnicode\nfrom .Parameter import Parameter, registerParameterType\nfrom .ParameterItem import ParameterItem\nfrom ..widgets.SpinBox import SpinBox\nfrom ..widgets.ColorButton import ColorButton\nfrom ..colormap import ColorMap\n#from ..widgets.GradientWidget import GradientWidget ## creates import loop\nfrom .. import pixmaps as pixmaps\nfrom .. import functions as fn\nimport os, sys\nfrom ..pgcollections import OrderedDict\n\nclass WidgetParameterItem(ParameterItem):\n    """"""\n    ParameterTree item with:\n    \n    * label in second column for displaying value\n    * simple widget for editing value (displayed instead of label when item is selected)\n    * button that resets value to default\n    \n    ==========================  =============================================================\n    **Registered Types:**\n    int                         Displays a :class:`SpinBox <pyqtgraph.SpinBox>` in integer\n                                mode.\n    float                       Displays a :class:`SpinBox <pyqtgraph.SpinBox>`.\n    bool                        Displays a QCheckBox\n    str                         Displays a QLineEdit\n    color                       Displays a :class:`ColorButton <pyqtgraph.ColorButton>`\n    colormap                    Displays a :class:`GradientWidget <pyqtgraph.GradientWidget>`\n    ==========================  =============================================================\n    \n    This class can be subclassed by overriding makeWidget() to provide a custom widget.\n    """"""\n    def __init__(self, param, depth):\n        ParameterItem.__init__(self, param, depth)\n        \n        self.hideWidget = True  ## hide edit widget, replace with label when not selected\n                                ## set this to False to keep the editor widget always visible\n        \n        \n        ## build widget into column 1 with a display label and default button.\n        w = self.makeWidget()  \n        self.widget = w\n        self.eventProxy = EventProxy(w, self.widgetEventFilter)\n        \n        opts = self.param.opts\n        if \'tip\' in opts:\n            w.setToolTip(opts[\'tip\'])\n        \n        self.defaultBtn = QtGui.QPushButton()\n        self.defaultBtn.setFixedWidth(20)\n        self.defaultBtn.setFixedHeight(20)\n        modDir = os.path.dirname(__file__)\n        self.defaultBtn.setIcon(QtGui.QIcon(pixmaps.getPixmap(\'default\')))\n        self.defaultBtn.clicked.connect(self.defaultClicked)\n        \n        self.displayLabel = QtGui.QLabel()\n        \n        layout = QtGui.QHBoxLayout()\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(2)\n        layout.addWidget(w)\n        layout.addWidget(self.displayLabel)\n        layout.addWidget(self.defaultBtn)\n        self.layoutWidget = QtGui.QWidget()\n        self.layoutWidget.setLayout(layout)\n        \n        if w.sigChanged is not None:\n            w.sigChanged.connect(self.widgetValueChanged)\n            \n        if hasattr(w, \'sigChanging\'):\n            w.sigChanging.connect(self.widgetValueChanging)\n            \n        ## update value shown in widget. \n        if opts.get(\'value\', None) is not None:\n            self.valueChanged(self, opts[\'value\'], force=True)\n        else:\n            ## no starting value was given; use whatever the widget has\n            self.widgetValueChanged()\n\n        self.updateDefaultBtn()\n\n    def makeWidget(self):\n        """"""\n        Return a single widget that should be placed in the second tree column.\n        The widget must be given three attributes:\n        \n        ==========  ============================================================\n        sigChanged  a signal that is emitted when the widget\'s value is changed\n        value       a function that returns the value\n        setValue    a function that sets the value\n        ==========  ============================================================\n            \n        This is a good function to override in subclasses.\n        """"""\n        opts = self.param.opts\n        t = opts[\'type\']\n        if t in (\'int\', \'float\'):\n            defs = {\n                \'value\': 0, \'min\': None, \'max\': None,\n                \'step\': 1.0, \'dec\': False, \n                \'siPrefix\': False, \'suffix\': \'\', \'decimals\': 3,\n            }\n            if t == \'int\':\n                defs[\'int\'] = True\n                defs[\'minStep\'] = 1.0\n                defs[\'format\'] = \'{value:d}\'\n            for k in defs:\n                if k in opts:\n                    defs[k] = opts[k]\n            if \'limits\' in opts:\n                defs[\'min\'], defs[\'max\'] = opts[\'limits\']\n            w = SpinBox()\n            w.setOpts(**defs)\n            w.sigChanged = w.sigValueChanged\n            w.sigChanging = w.sigValueChanging\n        elif t == \'bool\':\n            w = QtGui.QCheckBox()\n            w.sigChanged = w.toggled\n            w.value = w.isChecked\n            w.setValue = w.setChecked\n            w.setEnabled(not opts.get(\'readonly\', False))\n            self.hideWidget = False\n        elif t == \'str\':\n            w = QtGui.QLineEdit()\n            w.setStyleSheet(\'border: 0px\')\n            w.sigChanged = w.editingFinished\n            w.value = lambda: asUnicode(w.text())\n            w.setValue = lambda v: w.setText(asUnicode(v))\n            w.sigChanging = w.textChanged\n        elif t == \'color\':\n            w = ColorButton()\n            w.sigChanged = w.sigColorChanged\n            w.sigChanging = w.sigColorChanging\n            w.value = w.color\n            w.setValue = w.setColor\n            self.hideWidget = False\n            w.setFlat(True)\n            w.setEnabled(not opts.get(\'readonly\', False))            \n        elif t == \'colormap\':\n            from ..widgets.GradientWidget import GradientWidget ## need this here to avoid import loop\n            w = GradientWidget(orientation=\'bottom\')\n            w.sigChanged = w.sigGradientChangeFinished\n            w.sigChanging = w.sigGradientChanged\n            w.value = w.colorMap\n            w.setValue = w.setColorMap\n            self.hideWidget = False\n        else:\n            raise Exception(""Unknown type \'%s\'"" % asUnicode(t))\n        return w\n        \n    def widgetEventFilter(self, obj, ev):\n        ## filter widget\'s events\n        ## catch TAB to change focus\n        ## catch focusOut to hide editor\n        if ev.type() == ev.KeyPress:\n            if ev.key() == QtCore.Qt.Key_Tab:\n                self.focusNext(forward=True)\n                return True ## don\'t let anyone else see this event\n            elif ev.key() == QtCore.Qt.Key_Backtab:\n                self.focusNext(forward=False)\n                return True ## don\'t let anyone else see this event\n            \n        #elif ev.type() == ev.FocusOut:\n            #self.hideEditor()\n        return False\n        \n    def setFocus(self):\n        self.showEditor()\n        \n    def isFocusable(self):\n        return self.param.writable()        \n        \n    def valueChanged(self, param, val, force=False):\n        ## called when the parameter\'s value has changed\n        ParameterItem.valueChanged(self, param, val)\n        self.widget.sigChanged.disconnect(self.widgetValueChanged)\n        try:\n            if force or val != self.widget.value():\n                self.widget.setValue(val)\n            self.updateDisplayLabel(val)  ## always make sure label is updated, even if values match!\n        finally:\n            self.widget.sigChanged.connect(self.widgetValueChanged)\n        self.updateDefaultBtn()\n        \n    def updateDefaultBtn(self):\n        ## enable/disable default btn \n        self.defaultBtn.setEnabled(not self.param.valueIsDefault() and self.param.writable())        \n        \n        # hide / show\n        self.defaultBtn.setVisible(not self.param.readonly())\n\n    def updateDisplayLabel(self, value=None):\n        """"""Update the display label to reflect the value of the parameter.""""""\n        if value is None:\n            value = self.param.value()\n        opts = self.param.opts\n        if isinstance(self.widget, QtGui.QAbstractSpinBox):\n            text = asUnicode(self.widget.lineEdit().text())\n        elif isinstance(self.widget, QtGui.QComboBox):\n            text = self.widget.currentText()\n        else:\n            text = asUnicode(value)\n        self.displayLabel.setText(text)\n\n    def widgetValueChanged(self):\n        ## called when the widget\'s value has been changed by the user\n        val = self.widget.value()\n        newVal = self.param.setValue(val)\n\n    def widgetValueChanging(self, *args):\n        """"""\n        Called when the widget\'s value is changing, but not finalized.\n        For example: editing text before pressing enter or changing focus.\n        """"""\n        # This is a bit sketchy: assume the last argument of each signal is\n        # the value..\n        self.param.sigValueChanging.emit(self.param, args[-1])\n        \n    def selected(self, sel):\n        """"""Called when this item has been selected (sel=True) OR deselected (sel=False)""""""\n        ParameterItem.selected(self, sel)\n        \n        if self.widget is None:\n            return\n        if sel and self.param.writable():\n            self.showEditor()\n        elif self.hideWidget:\n            self.hideEditor()\n\n    def showEditor(self):\n        self.widget.show()\n        self.displayLabel.hide()\n        self.widget.setFocus(QtCore.Qt.OtherFocusReason)\n        if isinstance(self.widget, SpinBox):\n            self.widget.selectNumber()  # select the numerical portion of the text for quick editing\n\n    def hideEditor(self):\n        self.widget.hide()\n        self.displayLabel.show()\n\n    def limitsChanged(self, param, limits):\n        """"""Called when the parameter\'s limits have changed""""""\n        ParameterItem.limitsChanged(self, param, limits)\n        \n        t = self.param.opts[\'type\']\n        if t == \'int\' or t == \'float\':\n            self.widget.setOpts(bounds=limits)\n        else:\n            return  ## don\'t know what to do with any other types..\n\n    def defaultChanged(self, param, value):\n        self.updateDefaultBtn()\n\n    def treeWidgetChanged(self):\n        """"""Called when this item is added or removed from a tree.""""""\n        ParameterItem.treeWidgetChanged(self)\n        \n        ## add all widgets for this item into the tree\n        if self.widget is not None:\n            tree = self.treeWidget()\n            if tree is None:\n                return\n            tree.setItemWidget(self, 1, self.layoutWidget)\n            self.displayLabel.hide()\n            self.selected(False)            \n\n    def defaultClicked(self):\n        self.param.setToDefault()\n\n    def optsChanged(self, param, opts):\n        """"""Called when any options are changed that are not\n        name, value, default, or limits""""""\n        #print ""opts changed:"", opts\n        ParameterItem.optsChanged(self, param, opts)\n        \n        if \'readonly\' in opts:\n            self.updateDefaultBtn()\n            if isinstance(self.widget, (QtGui.QCheckBox,ColorButton)):\n                self.widget.setEnabled(not opts[\'readonly\'])\n        \n        ## If widget is a SpinBox, pass options straight through\n        if isinstance(self.widget, SpinBox):\n            # send only options supported by spinbox\n            sbOpts = {}\n            if \'units\' in opts and \'suffix\' not in opts:\n                sbOpts[\'suffix\'] = opts[\'units\']\n            for k,v in opts.items():\n                if k in self.widget.opts:\n                    sbOpts[k] = v\n            self.widget.setOpts(**sbOpts)\n            self.updateDisplayLabel()\n        \n            \nclass EventProxy(QtCore.QObject):\n    def __init__(self, qobj, callback):\n        QtCore.QObject.__init__(self)\n        self.callback = callback\n        qobj.installEventFilter(self)\n        \n    def eventFilter(self, obj, ev):\n        return self.callback(obj, ev)\n\n\nclass SimpleParameter(Parameter):\n    itemClass = WidgetParameterItem\n    \n    def __init__(self, *args, **kargs):\n        Parameter.__init__(self, *args, **kargs)\n        \n        ## override a few methods for color parameters\n        if self.opts[\'type\'] == \'color\':\n            self.value = self.colorValue\n            self.saveState = self.saveColorState\n    \n    def colorValue(self):\n        return fn.mkColor(Parameter.value(self))\n    \n    def saveColorState(self, *args, **kwds):\n        state = Parameter.saveState(self, *args, **kwds)\n        state[\'value\'] = fn.colorTuple(self.value())\n        return state\n        \n    def _interpretValue(self, v):\n        fn = {\n            \'int\': int,\n            \'float\': float,\n            \'bool\': bool,\n            \'str\': asUnicode,\n            \'color\': self._interpColor,\n            \'colormap\': self._interpColormap,\n        }[self.opts[\'type\']]\n        return fn(v)\n    \n    def _interpColor(self, v):\n        return fn.mkColor(v)\n    \n    def _interpColormap(self, v):\n        if not isinstance(v, ColorMap):\n            raise TypeError(""Cannot set colormap parameter from object %r"" % v)\n        return v\n            \n        \n    \nregisterParameterType(\'int\', SimpleParameter, override=True)\nregisterParameterType(\'float\', SimpleParameter, override=True)\nregisterParameterType(\'bool\', SimpleParameter, override=True)\nregisterParameterType(\'str\', SimpleParameter, override=True)\nregisterParameterType(\'color\', SimpleParameter, override=True)\nregisterParameterType(\'colormap\', SimpleParameter, override=True)\n\n\n\n\nclass GroupParameterItem(ParameterItem):\n    """"""\n    Group parameters are used mainly as a generic parent item that holds (and groups!) a set\n    of child parameters. It also provides a simple mechanism for displaying a button or combo\n    that can be used to add new parameters to the group.\n    """"""\n    def __init__(self, param, depth):\n        ParameterItem.__init__(self, param, depth)\n        self.updateDepth(depth) \n                \n        self.addItem = None\n        if \'addText\' in param.opts:\n            addText = param.opts[\'addText\']\n            if \'addList\' in param.opts:\n                self.addWidget = QtGui.QComboBox()\n                self.addWidget.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)\n                self.updateAddList()\n                self.addWidget.currentIndexChanged.connect(self.addChanged)\n            else:\n                self.addWidget = QtGui.QPushButton(addText)\n                self.addWidget.clicked.connect(self.addClicked)\n            w = QtGui.QWidget()\n            l = QtGui.QHBoxLayout()\n            l.setContentsMargins(0,0,0,0)\n            w.setLayout(l)\n            l.addWidget(self.addWidget)\n            l.addStretch()\n            #l.addItem(QtGui.QSpacerItem(200, 10, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum))\n            self.addWidgetBox = w\n            self.addItem = QtGui.QTreeWidgetItem([])\n            self.addItem.setFlags(QtCore.Qt.ItemIsEnabled)\n            ParameterItem.addChild(self, self.addItem)\n            \n    def updateDepth(self, depth):\n        ## Change item\'s appearance based on its depth in the tree\n        ## This allows highest-level groups to be displayed more prominently.\n        if depth == 0:\n            for c in [0,1]:\n                self.setBackground(c, QtGui.QBrush(QtGui.QColor(100,100,100)))\n                self.setForeground(c, QtGui.QBrush(QtGui.QColor(220,220,255)))\n                font = self.font(c)\n                font.setBold(True)\n                font.setPointSize(font.pointSize()+1)\n                self.setFont(c, font)\n                self.setSizeHint(0, QtCore.QSize(0, 25))\n        else:\n            for c in [0,1]:\n                self.setBackground(c, QtGui.QBrush(QtGui.QColor(220,220,220)))\n                self.setForeground(c, QtGui.QBrush(QtGui.QColor(50,50,50)))\n                font = self.font(c)\n                font.setBold(True)\n                #font.setPointSize(font.pointSize()+1)\n                self.setFont(c, font)\n                self.setSizeHint(0, QtCore.QSize(0, 20))\n    \n    def addClicked(self):\n        """"""Called when ""add new"" button is clicked\n        The parameter MUST have an \'addNew\' method defined.\n        """"""\n        self.param.addNew()\n\n    def addChanged(self):\n        """"""Called when ""add new"" combo is changed\n        The parameter MUST have an \'addNew\' method defined.\n        """"""\n        if self.addWidget.currentIndex() == 0:\n            return\n        typ = asUnicode(self.addWidget.currentText())\n        self.param.addNew(typ)\n        self.addWidget.setCurrentIndex(0)\n\n    def treeWidgetChanged(self):\n        ParameterItem.treeWidgetChanged(self)\n        self.treeWidget().setFirstItemColumnSpanned(self, True)\n        if self.addItem is not None:\n            self.treeWidget().setItemWidget(self.addItem, 0, self.addWidgetBox)\n            self.treeWidget().setFirstItemColumnSpanned(self.addItem, True)\n        \n    def addChild(self, child):  ## make sure added childs are actually inserted before add btn\n        if self.addItem is not None:\n            ParameterItem.insertChild(self, self.childCount()-1, child)\n        else:\n            ParameterItem.addChild(self, child)\n            \n    def optsChanged(self, param, changed):\n        if \'addList\' in changed:\n            self.updateAddList()\n                \n    def updateAddList(self):\n        self.addWidget.blockSignals(True)\n        try:\n            self.addWidget.clear()\n            self.addWidget.addItem(self.param.opts[\'addText\'])\n            for t in self.param.opts[\'addList\']:\n                self.addWidget.addItem(t)\n        finally:\n            self.addWidget.blockSignals(False)\n            \nclass GroupParameter(Parameter):\n    """"""\n    Group parameters are used mainly as a generic parent item that holds (and groups!) a set\n    of child parameters. \n    \n    It also provides a simple mechanism for displaying a button or combo\n    that can be used to add new parameters to the group. To enable this, the group \n    must be initialized with the \'addText\' option (the text will be displayed on\n    a button which, when clicked, will cause addNew() to be called). If the \'addList\'\n    option is specified as well, then a dropdown-list of addable items will be displayed\n    instead of a button.\n    """"""\n    itemClass = GroupParameterItem\n    \n    sigAddNew = QtCore.Signal(object, object)  # self, type\n\n    def addNew(self, typ=None):\n        """"""\n        This method is called when the user has requested to add a new item to the group.\n        By default, it emits ``sigAddNew(self, typ)``.\n        """"""\n        self.sigAddNew.emit(self, typ)\n    \n    def setAddList(self, vals):\n        """"""Change the list of options available for the user to add to the group.""""""\n        self.setOpts(addList=vals)\n\n    \n\nregisterParameterType(\'group\', GroupParameter, override=True)\n\n\n\n\n\nclass ListParameterItem(WidgetParameterItem):\n    """"""\n    WidgetParameterItem subclass providing comboBox that lets the user select from a list of options.\n    \n    """"""\n    def __init__(self, param, depth):\n        self.targetValue = None\n        WidgetParameterItem.__init__(self, param, depth)\n        \n        \n    def makeWidget(self):\n        opts = self.param.opts\n        t = opts[\'type\']\n        w = QtGui.QComboBox()\n        w.setMaximumHeight(20)  ## set to match height of spin box and line edit\n        w.sigChanged = w.currentIndexChanged\n        w.value = self.value\n        w.setValue = self.setValue\n        self.widget = w  ## needs to be set before limits are changed\n        self.limitsChanged(self.param, self.param.opts[\'limits\'])\n        if len(self.forward) > 0:\n            self.setValue(self.param.value())\n        return w\n        \n    def value(self):\n        key = asUnicode(self.widget.currentText())\n        \n        return self.forward.get(key, None)\n            \n    def setValue(self, val):\n        self.targetValue = val\n        if val not in self.reverse[0]:\n            self.widget.setCurrentIndex(0)\n        else:\n            key = self.reverse[1][self.reverse[0].index(val)]\n            ind = self.widget.findText(key)\n            self.widget.setCurrentIndex(ind)\n\n    def limitsChanged(self, param, limits):\n        # set up forward / reverse mappings for name:value\n        \n        if len(limits) == 0:\n            limits = [\'\']  ## Can never have an empty list--there is always at least a singhe blank item.\n        \n        self.forward, self.reverse = ListParameter.mapping(limits)\n        try:\n            self.widget.blockSignals(True)\n            val = self.targetValue  #asUnicode(self.widget.currentText())\n            \n            self.widget.clear()\n            for k in self.forward:\n                self.widget.addItem(k)\n                if k == val:\n                    self.widget.setCurrentIndex(self.widget.count()-1)\n                    self.updateDisplayLabel()\n        finally:\n            self.widget.blockSignals(False)\n            \n\n\nclass ListParameter(Parameter):\n    itemClass = ListParameterItem\n\n    def __init__(self, **opts):\n        self.forward = OrderedDict()  ## {name: value, ...}\n        self.reverse = ([], [])       ## ([value, ...], [name, ...])\n        \n        ## Parameter uses \'limits\' option to define the set of allowed values\n        if \'values\' in opts:\n            opts[\'limits\'] = opts[\'values\']\n        if opts.get(\'limits\', None) is None:\n            opts[\'limits\'] = []\n        Parameter.__init__(self, **opts)\n        self.setLimits(opts[\'limits\'])\n        \n    def setLimits(self, limits):\n        self.forward, self.reverse = self.mapping(limits)\n        \n        Parameter.setLimits(self, limits)\n        if len(self.reverse[0]) > 0 and self.value() not in self.reverse[0]:\n            self.setValue(self.reverse[0][0])\n            \n    #def addItem(self, name, value=None):\n        #if name in self.forward:\n            #raise Exception(""Name \'%s\' is already in use for this parameter"" % name)\n        #limits = self.opts[\'limits\']\n        #if isinstance(limits, dict):\n            #limits = limits.copy()\n            #limits[name] = value\n            #self.setLimits(limits)\n        #else:\n            #if value is not None:\n                #raise Exception  ## raise exception or convert to dict?\n            #limits = limits[:]\n            #limits.append(name)\n        ## what if limits == None?\n            \n    @staticmethod\n    def mapping(limits):\n        ## Return forward and reverse mapping objects given a limit specification\n        forward = OrderedDict()  ## {name: value, ...}\n        reverse = ([], [])       ## ([value, ...], [name, ...])\n        if isinstance(limits, dict):\n            for k, v in limits.items():\n                forward[k] = v\n                reverse[0].append(v)\n                reverse[1].append(k)\n        else:\n            for v in limits:\n                n = asUnicode(v)\n                forward[n] = v\n                reverse[0].append(v)\n                reverse[1].append(n)\n        return forward, reverse\n\nregisterParameterType(\'list\', ListParameter, override=True)\n\n\n\nclass ActionParameterItem(ParameterItem):\n    def __init__(self, param, depth):\n        ParameterItem.__init__(self, param, depth)\n        self.layoutWidget = QtGui.QWidget()\n        self.layout = QtGui.QHBoxLayout()\n        self.layout.setContentsMargins(0, 0, 0, 0)\n        self.layoutWidget.setLayout(self.layout)\n        self.button = QtGui.QPushButton(param.name())\n        #self.layout.addSpacing(100)\n        self.layout.addWidget(self.button)\n        self.layout.addStretch()\n        self.button.clicked.connect(self.buttonClicked)\n        param.sigNameChanged.connect(self.paramRenamed)\n        self.setText(0, \'\')\n        \n    def treeWidgetChanged(self):\n        ParameterItem.treeWidgetChanged(self)\n        tree = self.treeWidget()\n        if tree is None:\n            return\n        \n        tree.setFirstItemColumnSpanned(self, True)\n        tree.setItemWidget(self, 0, self.layoutWidget)\n        \n    def paramRenamed(self, param, name):\n        self.button.setText(name)\n        \n    def buttonClicked(self):\n        self.param.activate()\n        \nclass ActionParameter(Parameter):\n    """"""Used for displaying a button within the tree.""""""\n    itemClass = ActionParameterItem\n    sigActivated = QtCore.Signal(object)\n    \n    def activate(self):\n        self.sigActivated.emit(self)\n        self.emitStateChanged(\'activated\', None)\n        \nregisterParameterType(\'action\', ActionParameter, override=True)\n\n\n\nclass TextParameterItem(WidgetParameterItem):\n    def __init__(self, param, depth):\n        WidgetParameterItem.__init__(self, param, depth)\n        self.hideWidget = False\n        self.subItem = QtGui.QTreeWidgetItem()\n        self.addChild(self.subItem)\n\n    def treeWidgetChanged(self):\n        ## TODO: fix so that superclass method can be called\n        ## (WidgetParameter should just natively support this style)\n        #WidgetParameterItem.treeWidgetChanged(self)\n        self.treeWidget().setFirstItemColumnSpanned(self.subItem, True)\n        self.treeWidget().setItemWidget(self.subItem, 0, self.textBox)\n        \n        # for now, these are copied from ParameterItem.treeWidgetChanged\n        self.setHidden(not self.param.opts.get(\'visible\', True))\n        self.setExpanded(self.param.opts.get(\'expanded\', True))\n        \n    def makeWidget(self):\n        self.textBox = QtGui.QTextEdit()\n        self.textBox.setMaximumHeight(100)\n        self.textBox.setReadOnly(self.param.opts.get(\'readonly\', False))\n        self.textBox.value = lambda: str(self.textBox.toPlainText())\n        self.textBox.setValue = self.textBox.setPlainText\n        self.textBox.sigChanged = self.textBox.textChanged\n        return self.textBox\n        \nclass TextParameter(Parameter):\n    """"""Editable string; displayed as large text box in the tree.""""""\n    itemClass = TextParameterItem\n\n    \n    \nregisterParameterType(\'text\', TextParameter, override=True)\n'"
src/third_party/pyqtgraph/pixmaps/__init__.py,0,"b'""""""\nAllows easy loading of pixmaps used in UI elements. \nProvides support for frozen environments as well.\n""""""\n\nimport os, sys, pickle\nfrom ..functions import makeQImage\nfrom ..Qt import QtGui\nfrom ..python2_3 import basestring\nif sys.version_info[0] == 2:\n    from . import pixmapData_2 as pixmapData\nelse:\n    from . import pixmapData_3 as pixmapData\n\n\ndef getPixmap(name):\n    """"""\n    Return a QPixmap corresponding to the image file with the given name.\n    (eg. getPixmap(\'auto\') loads pyqtgraph/pixmaps/auto.png)\n    """"""\n    key = name+\'.png\'\n    data = pixmapData.pixmapData[key]\n    if isinstance(data, basestring) or isinstance(data, bytes):\n        pixmapData.pixmapData[key] = pickle.loads(data)\n    arr = pixmapData.pixmapData[key]\n    return QtGui.QPixmap(makeQImage(arr, alpha=True))\n    \n'"
src/third_party/pyqtgraph/pixmaps/compile.py,1,"b'import numpy as np\nfrom PyQt4 import QtGui\nimport os, pickle, sys\n\npath = os.path.abspath(os.path.split(__file__)[0])\npixmaps = {}\nfor f in os.listdir(path):\n    if not f.endswith(\'.png\'):\n        continue\n    print(f)\n    img = QtGui.QImage(os.path.join(path, f))\n    ptr = img.bits()\n    ptr.setsize(img.byteCount())\n    arr = np.asarray(ptr).reshape(img.height(), img.width(), 4).transpose(1,0,2)\n    pixmaps[f] = pickle.dumps(arr)\nver = sys.version_info[0]\nfh = open(os.path.join(path, \'pixmapData_%d.py\' %ver), \'w\')\nfh.write(""import numpy as np; pixmapData=%s"" % repr(pixmaps))\n    \n'"
src/third_party/pyqtgraph/pixmaps/pixmapData_2.py,0,"b'import numpy as np; pixmapData={\'lock.png\': ""cnumpy.core.multiarray\\n_reconstruct\\np0\\n(cnumpy\\nndarray\\np1\\n(I0\\ntp2\\nS\'b\'\\np3\\ntp4\\nRp5\\n(I1\\n(I32\\nI32\\nI4\\ntp6\\ncnumpy\\ndtype\\np7\\n(S\'u1\'\\np8\\nI0\\nI1\\ntp9\\nRp10\\n(I3\\nS\'|\'\\np11\\nNNNI-1\\nI-1\\nI0\\ntp12\\nbI00\\nS\'\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xad\\\\xad\\\\xad\\\\x19\\\\xa8\\\\xa8\\\\xa8\\\\x8d\\\\xa9\\\\xa9\\\\xa9\\\\xc1\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xaa\\\\xaa\\\\xaa\\\\xc2\\\\xa9\\\\xa9\\\\xa9\\\\x8e\\\\xad\\\\xad\\\\xad\\\\x19\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xa8\\\\xa8\\\\xa8X\\\\xa9\\\\xa9\\\\xa9\\\\xed\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xed\\\\xa8\\\\xa8\\\\xa8X\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaaW\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xaa\\\\xaa\\\\xaaW\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff)))\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff)))\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xbe\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff)))\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff)))\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xbe\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x0c\\\\x0c\\\\x0c\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe1\\\\xe1\\\\xe1\\\\xff{{{\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x0e\\\\x0e\\\\x0e\\\\xff***\\\\xff+++\\\\xff+++\\\\xff\\\\xaf\\\\xaf\\\\xaf\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe2\\\\xe2\\\\xe2\\\\xff\\\\x10\\\\x10\\\\x10\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x1e\\\\x1e\\\\x1e\\\\xff\\\\x93\\\\x93\\\\x93\\\\xff\\\\xc6\\\\xc6\\\\xc6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xffaaa\\\\xff\\\\xdc\\\\xdc\\\\xdc\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\\\\\\\\\\\\\\\\\\\\\\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe2\\\\xe2\\\\xe2\\\\xff\\\\xbb\\\\xbb\\\\xbb\\\\xff\\\\x9f\\\\x9f\\\\x9f\\\\xff\\\\x9f\\\\x9f\\\\x9f\\\\xff\\\\x9f\\\\x9f\\\\x9f\\\\xff\\\\xd7\\\\xd7\\\\xd7\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x1c\\\\x1c\\\\x1c\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x91\\\\x91\\\\x91\\\\xff\\\\x0f\\\\x0f\\\\x0f\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xb4\\\\xb4\\\\xb4\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x87\\\\x87\\\\x87\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x98\\\\x98\\\\x98\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xb4\\\\xb4\\\\xb4\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xba\\\\xba\\\\xba\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x19\\\\x19\\\\x19\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xb4\\\\xb4\\\\xb4\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x08\\\\x08\\\\x08\\\\xff\\\\xe2\\\\xe2\\\\xe2\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xcc\\\\xcc\\\\xcc\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xb4\\\\xb4\\\\xb4\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x08\\\\x08\\\\x08\\\\xff\\\\xe2\\\\xe2\\\\xe2\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xcc\\\\xcc\\\\xcc\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xb4\\\\xb4\\\\xb4\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xba\\\\xba\\\\xba\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x19\\\\x19\\\\x19\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xb4\\\\xb4\\\\xb4\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x85\\\\x85\\\\x85\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x98\\\\x98\\\\x98\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xb4\\\\xb4\\\\xb4\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x19\\\\x19\\\\x19\\\\xff\\\\xd9\\\\xd9\\\\xd9\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x91\\\\x91\\\\x91\\\\xff\\\\x0f\\\\x0f\\\\x0f\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xb4\\\\xb4\\\\xb4\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xffZZZ\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe2\\\\xe2\\\\xe2\\\\xff\\\\xbc\\\\xbc\\\\xbc\\\\xff\\\\x9f\\\\x9f\\\\x9f\\\\xff\\\\x9f\\\\x9f\\\\x9f\\\\xff\\\\x9f\\\\x9f\\\\x9f\\\\xff\\\\xd7\\\\xd7\\\\xd7\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xffaaa\\\\xff\\\\xdc\\\\xdc\\\\xdc\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x1e\\\\x1e\\\\x1e\\\\xff\\\\x93\\\\x93\\\\x93\\\\xff\\\\xc6\\\\xc6\\\\xc6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\x1d\\\\x1d\\\\x1d\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x0e\\\\x0e\\\\x0e\\\\xff***\\\\xff+++\\\\xff+++\\\\xff\\\\xaf\\\\xaf\\\\xaf\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe2\\\\xe2\\\\xe2\\\\xff\\\\x10\\\\x10\\\\x10\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe1\\\\xe1\\\\xe1\\\\xff{{{\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x16\\\\x16\\\\x16\\\\xff\\\\x0c\\\\x0c\\\\x0c\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xbd\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff)))\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff)))\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xbd\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff)))\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff)))\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaaW\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xaa\\\\xaa\\\\xaaW\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaaW\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xaa\\\\xaa\\\\xaaW\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xbd\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xbe\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\'\\np13\\ntp14\\nb."", \'default.png\': \'cnumpy.core.multiarray\\n_reconstruct\\np0\\n(cnumpy\\nndarray\\np1\\n(I0\\ntp2\\nS\\\'b\\\'\\np3\\ntp4\\nRp5\\n(I1\\n(I16\\nI16\\nI4\\ntp6\\ncnumpy\\ndtype\\np7\\n(S\\\'u1\\\'\\np8\\nI0\\nI1\\ntp9\\nRp10\\n(I3\\nS\\\'|\\\'\\np11\\nNNNI-1\\nI-1\\nI0\\ntp12\\nbI00\\nS\\\'\\\\x00\\\\x7f\\\\xa6\\\\x1b\\\\x0c\\\\x8a\\\\xad\\\\xdc\\\\r\\\\x91\\\\xb0\\\\xf3\\\\r\\\\x91\\\\xb0\\\\xf3\\\\r\\\\x91\\\\xb0\\\\xf4\\\\r\\\\x91\\\\xb1\\\\xf4\\\\r\\\\x90\\\\xb0\\\\xf4\\\\x05\\\\x85\\\\xa9\\\\xef\\\\x00\\\\x7f\\\\xa6<\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6!\\\\x1d\\\\x9c\\\\xb9\\\\xf5g\\\\xd9\\\\xf1\\\\xffi\\\\xd9\\\\xf3\\\\xffd\\\\xd1\\\\xee\\\\xff]\\\\xcb\\\\xeb\\\\xff@\\\\xbb\\\\xe3\\\\xff\\\\x16\\\\x9c\\\\xc2\\\\xf8\\\\x00\\\\x7f\\\\xa6\\\\xb4\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6U\\\\\\\'\\\\xac\\\\xc5\\\\xf9i\\\\xd9\\\\xf3\\\\xffc\\\\xd3\\\\xef\\\\xff\\\\\\\\\\\\xcf\\\\xeb\\\\xffP\\\\xc8\\\\xe6\\\\xff\\\\x17\\\\x9f\\\\xc4\\\\xfd\\\\x00\\\\x7f\\\\xa6\\\\xfc\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x02\\\\x83\\\\xa8lH\\\\xc5\\\\xdd\\\\xfah\\\\xdc\\\\xf3\\\\xffc\\\\xd4\\\\xef\\\\xffV\\\\xce\\\\xe9\\\\xffN\\\\xcf\\\\xe7\\\\xff&\\\\xaa\\\\xca\\\\xfd\\\\x00\\\\x7f\\\\xa6\\\\xff\\\\x03\\\\x81\\\\xc7\\\\x01\\\\x04\\\\x8d\\\\xda\\\\x01\\\\t\\\\x94\\\\xd9\\\\x01\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6""$\\\\xa9\\\\xc4\\\\xf7g\\\\xdf\\\\xf5\\\\xfff\\\\xdb\\\\xf3\\\\xffU\\\\xcd\\\\xeb\\\\xff\\\\x16\\\\xb3\\\\xda\\\\xff.\\\\xc9\\\\xe1\\\\xff(\\\\xb2\\\\xd0\\\\xfe\\\\x01\\\\x7f\\\\xa6\\\\xff\\\\x04\\\\x84\\\\xc9\\\\x05\\\\t\\\\x94\\\\xd9\\\\x06\\\\x10\\\\x9c\\\\xd7\\\\x01\\\\x16\\\\xa2\\\\xd6\\\\x01\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x02\\\\x83\\\\xa9\\\\x81T\\\\xd3\\\\xeb\\\\xffg\\\\xe5\\\\xf7\\\\xffe\\\\xda\\\\xf3\\\\xff!\\\\xaa\\\\xde\\\\xff\\\\x11\\\\x9d\\\\xc3\\\\xfe\\\\x11\\\\xba\\\\xd7\\\\xff \\\\xb9\\\\xd5\\\\xfe\\\\x00\\\\x7f\\\\xa6\\\\xff\\\\x16u\\\\x8d\\\\x03\\\\x14\\\\x84\\\\xae\\\\x05\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x10\\\\x92\\\\xb4\\\\xc0d\\\\xde\\\\xf3\\\\xffg\\\\xe5\\\\xf7\\\\xff_\\\\xcc\\\\xef\\\\xff\\\\x0e\\\\x9c\\\\xd5\\\\xff\\\\rx\\\\x95\\\\xf6\\\\x0e\\\\x89\\\\xab\\\\xf4\\\\x18\\\\xb2\\\\xd1\\\\xfc\\\\x00\\\\x7f\\\\xa6\\\\xff\\\\xff\\\\xff\\\\xff\\\\x00\\\\x1a~\\\\x91\\\\x01\\\\x1d\\\\xa5\\\\xce\\\\x01\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x005\\\\xa9\\\\xc3\\\\xefq\\\\xec\\\\xf9\\\\xffg\\\\xe5\\\\xf7\\\\xff>\\\\xb7\\\\xe8\\\\xff\\\\x14\\\\x96\\\\xc8\\\\xfe\\\\x02}\\\\xa3\\\\xb1\\\\x00\\\\x7f\\\\xa6Q\\\\x03\\\\x82\\\\xa9\\\\xe8\\\\x00\\\\x7f\\\\xa6\\\\xe9\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6\\\\x11\\\\x1c\\\\x98\\\\xb8\\\\x04%\\\\xb5\\\\xd3\\\\x01\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00D\\\\xad\\\\xc8\\\\xf3r\\\\xec\\\\xf9\\\\xffg\\\\xe5\\\\xf7\\\\xff:\\\\xb7\\\\xe8\\\\xff\\\\x19\\\\x90\\\\xc5\\\\xfe\\\\x03{\\\\xa0\\\\xa6\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6*\\\\x00\\\\x7f\\\\xa6*\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6\\\\x98\\\\x0f\\\\x8f\\\\xb1\\\\x13&\\\\xb5\\\\xd3\\\\x04.\\\\xc0\\\\xd1\\\\x01\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x19\\\\x93\\\\xb7\\\\xc6i\\\\xdf\\\\xf4\\\\xffg\\\\xe5\\\\xf7\\\\xffT\\\\xc8\\\\xee\\\\xff\\\\x06\\\\x88\\\\xcd\\\\xff\\\\x08g\\\\x85\\\\xf7\\\\x00\\\\x7f\\\\xa6\\\\x15\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6\\\\x1b\\\\x01\\\\x80\\\\xa7\\\\xeb\\\\x1d\\\\xa3\\\\xca\\\\x16#\\\\xb2\\\\xd4\\\\n*\\\\xbb\\\\xd2\\\\x04.\\\\xbc\\\\xd7\\\\x01\\\\xff\\\\xff\\\\xff\\\\x00\\\\x01\\\\x81\\\\xa7\\\\x88Y\\\\xd1\\\\xee\\\\xffg\\\\xe5\\\\xf7\\\\xfff\\\\xd9\\\\xf3\\\\xff\\\\\\\'\\\\xa2\\\\xe2\\\\xff\\\\x05e\\\\x99\\\\xf9\\\\x06~\\\\xa5\\\\xf3\\\\x01\\\\x81\\\\xa8\\\\x9c\\\\x01\\\\x80\\\\xa8\\\\x9f\\\\x04\\\\x85\\\\xad\\\\xef\\\\x08\\\\x8f\\\\xb9\\\\x92\\\\x17\\\\xa4\\\\xd6*\\\\x1e\\\\xac\\\\xd5\\\\x1a$\\\\xb3\\\\xd3\\\\x0c\\\\x19\\\\xa7\\\\xd5\\\\x02\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6+!\\\\xa3\\\\xc8\\\\xf5i\\\\xe0\\\\xf5\\\\xffe\\\\xd9\\\\xf3\\\\xff\\\\\\\\\\\\xca\\\\xee\\\\xff\\\\x1f\\\\x9c\\\\xe0\\\\xfa\\\\x03\\\\x84\\\\xca\\\\xd6\\\\x07\\\\x8b\\\\xc5\\\\xca\\\\x06\\\\x88\\\\xc1\\\\xb8\\\\x08\\\\x8e\\\\xd0l\\\\x0b\\\\x96\\\\xd8I\\\\x11\\\\x9e\\\\xd74\\\\x17\\\\xa5\\\\xd6  \\\\xab\\\\xd7\\\\x0b\\\\x17\\\\xa2\\\\xdc\\\\x01\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x01\\\\x80\\\\xa8~?\\\\xb9\\\\xe0\\\\xf9h\\\\xda\\\\xf3\\\\xff_\\\\xcc\\\\xef\\\\xffV\\\\xc1\\\\xec\\\\xfd3\\\\xa7\\\\xe3\\\\xe3\\\\x1a\\\\x96\\\\xde\\\\xae\\\\x04\\\\x8b\\\\xdb\\\\x89\\\\x00\\\\x89\\\\xdao\\\\x05\\\\x8f\\\\xd9T\\\\x0b\\\\x96\\\\xd8<\\\\x11\\\\x9b\\\\xd7\\\\x1d\\\\x18\\\\x95\\\\xc9\\\\x0c\\\\x00\\\\x80\\\\xd5\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6\\\\x04\\\\x03\\\\x83\\\\xaa\\\\xcd5\\\\xa2\\\\xc9\\\\xf9[\\\\xc6\\\\xea\\\\xffU\\\\xc1\\\\xec\\\\xffH\\\\xb4\\\\xe8\\\\xf39\\\\xa8\\\\xe4\\\\xc5\\\\x0b\\\\x8f\\\\xdc\\\\x9f\\\\x00\\\\x89\\\\xda{\\\\x00\\\\x89\\\\xda_\\\\x07\\\\x87\\\\xc4I\\\\x05|\\\\xa5s\\\\x05m\\\\xa3\\\\x02\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa6\\\\x06\\\\x01\\\\x7f\\\\xa6\\\\x89\\\\x12x\\\\x9e\\\\xf63\\\\x88\\\\xae\\\\xfe6\\\\x93\\\\xc3\\\\xfe4\\\\x9d\\\\xd6\\\\xdf\\\\x08\\\\x82\\\\xc7\\\\xb8\\\\x03k\\\\xa2\\\\xab\\\\x04k\\\\x97\\\\xa8\\\\x02w\\\\x9e\\\\xeb\\\\x00\\\\x7f\\\\xa6j\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x7f\\\\xa67\\\\x00~\\\\xa5\\\\x95\\\\x03v\\\\x9c\\\\xd4\\\\x03h\\\\x8c\\\\xfa\\\\x02i\\\\x8e\\\\xf9\\\\x01x\\\\x9f\\\\xcc\\\\x00\\\\x7f\\\\xa6\\\\x92\\\\x00\\\\x7f\\\\xa63\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\'\\np13\\ntp14\\nb.\', \'ctrl.png\': ""cnumpy.core.multiarray\\n_reconstruct\\np0\\n(cnumpy\\nndarray\\np1\\n(I0\\ntp2\\nS\'b\'\\np3\\ntp4\\nRp5\\n(I1\\n(I32\\nI32\\nI4\\ntp6\\ncnumpy\\ndtype\\np7\\n(S\'u1\'\\np8\\nI0\\nI1\\ntp9\\nRp10\\n(I3\\nS\'|\'\\np11\\nNNNI-1\\nI-1\\nI0\\ntp12\\nbI00\\nS\'\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xad\\\\xad\\\\xad\\\\x19\\\\xa8\\\\xa8\\\\xa8\\\\x8d\\\\xa9\\\\xa9\\\\xa9\\\\xc1\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xaa\\\\xaa\\\\xaa\\\\xc2\\\\xa9\\\\xa9\\\\xa9\\\\x8e\\\\xad\\\\xad\\\\xad\\\\x19\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xa8\\\\xa8\\\\xa8X\\\\xa9\\\\xa9\\\\xa9\\\\xed\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xed\\\\xa8\\\\xa8\\\\xa8X\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaaW\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xaa\\\\xaa\\\\xaaW\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff)))\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff)))\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xbe\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff)))\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff555\\\\xffPPP\\\\xff\\\\x13\\\\x13\\\\x13\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff)))\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xbe\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x01\\\\x01\\\\x01\\\\xff\\\\xb2\\\\xb2\\\\xb2\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xd9\\\\xd9\\\\xd9\\\\xff]]]\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x13\\\\x13\\\\x13\\\\xff\\\\xbb\\\\xbb\\\\xbb\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xffFFF\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x13\\\\x13\\\\x13\\\\xff\\\\xbb\\\\xbb\\\\xbb\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xc4\\\\xc4\\\\xc4\\\\xff\\\\x06\\\\x06\\\\x06\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff```\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff:::\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff666\\\\xff\\\\xaf\\\\xaf\\\\xaf\\\\xff\\\\x10\\\\x10\\\\x10\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9b\\\\x9b\\\\x9b\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff@@@\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xffSSS\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xb7\\\\xb7\\\\xb7\\\\xff\\\\x10\\\\x10\\\\x10\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x04\\\\x04\\\\x04\\\\xff\\\\xd5\\\\xd5\\\\xd5\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xffXXX\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x17\\\\x17\\\\x17\\\\xff\\\\xdb\\\\xdb\\\\xdb\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xb7\\\\xb7\\\\xb7\\\\xff[[[\\\\xff\\\\x97\\\\x97\\\\x97\\\\xff\\\\xd4\\\\xd4\\\\xd4\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff```\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xffHHH\\\\xff\\\\xc6\\\\xc6\\\\xc6\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x07\\\\x07\\\\x07\\\\xff;;;\\\\xffAAA\\\\xff\\\\\\\\\\\\\\\\\\\\\\\\\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff;;;\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xc7\\\\xc7\\\\xc7\\\\xffZZZ\\\\xff~~~\\\\xff\\\\xd9\\\\xd9\\\\xd9\\\\xff\\\\x10\\\\x10\\\\x10\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xffXXX\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xb0\\\\xb0\\\\xb0\\\\xfffff\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xdd\\\\xdd\\\\xdd\\\\xffyyy\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x06\\\\x06\\\\x06\\\\xff\\\\xcd\\\\xcd\\\\xcd\\\\xfffff\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff@@@\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff\\\\xaf\\\\xaf\\\\xaf\\\\xff\\\\xcd\\\\xcd\\\\xcd\\\\xff\\\\xd7\\\\xd7\\\\xd7\\\\xff\\\\x10\\\\x10\\\\x10\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xbd\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff)))\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x12\\\\x12\\\\x12\\\\xffiii\\\\xffccc\\\\xff\\\\x0e\\\\x0e\\\\x0e\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff)))\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xbd\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff)))\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff)))\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaaW\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xaa\\\\xaa\\\\xaaW\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaaW\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xaa\\\\xaa\\\\xaaW\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xbd\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xbe\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\'\\np13\\ntp14\\nb."", \'auto.png\': ""cnumpy.core.multiarray\\n_reconstruct\\np0\\n(cnumpy\\nndarray\\np1\\n(I0\\ntp2\\nS\'b\'\\np3\\ntp4\\nRp5\\n(I1\\n(I32\\nI32\\nI4\\ntp6\\ncnumpy\\ndtype\\np7\\n(S\'u1\'\\np8\\nI0\\nI1\\ntp9\\nRp10\\n(I3\\nS\'|\'\\np11\\nNNNI-1\\nI-1\\nI0\\ntp12\\nbI00\\nS\'\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xad\\\\xad\\\\xad\\\\x19\\\\xa8\\\\xa8\\\\xa8\\\\x8d\\\\xa9\\\\xa9\\\\xa9\\\\xc1\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xaa\\\\xaa\\\\xaa\\\\xc2\\\\xa9\\\\xa9\\\\xa9\\\\x8e\\\\xad\\\\xad\\\\xad\\\\x19\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xa8\\\\xa8\\\\xa8X\\\\xa9\\\\xa9\\\\xa9\\\\xed\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xed\\\\xa8\\\\xa8\\\\xa8X\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaaW\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xaa\\\\xaa\\\\xaaW\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff)))\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff)))\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x19\\\\x19\\\\x19\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xbe\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff)))\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x04\\\\x04\\\\x04\\\\xffHHH\\\\xff\\\\xa4\\\\xa4\\\\xa4\\\\xff\\\\xe5\\\\xe5\\\\xe5\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff)))\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xbe\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff   \\\\xffyyy\\\\xff\\\\xd1\\\\xd1\\\\xd1\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x06\\\\x06\\\\x06\\\\xffPPP\\\\xff\\\\xab\\\\xab\\\\xab\\\\xff\\\\xe6\\\\xe6\\\\xe6\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff&&&\\\\xff\\\\x82\\\\x82\\\\x82\\\\xff\\\\xd6\\\\xd6\\\\xd6\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\t\\\\t\\\\t\\\\xffWWW\\\\xff\\\\xb2\\\\xb2\\\\xb2\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe5\\\\xe5\\\\xe5\\\\xff\\\\xa8\\\\xa8\\\\xa8\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff---\\\\xff\\\\x89\\\\x89\\\\x89\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xc1\\\\xc1\\\\xc1\\\\xfflll\\\\xff\\\\x18\\\\x18\\\\x18\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\r\\\\r\\\\r\\\\xff^^^\\\\xff\\\\xba\\\\xba\\\\xba\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff...\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff555\\\\xff\\\\x90\\\\x90\\\\x90\\\\xff\\\\xde\\\\xde\\\\xde\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe2\\\\xe2\\\\xe2\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff;;;\\\\xff\\\\xc1\\\\xc1\\\\xc1\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xb7\\\\xb7\\\\xb7\\\\xffbbb\\\\xff\\\\x12\\\\x12\\\\x12\\\\xff\\\\xcb\\\\xcb\\\\xcb\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xffmmm\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xcd\\\\xcd\\\\xcd\\\\xffyyy\\\\xff$$$\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xcb\\\\xcb\\\\xcb\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xffmmm\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe3\\\\xe3\\\\xe3\\\\xff\\\\x91\\\\x91\\\\x91\\\\xff<<<\\\\xff\\\\x01\\\\x01\\\\x01\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xcb\\\\xcb\\\\xcb\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xffmmm\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xc3\\\\xc3\\\\xc3\\\\xfflll\\\\xff\\\\x18\\\\x18\\\\x18\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xcb\\\\xcb\\\\xcb\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xffmmm\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe4\\\\xe4\\\\xe4\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xffOOO\\\\xff\\\\x07\\\\x07\\\\x07\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\xcb\\\\xcb\\\\xcb\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff555\\\\xff\\\\xb4\\\\xb4\\\\xb4\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xd9\\\\xd9\\\\xd9\\\\xff\\\\x8a\\\\x8a\\\\x8a\\\\xff333\\\\xff\\\\xcb\\\\xcb\\\\xcb\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff+++\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xda\\\\xda\\\\xda\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xd2\\\\xd2\\\\xd2\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\n\\\\n\\\\n\\\\xff[[[\\\\xff\\\\xb8\\\\xb8\\\\xb8\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xdc\\\\xdc\\\\xdc\\\\xffAAA\\\\xff\\\\x02\\\\x02\\\\x02\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff...\\\\xff\\\\x8c\\\\x8c\\\\x8c\\\\xff\\\\xdc\\\\xdc\\\\xdc\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xcc\\\\xcc\\\\xcc\\\\xffsss\\\\xff\\\\x1a\\\\x1a\\\\x1a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x0c\\\\x0c\\\\x0c\\\\xff___\\\\xff\\\\xbc\\\\xbc\\\\xbc\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe5\\\\xe5\\\\xe5\\\\xff\\\\xa5\\\\xa5\\\\xa5\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff222\\\\xff\\\\x8f\\\\x8f\\\\x8f\\\\xff\\\\xde\\\\xde\\\\xde\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x0e\\\\x0e\\\\x0e\\\\xffccc\\\\xff\\\\xc0\\\\xc0\\\\xc0\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff555\\\\xff\\\\x94\\\\x94\\\\x94\\\\xff\\\\xe0\\\\xe0\\\\xe0\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xbd\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff)))\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x10\\\\x10\\\\x10\\\\xfffff\\\\xff\\\\xc4\\\\xc4\\\\xc4\\\\xff\\\\xe7\\\\xe7\\\\xe7\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff)))\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xbd\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff:::\\\\xff\\\\x03\\\\x03\\\\x03\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff)))\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x00\\\\x00\\\\x00\\\\xff\\\\x05\\\\x05\\\\x05\\\\xff)))\\\\xff\\\\x88\\\\x88\\\\x88\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaaW\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\x9a\\\\x9a\\\\x9a\\\\xff\\\\xa6\\\\xa6\\\\xa6\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xaa\\\\xaa\\\\xaaW\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaaW\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xeb\\\\xaa\\\\xaa\\\\xaaW\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xa9\\\\xa9\\\\xa9\\\\xbd\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xff\\\\xa9\\\\xa9\\\\xa9\\\\xf1\\\\xa9\\\\xa9\\\\xa9\\\\xbe\\\\xa9\\\\xa9\\\\xa9\\\\x88\\\\xaa\\\\xaa\\\\xaa\\\\x15\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\\\\xff\\\\xff\\\\xff\\\\x00\'\\np13\\ntp14\\nb.""}'"
src/third_party/pyqtgraph/pixmaps/pixmapData_3.py,0,"b'import numpy as np; pixmapData={\'lock.png\': b\'\\x80\\x03cnumpy.core.multiarray\\n_reconstruct\\nq\\x00cnumpy\\nndarray\\nq\\x01K\\x00\\x85q\\x02C\\x01bq\\x03\\x87q\\x04Rq\\x05(K\\x01K K K\\x04\\x87q\\x06cnumpy\\ndtype\\nq\\x07X\\x02\\x00\\x00\\x00u1q\\x08K\\x00K\\x01\\x87q\\tRq\\n(K\\x03X\\x01\\x00\\x00\\x00|q\\x0bNNNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xffK\\x00tq\\x0cb\\x89B\\x00\\x10\\x00\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xad\\xad\\xad\\x19\\xa8\\xa8\\xa8\\x8d\\xa9\\xa9\\xa9\\xc1\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xaa\\xaa\\xaa\\xc2\\xa9\\xa9\\xa9\\x8e\\xad\\xad\\xad\\x19\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xa8\\xa8\\xa8X\\xa9\\xa9\\xa9\\xed\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xed\\xa8\\xa8\\xa8X\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaaW\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xaa\\xaa\\xaaW\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\xeb\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff)))\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff)))\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xeb\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff\\x03\\x03\\x03\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x03\\x03\\x03\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xbe\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff)))\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff)))\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xbe\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x0c\\x0c\\x0c\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xd2\\xd2\\xd2\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe1\\xe1\\xe1\\xff{{{\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x0e\\x0e\\x0e\\xff***\\xff+++\\xff+++\\xff\\xaf\\xaf\\xaf\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe2\\xe2\\xe2\\xff\\x10\\x10\\x10\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x1e\\x1e\\x1e\\xff\\x93\\x93\\x93\\xff\\xc6\\xc6\\xc6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xffaaa\\xff\\xdc\\xdc\\xdc\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\\\\\\\\\\\\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe2\\xe2\\xe2\\xff\\xbb\\xbb\\xbb\\xff\\x9f\\x9f\\x9f\\xff\\x9f\\x9f\\x9f\\xff\\x9f\\x9f\\x9f\\xff\\xd7\\xd7\\xd7\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x1c\\x1c\\x1c\\xff\\xda\\xda\\xda\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x91\\x91\\x91\\xff\\x0f\\x0f\\x0f\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xb4\\xb4\\xb4\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x87\\x87\\x87\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x98\\x98\\x98\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xb4\\xb4\\xb4\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xba\\xba\\xba\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x19\\x19\\x19\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xb4\\xb4\\xb4\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x08\\x08\\x08\\xff\\xe2\\xe2\\xe2\\xff\\xe6\\xe6\\xe6\\xff\\xcc\\xcc\\xcc\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xb4\\xb4\\xb4\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x08\\x08\\x08\\xff\\xe2\\xe2\\xe2\\xff\\xe6\\xe6\\xe6\\xff\\xcc\\xcc\\xcc\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xb4\\xb4\\xb4\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xba\\xba\\xba\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x19\\x19\\x19\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xb4\\xb4\\xb4\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x85\\x85\\x85\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x98\\x98\\x98\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xb4\\xb4\\xb4\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x19\\x19\\x19\\xff\\xd9\\xd9\\xd9\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x91\\x91\\x91\\xff\\x0f\\x0f\\x0f\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xb4\\xb4\\xb4\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xffZZZ\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe2\\xe2\\xe2\\xff\\xbc\\xbc\\xbc\\xff\\x9f\\x9f\\x9f\\xff\\x9f\\x9f\\x9f\\xff\\x9f\\x9f\\x9f\\xff\\xd7\\xd7\\xd7\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xffaaa\\xff\\xdc\\xdc\\xdc\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x1e\\x1e\\x1e\\xff\\x93\\x93\\x93\\xff\\xc6\\xc6\\xc6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\x1d\\x1d\\x1d\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x0e\\x0e\\x0e\\xff***\\xff+++\\xff+++\\xff\\xaf\\xaf\\xaf\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe2\\xe2\\xe2\\xff\\x10\\x10\\x10\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xd2\\xd2\\xd2\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe6\\xe6\\xe6\\xff\\xe1\\xe1\\xe1\\xff{{{\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x16\\x16\\x16\\xff\\x0c\\x0c\\x0c\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xbd\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff)))\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff)))\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xbd\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff\\x03\\x03\\x03\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x03\\x03\\x03\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\x88\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\xeb\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff)))\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff)))\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xeb\\xaa\\xaa\\xaa\\x15\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaaW\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xaa\\xaa\\xaaW\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaaW\\xa9\\xa9\\xa9\\xeb\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xeb\\xaa\\xaa\\xaaW\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xbd\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xbe\\xa9\\xa9\\xa9\\x88\\xaa\\xaa\\xaa\\x15\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00q\\rtq\\x0eb.\', \'default.png\': b\'\\x80\\x03cnumpy.core.multiarray\\n_reconstruct\\nq\\x00cnumpy\\nndarray\\nq\\x01K\\x00\\x85q\\x02C\\x01bq\\x03\\x87q\\x04Rq\\x05(K\\x01K\\x10K\\x10K\\x04\\x87q\\x06cnumpy\\ndtype\\nq\\x07X\\x02\\x00\\x00\\x00u1q\\x08K\\x00K\\x01\\x87q\\tRq\\n(K\\x03X\\x01\\x00\\x00\\x00|q\\x0bNNNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xffK\\x00tq\\x0cb\\x89B\\x00\\x04\\x00\\x00\\x00\\x7f\\xa6\\x1b\\x0c\\x8a\\xad\\xdc\\r\\x91\\xb0\\xf3\\r\\x91\\xb0\\xf3\\r\\x91\\xb0\\xf4\\r\\x91\\xb1\\xf4\\r\\x90\\xb0\\xf4\\x05\\x85\\xa9\\xef\\x00\\x7f\\xa6<\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6!\\x1d\\x9c\\xb9\\xf5g\\xd9\\xf1\\xffi\\xd9\\xf3\\xffd\\xd1\\xee\\xff]\\xcb\\xeb\\xff@\\xbb\\xe3\\xff\\x16\\x9c\\xc2\\xf8\\x00\\x7f\\xa6\\xb4\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6U\\\'\\xac\\xc5\\xf9i\\xd9\\xf3\\xffc\\xd3\\xef\\xff\\\\\\xcf\\xeb\\xffP\\xc8\\xe6\\xff\\x17\\x9f\\xc4\\xfd\\x00\\x7f\\xa6\\xfc\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x02\\x83\\xa8lH\\xc5\\xdd\\xfah\\xdc\\xf3\\xffc\\xd4\\xef\\xffV\\xce\\xe9\\xffN\\xcf\\xe7\\xff&\\xaa\\xca\\xfd\\x00\\x7f\\xa6\\xff\\x03\\x81\\xc7\\x01\\x04\\x8d\\xda\\x01\\t\\x94\\xd9\\x01\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6""$\\xa9\\xc4\\xf7g\\xdf\\xf5\\xfff\\xdb\\xf3\\xffU\\xcd\\xeb\\xff\\x16\\xb3\\xda\\xff.\\xc9\\xe1\\xff(\\xb2\\xd0\\xfe\\x01\\x7f\\xa6\\xff\\x04\\x84\\xc9\\x05\\t\\x94\\xd9\\x06\\x10\\x9c\\xd7\\x01\\x16\\xa2\\xd6\\x01\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x02\\x83\\xa9\\x81T\\xd3\\xeb\\xffg\\xe5\\xf7\\xffe\\xda\\xf3\\xff!\\xaa\\xde\\xff\\x11\\x9d\\xc3\\xfe\\x11\\xba\\xd7\\xff \\xb9\\xd5\\xfe\\x00\\x7f\\xa6\\xff\\x16u\\x8d\\x03\\x14\\x84\\xae\\x05\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x10\\x92\\xb4\\xc0d\\xde\\xf3\\xffg\\xe5\\xf7\\xff_\\xcc\\xef\\xff\\x0e\\x9c\\xd5\\xff\\rx\\x95\\xf6\\x0e\\x89\\xab\\xf4\\x18\\xb2\\xd1\\xfc\\x00\\x7f\\xa6\\xff\\xff\\xff\\xff\\x00\\x1a~\\x91\\x01\\x1d\\xa5\\xce\\x01\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x005\\xa9\\xc3\\xefq\\xec\\xf9\\xffg\\xe5\\xf7\\xff>\\xb7\\xe8\\xff\\x14\\x96\\xc8\\xfe\\x02}\\xa3\\xb1\\x00\\x7f\\xa6Q\\x03\\x82\\xa9\\xe8\\x00\\x7f\\xa6\\xe9\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6\\x11\\x1c\\x98\\xb8\\x04%\\xb5\\xd3\\x01\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00D\\xad\\xc8\\xf3r\\xec\\xf9\\xffg\\xe5\\xf7\\xff:\\xb7\\xe8\\xff\\x19\\x90\\xc5\\xfe\\x03{\\xa0\\xa6\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6*\\x00\\x7f\\xa6*\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6\\x98\\x0f\\x8f\\xb1\\x13&\\xb5\\xd3\\x04.\\xc0\\xd1\\x01\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x19\\x93\\xb7\\xc6i\\xdf\\xf4\\xffg\\xe5\\xf7\\xffT\\xc8\\xee\\xff\\x06\\x88\\xcd\\xff\\x08g\\x85\\xf7\\x00\\x7f\\xa6\\x15\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6\\x1b\\x01\\x80\\xa7\\xeb\\x1d\\xa3\\xca\\x16#\\xb2\\xd4\\n*\\xbb\\xd2\\x04.\\xbc\\xd7\\x01\\xff\\xff\\xff\\x00\\x01\\x81\\xa7\\x88Y\\xd1\\xee\\xffg\\xe5\\xf7\\xfff\\xd9\\xf3\\xff\\\'\\xa2\\xe2\\xff\\x05e\\x99\\xf9\\x06~\\xa5\\xf3\\x01\\x81\\xa8\\x9c\\x01\\x80\\xa8\\x9f\\x04\\x85\\xad\\xef\\x08\\x8f\\xb9\\x92\\x17\\xa4\\xd6*\\x1e\\xac\\xd5\\x1a$\\xb3\\xd3\\x0c\\x19\\xa7\\xd5\\x02\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6+!\\xa3\\xc8\\xf5i\\xe0\\xf5\\xffe\\xd9\\xf3\\xff\\\\\\xca\\xee\\xff\\x1f\\x9c\\xe0\\xfa\\x03\\x84\\xca\\xd6\\x07\\x8b\\xc5\\xca\\x06\\x88\\xc1\\xb8\\x08\\x8e\\xd0l\\x0b\\x96\\xd8I\\x11\\x9e\\xd74\\x17\\xa5\\xd6  \\xab\\xd7\\x0b\\x17\\xa2\\xdc\\x01\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x01\\x80\\xa8~?\\xb9\\xe0\\xf9h\\xda\\xf3\\xff_\\xcc\\xef\\xffV\\xc1\\xec\\xfd3\\xa7\\xe3\\xe3\\x1a\\x96\\xde\\xae\\x04\\x8b\\xdb\\x89\\x00\\x89\\xdao\\x05\\x8f\\xd9T\\x0b\\x96\\xd8<\\x11\\x9b\\xd7\\x1d\\x18\\x95\\xc9\\x0c\\x00\\x80\\xd5\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6\\x04\\x03\\x83\\xaa\\xcd5\\xa2\\xc9\\xf9[\\xc6\\xea\\xffU\\xc1\\xec\\xffH\\xb4\\xe8\\xf39\\xa8\\xe4\\xc5\\x0b\\x8f\\xdc\\x9f\\x00\\x89\\xda{\\x00\\x89\\xda_\\x07\\x87\\xc4I\\x05|\\xa5s\\x05m\\xa3\\x02\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x00\\x7f\\xa6\\x06\\x01\\x7f\\xa6\\x89\\x12x\\x9e\\xf63\\x88\\xae\\xfe6\\x93\\xc3\\xfe4\\x9d\\xd6\\xdf\\x08\\x82\\xc7\\xb8\\x03k\\xa2\\xab\\x04k\\x97\\xa8\\x02w\\x9e\\xeb\\x00\\x7f\\xa6j\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\x00\\x7f\\xa67\\x00~\\xa5\\x95\\x03v\\x9c\\xd4\\x03h\\x8c\\xfa\\x02i\\x8e\\xf9\\x01x\\x9f\\xcc\\x00\\x7f\\xa6\\x92\\x00\\x7f\\xa63\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00q\\rtq\\x0eb.\', \'ctrl.png\': b\'\\x80\\x03cnumpy.core.multiarray\\n_reconstruct\\nq\\x00cnumpy\\nndarray\\nq\\x01K\\x00\\x85q\\x02C\\x01bq\\x03\\x87q\\x04Rq\\x05(K\\x01K K K\\x04\\x87q\\x06cnumpy\\ndtype\\nq\\x07X\\x02\\x00\\x00\\x00u1q\\x08K\\x00K\\x01\\x87q\\tRq\\n(K\\x03X\\x01\\x00\\x00\\x00|q\\x0bNNNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xffK\\x00tq\\x0cb\\x89B\\x00\\x10\\x00\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xad\\xad\\xad\\x19\\xa8\\xa8\\xa8\\x8d\\xa9\\xa9\\xa9\\xc1\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xaa\\xaa\\xaa\\xc2\\xa9\\xa9\\xa9\\x8e\\xad\\xad\\xad\\x19\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xa8\\xa8\\xa8X\\xa9\\xa9\\xa9\\xed\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xed\\xa8\\xa8\\xa8X\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaaW\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xaa\\xaa\\xaaW\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\xeb\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff)))\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff)))\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xeb\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff\\x03\\x03\\x03\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x03\\x03\\x03\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xbe\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff)))\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff555\\xffPPP\\xff\\x13\\x13\\x13\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff)))\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xbe\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x01\\x01\\x01\\xff\\xb2\\xb2\\xb2\\xff\\xe3\\xe3\\xe3\\xff\\xd9\\xd9\\xd9\\xff]]]\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x13\\x13\\x13\\xff\\xbb\\xbb\\xbb\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xffFFF\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x13\\x13\\x13\\xff\\xbb\\xbb\\xbb\\xff\\xe3\\xe3\\xe3\\xff\\xc4\\xc4\\xc4\\xff\\x06\\x06\\x06\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff```\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff:::\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff666\\xff\\xaf\\xaf\\xaf\\xff\\x10\\x10\\x10\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9b\\x9b\\x9b\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff@@@\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xffSSS\\xff\\xe3\\xe3\\xe3\\xff\\xb7\\xb7\\xb7\\xff\\x10\\x10\\x10\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x04\\x04\\x04\\xff\\xd5\\xd5\\xd5\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xffXXX\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x17\\x17\\x17\\xff\\xdb\\xdb\\xdb\\xff\\xe3\\xe3\\xe3\\xff\\xb7\\xb7\\xb7\\xff[[[\\xff\\x97\\x97\\x97\\xff\\xd4\\xd4\\xd4\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff```\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xffHHH\\xff\\xc6\\xc6\\xc6\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x07\\x07\\x07\\xff;;;\\xffAAA\\xff\\\\\\\\\\\\\\xff\\xdd\\xdd\\xdd\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xdd\\xdd\\xdd\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xdd\\xdd\\xdd\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xdd\\xdd\\xdd\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xdd\\xdd\\xdd\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xdd\\xdd\\xdd\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xdd\\xdd\\xdd\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xda\\xda\\xda\\xff;;;\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xdd\\xdd\\xdd\\xff\\xe3\\xe3\\xe3\\xff\\xe3\\xe3\\xe3\\xff\\xc7\\xc7\\xc7\\xffZZZ\\xff~~~\\xff\\xd9\\xd9\\xd9\\xff\\x10\\x10\\x10\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xdd\\xdd\\xdd\\xff\\xe3\\xe3\\xe3\\xffXXX\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xb0\\xb0\\xb0\\xfffff\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xdd\\xdd\\xdd\\xffyyy\\xff\\x00\\x00\\x00\\xff\\x06\\x06\\x06\\xff\\xcd\\xcd\\xcd\\xfffff\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff@@@\\xff\\xda\\xda\\xda\\xff\\xaf\\xaf\\xaf\\xff\\xcd\\xcd\\xcd\\xff\\xd7\\xd7\\xd7\\xff\\x10\\x10\\x10\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xbd\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff)))\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x12\\x12\\x12\\xffiii\\xffccc\\xff\\x0e\\x0e\\x0e\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff)))\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xbd\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff\\x03\\x03\\x03\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x03\\x03\\x03\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\x88\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\xeb\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff)))\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff)))\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xeb\\xaa\\xaa\\xaa\\x15\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaaW\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xaa\\xaa\\xaaW\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaaW\\xa9\\xa9\\xa9\\xeb\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xeb\\xaa\\xaa\\xaaW\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xbd\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xbe\\xa9\\xa9\\xa9\\x88\\xaa\\xaa\\xaa\\x15\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00q\\rtq\\x0eb.\', \'auto.png\': b\'\\x80\\x03cnumpy.core.multiarray\\n_reconstruct\\nq\\x00cnumpy\\nndarray\\nq\\x01K\\x00\\x85q\\x02C\\x01bq\\x03\\x87q\\x04Rq\\x05(K\\x01K K K\\x04\\x87q\\x06cnumpy\\ndtype\\nq\\x07X\\x02\\x00\\x00\\x00u1q\\x08K\\x00K\\x01\\x87q\\tRq\\n(K\\x03X\\x01\\x00\\x00\\x00|q\\x0bNNNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xffK\\x00tq\\x0cb\\x89B\\x00\\x10\\x00\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xad\\xad\\xad\\x19\\xa8\\xa8\\xa8\\x8d\\xa9\\xa9\\xa9\\xc1\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xaa\\xaa\\xaa\\xc2\\xa9\\xa9\\xa9\\x8e\\xad\\xad\\xad\\x19\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xa8\\xa8\\xa8X\\xa9\\xa9\\xa9\\xed\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xed\\xa8\\xa8\\xa8X\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaaW\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xaa\\xaa\\xaaW\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\xeb\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff)))\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff)))\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xeb\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff\\x03\\x03\\x03\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x19\\x19\\x19\\xff\\x03\\x03\\x03\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xbe\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff)))\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x04\\x04\\x04\\xffHHH\\xff\\xa4\\xa4\\xa4\\xff\\xe5\\xe5\\xe5\\xff\\x00\\x00\\x00\\xff)))\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xbe\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff   \\xffyyy\\xff\\xd1\\xd1\\xd1\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x06\\x06\\x06\\xffPPP\\xff\\xab\\xab\\xab\\xff\\xe6\\xe6\\xe6\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff&&&\\xff\\x82\\x82\\x82\\xff\\xd6\\xd6\\xd6\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\t\\t\\t\\xffWWW\\xff\\xb2\\xb2\\xb2\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe5\\xe5\\xe5\\xff\\xa8\\xa8\\xa8\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff---\\xff\\x89\\x89\\x89\\xff\\xda\\xda\\xda\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xc1\\xc1\\xc1\\xfflll\\xff\\x18\\x18\\x18\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\r\\r\\r\\xff^^^\\xff\\xba\\xba\\xba\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xda\\xda\\xda\\xff...\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff555\\xff\\x90\\x90\\x90\\xff\\xde\\xde\\xde\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe2\\xe2\\xe2\\xff\\xe3\\xe3\\xe3\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xd2\\xd2\\xd2\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff;;;\\xff\\xc1\\xc1\\xc1\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xb7\\xb7\\xb7\\xffbbb\\xff\\x12\\x12\\x12\\xff\\xcb\\xcb\\xcb\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xd2\\xd2\\xd2\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xffmmm\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xcd\\xcd\\xcd\\xffyyy\\xff$$$\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xcb\\xcb\\xcb\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xd2\\xd2\\xd2\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xffmmm\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe3\\xe3\\xe3\\xff\\x91\\x91\\x91\\xff<<<\\xff\\x01\\x01\\x01\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xcb\\xcb\\xcb\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xd2\\xd2\\xd2\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xffmmm\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xc3\\xc3\\xc3\\xfflll\\xff\\x18\\x18\\x18\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xcb\\xcb\\xcb\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xd2\\xd2\\xd2\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xffmmm\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe4\\xe4\\xe4\\xff\\xa6\\xa6\\xa6\\xffOOO\\xff\\x07\\x07\\x07\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\xcb\\xcb\\xcb\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xd2\\xd2\\xd2\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff555\\xff\\xb4\\xb4\\xb4\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xd9\\xd9\\xd9\\xff\\x8a\\x8a\\x8a\\xff333\\xff\\xcb\\xcb\\xcb\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xd2\\xd2\\xd2\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff+++\\xff\\x88\\x88\\x88\\xff\\xda\\xda\\xda\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xd2\\xd2\\xd2\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\n\\n\\n\\xff[[[\\xff\\xb8\\xb8\\xb8\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xdc\\xdc\\xdc\\xffAAA\\xff\\x02\\x02\\x02\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff...\\xff\\x8c\\x8c\\x8c\\xff\\xdc\\xdc\\xdc\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xcc\\xcc\\xcc\\xffsss\\xff\\x1a\\x1a\\x1a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x0c\\x0c\\x0c\\xff___\\xff\\xbc\\xbc\\xbc\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe5\\xe5\\xe5\\xff\\xa5\\xa5\\xa5\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff222\\xff\\x8f\\x8f\\x8f\\xff\\xde\\xde\\xde\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x9a\\x9a\\x9a\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x0e\\x0e\\x0e\\xffccc\\xff\\xc0\\xc0\\xc0\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x9a\\x9a\\x9a\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff555\\xff\\x94\\x94\\x94\\xff\\xe0\\xe0\\xe0\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\xe7\\xe7\\xe7\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xbd\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff)))\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x10\\x10\\x10\\xfffff\\xff\\xc4\\xc4\\xc4\\xff\\xe7\\xe7\\xe7\\xff\\x00\\x00\\x00\\xff)))\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xbd\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff\\x03\\x03\\x03\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff:::\\xff\\x03\\x03\\x03\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\x88\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\xeb\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\x88\\x88\\x88\\xff)))\\xff\\x05\\x05\\x05\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\xff\\x05\\x05\\x05\\xff)))\\xff\\x88\\x88\\x88\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xeb\\xaa\\xaa\\xaa\\x15\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaaW\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa6\\xa6\\xa6\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\x9a\\x9a\\x9a\\xff\\xa6\\xa6\\xa6\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xaa\\xaa\\xaaW\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaaW\\xa9\\xa9\\xa9\\xeb\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xeb\\xaa\\xaa\\xaaW\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xaa\\xaa\\xaa\\x15\\xa9\\xa9\\xa9\\x88\\xa9\\xa9\\xa9\\xbd\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xff\\xa9\\xa9\\xa9\\xf1\\xa9\\xa9\\xa9\\xbe\\xa9\\xa9\\xa9\\x88\\xaa\\xaa\\xaa\\x15\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\x00q\\rtq\\x0eb.\'}'"
src/third_party/pyqtgraph/tests/__init__.py,0,"b'from .image_testing import assertImageApproved, TransposedImageItem\nfrom .ui_testing import resizeWindow, mousePress, mouseMove, mouseRelease, mouseDrag, mouseClick\n'"
src/third_party/pyqtgraph/tests/image_testing.py,16,"b'# Image-based testing borrowed from vispy\n\n""""""\nProcedure for unit-testing with images:\n\n1. Run unit tests at least once; this initializes a git clone of\n   pyqtgraph/test-data in ~/.pyqtgraph.\n\n2. Run individual test scripts with the PYQTGRAPH_AUDIT environment variable set:\n\n       $ PYQTGRAPH_AUDIT=1 python pyqtgraph/graphicsItems/tests/test_PlotCurveItem.py\n\n   Any failing tests will display the test results, standard image, and the\n   differences between the two. If the test result is bad, then press (f)ail.\n   If the test result is good, then press (p)ass and the new image will be\n   saved to the test-data directory.\n   \n   To check all test results regardless of whether the test failed, set the\n   environment variable PYQTGRAPH_AUDIT_ALL=1.\n\n3. After adding or changing test images, create a new commit:\n\n        $ cd ~/.pyqtgraph/test-data\n        $ git add ...\n        $ git commit -a\n\n4. Look up the most recent tag name from the `testDataTag` global variable\n   below. Increment the tag name by 1 and create a new tag in the test-data\n   repository:\n\n        $ git tag test-data-NNN\n        $ git push --tags origin master\n\n    This tag is used to ensure that each pyqtgraph commit is linked to a specific\n    commit in the test-data repository. This makes it possible to push new\n    commits to the test-data repository without interfering with existing\n    tests, and also allows unit tests to continue working on older pyqtgraph\n    versions.\n\n""""""\n\n\n# This is the name of a tag in the test-data repository that this version of\n# pyqtgraph should be tested against. When adding or changing test images,\n# create and push a new tag and update this variable. To test locally, begin\n# by creating the tag in your ~/.pyqtgraph/test-data repository.\ntestDataTag = \'test-data-7\'\n\n\nimport time\nimport os\nimport sys\nimport inspect\nimport base64\nimport subprocess as sp\nimport numpy as np\n\nif sys.version[0] >= \'3\':\n    import http.client as httplib\n    import urllib.parse as urllib\nelse:\n    import httplib\n    import urllib\nfrom ..Qt import QtGui, QtCore, QtTest, QT_LIB\nfrom .. import functions as fn\nfrom .. import GraphicsLayoutWidget\nfrom .. import ImageItem, TextItem\n\n\ntester = None\n\n# Convenient stamp used for ensuring image orientation is correct\naxisImg = [\n    ""            1         1 1        "",\n    ""          1 1         1 1 1 1    "",\n    ""            1   1 1 1 1 1 1 1 1 1"",\n    ""            1         1 1 1 1    "",\n    ""    1     1 1 1       1 1        "",\n    ""  1   1                          "",\n    ""  1   1                          "",\n    ""    1                            "",\n    ""                                 "",\n    ""    1                            "",\n    ""    1                            "",\n    ""    1                            "",\n    ""1 1 1 1 1                        "",\n    ""1 1 1 1 1                        "",\n    ""  1 1 1                          "",\n    ""  1 1 1                          "",\n    ""    1                            "",\n    ""    1                            "",\n]\naxisImg = np.array([map(int, row[::2].replace(\' \', \'0\')) for row in axisImg])\n\n\n\ndef getTester():\n    global tester\n    if tester is None:\n        tester = ImageTester()\n    return tester\n\n\ndef assertImageApproved(image, standardFile, message=None, **kwargs):\n    """"""Check that an image test result matches a pre-approved standard.\n\n    If the result does not match, then the user can optionally invoke a GUI\n    to compare the images and decide whether to fail the test or save the new\n    image as the standard.\n\n    This function will automatically clone the test-data repository into\n    ~/.pyqtgraph/test-data. However, it is up to the user to ensure this repository\n    is kept up to date and to commit/push new images after they are saved.\n\n    Run the test with the environment variable PYQTGRAPH_AUDIT=1 to bring up\n    the auditing GUI.\n\n    Parameters\n    ----------\n    image : (h, w, 4) ndarray\n    standardFile : str\n        The name of the approved test image to check against. This file name\n        is relative to the root of the pyqtgraph test-data repository and will\n        be automatically fetched.\n    message : str\n        A string description of the image. It is recommended to describe\n        specific features that an auditor should look for when deciding whether\n        to fail a test.\n\n    Extra keyword arguments are used to set the thresholds for automatic image\n    comparison (see ``assertImageMatch()``).\n    """"""\n    if isinstance(image, QtGui.QWidget):\n        w = image\n        \n            # just to be sure the widget size is correct (new window may be resized):\n        QtGui.QApplication.processEvents()\n\n        graphstate = scenegraphState(w, standardFile)\n        image = np.zeros((w.height(), w.width(), 4), dtype=np.ubyte)\n        qimg = fn.makeQImage(image, alpha=True, copy=False, transpose=False)\n        painter = QtGui.QPainter(qimg)\n        w.render(painter)\n        painter.end()\n        \n        # transpose BGRA to RGBA\n        image = image[..., [2, 1, 0, 3]]\n\n    if message is None:\n        code = inspect.currentframe().f_back.f_code\n        message = ""%s::%s"" % (code.co_filename, code.co_name)\n\n    # Make sure we have a test data repo available, possibly invoking git\n    dataPath = getTestDataRepo()\n\n    # Read the standard image if it exists\n    stdFileName = os.path.join(dataPath, standardFile + \'.png\')\n    if not os.path.isfile(stdFileName):\n        stdImage = None\n    else:\n        pxm = QtGui.QPixmap()\n        pxm.load(stdFileName)\n        stdImage = fn.imageToArray(pxm.toImage(), copy=True, transpose=False)\n\n    # If the test image does not match, then we go to audit if requested.\n    try:\n        if stdImage is None:\n            raise Exception(""No reference image saved for this test."")\n        if image.shape[2] != stdImage.shape[2]:\n            raise Exception(""Test result has different channel count than standard image""\n                            ""(%d vs %d)"" % (image.shape[2], stdImage.shape[2]))\n        if image.shape != stdImage.shape:\n            # Allow im1 to be an integer multiple larger than im2 to account\n            # for high-resolution displays\n            ims1 = np.array(image.shape).astype(float)\n            ims2 = np.array(stdImage.shape).astype(float)\n            sr = ims1 / ims2 if ims1[0] > ims2[0] else ims2 / ims1\n            if (sr[0] != sr[1] or not np.allclose(sr, np.round(sr)) or\n               sr[0] < 1):\n                raise TypeError(""Test result shape %s is not an integer factor""\n                                    "" different than standard image shape %s."" %\n                                (ims1, ims2))\n            sr = np.round(sr).astype(int)\n            image = fn.downsample(image, sr[0], axis=(0, 1)).astype(image.dtype)\n\n        assertImageMatch(image, stdImage, **kwargs)\n        \n        if bool(os.getenv(\'PYQTGRAPH_PRINT_TEST_STATE\', False)):\n            print(graphstate)\n            \n        if os.getenv(\'PYQTGRAPH_AUDIT_ALL\') == \'1\':\n            raise Exception(""Image test passed, but auditing due to PYQTGRAPH_AUDIT_ALL evnironment variable."")\n    except Exception:\n        if stdFileName in gitStatus(dataPath):\n            print(""\\n\\nWARNING: unit test failed against modified standard ""\n                  ""image %s.\\nTo revert this file, run `cd %s; git checkout ""\n                  ""%s`\\n"" % (stdFileName, dataPath, standardFile))\n        if os.getenv(\'PYQTGRAPH_AUDIT\') == \'1\' or os.getenv(\'PYQTGRAPH_AUDIT_ALL\') == \'1\':\n            sys.excepthook(*sys.exc_info())\n            getTester().test(image, stdImage, message)\n            stdPath = os.path.dirname(stdFileName)\n            print(\'Saving new standard image to ""%s""\' % stdFileName)\n            if not os.path.isdir(stdPath):\n                os.makedirs(stdPath)\n            img = fn.makeQImage(image, alpha=True, transpose=False)\n            img.save(stdFileName)\n        else:\n            if stdImage is None:\n                raise Exception(""Test standard %s does not exist. Set ""\n                                ""PYQTGRAPH_AUDIT=1 to add this image."" % stdFileName)\n            else:\n                if os.getenv(\'TRAVIS\') is not None:\n                    saveFailedTest(image, stdImage, standardFile)\n                print(graphstate)\n                raise\n\n\ndef assertImageMatch(im1, im2, minCorr=None, pxThreshold=50.,\n                       pxCount=-1, maxPxDiff=None, avgPxDiff=None,\n                       imgDiff=None):\n    """"""Check that two images match.\n\n    Images that differ in shape or dtype will fail unconditionally.\n    Further tests for similarity depend on the arguments supplied.\n\n    By default, images may have no pixels that gave a value difference greater\n    than 50.\n\n    Parameters\n    ----------\n    im1 : (h, w, 4) ndarray\n        Test output image\n    im2 : (h, w, 4) ndarray\n        Test standard image\n    minCorr : float or None\n        Minimum allowed correlation coefficient between corresponding image\n        values (see numpy.corrcoef)\n    pxThreshold : float\n        Minimum value difference at which two pixels are considered different\n    pxCount : int or None\n        Maximum number of pixels that may differ. Default is 0 for Qt4 and \n        1% of image size for Qt5.\n    maxPxDiff : float or None\n        Maximum allowed difference between pixels\n    avgPxDiff : float or None\n        Average allowed difference between pixels\n    imgDiff : float or None\n        Maximum allowed summed difference between images\n\n    """"""\n    assert im1.ndim == 3\n    assert im1.shape[2] == 4\n    assert im1.dtype == im2.dtype\n\n    if pxCount == -1:\n        if QT_LIB == \'PyQt5\':\n            # Qt5 generates slightly different results; relax the tolerance\n            # until test images are updated.\n            pxCount = int(im1.shape[0] * im1.shape[1] * 0.01)\n        else:\n            pxCount = 0\n    \n    diff = im1.astype(float) - im2.astype(float)\n    if imgDiff is not None:\n        assert np.abs(diff).sum() <= imgDiff\n\n    pxdiff = diff.max(axis=2)  # largest value difference per pixel\n    mask = np.abs(pxdiff) >= pxThreshold\n    if pxCount is not None:\n        assert mask.sum() <= pxCount\n\n    maskedDiff = diff[mask]\n    if maxPxDiff is not None and maskedDiff.size > 0:\n        assert maskedDiff.max() <= maxPxDiff\n    if avgPxDiff is not None and maskedDiff.size > 0:\n        assert maskedDiff.mean() <= avgPxDiff\n\n    if minCorr is not None:\n        with np.errstate(invalid=\'ignore\'):\n            corr = np.corrcoef(im1.ravel(), im2.ravel())[0, 1]\n        assert corr >= minCorr\n\n\ndef saveFailedTest(data, expect, filename):\n    """"""Upload failed test images to web server to allow CI test debugging.\n    """"""\n    commit = runSubprocess([\'git\', \'rev-parse\',  \'HEAD\'])\n    name = filename.split(\'/\')\n    name.insert(-1, commit.strip())\n    filename = \'/\'.join(name)\n    host = \'data.pyqtgraph.org\'\n\n    # concatenate data, expect, and diff into a single image\n    ds = data.shape\n    es = expect.shape\n\n    shape = (max(ds[0], es[0]) + 4, ds[1] + es[1] + 8 + max(ds[1], es[1]), 4)\n    img = np.empty(shape, dtype=np.ubyte)\n    img[..., :3] = 100\n    img[..., 3] = 255\n\n    img[2:2+ds[0], 2:2+ds[1], :ds[2]] = data\n    img[2:2+es[0], ds[1]+4:ds[1]+4+es[1], :es[2]] = expect\n\n    diff = makeDiffImage(data, expect)\n    img[2:2+diff.shape[0], -diff.shape[1]-2:-2] = diff\n\n    png = makePng(img)\n    \n    conn = httplib.HTTPConnection(host)\n    req = urllib.urlencode({\'name\': filename,\n                            \'data\': base64.b64encode(png)})\n    conn.request(\'POST\', \'/upload.py\', req)\n    response = conn.getresponse().read()\n    conn.close()\n    print(""\\nImage comparison failed. Test result: %s %s   Expected result: ""\n          ""%s %s"" % (data.shape, data.dtype, expect.shape, expect.dtype))\n    print(""Uploaded to: \\nhttp://%s/data/%s"" % (host, filename))\n    if not response.startswith(b\'OK\'):\n        print(""WARNING: Error uploading data to %s"" % host)\n        print(response)\n\n\ndef makePng(img):\n    """"""Given an array like (H, W, 4), return a PNG-encoded byte string.\n    """"""\n    io = QtCore.QBuffer()\n    qim = fn.makeQImage(img.transpose(1, 0, 2), alpha=False)\n    qim.save(io, \'PNG\')\n    png = bytes(io.data().data())\n    return png\n\n\ndef makeDiffImage(im1, im2):\n    """"""Return image array showing the differences between im1 and im2.\n\n    Handles images of different shape. Alpha channels are not compared.\n    """"""\n    ds = im1.shape\n    es = im2.shape\n\n    diff = np.empty((max(ds[0], es[0]), max(ds[1], es[1]), 4), dtype=int)\n    diff[..., :3] = 128\n    diff[..., 3] = 255\n    diff[:ds[0], :ds[1], :min(ds[2], 3)] += im1[..., :3]\n    diff[:es[0], :es[1], :min(es[2], 3)] -= im2[..., :3]\n    diff = np.clip(diff, 0, 255).astype(np.ubyte)\n    return diff\n\n\nclass ImageTester(QtGui.QWidget):\n    """"""Graphical interface for auditing image comparison tests.\n    """"""\n    def __init__(self):\n        self.lastKey = None\n        \n        QtGui.QWidget.__init__(self)\n        self.resize(1200, 800)\n        #self.showFullScreen()\n        \n        self.layout = QtGui.QGridLayout()\n        self.setLayout(self.layout)\n        \n        self.view = GraphicsLayoutWidget()\n        self.layout.addWidget(self.view, 0, 0, 1, 2)\n\n        self.label = QtGui.QLabel()\n        self.layout.addWidget(self.label, 1, 0, 1, 2)\n        self.label.setWordWrap(True)\n        font = QtGui.QFont(""monospace"", 14, QtGui.QFont.Bold)\n        self.label.setFont(font)\n\n        self.passBtn = QtGui.QPushButton(\'Pass\')\n        self.failBtn = QtGui.QPushButton(\'Fail\')\n        self.layout.addWidget(self.passBtn, 2, 0)\n        self.layout.addWidget(self.failBtn, 2, 1)\n        self.passBtn.clicked.connect(self.passTest)\n        self.failBtn.clicked.connect(self.failTest)\n\n        self.views = (self.view.addViewBox(row=0, col=0),\n                      self.view.addViewBox(row=0, col=1),\n                      self.view.addViewBox(row=0, col=2))\n        labelText = [\'test output\', \'standard\', \'diff\']\n        for i, v in enumerate(self.views):\n            v.setAspectLocked(1)\n            v.invertY()\n            v.image = ImageItem(axisOrder=\'row-major\')\n            v.image.setAutoDownsample(True)\n            v.addItem(v.image)\n            v.label = TextItem(labelText[i])\n            v.setBackgroundColor(0.5)\n\n        self.views[1].setXLink(self.views[0])\n        self.views[1].setYLink(self.views[0])\n        self.views[2].setXLink(self.views[0])\n        self.views[2].setYLink(self.views[0])\n\n    def test(self, im1, im2, message):\n        """"""Ask the user to decide whether an image test passes or fails.\n        \n        This method displays the test image, reference image, and the difference\n        between the two. It then blocks until the user selects the test output\n        by clicking a pass/fail button or typing p/f. If the user fails the test,\n        then an exception is raised.\n        """"""\n        self.show()\n        if im2 is None:\n            message += \'\\nImage1: %s %s   Image2: [no standard]\' % (im1.shape, im1.dtype)\n            im2 = np.zeros((1, 1, 3), dtype=np.ubyte)\n        else:\n            message += \'\\nImage1: %s %s   Image2: %s %s\' % (im1.shape, im1.dtype, im2.shape, im2.dtype)\n        self.label.setText(message)\n        \n        self.views[0].image.setImage(im1)\n        self.views[1].image.setImage(im2)\n        diff = makeDiffImage(im1, im2)\n\n        self.views[2].image.setImage(diff)\n        self.views[0].autoRange()\n\n        while True:\n            QtGui.QApplication.processEvents()\n            lastKey = self.lastKey\n            \n            self.lastKey = None\n            if lastKey in (\'f\', \'esc\') or not self.isVisible():\n                raise Exception(""User rejected test result."")\n            elif lastKey == \'p\':\n                break\n            time.sleep(0.03)\n\n        for v in self.views:\n            v.image.setImage(np.zeros((1, 1, 3), dtype=np.ubyte))\n\n    def keyPressEvent(self, event):\n        if event.key() == QtCore.Qt.Key_Escape:\n            self.lastKey = \'esc\'\n        else:\n            self.lastKey = str(event.text()).lower()\n\n    def passTest(self):\n        self.lastKey = \'p\'\n\n    def failTest(self):\n        self.lastKey = \'f\'\n\n\ndef getTestDataRepo():\n    """"""Return the path to a git repository with the required commit checked\n    out.\n\n    If the repository does not exist, then it is cloned from\n    https://github.com/pyqtgraph/test-data. If the repository already exists\n    then the required commit is checked out.\n    """"""\n    global testDataTag\n\n    dataPath = os.path.join(os.path.expanduser(\'~\'), \'.pyqtgraph\', \'test-data\')\n    gitPath = \'https://github.com/pyqtgraph/test-data\'\n    gitbase = gitCmdBase(dataPath)\n\n    if os.path.isdir(dataPath):\n        # Already have a test-data repository to work with.\n\n        # Get the commit ID of testDataTag. Do a fetch if necessary.\n        try:\n            tagCommit = gitCommitId(dataPath, testDataTag)\n        except NameError:\n            cmd = gitbase + [\'fetch\', \'--tags\', \'origin\']\n            print(\' \'.join(cmd))\n            sp.check_call(cmd)\n            try:\n                tagCommit = gitCommitId(dataPath, testDataTag)\n            except NameError:\n                raise Exception(""Could not find tag \'%s\' in test-data repo at""\n                                "" %s"" % (testDataTag, dataPath))\n        except Exception:\n            if not os.path.exists(os.path.join(dataPath, \'.git\')):\n                raise Exception(""Directory \'%s\' does not appear to be a git ""\n                                ""repository. Please remove this directory."" %\n                                dataPath)\n            else:\n                raise\n\n        # If HEAD is not the correct commit, then do a checkout\n        if gitCommitId(dataPath, \'HEAD\') != tagCommit:\n            print(""Checking out test-data tag \'%s\'"" % testDataTag)\n            sp.check_call(gitbase + [\'checkout\', testDataTag])\n\n    else:\n        print(""Attempting to create git clone of test data repo in %s.."" %\n              dataPath)\n\n        parentPath = os.path.split(dataPath)[0]\n        if not os.path.isdir(parentPath):\n            os.makedirs(parentPath)\n\n        if os.getenv(\'TRAVIS\') is not None:\n            # Create a shallow clone of the test-data repository (to avoid\n            # downloading more data than is necessary)\n            os.makedirs(dataPath)\n            cmds = [\n                gitbase + [\'init\'],\n                gitbase + [\'remote\', \'add\', \'origin\', gitPath],\n                gitbase + [\'fetch\', \'--tags\', \'origin\', testDataTag,\n                           \'--depth=1\'],\n                gitbase + [\'checkout\', \'-b\', \'master\', \'FETCH_HEAD\'],\n            ]\n        else:\n            # Create a full clone\n            cmds = [[\'git\', \'clone\', gitPath, dataPath]]\n\n        for cmd in cmds:\n            print(\' \'.join(cmd))\n            rval = sp.check_call(cmd)\n            if rval == 0:\n                continue\n            raise RuntimeError(""Test data path \'%s\' does not exist and could ""\n                               ""not be created with git. Please create a git ""\n                               ""clone of %s at this path."" %\n                               (dataPath, gitPath))\n\n    return dataPath\n\n\ndef gitCmdBase(path):\n    return [\'git\', \'--git-dir=%s/.git\' % path, \'--work-tree=%s\' % path]\n\n\ndef gitStatus(path):\n    """"""Return a string listing all changes to the working tree in a git\n    repository.\n    """"""\n    cmd = gitCmdBase(path) + [\'status\', \'--porcelain\']\n    return runSubprocess(cmd, stderr=None, universal_newlines=True)\n\n\ndef gitCommitId(path, ref):\n    """"""Return the commit id of *ref* in the git repository at *path*.\n    """"""\n    cmd = gitCmdBase(path) + [\'show\', ref]\n    try:\n        output = runSubprocess(cmd, stderr=None, universal_newlines=True)\n    except sp.CalledProcessError:\n        print(cmd)\n        raise NameError(""Unknown git reference \'%s\'"" % ref)\n    commit = output.split(\'\\n\')[0]\n    assert commit[:7] == \'commit \'\n    return commit[7:]\n\n\ndef runSubprocess(command, return_code=False, **kwargs):\n    """"""Run command using subprocess.Popen\n    \n    Similar to subprocess.check_output(), which is not available in 2.6.\n\n    Run command and wait for command to complete. If the return code was zero\n    then return, otherwise raise CalledProcessError.\n    By default, this will also add stdout= and stderr=subproces.PIPE\n    to the call to Popen to suppress printing to the terminal.\n\n    Parameters\n    ----------\n    command : list of str\n        Command to run as subprocess (see subprocess.Popen documentation).\n    **kwargs : dict\n        Additional kwargs to pass to ``subprocess.Popen``.\n\n    Returns\n    -------\n    stdout : str\n        Stdout returned by the process.\n    """"""\n    # code adapted with permission from mne-python\n    use_kwargs = dict(stderr=None, stdout=sp.PIPE)\n    use_kwargs.update(kwargs)\n\n    p = sp.Popen(command, **use_kwargs)\n    output = p.communicate()[0]\n\n    # communicate() may return bytes, str, or None depending on the kwargs\n    # passed to Popen(). Convert all to unicode str:\n    output = \'\' if output is None else output\n    output = output.decode(\'utf-8\') if isinstance(output, bytes) else output\n\n    if p.returncode != 0:\n        print(output)\n        err_fun = sp.CalledProcessError.__init__\n        if \'output\' in inspect.getargspec(err_fun).args:\n            raise sp.CalledProcessError(p.returncode, command, output)\n        else:\n            raise sp.CalledProcessError(p.returncode, command)\n    \n    return output\n\n\ndef scenegraphState(view, name):\n    """"""Return information about the scenegraph for debugging test failures.\n    """"""\n    state = ""====== Scenegraph state for %s ======\\n"" % name\n    state += ""view size: %dx%d\\n"" % (view.width(), view.height())\n    state += ""view transform:\\n"" + indent(transformStr(view.transform()), ""  "")\n    for item in view.scene().items():\n        if item.parentItem() is None:\n            state += itemState(item) + \'\\n\'\n    return state\n\n    \ndef itemState(root):\n    state = str(root) + \'\\n\'\n    from .. import ViewBox\n    state += \'bounding rect: \' + str(root.boundingRect()) + \'\\n\'\n    if isinstance(root, ViewBox):\n        state += ""view range: "" + str(root.viewRange()) + \'\\n\'\n    state += ""transform:\\n"" + indent(transformStr(root.transform()).strip(), ""  "") + \'\\n\'\n    for item in root.childItems():\n        state += indent(itemState(item).strip(), ""    "") + \'\\n\'\n    return state\n\n    \ndef transformStr(t):\n    return (""[%0.2f %0.2f %0.2f]\\n""*3) % (t.m11(), t.m12(), t.m13(), t.m21(), t.m22(), t.m23(), t.m31(), t.m32(), t.m33())\n\n\ndef indent(s, pfx):\n    return \'\\n\'.join([pfx+line for line in s.split(\'\\n\')])\n\n\nclass TransposedImageItem(ImageItem):\n    # used for testing image axis order; we can test row-major and col-major using\n    # the same test images\n    def __init__(self, *args, **kwds):\n        self.__transpose = kwds.pop(\'transpose\', False)\n        ImageItem.__init__(self, *args, **kwds)\n    def setImage(self, image=None, **kwds):\n        if image is not None and self.__transpose is True:\n            image = np.swapaxes(image, 0, 1)\n        return ImageItem.setImage(self, image, **kwds)\n'"
src/third_party/pyqtgraph/tests/test_exit_crash.py,0,"b'import os, sys, subprocess, tempfile\nimport pyqtgraph as pg\nimport six\nimport pytest\n\ncode = """"""\nimport sys\nsys.path.insert(0, \'{path}\')\nimport pyqtgraph as pg\napp = pg.mkQApp()\nw = pg.{classname}({args})\n""""""\n\nskipmessage = (\'unclear why this test is failing. skipping until someone has\'\n               \' time to fix it\')\n\n@pytest.mark.skipif(True, reason=skipmessage)\ndef test_exit_crash():\n    # For each Widget subclass, run a simple python script that creates an\n    # instance and then shuts down. The intent is to check for segmentation\n    # faults when each script exits.\n    tmp = tempfile.mktemp("".py"")\n    path = os.path.dirname(pg.__file__)\n\n    initArgs = {\n        \'CheckTable\': ""[]"",\n        \'ProgressDialog\': \'""msg""\',\n        \'VerticalLabel\': \'""msg""\',\n    }\n\n    for name in dir(pg):\n        obj = getattr(pg, name)\n        if not isinstance(obj, type) or not issubclass(obj, pg.QtGui.QWidget):\n            continue\n\n        print(name)\n        argstr = initArgs.get(name, """")\n        open(tmp, \'w\').write(code.format(path=path, classname=name, args=argstr))\n        proc = subprocess.Popen([sys.executable, tmp])\n        assert proc.wait() == 0\n\n    os.remove(tmp)\n'"
src/third_party/pyqtgraph/tests/test_functions.py,83,"b'import pyqtgraph as pg\nimport numpy as np\nimport sys\nfrom numpy.testing import assert_array_almost_equal, assert_almost_equal\nimport pytest\n\nnp.random.seed(12345)\n\ndef testSolve3D():\n    p1 = np.array([[0,0,0,1],\n                   [1,0,0,1],\n                   [0,1,0,1],\n                   [0,0,1,1]], dtype=float)\n    \n    # transform points through random matrix\n    tr = np.random.normal(size=(4, 4))\n    tr[3] = (0,0,0,1)\n    p2 = np.dot(tr, p1.T).T[:,:3]\n    \n    # solve to see if we can recover the transformation matrix.\n    tr2 = pg.solve3DTransform(p1, p2)\n    \n    assert_array_almost_equal(tr[:3], tr2[:3])\n\n\ndef test_interpolateArray_order0():\n    check_interpolateArray(order=0)\n\n\ndef test_interpolateArray_order1():\n    check_interpolateArray(order=1)\n\n\ndef check_interpolateArray(order):\n    def interpolateArray(data, x):\n        result = pg.interpolateArray(data, x, order=order)\n        assert result.shape == x.shape[:-1] + data.shape[x.shape[-1]:]\n        return result\n    \n    data = np.array([[ 1.,   2.,   4.  ],\n                     [ 10.,  20.,  40. ],\n                     [ 100., 200., 400.]])\n    \n    # test various x shapes\n    interpolateArray(data, np.ones((1,)))\n    interpolateArray(data, np.ones((2,)))\n    interpolateArray(data, np.ones((1, 1)))\n    interpolateArray(data, np.ones((1, 2)))\n    interpolateArray(data, np.ones((5, 1)))\n    interpolateArray(data, np.ones((5, 2)))\n    interpolateArray(data, np.ones((5, 5, 1)))\n    interpolateArray(data, np.ones((5, 5, 2)))\n    with pytest.raises(TypeError):\n        interpolateArray(data, np.ones((3,)))\n    with pytest.raises(TypeError):\n        interpolateArray(data, np.ones((1, 3,)))\n    with pytest.raises(TypeError):\n        interpolateArray(data, np.ones((5, 5, 3,)))\n    \n    x = np.array([[  0.3,   0.6],\n                  [  1. ,   1. ],\n                  [  0.501,   1. ],   # NOTE: testing at exactly 0.5 can yield different results from map_coordinates\n                  [  0.501,   2.501],  # due to differences in rounding\n                  [ 10. ,  10. ]])\n    \n    result = interpolateArray(data, x)\n    # make sure results match ndimage.map_coordinates\n    import scipy.ndimage\n    spresult = scipy.ndimage.map_coordinates(data, x.T, order=order)\n    #spresult = np.array([  5.92,  20.  ,  11.  ,   0.  ,   0.  ])  # generated with the above line\n    \n    assert_array_almost_equal(result, spresult)\n    \n    # test mapping when x.shape[-1] < data.ndim\n    x = np.array([[  0.3,   0],\n                  [  0.3,   1],\n                  [  0.3,   2]])\n    r1 = interpolateArray(data, x)\n    x = np.array([0.3])  # should broadcast across axis 1\n    r2 = interpolateArray(data, x)\n    \n    assert_array_almost_equal(r1, r2)\n    \n    \n    # test mapping 2D array of locations\n    x = np.array([[[0.501, 0.501], [0.501, 1.0], [0.501, 1.501]],\n                  [[1.501, 0.501], [1.501, 1.0], [1.501, 1.501]]])\n    \n    r1 = interpolateArray(data, x)\n    r2 = scipy.ndimage.map_coordinates(data, x.transpose(2,0,1), order=order)\n    #r2 = np.array([[   8.25,   11.  ,   16.5 ],  # generated with the above line\n                   #[  82.5 ,  110.  ,  165.  ]])\n\n    assert_array_almost_equal(r1, r2)\n    \n    \ndef test_subArray():\n    a = np.array([0, 0, 111, 112, 113, 0, 121, 122, 123, 0, 0, 0, 211, 212, 213, 0, 221, 222, 223, 0, 0, 0, 0])\n    b = pg.subArray(a, offset=2, shape=(2,2,3), stride=(10,4,1))\n    c = np.array([[[111,112,113], [121,122,123]], [[211,212,213], [221,222,223]]])\n    assert np.all(b == c)\n    \n    # operate over first axis; broadcast over the rest\n    aa = np.vstack([a, a/100.]).T\n    cc = np.empty(c.shape + (2,))\n    cc[..., 0] = c\n    cc[..., 1] = c / 100.\n    bb = pg.subArray(aa, offset=2, shape=(2,2,3), stride=(10,4,1))\n    assert np.all(bb == cc)\n    \n    \ndef test_rescaleData():\n    dtypes = map(np.dtype, (\'ubyte\', \'uint16\', \'byte\', \'int16\', \'int\', \'float\'))\n    for dtype1 in dtypes:\n        for dtype2 in dtypes:\n            data = (np.random.random(size=10) * 2**32 - 2**31).astype(dtype1)\n            for scale, offset in [(10, 0), (10., 0.), (1, -50), (0.2, 0.5), (0.001, 0)]:\n                if dtype2.kind in \'iu\':\n                    lim = np.iinfo(dtype2)\n                    lim = lim.min, lim.max\n                else:\n                    lim = (-np.inf, np.inf)\n                s1 = np.clip(float(scale) * (data-float(offset)), *lim).astype(dtype2)\n                s2 = pg.rescaleData(data, scale, offset, dtype2)\n                assert s1.dtype == s2.dtype\n                if dtype2.kind in \'iu\':\n                    assert np.all(s1 == s2)\n                else:\n                    assert np.allclose(s1, s2)\n\n\ndef test_makeARGB():\n    # Many parameters to test here:\n    #  * data dtype (ubyte, uint16, float, others)\n    #  * data ndim (2 or 3)\n    #  * levels (None, 1D, or 2D)\n    #  * lut dtype\n    #  * lut size\n    #  * lut ndim (1 or 2)\n    #  * useRGBA argument\n    # Need to check that all input values map to the correct output values, especially\n    # at and beyond the edges of the level range.\n\n    def checkArrays(a, b):\n        # because py.test output is difficult to read for arrays\n        if not np.all(a == b):\n            comp = []\n            for i in range(a.shape[0]):\n                if a.shape[1] > 1:\n                    comp.append(\'[\')\n                for j in range(a.shape[1]):\n                    m = a[i,j] == b[i,j]\n                    comp.append(\'%d,%d  %s %s  %s%s\' % \n                                (i, j, str(a[i,j]).ljust(15), str(b[i,j]).ljust(15),\n                                 m, \' ********\' if not np.all(m) else \'\'))\n                if a.shape[1] > 1:\n                    comp.append(\']\')\n            raise Exception(""arrays do not match:\\n%s"" % \'\\n\'.join(comp))\n    \n    def checkImage(img, check, alpha, alphaCheck):\n        assert img.dtype == np.ubyte\n        assert alpha is alphaCheck\n        if alpha is False:\n            checkArrays(img[..., 3], 255)\n        \n        if np.isscalar(check) or check.ndim == 3:\n            checkArrays(img[..., :3], check)\n        elif check.ndim == 2:\n            checkArrays(img[..., :3], check[..., np.newaxis])\n        elif check.ndim == 1:\n            checkArrays(img[..., :3], check[..., np.newaxis, np.newaxis])\n        else:\n            raise Exception(\'invalid check array ndim\')\n        \n    # uint8 data tests\n    \n    im1 = np.arange(256).astype(\'ubyte\').reshape(256, 1)\n    im2, alpha = pg.makeARGB(im1, levels=(0, 255))\n    checkImage(im2, im1, alpha, False)\n    \n    im3, alpha = pg.makeARGB(im1, levels=(0.0, 255.0))\n    checkImage(im3, im1, alpha, False)\n\n    im4, alpha = pg.makeARGB(im1, levels=(255, 0))\n    checkImage(im4, 255-im1, alpha, False)\n    \n    im5, alpha = pg.makeARGB(np.concatenate([im1]*3, axis=1), levels=[(0, 255), (0.0, 255.0), (255, 0)])\n    checkImage(im5, np.concatenate([im1, im1, 255-im1], axis=1), alpha, False)\n    \n\n    im2, alpha = pg.makeARGB(im1, levels=(128,383))\n    checkImage(im2[:128], 0, alpha, False)\n    checkImage(im2[128:], im1[:128], alpha, False)\n    \n\n    # uint8 data + uint8 LUT\n    lut = np.arange(256)[::-1].astype(np.uint8)\n    im2, alpha = pg.makeARGB(im1, lut=lut)\n    checkImage(im2, lut, alpha, False)\n    \n    # lut larger than maxint\n    lut = np.arange(511).astype(np.uint8)\n    im2, alpha = pg.makeARGB(im1, lut=lut)\n    checkImage(im2, lut[::2], alpha, False)\n    \n    # lut smaller than maxint\n    lut = np.arange(128).astype(np.uint8)\n    im2, alpha = pg.makeARGB(im1, lut=lut)\n    checkImage(im2, np.linspace(0, 127, 256).astype(\'ubyte\'), alpha, False)\n\n    # lut + levels\n    lut = np.arange(256)[::-1].astype(np.uint8)\n    im2, alpha = pg.makeARGB(im1, lut=lut, levels=[-128, 384])\n    checkImage(im2, np.linspace(192, 65.5, 256).astype(\'ubyte\'), alpha, False)\n    \n    im2, alpha = pg.makeARGB(im1, lut=lut, levels=[64, 192])\n    checkImage(im2, np.clip(np.linspace(385.5, -126.5, 256), 0, 255).astype(\'ubyte\'), alpha, False)\n\n    # uint8 data + uint16 LUT\n    lut = np.arange(4096)[::-1].astype(np.uint16) // 16\n    im2, alpha = pg.makeARGB(im1, lut=lut)\n    checkImage(im2, np.arange(256)[::-1].astype(\'ubyte\'), alpha, False)\n\n    # uint8 data + float LUT\n    lut = np.linspace(10., 137., 256)\n    im2, alpha = pg.makeARGB(im1, lut=lut)\n    checkImage(im2, lut.astype(\'ubyte\'), alpha, False)\n\n    # uint8 data + 2D LUT\n    lut = np.zeros((256, 3), dtype=\'ubyte\')\n    lut[:,0] = np.arange(256)\n    lut[:,1] = np.arange(256)[::-1]\n    lut[:,2] = 7\n    im2, alpha = pg.makeARGB(im1, lut=lut)\n    checkImage(im2, lut[:,None,::-1], alpha, False)\n    \n    # check useRGBA\n    im2, alpha = pg.makeARGB(im1, lut=lut, useRGBA=True)\n    checkImage(im2, lut[:,None,:], alpha, False)\n\n    \n    # uint16 data tests\n    im1 = np.arange(0, 2**16, 256).astype(\'uint16\')[:, None]\n    im2, alpha = pg.makeARGB(im1, levels=(512, 2**16))\n    checkImage(im2, np.clip(np.linspace(-2, 253, 256), 0, 255).astype(\'ubyte\'), alpha, False)\n\n    lut = (np.arange(512, 2**16)[::-1] // 256).astype(\'ubyte\')\n    im2, alpha = pg.makeARGB(im1, lut=lut, levels=(512, 2**16-256))\n    checkImage(im2, np.clip(np.linspace(257, 2, 256), 0, 255).astype(\'ubyte\'), alpha, False)\n\n    lut = np.zeros(2**16, dtype=\'ubyte\')\n    lut[1000:1256] = np.arange(256)\n    lut[1256:] = 255\n    im1 = np.arange(1000, 1256).astype(\'uint16\')[:, None]\n    im2, alpha = pg.makeARGB(im1, lut=lut)\n    checkImage(im2, np.arange(256).astype(\'ubyte\'), alpha, False)\n    \n    \n    \n    # float data tests\n    im1 = np.linspace(1.0, 17.0, 256)[:, None]\n    im2, alpha = pg.makeARGB(im1, levels=(5.0, 13.0))\n    checkImage(im2, np.clip(np.linspace(-128, 383, 256), 0, 255).astype(\'ubyte\'), alpha, False)\n    \n    lut = (np.arange(1280)[::-1] // 10).astype(\'ubyte\')\n    im2, alpha = pg.makeARGB(im1, lut=lut, levels=(1, 17))\n    checkImage(im2, np.linspace(127.5, 0, 256).astype(\'ubyte\'), alpha, False)\n\n\n    # test sanity checks\n    class AssertExc(object):\n        def __init__(self, exc=Exception):\n            self.exc = exc\n        def __enter__(self):\n            return self\n        def __exit__(self, *args):\n            assert args[0] is self.exc, ""Should have raised %s (got %s)"" % (self.exc, args[0])\n            return True\n    \n    with AssertExc(TypeError):  # invalid image shape\n        pg.makeARGB(np.zeros((2,), dtype=\'float\'))\n    with AssertExc(TypeError):  # invalid image shape\n        pg.makeARGB(np.zeros((2,2,7), dtype=\'float\'))\n    with AssertExc():  # float images require levels arg\n        pg.makeARGB(np.zeros((2,2), dtype=\'float\'))\n    with AssertExc():  # bad levels arg\n        pg.makeARGB(np.zeros((2,2), dtype=\'float\'), levels=[1])\n    with AssertExc():  # bad levels arg\n        pg.makeARGB(np.zeros((2,2), dtype=\'float\'), levels=[1,2,3])\n    with AssertExc():  # can\'t mix 3-channel levels and LUT\n        pg.makeARGB(np.zeros((2,2)), lut=np.zeros((10,3), dtype=\'ubyte\'), levels=[(0,1)]*3)\n    with AssertExc():  # multichannel levels must have same number of channels as image\n        pg.makeARGB(np.zeros((2,2,3), dtype=\'float\'), levels=[(1,2)]*4)\n    with AssertExc():  # 3d levels not allowed\n        pg.makeARGB(np.zeros((2,2,3), dtype=\'float\'), levels=np.zeros([3, 2, 2]))\n\n\ndef test_eq():\n    eq = pg.functions.eq\n    \n    zeros = [0, 0.0, np.float(0), np.int(0)]\n    if sys.version[0] < \'3\':\n        zeros.append(long(0))\n    for i,x in enumerate(zeros):\n        for y in zeros[i:]:\n            assert eq(x, y)\n            assert eq(y, x)\n    \n    assert eq(np.nan, np.nan)\n    \n    # test \n    class NotEq(object):\n        def __eq__(self, x):\n            return False\n        \n    noteq = NotEq()\n    assert eq(noteq, noteq) # passes because they are the same object\n    assert not eq(noteq, NotEq())\n\n\n    # Should be able to test for equivalence even if the test raises certain\n    # exceptions\n    class NoEq(object):\n        def __init__(self, err):\n            self.err = err\n        def __eq__(self, x):\n            raise self.err\n        \n    noeq1 = NoEq(AttributeError())\n    noeq2 = NoEq(ValueError())\n    noeq3 = NoEq(Exception())\n    \n    assert eq(noeq1, noeq1)\n    assert not eq(noeq1, noeq2)\n    assert not eq(noeq2, noeq1)\n    with pytest.raises(Exception):\n        eq(noeq3, noeq2)\n\n    # test array equivalence\n    # note that numpy has a weird behavior here--np.all() always returns True\n    # if one of the arrays has size=0; eq() will only return True if both arrays\n    # have the same shape.\n    a1 = np.zeros((10, 20)).astype(\'float\')\n    a2 = a1 + 1\n    a3 = a2.astype(\'int\')\n    a4 = np.empty((0, 20))\n    assert not eq(a1, a2)  # same shape/dtype, different values\n    assert not eq(a1, a3)  # same shape, different dtype and values\n    assert not eq(a1, a4)  # different shape (note: np.all gives True if one array has size 0)\n\n    assert not eq(a2, a3)  # same values, but different dtype\n    assert not eq(a2, a4)  # different shape\n    \n    assert not eq(a3, a4)  # different shape and dtype\n    \n    assert eq(a4, a4.copy())\n    assert not eq(a4, a4.T)\n\n    \nif __name__ == \'__main__\':\n    test_interpolateArray()'"
src/third_party/pyqtgraph/tests/test_qt.py,0,"b""import pyqtgraph as pg\nimport gc, os\nimport pytest\n\n\napp = pg.mkQApp()\n\ndef test_isQObjectAlive():\n    o1 = pg.QtCore.QObject()\n    o2 = pg.QtCore.QObject()\n    o2.setParent(o1)\n    del o1\n    gc.collect()\n    assert not pg.Qt.isQObjectAlive(o2)\n\n@pytest.mark.skipif(pg.Qt.QT_LIB == 'PySide', reason='pysideuic does not appear to be '\n                                                     'packaged with conda')\ndef test_loadUiType():\n    path = os.path.dirname(__file__)\n    formClass, baseClass = pg.Qt.loadUiType(os.path.join(path, 'uictest.ui'))\n    w = baseClass()\n    ui = formClass()\n    ui.setupUi(w)\n    w.show()\n    app.processEvents()\n"""
src/third_party/pyqtgraph/tests/test_ref_cycles.py,2,"b'""""""\nTest for unwanted reference cycles\n\n""""""\nimport pyqtgraph as pg\nimport numpy as np\nimport gc, weakref\nimport six\nimport pytest\napp = pg.mkQApp()\n\nskipreason = (\'unclear why test is failing on python 3. skipping until someone \'\n              \'has time to fix it. Or pyside is being used. This test is \'\n              \'failing on pyside for an unknown reason too.\')\n                 \ndef assert_alldead(refs):\n    for ref in refs:\n        assert ref() is None\n\ndef qObjectTree(root):\n    """"""Return root and its entire tree of qobject children""""""\n    childs = [root]\n    for ch in pg.QtCore.QObject.children(root):\n        childs += qObjectTree(ch)\n    return childs\n\ndef mkrefs(*objs):\n    """"""Return a list of weakrefs to each object in *objs.\n    QObject instances are expanded to include all child objects.\n    """"""\n    allObjs = {}\n    for obj in objs:\n        if isinstance(obj, pg.QtCore.QObject):\n            obj = qObjectTree(obj)\n        else:\n            obj = [obj]\n        for o in obj:\n            allObjs[id(o)] = o\n            \n    return map(weakref.ref, allObjs.values())\n\n\n@pytest.mark.skipif(six.PY3 or pg.Qt.QT_LIB == \'PySide\', reason=skipreason)\ndef test_PlotWidget():\n    def mkobjs(*args, **kwds):\n        w = pg.PlotWidget(*args, **kwds)\n        data = pg.np.array([1,5,2,4,3])\n        c = w.plot(data, name=\'stuff\')\n        w.addLegend()\n        \n        # test that connections do not keep objects alive\n        w.plotItem.vb.sigRangeChanged.connect(mkrefs)\n        app.focusChanged.connect(w.plotItem.vb.invertY)\n        \n        # return weakrefs to a bunch of objects that should die when the scope exits.\n        return mkrefs(w, c, data, w.plotItem, w.plotItem.vb, w.plotItem.getMenu(), w.plotItem.getAxis(\'left\'))\n    \n    for i in range(5):\n        assert_alldead(mkobjs())\n    \n@pytest.mark.skipif(six.PY3 or pg.Qt.QT_LIB == \'PySide\', reason=skipreason)\ndef test_ImageView():\n    def mkobjs():\n        iv = pg.ImageView()\n        data = np.zeros((10,10,5))\n        iv.setImage(data)\n        \n        return mkrefs(iv, iv.imageItem, iv.view, iv.ui.histogram, data)\n    \n    for i in range(5):\n        assert_alldead(mkobjs())\n\n\n@pytest.mark.skipif(six.PY3 or pg.Qt.QT_LIB == \'PySide\', reason=skipreason)\ndef test_GraphicsWindow():\n    def mkobjs():\n        w = pg.GraphicsWindow()\n        p1 = w.addPlot()\n        v1 = w.addViewBox()\n        return mkrefs(w, p1, v1)\n    \n    for i in range(5):\n        assert_alldead(mkobjs())\n\n    \n    \nif __name__ == \'__main__\':\n    ot = test_PlotItem()\n'"
src/third_party/pyqtgraph/tests/test_reload.py,0,"b'import tempfile, os, sys, shutil\nimport pyqtgraph as pg\nimport pyqtgraph.reload\n\n\npgpath = os.path.join(os.path.dirname(pg.__file__), \'..\')\n\n# make temporary directory to write module code\npath = None\n\ndef setup_module():\n    # make temporary directory to write module code\n    global path\n    path = tempfile.mkdtemp()\n    sys.path.insert(0, path)\n\ndef teardown_module():\n    global path\n    shutil.rmtree(path)\n    sys.path.remove(path)\n\n\ncode = """"""\nimport sys\nsys.path.append(\'{path}\')\n\nimport pyqtgraph as pg\n\nclass C(pg.QtCore.QObject):\n    sig = pg.QtCore.Signal()\n    def fn(self):\n        print(""{msg}"")\n\n""""""\n\ndef remove_cache(mod):\n    if os.path.isfile(mod+\'c\'):\n        os.remove(mod+\'c\')\n    cachedir = os.path.join(os.path.dirname(mod), \'__pycache__\')\n    if os.path.isdir(cachedir):\n        shutil.rmtree(cachedir)\n\n\ndef test_reload():\n    py3 = sys.version_info >= (3,)\n\n    # write a module\n    mod = os.path.join(path, \'reload_test_mod.py\')\n    print(""\\nRELOAD FILE:"", mod)\n    open(mod, \'w\').write(code.format(path=pgpath, msg=""C.fn() Version1""))\n\n    # import the new module\n    import reload_test_mod\n    print(""RELOAD MOD:"", reload_test_mod.__file__)\n\n    c = reload_test_mod.C()\n    c.sig.connect(c.fn)\n    if py3:\n        v1 = (reload_test_mod.C, reload_test_mod.C.sig, reload_test_mod.C.fn, c.sig, c.fn, c.fn.__func__)\n    else:\n        v1 = (reload_test_mod.C, reload_test_mod.C.sig, reload_test_mod.C.fn, reload_test_mod.C.fn.__func__, c.sig, c.fn, c.fn.__func__)\n\n\n\n    # write again and reload\n    open(mod, \'w\').write(code.format(path=pgpath, msg=""C.fn() Version2""))\n    remove_cache(mod)\n    pg.reload.reloadAll(path, debug=True)\n    if py3:\n        v2 = (reload_test_mod.C, reload_test_mod.C.sig, reload_test_mod.C.fn, c.sig, c.fn, c.fn.__func__)\n    else:\n        v2 = (reload_test_mod.C, reload_test_mod.C.sig, reload_test_mod.C.fn, reload_test_mod.C.fn.__func__, c.sig, c.fn, c.fn.__func__)\n\n    if not py3:\n        assert c.fn.im_class is v2[0]\n    oldcfn = pg.reload.getPreviousVersion(c.fn)\n    if oldcfn is None:\n        # Function did not reload; are we using pytest\'s assertion rewriting?\n        raise Exception(""Function did not reload. (This can happen when using py.test""\n            "" with assertion rewriting; use --assert=plain for this test.)"")\n    if py3:\n        assert oldcfn.__func__ is v1[2]\n    else:\n        assert oldcfn.im_class is v1[0]\n        assert oldcfn.__func__ is v1[2].__func__\n    assert oldcfn.__self__ is c\n\n\n    # write again and reload\n    open(mod, \'w\').write(code.format(path=pgpath, msg=""C.fn() Version2""))\n    remove_cache(mod)\n    pg.reload.reloadAll(path, debug=True)\n    if py3:\n        v3 = (reload_test_mod.C, reload_test_mod.C.sig, reload_test_mod.C.fn, c.sig, c.fn, c.fn.__func__)\n    else:\n        v3 = (reload_test_mod.C, reload_test_mod.C.sig, reload_test_mod.C.fn, reload_test_mod.C.fn.__func__, c.sig, c.fn, c.fn.__func__)\n\n    #for i in range(len(old)):\n        #print id(old[i]), id(new1[i]), id(new2[i]), old[i], new1[i]\n\n    cfn1 = pg.reload.getPreviousVersion(c.fn)\n    cfn2 = pg.reload.getPreviousVersion(cfn1)\n\n    if py3:\n        assert cfn1.__func__ is v2[2]\n        assert cfn2.__func__ is v1[2]\n    else:\n        assert cfn1.__func__ is v2[2].__func__\n        assert cfn2.__func__ is v1[2].__func__\n        assert cfn1.im_class is v2[0]\n        assert cfn2.im_class is v1[0]\n    assert cfn1.__self__ is c\n    assert cfn2.__self__ is c\n\n    pg.functions.disconnect(c.sig, c.fn)\n\n'"
src/third_party/pyqtgraph/tests/test_srttransform3d.py,2,"b'import pyqtgraph as pg\nfrom pyqtgraph.Qt import QtCore, QtGui\nimport numpy as np\nfrom numpy.testing import assert_array_almost_equal, assert_almost_equal\n\ntestPoints = np.array([\n                       [0, 0, 0],\n                       [1, 0, 0],\n                       [0, 1, 0],\n                       [0, 0, 1],\n                       [-1, -1, 0],\n                       [0, -1, -1]])\n\n\ndef testMatrix():\n    """"""\n    SRTTransform3D => Transform3D => SRTTransform3D\n    """"""\n    tr = pg.SRTTransform3D()\n    tr.setRotate(45, (0, 0, 1))\n    tr.setScale(0.2, 0.4, 1)\n    tr.setTranslate(10, 20, 40)\n    assert tr.getRotation() == (45, QtGui.QVector3D(0, 0, 1))\n    assert tr.getScale() == QtGui.QVector3D(0.2, 0.4, 1)\n    assert tr.getTranslation() == QtGui.QVector3D(10, 20, 40)\n\n    tr2 = pg.Transform3D(tr)\n    assert np.all(tr.matrix() == tr2.matrix())\n    \n    # This is the most important test:\n    # The transition from Transform3D to SRTTransform3D is a tricky one.\n    tr3 = pg.SRTTransform3D(tr2)\n    assert_array_almost_equal(tr.matrix(), tr3.matrix())\n    assert_almost_equal(tr3.getRotation()[0], tr.getRotation()[0])\n    assert_array_almost_equal(tr3.getRotation()[1], tr.getRotation()[1])\n    assert_array_almost_equal(tr3.getScale(), tr.getScale())\n    assert_array_almost_equal(tr3.getTranslation(), tr.getTranslation())\n\n\n'"
src/third_party/pyqtgraph/tests/test_stability.py,0,"b'""""""\nPyQt/PySide stress test:\n\nCreate lots of random widgets and graphics items, connect them together randomly,\nthe tear them down repeatedly. \n\nThe purpose of this is to attempt to generate segmentation faults.\n""""""\nfrom pyqtgraph.Qt import QtTest\nimport pyqtgraph as pg\nfrom random import seed, randint\nimport sys, gc, weakref\n\napp = pg.mkQApp()\n\nseed(12345)\n\nwidgetTypes = [\n    pg.PlotWidget, \n    pg.ImageView, \n    pg.GraphicsView, \n    pg.QtGui.QWidget,\n    pg.QtGui.QTreeWidget, \n    pg.QtGui.QPushButton,\n    ]\n\nitemTypes = [\n    pg.PlotCurveItem, \n    pg.ImageItem, \n    pg.PlotDataItem, \n    pg.ViewBox,\n    pg.QtGui.QGraphicsRectItem\n    ]\n\nwidgets = []\nitems = []\nallWidgets = weakref.WeakKeyDictionary()\n\n\ndef crashtest():\n    global allWidgets\n    try:\n        gc.disable()\n        actions = [\n                createWidget,\n                #setParent,\n                forgetWidget,\n                showWidget,\n                processEvents,\n                #raiseException,\n                #addReference,\n                ]\n\n        thread = WorkThread()\n        thread.start()\n\n        while True:\n            try:\n                action = randItem(actions)\n                action()\n                print(\'[%d widgets alive, %d zombie]\' % (len(allWidgets), len(allWidgets) - len(widgets)))\n            except KeyboardInterrupt:\n                print(""Caught interrupt; send another to exit."")\n                try:\n                    for i in range(100):\n                        QtTest.QTest.qWait(100)\n                except KeyboardInterrupt:\n                    thread.terminate()\n                    break\n            except:\n                sys.excepthook(*sys.exc_info())\n    finally:\n        gc.enable()\n\n\n\nclass WorkThread(pg.QtCore.QThread):\n    \'\'\'Intended to give the gc an opportunity to run from a non-gui thread.\'\'\'\n    def run(self):\n        i = 0\n        while True:\n            i += 1\n            if (i % 1000000) == 0:\n                print(\'--worker--\')\n            \n\ndef randItem(items):\n    return items[randint(0, len(items)-1)]\n\ndef p(msg):\n    print(msg)\n    sys.stdout.flush()\n\ndef createWidget():\n    p(\'create widget\')\n    global widgets, allWidgets\n    if len(widgets) > 50:\n        return\n    widget = randItem(widgetTypes)()\n    widget.setWindowTitle(widget.__class__.__name__)\n    widgets.append(widget)\n    allWidgets[widget] = 1\n    p(""    %s"" % widget)\n    return widget\n\ndef setParent():\n    p(\'set parent\')\n    global widgets\n    if len(widgets) < 2:\n        return\n    child = parent = None\n    while child is parent:\n        child = randItem(widgets)\n        parent = randItem(widgets)\n    p(""    %s parent of %s"" % (parent, child))\n    child.setParent(parent)\n\ndef forgetWidget():\n    p(\'forget widget\')\n    global widgets\n    if len(widgets) < 1:\n        return\n    widget = randItem(widgets)\n    p(\'    %s\' % widget)\n    widgets.remove(widget)\n\ndef showWidget():\n    p(\'show widget\')\n    global widgets\n    if len(widgets) < 1:\n        return\n    widget = randItem(widgets)\n    p(\'    %s\' % widget)\n    widget.show()\n\ndef processEvents():\n    p(\'process events\')\n    QtTest.QTest.qWait(25)\n\nclass TstException(Exception):\n    pass\n\ndef raiseException():\n    p(\'raise exception\')\n    raise TstException(""A test exception"")\n\ndef addReference():\n    p(\'add reference\')\n    global widgets\n    if len(widgets) < 1:\n        return\n    obj1 = randItem(widgets)\n    obj2 = randItem(widgets)\n    p(\'    %s -> %s\' % (obj1, obj2))    \n    obj1._testref = obj2\n    \n\n        \nif __name__ == \'__main__\':\n    test_stability()\n'"
src/third_party/pyqtgraph/tests/ui_testing.py,0,"b'import time\nfrom ..Qt import QtCore, QtGui, QtTest, QT_LIB\n\n\ndef resizeWindow(win, w, h, timeout=2.0):\n    """"""Resize a window and wait until it has the correct size.\n    \n    This is required for unit testing on some platforms that do not guarantee\n    immediate response from the windowing system.\n    """"""\n    QtGui.QApplication.processEvents()\n    # Sometimes the window size will switch multiple times before settling\n    # on its final size. Adding qWaitForWindowShown seems to help with this.\n    QtTest.QTest.qWaitForWindowShown(win)\n    win.resize(w, h)\n    start = time.time()\n    while True:\n        w1, h1 = win.width(), win.height()\n        if (w,h) == (w1,h1):\n            return\n        QtTest.QTest.qWait(10)\n        if time.time()-start > timeout:\n            raise TimeoutError(""Window resize failed (requested %dx%d, got %dx%d)"" % (w, h, w1, h1))\n    \n\n# Functions for generating user input events. \n# We would like to use QTest for this purpose, but it seems to be broken.\n# See: http://stackoverflow.com/questions/16299779/qt-qgraphicsview-unit-testing-how-to-keep-the-mouse-in-a-pressed-state\n\ndef mousePress(widget, pos, button, modifier=None):\n    if isinstance(widget, QtGui.QGraphicsView):\n        widget = widget.viewport()\n    if modifier is None:\n        modifier = QtCore.Qt.NoModifier\n    if QT_LIB != \'PyQt5\' and isinstance(pos, QtCore.QPointF):\n        pos = pos.toPoint()\n    event = QtGui.QMouseEvent(QtCore.QEvent.MouseButtonPress, pos, button, QtCore.Qt.NoButton, modifier)\n    QtGui.QApplication.sendEvent(widget, event)\n\n\ndef mouseRelease(widget, pos, button, modifier=None):\n    if isinstance(widget, QtGui.QGraphicsView):\n        widget = widget.viewport()\n    if modifier is None:\n        modifier = QtCore.Qt.NoModifier\n    if QT_LIB != \'PyQt5\' and isinstance(pos, QtCore.QPointF):\n        pos = pos.toPoint()\n    event = QtGui.QMouseEvent(QtCore.QEvent.MouseButtonRelease, pos, button, QtCore.Qt.NoButton, modifier)\n    QtGui.QApplication.sendEvent(widget, event)\n\n\ndef mouseMove(widget, pos, buttons=None, modifier=None):\n    if isinstance(widget, QtGui.QGraphicsView):\n        widget = widget.viewport()\n    if modifier is None:\n        modifier = QtCore.Qt.NoModifier\n    if buttons is None:\n        buttons = QtCore.Qt.NoButton\n    if QT_LIB != \'PyQt5\' and isinstance(pos, QtCore.QPointF):\n        pos = pos.toPoint()\n    event = QtGui.QMouseEvent(QtCore.QEvent.MouseMove, pos, QtCore.Qt.NoButton, buttons, modifier)\n    QtGui.QApplication.sendEvent(widget, event)\n\n\ndef mouseDrag(widget, pos1, pos2, button, modifier=None):\n    mouseMove(widget, pos1)\n    mousePress(widget, pos1, button, modifier)\n    mouseMove(widget, pos2, button, modifier)\n    mouseRelease(widget, pos2, button, modifier)\n\n    \ndef mouseClick(widget, pos, button, modifier=None):\n    mouseMove(widget, pos)\n    mousePress(widget, pos, button, modifier)\n    mouseRelease(widget, pos, button, modifier)\n'"
src/third_party/pyqtgraph/util/__init__.py,0,b''
src/third_party/pyqtgraph/util/cprint.py,0,"b'""""""\nCross-platform color text printing\n\nBased on colorama (see pyqtgraph/util/colorama/README.txt)\n""""""\nimport sys, re\n\nfrom .colorama.winterm import WinTerm, WinColor, WinStyle\nfrom .colorama.win32 import windll\nfrom ..python2_3 import basestring\n\n_WIN = sys.platform.startswith(\'win\')\nif windll is not None:\n    winterm = WinTerm()\nelse:\n    _WIN = False\n\ndef winset(reset=False, fore=None, back=None, style=None, stderr=False):\n    if reset:\n        winterm.reset_all()\n    if fore is not None:\n        winterm.fore(fore, stderr)\n    if back is not None:\n        winterm.back(back, stderr)\n    if style is not None:\n        winterm.style(style, stderr)\n\nANSI = {}\nWIN = {}\nfor i,color in enumerate([\'BLACK\', \'RED\', \'GREEN\', \'YELLOW\', \'BLUE\', \'MAGENTA\', \'CYAN\', \'WHITE\']):\n    globals()[color] = i\n    globals()[\'BR_\' + color] = i + 8\n    globals()[\'BACK_\' + color] = i + 40\n    ANSI[i] = ""\\033[%dm"" % (30+i)\n    ANSI[i+8] = ""\\033[2;%dm"" % (30+i)\n    ANSI[i+40] = ""\\033[%dm"" % (40+i)\n    color = \'GREY\' if color == \'WHITE\' else color\n    WIN[i] = {\'fore\': getattr(WinColor, color), \'style\': WinStyle.NORMAL}\n    WIN[i+8] = {\'fore\': getattr(WinColor, color), \'style\': WinStyle.BRIGHT}\n    WIN[i+40] = {\'back\': getattr(WinColor, color)}\n\nRESET = -1\nANSI[RESET] = ""\\033[0m""\nWIN[RESET] =  {\'reset\': True}\n\n\ndef cprint(stream, *args, **kwds):\n    """"""\n    Print with color. Examples::\n\n        # colors are BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE\n        cprint(\'stdout\', RED, \'This is in red. \', RESET, \'and this is normal\\n\')\n\n        # Adding BR_ before the color manes it bright\n        cprint(\'stdout\', BR_GREEN, \'This is bright green.\\n\', RESET)\n\n        # Adding BACK_ changes background color\n        cprint(\'stderr\', BACK_BLUE, WHITE, \'This is white-on-blue.\', -1)\n\n        # Integers 0-7 for normal, 8-15 for bright, and 40-47 for background.\n        # -1 to reset.\n        cprint(\'stderr\', 1, \'This is in red.\', -1)\n\n    """"""\n    if isinstance(stream, basestring):\n        stream = kwds.get(\'stream\', \'stdout\')\n        err = stream == \'stderr\'\n        stream = getattr(sys, stream)\n    else:\n        err = kwds.get(\'stderr\', False)\n\n    if hasattr(stream, \'isatty\') and stream.isatty():\n        if _WIN:\n            # convert to win32 calls\n            for arg in args:\n                if isinstance(arg, basestring):\n                    stream.write(arg)\n                else:\n                    kwds = WIN[arg]\n                    winset(stderr=err, **kwds)\n        else:\n            # convert to ANSI\n            for arg in args:\n                if isinstance(arg, basestring):\n                    stream.write(arg)\n                else:\n                    stream.write(ANSI[arg])\n    else:\n        # ignore colors\n        for arg in args:\n            if isinstance(arg, basestring):\n                stream.write(arg)\n\ndef cout(*args):\n    """"""Shorthand for cprint(\'stdout\', ...)""""""\n    cprint(\'stdout\', *args)\n\ndef cerr(*args):\n    """"""Shorthand for cprint(\'stderr\', ...)""""""\n    cprint(\'stderr\', *args)\n\n\n'"
src/third_party/pyqtgraph/util/garbage_collector.py,0,"b""import gc\n\nfrom ..Qt import QtCore\n\nclass GarbageCollector(object):\n    '''\n    Disable automatic garbage collection and instead collect manually\n    on a timer.\n\n    This is done to ensure that garbage collection only happens in the GUI\n    thread, as otherwise Qt can crash.\n\n    Credit:  Erik Janssens\n    Source:  http://pydev.blogspot.com/2014/03/should-python-garbage-collector-be.html\n    '''\n\n    def __init__(self, interval=1.0, debug=False):\n        self.debug = debug\n        if debug:\n            gc.set_debug(gc.DEBUG_LEAK)\n\n        self.timer = QtCore.QTimer()\n        self.timer.timeout.connect(self.check)\n\n        self.threshold = gc.get_threshold()\n        gc.disable()\n        self.timer.start(interval * 1000)\n\n    def check(self):\n        #return self.debug_cycles() # uncomment to just debug cycles\n        l0, l1, l2 = gc.get_count()\n        if self.debug:\n            print('gc_check called:', l0, l1, l2)\n        if l0 > self.threshold[0]:\n            num = gc.collect(0)\n            if self.debug:\n                print('collecting gen 0, found: %d unreachable' % num)\n            if l1 > self.threshold[1]:\n                num = gc.collect(1)\n                if self.debug:\n                    print('collecting gen 1, found: %d unreachable' % num)\n                if l2 > self.threshold[2]:\n                    num = gc.collect(2)\n                    if self.debug:\n                        print('collecting gen 2, found: %d unreachable' % num)\n\n    def debug_cycles(self):\n        gc.collect()\n        for obj in gc.garbage:\n            print(obj, repr(obj), type(obj))\n"""
src/third_party/pyqtgraph/util/lru_cache.py,0,"b""import operator\nimport sys\nimport itertools\n\n\n_IS_PY3 = sys.version_info[0] == 3\n\nclass LRUCache(object):\n    '''\n    This LRU cache should be reasonable for short collections (until around 100 items), as it does a\n    sort on the items if the collection would become too big (so, it is very fast for getting and\n    setting but when its size would become higher than the max size it does one sort based on the\n    internal time to decide which items should be removed -- which should be Ok if the resizeTo\n    isn't too close to the maxSize so that it becomes an operation that doesn't happen all the\n    time).\n    '''\n\n    def __init__(self, maxSize=100, resizeTo=70):\n        '''\n        ============== =========================================================\n        **Arguments:**\n        maxSize        (int) This is the maximum size of the cache. When some \n                       item is added and the cache would become bigger than \n                       this, it's resized to the value passed on resizeTo.\n        resizeTo       (int) When a resize operation happens, this is the size \n                       of the final cache.\n        ============== =========================================================\n        '''\n        assert resizeTo < maxSize\n        self.maxSize = maxSize\n        self.resizeTo = resizeTo\n        self._counter = 0\n        self._dict = {}\n        if _IS_PY3:\n            self._nextTime = itertools.count(0).__next__\n        else:\n            self._nextTime = itertools.count(0).next\n\n    def __getitem__(self, key):\n        item = self._dict[key]\n        item[2] = self._nextTime()\n        return item[1]\n\n    def __len__(self):\n        return len(self._dict)\n\n    def __setitem__(self, key, value):\n        item = self._dict.get(key)\n        if item is None:\n            if len(self._dict) + 1 > self.maxSize:\n                self._resizeTo()\n            \n            item = [key, value, self._nextTime()]\n            self._dict[key] = item\n        else:\n            item[1] = value\n            item[2] = self._nextTime()\n            \n    def __delitem__(self, key):\n        del self._dict[key]\n        \n    def get(self, key, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default\n        \n    def clear(self):\n        self._dict.clear()\n \n    if _IS_PY3:\n        def values(self):\n            return [i[1] for i in self._dict.values()]\n        \n        def keys(self):\n            return [x[0] for x in self._dict.values()]\n        \n        def _resizeTo(self):\n            ordered = sorted(self._dict.values(), key=operator.itemgetter(2))[:self.resizeTo]\n            for i in ordered:\n                del self._dict[i[0]]\n                \n        def items(self, accessTime=False):\n            '''\n            :param bool accessTime:\n                If True sorts the returned items by the internal access time.\n            '''\n            if accessTime:\n                for x in sorted(self._dict.values(), key=operator.itemgetter(2)):\n                    yield x[0], x[1]\n            else:\n                for x in self._dict.items():\n                    yield x[0], x[1]\n                    \n    else:\n        def values(self):\n            return [i[1] for i in self._dict.values()]\n        \n        def keys(self):\n            return [x[0] for x in self._dict.values()]\n            \n        \n        def _resizeTo(self):\n            ordered = sorted(self._dict.values(), key=operator.itemgetter(2))[:self.resizeTo]\n            for i in ordered:\n                del self._dict[i[0]]\n                \n        def items(self, accessTime=False):\n            '''\n            ============= ======================================================\n            **Arguments**\n            accessTime    (bool) If True sorts the returned items by the \n                          internal access time.\n            ============= ======================================================\n            '''\n            if accessTime:\n                for x in sorted(self._dict.values(), key=operator.itemgetter(2)):\n                    yield x[0], x[1]\n            else:\n                for x in self._dict.items():\n                    yield x[0], x[1]\n"""
src/third_party/pyqtgraph/util/mutex.py,0,"b'# -*- coding: utf-8 -*-\nimport traceback\nfrom ..Qt import QtCore\n\n\nclass Mutex(QtCore.QMutex):\n    """"""\n    Subclass of QMutex that provides useful debugging information during\n    deadlocks--tracebacks are printed for both the code location that is \n    attempting to lock the mutex as well as the location that has already\n    acquired the lock.\n    \n    Also provides __enter__ and __exit__ methods for use in ""with"" statements.\n    """"""    \n    def __init__(self, *args, **kargs):\n        if kargs.get(\'recursive\', False):\n            args = (QtCore.QMutex.Recursive,)\n        QtCore.QMutex.__init__(self, *args)\n        self.l = QtCore.QMutex()  ## for serializing access to self.tb\n        self.tb = []\n        self.debug = kargs.pop(\'debug\', False) ## True to enable debugging functions\n\n    def tryLock(self, timeout=None, id=None):\n        if timeout is None:\n            locked = QtCore.QMutex.tryLock(self)\n        else:\n            locked = QtCore.QMutex.tryLock(self, timeout)\n\n        if self.debug and locked:\n            self.l.lock()\n            try:\n                if id is None:\n                    self.tb.append(\'\'.join(traceback.format_stack()[:-1]))\n                else:\n                    self.tb.append(""  "" + str(id))\n                #print \'trylock\', self, len(self.tb)\n            finally:\n                self.l.unlock()\n        return locked\n        \n    def lock(self, id=None):\n        c = 0\n        waitTime = 5000  # in ms\n        while True:\n            if self.tryLock(waitTime, id):\n                break\n            c += 1\n            if self.debug:\n                self.l.lock()\n                try:\n                    print(""Waiting for mutex lock (%0.1f sec). Traceback follows:"" \n                          % (c*waitTime/1000.))\n                    traceback.print_stack()\n                    if len(self.tb) > 0:\n                        print(""Mutex is currently locked from:\\n"")\n                        print(self.tb[-1])\n                    else:\n                        print(""Mutex is currently locked from [???]"")\n                finally:\n                    self.l.unlock()\n        #print \'lock\', self, len(self.tb)\n\n    def unlock(self):\n        QtCore.QMutex.unlock(self)\n        if self.debug:\n            self.l.lock()\n            try:\n                #print \'unlock\', self, len(self.tb)\n                if len(self.tb) > 0:\n                    self.tb.pop()\n                else:\n                    raise Exception(""Attempt to unlock mutex before it has been locked"")\n            finally:\n                self.l.unlock()\n\n    def acquire(self, blocking=True):\n        """"""Mimics threading.Lock.acquire() to allow this class as a drop-in replacement.\n        """"""\n        return self.tryLock()\n        \n    def release(self): \n        """"""Mimics threading.Lock.release() to allow this class as a drop-in replacement.\n        """"""\n        self.unlock()\n\n    def depth(self):\n        self.l.lock()\n        n = len(self.tb)\n        self.l.unlock()\n        return n\n\n    def traceback(self):\n        self.l.lock()\n        try:\n            ret = self.tb[:]\n        finally:\n            self.l.unlock()\n        return ret\n\n    def __exit__(self, *args):\n        self.unlock()\n\n    def __enter__(self):\n        self.lock()\n        return self\n\n\nclass RecursiveMutex(Mutex):\n    """"""Mimics threading.RLock class.\n    """"""\n    def __init__(self, **kwds):\n        kwds[\'recursive\'] = True\n        Mutex.__init__(self, **kwds)\n\n'"
src/third_party/pyqtgraph/util/pil_fix.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nImporting this module installs support for 16-bit images in PIL.\nThis works by patching objects in the PIL namespace; no files are\nmodified.\n""""""\n\nfrom PIL import Image\n\nif Image.VERSION == \'1.1.7\':\n    Image._MODE_CONV[""I;16""] = (\'%su2\' % Image._ENDIAN, None)\n    Image._fromarray_typemap[((1, 1), ""<u2"")] = (""I"", ""I;16"")\nif Image.VERSION == \'1.1.6\':\n    Image._MODE_CONV[""I;16""] = (\'%su2\' % Image._ENDIAN, None)\n    ## just a copy of fromarray() from Image.py with I;16 added in\n    def fromarray(obj, mode=None):\n        arr = obj.__array_interface__\n        shape = arr[\'shape\']\n        ndim = len(shape)\n        try:\n            strides = arr[\'strides\']\n        except KeyError:\n            strides = None\n        if mode is None:\n            typestr = arr[\'typestr\']\n            if not (typestr[0] == \'|\' or typestr[0] == Image._ENDIAN or\n                    typestr[1:] not in [\'u1\', \'b1\', \'i4\', \'f4\']):\n                raise TypeError(""cannot handle data-type"")\n            if typestr[0] == Image._ENDIAN:\n                typestr = typestr[1:3]\n            else:\n                typestr = typestr[:2]\n            if typestr == \'i4\':\n                mode = \'I\'\n            if typestr == \'u2\':\n                mode = \'I;16\'\n            elif typestr == \'f4\':\n                mode = \'F\'\n            elif typestr == \'b1\':\n                mode = \'1\'\n            elif ndim == 2:\n                mode = \'L\'\n            elif ndim == 3:\n                mode = \'RGB\'\n            elif ndim == 4:\n                mode = \'RGBA\'\n            else:\n                raise TypeError(""Do not understand data."")\n        ndmax = 4\n        bad_dims=0\n        if mode in [\'1\',\'L\',\'I\',\'P\',\'F\']:\n            ndmax = 2\n        elif mode == \'RGB\':\n            ndmax = 3\n        if ndim > ndmax:\n            raise ValueError(""Too many dimensions."")\n\n        size = shape[:2][::-1]\n        if strides is not None:\n            obj = obj.tostring()\n\n        return frombuffer(mode, size, obj, ""raw"", mode, 0, 1)\n        \n    Image.fromarray=fromarray'"
src/third_party/pyqtgraph/widgets/BusyCursor.py,0,"b'from ..Qt import QtGui, QtCore\n\n__all__ = [\'BusyCursor\']\n\nclass BusyCursor(object):\n    """"""Class for displaying a busy mouse cursor during long operations.\n    Usage::\n\n        with pyqtgraph.BusyCursor():\n            doLongOperation()\n\n    May be nested. If called from a non-gui thread, then the cursor will not be affected.\n    """"""\n    active = []\n\n    def __enter__(self):\n        app = QtCore.QCoreApplication.instance()\n        isGuiThread = (app is not None) and (QtCore.QThread.currentThread() == app.thread())\n        if isGuiThread and QtGui.QApplication.instance() is not None:\n            QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))\n            BusyCursor.active.append(self)\n            self._active = True\n        else:\n            self._active = False\n\n    def __exit__(self, *args):\n        if self._active:\n            BusyCursor.active.pop(-1)\n            QtGui.QApplication.restoreOverrideCursor()\n        '"
src/third_party/pyqtgraph/widgets/CheckTable.py,0,"b""# -*- coding: utf-8 -*-\nfrom ..Qt import QtGui, QtCore\nfrom . import VerticalLabel\n\n__all__ = ['CheckTable']\n\nclass CheckTable(QtGui.QWidget):\n    \n    sigStateChanged = QtCore.Signal(object, object, object) # (row, col, state)\n    \n    def __init__(self, columns):\n        QtGui.QWidget.__init__(self)\n        self.layout = QtGui.QGridLayout()\n        self.layout.setSpacing(0)\n        self.setLayout(self.layout)\n        self.headers = []\n        self.columns = columns\n        col = 1\n        for c in columns:\n            label = VerticalLabel.VerticalLabel(c, orientation='vertical')\n            self.headers.append(label)\n            self.layout.addWidget(label, 0, col)\n            col += 1\n        \n        self.rowNames = []\n        self.rowWidgets = []\n        self.oldRows = {}  ## remember settings from removed rows; reapply if they reappear.\n        \n\n    def updateRows(self, rows):\n        for r in self.rowNames[:]:\n            if r not in rows:\n                self.removeRow(r)\n        for r in rows:\n            if r not in self.rowNames:\n                self.addRow(r)\n\n    def addRow(self, name):\n        label = QtGui.QLabel(name)\n        row = len(self.rowNames)+1\n        self.layout.addWidget(label, row, 0)\n        checks = []\n        col = 1\n        for c in self.columns:\n            check = QtGui.QCheckBox('')\n            check.col = c\n            check.row = name\n            self.layout.addWidget(check, row, col)\n            checks.append(check)\n            if name in self.oldRows:\n                check.setChecked(self.oldRows[name][col])\n            col += 1\n            #QtCore.QObject.connect(check, QtCore.SIGNAL('stateChanged(int)'), self.checkChanged)\n            check.stateChanged.connect(self.checkChanged)\n        self.rowNames.append(name)\n        self.rowWidgets.append([label] + checks)\n        \n    def removeRow(self, name):\n        row = self.rowNames.index(name)\n        self.oldRows[name] = self.saveState()['rows'][row]  ## save for later\n        self.rowNames.pop(row)\n        for w in self.rowWidgets[row]:\n            w.setParent(None)\n            #QtCore.QObject.disconnect(w, QtCore.SIGNAL('stateChanged(int)'), self.checkChanged)\n            if isinstance(w, QtGui.QCheckBox):\n                w.stateChanged.disconnect(self.checkChanged)\n        self.rowWidgets.pop(row)\n        for i in range(row, len(self.rowNames)):\n            widgets = self.rowWidgets[i]\n            for j in range(len(widgets)):\n                widgets[j].setParent(None)\n                self.layout.addWidget(widgets[j], i+1, j)\n\n    def checkChanged(self, state):\n        check = QtCore.QObject.sender(self)\n        #self.emit(QtCore.SIGNAL('stateChanged'), check.row, check.col, state)\n        self.sigStateChanged.emit(check.row, check.col, state)\n        \n    def saveState(self):\n        rows = []\n        for i in range(len(self.rowNames)):\n            row = [self.rowNames[i]] + [c.isChecked() for c in self.rowWidgets[i][1:]]\n            rows.append(row)\n        return {'cols': self.columns, 'rows': rows}\n        \n    def restoreState(self, state):\n        rows = [r[0] for r in state['rows']]\n        self.updateRows(rows)\n        for r in state['rows']:\n            rowNum = self.rowNames.index(r[0])\n            for i in range(1, len(r)):\n                self.rowWidgets[rowNum][i].setChecked(r[i])\n            \n"""
src/third_party/pyqtgraph/widgets/ColorButton.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtGui, QtCore\nfrom .. import functions as functions\n\n__all__ = [\'ColorButton\']\n\nclass ColorButton(QtGui.QPushButton):\n    """"""\n    **Bases:** QtGui.QPushButton\n    \n    Button displaying a color and allowing the user to select a new color.\n    \n    ====================== ============================================================\n    **Signals:**\n    sigColorChanging(self) emitted whenever a new color is picked in the color dialog\n    sigColorChanged(self)  emitted when the selected color is accepted (user clicks OK)\n    ====================== ============================================================\n    """"""\n    sigColorChanging = QtCore.Signal(object)  ## emitted whenever a new color is picked in the color dialog\n    sigColorChanged = QtCore.Signal(object)   ## emitted when the selected color is accepted (user clicks OK)\n    \n    def __init__(self, parent=None, color=(128,128,128)):\n        QtGui.QPushButton.__init__(self, parent)\n        self.setColor(color)\n        self.colorDialog = QtGui.QColorDialog()\n        self.colorDialog.setOption(QtGui.QColorDialog.ShowAlphaChannel, True)\n        self.colorDialog.setOption(QtGui.QColorDialog.DontUseNativeDialog, True)\n        self.colorDialog.currentColorChanged.connect(self.dialogColorChanged)\n        self.colorDialog.rejected.connect(self.colorRejected)\n        self.colorDialog.colorSelected.connect(self.colorSelected)\n        #QtCore.QObject.connect(self.colorDialog, QtCore.SIGNAL(\'currentColorChanged(const QColor&)\'), self.currentColorChanged)\n        #QtCore.QObject.connect(self.colorDialog, QtCore.SIGNAL(\'rejected()\'), self.currentColorRejected)\n        self.clicked.connect(self.selectColor)\n        self.setMinimumHeight(15)\n        self.setMinimumWidth(15)\n        \n    def paintEvent(self, ev):\n        QtGui.QPushButton.paintEvent(self, ev)\n        p = QtGui.QPainter(self)\n        rect = self.rect().adjusted(6, 6, -6, -6)\n        ## draw white base, then texture for indicating transparency, then actual color\n        p.setBrush(functions.mkBrush(\'w\'))\n        p.drawRect(rect)\n        p.setBrush(QtGui.QBrush(QtCore.Qt.DiagCrossPattern))\n        p.drawRect(rect)\n        p.setBrush(functions.mkBrush(self._color))\n        p.drawRect(rect)\n        p.end()\n    \n    def setColor(self, color, finished=True):\n        """"""Sets the button\'s color and emits both sigColorChanged and sigColorChanging.""""""\n        self._color = functions.mkColor(color)\n        if finished:\n            self.sigColorChanged.emit(self)\n        else:\n            self.sigColorChanging.emit(self)\n        self.update()\n        \n    def selectColor(self):\n        self.origColor = self.color()\n        self.colorDialog.setCurrentColor(self.color())\n        self.colorDialog.open()\n        \n    def dialogColorChanged(self, color):\n        if color.isValid():\n            self.setColor(color, finished=False)\n            \n    def colorRejected(self):\n        self.setColor(self.origColor, finished=False)\n    \n    def colorSelected(self, color):\n        self.setColor(self._color, finished=True)\n    \n    def saveState(self):\n        return functions.colorTuple(self._color)\n        \n    def restoreState(self, state):\n        self.setColor(state)\n        \n    def color(self, mode=\'qcolor\'):\n        color = functions.mkColor(self._color)\n        if mode == \'qcolor\':\n            return color\n        elif mode == \'byte\':\n            return (color.red(), color.green(), color.blue(), color.alpha())\n        elif mode == \'float\':\n            return (color.red()/255., color.green()/255., color.blue()/255., color.alpha()/255.)\n\n    def widgetGroupInterface(self):\n        return (self.sigColorChanged, ColorButton.saveState, ColorButton.restoreState)\n    \n'"
src/third_party/pyqtgraph/widgets/ColorMapWidget.py,12,"b'from ..Qt import QtGui, QtCore\nfrom .. import parametertree as ptree\nimport numpy as np\nfrom ..pgcollections import OrderedDict\nfrom .. import functions as fn\n\n__all__ = [\'ColorMapWidget\']\n\nclass ColorMapWidget(ptree.ParameterTree):\n    """"""\n    This class provides a widget allowing the user to customize color mapping\n    for multi-column data. Given a list of field names, the user may specify\n    multiple criteria for assigning colors to each record in a numpy record array.\n    Multiple criteria are evaluated and combined into a single color for each\n    record by user-defined compositing methods.\n    \n    For simpler color mapping using a single gradient editor, see \n    :class:`GradientWidget <pyqtgraph.GradientWidget>`\n    """"""\n    sigColorMapChanged = QtCore.Signal(object)\n    \n    def __init__(self, parent=None):\n        ptree.ParameterTree.__init__(self, parent=parent, showHeader=False)\n        \n        self.params = ColorMapParameter()\n        self.setParameters(self.params)\n        self.params.sigTreeStateChanged.connect(self.mapChanged)\n        \n        ## wrap a couple methods \n        self.setFields = self.params.setFields\n        self.map = self.params.map\n\n    def mapChanged(self):\n        self.sigColorMapChanged.emit(self)\n\n    def widgetGroupInterface(self):\n        return (self.sigColorMapChanged, self.saveState, self.restoreState)\n\n    def saveState(self):\n        return self.params.saveState()\n\n    def restoreState(self, state):\n        self.params.restoreState(state)\n        \n    def addColorMap(self, name):\n        """"""Add a new color mapping and return the created parameter.\n        """"""\n        return self.params.addNew(name)\n\n\nclass ColorMapParameter(ptree.types.GroupParameter):\n    sigColorMapChanged = QtCore.Signal(object)\n    \n    def __init__(self):\n        self.fields = {}\n        ptree.types.GroupParameter.__init__(self, name=\'Color Map\', addText=\'Add Mapping..\', addList=[])\n        self.sigTreeStateChanged.connect(self.mapChanged)\n        \n    def mapChanged(self):\n        self.sigColorMapChanged.emit(self)\n        \n    def addNew(self, name):\n        mode = self.fields[name].get(\'mode\', \'range\')\n        if mode == \'range\':\n            item = RangeColorMapItem(name, self.fields[name])\n        elif mode == \'enum\':\n            item = EnumColorMapItem(name, self.fields[name])\n        self.addChild(item)\n        return item\n        \n    def fieldNames(self):\n        return self.fields.keys()\n    \n    def setFields(self, fields):\n        """"""\n        Set the list of fields to be used by the mapper. \n        \n        The format of *fields* is::\n        \n            [ (fieldName, {options}), ... ]\n        \n        ============== ============================================================\n        Field Options:\n        mode           Either \'range\' or \'enum\' (default is range). For \'range\', \n                       The user may specify a gradient of colors to be applied \n                       linearly across a specific range of values. For \'enum\', \n                       the user specifies a single color for each unique value\n                       (see *values* option).\n        units          String indicating the units of the data for this field.\n        values         List of unique values for which the user may assign a \n                       color when mode==\'enum\'. Optionally may specify a dict \n                       instead {value: name}.\n        ============== ============================================================\n        """"""\n        self.fields = OrderedDict(fields)\n        #self.fields = fields\n        #self.fields.sort()\n        names = self.fieldNames()\n        self.setAddList(names)\n        \n    def map(self, data, mode=\'byte\'):\n        """"""\n        Return an array of colors corresponding to *data*. \n        \n        ==============  =================================================================\n        **Arguments:**\n        data            A numpy record array where the fields in data.dtype match those\n                        defined by a prior call to setFields().\n        mode            Either \'byte\' or \'float\'. For \'byte\', the method returns an array\n                        of dtype ubyte with values scaled 0-255. For \'float\', colors are\n                        returned as 0.0-1.0 float values.\n        ==============  =================================================================\n        """"""\n        if isinstance(data, dict):\n            data = np.array([tuple(data.values())], dtype=[(k, float) for k in data.keys()])\n\n        colors = np.zeros((len(data),4))\n        for item in self.children():\n            if not item[\'Enabled\']:\n                continue\n            chans = item.param(\'Channels..\')\n            mask = np.empty((len(data), 4), dtype=bool)\n            for i,f in enumerate([\'Red\', \'Green\', \'Blue\', \'Alpha\']):\n                mask[:,i] = chans[f]\n            \n            colors2 = item.map(data)\n            \n            op = item[\'Operation\']\n            if op == \'Add\':\n                colors[mask] = colors[mask] + colors2[mask]\n            elif op == \'Multiply\':\n                colors[mask] *= colors2[mask]\n            elif op == \'Overlay\':\n                a = colors2[:,3:4]\n                c3 = colors * (1-a) + colors2 * a\n                c3[:,3:4] = colors[:,3:4] + (1-colors[:,3:4]) * a\n                colors = c3\n            elif op == \'Set\':\n                colors[mask] = colors2[mask]\n            \n                \n        colors = np.clip(colors, 0, 1)\n        if mode == \'byte\':\n            colors = (colors * 255).astype(np.ubyte)\n        \n        return colors\n            \n    def saveState(self):\n        items = OrderedDict()\n        for item in self:\n            itemState = item.saveState(filter=\'user\')\n            itemState[\'field\'] = item.fieldName\n            items[item.name()] = itemState\n        state = {\'fields\': self.fields, \'items\': items}\n        return state\n\n    def restoreState(self, state):\n        if \'fields\' in state:\n            self.setFields(state[\'fields\'])\n        for name, itemState in state[\'items\'].items():\n            item = self.addNew(itemState[\'field\'])\n            item.restoreState(itemState)\n        \n    \nclass RangeColorMapItem(ptree.types.SimpleParameter):\n    mapType = \'range\'\n    \n    def __init__(self, name, opts):\n        self.fieldName = name\n        units = opts.get(\'units\', \'\')\n        ptree.types.SimpleParameter.__init__(self, \n            name=name, autoIncrementName=True, type=\'colormap\', removable=True, renamable=True, \n            children=[\n                #dict(name=""Field"", type=\'list\', value=name, values=fields),\n                dict(name=\'Min\', type=\'float\', value=0.0, suffix=units, siPrefix=True),\n                dict(name=\'Max\', type=\'float\', value=1.0, suffix=units, siPrefix=True),\n                dict(name=\'Operation\', type=\'list\', value=\'Overlay\', values=[\'Overlay\', \'Add\', \'Multiply\', \'Set\']),\n                dict(name=\'Channels..\', type=\'group\', expanded=False, children=[\n                    dict(name=\'Red\', type=\'bool\', value=True),\n                    dict(name=\'Green\', type=\'bool\', value=True),\n                    dict(name=\'Blue\', type=\'bool\', value=True),\n                    dict(name=\'Alpha\', type=\'bool\', value=True),\n                    ]),\n                dict(name=\'Enabled\', type=\'bool\', value=True),\n                dict(name=\'NaN\', type=\'color\'),\n            ])\n    \n    def map(self, data):\n        data = data[self.fieldName]\n        \n        scaled = np.clip((data-self[\'Min\']) / (self[\'Max\']-self[\'Min\']), 0, 1)\n        cmap = self.value()\n        colors = cmap.map(scaled, mode=\'float\')\n        \n        mask = np.isnan(data) | np.isinf(data)\n        nanColor = self[\'NaN\']\n        nanColor = (nanColor.red()/255., nanColor.green()/255., nanColor.blue()/255., nanColor.alpha()/255.)\n        colors[mask] = nanColor\n        \n        return colors        \n\nclass EnumColorMapItem(ptree.types.GroupParameter):\n    mapType = \'enum\'\n    \n    def __init__(self, name, opts):\n        self.fieldName = name\n        vals = opts.get(\'values\', [])\n        if isinstance(vals, list):\n            vals = OrderedDict([(v,str(v)) for v in vals])\n        childs = [{\'name\': v, \'type\': \'color\'} for v in vals]\n        \n        childs = []\n        for val,vname in vals.items():\n            ch = ptree.Parameter.create(name=vname, type=\'color\')\n            ch.maskValue = val\n            childs.append(ch)\n        \n        ptree.types.GroupParameter.__init__(self, \n            name=name, autoIncrementName=True, removable=True, renamable=True, \n            children=[\n                dict(name=\'Values\', type=\'group\', children=childs),\n                dict(name=\'Operation\', type=\'list\', value=\'Overlay\', values=[\'Overlay\', \'Add\', \'Multiply\', \'Set\']),\n                dict(name=\'Channels..\', type=\'group\', expanded=False, children=[\n                    dict(name=\'Red\', type=\'bool\', value=True),\n                    dict(name=\'Green\', type=\'bool\', value=True),\n                    dict(name=\'Blue\', type=\'bool\', value=True),\n                    dict(name=\'Alpha\', type=\'bool\', value=True),\n                    ]),\n                dict(name=\'Enabled\', type=\'bool\', value=True),\n                dict(name=\'Default\', type=\'color\'),\n            ])\n    \n    def map(self, data):\n        data = data[self.fieldName]\n        colors = np.empty((len(data), 4))\n        default = np.array(fn.colorTuple(self[\'Default\'])) / 255.\n        colors[:] = default\n        \n        for v in self.param(\'Values\'):\n            mask = data == v.maskValue\n            c = np.array(fn.colorTuple(v.value())) / 255.\n            colors[mask] = c\n        #scaled = np.clip((data-self[\'Min\']) / (self[\'Max\']-self[\'Min\']), 0, 1)\n        #cmap = self.value()\n        #colors = cmap.map(scaled, mode=\'float\')\n        \n        #mask = np.isnan(data) | np.isinf(data)\n        #nanColor = self[\'NaN\']\n        #nanColor = (nanColor.red()/255., nanColor.green()/255., nanColor.blue()/255., nanColor.alpha()/255.)\n        #colors[mask] = nanColor\n        \n        return colors\n\n\n'"
src/third_party/pyqtgraph/widgets/ComboBox.py,0,"b'import sys\nfrom ..Qt import QtGui, QtCore\nfrom ..SignalProxy import SignalProxy\nfrom ..pgcollections import OrderedDict\nfrom ..python2_3 import asUnicode, basestring\n\n\nclass ComboBox(QtGui.QComboBox):\n    """"""Extends QComboBox to add extra functionality.\n\n    * Handles dict mappings -- user selects a text key, and the ComboBox indicates\n      the selected value.\n    * Requires item strings to be unique\n    * Remembers selected value if list is cleared and subsequently repopulated\n    * setItems() replaces the items in the ComboBox and blocks signals if the\n      value ultimately does not change.\n    """"""\n    \n    \n    def __init__(self, parent=None, items=None, default=None):\n        QtGui.QComboBox.__init__(self, parent)\n        self.currentIndexChanged.connect(self.indexChanged)\n        self._ignoreIndexChange = False\n        \n        #self.value = default\n        if \'darwin\' in sys.platform: ## because MacOSX can show names that are wider than the comboBox\n            self.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToMinimumContentsLength)\n            #self.setMinimumContentsLength(10)\n        self._chosenText = None\n        self._items = OrderedDict()\n        \n        if items is not None:\n            self.setItems(items)\n            if default is not None:\n                self.setValue(default)\n    \n    def setValue(self, value):\n        """"""Set the selected item to the first one having the given value.""""""\n        text = None\n        for k,v in self._items.items():\n            if v == value:\n                text = k\n                break\n        if text is None:\n            raise ValueError(value)\n            \n        self.setText(text)\n\n    def setText(self, text):\n        """"""Set the selected item to the first one having the given text.""""""\n        ind = self.findText(text)\n        if ind == -1:\n            raise ValueError(text)\n        #self.value = value\n        self.setCurrentIndex(ind)\n       \n    def value(self):\n        """"""\n        If items were given as a list of strings, then return the currently \n        selected text. If items were given as a dict, then return the value\n        corresponding to the currently selected key. If the combo list is empty,\n        return None.\n        """"""\n        if self.count() == 0:\n            return None\n        text = asUnicode(self.currentText())\n        return self._items[text]\n    \n    def ignoreIndexChange(func):\n        # Decorator that prevents updates to self._chosenText\n        def fn(self, *args, **kwds):\n            prev = self._ignoreIndexChange\n            self._ignoreIndexChange = True\n            try:\n                ret = func(self, *args, **kwds)\n            finally:\n                self._ignoreIndexChange = prev\n            return ret\n        return fn\n    \n    def blockIfUnchanged(func):\n        # decorator that blocks signal emission during complex operations\n        # and emits currentIndexChanged only if the value has actually\n        # changed at the end.\n        def fn(self, *args, **kwds):\n            prevVal = self.value()\n            blocked = self.signalsBlocked()\n            self.blockSignals(True)\n            try:\n                ret = func(self, *args, **kwds)\n            finally:\n                self.blockSignals(blocked)\n                \n            # only emit if the value has changed\n            if self.value() != prevVal:\n                self.currentIndexChanged.emit(self.currentIndex())\n                \n            return ret\n        return fn\n    \n    @ignoreIndexChange\n    @blockIfUnchanged\n    def setItems(self, items):\n        """"""\n        *items* may be a list, a tuple, or a dict. \n        If a dict is given, then the keys are used to populate the combo box\n        and the values will be used for both value() and setValue().\n        """"""\n        prevVal = self.value()\n        \n        self.blockSignals(True)\n        try:\n            self.clear()\n            self.addItems(items)\n        finally:\n            self.blockSignals(False)\n            \n        # only emit if we were not able to re-set the original value\n        if self.value() != prevVal:\n            self.currentIndexChanged.emit(self.currentIndex())\n        \n    def items(self):\n        return self.items.copy()\n        \n    def updateList(self, items):\n        # for backward compatibility\n        return self.setItems(items)\n\n    def indexChanged(self, index):\n        # current index has changed; need to remember new \'chosen text\'\n        if self._ignoreIndexChange:\n            return\n        self._chosenText = asUnicode(self.currentText())\n        \n    def setCurrentIndex(self, index):\n        QtGui.QComboBox.setCurrentIndex(self, index)\n        \n    def itemsChanged(self):\n        # try to set the value to the last one selected, if it is available.\n        if self._chosenText is not None:\n            try:\n                self.setText(self._chosenText)\n            except ValueError:\n                pass\n\n    @ignoreIndexChange\n    def insertItem(self, *args):\n        raise NotImplementedError()\n        #QtGui.QComboBox.insertItem(self, *args)\n        #self.itemsChanged()\n        \n    @ignoreIndexChange\n    def insertItems(self, *args):\n        raise NotImplementedError()\n        #QtGui.QComboBox.insertItems(self, *args)\n        #self.itemsChanged()\n    \n    @ignoreIndexChange\n    def addItem(self, *args, **kwds):\n        # Need to handle two different function signatures for QComboBox.addItem\n        try:\n            if isinstance(args[0], basestring):\n                text = args[0]\n                if len(args) == 2:\n                    value = args[1]\n                else:\n                    value = kwds.get(\'value\', text)\n            else:\n                text = args[1]\n                if len(args) == 3:\n                    value = args[2]\n                else:\n                    value = kwds.get(\'value\', text)\n        \n        except IndexError:\n            raise TypeError(""First or second argument of addItem must be a string."")\n            \n        if text in self._items:\n            raise Exception(\'ComboBox already has item named ""%s"".\' % text)\n        \n        self._items[text] = value\n        QtGui.QComboBox.addItem(self, *args)\n        self.itemsChanged()\n        \n    def setItemValue(self, name, value):\n        if name not in self._items:\n            self.addItem(name, value)\n        else:\n            self._items[name] = value\n        \n    @ignoreIndexChange\n    @blockIfUnchanged\n    def addItems(self, items):\n        if isinstance(items, list) or isinstance(items, tuple):\n            texts = items\n            items = dict([(x, x) for x in items])\n        elif isinstance(items, dict):\n            texts = list(items.keys())\n        else:\n            raise TypeError(""items argument must be list or dict or tuple (got %s)."" % type(items))\n        \n        for t in texts:\n            if t in self._items:\n                raise Exception(\'ComboBox already has item named ""%s"".\' % t)\n                \n        \n        for k,v in items.items():\n            self._items[k] = v\n        QtGui.QComboBox.addItems(self, list(texts))\n        \n        self.itemsChanged()\n        \n    @ignoreIndexChange\n    def clear(self):\n        self._items = OrderedDict()\n        QtGui.QComboBox.clear(self)\n        self.itemsChanged()\n        \n    def saveState(self):\n        ind = self.currentIndex()\n        data = self.itemData(ind)\n        #if not data.isValid():\n        if data is not None:\n            try:\n                if not data.isValid():\n                    data = None\n                else:\n                    data = data.toInt()[0]\n            except AttributeError:\n                pass\n        if data is None:\n            return asUnicode(self.itemText(ind))\n        else:\n            return data\n        \n    def restoreState(self, v):\n        if type(v) is int:\n            ind = self.findData(v)\n            if ind > -1:\n                self.setCurrentIndex(ind)\n                return\n        self.setCurrentIndex(self.findText(str(v)))\n\n    def widgetGroupInterface(self):\n        return (self.currentIndexChanged, self.saveState, self.restoreState)\n'"
src/third_party/pyqtgraph/widgets/DataFilterWidget.py,3,"b'from ..Qt import QtGui, QtCore\nfrom .. import parametertree as ptree\nimport numpy as np\nfrom ..pgcollections import OrderedDict\nfrom .. import functions as fn\nfrom ..python2_3 import basestring\n\n__all__ = [\'DataFilterWidget\']\n\n\nclass DataFilterWidget(ptree.ParameterTree):\n    """"""\n    This class allows the user to filter multi-column data sets by specifying\n    multiple criteria\n    \n    Wraps methods from DataFilterParameter: setFields, generateMask,\n    filterData, and describe.\n    """"""\n    \n    sigFilterChanged = QtCore.Signal(object)\n    \n    def __init__(self):\n        ptree.ParameterTree.__init__(self, showHeader=False)\n        self.params = DataFilterParameter()\n        \n        self.setParameters(self.params)\n        self.params.sigFilterChanged.connect(self.sigFilterChanged)\n        \n        self.setFields = self.params.setFields\n        self.generateMask = self.params.generateMask\n        self.filterData = self.params.filterData\n        self.describe = self.params.describe\n        \n    def parameters(self):\n        return self.params\n\n    def addFilter(self, name):\n        """"""Add a new filter and return the created parameter item.\n        """"""\n        return self.params.addNew(name)\n\n        \nclass DataFilterParameter(ptree.types.GroupParameter):\n    """"""A parameter group that specifies a set of filters to apply to tabular data.\n    """"""\n    sigFilterChanged = QtCore.Signal(object)\n    \n    def __init__(self):\n        self.fields = {}\n        ptree.types.GroupParameter.__init__(self, name=\'Data Filter\', addText=\'Add filter..\', addList=[])\n        self.sigTreeStateChanged.connect(self.filterChanged)\n    \n    def filterChanged(self):\n        self.sigFilterChanged.emit(self)\n        \n    def addNew(self, name):\n        mode = self.fields[name].get(\'mode\', \'range\')\n        if mode == \'range\':\n            child = self.addChild(RangeFilterItem(name, self.fields[name]))\n        elif mode == \'enum\':\n            child = self.addChild(EnumFilterItem(name, self.fields[name]))\n        return child\n            \n    def fieldNames(self):\n        return self.fields.keys()\n    \n    def setFields(self, fields):\n        """"""Set the list of fields that are available to be filtered.\n\n        *fields* must be a dict or list of tuples that maps field names\n        to a specification describing the field. Each specification is\n        itself a dict with either ``\'mode\':\'range\'`` or ``\'mode\':\'enum\'``::\n\n            filter.setFields([\n                (\'field1\', {\'mode\': \'range\'}),\n                (\'field2\', {\'mode\': \'enum\', \'values\': [\'val1\', \'val2\', \'val3\']}),\n                (\'field3\', {\'mode\': \'enum\', \'values\': {\'val1\':True, \'val2\':False, \'val3\':True}}),\n            ])\n        """"""\n        with fn.SignalBlock(self.sigTreeStateChanged, self.filterChanged):\n            self.fields = OrderedDict(fields)\n            names = self.fieldNames()\n            self.setAddList(names)\n\n            # update any existing filters\n            for ch in self.children():\n                name = ch.fieldName\n                if name in fields:\n                    ch.updateFilter(fields[name])\n        self.sigFilterChanged.emit(self)\n    \n    def filterData(self, data):\n        if len(data) == 0:\n            return data\n        return data[self.generateMask(data)]\n    \n    def generateMask(self, data):\n        """"""Return a boolean mask indicating whether each item in *data* passes\n        the filter critera.\n        """"""\n        mask = np.ones(len(data), dtype=bool)\n        if len(data) == 0:\n            return mask\n        for fp in self:\n            if fp.value() is False:\n                continue\n            mask &= fp.generateMask(data, mask.copy())\n            #key, mn, mx = fp.fieldName, fp[\'Min\'], fp[\'Max\']\n            \n            #vals = data[key]\n            #mask &= (vals >= mn)\n            #mask &= (vals < mx)  ## Use inclusive minimum and non-inclusive maximum. This makes it easier to create non-overlapping selections\n        return mask\n    \n    def describe(self):\n        """"""Return a list of strings describing the currently enabled filters.""""""\n        desc = []\n        for fp in self:\n            if fp.value() is False:\n                continue\n            desc.append(fp.describe())\n        return desc\n\n\nclass RangeFilterItem(ptree.types.SimpleParameter):\n    def __init__(self, name, opts):\n        self.fieldName = name\n        units = opts.get(\'units\', \'\')\n        self.units = units\n        ptree.types.SimpleParameter.__init__(self, \n            name=name, autoIncrementName=True, type=\'bool\', value=True, removable=True, renamable=True, \n            children=[\n                #dict(name=""Field"", type=\'list\', value=name, values=fields),\n                dict(name=\'Min\', type=\'float\', value=0.0, suffix=units, siPrefix=True),\n                dict(name=\'Max\', type=\'float\', value=1.0, suffix=units, siPrefix=True),\n            ])\n            \n    def generateMask(self, data, mask):\n        vals = data[self.fieldName][mask]\n        mask[mask] = (vals >= self[\'Min\']) & (vals < self[\'Max\'])  ## Use inclusive minimum and non-inclusive maximum. This makes it easier to create non-overlapping selections\n        return mask\n    \n    def describe(self):\n        return ""%s < %s < %s"" % (fn.siFormat(self[\'Min\'], suffix=self.units), self.fieldName, fn.siFormat(self[\'Max\'], suffix=self.units))\n\n    def updateFilter(self, opts):\n        pass\n    \n\nclass EnumFilterItem(ptree.types.SimpleParameter):\n    def __init__(self, name, opts):\n        self.fieldName = name\n        ptree.types.SimpleParameter.__init__(self, \n            name=name, autoIncrementName=True, type=\'bool\', value=True, removable=True, renamable=True)\n        self.setEnumVals(opts)            \n    \n    def generateMask(self, data, startMask):\n        vals = data[self.fieldName][startMask]\n        mask = np.ones(len(vals), dtype=bool)\n        otherMask = np.ones(len(vals), dtype=bool)\n        for c in self:\n            key = c.maskValue\n            if key == \'__other__\':\n                m = ~otherMask\n            else:\n                m = vals != key\n                otherMask &= m\n            if c.value() is False:\n                mask &= m\n        startMask[startMask] = mask\n        return startMask\n\n    def describe(self):\n        vals = [ch.name() for ch in self if ch.value() is True]\n        return ""%s: %s"" % (self.fieldName, \', \'.join(vals))\n\n    def updateFilter(self, opts):\n        self.setEnumVals(opts)\n\n    def setEnumVals(self, opts):\n        vals = opts.get(\'values\', {})\n\n        prevState = {}\n        for ch in self.children():\n            prevState[ch.name()] = ch.value()\n            self.removeChild(ch)\n\n        if not isinstance(vals, dict):\n            vals = OrderedDict([(v,(str(v), True)) for v in vals])\n        \n        # Each filterable value can come with either (1) a string name, (2) a bool\n        # indicating whether the value is enabled by default, or (3) a tuple providing\n        # both.\n        for val,valopts in vals.items():\n            if isinstance(valopts, bool):\n                enabled = valopts\n                vname = str(val)\n            elif isinstance(valopts, basestring):\n                enabled = True\n                vname = valopts\n            elif isinstance(valopts, tuple):\n                vname, enabled = valopts\n\n            ch = ptree.Parameter.create(name=vname, type=\'bool\', value=prevState.get(vname, enabled))\n            ch.maskValue = val\n            self.addChild(ch)\n        ch = ptree.Parameter.create(name=\'(other)\', type=\'bool\', value=prevState.get(\'(other)\', True))\n        ch.maskValue = \'__other__\'\n        self.addChild(ch)\n'"
src/third_party/pyqtgraph/widgets/DataTreeWidget.py,2,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtGui, QtCore\nfrom ..pgcollections import OrderedDict\nfrom .TableWidget import TableWidget\nfrom ..python2_3 import asUnicode\nimport types, traceback\nimport numpy as np\n\ntry:\n    import metaarray\n    HAVE_METAARRAY = True\nexcept:\n    HAVE_METAARRAY = False\n\n__all__ = [\'DataTreeWidget\']\n\nclass DataTreeWidget(QtGui.QTreeWidget):\n    """"""\n    Widget for displaying hierarchical python data structures\n    (eg, nested dicts, lists, and arrays)\n    """"""\n    def __init__(self, parent=None, data=None):\n        QtGui.QTreeWidget.__init__(self, parent)\n        self.setVerticalScrollMode(self.ScrollPerPixel)\n        self.setData(data)\n        self.setColumnCount(3)\n        self.setHeaderLabels([\'key / index\', \'type\', \'value\'])\n        self.setAlternatingRowColors(True)\n        \n    def setData(self, data, hideRoot=False):\n        """"""data should be a dictionary.""""""\n        self.clear()\n        self.widgets = []\n        self.nodes = {}\n        self.buildTree(data, self.invisibleRootItem(), hideRoot=hideRoot)\n        self.expandToDepth(3)\n        self.resizeColumnToContents(0)\n        \n    def buildTree(self, data, parent, name=\'\', hideRoot=False, path=()):\n        if hideRoot:\n            node = parent\n        else:\n            node = QtGui.QTreeWidgetItem([name, """", """"])\n            parent.addChild(node)\n        \n        # record the path to the node so it can be retrieved later\n        # (this is used by DiffTreeWidget)\n        self.nodes[path] = node\n\n        typeStr, desc, childs, widget = self.parse(data)\n        node.setText(1, typeStr)\n        node.setText(2, desc)\n            \n        # Truncate description and add text box if needed\n        if len(desc) > 100:\n            desc = desc[:97] + \'...\'\n            if widget is None:\n                widget = QtGui.QPlainTextEdit(asUnicode(data))\n                widget.setMaximumHeight(200)\n                widget.setReadOnly(True)\n        \n        # Add widget to new subnode\n        if widget is not None:\n            self.widgets.append(widget)\n            subnode = QtGui.QTreeWidgetItem(["""", """", """"])\n            node.addChild(subnode)\n            self.setItemWidget(subnode, 0, widget)\n            self.setFirstItemColumnSpanned(subnode, True)\n            \n        # recurse to children\n        for key, data in childs.items():\n            self.buildTree(data, node, asUnicode(key), path=path+(key,))\n\n    def parse(self, data):\n        """"""\n        Given any python object, return:\n        * type\n        * a short string representation\n        * a dict of sub-objects to be parsed\n        * optional widget to display as sub-node\n        """"""\n        # defaults for all objects\n        typeStr = type(data).__name__\n        if typeStr == \'instance\':\n            typeStr += "": "" + data.__class__.__name__\n        widget = None\n        desc = """"\n        childs = {}\n        \n        # type-specific changes\n        if isinstance(data, dict):\n            desc = ""length=%d"" % len(data)\n            if isinstance(data, OrderedDict):\n                childs = data\n            else:\n                childs = OrderedDict(sorted(data.items()))\n        elif isinstance(data, (list, tuple)):\n            desc = ""length=%d"" % len(data)\n            childs = OrderedDict(enumerate(data))\n        elif HAVE_METAARRAY and (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n            childs = OrderedDict([\n                (\'data\', data.view(np.ndarray)),\n                (\'meta\', data.infoCopy())\n            ])\n        elif isinstance(data, np.ndarray):\n            desc = ""shape=%s dtype=%s"" % (data.shape, data.dtype)\n            table = TableWidget()\n            table.setData(data)\n            table.setMaximumHeight(200)\n            widget = table\n        elif isinstance(data, types.TracebackType):  ## convert traceback to a list of strings\n            frames = list(map(str.strip, traceback.format_list(traceback.extract_tb(data))))\n            #childs = OrderedDict([\n                #(i, {\'file\': child[0], \'line\': child[1], \'function\': child[2], \'code\': child[3]})\n                #for i, child in enumerate(frames)])\n            #childs = OrderedDict([(i, ch) for i,ch in enumerate(frames)])\n            widget = QtGui.QPlainTextEdit(asUnicode(\'\\n\'.join(frames)))\n            widget.setMaximumHeight(200)\n            widget.setReadOnly(True)\n        else:\n            desc = asUnicode(data)\n        \n        return typeStr, desc, childs, widget\n        '"
src/third_party/pyqtgraph/widgets/DiffTreeWidget.py,15,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtGui, QtCore\nfrom ..pgcollections import OrderedDict\nfrom .DataTreeWidget import DataTreeWidget\nfrom .. import functions as fn\nimport types, traceback\nimport numpy as np\n\n__all__ = [\'DiffTreeWidget\']\n\n\nclass DiffTreeWidget(QtGui.QWidget):\n    """"""\n    Widget for displaying differences between hierarchical python data structures\n    (eg, nested dicts, lists, and arrays)\n    """"""\n    def __init__(self, parent=None, a=None, b=None):\n        QtGui.QWidget.__init__(self, parent)\n        self.layout = QtGui.QHBoxLayout()\n        self.setLayout(self.layout)\n        self.trees = [DataTreeWidget(self), DataTreeWidget(self)]\n        for t in self.trees:\n            self.layout.addWidget(t)\n        if a is not None:\n            self.setData(a, b)\n    \n    def setData(self, a, b):\n        """"""\n        Set the data to be compared in this widget.\n        """"""\n        self.data = (a, b)\n        self.trees[0].setData(a)\n        self.trees[1].setData(b)\n        \n        return self.compare(a, b)\n        \n    def compare(self, a, b, path=()):\n        """"""\n        Compare data structure *a* to structure *b*. \n        \n        Return True if the objects match completely. \n        Otherwise, return a structure that describes the differences:\n        \n            { \'type\': bool\n              \'len\': bool,\n              \'str\': bool,\n              \'shape\': bool,\n              \'dtype\': bool,\n              \'mask\': array,\n              }\n        \n                \n        """"""\n        bad = (255, 200, 200)\n        diff = []\n        # generate typestr, desc, childs for each object\n        typeA, descA, childsA, _ = self.trees[0].parse(a)\n        typeB, descB, childsB, _ = self.trees[1].parse(b)\n        \n        if typeA != typeB:\n            self.setColor(path, 1, bad)\n        if descA != descB:\n            self.setColor(path, 2, bad)\n            \n        if isinstance(a, dict) and isinstance(b, dict):\n            keysA = set(a.keys())\n            keysB = set(b.keys())\n            for key in keysA - keysB:\n                self.setColor(path+(key,), 0, bad, tree=0)\n            for key in keysB - keysA:\n                self.setColor(path+(key,), 0, bad, tree=1)\n            for key in keysA & keysB:\n                self.compare(a[key], b[key], path+(key,))\n            \n        elif isinstance(a, (list, tuple)) and isinstance(b, (list, tuple)):\n            for i in range(max(len(a), len(b))):\n                if len(a) <= i:\n                    self.setColor(path+(i,), 0, bad, tree=1)\n                elif len(b) <= i:\n                    self.setColor(path+(i,), 0, bad, tree=0)\n                else:\n                    self.compare(a[i], b[i], path+(i,))\n                    \n        elif isinstance(a, np.ndarray) and isinstance(b, np.ndarray) and a.shape == b.shape:\n            tableNodes = [tree.nodes[path].child(0) for tree in self.trees]\n            if a.dtype.fields is None and b.dtype.fields is None:\n                eq = self.compareArrays(a, b)\n                if not np.all(eq):\n                    for n in tableNodes:\n                        n.setBackground(0, fn.mkBrush(bad))\n                #for i in np.argwhere(~eq):\n                    \n            else:\n                if a.dtype == b.dtype:\n                    for i,k in enumerate(a.dtype.fields.keys()):\n                        eq = self.compareArrays(a[k], b[k])\n                        if not np.all(eq):\n                            for n in tableNodes:\n                                n.setBackground(0, fn.mkBrush(bad))\n                        #for j in np.argwhere(~eq):\n                    \n        # dict: compare keys, then values where keys match\n        # list: \n        # array: compare elementwise for same shape\n\n    def compareArrays(self, a, b):\n        intnan = -9223372036854775808  # happens when np.nan is cast to int\n        anans = np.isnan(a) | (a == intnan)\n        bnans = np.isnan(b) | (b == intnan)\n        eq = anans == bnans\n        mask = ~anans\n        eq[mask] = np.allclose(a[mask], b[mask])\n        return eq\n    \n    def setColor(self, path, column, color, tree=None):\n        brush = fn.mkBrush(color)\n        \n        # Color only one tree if specified.\n        if tree is None:\n            trees = self.trees\n        else:\n            trees = [self.trees[tree]]\n        \n        for tree in trees:\n            item = tree.nodes[path]\n            item.setBackground(column, brush)\n    \n    def _compare(self, a, b):\n        """"""\n        Compare data structure *a* to structure *b*. \n        """"""\n        # Check test structures are the same\n        assert type(info) is type(expect)\n        if hasattr(info, \'__len__\'):\n            assert len(info) == len(expect)\n            \n        if isinstance(info, dict):\n            for k in info:\n                assert k in expect\n            for k in expect:\n                assert k in info\n                self.compare_results(info[k], expect[k])\n        elif isinstance(info, list):\n            for i in range(len(info)):\n                self.compare_results(info[i], expect[i])\n        elif isinstance(info, np.ndarray):\n            assert info.shape == expect.shape\n            assert info.dtype == expect.dtype\n            if info.dtype.fields is None:\n                intnan = -9223372036854775808  # happens when np.nan is cast to int\n                inans = np.isnan(info) | (info == intnan)\n                enans = np.isnan(expect) | (expect == intnan)\n                assert np.all(inans == enans)\n                mask = ~inans\n                assert np.allclose(info[mask], expect[mask])\n            else:\n                for k in info.dtype.fields.keys():\n                    self.compare_results(info[k], expect[k])\n        else:\n            try:\n                assert info == expect\n            except Exception:\n                raise NotImplementedError(""Cannot compare objects of type %s"" % type(info))\n    '"
src/third_party/pyqtgraph/widgets/FeedbackButton.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtCore, QtGui\n\n__all__ = [\'FeedbackButton\']\n\nclass FeedbackButton(QtGui.QPushButton):\n    """"""\n    QPushButton which flashes success/failure indication for slow or asynchronous procedures.\n    """"""\n    \n    \n    ### For thread-safetyness\n    sigCallSuccess = QtCore.Signal(object, object, object)\n    sigCallFailure = QtCore.Signal(object, object, object)\n    sigCallProcess = QtCore.Signal(object, object, object)\n    sigReset = QtCore.Signal()\n    \n    def __init__(self, *args):\n        QtGui.QPushButton.__init__(self, *args)\n        self.origStyle = None\n        self.origText = self.text()\n        self.origStyle = self.styleSheet()\n        self.origTip = self.toolTip()\n        self.limitedTime = True\n        \n        \n        #self.textTimer = QtCore.QTimer()\n        #self.tipTimer = QtCore.QTimer()\n        #self.textTimer.timeout.connect(self.setText)\n        #self.tipTimer.timeout.connect(self.setToolTip)\n        \n        self.sigCallSuccess.connect(self.success)\n        self.sigCallFailure.connect(self.failure)\n        self.sigCallProcess.connect(self.processing)\n        self.sigReset.connect(self.reset)\n        \n\n    def feedback(self, success, message=None, tip="""", limitedTime=True):\n        """"""Calls success() or failure(). If you want the message to be displayed until the user takes an action, set limitedTime to False. Then call self.reset() after the desired action.Threadsafe.""""""\n        if success:\n            self.success(message, tip, limitedTime=limitedTime)\n        else:\n            self.failure(message, tip, limitedTime=limitedTime)\n    \n    def success(self, message=None, tip="""", limitedTime=True):\n        """"""Displays specified message on button and flashes button green to let user know action was successful. If you want the success to be displayed until the user takes an action, set limitedTime to False. Then call self.reset() after the desired action. Threadsafe.""""""\n        isGuiThread = QtCore.QThread.currentThread() == QtCore.QCoreApplication.instance().thread()\n        if isGuiThread:\n            self.setEnabled(True)\n            #print ""success""\n            self.startBlink(""#0F0"", message, tip, limitedTime=limitedTime)\n        else:\n            self.sigCallSuccess.emit(message, tip, limitedTime)\n            \n    def failure(self, message=None, tip="""", limitedTime=True):\n        """"""Displays specified message on button and flashes button red to let user know there was an error. If you want the error to be displayed until the user takes an action, set limitedTime to False. Then call self.reset() after the desired action. Threadsafe. """"""\n        isGuiThread = QtCore.QThread.currentThread() == QtCore.QCoreApplication.instance().thread()\n        if isGuiThread:\n            self.setEnabled(True)\n            #print ""fail""\n            self.startBlink(""#F00"", message, tip, limitedTime=limitedTime)\n        else:\n            self.sigCallFailure.emit(message, tip, limitedTime)\n\n    def processing(self, message=""Processing.."", tip="""", processEvents=True):\n        """"""Displays specified message on button to let user know the action is in progress. Threadsafe. """"""\n        isGuiThread = QtCore.QThread.currentThread() == QtCore.QCoreApplication.instance().thread()\n        if isGuiThread:\n            self.setEnabled(False)\n            self.setText(message, temporary=True)\n            self.setToolTip(tip, temporary=True)\n            if processEvents:\n                QtGui.QApplication.processEvents()\n        else:\n            self.sigCallProcess.emit(message, tip, processEvents)\n           \n                \n    def reset(self):\n        """"""Resets the button to its original text and style. Threadsafe.""""""\n        isGuiThread = QtCore.QThread.currentThread() == QtCore.QCoreApplication.instance().thread()\n        if isGuiThread:\n            self.limitedTime = True\n            self.setText()\n            self.setToolTip()\n            self.setStyleSheet()\n        else:\n            self.sigReset.emit()\n        \n    def startBlink(self, color, message=None, tip="""", limitedTime=True):\n        #if self.origStyle is None:\n            #self.origStyle = self.styleSheet()\n            #self.origText = self.text()\n        self.setFixedHeight(self.height())\n        \n        if message is not None:\n            self.setText(message, temporary=True)\n        self.setToolTip(tip, temporary=True)\n        self.count = 0\n        #self.indStyle = ""QPushButton {border: 2px solid %s; border-radius: 5px}"" % color\n        self.indStyle = ""QPushButton {background-color: %s}"" % color\n        self.limitedTime = limitedTime\n        self.borderOn()\n        if limitedTime:\n            QtCore.QTimer.singleShot(2000, self.setText)\n            QtCore.QTimer.singleShot(10000, self.setToolTip)\n\n    def borderOn(self):\n        self.setStyleSheet(self.indStyle, temporary=True)\n        if self.limitedTime or self.count <=2:\n            QtCore.QTimer.singleShot(100, self.borderOff)\n        \n            \n    def borderOff(self):\n        self.setStyleSheet()\n        self.count += 1\n        if self.count >= 2:\n            if self.limitedTime:\n                return\n        QtCore.QTimer.singleShot(30, self.borderOn)\n        \n            \n    def setText(self, text=None, temporary=False):\n        if text is None:\n            text = self.origText\n        #print text\n        QtGui.QPushButton.setText(self, text)\n        if not temporary:\n            self.origText = text\n\n    def setToolTip(self, text=None, temporary=False):\n        if text is None:\n            text = self.origTip\n        QtGui.QPushButton.setToolTip(self, text)\n        if not temporary:\n            self.origTip = text\n\n    def setStyleSheet(self, style=None, temporary=False):\n        if style is None:\n            style = self.origStyle\n        QtGui.QPushButton.setStyleSheet(self, style)\n        if not temporary:\n            self.origStyle = style\n\n\nif __name__ == \'__main__\':\n    import time\n    app = QtGui.QApplication([])\n    win = QtGui.QMainWindow()\n    btn = FeedbackButton(""Button"")\n    fail = True\n    def click():\n        btn.processing(""Hold on.."")\n        time.sleep(2.0)\n        \n        global fail\n        fail = not fail\n        if fail:\n            btn.failure(message=""FAIL."", tip=""There was a failure. Get over it."")\n        else:\n            btn.success(message=""Bueno!"")\n    btn.clicked.connect(click)\n    win.setCentralWidget(btn)\n    win.show()'"
src/third_party/pyqtgraph/widgets/FileDialog.py,0,"b""from ..Qt import QtGui, QtCore\nimport sys\n\n__all__ = ['FileDialog']\n\nclass FileDialog(QtGui.QFileDialog):\n    ## Compatibility fix for OSX:\n    ## For some reason the native dialog doesn't show up when you set AcceptMode to AcceptSave on OS X, so we don't use the native dialog    \n    \n    def __init__(self, *args):\n        QtGui.QFileDialog.__init__(self, *args)\n        \n        if sys.platform == 'darwin': \n            self.setOption(QtGui.QFileDialog.DontUseNativeDialog)"""
src/third_party/pyqtgraph/widgets/GradientWidget.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtGui, QtCore\nfrom .GraphicsView import GraphicsView\nfrom ..graphicsItems.GradientEditorItem import GradientEditorItem\nimport weakref\nimport numpy as np\n\n__all__ = [\'GradientWidget\']\n\n\nclass GradientWidget(GraphicsView):\n    """"""\n    Widget displaying an editable color gradient. The user may add, move, recolor,\n    or remove colors from the gradient. Additionally, a context menu allows the \n    user to select from pre-defined gradients.\n    """"""\n    sigGradientChanged = QtCore.Signal(object)\n    sigGradientChangeFinished = QtCore.Signal(object)\n    \n    def __init__(self, parent=None, orientation=\'bottom\',  *args, **kargs):\n        """"""\n        The *orientation* argument may be \'bottom\', \'top\', \'left\', or \'right\' \n        indicating whether the gradient is displayed horizontally (top, bottom)\n        or vertically (left, right) and on what side of the gradient the editable \n        ticks will appear.\n        \n        All other arguments are passed to \n        :func:`GradientEditorItem.__init__ <pyqtgraph.GradientEditorItem.__init__>`.\n        \n        Note: For convenience, this class wraps methods from \n        :class:`GradientEditorItem <pyqtgraph.GradientEditorItem>`.\n        """"""\n        GraphicsView.__init__(self, parent, useOpenGL=False, background=None)\n        self.maxDim = 31\n        kargs[\'tickPen\'] = \'k\'\n        self.item = GradientEditorItem(*args, **kargs)\n        self.item.sigGradientChanged.connect(self.sigGradientChanged)\n        self.item.sigGradientChangeFinished.connect(self.sigGradientChangeFinished)\n        self.setCentralItem(self.item)\n        self.setOrientation(orientation)\n        self.setCacheMode(self.CacheNone)\n        self.setRenderHints(QtGui.QPainter.Antialiasing | QtGui.QPainter.TextAntialiasing)\n        self.setFrameStyle(QtGui.QFrame.NoFrame | QtGui.QFrame.Plain)\n        #self.setBackgroundRole(QtGui.QPalette.NoRole)\n        #self.setBackgroundBrush(QtGui.QBrush(QtCore.Qt.NoBrush))\n        #self.setAutoFillBackground(False)\n        #self.setAttribute(QtCore.Qt.WA_PaintOnScreen, False)\n        #self.setAttribute(QtCore.Qt.WA_OpaquePaintEvent, True)\n\n    def setOrientation(self, ort):\n        """"""Set the orientation of the widget. May be one of \'bottom\', \'top\', \n        \'left\', or \'right\'.""""""\n        self.item.setOrientation(ort)\n        self.orientation = ort\n        self.setMaxDim()\n        \n    def setMaxDim(self, mx=None):\n        if mx is None:\n            mx = self.maxDim\n        else:\n            self.maxDim = mx\n            \n        if self.orientation in [\'bottom\', \'top\']:\n            self.setFixedHeight(mx)\n            self.setMaximumWidth(16777215)\n        else:\n            self.setFixedWidth(mx)\n            self.setMaximumHeight(16777215)\n        \n    def __getattr__(self, attr):\n        ### wrap methods from GradientEditorItem\n        return getattr(self.item, attr)\n\n\n'"
src/third_party/pyqtgraph/widgets/GraphicsLayoutWidget.py,0,"b'from ..Qt import QtGui, mkQApp\nfrom ..graphicsItems.GraphicsLayout import GraphicsLayout\nfrom .GraphicsView import GraphicsView\n\n__all__ = [\'GraphicsLayoutWidget\']\nclass GraphicsLayoutWidget(GraphicsView):\n    """"""\n    Convenience class consisting of a :class:`GraphicsView \n    <pyqtgraph.GraphicsView>` with a single :class:`GraphicsLayout\n    <pyqtgraph.GraphicsLayout>` as its central item. \n\n    This widget is an easy starting point for generating multi-panel figures.\n    Example::\n    \n        w = pg.GraphicsLayoutWidget()\n        p1 = w.addPlot(row=0, col=0)\n        p2 = w.addPlot(row=0, col=1)\n        v = w.addViewBox(row=1, col=0, colspan=2)\n    \n    Parameters\n    ----------\n    parent : QWidget or None\n        The parent widget (see QWidget.__init__)\n    show : bool\n        If True, then immediately show the widget after it is created.\n        If the widget has no parent, then it will be shown inside a new window.\n    size : (width, height) tuple\n        Optionally resize the widget. Note: if this widget is placed inside a\n        layout, then this argument has no effect.\n    title : str or None\n        If specified, then set the window title for this widget.\n    kargs : \n        All extra arguments are passed to \n        :func:`GraphicsLayout.__init__() <pyqtgraph.GraphicsLayout.__init__>`\n        \n\n    This class wraps several methods from its internal GraphicsLayout:\n    :func:`nextRow <pyqtgraph.GraphicsLayout.nextRow>`\n    :func:`nextColumn <pyqtgraph.GraphicsLayout.nextColumn>`\n    :func:`addPlot <pyqtgraph.GraphicsLayout.addPlot>`\n    :func:`addViewBox <pyqtgraph.GraphicsLayout.addViewBox>`\n    :func:`addItem <pyqtgraph.GraphicsLayout.addItem>`\n    :func:`getItem <pyqtgraph.GraphicsLayout.getItem>`\n    :func:`addLabel <pyqtgraph.GraphicsLayout.addLabel>`\n    :func:`addLayout <pyqtgraph.GraphicsLayout.addLayout>`\n    :func:`removeItem <pyqtgraph.GraphicsLayout.removeItem>`\n    :func:`itemIndex <pyqtgraph.GraphicsLayout.itemIndex>`\n    :func:`clear <pyqtgraph.GraphicsLayout.clear>`\n    """"""\n    def __init__(self, parent=None, show=False, size=None, title=None, **kargs):\n        mkQApp()\n        GraphicsView.__init__(self, parent)\n        self.ci = GraphicsLayout(**kargs)\n        for n in [\'nextRow\', \'nextCol\', \'nextColumn\', \'addPlot\', \'addViewBox\', \'addItem\', \'getItem\', \'addLayout\', \'addLabel\', \'removeItem\', \'itemIndex\', \'clear\']:\n            setattr(self, n, getattr(self.ci, n))\n        self.setCentralItem(self.ci)\n        \n        if size is not None:\n            self.resize(*size)\n            \n        if title is not None:\n            self.setWindowTitle(title)\n            \n        if show is True:\n            self.show()\n'"
src/third_party/pyqtgraph/widgets/GraphicsView.py,1,"b'# -*- coding: utf-8 -*-\n""""""\nGraphicsView.py -   Extension of QGraphicsView\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n""""""\n\nfrom ..Qt import QtCore, QtGui, QT_LIB\n\ntry:\n    from ..Qt import QtOpenGL\n    HAVE_OPENGL = True\nexcept ImportError:\n    HAVE_OPENGL = False\n\nfrom ..Point import Point\nimport sys, os\nfrom .FileDialog import FileDialog\nfrom ..GraphicsScene import GraphicsScene\nimport numpy as np\nfrom .. import functions as fn\nfrom .. import debug as debug\nfrom .. import getConfigOption\n\n__all__ = [\'GraphicsView\']\n\nclass GraphicsView(QtGui.QGraphicsView):\n    """"""Re-implementation of QGraphicsView that removes scrollbars and allows unambiguous control of the \n    viewed coordinate range. Also automatically creates a GraphicsScene and a central QGraphicsWidget\n    that is automatically scaled to the full view geometry.\n    \n    This widget is the basis for :class:`PlotWidget <pyqtgraph.PlotWidget>`, \n    :class:`GraphicsLayoutWidget <pyqtgraph.GraphicsLayoutWidget>`, and the view widget in\n    :class:`ImageView <pyqtgraph.ImageView>`.\n    \n    By default, the view coordinate system matches the widget\'s pixel coordinates and \n    automatically updates when the view is resized. This can be overridden by setting \n    autoPixelRange=False. The exact visible range can be set with setRange().\n    \n    The view can be panned using the middle mouse button and scaled using the right mouse button if\n    enabled via enableMouse()  (but ordinarily, we use ViewBox for this functionality).""""""\n    \n    sigDeviceRangeChanged = QtCore.Signal(object, object)\n    sigDeviceTransformChanged = QtCore.Signal(object)\n    sigMouseReleased = QtCore.Signal(object)\n    sigSceneMouseMoved = QtCore.Signal(object)\n    #sigRegionChanged = QtCore.Signal(object)\n    sigScaleChanged = QtCore.Signal(object)\n    lastFileDir = None\n    \n    def __init__(self, parent=None, useOpenGL=None, background=\'default\'):\n        """"""\n        ==============  ============================================================\n        **Arguments:**\n        parent          Optional parent widget\n        useOpenGL       If True, the GraphicsView will use OpenGL to do all of its\n                        rendering. This can improve performance on some systems,\n                        but may also introduce bugs (the combination of \n                        QGraphicsView and QGLWidget is still an \'experimental\' \n                        feature of Qt)\n        background      Set the background color of the GraphicsView. Accepts any\n                        single argument accepted by \n                        :func:`mkColor <pyqtgraph.mkColor>`. By \n                        default, the background color is determined using the\n                        \'backgroundColor\' configuration option (see \n                        :func:`setConfigOptions <pyqtgraph.setConfigOptions>`).\n        ==============  ============================================================\n        """"""\n        \n        self.closed = False\n        \n        QtGui.QGraphicsView.__init__(self, parent)\n        \n        # This connects a cleanup function to QApplication.aboutToQuit. It is\n        # called from here because we have no good way to react when the\n        # QApplication is created by the user.\n        # See pyqtgraph.__init__.py\n        from .. import _connectCleanup\n        _connectCleanup()\n        \n        if useOpenGL is None:\n            useOpenGL = getConfigOption(\'useOpenGL\')\n        \n        self.useOpenGL(useOpenGL)\n        \n        self.setCacheMode(self.CacheBackground)\n        \n        ## This might help, but it\'s probably dangerous in the general case..\n        #self.setOptimizationFlag(self.DontSavePainterState, True)\n        \n        self.setBackgroundRole(QtGui.QPalette.NoRole)\n        self.setBackground(background)\n        \n        self.setFocusPolicy(QtCore.Qt.StrongFocus)\n        self.setFrameShape(QtGui.QFrame.NoFrame)\n        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        self.setTransformationAnchor(QtGui.QGraphicsView.NoAnchor)\n        self.setResizeAnchor(QtGui.QGraphicsView.AnchorViewCenter)\n        self.setViewportUpdateMode(QtGui.QGraphicsView.MinimalViewportUpdate)\n        \n        \n        self.lockedViewports = []\n        self.lastMousePos = None\n        self.setMouseTracking(True)\n        self.aspectLocked = False\n        self.range = QtCore.QRectF(0, 0, 1, 1)\n        self.autoPixelRange = True\n        self.currentItem = None\n        self.clearMouse()\n        self.updateMatrix()\n        # GraphicsScene must have parent or expect crashes!\n        self.sceneObj = GraphicsScene(parent=self)\n        self.setScene(self.sceneObj)\n        \n        ## Workaround for PySide crash\n        ## This ensures that the scene will outlive the view.\n        if QT_LIB == \'PySide\':\n            self.sceneObj._view_ref_workaround = self\n        \n        ## by default we set up a central widget with a grid layout.\n        ## this can be replaced if needed.\n        self.centralWidget = None\n        self.setCentralItem(QtGui.QGraphicsWidget())\n        self.centralLayout = QtGui.QGraphicsGridLayout()\n        self.centralWidget.setLayout(self.centralLayout)\n        \n        self.mouseEnabled = False\n        self.scaleCenter = False  ## should scaling center around view center (True) or mouse click (False)\n        self.clickAccepted = False\n        \n    def setAntialiasing(self, aa):\n        """"""Enable or disable default antialiasing.\n        Note that this will only affect items that do not specify their own antialiasing options.""""""\n        if aa:\n            self.setRenderHints(self.renderHints() | QtGui.QPainter.Antialiasing)\n        else:\n            self.setRenderHints(self.renderHints() & ~QtGui.QPainter.Antialiasing)\n        \n    def setBackground(self, background):\n        """"""\n        Set the background color of the GraphicsView.\n        To use the defaults specified py pyqtgraph.setConfigOption, use background=\'default\'.\n        To make the background transparent, use background=None.\n        """"""\n        self._background = background\n        if background == \'default\':\n            background = getConfigOption(\'background\')\n        brush = fn.mkBrush(background)\n        self.setBackgroundBrush(brush)\n    \n    def paintEvent(self, ev):\n        self.scene().prepareForPaint()\n        return QtGui.QGraphicsView.paintEvent(self, ev)\n    \n    def render(self, *args, **kwds):\n        self.scene().prepareForPaint()\n        return QtGui.QGraphicsView.render(self, *args, **kwds)\n        \n    \n    def close(self):\n        self.centralWidget = None\n        self.scene().clear()\n        self.currentItem = None\n        self.sceneObj = None\n        self.closed = True\n        self.setViewport(None)\n        super(GraphicsView, self).close()\n\n    def useOpenGL(self, b=True):\n        if b:\n            if not HAVE_OPENGL:\n                raise Exception(""Requested to use OpenGL with QGraphicsView, but QtOpenGL module is not available."")\n            v = QtOpenGL.QGLWidget()\n        else:\n            v = QtGui.QWidget()\n            \n        self.setViewport(v)\n            \n    def keyPressEvent(self, ev):\n        self.scene().keyPressEvent(ev)  ## bypass view, hand event directly to scene\n                                        ## (view likes to eat arrow key events)\n        \n        \n    def setCentralItem(self, item):\n        return self.setCentralWidget(item)\n        \n    def setCentralWidget(self, item):\n        """"""Sets a QGraphicsWidget to automatically fill the entire view (the item will be automatically\n        resize whenever the GraphicsView is resized).""""""\n        if self.centralWidget is not None:\n            self.scene().removeItem(self.centralWidget)\n        self.centralWidget = item\n        if item is not None:\n            self.sceneObj.addItem(item)\n            self.resizeEvent(None)\n        \n    def addItem(self, *args):\n        return self.scene().addItem(*args)\n        \n    def removeItem(self, *args):\n        return self.scene().removeItem(*args)\n        \n    def enableMouse(self, b=True):\n        self.mouseEnabled = b\n        self.autoPixelRange = (not b)\n        \n    def clearMouse(self):\n        self.mouseTrail = []\n        self.lastButtonReleased = None\n    \n    def resizeEvent(self, ev):\n        if self.closed:\n            return\n        if self.autoPixelRange:\n            self.range = QtCore.QRectF(0, 0, self.size().width(), self.size().height())\n        GraphicsView.setRange(self, self.range, padding=0, disableAutoPixel=False)  ## we do this because some subclasses like to redefine setRange in an incompatible way.\n        self.updateMatrix()\n    \n    def updateMatrix(self, propagate=True):\n        self.setSceneRect(self.range)\n        if self.autoPixelRange:\n            self.resetTransform()\n        else:\n            if self.aspectLocked:\n                self.fitInView(self.range, QtCore.Qt.KeepAspectRatio)\n            else:\n                self.fitInView(self.range, QtCore.Qt.IgnoreAspectRatio)\n            \n        self.sigDeviceRangeChanged.emit(self, self.range)\n        self.sigDeviceTransformChanged.emit(self)\n        \n        if propagate:\n            for v in self.lockedViewports:\n                v.setXRange(self.range, padding=0)\n        \n    def viewRect(self):\n        """"""Return the boundaries of the view in scene coordinates""""""\n        ## easier to just return self.range ?\n        r = QtCore.QRectF(self.rect())\n        return self.viewportTransform().inverted()[0].mapRect(r)\n\n    def visibleRange(self):\n        ## for backward compatibility\n        return self.viewRect()\n\n    def translate(self, dx, dy):\n        self.range.adjust(dx, dy, dx, dy)\n        self.updateMatrix()\n    \n    def scale(self, sx, sy, center=None):\n        scale = [sx, sy]\n        if self.aspectLocked:\n            scale[0] = scale[1]\n        \n        if self.scaleCenter:\n            center = None\n        if center is None:\n            center = self.range.center()\n            \n        w = self.range.width()  / scale[0]\n        h = self.range.height() / scale[1]\n        self.range = QtCore.QRectF(center.x() - (center.x()-self.range.left()) / scale[0], center.y() - (center.y()-self.range.top())  /scale[1], w, h)\n        \n        \n        self.updateMatrix()\n        self.sigScaleChanged.emit(self)\n\n    def setRange(self, newRect=None, padding=0.05, lockAspect=None, propagate=True, disableAutoPixel=True):\n        if disableAutoPixel:\n            self.autoPixelRange=False\n        if newRect is None:\n            newRect = self.visibleRange()\n            padding = 0\n        \n        padding = Point(padding)\n        newRect = QtCore.QRectF(newRect)\n        pw = newRect.width() * padding[0]\n        ph = newRect.height() * padding[1]\n        newRect = newRect.adjusted(-pw, -ph, pw, ph)\n        scaleChanged = False\n        if self.range.width() != newRect.width() or self.range.height() != newRect.height():\n            scaleChanged = True\n        self.range = newRect\n        #print ""New Range:"", self.range\n        if self.centralWidget is not None:\n            self.centralWidget.setGeometry(self.range)\n        self.updateMatrix(propagate)\n        if scaleChanged:\n            self.sigScaleChanged.emit(self)\n\n    def scaleToImage(self, image):\n        """"""Scales such that pixels in image are the same size as screen pixels. This may result in a significant performance increase.""""""\n        pxSize = image.pixelSize()\n        image.setPxMode(True)\n        try:\n            self.sigScaleChanged.disconnect(image.setScaledMode)\n        except (TypeError, RuntimeError):\n            pass\n        tl = image.sceneBoundingRect().topLeft()\n        w = self.size().width() * pxSize[0]\n        h = self.size().height() * pxSize[1]\n        range = QtCore.QRectF(tl.x(), tl.y(), w, h)\n        GraphicsView.setRange(self, range, padding=0)\n        self.sigScaleChanged.connect(image.setScaledMode)\n        \n        \n        \n    def lockXRange(self, v1):\n        if not v1 in self.lockedViewports:\n            self.lockedViewports.append(v1)\n        \n    def setXRange(self, r, padding=0.05):\n        r1 = QtCore.QRectF(self.range)\n        r1.setLeft(r.left())\n        r1.setRight(r.right())\n        GraphicsView.setRange(self, r1, padding=[padding, 0], propagate=False)\n        \n    def setYRange(self, r, padding=0.05):\n        r1 = QtCore.QRectF(self.range)\n        r1.setTop(r.top())\n        r1.setBottom(r.bottom())\n        GraphicsView.setRange(self, r1, padding=[0, padding], propagate=False)\n        \n    def wheelEvent(self, ev):\n        QtGui.QGraphicsView.wheelEvent(self, ev)\n        if not self.mouseEnabled:\n            ev.ignore()\n            return\n        sc = 1.001 ** ev.delta()\n        #self.scale *= sc\n        #self.updateMatrix()\n        self.scale(sc, sc)\n        \n    def setAspectLocked(self, s):\n        self.aspectLocked = s\n        \n    def leaveEvent(self, ev):\n        self.scene().leaveEvent(ev)  ## inform scene when mouse leaves\n        \n    def mousePressEvent(self, ev):\n        QtGui.QGraphicsView.mousePressEvent(self, ev)\n        \n\n        if not self.mouseEnabled:\n            return\n        self.lastMousePos = Point(ev.pos())\n        self.mousePressPos = ev.pos()\n        self.clickAccepted = ev.isAccepted()\n        if not self.clickAccepted:\n            self.scene().clearSelection()\n        return   ## Everything below disabled for now..\n        \n    def mouseReleaseEvent(self, ev):\n        QtGui.QGraphicsView.mouseReleaseEvent(self, ev)\n        if not self.mouseEnabled:\n            return \n        self.sigMouseReleased.emit(ev)\n        self.lastButtonReleased = ev.button()\n        return   ## Everything below disabled for now..\n        \n    def mouseMoveEvent(self, ev):\n        if self.lastMousePos is None:\n            self.lastMousePos = Point(ev.pos())\n        delta = Point(ev.pos() - self.lastMousePos)\n        self.lastMousePos = Point(ev.pos())\n\n        QtGui.QGraphicsView.mouseMoveEvent(self, ev)\n        if not self.mouseEnabled:\n            return\n        self.sigSceneMouseMoved.emit(self.mapToScene(ev.pos()))\n            \n        if self.clickAccepted:  ## Ignore event if an item in the scene has already claimed it.\n            return\n        \n        if ev.buttons() == QtCore.Qt.RightButton:\n            delta = Point(np.clip(delta[0], -50, 50), np.clip(-delta[1], -50, 50))\n            scale = 1.01 ** delta\n            self.scale(scale[0], scale[1], center=self.mapToScene(self.mousePressPos))\n            self.sigDeviceRangeChanged.emit(self, self.range)\n\n        elif ev.buttons() in [QtCore.Qt.MidButton, QtCore.Qt.LeftButton]:  ## Allow panning by left or mid button.\n            px = self.pixelSize()\n            tr = -delta * px\n            \n            self.translate(tr[0], tr[1])\n            self.sigDeviceRangeChanged.emit(self, self.range)\n        \n    def pixelSize(self):\n        """"""Return vector with the length and width of one view pixel in scene coordinates""""""\n        p0 = Point(0,0)\n        p1 = Point(1,1)\n        tr = self.transform().inverted()[0]\n        p01 = tr.map(p0)\n        p11 = tr.map(p1)\n        return Point(p11 - p01)\n        \n    def dragEnterEvent(self, ev):\n        ev.ignore()  ## not sure why, but for some reason this class likes to consume drag events\n        \n\n'"
src/third_party/pyqtgraph/widgets/GroupBox.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .PathButton import PathButton\nfrom ..python2_3 import basestring\n\n\nclass GroupBox(QtGui.QGroupBox):\n    """"""Subclass of QGroupBox that implements collapse handle.\n    """"""\n    sigCollapseChanged = QtCore.Signal(object)\n    \n    def __init__(self, *args):\n        QtGui.QGroupBox.__init__(self, *args)\n        \n        self._collapsed = False\n        # We modify the size policy when the group box is collapsed, so \n        # keep track of the last requested policy:\n        self._lastSizePlocy = self.sizePolicy()\n        \n        self.closePath = QtGui.QPainterPath()\n        self.closePath.moveTo(0, -1)\n        self.closePath.lineTo(0, 1)\n        self.closePath.lineTo(1, 0)\n        self.closePath.lineTo(0, -1)\n        \n        self.openPath = QtGui.QPainterPath()\n        self.openPath.moveTo(-1, 0)\n        self.openPath.lineTo(1, 0)\n        self.openPath.lineTo(0, 1)\n        self.openPath.lineTo(-1, 0)\n        \n        self.collapseBtn = PathButton(path=self.openPath, size=(12, 12), margin=0)\n        self.collapseBtn.setStyleSheet(""""""\n            border: none;\n        """""")\n        self.collapseBtn.setPen(\'k\')\n        self.collapseBtn.setBrush(\'w\')\n        self.collapseBtn.setParent(self)\n        self.collapseBtn.move(3, 3)\n        self.collapseBtn.setFlat(True)\n        \n        self.collapseBtn.clicked.connect(self.toggleCollapsed)\n\n        if len(args) > 0 and isinstance(args[0], basestring):\n            self.setTitle(args[0])\n        \n    def toggleCollapsed(self):\n        self.setCollapsed(not self._collapsed)\n\n    def collapsed(self):\n        return self._collapsed\n    \n    def setCollapsed(self, c):\n        if c == self._collapsed:\n            return\n        \n        if c is True:\n            self.collapseBtn.setPath(self.closePath)\n            self.setSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred, closing=True)\n        elif c is False:\n            self.collapseBtn.setPath(self.openPath)\n            self.setSizePolicy(self._lastSizePolicy)\n        else:\n            raise TypeError(""Invalid argument %r; must be bool."" % c)\n        \n        for ch in self.children():\n            if isinstance(ch, QtGui.QWidget) and ch is not self.collapseBtn:\n                ch.setVisible(not c)\n        \n        self._collapsed = c\n        self.sigCollapseChanged.emit(c)\n\n    def setSizePolicy(self, *args, **kwds):\n        QtGui.QGroupBox.setSizePolicy(self, *args)\n        if kwds.pop(\'closing\', False) is True:\n            self._lastSizePolicy = self.sizePolicy()\n\n    def setHorizontalPolicy(self, *args):\n        QtGui.QGroupBox.setHorizontalPolicy(self, *args)\n        self._lastSizePolicy = self.sizePolicy()\n\n    def setVerticalPolicy(self, *args):\n        QtGui.QGroupBox.setVerticalPolicy(self, *args)\n        self._lastSizePolicy = self.sizePolicy()\n\n    def setTitle(self, title):\n        # Leave room for button\n        QtGui.QGroupBox.setTitle(self, ""   "" + title)\n        \n    def widgetGroupInterface(self):\n        return (self.sigCollapseChanged, \n                GroupBox.collapsed, \n                GroupBox.setCollapsed, \n                True)\n'"
src/third_party/pyqtgraph/widgets/HistogramLUTWidget.py,0,"b'""""""\nWidget displaying an image histogram along with gradient editor. Can be used to adjust the appearance of images.\nThis is a wrapper around HistogramLUTItem\n""""""\n\nfrom ..Qt import QtGui, QtCore\nfrom .GraphicsView import GraphicsView\nfrom ..graphicsItems.HistogramLUTItem import HistogramLUTItem\n\n__all__ = [\'HistogramLUTWidget\']\n\n\nclass HistogramLUTWidget(GraphicsView):\n    \n    def __init__(self, parent=None,  *args, **kargs):\n        background = kargs.get(\'background\', \'default\')\n        GraphicsView.__init__(self, parent, useOpenGL=False, background=background)\n        self.item = HistogramLUTItem(*args, **kargs)\n        self.setCentralItem(self.item)\n        self.setSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Expanding)\n        self.setMinimumWidth(95)\n        \n\n    def sizeHint(self):\n        return QtCore.QSize(115, 200)\n    \n    \n\n    def __getattr__(self, attr):\n        return getattr(self.item, attr)\n\n\n\n'"
src/third_party/pyqtgraph/widgets/JoystickButton.py,0,"b'from ..Qt import QtGui, QtCore\n\n\n__all__ = [\'JoystickButton\']\n\nclass JoystickButton(QtGui.QPushButton):\n    sigStateChanged = QtCore.Signal(object, object)  ## self, state\n    \n    def __init__(self, parent=None):\n        QtGui.QPushButton.__init__(self, parent)\n        self.radius = 200\n        self.setCheckable(True)\n        self.state = None\n        self.setState(0,0)\n        self.setFixedWidth(50)\n        self.setFixedHeight(50)\n        \n        \n    def mousePressEvent(self, ev):\n        self.setChecked(True)\n        self.pressPos = ev.pos()\n        ev.accept()\n        \n    def mouseMoveEvent(self, ev):\n        dif = ev.pos()-self.pressPos\n        self.setState(dif.x(), -dif.y())\n        \n    def mouseReleaseEvent(self, ev):\n        self.setChecked(False)\n        self.setState(0,0)\n        \n    def wheelEvent(self, ev):\n        ev.accept()\n        \n        \n    def doubleClickEvent(self, ev):\n        ev.accept()\n        \n    def getState(self):\n        return self.state\n        \n    def setState(self, *xy):\n        xy = list(xy)\n        d = (xy[0]**2 + xy[1]**2)**0.5\n        nxy = [0,0]\n        for i in [0,1]:\n            if xy[i] == 0:\n                nxy[i] = 0\n            else:\n                nxy[i] = xy[i]/d\n        \n        if d > self.radius:\n            d = self.radius\n        d = (d/self.radius)**2\n        xy = [nxy[0]*d, nxy[1]*d]\n        \n        w2 = self.width()/2.\n        h2 = self.height()/2\n        self.spotPos = QtCore.QPoint(w2*(1+xy[0]), h2*(1-xy[1]))\n        self.update()\n        if self.state == xy:\n            return\n        self.state = xy\n        self.sigStateChanged.emit(self, self.state)\n        \n    def paintEvent(self, ev):\n        QtGui.QPushButton.paintEvent(self, ev)\n        p = QtGui.QPainter(self)\n        p.setBrush(QtGui.QBrush(QtGui.QColor(0,0,0)))\n        p.drawEllipse(self.spotPos.x()-3,self.spotPos.y()-3,6,6)\n        \n    def resizeEvent(self, ev):\n        self.setState(*self.state)\n        QtGui.QPushButton.resizeEvent(self, ev)\n        \n        \n        \nif __name__ == \'__main__\':\n    app = QtGui.QApplication([])\n    w = QtGui.QMainWindow()\n    b = JoystickButton()\n    w.setCentralWidget(b)\n    w.show()\n    w.resize(100, 100)\n    \n    def fn(b, s):\n        print(""state changed:"", s)\n        \n    b.sigStateChanged.connect(fn)\n        \n    ## Start Qt event loop unless running in interactive mode.\n    import sys\n    if sys.flags.interactive != 1:\n        app.exec_()\n        '"
src/third_party/pyqtgraph/widgets/LayoutWidget.py,0,"b'from ..Qt import QtGui, QtCore\n\n__all__ = [\'LayoutWidget\']\nclass LayoutWidget(QtGui.QWidget):\n    """"""\n    Convenience class used for laying out QWidgets in a grid.\n    (It\'s just a little less effort to use than QGridLayout)\n    """"""\n\n    def __init__(self, parent=None):\n        QtGui.QWidget.__init__(self, parent)\n        self.layout = QtGui.QGridLayout()\n        self.setLayout(self.layout)\n        self.items = {}\n        self.rows = {}\n        self.currentRow = 0\n        self.currentCol = 0\n    \n    def nextRow(self):\n        """"""Advance to next row for automatic widget placement""""""\n        self.currentRow += 1\n        self.currentCol = 0\n        \n    def nextColumn(self, colspan=1):\n        """"""Advance to next column, while returning the current column number \n        (generally only for internal use--called by addWidget)""""""\n        self.currentCol += colspan\n        return self.currentCol-colspan\n        \n    def nextCol(self, *args, **kargs):\n        """"""Alias of nextColumn""""""\n        return self.nextColumn(*args, **kargs)\n        \n        \n    def addLabel(self, text=\' \', row=None, col=None, rowspan=1, colspan=1, **kargs):\n        """"""\n        Create a QLabel with *text* and place it in the next available cell (or in the cell specified)\n        All extra keyword arguments are passed to QLabel().\n        Returns the created widget.\n        """"""\n        text = QtGui.QLabel(text, **kargs)\n        self.addItem(text, row, col, rowspan, colspan)\n        return text\n        \n    def addLayout(self, row=None, col=None, rowspan=1, colspan=1, **kargs):\n        """"""\n        Create an empty LayoutWidget and place it in the next available cell (or in the cell specified)\n        All extra keyword arguments are passed to :func:`LayoutWidget.__init__ <pyqtgraph.LayoutWidget.__init__>`\n        Returns the created widget.\n        """"""\n        layout = LayoutWidget(**kargs)\n        self.addItem(layout, row, col, rowspan, colspan)\n        return layout\n        \n    def addWidget(self, item, row=None, col=None, rowspan=1, colspan=1):\n        """"""\n        Add a widget to the layout and place it in the next available cell (or in the cell specified).\n        """"""\n        if row == \'next\':\n            self.nextRow()\n            row = self.currentRow\n        elif row is None:\n            row = self.currentRow\n            \n        \n        if col is None:\n            col = self.nextCol(colspan)\n            \n        if row not in self.rows:\n            self.rows[row] = {}\n        self.rows[row][col] = item\n        self.items[item] = (row, col)\n        \n        self.layout.addWidget(item, row, col, rowspan, colspan)\n\n    def getWidget(self, row, col):\n        """"""Return the widget in (*row*, *col*)""""""\n        return self.row[row][col]\n\n    #def itemIndex(self, item):\n        #for i in range(self.layout.count()):\n            #if self.layout.itemAt(i).graphicsItem() is item:\n                #return i\n        #raise Exception(""Could not determine index of item "" + str(item))\n    \n    #def removeItem(self, item):\n        #""""""Remove *item* from the layout.""""""\n        #ind = self.itemIndex(item)\n        #self.layout.removeAt(ind)\n        #self.scene().removeItem(item)\n        #r,c = self.items[item]\n        #del self.items[item]\n        #del self.rows[r][c]\n        #self.update()\n    \n    #def clear(self):\n        #items = []\n        #for i in list(self.items.keys()):\n            #self.removeItem(i)\n\n\n'"
src/third_party/pyqtgraph/widgets/MatplotlibWidget.py,0,"b'from ..Qt import QtGui, QtCore, QT_LIB\nimport matplotlib\n\nif QT_LIB != \'PyQt5\':\n    if QT_LIB == \'PySide\':\n        matplotlib.rcParams[\'backend.qt4\']=\'PySide\'\n\n    from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas\n    try:\n        from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as NavigationToolbar\n    except ImportError:\n        from matplotlib.backends.backend_qt4agg import NavigationToolbar2QT as NavigationToolbar\nelse:\n    from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\n    from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar\n\nfrom matplotlib.figure import Figure\n\nclass MatplotlibWidget(QtGui.QWidget):\n    """"""\n    Implements a Matplotlib figure inside a QWidget.\n    Use getFigure() and redraw() to interact with matplotlib.\n    \n    Example::\n    \n        mw = MatplotlibWidget()\n        subplot = mw.getFigure().add_subplot(111)\n        subplot.plot(x,y)\n        mw.draw()\n    """"""\n    \n    def __init__(self, size=(5.0, 4.0), dpi=100):\n        QtGui.QWidget.__init__(self)\n        self.fig = Figure(size, dpi=dpi)\n        self.canvas = FigureCanvas(self.fig)\n        self.canvas.setParent(self)\n        self.toolbar = NavigationToolbar(self.canvas, self)\n        \n        self.vbox = QtGui.QVBoxLayout()\n        self.vbox.addWidget(self.toolbar)\n        self.vbox.addWidget(self.canvas)\n        \n        self.setLayout(self.vbox)\n\n    def getFigure(self):\n        return self.fig\n        \n    def draw(self):\n        self.canvas.draw()\n'"
src/third_party/pyqtgraph/widgets/MultiPlotWidget.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nMultiPlotWidget.py -  Convenience class--GraphicsView widget displaying a MultiPlotItem\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n""""""\nfrom ..Qt import QtCore\nfrom .GraphicsView import GraphicsView\nfrom ..graphicsItems import MultiPlotItem as MultiPlotItem\n\n__all__ = [\'MultiPlotWidget\']\nclass MultiPlotWidget(GraphicsView):\n    """"""Widget implementing a graphicsView with a single MultiPlotItem inside.""""""\n    def __init__(self, parent=None):\n        self.minPlotHeight = 50\n        self.mPlotItem = MultiPlotItem.MultiPlotItem()\n        GraphicsView.__init__(self, parent)\n        self.enableMouse(False)\n        self.setCentralItem(self.mPlotItem)\n        ## Explicitly wrap methods from mPlotItem\n        #for m in [\'setData\']:\n            #setattr(self, m, getattr(self.mPlotItem, m))\n        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n                \n    def __getattr__(self, attr):  ## implicitly wrap methods from plotItem\n        if hasattr(self.mPlotItem, attr):\n            m = getattr(self.mPlotItem, attr)\n            if hasattr(m, \'__call__\'):\n                return m\n        raise AttributeError(attr)\n\n    def setMinimumPlotHeight(self, min):\n        """"""Set the minimum height for each sub-plot displayed. \n        \n        If the total height of all plots is greater than the height of the \n        widget, then a scroll bar will appear to provide access to the entire\n        set of plots.\n        \n        Added in version 0.9.9\n        """"""\n        self.minPlotHeight = min\n        self.resizeEvent(None)\n\n    def widgetGroupInterface(self):\n        return (None, MultiPlotWidget.saveState, MultiPlotWidget.restoreState)\n\n    def saveState(self):\n        return {}\n        #return self.plotItem.saveState()\n        \n    def restoreState(self, state):\n        pass\n        #return self.plotItem.restoreState(state)\n\n    def close(self):\n        self.mPlotItem.close()\n        self.mPlotItem = None\n        self.setParent(None)\n        GraphicsView.close(self)\n\n    def setRange(self, *args, **kwds):\n        GraphicsView.setRange(self, *args, **kwds)\n        if self.centralWidget is not None:\n            r = self.range\n            minHeight = len(self.mPlotItem.plots) * self.minPlotHeight\n            if r.height() < minHeight:\n                r.setHeight(minHeight)\n                r.setWidth(r.width() - self.verticalScrollBar().width())\n            self.centralWidget.setGeometry(r)\n\n    def resizeEvent(self, ev):\n        if self.closed:\n            return\n        if self.autoPixelRange:\n            self.range = QtCore.QRectF(0, 0, self.size().width(), self.size().height())\n        MultiPlotWidget.setRange(self, self.range, padding=0, disableAutoPixel=False)  ## we do this because some subclasses like to redefine setRange in an incompatible way.\n        self.updateMatrix()\n'"
src/third_party/pyqtgraph/widgets/PathButton.py,0,"b'from ..Qt import QtGui, QtCore\nfrom .. import functions as fn\n\n__all__ = [\'PathButton\']\n\n\nclass PathButton(QtGui.QPushButton):\n    """"""Simple PushButton extension that paints a QPainterPath centered on its face.\n    """"""\n    def __init__(self, parent=None, path=None, pen=\'default\', brush=None, size=(30,30), margin=7):\n        QtGui.QPushButton.__init__(self, parent)\n        self.margin = margin\n        self.path = None\n        if pen == \'default\':\n            pen = \'k\'\n        self.setPen(pen)\n        self.setBrush(brush)\n        if path is not None:\n            self.setPath(path)\n        if size is not None:\n            self.setFixedWidth(size[0])\n            self.setFixedHeight(size[1])\n            \n    def setBrush(self, brush):\n        self.brush = fn.mkBrush(brush)\n        \n    def setPen(self, *args, **kwargs):\n        self.pen = fn.mkPen(*args, **kwargs)\n        \n    def setPath(self, path):\n        self.path = path\n        self.update()\n        \n    def paintEvent(self, ev):\n        QtGui.QPushButton.paintEvent(self, ev)\n        margin = self.margin\n        geom = QtCore.QRectF(0, 0, self.width(), self.height()).adjusted(margin, margin, -margin, -margin)\n        rect = self.path.boundingRect()\n        scale = min(geom.width() / float(rect.width()), geom.height() / float(rect.height()))\n        \n        p = QtGui.QPainter(self)\n        p.setRenderHint(p.Antialiasing)\n        p.translate(geom.center())\n        p.scale(scale, scale)\n        p.translate(-rect.center())\n        p.setPen(self.pen)\n        p.setBrush(self.brush)\n        p.drawPath(self.path)\n        p.end()\n\n    \n'"
src/third_party/pyqtgraph/widgets/PlotWidget.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nPlotWidget.py -  Convenience class--GraphicsView widget displaying a single PlotItem\nCopyright 2010  Luke Campagnola\nDistributed under MIT/X11 license. See license.txt for more infomation.\n""""""\n\nfrom ..Qt import QtCore, QtGui\nfrom .GraphicsView import *\nfrom ..graphicsItems.PlotItem import *\n\n__all__ = [\'PlotWidget\']\nclass PlotWidget(GraphicsView):\n    \n    # signals wrapped from PlotItem / ViewBox\n    sigRangeChanged = QtCore.Signal(object, object)\n    sigTransformChanged = QtCore.Signal(object)\n    \n    """"""\n    :class:`GraphicsView <pyqtgraph.GraphicsView>` widget with a single \n    :class:`PlotItem <pyqtgraph.PlotItem>` inside.\n    \n    The following methods are wrapped directly from PlotItem: \n    :func:`addItem <pyqtgraph.PlotItem.addItem>`, \n    :func:`removeItem <pyqtgraph.PlotItem.removeItem>`, \n    :func:`clear <pyqtgraph.PlotItem.clear>`, \n    :func:`setXRange <pyqtgraph.ViewBox.setXRange>`,\n    :func:`setYRange <pyqtgraph.ViewBox.setYRange>`,\n    :func:`setRange <pyqtgraph.ViewBox.setRange>`,\n    :func:`autoRange <pyqtgraph.ViewBox.autoRange>`,\n    :func:`setXLink <pyqtgraph.ViewBox.setXLink>`,\n    :func:`setYLink <pyqtgraph.ViewBox.setYLink>`,\n    :func:`viewRect <pyqtgraph.ViewBox.viewRect>`,\n    :func:`setMouseEnabled <pyqtgraph.ViewBox.setMouseEnabled>`,\n    :func:`enableAutoRange <pyqtgraph.ViewBox.enableAutoRange>`,\n    :func:`disableAutoRange <pyqtgraph.ViewBox.disableAutoRange>`,\n    :func:`setAspectLocked <pyqtgraph.ViewBox.setAspectLocked>`,\n    :func:`setLimits <pyqtgraph.ViewBox.setLimits>`,\n    :func:`register <pyqtgraph.ViewBox.register>`,\n    :func:`unregister <pyqtgraph.ViewBox.unregister>`\n    \n    \n    For all \n    other methods, use :func:`getPlotItem <pyqtgraph.PlotWidget.getPlotItem>`.\n    """"""\n    def __init__(self, parent=None, background=\'default\', **kargs):\n        """"""When initializing PlotWidget, *parent* and *background* are passed to \n        :func:`GraphicsWidget.__init__() <pyqtgraph.GraphicsWidget.__init__>`\n        and all others are passed\n        to :func:`PlotItem.__init__() <pyqtgraph.PlotItem.__init__>`.""""""\n        GraphicsView.__init__(self, parent, background=background)\n        self.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)\n        self.enableMouse(False)\n        self.plotItem = PlotItem(**kargs)\n        self.setCentralItem(self.plotItem)\n        ## Explicitly wrap methods from plotItem\n        ## NOTE: If you change this list, update the documentation above as well.\n        for m in [\'addItem\', \'removeItem\', \'autoRange\', \'clear\', \'setXRange\', \n                  \'setYRange\', \'setRange\', \'setAspectLocked\', \'setMouseEnabled\', \n                  \'setXLink\', \'setYLink\', \'enableAutoRange\', \'disableAutoRange\', \n                  \'setLimits\', \'register\', \'unregister\', \'viewRect\']:\n            setattr(self, m, getattr(self.plotItem, m))\n        #QtCore.QObject.connect(self.plotItem, QtCore.SIGNAL(\'viewChanged\'), self.viewChanged)\n        self.plotItem.sigRangeChanged.connect(self.viewRangeChanged)\n    \n    def close(self):\n        self.plotItem.close()\n        self.plotItem = None\n        #self.scene().clear()\n        #self.mPlotItem.close()\n        self.setParent(None)\n        super(PlotWidget, self).close()\n\n    def __getattr__(self, attr):  ## implicitly wrap methods from plotItem\n        if hasattr(self.plotItem, attr):\n            m = getattr(self.plotItem, attr)\n            if hasattr(m, \'__call__\'):\n                return m\n        raise AttributeError(attr)\n    \n    def viewRangeChanged(self, view, range):\n        #self.emit(QtCore.SIGNAL(\'viewChanged\'), *args)\n        self.sigRangeChanged.emit(self, range)\n\n    def widgetGroupInterface(self):\n        return (None, PlotWidget.saveState, PlotWidget.restoreState)\n\n    def saveState(self):\n        return self.plotItem.saveState()\n        \n    def restoreState(self, state):\n        return self.plotItem.restoreState(state)\n        \n    def getPlotItem(self):\n        """"""Return the PlotItem contained within.""""""\n        return self.plotItem\n        \n        \n        '"
src/third_party/pyqtgraph/widgets/ProgressDialog.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtGui, QtCore\n\n__all__ = [\'ProgressDialog\']\n\n\nclass ProgressDialog(QtGui.QProgressDialog):\n    """"""\n    Extends QProgressDialog:\n    \n    * Adds context management so the dialog may be used in `with` statements\n    * Allows nesting multiple progress dialogs\n\n    Example::\n\n        with ProgressDialog(""Processing.."", minVal, maxVal) as dlg:\n            # do stuff\n            dlg.setValue(i)   ## could also use dlg += 1\n            if dlg.wasCanceled():\n                raise Exception(""Processing canceled by user"")\n    """"""\n    \n    allDialogs = []\n    \n    def __init__(self, labelText, minimum=0, maximum=100, cancelText=\'Cancel\', parent=None, wait=250, busyCursor=False, disable=False, nested=False):\n        """"""\n        ============== ================================================================\n        **Arguments:**\n        labelText      (required)\n        cancelText     Text to display on cancel button, or None to disable it.\n        minimum\n        maximum\n        parent       \n        wait           Length of time (im ms) to wait before displaying dialog\n        busyCursor     If True, show busy cursor until dialog finishes\n        disable        If True, the progress dialog will not be displayed\n                       and calls to wasCanceled() will always return False.\n                       If ProgressDialog is entered from a non-gui thread, it will\n                       always be disabled.\n        nested         (bool) If True, then this progress bar will be displayed inside\n                       any pre-existing progress dialogs that also allow nesting.\n        ============== ================================================================\n        """"""    \n        # attributes used for nesting dialogs\n        self.nestedLayout = None\n        self._nestableWidgets = None\n        self._nestingReady = False\n        self._topDialog = None\n        self._subBars = []\n        self.nested = nested\n        \n        isGuiThread = QtCore.QThread.currentThread() == QtCore.QCoreApplication.instance().thread()\n        self.disabled = disable or (not isGuiThread)\n        if self.disabled:\n            return\n\n        noCancel = False\n        if cancelText is None:\n            cancelText = \'\'\n            noCancel = True\n            \n        self.busyCursor = busyCursor\n\n        QtGui.QProgressDialog.__init__(self, labelText, cancelText, minimum, maximum, parent)\n        \n        # If this will be a nested dialog, then we ignore the wait time\n        if nested is True and len(ProgressDialog.allDialogs) > 0:\n            self.setMinimumDuration(2**30)\n        else:\n            self.setMinimumDuration(wait)\n            \n        self.setWindowModality(QtCore.Qt.WindowModal)\n        self.setValue(self.minimum())\n        if noCancel:\n            self.setCancelButton(None)\n        \n    def __enter__(self):\n        if self.disabled:\n            return self\n        if self.busyCursor:\n            QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))\n        \n        if self.nested and len(ProgressDialog.allDialogs) > 0:\n            topDialog = ProgressDialog.allDialogs[0]\n            topDialog._addSubDialog(self)\n            self._topDialog = topDialog\n            topDialog.canceled.connect(self.cancel)\n        \n        ProgressDialog.allDialogs.append(self)\n        \n        return self\n\n    def __exit__(self, exType, exValue, exTrace):\n        if self.disabled:\n            return\n        if self.busyCursor:\n            QtGui.QApplication.restoreOverrideCursor()\n            \n        if self._topDialog is not None:\n            self._topDialog._removeSubDialog(self)\n        \n        ProgressDialog.allDialogs.pop(-1)\n\n        self.setValue(self.maximum())\n        \n    def __iadd__(self, val):\n        """"""Use inplace-addition operator for easy incrementing.""""""\n        if self.disabled:\n            return self\n        self.setValue(self.value()+val)\n        return self\n\n    def _addSubDialog(self, dlg):\n        # insert widgets from another dialog into this one.\n        \n        # set a new layout and arrange children into it (if needed).\n        self._prepareNesting()\n        \n        bar, btn = dlg._extractWidgets()\n        \n        # where should we insert this widget? Find the first slot with a \n        # ""removed"" widget (that was left as a placeholder)\n        inserted = False\n        for i,bar2 in enumerate(self._subBars):\n            if bar2.hidden:\n                self._subBars.pop(i)\n                bar2.hide()\n                bar2.setParent(None)\n                self._subBars.insert(i, bar)\n                inserted = True\n                break\n        if not inserted:\n            self._subBars.append(bar)\n            \n        # reset the layout\n        while self.nestedLayout.count() > 0:\n            self.nestedLayout.takeAt(0)\n        for b in self._subBars:\n            self.nestedLayout.addWidget(b)\n            \n    def _removeSubDialog(self, dlg):\n        # don\'t remove the widget just yet; instead we hide it and leave it in \n        # as a placeholder.\n        bar, btn = dlg._extractWidgets()\n        bar.hide()\n\n    def _prepareNesting(self):\n        # extract all child widgets and place into a new layout that we can add to\n        if self._nestingReady is False:\n            # top layout contains progress bars + cancel button at the bottom\n            self._topLayout = QtGui.QGridLayout()\n            self.setLayout(self._topLayout)\n            self._topLayout.setContentsMargins(0, 0, 0, 0)\n            \n            # A vbox to contain all progress bars\n            self.nestedVBox = QtGui.QWidget()\n            self._topLayout.addWidget(self.nestedVBox, 0, 0, 1, 2)\n            self.nestedLayout = QtGui.QVBoxLayout()\n            self.nestedVBox.setLayout(self.nestedLayout)\n            \n            # re-insert all widgets\n            bar, btn = self._extractWidgets()\n            self.nestedLayout.addWidget(bar)\n            self._subBars.append(bar)\n            self._topLayout.addWidget(btn, 1, 1, 1, 1)\n            self._topLayout.setColumnStretch(0, 100)\n            self._topLayout.setColumnStretch(1, 1)\n            self._topLayout.setRowStretch(0, 100)\n            self._topLayout.setRowStretch(1, 1)\n            \n            self._nestingReady = True\n\n    def _extractWidgets(self):\n        # return:\n        #   1. a single widget containing the label and progress bar\n        #   2. the cancel button\n        \n        if self._nestableWidgets is None:\n            widgets = [ch for ch in self.children() if isinstance(ch, QtGui.QWidget)]\n            label = [ch for ch in self.children() if isinstance(ch, QtGui.QLabel)][0]\n            bar = [ch for ch in self.children() if isinstance(ch, QtGui.QProgressBar)][0]\n            btn = [ch for ch in self.children() if isinstance(ch, QtGui.QPushButton)][0]\n            \n            sw = ProgressWidget(label, bar)\n            \n            self._nestableWidgets = (sw, btn)\n            \n        return self._nestableWidgets\n    \n    def resizeEvent(self, ev):\n        if self._nestingReady:\n            # don\'t let progress dialog manage widgets anymore.\n            return\n        return QtGui.QProgressDialog.resizeEvent(self, ev)\n\n    ## wrap all other functions to make sure they aren\'t being called from non-gui threads\n    \n    def setValue(self, val):\n        if self.disabled:\n            return\n        QtGui.QProgressDialog.setValue(self, val)\n        \n        # Qt docs say this should happen automatically, but that doesn\'t seem\n        # to be the case.\n        if self.windowModality() == QtCore.Qt.WindowModal:\n            QtGui.QApplication.processEvents()\n        \n    def setLabelText(self, val):\n        if self.disabled:\n            return\n        QtGui.QProgressDialog.setLabelText(self, val)\n    \n    def setMaximum(self, val):\n        if self.disabled:\n            return\n        QtGui.QProgressDialog.setMaximum(self, val)\n\n    def setMinimum(self, val):\n        if self.disabled:\n            return\n        QtGui.QProgressDialog.setMinimum(self, val)\n        \n    def wasCanceled(self):\n        if self.disabled:\n            return False\n        return QtGui.QProgressDialog.wasCanceled(self)\n\n    def maximum(self):\n        if self.disabled:\n            return 0\n        return QtGui.QProgressDialog.maximum(self)\n\n    def minimum(self):\n        if self.disabled:\n            return 0\n        return QtGui.QProgressDialog.minimum(self)\n\n\nclass ProgressWidget(QtGui.QWidget):\n    """"""Container for a label + progress bar that also allows its child widgets\n    to be hidden without changing size.\n    """"""\n    def __init__(self, label, bar):\n        QtGui.QWidget.__init__(self)\n        self.hidden = False\n        self.layout = QtGui.QVBoxLayout()\n        self.setLayout(self.layout)\n        \n        self.label = label\n        self.bar = bar\n        self.layout.addWidget(label)\n        self.layout.addWidget(bar)\n        \n    def eventFilter(self, obj, ev):\n        return ev.type() == QtCore.QEvent.Paint\n    \n    def hide(self):\n        # hide label and bar, but continue occupying the same space in the layout\n        for widget in (self.label, self.bar):\n            widget.installEventFilter(self)\n            widget.update()\n        self.hidden = True\n'"
src/third_party/pyqtgraph/widgets/RawImageWidget.py,0,"b'from ..Qt import QtCore, QtGui\ntry:\n    from ..Qt import QtOpenGL\n    from OpenGL.GL import *\n    HAVE_OPENGL = True\nexcept Exception:\n    # Would prefer `except ImportError` here, but some versions of pyopengl generate\n    # AttributeError upon import\n    HAVE_OPENGL = False\n\nfrom .. import functions as fn\nimport numpy as np\n\nclass RawImageWidget(QtGui.QWidget):\n    """"""\n    Widget optimized for very fast video display. \n    Generally using an ImageItem inside GraphicsView is fast enough.\n    On some systems this may provide faster video. See the VideoSpeedTest example for benchmarking.\n    """"""\n    def __init__(self, parent=None, scaled=False):\n        """"""\n        Setting scaled=True will cause the entire image to be displayed within the boundaries of the widget. This also greatly reduces the speed at which it will draw frames.\n        """"""\n        QtGui.QWidget.__init__(self, parent=None)\n        self.setSizePolicy(QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding,QtGui.QSizePolicy.Expanding))\n        self.scaled = scaled\n        self.opts = None\n        self.image = None\n    \n    def setImage(self, img, *args, **kargs):\n        """"""\n        img must be ndarray of shape (x,y), (x,y,3), or (x,y,4).\n        Extra arguments are sent to functions.makeARGB\n        """"""\n        self.opts = (img, args, kargs)\n        self.image = None\n        self.update()\n\n    def paintEvent(self, ev):\n        if self.opts is None:\n            return\n        if self.image is None:\n            argb, alpha = fn.makeARGB(self.opts[0], *self.opts[1], **self.opts[2])\n            self.image = fn.makeQImage(argb, alpha)\n            self.opts = ()\n        #if self.pixmap is None:\n            #self.pixmap = QtGui.QPixmap.fromImage(self.image)\n        p = QtGui.QPainter(self)\n        if self.scaled:\n            rect = self.rect()\n            ar = rect.width() / float(rect.height())\n            imar = self.image.width() / float(self.image.height())\n            if ar > imar:\n                rect.setWidth(int(rect.width() * imar/ar))\n            else:\n                rect.setHeight(int(rect.height() * ar/imar))\n                \n            p.drawImage(rect, self.image)\n        else:\n            p.drawImage(QtCore.QPointF(), self.image)\n        #p.drawPixmap(self.rect(), self.pixmap)\n        p.end()\n\n\nif HAVE_OPENGL:\n    class RawImageGLWidget(QtOpenGL.QGLWidget):\n        """"""\n        Similar to RawImageWidget, but uses a GL widget to do all drawing.\n        Perfomance varies between platforms; see examples/VideoSpeedTest for benchmarking.\n        """"""\n        def __init__(self, parent=None, scaled=False):\n            QtOpenGL.QGLWidget.__init__(self, parent=None)\n            self.scaled = scaled\n            self.image = None\n            self.uploaded = False\n            self.smooth = False\n            self.opts = None\n\n        def setImage(self, img, *args, **kargs):\n            """"""\n            img must be ndarray of shape (x,y), (x,y,3), or (x,y,4).\n            Extra arguments are sent to functions.makeARGB\n            """"""\n            self.opts = (img, args, kargs)\n            self.image = None\n            self.uploaded = False\n            self.update()\n\n        def initializeGL(self):\n            self.texture = glGenTextures(1)\n            \n        def uploadTexture(self):\n            glEnable(GL_TEXTURE_2D)\n            glBindTexture(GL_TEXTURE_2D, self.texture)\n            if self.smooth:\n                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n            else:\n                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)\n                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER)\n            #glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER)\n            shape = self.image.shape\n            \n            ### Test texture dimensions first\n            #glTexImage2D(GL_PROXY_TEXTURE_2D, 0, GL_RGBA, shape[0], shape[1], 0, GL_RGBA, GL_UNSIGNED_BYTE, None)\n            #if glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, 0, GL_TEXTURE_WIDTH) == 0:\n                #raise Exception(""OpenGL failed to create 2D texture (%dx%d); too large for this hardware."" % shape[:2])\n            \n            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, shape[0], shape[1], 0, GL_RGBA, GL_UNSIGNED_BYTE, self.image.transpose((1,0,2)))\n            glDisable(GL_TEXTURE_2D)\n            \n        def paintGL(self):\n            if self.image is None:\n                if self.opts is None:\n                    return\n                img, args, kwds = self.opts\n                kwds[\'useRGBA\'] = True\n                self.image, alpha = fn.makeARGB(img, *args, **kwds)\n            \n            if not self.uploaded:\n                self.uploadTexture()\n            \n            glViewport(0, 0, self.width() * self.devicePixelRatio(), self.height() * self.devicePixelRatio())\n            glEnable(GL_TEXTURE_2D)\n            glBindTexture(GL_TEXTURE_2D, self.texture)\n            glColor4f(1,1,1,1)\n\n            glBegin(GL_QUADS)\n            glTexCoord2f(0,0)\n            glVertex3f(-1,-1,0)\n            glTexCoord2f(1,0)\n            glVertex3f(1, -1, 0)\n            glTexCoord2f(1,1)\n            glVertex3f(1, 1, 0)\n            glTexCoord2f(0,1)\n            glVertex3f(-1, 1, 0)\n            glEnd()\n            glDisable(GL_TEXTURE_3D)\n            \n\n\n'"
src/third_party/pyqtgraph/widgets/RemoteGraphicsView.py,0,"b'from ..Qt import QtGui, QtCore, QT_LIB\nif QT_LIB in [\'PyQt4\', \'PyQt5\']:\n    import sip\nfrom .. import multiprocess as mp\nfrom .GraphicsView import GraphicsView\nfrom .. import CONFIG_OPTIONS\nimport numpy as np\nimport mmap, tempfile, ctypes, atexit, sys, random\n\n__all__ = [\'RemoteGraphicsView\']\n\nclass RemoteGraphicsView(QtGui.QWidget):\n    """"""\n    Replacement for GraphicsView that does all scene management and rendering on a remote process,\n    while displaying on the local widget.\n    \n    GraphicsItems must be created by proxy to the remote process.\n    \n    """"""\n    def __init__(self, parent=None, *args, **kwds):\n        """"""\n        The keyword arguments \'useOpenGL\' and \'backgound\', if specified, are passed to the remote\n        GraphicsView.__init__(). All other keyword arguments are passed to multiprocess.QtProcess.__init__().\n        """"""\n        self._img = None\n        self._imgReq = None\n        self._sizeHint = (640,480)  ## no clue why this is needed, but it seems to be the default sizeHint for GraphicsView.\n                                    ## without it, the widget will not compete for space against another GraphicsView.\n        QtGui.QWidget.__init__(self)\n\n        # separate local keyword arguments from remote.\n        remoteKwds = {}\n        for kwd in [\'useOpenGL\', \'background\']:\n            if kwd in kwds:\n                remoteKwds[kwd] = kwds.pop(kwd)\n\n        self._proc = mp.QtProcess(**kwds)\n        self.pg = self._proc._import(\'pyqtgraph\')\n        self.pg.setConfigOptions(**CONFIG_OPTIONS)\n        rpgRemote = self._proc._import(\'pyqtgraph.widgets.RemoteGraphicsView\')\n        self._view = rpgRemote.Renderer(*args, **remoteKwds)\n        self._view._setProxyOptions(deferGetattr=True)\n        \n        self.setFocusPolicy(QtCore.Qt.StrongFocus)\n        self.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)\n        self.setMouseTracking(True)\n        self.shm = None\n        shmFileName = self._view.shmFileName()\n        if sys.platform.startswith(\'win\'):\n            self.shmtag = shmFileName\n        else:\n            self.shmFile = open(shmFileName, \'r\')\n        \n        self._view.sceneRendered.connect(mp.proxy(self.remoteSceneChanged)) #, callSync=\'off\'))\n                                                                            ## Note: we need synchronous signals\n                                                                            ## even though there is no return value--\n                                                                            ## this informs the renderer that it is \n                                                                            ## safe to begin rendering again. \n        \n        for method in [\'scene\', \'setCentralItem\']:\n            setattr(self, method, getattr(self._view, method))\n        \n    def resizeEvent(self, ev):\n        ret = QtGui.QWidget.resizeEvent(self, ev)\n        self._view.resize(self.size(), _callSync=\'off\')\n        return ret\n        \n    def sizeHint(self):\n        return QtCore.QSize(*self._sizeHint)\n        \n    def remoteSceneChanged(self, data):\n        w, h, size, newfile = data\n        #self._sizeHint = (whint, hhint)\n        if self.shm is None or self.shm.size != size:\n            if self.shm is not None:\n                self.shm.close()\n            if sys.platform.startswith(\'win\'):\n                self.shmtag = newfile   ## on windows, we create a new tag for every resize\n                self.shm = mmap.mmap(-1, size, self.shmtag) ## can\'t use tmpfile on windows because the file can only be opened once.\n            elif sys.platform == \'darwin\':\n                self.shmFile.close()\n                self.shmFile = open(self._view.shmFileName(), \'r\')\n                self.shm = mmap.mmap(self.shmFile.fileno(), size, mmap.MAP_SHARED, mmap.PROT_READ)\n            else:\n                self.shm = mmap.mmap(self.shmFile.fileno(), size, mmap.MAP_SHARED, mmap.PROT_READ)\n        self.shm.seek(0)\n        data = self.shm.read(w*h*4)\n        self._img = QtGui.QImage(data, w, h, QtGui.QImage.Format_ARGB32)\n        self._img.data = data  # data must be kept alive or PySide 1.2.1 (and probably earlier) will crash.\n        self.update()\n        \n    def paintEvent(self, ev):\n        if self._img is None:\n            return\n        p = QtGui.QPainter(self)\n        p.drawImage(self.rect(), self._img, QtCore.QRect(0, 0, self._img.width(), self._img.height()))\n        p.end()\n        \n    def mousePressEvent(self, ev):\n        self._view.mousePressEvent(int(ev.type()), ev.pos(), ev.globalPos(), int(ev.button()), int(ev.buttons()), int(ev.modifiers()), _callSync=\'off\')\n        ev.accept()\n        return QtGui.QWidget.mousePressEvent(self, ev)\n\n    def mouseReleaseEvent(self, ev):\n        self._view.mouseReleaseEvent(int(ev.type()), ev.pos(), ev.globalPos(), int(ev.button()), int(ev.buttons()), int(ev.modifiers()), _callSync=\'off\')\n        ev.accept()\n        return QtGui.QWidget.mouseReleaseEvent(self, ev)\n\n    def mouseMoveEvent(self, ev):\n        self._view.mouseMoveEvent(int(ev.type()), ev.pos(), ev.globalPos(), int(ev.button()), int(ev.buttons()), int(ev.modifiers()), _callSync=\'off\')\n        ev.accept()\n        return QtGui.QWidget.mouseMoveEvent(self, ev)\n        \n    def wheelEvent(self, ev):\n        self._view.wheelEvent(ev.pos(), ev.globalPos(), ev.delta(), int(ev.buttons()), int(ev.modifiers()), int(ev.orientation()), _callSync=\'off\')\n        ev.accept()\n        return QtGui.QWidget.wheelEvent(self, ev)\n    \n    def keyEvent(self, ev):\n        if self._view.keyEvent(int(ev.type()), int(ev.modifiers()), text, autorep, count):\n            ev.accept()\n        return QtGui.QWidget.keyEvent(self, ev)\n        \n    def enterEvent(self, ev):\n        self._view.enterEvent(int(ev.type()), _callSync=\'off\')\n        return QtGui.QWidget.enterEvent(self, ev)\n        \n    def leaveEvent(self, ev):\n        self._view.leaveEvent(int(ev.type()), _callSync=\'off\')\n        return QtGui.QWidget.leaveEvent(self, ev)\n        \n    def remoteProcess(self):\n        """"""Return the remote process handle. (see multiprocess.remoteproxy.RemoteEventHandler)""""""\n        return self._proc\n\n    def close(self):\n        """"""Close the remote process. After this call, the widget will no longer be updated.""""""\n        self._proc.close()\n\n\nclass Renderer(GraphicsView):\n    ## Created by the remote process to handle render requests\n    \n    sceneRendered = QtCore.Signal(object)\n    \n    def __init__(self, *args, **kwds):\n        ## Create shared memory for rendered image\n        #pg.dbg(namespace={\'r\': self})\n        if sys.platform.startswith(\'win\'):\n            self.shmtag = ""pyqtgraph_shmem_"" + \'\'.join([chr((random.getrandbits(20)%25) + 97) for i in range(20)])\n            self.shm = mmap.mmap(-1, mmap.PAGESIZE, self.shmtag) # use anonymous mmap on windows\n        else:\n            self.shmFile = tempfile.NamedTemporaryFile(prefix=\'pyqtgraph_shmem_\')\n            self.shmFile.write(b\'\\x00\' * (mmap.PAGESIZE+1))\n            self.shmFile.flush()\n            fd = self.shmFile.fileno()\n            self.shm = mmap.mmap(fd, mmap.PAGESIZE, mmap.MAP_SHARED, mmap.PROT_WRITE)\n        atexit.register(self.close)\n        \n        GraphicsView.__init__(self, *args, **kwds)\n        self.scene().changed.connect(self.update)\n        self.img = None\n        self.renderTimer = QtCore.QTimer()\n        self.renderTimer.timeout.connect(self.renderView)\n        self.renderTimer.start(16)\n        \n    def close(self):\n        self.shm.close()\n        if not sys.platform.startswith(\'win\'):\n            self.shmFile.close()\n\n    def shmFileName(self):\n        if sys.platform.startswith(\'win\'):\n            return self.shmtag\n        else:\n            return self.shmFile.name\n        \n    def update(self):\n        self.img = None\n        return GraphicsView.update(self)\n        \n    def resize(self, size):\n        oldSize = self.size()\n        GraphicsView.resize(self, size)\n        self.resizeEvent(QtGui.QResizeEvent(size, oldSize))\n        self.update()\n        \n    def renderView(self):\n        if self.img is None:\n            ## make sure shm is large enough and get its address\n            if self.width() == 0 or self.height() == 0:\n                return\n            size = self.width() * self.height() * 4\n            if size > self.shm.size():\n                if sys.platform.startswith(\'win\'):\n                    ## windows says ""WindowsError: [Error 87] the parameter is incorrect"" if we try to resize the mmap\n                    self.shm.close()\n                    ## it also says (sometimes) \'access is denied\' if we try to reuse the tag.\n                    self.shmtag = ""pyqtgraph_shmem_"" + \'\'.join([chr((random.getrandbits(20)%25) + 97) for i in range(20)])\n                    self.shm = mmap.mmap(-1, size, self.shmtag)\n                elif sys.platform == \'darwin\':\n                    self.shm.close()\n                    self.shmFile.close()\n                    self.shmFile = tempfile.NamedTemporaryFile(prefix=\'pyqtgraph_shmem_\')\n                    self.shmFile.write(b\'\\x00\' * (size + 1))\n                    self.shmFile.flush()\n                    self.shm = mmap.mmap(self.shmFile.fileno(), size, mmap.MAP_SHARED, mmap.PROT_WRITE)\n                else:\n                    self.shm.resize(size)\n            \n            ## render the scene directly to shared memory\n            if QT_LIB in [\'PySide\', \'PySide2\']:\n                ch = ctypes.c_char.from_buffer(self.shm, 0)\n                #ch = ctypes.c_char_p(address)\n                self.img = QtGui.QImage(ch, self.width(), self.height(), QtGui.QImage.Format_ARGB32)\n            else:\n                address = ctypes.addressof(ctypes.c_char.from_buffer(self.shm, 0))\n\n                # different versions of pyqt have different requirements here..\n                try:\n                    self.img = QtGui.QImage(sip.voidptr(address), self.width(), self.height(), QtGui.QImage.Format_ARGB32)\n                except TypeError:\n                    try:\n                        self.img = QtGui.QImage(memoryview(buffer(self.shm)), self.width(), self.height(), QtGui.QImage.Format_ARGB32)\n                    except TypeError:\n                        # Works on PyQt 4.9.6\n                        self.img = QtGui.QImage(address, self.width(), self.height(), QtGui.QImage.Format_ARGB32)\n            self.img.fill(0xffffffff)\n            p = QtGui.QPainter(self.img)\n            self.render(p, self.viewRect(), self.rect())\n            p.end()\n            self.sceneRendered.emit((self.width(), self.height(), self.shm.size(), self.shmFileName()))\n\n    def mousePressEvent(self, typ, pos, gpos, btn, btns, mods):\n        typ = QtCore.QEvent.Type(typ)\n        btn = QtCore.Qt.MouseButton(btn)\n        btns = QtCore.Qt.MouseButtons(btns)\n        mods = QtCore.Qt.KeyboardModifiers(mods)\n        return GraphicsView.mousePressEvent(self, QtGui.QMouseEvent(typ, pos, gpos, btn, btns, mods))\n\n    def mouseMoveEvent(self, typ, pos, gpos, btn, btns, mods):\n        typ = QtCore.QEvent.Type(typ)\n        btn = QtCore.Qt.MouseButton(btn)\n        btns = QtCore.Qt.MouseButtons(btns)\n        mods = QtCore.Qt.KeyboardModifiers(mods)\n        return GraphicsView.mouseMoveEvent(self, QtGui.QMouseEvent(typ, pos, gpos, btn, btns, mods))\n\n    def mouseReleaseEvent(self, typ, pos, gpos, btn, btns, mods):\n        typ = QtCore.QEvent.Type(typ)\n        btn = QtCore.Qt.MouseButton(btn)\n        btns = QtCore.Qt.MouseButtons(btns)\n        mods = QtCore.Qt.KeyboardModifiers(mods)\n        return GraphicsView.mouseReleaseEvent(self, QtGui.QMouseEvent(typ, pos, gpos, btn, btns, mods))\n\n    def wheelEvent(self, pos, gpos, d, btns, mods, ori):\n        btns = QtCore.Qt.MouseButtons(btns)\n        mods = QtCore.Qt.KeyboardModifiers(mods)\n        ori = (None, QtCore.Qt.Horizontal, QtCore.Qt.Vertical)[ori]\n        return GraphicsView.wheelEvent(self, QtGui.QWheelEvent(pos, gpos, d, btns, mods, ori))\n\n    def keyEvent(self, typ, mods, text, autorep, count):\n        typ = QtCore.QEvent.Type(typ)\n        mods = QtCore.Qt.KeyboardModifiers(mods)\n        GraphicsView.keyEvent(self, QtGui.QKeyEvent(typ, mods, text, autorep, count))\n        return ev.accepted()\n        \n    def enterEvent(self, typ):\n        ev = QtCore.QEvent(QtCore.QEvent.Type(typ))\n        return GraphicsView.enterEvent(self, ev)\n\n    def leaveEvent(self, typ):\n        ev = QtCore.QEvent(QtCore.QEvent.Type(typ))\n        return GraphicsView.leaveEvent(self, ev)\n\n'"
src/third_party/pyqtgraph/widgets/ScatterPlotWidget.py,8,"b'from ..Qt import QtGui, QtCore\nfrom .PlotWidget import PlotWidget\nfrom .DataFilterWidget import DataFilterParameter\nfrom .ColorMapWidget import ColorMapParameter\nfrom .. import parametertree as ptree\nfrom .. import functions as fn\nfrom .. import getConfigOption\nfrom ..graphicsItems.TextItem import TextItem\nimport numpy as np\nfrom ..pgcollections import OrderedDict\n\n__all__ = [\'ScatterPlotWidget\']\n\nclass ScatterPlotWidget(QtGui.QSplitter):\n    """"""\n    This is a high-level widget for exploring relationships in tabular data.\n        \n    Given a multi-column record array, the widget displays a scatter plot of a\n    specific subset of the data. Includes controls for selecting the columns to\n    plot, filtering data, and determining symbol color and shape.\n    \n    The widget consists of four components:\n    \n    1) A list of column names from which the user may select 1 or 2 columns\n       to plot. If one column is selected, the data for that column will be\n       plotted in a histogram-like manner by using :func:`pseudoScatter()\n       <pyqtgraph.pseudoScatter>`. If two columns are selected, then the\n       scatter plot will be generated with x determined by the first column\n       that was selected and y by the second.\n    2) A DataFilter that allows the user to select a subset of the data by \n       specifying multiple selection criteria.\n    3) A ColorMap that allows the user to determine how points are colored by\n       specifying multiple criteria.\n    4) A PlotWidget for displaying the data.\n    """"""\n    sigScatterPlotClicked = QtCore.Signal(object, object)\n    \n    def __init__(self, parent=None):\n        QtGui.QSplitter.__init__(self, QtCore.Qt.Horizontal)\n        self.ctrlPanel = QtGui.QSplitter(QtCore.Qt.Vertical)\n        self.addWidget(self.ctrlPanel)\n        self.fieldList = QtGui.QListWidget()\n        self.fieldList.setSelectionMode(self.fieldList.ExtendedSelection)\n        self.ptree = ptree.ParameterTree(showHeader=False)\n        self.filter = DataFilterParameter()\n        self.colorMap = ColorMapParameter()\n        self.params = ptree.Parameter.create(name=\'params\', type=\'group\', children=[self.filter, self.colorMap])\n        self.ptree.setParameters(self.params, showTop=False)\n        \n        self.plot = PlotWidget()\n        self.ctrlPanel.addWidget(self.fieldList)\n        self.ctrlPanel.addWidget(self.ptree)\n        self.addWidget(self.plot)\n        \n        fg = fn.mkColor(getConfigOption(\'foreground\'))\n        fg.setAlpha(150)\n        self.filterText = TextItem(border=getConfigOption(\'foreground\'), color=fg)\n        self.filterText.setPos(60,20)\n        self.filterText.setParentItem(self.plot.plotItem)\n        \n        self.data = None\n        self.indices = None\n        self.mouseOverField = None\n        self.scatterPlot = None\n        self.selectionScatter = None\n        self.selectedIndices = []\n        self.style = dict(pen=None, symbol=\'o\')\n        self._visibleXY = None  # currently plotted points\n        self._visibleData = None  # currently plotted records\n        self._visibleIndices = None\n        self._indexMap = None\n        \n        self.fieldList.itemSelectionChanged.connect(self.fieldSelectionChanged)\n        self.filter.sigFilterChanged.connect(self.filterChanged)\n        self.colorMap.sigColorMapChanged.connect(self.updatePlot)\n    \n    def setFields(self, fields, mouseOverField=None):\n        """"""\n        Set the list of field names/units to be processed.\n        \n        The format of *fields* is the same as used by \n        :func:`ColorMapWidget.setFields <pyqtgraph.widgets.ColorMapWidget.ColorMapParameter.setFields>`\n        """"""\n        self.fields = OrderedDict(fields)\n        self.mouseOverField = mouseOverField\n        self.fieldList.clear()\n        for f,opts in fields:\n            item = QtGui.QListWidgetItem(f)\n            item.opts = opts\n            item = self.fieldList.addItem(item)\n        self.filter.setFields(fields)\n        self.colorMap.setFields(fields)\n\n    def setSelectedFields(self, *fields):\n        self.fieldList.itemSelectionChanged.disconnect(self.fieldSelectionChanged)\n        try:\n            self.fieldList.clearSelection()\n            for f in fields:\n                i = self.fields.keys().index(f)\n                item = self.fieldList.item(i)\n                item.setSelected(True)\n        finally:\n            self.fieldList.itemSelectionChanged.connect(self.fieldSelectionChanged)\n        self.fieldSelectionChanged()\n\n    def setData(self, data):\n        """"""\n        Set the data to be processed and displayed. \n        Argument must be a numpy record array.\n        """"""\n        self.data = data\n        self.indices = np.arange(len(data))\n        self.filtered = None\n        self.filteredIndices = None\n        self.updatePlot()\n        \n    def setSelectedIndices(self, inds):\n        """"""Mark the specified indices as selected.\n\n        Must be a sequence of integers that index into the array given in setData().\n        """"""\n        self.selectedIndices = inds\n        self.updateSelected()\n\n    def setSelectedPoints(self, points):\n        """"""Mark the specified points as selected.\n\n        Must be a list of points as generated by the sigScatterPlotClicked signal.\n        """"""\n        self.setSelectedIndices([pt.originalIndex for pt in points])\n\n    def fieldSelectionChanged(self):\n        sel = self.fieldList.selectedItems()\n        if len(sel) > 2:\n            self.fieldList.blockSignals(True)\n            try:\n                for item in sel[1:-1]:\n                    item.setSelected(False)\n            finally:\n                self.fieldList.blockSignals(False)\n                \n        self.updatePlot()\n        \n    def filterChanged(self, f):\n        self.filtered = None\n        self.updatePlot()\n        desc = self.filter.describe()\n        if len(desc) == 0:\n            self.filterText.setVisible(False)\n        else:\n            self.filterText.setText(\'\\n\'.join(desc))\n            self.filterText.setVisible(True)\n        \n    def updatePlot(self):\n        self.plot.clear()\n        if self.data is None or len(self.data) == 0:\n            return\n        \n        if self.filtered is None:\n            mask = self.filter.generateMask(self.data)\n            self.filtered = self.data[mask]\n            self.filteredIndices = self.indices[mask]\n        data = self.filtered\n        if len(data) == 0:\n            return\n        \n        colors = np.array([fn.mkBrush(*x) for x in self.colorMap.map(data)])\n        \n        style = self.style.copy()\n        \n        ## Look up selected columns and units\n        sel = list([str(item.text()) for item in self.fieldList.selectedItems()])\n        units = list([item.opts.get(\'units\', \'\') for item in self.fieldList.selectedItems()])\n        if len(sel) == 0:\n            self.plot.setTitle(\'\')\n            return\n        \n\n        if len(sel) == 1:\n            self.plot.setLabels(left=(\'N\', \'\'), bottom=(sel[0], units[0]), title=\'\')\n            if len(data) == 0:\n                return\n            #x = data[sel[0]]\n            #y = None\n            xy = [data[sel[0]], None]\n        elif len(sel) == 2:\n            self.plot.setLabels(left=(sel[1],units[1]), bottom=(sel[0],units[0]))\n            if len(data) == 0:\n                return\n            \n            xy = [data[sel[0]], data[sel[1]]]\n            #xydata = []\n            #for ax in [0,1]:\n                #d = data[sel[ax]]\n                ### scatter catecorical values just a bit so they show up better in the scatter plot.\n                ##if sel[ax] in [\'MorphologyBSMean\', \'MorphologyTDMean\', \'FIType\']:\n                    ##d += np.random.normal(size=len(cells), scale=0.1)\n                    \n                #xydata.append(d)\n            #x,y = xydata\n\n        ## convert enum-type fields to float, set axis labels\n        enum = [False, False]\n        for i in [0,1]:\n            axis = self.plot.getAxis([\'bottom\', \'left\'][i])\n            if xy[i] is not None and (self.fields[sel[i]].get(\'mode\', None) == \'enum\' or xy[i].dtype.kind in (\'S\', \'O\')):\n                vals = self.fields[sel[i]].get(\'values\', list(set(xy[i])))\n                xy[i] = np.array([vals.index(x) if x in vals else len(vals) for x in xy[i]], dtype=float)\n                axis.setTicks([list(enumerate(vals))])\n                enum[i] = True\n            else:\n                axis.setTicks(None)  # reset to automatic ticking\n        \n        ## mask out any nan values\n        mask = np.ones(len(xy[0]), dtype=bool)\n        if xy[0].dtype.kind == \'f\':\n            mask &= np.isfinite(xy[0])\n        if xy[1] is not None and xy[1].dtype.kind == \'f\':\n            mask &= np.isfinite(xy[1])\n        \n        xy[0] = xy[0][mask]\n        style[\'symbolBrush\'] = colors[mask]\n        data = data[mask]\n        indices = self.filteredIndices[mask]\n\n        ## Scatter y-values for a histogram-like appearance\n        if xy[1] is None:\n            ## column scatter plot\n            xy[1] = fn.pseudoScatter(xy[0])\n        else:\n            ## beeswarm plots\n            xy[1] = xy[1][mask]\n            for ax in [0,1]:\n                if not enum[ax]:\n                    continue\n                imax = int(xy[ax].max()) if len(xy[ax]) > 0 else 0\n                for i in range(imax+1):\n                    keymask = xy[ax] == i\n                    scatter = fn.pseudoScatter(xy[1-ax][keymask], bidir=True)\n                    if len(scatter) == 0:\n                        continue\n                    smax = np.abs(scatter).max()\n                    if smax != 0:\n                        scatter *= 0.2 / smax\n                    xy[ax][keymask] += scatter\n\n\n        if self.scatterPlot is not None:\n            try:\n                self.scatterPlot.sigPointsClicked.disconnect(self.plotClicked)\n            except:\n                pass\n        \n        self._visibleXY = xy\n        self._visibleData = data\n        self._visibleIndices = indices\n        self._indexMap = None\n        self.scatterPlot = self.plot.plot(xy[0], xy[1], data=data, **style)\n        self.scatterPlot.sigPointsClicked.connect(self.plotClicked)\n        self.updateSelected()\n\n    def updateSelected(self):\n        if self._visibleXY is None:\n            return\n        # map from global index to visible index\n        indMap = self._getIndexMap()\n        inds = [indMap[i] for i in self.selectedIndices if i in indMap]\n        x,y = self._visibleXY[0][inds], self._visibleXY[1][inds]\n\n        if self.selectionScatter is not None:\n            self.plot.plotItem.removeItem(self.selectionScatter)\n        if len(x) == 0:\n            return\n        self.selectionScatter = self.plot.plot(x, y, pen=None, symbol=\'s\', symbolSize=12, symbolBrush=None, symbolPen=\'y\')\n\n    def _getIndexMap(self):\n        # mapping from original data index to visible point index\n        if self._indexMap is None:\n            self._indexMap = {j:i for i,j in enumerate(self._visibleIndices)}\n        return self._indexMap\n\n    def plotClicked(self, plot, points):\n        # Tag each point with its index into the original dataset\n        for pt in points:\n            pt.originalIndex = self._visibleIndices[pt.index()]\n        self.sigScatterPlotClicked.emit(self, points)\n'"
src/third_party/pyqtgraph/widgets/SpinBox.py,0,"b'# -*- coding: utf-8 -*-\nfrom math import log\nfrom decimal import Decimal as D  ## Use decimal to avoid accumulating floating-point errors\nimport decimal\nimport weakref\nimport re\n\nfrom ..Qt import QtGui, QtCore\nfrom ..python2_3 import asUnicode, basestring\nfrom ..SignalProxy import SignalProxy\nfrom .. import functions as fn\n\n\n__all__ = [\'SpinBox\']\n\n\nclass SpinBox(QtGui.QAbstractSpinBox):\n    """"""\n    **Bases:** QtGui.QAbstractSpinBox\n    \n    Extension of QSpinBox widget for selection of a numerical value.     \n    Adds many extra features:\n    \n    * SI prefix notation (eg, automatically display ""300 mV"" instead of ""0.003 V"")\n    * Float values with linear and decimal stepping (1-9, 10-90, 100-900, etc.)\n    * Option for unbounded values\n    * Delayed signals (allows multiple rapid changes with only one change signal)\n    * Customizable text formatting\n    \n    =============================  ==============================================\n    **Signals:**\n    valueChanged(value)            Same as QSpinBox; emitted every time the value \n                                   has changed.\n    sigValueChanged(self)          Emitted when value has changed, but also combines\n                                   multiple rapid changes into one signal (eg, \n                                   when rolling the mouse wheel).\n    sigValueChanging(self, value)  Emitted immediately for all value changes.\n    =============================  ==============================================\n    """"""\n    \n    ## There\'s a PyQt bug that leaks a reference to the \n    ## QLineEdit returned from QAbstractSpinBox.lineEdit()\n    ## This makes it possible to crash the entire program \n    ## by making accesses to the LineEdit after the spinBox has been deleted.\n    ## I have no idea how to get around this..\n    \n    \n    valueChanged = QtCore.Signal(object)     # (value)  for compatibility with QSpinBox\n    sigValueChanged = QtCore.Signal(object)  # (self)\n    sigValueChanging = QtCore.Signal(object, object)  # (self, value)  sent immediately; no delay.\n\n    def __init__(self, parent=None, value=0.0, **kwargs):\n        """"""\n        ============== ========================================================================\n        **Arguments:**\n        parent         Sets the parent widget for this SpinBox (optional). Default is None.\n        value          (float/int) initial value. Default is 0.0.\n        ============== ========================================================================\n        \n        All keyword arguments are passed to :func:`setOpts`.\n        """"""\n        QtGui.QAbstractSpinBox.__init__(self, parent)\n        self.lastValEmitted = None\n        self.lastText = \'\'\n        self.textValid = True  ## If false, we draw a red border\n        self.setMinimumWidth(0)\n        self._lastFontHeight = None\n        \n        self.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Preferred)\n        self.errorBox = ErrorBox(self.lineEdit())\n        \n        self.opts = {\n            \'bounds\': [None, None],\n            \'wrapping\': False,\n           \n            ## normal arithmetic step\n            \'step\': D(\'0.01\'),  ## if \'dec\' is false, the spinBox steps by \'step\' every time\n                                ## if \'dec\' is True, the step size is relative to the value\n                                ## \'step\' needs to be an integral divisor of ten, ie \'step\'*n=10 for some integer value of n (but only if dec is True)\n            \'log\': False,   # deprecated\n            \'dec\': False,   ## if true, does decimal stepping. ie from 1-10 it steps by \'step\', from 10 to 100 it steps by 10*\'step\', etc. \n                            ## if true, minStep must be set in order to cross zero.\n            \n            \'int\': False, ## Set True to force value to be integer\n            \n            \'suffix\': \'\',\n            \'siPrefix\': False,   ## Set to True to display numbers with SI prefix (ie, 100pA instead of 1e-10A)\n            \n            \'delay\': 0.3, ## delay sending wheel update signals for 300ms\n            \n            \'delayUntilEditFinished\': True,   ## do not send signals until text editing has finished\n            \n            \'decimals\': 6,\n            \n            \'format\': asUnicode(""{scaledValue:.{decimals}g}{suffixGap}{siPrefix}{suffix}""),\n            \'regex\': fn.FLOAT_REGEX,\n            \'evalFunc\': D,\n            \n            \'compactHeight\': True,  # manually remove extra margin outside of text\n        }\n        \n        self.decOpts = [\'step\', \'minStep\']\n        \n        self.val = D(asUnicode(value))  ## Value is precise decimal. Ordinary math not allowed.\n        self.updateText()\n        self.skipValidate = False\n        self.setCorrectionMode(self.CorrectToPreviousValue)\n        self.setKeyboardTracking(False)\n        self.proxy = SignalProxy(self.sigValueChanging, slot=self.delayedChange, delay=self.opts[\'delay\'])\n        self.setOpts(**kwargs)\n        self._updateHeight()\n        \n        self.editingFinished.connect(self.editingFinishedEvent)\n\n    def event(self, ev):\n        ret = QtGui.QAbstractSpinBox.event(self, ev)\n        if ev.type() == QtCore.QEvent.KeyPress and ev.key() == QtCore.Qt.Key_Return:\n            ret = True  ## For some reason, spinbox pretends to ignore return key press\n        return ret\n        \n    def setOpts(self, **opts):\n        """"""Set options affecting the behavior of the SpinBox.\n        \n        ============== ========================================================================\n        **Arguments:**\n        bounds         (min,max) Minimum and maximum values allowed in the SpinBox. \n                       Either may be None to leave the value unbounded. By default, values are\n                       unbounded.\n        suffix         (str) suffix (units) to display after the numerical value. By default,\n                       suffix is an empty str.\n        siPrefix       (bool) If True, then an SI prefix is automatically prepended\n                       to the units and the value is scaled accordingly. For example,\n                       if value=0.003 and suffix=\'V\', then the SpinBox will display\n                       ""300 mV"" (but a call to SpinBox.value will still return 0.003). Default\n                       is False.\n        step           (float) The size of a single step. This is used when clicking the up/\n                       down arrows, when rolling the mouse wheel, or when pressing \n                       keyboard arrows while the widget has keyboard focus. Note that\n                       the interpretation of this value is different when specifying\n                       the \'dec\' argument. Default is 0.01.\n        dec            (bool) If True, then the step value will be adjusted to match \n                       the current size of the variable (for example, a value of 15\n                       might step in increments of 1 whereas a value of 1500 would\n                       step in increments of 100). In this case, the \'step\' argument\n                       is interpreted *relative* to the current value. The most common\n                       \'step\' values when dec=True are 0.1, 0.2, 0.5, and 1.0. Default is\n                       False.\n        minStep        (float) When dec=True, this specifies the minimum allowable step size.\n        int            (bool) if True, the value is forced to integer type. Default is False\n        wrapping       (bool) If True and both bounds are not None, spin box has circular behavior.\n        decimals       (int) Number of decimal values to display. Default is 6. \n        format         (str) Formatting string used to generate the text shown. Formatting is\n                       done with ``str.format()`` and makes use of several arguments:\n                       \n                       * *value* - the unscaled value of the spin box\n                       * *suffix* - the suffix string\n                       * *scaledValue* - the scaled value to use when an SI prefix is present\n                       * *siPrefix* - the SI prefix string (if any), or an empty string if\n                         this feature has been disabled\n                       * *suffixGap* - a single space if a suffix is present, or an empty\n                         string otherwise.\n        regex          (str or RegexObject) Regular expression used to parse the spinbox text.\n                       May contain the following group names:\n                       \n                       * *number* - matches the numerical portion of the string (mandatory)\n                       * *siPrefix* - matches the SI prefix string\n                       * *suffix* - matches the suffix string\n                       \n                       Default is defined in ``pyqtgraph.functions.FLOAT_REGEX``.\n        evalFunc       (callable) Fucntion that converts a numerical string to a number,\n                       preferrably a Decimal instance. This function handles only the numerical\n                       of the text; it does not have access to the suffix or SI prefix.\n        compactHeight  (bool) if True, then set the maximum height of the spinbox based on the\n                       height of its font. This allows more compact packing on platforms with\n                       excessive widget decoration. Default is True.\n        ============== ========================================================================\n        """"""\n        #print opts\n        for k,v in opts.items():\n            if k == \'bounds\':\n                self.setMinimum(v[0], update=False)\n                self.setMaximum(v[1], update=False)\n            elif k == \'min\':\n                self.setMinimum(v, update=False)\n            elif k == \'max\':\n                self.setMaximum(v, update=False)\n            elif k in [\'step\', \'minStep\']:\n                self.opts[k] = D(asUnicode(v))\n            elif k == \'value\':\n                pass   ## don\'t set value until bounds have been set\n            elif k == \'format\':\n                self.opts[k] = asUnicode(v)\n            elif k == \'regex\' and isinstance(v, basestring):\n                self.opts[k] = re.compile(v)\n            elif k in self.opts:\n                self.opts[k] = v\n            else:\n                raise TypeError(""Invalid keyword argument \'%s\'."" % k)\n        if \'value\' in opts:\n            self.setValue(opts[\'value\'])\n            \n        ## If bounds have changed, update value to match\n        if \'bounds\' in opts and \'value\' not in opts:\n            self.setValue()   \n            \n        ## sanity checks:\n        if self.opts[\'int\']:\n            if \'step\' in opts:\n                step = opts[\'step\']\n                ## not necessary..\n                #if int(step) != step:\n                    #raise Exception(\'Integer SpinBox must have integer step size.\')\n            else:\n                self.opts[\'step\'] = int(self.opts[\'step\'])\n            \n            if \'minStep\' in opts:\n                step = opts[\'minStep\']\n                if int(step) != step:\n                    raise Exception(\'Integer SpinBox must have integer minStep size.\')\n            else:\n                ms = int(self.opts.get(\'minStep\', 1))\n                if ms < 1:\n                    ms = 1\n                self.opts[\'minStep\'] = ms\n        \n        if \'delay\' in opts:\n            self.proxy.setDelay(opts[\'delay\'])\n        \n        self.updateText()\n\n    def setMaximum(self, m, update=True):\n        """"""Set the maximum allowed value (or None for no limit)""""""\n        if m is not None:\n            m = D(asUnicode(m))\n        self.opts[\'bounds\'][1] = m\n        if update:\n            self.setValue()\n    \n    def setMinimum(self, m, update=True):\n        """"""Set the minimum allowed value (or None for no limit)""""""\n        if m is not None:\n            m = D(asUnicode(m))\n        self.opts[\'bounds\'][0] = m\n        if update:\n            self.setValue()\n\n    def wrapping(self):\n        """"""Return whether or not the spin box is circular.""""""\n        return self.opts[\'wrapping\']\n\n    def setWrapping(self, s):\n        """"""Set whether spin box is circular.\n        \n        Both bounds must be set for this to have an effect.""""""\n        self.opts[\'wrapping\'] = s\n        \n    def setPrefix(self, p):\n        """"""Set a string prefix.\n        """"""\n        self.setOpts(prefix=p)\n    \n    def setRange(self, r0, r1):\n        """"""Set the upper and lower limits for values in the spinbox.\n        """"""\n        self.setOpts(bounds = [r0,r1])\n        \n    def setProperty(self, prop, val):\n        ## for QSpinBox compatibility\n        if prop == \'value\':\n            #if type(val) is QtCore.QVariant:\n                #val = val.toDouble()[0]\n            self.setValue(val)\n        else:\n            print(""Warning: SpinBox.setProperty(\'%s\', ..) not supported."" % prop)\n\n    def setSuffix(self, suf):\n        """"""Set the string suffix appended to the spinbox text.\n        """"""\n        self.setOpts(suffix=suf)\n\n    def setSingleStep(self, step):\n        """"""Set the step size used when responding to the mouse wheel, arrow\n        buttons, or arrow keys.\n        """"""\n        self.setOpts(step=step)\n        \n    def setDecimals(self, decimals):\n        """"""Set the number of decimals to be displayed when formatting numeric\n        values.\n        """"""\n        self.setOpts(decimals=decimals)\n        \n    def selectNumber(self):\n        """"""\n        Select the numerical portion of the text to allow quick editing by the user.\n        """"""\n        le = self.lineEdit()\n        text = asUnicode(le.text())\n        m = self.opts[\'regex\'].match(text)\n        if m is None:\n            return\n        s,e = m.start(\'number\'), m.end(\'number\')\n        le.setSelection(s, e-s)\n\n    def focusInEvent(self, ev):\n        super(SpinBox, self).focusInEvent(ev)\n        self.selectNumber()\n\n    def value(self):\n        """"""\n        Return the value of this SpinBox.\n        \n        """"""\n        if self.opts[\'int\']:\n            return int(self.val)\n        else:\n            return float(self.val)\n\n    def setValue(self, value=None, update=True, delaySignal=False):\n        """"""Set the value of this SpinBox.\n        \n        If the value is out of bounds, it will be clipped to the nearest boundary\n        or wrapped if wrapping is enabled.\n        \n        If the spin is integer type, the value will be coerced to int.\n        Returns the actual value set.\n        \n        If value is None, then the current value is used (this is for resetting\n        the value after bounds, etc. have changed)\n        """"""\n        if value is None:\n            value = self.value()\n        \n        bounds = self.opts[\'bounds\']\n\n        if None not in bounds and self.opts[\'wrapping\'] is True:\n            # Casting of Decimals to floats required to avoid unexpected behavior of remainder operator\n            value = float(value)\n            l, u = float(bounds[0]), float(bounds[1])\n            value = (value - l) % (u - l) + l\n        else:\n            if bounds[0] is not None and value < bounds[0]:\n                value = bounds[0]\n            if bounds[1] is not None and value > bounds[1]:\n                value = bounds[1]\n\n        if self.opts[\'int\']:\n            value = int(value)\n\n        if not isinstance(value, D):\n            value = D(asUnicode(value))\n        \n        if value == self.val:\n            return\n        prev = self.val\n        \n        self.val = value\n        if update:\n            self.updateText(prev=prev)\n            \n        self.sigValueChanging.emit(self, float(self.val))  ## change will be emitted in 300ms if there are no subsequent changes.\n        if not delaySignal:\n            self.emitChanged()\n        \n        return value\n    \n    def emitChanged(self):\n        self.lastValEmitted = self.val\n        self.valueChanged.emit(float(self.val))\n        self.sigValueChanged.emit(self)\n    \n    def delayedChange(self):\n        try:\n            if self.val != self.lastValEmitted:\n                self.emitChanged()\n        except RuntimeError:\n            pass  ## This can happen if we try to handle a delayed signal after someone else has already deleted the underlying C++ object.\n    \n    def widgetGroupInterface(self):\n        return (self.valueChanged, SpinBox.value, SpinBox.setValue)\n    \n    def sizeHint(self):\n        return QtCore.QSize(120, 0)\n    \n    def stepEnabled(self):\n        return self.StepUpEnabled | self.StepDownEnabled        \n    \n    def stepBy(self, n):\n        n = D(int(n))   ## n must be integral number of steps.\n        s = [D(-1), D(1)][n >= 0]  ## determine sign of step\n        val = self.val\n        \n        for i in range(int(abs(n))):\n            \n            if self.opts[\'log\']:\n                raise Exception(""Log mode no longer supported."")\n            #    step = abs(val) * self.opts[\'step\']\n            #    if \'minStep\' in self.opts:\n            #        step = max(step, self.opts[\'minStep\'])\n            #    val += step * s\n            if self.opts[\'dec\']:\n                if val == 0:\n                    step = self.opts[\'minStep\']\n                    exp = None\n                else:\n                    vs = [D(-1), D(1)][val >= 0]\n                    #exp = D(int(abs(val*(D(\'1.01\')**(s*vs))).log10()))\n                    fudge = D(\'1.01\')**(s*vs) ## fudge factor. at some places, the step size depends on the step sign.\n                    exp = abs(val * fudge).log10().quantize(1, decimal.ROUND_FLOOR)\n                    step = self.opts[\'step\'] * D(10)**exp\n                if \'minStep\' in self.opts:\n                    step = max(step, self.opts[\'minStep\'])\n                val += s * step\n                #print ""Exp:"", exp, ""step"", step, ""val"", val\n            else:\n                val += s*self.opts[\'step\']\n                \n            if \'minStep\' in self.opts and abs(val) < self.opts[\'minStep\']:\n                val = D(0)\n        self.setValue(val, delaySignal=True)  ## note all steps (arrow buttons, wheel, up/down keys..) emit delayed signals only.\n\n    def valueInRange(self, value):\n        bounds = self.opts[\'bounds\']\n        if bounds[0] is not None and value < bounds[0]:\n            return False\n        if bounds[1] is not None and value > bounds[1]:\n            return False\n        if self.opts.get(\'int\', False):\n            if int(value) != value:\n                return False\n        return True\n\n    def updateText(self, prev=None):\n        # temporarily disable validation\n        self.skipValidate = True\n        \n        txt = self.formatText(prev=prev)\n        \n        # actually set the text\n        self.lineEdit().setText(txt)\n        self.lastText = txt\n\n        # re-enable the validation\n        self.skipValidate = False\n        \n    def formatText(self, prev=None):\n        # get the number of decimal places to print\n        decimals = self.opts[\'decimals\']\n        suffix = self.opts[\'suffix\']\n\n        # format the string \n        val = self.value()\n        if self.opts[\'siPrefix\'] is True and len(self.opts[\'suffix\']) > 0:\n            # SI prefix was requested, so scale the value accordingly\n\n            if self.val == 0 and prev is not None:\n                # special case: if it\'s zero use the previous prefix\n                (s, p) = fn.siScale(prev)\n            else:\n                (s, p) = fn.siScale(val)\n            parts = {\'value\': val, \'suffix\': suffix, \'decimals\': decimals, \'siPrefix\': p, \'scaledValue\': s*val}\n\n        else:\n            # no SI prefix /suffix requested; scale is 1\n            parts = {\'value\': val, \'suffix\': suffix, \'decimals\': decimals, \'siPrefix\': \'\', \'scaledValue\': val}\n\n        parts[\'suffixGap\'] = \'\' if (parts[\'suffix\'] == \'\' and parts[\'siPrefix\'] == \'\') else \' \'\n        \n        return self.opts[\'format\'].format(**parts)\n\n    def validate(self, strn, pos):\n        if self.skipValidate:\n            ret = QtGui.QValidator.Acceptable\n        else:\n            try:\n                val = self.interpret()\n                if val is False:\n                    ret = QtGui.QValidator.Intermediate\n                else:\n                    if self.valueInRange(val):\n                        if not self.opts[\'delayUntilEditFinished\']:\n                            self.setValue(val, update=False)\n                        ret = QtGui.QValidator.Acceptable\n                    else:\n                        ret = QtGui.QValidator.Intermediate\n                        \n            except:\n                import sys\n                sys.excepthook(*sys.exc_info())\n                ret = QtGui.QValidator.Intermediate\n            \n        ## draw / clear border\n        if ret == QtGui.QValidator.Intermediate:\n            self.textValid = False\n        elif ret == QtGui.QValidator.Acceptable:\n            self.textValid = True\n        ## note: if text is invalid, we don\'t change the textValid flag \n        ## since the text will be forced to its previous state anyway\n        self.update()\n        \n        self.errorBox.setVisible(not self.textValid)\n        \n        ## support 2 different pyqt APIs. Bleh.\n        if hasattr(QtCore, \'QString\'):\n            return (ret, pos)\n        else:\n            return (ret, strn, pos)\n        \n    def fixup(self, strn):\n        # fixup is called when the spinbox loses focus with an invalid or intermediate string\n        self.updateText()\n\n        # support both PyQt APIs (for Python 2 and 3 respectively)\n        # http://pyqt.sourceforge.net/Docs/PyQt4/python_v3.html#qvalidator\n        try:\n            strn.clear()\n            strn.append(self.lineEdit().text())\n        except AttributeError:\n            return self.lineEdit().text()\n\n    def interpret(self):\n        """"""Return value of text or False if text is invalid.""""""\n        strn = self.lineEdit().text()\n        \n        # tokenize into numerical value, si prefix, and suffix\n        try:\n            val, siprefix, suffix = fn.siParse(strn, self.opts[\'regex\'], suffix=self.opts[\'suffix\'])\n        except Exception:\n            return False\n            \n        # check suffix\n        if suffix != self.opts[\'suffix\'] or (suffix == \'\' and siprefix != \'\'):\n            return False\n           \n        # generate value\n        val = self.opts[\'evalFunc\'](val)\n        if self.opts[\'int\']:\n            val = int(fn.siApply(val, siprefix))\n        else:\n            try:\n                val = fn.siApply(val, siprefix)\n            except Exception:\n                import sys\n                sys.excepthook(*sys.exc_info())\n                return False\n\n        return val\n\n    def editingFinishedEvent(self):\n        """"""Edit has finished; set value.""""""\n        #print ""Edit finished.""\n        if asUnicode(self.lineEdit().text()) == self.lastText:\n            #print ""no text change.""\n            return\n        try:\n            val = self.interpret()\n        except Exception:\n            return\n        \n        if val is False:\n            #print ""value invalid:"", str(self.lineEdit().text())\n            return\n        if val == self.val:\n            #print ""no value change:"", val, self.val\n            return\n        self.setValue(val, delaySignal=False)  ## allow text update so that values are reformatted pretty-like\n\n    def _updateHeight(self):\n        # SpinBox has very large margins on some platforms; this is a hack to remove those\n        # margins and allow more compact packing of controls.\n        if not self.opts[\'compactHeight\']:\n            self.setMaximumHeight(1e6)\n            return\n        h = QtGui.QFontMetrics(self.font()).height()\n        if self._lastFontHeight != h:\n            self._lastFontHeight = h\n            self.setMaximumHeight(h)\n\n    def paintEvent(self, ev):\n        self._updateHeight()\n        QtGui.QAbstractSpinBox.paintEvent(self, ev)\n\n\nclass ErrorBox(QtGui.QWidget):\n    """"""Red outline to draw around lineedit when value is invalid.\n    (for some reason, setting border from stylesheet does not work)\n    """"""\n    def __init__(self, parent):\n        QtGui.QWidget.__init__(self, parent)\n        parent.installEventFilter(self)\n        self.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents)\n        self._resize()\n        self.setVisible(False)\n        \n    def eventFilter(self, obj, ev):\n        if ev.type() == QtCore.QEvent.Resize:\n            self._resize()\n        return False\n\n    def _resize(self):\n        self.setGeometry(0, 0, self.parent().width(), self.parent().height())\n        \n    def paintEvent(self, ev):\n        p = QtGui.QPainter(self)\n        p.setPen(fn.mkPen(color=\'r\', width=2))\n        p.drawRect(self.rect())\n        p.end()\n'"
src/third_party/pyqtgraph/widgets/TableWidget.py,8,"b'# -*- coding: utf-8 -*-\nimport numpy as np\nfrom ..Qt import QtGui, QtCore\nfrom ..python2_3 import asUnicode, basestring\nfrom .. import metaarray\n\n\n__all__ = [\'TableWidget\']\n\n\ndef _defersort(fn):\n    def defersort(self, *args, **kwds):\n        # may be called recursively; only the first call needs to block sorting\n        setSorting = False\n        if self._sorting is None:\n            self._sorting = self.isSortingEnabled()\n            setSorting = True\n            self.setSortingEnabled(False)\n        try:\n            return fn(self, *args, **kwds)\n        finally:\n            if setSorting:\n                self.setSortingEnabled(self._sorting)\n                self._sorting = None\n                \n    return defersort\n\n\nclass TableWidget(QtGui.QTableWidget):\n    """"""Extends QTableWidget with some useful functions for automatic data handling\n    and copy / export context menu. Can automatically format and display a variety\n    of data types (see :func:`setData() <pyqtgraph.TableWidget.setData>` for more\n    information.\n    """"""\n    \n    def __init__(self, *args, **kwds):\n        """"""\n        All positional arguments are passed to QTableWidget.__init__().\n        \n        ===================== =================================================\n        **Keyword Arguments**\n        editable              (bool) If True, cells in the table can be edited\n                              by the user. Default is False.\n        sortable              (bool) If True, the table may be soted by\n                              clicking on column headers. Note that this also\n                              causes rows to appear initially shuffled until\n                              a sort column is selected. Default is True.\n                              *(added in version 0.9.9)*\n        ===================== =================================================\n        """"""\n        \n        QtGui.QTableWidget.__init__(self, *args)\n        \n        self.itemClass = TableWidgetItem\n        \n        self.setVerticalScrollMode(self.ScrollPerPixel)\n        self.setSelectionMode(QtGui.QAbstractItemView.ContiguousSelection)\n        self.setSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)\n        self.clear()\n        \n        kwds.setdefault(\'sortable\', True)\n        kwds.setdefault(\'editable\', False)\n        self.setEditable(kwds.pop(\'editable\'))\n        self.setSortingEnabled(kwds.pop(\'sortable\'))\n        \n        if len(kwds) > 0:\n            raise TypeError(""Invalid keyword arguments \'%s\'"" % kwds.keys())\n        \n        self._sorting = None  # used when temporarily disabling sorting\n        \n        self._formats = {None: None} # stores per-column formats and entire table format\n        self.sortModes = {} # stores per-column sort mode\n        \n        self.itemChanged.connect(self.handleItemChanged)\n        \n        self.contextMenu = QtGui.QMenu()\n        self.contextMenu.addAction(\'Copy Selection\').triggered.connect(self.copySel)\n        self.contextMenu.addAction(\'Copy All\').triggered.connect(self.copyAll)\n        self.contextMenu.addAction(\'Save Selection\').triggered.connect(self.saveSel)\n        self.contextMenu.addAction(\'Save All\').triggered.connect(self.saveAll)\n        \n    def clear(self):\n        """"""Clear all contents from the table.""""""\n        QtGui.QTableWidget.clear(self)\n        self.verticalHeadersSet = False\n        self.horizontalHeadersSet = False\n        self.items = []\n        self.setRowCount(0)\n        self.setColumnCount(0)\n        self.sortModes = {}\n        \n    def setData(self, data):\n        """"""Set the data displayed in the table.\n        Allowed formats are:\n        \n        * numpy arrays\n        * numpy record arrays \n        * metaarrays\n        * list-of-lists  [[1,2,3], [4,5,6]]\n        * dict-of-lists  {\'x\': [1,2,3], \'y\': [4,5,6]}\n        * list-of-dicts  [{\'x\': 1, \'y\': 4}, {\'x\': 2, \'y\': 5}, ...]\n        """"""\n        self.clear()\n        self.appendData(data)\n        self.resizeColumnsToContents()\n        \n    @_defersort\n    def appendData(self, data):\n        """"""\n        Add new rows to the table.\n        \n        See :func:`setData() <pyqtgraph.TableWidget.setData>` for accepted\n        data types.\n        """"""\n        startRow = self.rowCount()\n        \n        fn0, header0 = self.iteratorFn(data)\n        if fn0 is None:\n            self.clear()\n            return\n        it0 = fn0(data)\n        try:\n            first = next(it0)\n        except StopIteration:\n            return\n        fn1, header1 = self.iteratorFn(first)\n        if fn1 is None:\n            self.clear()\n            return\n        \n        firstVals = [x for x in fn1(first)]\n        self.setColumnCount(len(firstVals))\n        \n        if not self.verticalHeadersSet and header0 is not None:\n            labels = [self.verticalHeaderItem(i).text() for i in range(self.rowCount())]\n            self.setRowCount(startRow + len(header0))\n            self.setVerticalHeaderLabels(labels + header0)\n            self.verticalHeadersSet = True\n        if not self.horizontalHeadersSet and header1 is not None:\n            self.setHorizontalHeaderLabels(header1)\n            self.horizontalHeadersSet = True\n        \n        i = startRow\n        self.setRow(i, firstVals)\n        for row in it0:\n            i += 1\n            self.setRow(i, [x for x in fn1(row)])\n            \n        if (self._sorting and self.horizontalHeadersSet and \n            self.horizontalHeader().sortIndicatorSection() >= self.columnCount()):\n            self.sortByColumn(0, QtCore.Qt.AscendingOrder)\n    \n    def setEditable(self, editable=True):\n        self.editable = editable\n        for item in self.items:\n            item.setEditable(editable)\n    \n    def setFormat(self, format, column=None):\n        """"""\n        Specify the default text formatting for the entire table, or for a\n        single column if *column* is specified.\n        \n        If a string is specified, it is used as a format string for converting\n        float values (and all other types are converted using str). If a \n        function is specified, it will be called with the item as its only\n        argument and must return a string. Setting format = None causes the \n        default formatter to be used instead.\n        \n        Added in version 0.9.9.\n        \n        """"""\n        if format is not None and not isinstance(format, basestring) and not callable(format):\n            raise ValueError(""Format argument must string, callable, or None. (got %s)"" % format)\n        \n        self._formats[column] = format\n        \n        \n        if column is None:\n            # update format of all items that do not have a column format \n            # specified\n            for c in range(self.columnCount()):\n                if self._formats.get(c, None) is None:\n                    for r in range(self.rowCount()):\n                        item = self.item(r, c)\n                        if item is None:\n                            continue\n                        item.setFormat(format)\n        else:\n            # set all items in the column to use this format, or the default \n            # table format if None was specified.\n            if format is None:\n                format = self._formats[None]\n            for r in range(self.rowCount()):\n                item = self.item(r, column)\n                if item is None:\n                    continue\n                item.setFormat(format)\n        \n    \n    def iteratorFn(self, data):\n        ## Return 1) a function that will provide an iterator for data and 2) a list of header strings\n        if isinstance(data, list) or isinstance(data, tuple):\n            return lambda d: d.__iter__(), None\n        elif isinstance(data, dict):\n            return lambda d: iter(d.values()), list(map(asUnicode, data.keys()))\n        elif (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n            if data.axisHasColumns(0):\n                header = [asUnicode(data.columnName(0, i)) for i in range(data.shape[0])]\n            elif data.axisHasValues(0):\n                header = list(map(asUnicode, data.xvals(0)))\n            else:\n                header = None\n            return self.iterFirstAxis, header\n        elif isinstance(data, np.ndarray):\n            return self.iterFirstAxis, None\n        elif isinstance(data, np.void):\n            return self.iterate, list(map(asUnicode, data.dtype.names))\n        elif data is None:\n            return (None,None)\n        elif np.isscalar(data):\n            return self.iterateScalar, None\n        else:\n            msg = ""Don\'t know how to iterate over data type: {!s}"".format(type(data))\n            raise TypeError(msg)\n        \n    def iterFirstAxis(self, data):\n        for i in range(data.shape[0]):\n            yield data[i]\n            \n    def iterate(self, data):\n        # for numpy.void, which can be iterated but mysteriously \n        # has no __iter__ (??)\n        for x in data:\n            yield x\n        \n    def iterateScalar(self, data):\n        yield data\n        \n    def appendRow(self, data):\n        self.appendData([data])\n        \n    @_defersort\n    def addRow(self, vals):\n        row = self.rowCount()\n        self.setRowCount(row + 1)\n        self.setRow(row, vals)\n        \n    @_defersort\n    def setRow(self, row, vals):\n        if row > self.rowCount() - 1:\n            self.setRowCount(row + 1)\n        for col in range(len(vals)):\n            val = vals[col]\n            item = self.itemClass(val, row)\n            item.setEditable(self.editable)\n            sortMode = self.sortModes.get(col, None)\n            if sortMode is not None:\n                item.setSortMode(sortMode)\n            format = self._formats.get(col, self._formats[None])\n            item.setFormat(format)\n            self.items.append(item)\n            self.setItem(row, col, item)\n            item.setValue(val)  # Required--the text-change callback is invoked\n                                # when we call setItem.\n\n    def setSortMode(self, column, mode):\n        """"""\n        Set the mode used to sort *column*.\n        \n        ============== ========================================================\n        **Sort Modes**\n        value          Compares item.value if available; falls back to text\n                       comparison.\n        text           Compares item.text()\n        index          Compares by the order in which items were inserted.\n        ============== ========================================================\n        \n        Added in version 0.9.9\n        """"""\n        for r in range(self.rowCount()):\n            item = self.item(r, column)\n            if hasattr(item, \'setSortMode\'):\n                item.setSortMode(mode)\n        self.sortModes[column] = mode\n        \n    def sizeHint(self):\n        # based on http://stackoverflow.com/a/7195443/54056\n        width = sum(self.columnWidth(i) for i in range(self.columnCount()))\n        width += self.verticalHeader().sizeHint().width()\n        width += self.verticalScrollBar().sizeHint().width()\n        width += self.frameWidth() * 2\n        height = sum(self.rowHeight(i) for i in range(self.rowCount()))\n        height += self.verticalHeader().sizeHint().height()\n        height += self.horizontalScrollBar().sizeHint().height()\n        return QtCore.QSize(width, height)\n         \n    def serialize(self, useSelection=False):\n        """"""Convert entire table (or just selected area) into tab-separated text values""""""\n        if useSelection:\n            selection = self.selectedRanges()[0]\n            rows = list(range(selection.topRow(),\n                              selection.bottomRow() + 1))\n            columns = list(range(selection.leftColumn(),\n                                 selection.rightColumn() + 1))        \n        else:\n            rows = list(range(self.rowCount()))\n            columns = list(range(self.columnCount()))\n\n        data = []\n        if self.horizontalHeadersSet:\n            row = []\n            if self.verticalHeadersSet:\n                row.append(asUnicode(\'\'))\n            \n            for c in columns:\n                row.append(asUnicode(self.horizontalHeaderItem(c).text()))\n            data.append(row)\n        \n        for r in rows:\n            row = []\n            if self.verticalHeadersSet:\n                row.append(asUnicode(self.verticalHeaderItem(r).text()))\n            for c in columns:\n                item = self.item(r, c)\n                if item is not None:\n                    row.append(asUnicode(item.value))\n                else:\n                    row.append(asUnicode(\'\'))\n            data.append(row)\n            \n        s = \'\'\n        for row in data:\n            s += (\'\\t\'.join(row) + \'\\n\')\n        return s\n\n    def copySel(self):\n        """"""Copy selected data to clipboard.""""""\n        QtGui.QApplication.clipboard().setText(self.serialize(useSelection=True))\n\n    def copyAll(self):\n        """"""Copy all data to clipboard.""""""\n        QtGui.QApplication.clipboard().setText(self.serialize(useSelection=False))\n\n    def saveSel(self):\n        """"""Save selected data to file.""""""\n        self.save(self.serialize(useSelection=True))\n\n    def saveAll(self):\n        """"""Save all data to file.""""""\n        self.save(self.serialize(useSelection=False))\n\n    def save(self, data):\n        fileName = QtGui.QFileDialog.getSaveFileName(self, ""Save As.."", """", ""Tab-separated values (*.tsv)"")\n        if isinstance(fileName, tuple):\n            fileName = fileName[0]  # Qt4/5 API difference\n        if fileName == \'\':\n            return\n        open(str(fileName), \'w\').write(data)\n\n    def contextMenuEvent(self, ev):\n        self.contextMenu.popup(ev.globalPos())\n        \n    def keyPressEvent(self, ev):\n        if ev.key() == QtCore.Qt.Key_C and ev.modifiers() == QtCore.Qt.ControlModifier:\n            ev.accept()\n            self.copySel()\n        else:\n            QtGui.QTableWidget.keyPressEvent(self, ev)\n\n    def handleItemChanged(self, item):\n        item.itemChanged()\n\n\nclass TableWidgetItem(QtGui.QTableWidgetItem):\n    def __init__(self, val, index, format=None):\n        QtGui.QTableWidgetItem.__init__(self, \'\')\n        self._blockValueChange = False\n        self._format = None\n        self._defaultFormat = \'%0.3g\'\n        self.sortMode = \'value\'\n        self.index = index\n        flags = QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled\n        self.setFlags(flags)\n        self.setValue(val)\n        self.setFormat(format)\n        \n    def setEditable(self, editable):\n        """"""\n        Set whether this item is user-editable.\n        """"""\n        if editable:\n            self.setFlags(self.flags() | QtCore.Qt.ItemIsEditable)\n        else:\n            self.setFlags(self.flags() & ~QtCore.Qt.ItemIsEditable)\n            \n    def setSortMode(self, mode):\n        """"""\n        Set the mode used to sort this item against others in its column.\n        \n        ============== ========================================================\n        **Sort Modes**\n        value          Compares item.value if available; falls back to text\n                       comparison.\n        text           Compares item.text()\n        index          Compares by the order in which items were inserted.\n        ============== ========================================================\n        """"""\n        modes = (\'value\', \'text\', \'index\', None)\n        if mode not in modes:\n            raise ValueError(\'Sort mode must be one of %s\' % str(modes))\n        self.sortMode = mode\n        \n    def setFormat(self, fmt):\n        """"""Define the conversion from item value to displayed text. \n        \n        If a string is specified, it is used as a format string for converting\n        float values (and all other types are converted using str). If a \n        function is specified, it will be called with the item as its only\n        argument and must return a string.\n        \n        Added in version 0.9.9.\n        """"""\n        if fmt is not None and not isinstance(fmt, basestring) and not callable(fmt):\n            raise ValueError(""Format argument must string, callable, or None. (got %s)"" % fmt)\n        self._format = fmt\n        self._updateText()\n        \n    def _updateText(self):\n        self._blockValueChange = True\n        try:\n            self._text = self.format()\n            self.setText(self._text)\n        finally:\n            self._blockValueChange = False\n\n    def setValue(self, value):\n        self.value = value\n        self._updateText()\n\n    def itemChanged(self):\n        """"""Called when the data of this item has changed.""""""\n        if self.text() != self._text:\n            self.textChanged()\n\n    def textChanged(self):\n        """"""Called when this item\'s text has changed for any reason.""""""\n        self._text = self.text()\n\n        if self._blockValueChange:\n            # text change was result of value or format change; do not\n            # propagate.\n            return\n        \n        try:\n\n            self.value = type(self.value)(self.text())\n        except ValueError:\n            self.value = str(self.text())\n\n    def format(self):\n        if callable(self._format):\n            return self._format(self)\n        if isinstance(self.value, (float, np.floating)):\n            if self._format is None:\n                return self._defaultFormat % self.value\n            else:\n                return self._format % self.value\n        else:\n            return asUnicode(self.value)\n\n    def __lt__(self, other):\n        if self.sortMode == \'index\' and hasattr(other, \'index\'):\n            return self.index < other.index\n        if self.sortMode == \'value\' and hasattr(other, \'value\'):\n            return self.value < other.value\n        else:\n            return self.text() < other.text()\n\n\nif __name__ == \'__main__\':\n    app = QtGui.QApplication([])\n    win = QtGui.QMainWindow()\n    t = TableWidget()\n    win.setCentralWidget(t)\n    win.resize(800,600)\n    win.show()\n    \n    ll = [[1,2,3,4,5]] * 20\n    ld = [{\'x\': 1, \'y\': 2, \'z\': 3}] * 20\n    dl = {\'x\': list(range(20)), \'y\': list(range(20)), \'z\': list(range(20))}\n    \n    a = np.ones((20, 5))\n    ra = np.ones((20,), dtype=[(\'x\', int), (\'y\', int), (\'z\', int)])\n    \n    t.setData(ll)\n    \n    ma = metaarray.MetaArray(np.ones((20, 3)), info=[\n        {\'values\': np.linspace(1, 5, 20)}, \n        {\'cols\': [\n            {\'name\': \'x\'},\n            {\'name\': \'y\'},\n            {\'name\': \'z\'},\n        ]}\n    ])\n    t.setData(ma)\n    \n'"
src/third_party/pyqtgraph/widgets/TreeWidget.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtGui, QtCore\nfrom weakref import *\n\n__all__ = [\'TreeWidget\', \'TreeWidgetItem\']\n\n\nclass TreeWidget(QtGui.QTreeWidget):\n    """"""Extends QTreeWidget to allow internal drag/drop with widgets in the tree.\n    Also maintains the expanded state of subtrees as they are moved.\n    This class demonstrates the absurd lengths one must go to to make drag/drop work.""""""\n    \n    sigItemMoved = QtCore.Signal(object, object, object) # (item, parent, index)\n    sigItemCheckStateChanged = QtCore.Signal(object, object)\n    sigItemTextChanged = QtCore.Signal(object, object)\n    sigColumnCountChanged = QtCore.Signal(object, object)  # self, count\n    \n    def __init__(self, parent=None):\n        QtGui.QTreeWidget.__init__(self, parent)\n        \n        # wrap this item so that we can propagate tree change information\n        # to children.\n        self._invRootItem = InvisibleRootItem(QtGui.QTreeWidget.invisibleRootItem(self))\n        \n        self.setAcceptDrops(True)\n        self.setDragEnabled(True)\n        self.setEditTriggers(QtGui.QAbstractItemView.EditKeyPressed|QtGui.QAbstractItemView.SelectedClicked)\n        self.placeholders = []\n        self.childNestingLimit = None\n        self.itemClicked.connect(self._itemClicked)\n\n    def setItemWidget(self, item, col, wid):\n        """"""\n        Overrides QTreeWidget.setItemWidget such that widgets are added inside an invisible wrapper widget.\n        This makes it possible to move the item in and out of the tree without its widgets being automatically deleted.\n        """"""\n        w = QtGui.QWidget()  ## foster parent / surrogate child widget\n        l = QtGui.QVBoxLayout()\n        l.setContentsMargins(0,0,0,0)\n        w.setLayout(l)\n        w.setSizePolicy(wid.sizePolicy())\n        w.setMinimumHeight(wid.minimumHeight())\n        w.setMinimumWidth(wid.minimumWidth())\n        l.addWidget(wid)\n        w.realChild = wid\n        self.placeholders.append(w)\n        QtGui.QTreeWidget.setItemWidget(self, item, col, w)\n\n    def itemWidget(self, item, col):\n        w = QtGui.QTreeWidget.itemWidget(self, item, col)\n        if w is not None and hasattr(w, \'realChild\'):\n            w = w.realChild\n        return w\n\n    def dropMimeData(self, parent, index, data, action):\n        item = self.currentItem()\n        p = parent\n        #print ""drop"", item, ""->"", parent, index\n        while True:\n            if p is None:\n                break\n            if p is item:\n                return False\n                #raise Exception(""Can not move item into itself."")\n            p = p.parent()\n        \n        if not self.itemMoving(item, parent, index):\n            return False\n        \n        currentParent = item.parent()\n        if currentParent is None:\n            currentParent = self.invisibleRootItem()\n        if parent is None:\n            parent = self.invisibleRootItem()\n            \n        if currentParent is parent and index > parent.indexOfChild(item):\n            index -= 1\n            \n        self.prepareMove(item)\n            \n        currentParent.removeChild(item)\n        #print ""  insert child to index"", index\n        parent.insertChild(index, item)  ## index will not be correct\n        self.setCurrentItem(item)\n        \n        self.recoverMove(item)\n        #self.emit(QtCore.SIGNAL(\'itemMoved\'), item, parent, index)\n        self.sigItemMoved.emit(item, parent, index)\n        return True\n\n    def itemMoving(self, item, parent, index):\n        """"""Called when item has been dropped elsewhere in the tree.\n        Return True to accept the move, False to reject.""""""\n        return True\n        \n    def prepareMove(self, item):\n        item.__widgets = []\n        item.__expanded = item.isExpanded()\n        for i in range(self.columnCount()):\n            w = self.itemWidget(item, i)\n            item.__widgets.append(w)\n            if w is None:\n                continue\n            w.setParent(None)\n        for i in range(item.childCount()):\n            self.prepareMove(item.child(i))\n        \n    def recoverMove(self, item):\n        for i in range(self.columnCount()):\n            w = item.__widgets[i]\n            if w is None:\n                continue\n            self.setItemWidget(item, i, w)\n        for i in range(item.childCount()):\n            self.recoverMove(item.child(i))\n        \n        item.setExpanded(False)  ## Items do not re-expand correctly unless they are collapsed first.\n        QtGui.QApplication.instance().processEvents()\n        item.setExpanded(item.__expanded)\n        \n    def collapseTree(self, item):\n        item.setExpanded(False)\n        for i in range(item.childCount()):\n            self.collapseTree(item.child(i))\n            \n    def removeTopLevelItem(self, item):\n        for i in range(self.topLevelItemCount()):\n            if self.topLevelItem(i) is item:\n                self.takeTopLevelItem(i)\n                return\n        raise Exception(""Item \'%s\' not in top-level items."" % str(item))\n    \n    def listAllItems(self, item=None):\n        items = []\n        if item != None:\n            items.append(item)\n        else:\n            item = self.invisibleRootItem()\n        \n        for cindex in range(item.childCount()):\n            foundItems = self.listAllItems(item=item.child(cindex))\n            for f in foundItems:\n                items.append(f)\n        return items\n            \n    def dropEvent(self, ev):\n        QtGui.QTreeWidget.dropEvent(self, ev)\n        self.updateDropFlags()\n\n    def updateDropFlags(self):\n        ### intended to put a limit on how deep nests of children can go.\n        ### self.childNestingLimit is upheld when moving items without children, but if the item being moved has children/grandchildren, the children/grandchildren\n        ### can end up over the childNestingLimit. \n        if self.childNestingLimit == None:\n            pass # enable drops in all items (but only if there are drops that aren\'t enabled? for performance...)\n        else:\n            items = self.listAllItems()\n            for item in items:\n                parentCount = 0\n                p = item.parent()\n                while p is not None:\n                    parentCount += 1\n                    p = p.parent()\n                if parentCount >= self.childNestingLimit:\n                    item.setFlags(item.flags() & (~QtCore.Qt.ItemIsDropEnabled))\n                else:\n                    item.setFlags(item.flags() | QtCore.Qt.ItemIsDropEnabled)\n\n    @staticmethod\n    def informTreeWidgetChange(item):\n        if hasattr(item, \'treeWidgetChanged\'):\n            item.treeWidgetChanged()\n        for i in range(item.childCount()):\n            TreeWidget.informTreeWidgetChange(item.child(i))\n        \n    def addTopLevelItem(self, item):\n        QtGui.QTreeWidget.addTopLevelItem(self, item)\n        self.informTreeWidgetChange(item)\n\n    def addTopLevelItems(self, items):\n        QtGui.QTreeWidget.addTopLevelItems(self, items)\n        for item in items:\n            self.informTreeWidgetChange(item)\n            \n    def insertTopLevelItem(self, index, item):\n        QtGui.QTreeWidget.insertTopLevelItem(self, index, item)\n        self.informTreeWidgetChange(item)\n\n    def insertTopLevelItems(self, index, items):\n        QtGui.QTreeWidget.insertTopLevelItems(self, index, items)\n        for item in items:\n            self.informTreeWidgetChange(item)\n            \n    def takeTopLevelItem(self, index):\n        item = self.topLevelItem(index)\n        if item is not None:\n            self.prepareMove(item)\n        item = QtGui.QTreeWidget.takeTopLevelItem(self, index)\n        self.prepareMove(item)\n        self.informTreeWidgetChange(item)\n        return item\n\n    def topLevelItems(self):\n        return map(self.topLevelItem, xrange(self.topLevelItemCount()))\n        \n    def clear(self):\n        items = self.topLevelItems()\n        for item in items:\n            self.prepareMove(item)\n        QtGui.QTreeWidget.clear(self)\n        \n        ## Why do we want to do this? It causes RuntimeErrors. \n        #for item in items:\n            #self.informTreeWidgetChange(item)\n\n    def invisibleRootItem(self):\n        return self._invRootItem\n        \n    def itemFromIndex(self, index):\n        """"""Return the item and column corresponding to a QModelIndex.\n        """"""\n        col = index.column()\n        rows = []\n        while index.row() >= 0:\n            rows.insert(0, index.row())\n            index = index.parent()\n        item = self.topLevelItem(rows[0])\n        for row in rows[1:]:\n            item = item.child(row)\n        return item, col\n\n    def setColumnCount(self, c):\n        QtGui.QTreeWidget.setColumnCount(self, c)\n        self.sigColumnCountChanged.emit(self, c)\n\n    def _itemClicked(self, item, col):\n        if hasattr(item, \'itemClicked\'):\n            item.itemClicked(col)\n\n\nclass TreeWidgetItem(QtGui.QTreeWidgetItem):\n    """"""\n    TreeWidgetItem that keeps track of its own widgets and expansion state.\n    \n    * Widgets may be added to columns before the item is added to a tree.\n    * Expanded state may be set before item is added to a tree.\n    * Adds setCheked and isChecked methods.\n    * Adds addChildren, insertChildren, and takeChildren methods.\n    """"""\n    def __init__(self, *args):\n        QtGui.QTreeWidgetItem.__init__(self, *args)\n        self._widgets = {}  # col: widget\n        self._tree = None\n        self._expanded = False\n        \n    def setChecked(self, column, checked):\n        self.setCheckState(column, QtCore.Qt.Checked if checked else QtCore.Qt.Unchecked)\n\n    def isChecked(self, col):\n        return self.checkState(col) == QtCore.Qt.Checked\n        \n    def setExpanded(self, exp):\n        self._expanded = exp\n        QtGui.QTreeWidgetItem.setExpanded(self, exp)\n        \n    def isExpanded(self):\n        return self._expanded\n        \n    def setWidget(self, column, widget):\n        if column in self._widgets:\n            self.removeWidget(column)\n        self._widgets[column] = widget\n        tree = self.treeWidget()\n        if tree is None:\n            return\n        else:\n            tree.setItemWidget(self, column, widget)\n            \n    def removeWidget(self, column):\n        del self._widgets[column]\n        tree = self.treeWidget()\n        if tree is None:\n            return\n        tree.removeItemWidget(self, column)\n            \n    def treeWidgetChanged(self):\n        tree = self.treeWidget()\n        if self._tree is tree:\n            return\n        self._tree = self.treeWidget()\n        if tree is None:\n            return\n        for col, widget in self._widgets.items():\n            tree.setItemWidget(self, col, widget)\n        QtGui.QTreeWidgetItem.setExpanded(self, self._expanded)\n    \n    def childItems(self):\n        return [self.child(i) for i in range(self.childCount())]\n    \n    def addChild(self, child):\n        QtGui.QTreeWidgetItem.addChild(self, child)\n        TreeWidget.informTreeWidgetChange(child)\n            \n    def addChildren(self, childs):\n        QtGui.QTreeWidgetItem.addChildren(self, childs)\n        for child in childs:\n            TreeWidget.informTreeWidgetChange(child)\n\n    def insertChild(self, index, child):\n        QtGui.QTreeWidgetItem.insertChild(self, index, child)\n        TreeWidget.informTreeWidgetChange(child)\n    \n    def insertChildren(self, index, childs):\n        QtGui.QTreeWidgetItem.addChildren(self, index, childs)\n        for child in childs:\n            TreeWidget.informTreeWidgetChange(child)\n    \n    def removeChild(self, child):\n        QtGui.QTreeWidgetItem.removeChild(self, child)\n        TreeWidget.informTreeWidgetChange(child)\n            \n    def takeChild(self, index):\n        child = QtGui.QTreeWidgetItem.takeChild(self, index)\n        TreeWidget.informTreeWidgetChange(child)\n        return child\n    \n    def takeChildren(self):\n        childs = QtGui.QTreeWidgetItem.takeChildren(self)\n        for child in childs:\n            TreeWidget.informTreeWidgetChange(child)\n        return childs\n        \n    def setData(self, column, role, value):\n        # credit: ekhumoro\n        #   http://stackoverflow.com/questions/13662020/how-to-implement-itemchecked-and-itemunchecked-signals-for-qtreewidget-in-pyqt4\n        checkstate = self.checkState(column)\n        text = self.text(column)\n        QtGui.QTreeWidgetItem.setData(self, column, role, value)\n        \n        treewidget = self.treeWidget()\n        if treewidget is None:\n            return\n        if (role == QtCore.Qt.CheckStateRole and checkstate != self.checkState(column)):\n            treewidget.sigItemCheckStateChanged.emit(self, column)\n        elif (role in (QtCore.Qt.DisplayRole, QtCore.Qt.EditRole) and text != self.text(column)):\n            treewidget.sigItemTextChanged.emit(self, column)\n\n    def itemClicked(self, col):\n        """"""Called when this item is clicked on.\n        \n        Override this method to react to user clicks.\n        """"""\n\n            \nclass InvisibleRootItem(object):\n    """"""Wrapper around a TreeWidget\'s invisible root item that calls\n    TreeWidget.informTreeWidgetChange when child items are added/removed.\n    """"""\n    def __init__(self, item):\n        self._real_item = item\n        \n    def addChild(self, child):\n        self._real_item.addChild(child)\n        TreeWidget.informTreeWidgetChange(child)\n            \n    def addChildren(self, childs):\n        self._real_item.addChildren(childs)\n        for child in childs:\n            TreeWidget.informTreeWidgetChange(child)\n\n    def insertChild(self, index, child):\n        self._real_item.insertChild(index, child)\n        TreeWidget.informTreeWidgetChange(child)\n    \n    def insertChildren(self, index, childs):\n        self._real_item.addChildren(index, childs)\n        for child in childs:\n            TreeWidget.informTreeWidgetChange(child)\n    \n    def removeChild(self, child):\n        self._real_item.removeChild(child)\n        TreeWidget.informTreeWidgetChange(child)\n            \n    def takeChild(self, index):\n        child = self._real_item.takeChild(index)\n        TreeWidget.informTreeWidgetChange(child)\n        return child\n    \n    def takeChildren(self):\n        childs = self._real_item.takeChildren()\n        for child in childs:\n            TreeWidget.informTreeWidgetChange(child)\n        return childs\n\n    def __getattr__(self, attr):\n        return getattr(self._real_item, attr)\n'"
src/third_party/pyqtgraph/widgets/ValueLabel.py,0,"b'from ..Qt import QtCore, QtGui\nfrom ..ptime import time\nfrom .. import functions as fn\nfrom functools import reduce\n\n__all__ = [\'ValueLabel\']\n\nclass ValueLabel(QtGui.QLabel):\n    """"""\n    QLabel specifically for displaying numerical values.\n    Extends QLabel adding some extra functionality:\n\n    - displaying units with si prefix\n    - built-in exponential averaging \n    """"""\n    \n    def __init__(self, parent=None, suffix=\'\', siPrefix=False, averageTime=0, formatStr=None):\n        """"""\n        ==============      ==================================================================================\n        **Arguments:**\n        suffix              (str or None) The suffix to place after the value\n        siPrefix            (bool) Whether to add an SI prefix to the units and display a scaled value\n        averageTime         (float) The length of time in seconds to average values. If this value\n                            is 0, then no averaging is performed. As this value increases\n                            the display value will appear to change more slowly and smoothly.\n        formatStr           (str) Optionally, provide a format string to use when displaying text. The text\n                            will be generated by calling formatStr.format(value=, avgValue=, suffix=)\n                            (see Python documentation on str.format)\n                            This option is not compatible with siPrefix\n        ==============      ==================================================================================\n        """"""\n        QtGui.QLabel.__init__(self, parent)\n        self.values = []\n        self.averageTime = averageTime ## no averaging by default\n        self.suffix = suffix\n        self.siPrefix = siPrefix\n        if formatStr is None:\n            formatStr = \'{avgValue:0.2g} {suffix}\'\n        self.formatStr = formatStr\n    \n    def setValue(self, value):\n        now = time()\n        self.values.append((now, value))\n        cutoff = now - self.averageTime\n        while len(self.values) > 0 and self.values[0][0] < cutoff:\n            self.values.pop(0)\n        self.update()\n        \n    def setFormatStr(self, text):\n        self.formatStr = text\n        self.update()\n        \n    def setAverageTime(self, t):\n        self.averageTime = t\n        \n    def averageValue(self):\n        return reduce(lambda a,b: a+b, [v[1] for v in self.values]) / float(len(self.values))\n        \n        \n    def paintEvent(self, ev):\n        self.setText(self.generateText())\n        return QtGui.QLabel.paintEvent(self, ev)\n        \n    def generateText(self):\n        if len(self.values) == 0:\n            return \'\'\n        avg = self.averageValue()\n        val = self.values[-1][1]\n        if self.siPrefix:\n            return fn.siFormat(avg, suffix=self.suffix)\n        else:\n            return self.formatStr.format(value=val, avgValue=avg, suffix=self.suffix)\n            \n'"
src/third_party/pyqtgraph/widgets/VerticalLabel.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Qt import QtGui, QtCore\n\n__all__ = [\'VerticalLabel\']\n#class VerticalLabel(QtGui.QLabel):\n    #def paintEvent(self, ev):\n        #p = QtGui.QPainter(self)\n        #p.rotate(-90)\n        #self.hint = p.drawText(QtCore.QRect(-self.height(), 0, self.height(), self.width()), QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter, self.text())\n        #p.end()\n        #self.setMinimumWidth(self.hint.height())\n        #self.setMinimumHeight(self.hint.width())\n\n    #def sizeHint(self):\n        #if hasattr(self, \'hint\'):\n            #return QtCore.QSize(self.hint.height(), self.hint.width())\n        #else:\n            #return QtCore.QSize(16, 50)\n\nclass VerticalLabel(QtGui.QLabel):\n    def __init__(self, text, orientation=\'vertical\', forceWidth=True):\n        QtGui.QLabel.__init__(self, text)\n        self.forceWidth = forceWidth\n        self.orientation = None\n        self.setOrientation(orientation)\n        \n    def setOrientation(self, o):\n        if self.orientation == o:\n            return\n        self.orientation = o\n        self.update()\n        self.updateGeometry()\n        \n    def paintEvent(self, ev):\n        p = QtGui.QPainter(self)\n        #p.setBrush(QtGui.QBrush(QtGui.QColor(100, 100, 200)))\n        #p.setPen(QtGui.QPen(QtGui.QColor(50, 50, 100)))\n        #p.drawRect(self.rect().adjusted(0, 0, -1, -1))\n        \n        #p.setPen(QtGui.QPen(QtGui.QColor(255, 255, 255)))\n        \n        if self.orientation == \'vertical\':\n            p.rotate(-90)\n            rgn = QtCore.QRect(-self.height(), 0, self.height(), self.width())\n        else:\n            rgn = self.contentsRect()\n        align = self.alignment()\n        #align  = QtCore.Qt.AlignTop|QtCore.Qt.AlignHCenter\n            \n        self.hint = p.drawText(rgn, align, self.text())\n        p.end()\n        \n        if self.orientation == \'vertical\':\n            self.setMaximumWidth(self.hint.height())\n            self.setMinimumWidth(0)\n            self.setMaximumHeight(16777215)\n            if self.forceWidth:\n                self.setMinimumHeight(self.hint.width())\n            else:\n                self.setMinimumHeight(0)\n        else:\n            self.setMaximumHeight(self.hint.height())\n            self.setMinimumHeight(0)\n            self.setMaximumWidth(16777215)\n            if self.forceWidth:\n                self.setMinimumWidth(self.hint.width())\n            else:\n                self.setMinimumWidth(0)\n\n    def sizeHint(self):\n        if self.orientation == \'vertical\':\n            if hasattr(self, \'hint\'):\n                return QtCore.QSize(self.hint.height(), self.hint.width())\n            else:\n                return QtCore.QSize(19, 50)\n        else:\n            if hasattr(self, \'hint\'):\n                return QtCore.QSize(self.hint.width(), self.hint.height())\n            else:\n                return QtCore.QSize(50, 19)\n\n\nif __name__ == \'__main__\':\n    app = QtGui.QApplication([])\n    win = QtGui.QMainWindow()\n    w = QtGui.QWidget()\n    l = QtGui.QGridLayout()\n    w.setLayout(l)\n    \n    l1 = VerticalLabel(""text 1"", orientation=\'horizontal\')\n    l2 = VerticalLabel(""text 2"")\n    l3 = VerticalLabel(""text 3"")\n    l4 = VerticalLabel(""text 4"", orientation=\'horizontal\')\n    l.addWidget(l1, 0, 0)\n    l.addWidget(l2, 1, 1)\n    l.addWidget(l3, 2, 2)\n    l.addWidget(l4, 3, 3)\n    win.setCentralWidget(w)\n    win.show()'"
src/third_party/pyqtgraph/widgets/__init__.py,0,b''
src/third_party/pyqtgraph/dockarea/tests/test_dock.py,0,"b'# -*- coding: utf-8 -*-\n#import sip\n#sip.setapi(\'QString\', 1)\n\nimport pyqtgraph as pg\npg.mkQApp()\n\nimport pyqtgraph.dockarea as da\n\ndef test_dock():\n    name = pg.asUnicode(""\xc3\xa9v\xc3\xa8nts_z\xc3\xa0h\xc3\xa9\xc3\xa9r"")\n    dock = da.Dock(name=name)\n    # make sure unicode names work correctly\n    assert dock.name() == name\n    # no surprises in return type.\n    assert type(dock.name()) == type(name)\n'"
src/third_party/pyqtgraph/dockarea/tests/test_dockarea.py,0,"b'# -*- coding: utf-8 -*-\n\nimport pytest\nimport pyqtgraph as pg\nfrom pyqtgraph.ordereddict import OrderedDict\npg.mkQApp()\n\nimport pyqtgraph.dockarea as da\n\ndef test_dockarea():\n    a = da.DockArea()\n    d1 = da.Dock(""dock 1"")\n    a.addDock(d1, \'left\')\n\n    assert a.topContainer is d1.container()\n    assert d1.container().container() is a\n    assert d1.area is a\n    assert a.topContainer.widget(0) is d1\n\n    d2 = da.Dock(""dock 2"")\n    a.addDock(d2, \'right\')\n\n    assert a.topContainer is d1.container()\n    assert a.topContainer is d2.container()\n    assert d1.container().container() is a\n    assert d2.container().container() is a\n    assert d2.area is a\n    assert a.topContainer.widget(0) is d1\n    assert a.topContainer.widget(1) is d2\n\n    d3 = da.Dock(""dock 3"")\n    a.addDock(d3, \'bottom\')\n\n    assert a.topContainer is d3.container()\n    assert d2.container().container() is d3.container()\n    assert d1.container().container() is d3.container()\n    assert d1.container().container().container() is a\n    assert d2.container().container().container() is a\n    assert d3.container().container() is a\n    assert d3.area is a\n    assert d2.area is a\n    assert a.topContainer.widget(0) is d1.container()\n    assert a.topContainer.widget(1) is d3\n\n    d4 = da.Dock(""dock 4"")\n    a.addDock(d4, \'below\', d3)\n\n    assert d4.container().type() == \'tab\'\n    assert d4.container() is d3.container()\n    assert d3.container().container() is d2.container().container()\n    assert d4.area is a\n    a.printState()\n\n    # layout now looks like:\n    #    vcontainer\n    #        hcontainer\n    #            dock 1\n    #            dock 2\n    #        tcontainer\n    #            dock 3\n    #            dock 4\n\n    # test save/restore state\n    state = a.saveState()\n    a2 = da.DockArea()\n    # default behavior is to raise exception if docks are missing\n    with pytest.raises(Exception):\n        a2.restoreState(state)\n\n    # test restore with ignore missing\n    a2.restoreState(state, missing=\'ignore\')\n    assert a2.topContainer is None\n\n    # test restore with auto-create\n    a2.restoreState(state, missing=\'create\')\n    assert a2.saveState() == state\n    a2.printState()\n\n    # double-check that state actually matches the output of saveState()\n    c1 = a2.topContainer\n    assert c1.type() == \'vertical\'\n    c2 = c1.widget(0)\n    c3 = c1.widget(1)\n    assert c2.type() == \'horizontal\'\n    assert c2.widget(0).name() == \'dock 1\'\n    assert c2.widget(1).name() == \'dock 2\'\n    assert c3.type() == \'tab\'\n    assert c3.widget(0).name() == \'dock 3\'\n    assert c3.widget(1).name() == \'dock 4\'\n\n    # test restore with docks already present\n    a3 = da.DockArea()\n    a3docks = []\n    for i in range(1, 5):\n        dock = da.Dock(\'dock %d\' % i)\n        a3docks.append(dock)\n        a3.addDock(dock, \'right\')\n    a3.restoreState(state)\n    assert a3.saveState() == state\n\n    # test restore with extra docks present    \n    a3 = da.DockArea()\n    a3docks = []\n    for i in [1, 2, 5, 4, 3]:\n        dock = da.Dock(\'dock %d\' % i)\n        a3docks.append(dock)\n        a3.addDock(dock, \'left\')\n    a3.restoreState(state)\n    a3.printState()\n\n\n    # test a more complex restore\n    a4 = da.DockArea()\n    state1 = {\'float\': [], \'main\': \n        (\'horizontal\', [\n            (\'vertical\', [\n                (\'horizontal\', [\n                    (\'tab\', [\n                        (\'dock\', \'dock1\', {}), \n                        (\'dock\', \'dock2\', {}), \n                        (\'dock\', \'dock3\', {}), \n                        (\'dock\', \'dock4\', {})\n                        ], {\'index\': 1}), \n                    (\'vertical\', [\n                        (\'dock\', \'dock5\', {}), \n                        (\'horizontal\', [\n                            (\'dock\', \'dock6\', {}), \n                            (\'dock\', \'dock7\', {})\n                            ], {\'sizes\': [184, 363]})\n                        ], {\'sizes\': [355, 120]})\n                    ], {\'sizes\': [9, 552]})\n                ], {\'sizes\': [480]}), \n            (\'dock\', \'dock8\', {})\n            ], {\'sizes\': [566, 69]})\n        }\n\n    state2 = {\'float\': [], \'main\': \n        (\'horizontal\', [\n            (\'vertical\', [\n                (\'horizontal\', [\n                    (\'dock\', \'dock2\', {}), \n                    (\'vertical\', [\n                        (\'dock\', \'dock5\', {}), \n                        (\'horizontal\', [\n                            (\'dock\', \'dock6\', {}), \n                            (\'dock\', \'dock7\', {})\n                            ], {\'sizes\': [492, 485]})\n                        ], {\'sizes\': [936, 0]})\n                    ], {\'sizes\': [172, 982]})\n                ], {\'sizes\': [941]}), \n            (\'vertical\', [\n                (\'dock\', \'dock8\', {}), \n                (\'dock\', \'dock4\', {}), \n                (\'dock\', \'dock1\', {})\n                ], {\'sizes\': [681, 225, 25]})\n            ], {\'sizes\': [1159, 116]})}\n\n    a4.restoreState(state1, missing=\'create\')\n    # dock3 not mentioned in restored state; stays in dockarea by default\n    c, d = a4.findAll()\n    assert d[\'dock3\'].area is a4\n    \n    a4.restoreState(state2, missing=\'ignore\', extra=\'float\')\n    a4.printState()\n\n    c, d = a4.findAll()\n    # dock3 not mentioned in restored state; goes to float due to `extra` argument\n    assert d[\'dock3\'].area is not a4\n    assert d[\'dock1\'].container() is d[\'dock4\'].container() is d[\'dock8\'].container()\n    assert d[\'dock6\'].container() is d[\'dock7\'].container()\n    assert a4 is d[\'dock2\'].area is d[\'dock2\'].container().container().container()\n    assert a4 is d[\'dock5\'].area is d[\'dock5\'].container().container().container().container()\n\n    # States should be the same with two exceptions:\n    #   dock3 is in a float because it does not appear in state2\n    #   a superfluous vertical splitter in state2 has been removed\n    state4 = a4.saveState()\n    state4[\'main\'][1][0] = state4[\'main\'][1][0][1][0]\n    assert clean_state(state4[\'main\']) == clean_state(state2[\'main\'])\n\n\ndef clean_state(state):\n    # return state dict with sizes removed\n    ch = [clean_state(x) for x in state[1]] if isinstance(state[1], list) else state[1]\n    state = (state[0], ch, {})\n\n\nif __name__ == \'__main__\':\n    test_dockarea()\n'"
src/third_party/pyqtgraph/exporters/tests/__init__.py,0,b''
src/third_party/pyqtgraph/exporters/tests/test_csv.py,2,"b'""""""\nSVG export test\n""""""\nfrom __future__ import division, print_function, absolute_import\nimport pyqtgraph as pg\nimport csv\nimport os\nimport tempfile\n\napp = pg.mkQApp()\n\n\ndef approxeq(a, b):\n    return (a-b) <= ((a + b) * 1e-6)\n\n\ndef test_CSVExporter():\n    tempfilename = tempfile.NamedTemporaryFile(suffix=\'.csv\').name\n    print(""using %s as a temporary file"" % tempfilename)\n    \n    plt = pg.plot()\n    y1 = [1,3,2,3,1,6,9,8,4,2]\n    plt.plot(y=y1, name=\'myPlot\')\n    \n    y2 = [3,4,6,1,2,4,2,3,5,3,5,1,3]\n    x2 = pg.np.linspace(0, 1.0, len(y2))\n    plt.plot(x=x2, y=y2)\n    \n    y3 = [1,5,2,3,4,6,1,2,4,2,3,5,3]\n    x3 = pg.np.linspace(0, 1.0, len(y3)+1)\n    plt.plot(x=x3, y=y3, stepMode=True)\n    \n    ex = pg.exporters.CSVExporter(plt.plotItem)\n    ex.export(fileName=tempfilename)\n\n    r = csv.reader(open(tempfilename, \'r\'))\n    lines = [line for line in r]\n    header = lines.pop(0)\n    assert header == [\'myPlot_x\', \'myPlot_y\', \'x0001\', \'y0001\', \'x0002\', \'y0002\']\n    \n    i = 0\n    for vals in lines:\n        vals = list(map(str.strip, vals))\n        assert (i >= len(y1) and vals[0] == \'\') or approxeq(float(vals[0]), i) \n        assert (i >= len(y1) and vals[1] == \'\') or approxeq(float(vals[1]), y1[i]) \n        \n        assert (i >= len(x2) and vals[2] == \'\') or approxeq(float(vals[2]), x2[i])\n        assert (i >= len(y2) and vals[3] == \'\') or approxeq(float(vals[3]), y2[i])\n        \n        assert (i >= len(x3) and vals[4] == \'\') or approxeq(float(vals[4]), x3[i])\n        assert (i >= len(y3) and vals[5] == \'\') or approxeq(float(vals[5]), y3[i])\n        i += 1\n\n    os.unlink(tempfilename)\n\nif __name__ == \'__main__\':\n    test_CSVExporter()\n'"
src/third_party/pyqtgraph/exporters/tests/test_svg.py,0,"b'""""""\nSVG export test\n""""""\nfrom __future__ import division, print_function, absolute_import\nimport pyqtgraph as pg\nimport tempfile\nimport os\n\n\napp = pg.mkQApp()\n\n\ndef test_plotscene():\n    tempfilename = tempfile.NamedTemporaryFile(suffix=\'.svg\').name\n    print(""using %s as a temporary file"" % tempfilename)\n    pg.setConfigOption(\'foreground\', (0,0,0))\n    w = pg.GraphicsWindow()\n    w.show()        \n    p1 = w.addPlot()\n    p2 = w.addPlot()\n    p1.plot([1,3,2,3,1,6,9,8,4,2,3,5,3], pen={\'color\':\'k\'})\n    p1.setXRange(0,5)\n    p2.plot([1,5,2,3,4,6,1,2,4,2,3,5,3], pen={\'color\':\'k\', \'cosmetic\':False, \'width\': 0.3})\n    app.processEvents()\n    app.processEvents()\n    \n    ex = pg.exporters.SVGExporter(w.scene())\n    ex.export(fileName=tempfilename)\n    # clean up after the test is done\n    os.unlink(tempfilename)\n\ndef test_simple():\n    tempfilename = tempfile.NamedTemporaryFile(suffix=\'.svg\').name\n    print(""using %s as a temporary file"" % tempfilename)\n    scene = pg.QtGui.QGraphicsScene()\n    #rect = pg.QtGui.QGraphicsRectItem(0, 0, 100, 100)\n    #scene.addItem(rect)\n    #rect.setPos(20,20)\n    #rect.translate(50, 50)\n    #rect.rotate(30)\n    #rect.scale(0.5, 0.5)\n    \n    #rect1 = pg.QtGui.QGraphicsRectItem(0, 0, 100, 100)\n    #rect1.setParentItem(rect)\n    #rect1.setFlag(rect1.ItemIgnoresTransformations)\n    #rect1.setPos(20, 20)\n    #rect1.scale(2,2)\n    \n    #el1 = pg.QtGui.QGraphicsEllipseItem(0, 0, 100, 100)\n    #el1.setParentItem(rect1)\n    ##grp = pg.ItemGroup()\n    #grp.setParentItem(rect)\n    #grp.translate(200,0)\n    ##grp.rotate(30)\n    \n    #rect2 = pg.QtGui.QGraphicsRectItem(0, 0, 100, 25)\n    #rect2.setFlag(rect2.ItemClipsChildrenToShape)\n    #rect2.setParentItem(grp)\n    #rect2.setPos(0,25)\n    #rect2.rotate(30)\n    #el = pg.QtGui.QGraphicsEllipseItem(0, 0, 100, 50)\n    #el.translate(10,-5)\n    #el.scale(0.5,2)\n\n    #el.setParentItem(rect2)\n\n    grp2 = pg.ItemGroup()\n    scene.addItem(grp2)\n    grp2.scale(100,100)\n\n    rect3 = pg.QtGui.QGraphicsRectItem(0,0,2,2)\n    rect3.setPen(pg.mkPen(width=1, cosmetic=False))\n    grp2.addItem(rect3)\n\n    ex = pg.exporters.SVGExporter(scene)\n    ex.export(fileName=tempfilename)\n    os.unlink(tempfilename)\n'"
src/third_party/pyqtgraph/flowchart/library/Data.py,2,"b'# -*- coding: utf-8 -*-\nfrom ..Node import Node\nfrom ...Qt import QtGui, QtCore\nimport numpy as np\nfrom .common import *\nfrom ...SRTTransform import SRTTransform\nfrom ...Point import Point\nfrom ...widgets.TreeWidget import TreeWidget\nfrom ...graphicsItems.LinearRegionItem import LinearRegionItem\n\nfrom . import functions\n\nclass ColumnSelectNode(Node):\n    """"""Select named columns from a record array or MetaArray.""""""\n    nodeName = ""ColumnSelect""\n    def __init__(self, name):\n        Node.__init__(self, name, terminals={\'In\': {\'io\': \'in\'}})\n        self.columns = set()\n        self.columnList = QtGui.QListWidget()\n        self.axis = 0\n        self.columnList.itemChanged.connect(self.itemChanged)\n        \n    def process(self, In, display=True):\n        if display:\n            self.updateList(In)\n                \n        out = {}\n        if hasattr(In, \'implements\') and In.implements(\'MetaArray\'):\n            for c in self.columns:\n                out[c] = In[self.axis:c]\n        elif isinstance(In, np.ndarray) and In.dtype.fields is not None:\n            for c in self.columns:\n                out[c] = In[c]\n        else:\n            self.In.setValueAcceptable(False)\n            raise Exception(""Input must be MetaArray or ndarray with named fields"")\n            \n        return out\n        \n    def ctrlWidget(self):\n        return self.columnList\n\n    def updateList(self, data):\n        if hasattr(data, \'implements\') and data.implements(\'MetaArray\'):\n            cols = data.listColumns()\n            for ax in cols:  ## find first axis with columns\n                if len(cols[ax]) > 0:\n                    self.axis = ax\n                    cols = set(cols[ax])\n                    break\n        else:\n            cols = list(data.dtype.fields.keys())\n                \n        rem = set()\n        for c in self.columns:\n            if c not in cols:\n                self.removeTerminal(c)\n                rem.add(c)\n        self.columns -= rem\n                \n        self.columnList.blockSignals(True)\n        self.columnList.clear()\n        for c in cols:\n            item = QtGui.QListWidgetItem(c)\n            item.setFlags(QtCore.Qt.ItemIsEnabled|QtCore.Qt.ItemIsUserCheckable)\n            if c in self.columns:\n                item.setCheckState(QtCore.Qt.Checked)\n            else:\n                item.setCheckState(QtCore.Qt.Unchecked)\n            self.columnList.addItem(item)\n        self.columnList.blockSignals(False)\n        \n\n    def itemChanged(self, item):\n        col = str(item.text())\n        if item.checkState() == QtCore.Qt.Checked:\n            if col not in self.columns:\n                self.columns.add(col)\n                self.addOutput(col)\n        else:\n            if col in self.columns:\n                self.columns.remove(col)\n                self.removeTerminal(col)\n        self.update()\n        \n    def saveState(self):\n        state = Node.saveState(self)\n        state[\'columns\'] = list(self.columns)\n        return state\n    \n    def restoreState(self, state):\n        Node.restoreState(self, state)\n        self.columns = set(state.get(\'columns\', []))\n        for c in self.columns:\n            self.addOutput(c)\n\n\n\nclass RegionSelectNode(CtrlNode):\n    """"""Returns a slice from a 1-D array. Connect the \'widget\' output to a plot to display a region-selection widget.""""""\n    nodeName = ""RegionSelect""\n    uiTemplate = [\n        (\'start\', \'spin\', {\'value\': 0, \'step\': 0.1}),\n        (\'stop\', \'spin\', {\'value\': 0.1, \'step\': 0.1}),\n        (\'display\', \'check\', {\'value\': True}),\n        (\'movable\', \'check\', {\'value\': True}),\n    ]\n    \n    def __init__(self, name):\n        self.items = {}\n        CtrlNode.__init__(self, name, terminals={\n            \'data\': {\'io\': \'in\'},\n            \'selected\': {\'io\': \'out\'},\n            \'region\': {\'io\': \'out\'},\n            \'widget\': {\'io\': \'out\', \'multi\': True}\n        })\n        self.ctrls[\'display\'].toggled.connect(self.displayToggled)\n        self.ctrls[\'movable\'].toggled.connect(self.movableToggled)\n        \n    def displayToggled(self, b):\n        for item in self.items.values():\n            item.setVisible(b)\n            \n    def movableToggled(self, b):\n        for item in self.items.values():\n            item.setMovable(b)\n            \n        \n    def process(self, data=None, display=True):\n        #print ""process..""\n        s = self.stateGroup.state()\n        region = [s[\'start\'], s[\'stop\']]\n        \n        if display:\n            conn = self[\'widget\'].connections()\n            for c in conn:\n                plot = c.node().getPlot()\n                if plot is None:\n                    continue\n                if c in self.items:\n                    item = self.items[c]\n                    item.setRegion(region)\n                    #print ""  set rgn:"", c, region\n                    #item.setXVals(events)\n                else:\n                    item = LinearRegionItem(values=region)\n                    self.items[c] = item\n                    #item.connect(item, QtCore.SIGNAL(\'regionChanged\'), self.rgnChanged)\n                    item.sigRegionChanged.connect(self.rgnChanged)\n                    item.setVisible(s[\'display\'])\n                    item.setMovable(s[\'movable\'])\n                    #print ""  new rgn:"", c, region\n                    #self.items[c].setYRange([0., 0.2], relative=True)\n        \n        if self[\'selected\'].isConnected():\n            if data is None:\n                sliced = None\n            elif (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n                sliced = data[0:s[\'start\']:s[\'stop\']]\n            else:\n                mask = (data[\'time\'] >= s[\'start\']) * (data[\'time\'] < s[\'stop\'])\n            sliced = data[mask]\n        else:\n            sliced = None\n            \n        return {\'selected\': sliced, \'widget\': self.items, \'region\': region}\n        \n        \n    def rgnChanged(self, item):\n        region = item.getRegion()\n        self.stateGroup.setState({\'start\': region[0], \'stop\': region[1]})\n        self.update()\n        \n        \nclass EvalNode(Node):\n    """"""Return the output of a string evaluated/executed by the python interpreter.\n    The string may be either an expression or a python script, and inputs are accessed as the name of the terminal. \n    For expressions, a single value may be evaluated for a single output, or a dict for multiple outputs.\n    For a script, the text will be executed as the body of a function.""""""\n    nodeName = \'PythonEval\'\n    \n    def __init__(self, name):\n        Node.__init__(self, name, \n            terminals = {\n                \'input\': {\'io\': \'in\', \'renamable\': True, \'multiable\': True},\n                \'output\': {\'io\': \'out\', \'renamable\': True, \'multiable\': True},\n            },\n            allowAddInput=True, allowAddOutput=True)\n        \n        self.ui = QtGui.QWidget()\n        self.layout = QtGui.QGridLayout()\n        self.text = QtGui.QTextEdit()\n        self.text.setTabStopWidth(30)\n        self.text.setPlainText(""# Access inputs as args[\'input_name\']\\nreturn {\'output\': None} ## one key per output terminal"")\n        self.layout.addWidget(self.text, 1, 0, 1, 2)\n        self.ui.setLayout(self.layout)\n        \n        self.text.focusOutEvent = self.focusOutEvent\n        self.lastText = None\n        \n    def ctrlWidget(self):\n        return self.ui\n        \n    def setCode(self, code):\n        # unindent code; this allows nicer inline code specification when \n        # calling this method.\n        ind = []\n        lines = code.split(\'\\n\')\n        for line in lines:\n            stripped = line.lstrip()\n            if len(stripped) > 0:\n                ind.append(len(line) - len(stripped))\n        if len(ind) > 0:\n            ind = min(ind)\n            code = \'\\n\'.join([line[ind:] for line in lines])\n        \n        self.text.clear()\n        self.text.insertPlainText(code)\n\n    def code(self):\n        return self.text.toPlainText()\n        \n    def focusOutEvent(self, ev):\n        text = str(self.text.toPlainText())\n        if text != self.lastText:\n            self.lastText = text\n            self.update()\n        return QtGui.QTextEdit.focusOutEvent(self.text, ev)\n        \n    def process(self, display=True, **args):\n        l = locals()\n        l.update(args)\n        ## try eval first, then exec\n        try:  \n            text = str(self.text.toPlainText()).replace(\'\\n\', \' \')\n            output = eval(text, globals(), l)\n        except SyntaxError:\n            fn = ""def fn(**args):\\n""\n            run = ""\\noutput=fn(**args)\\n""\n            text = fn + ""\\n"".join([""    ""+l for l in str(self.text.toPlainText()).split(\'\\n\')]) + run\n            exec(text)\n        except:\n            print(""Error processing node: %s"" % self.name())\n            raise\n        return output\n        \n    def saveState(self):\n        state = Node.saveState(self)\n        state[\'text\'] = str(self.text.toPlainText())\n        #state[\'terminals\'] = self.saveTerminals()\n        return state\n        \n    def restoreState(self, state):\n        Node.restoreState(self, state)\n        self.setCode(state[\'text\'])\n        self.restoreTerminals(state[\'terminals\'])\n        self.update()\n\n        \nclass ColumnJoinNode(Node):\n    """"""Concatenates record arrays and/or adds new columns""""""\n    nodeName = \'ColumnJoin\'\n    \n    def __init__(self, name):\n        Node.__init__(self, name, terminals = {\n            \'output\': {\'io\': \'out\'},\n        })\n        \n        #self.items = []\n        \n        self.ui = QtGui.QWidget()\n        self.layout = QtGui.QGridLayout()\n        self.ui.setLayout(self.layout)\n        \n        self.tree = TreeWidget()\n        self.addInBtn = QtGui.QPushButton(\'+ Input\')\n        self.remInBtn = QtGui.QPushButton(\'- Input\')\n        \n        self.layout.addWidget(self.tree, 0, 0, 1, 2)\n        self.layout.addWidget(self.addInBtn, 1, 0)\n        self.layout.addWidget(self.remInBtn, 1, 1)\n\n        self.addInBtn.clicked.connect(self.addInput)\n        self.remInBtn.clicked.connect(self.remInput)\n        self.tree.sigItemMoved.connect(self.update)\n        \n    def ctrlWidget(self):\n        return self.ui\n        \n    def addInput(self):\n        #print ""ColumnJoinNode.addInput called.""\n        term = Node.addInput(self, \'input\', renamable=True, removable=True, multiable=True)\n        #print ""Node.addInput returned. term:"", term\n        item = QtGui.QTreeWidgetItem([term.name()])\n        item.term = term\n        term.joinItem = item\n        #self.items.append((term, item))\n        self.tree.addTopLevelItem(item)\n\n    def remInput(self):\n        sel = self.tree.currentItem()\n        term = sel.term\n        term.joinItem = None\n        sel.term = None\n        self.tree.removeTopLevelItem(sel)\n        self.removeTerminal(term)\n        self.update()\n\n    def process(self, display=True, **args):\n        order = self.order()\n        vals = []\n        for name in order:\n            if name not in args:\n                continue\n            val = args[name]\n            if isinstance(val, np.ndarray) and len(val.dtype) > 0:\n                vals.append(val)\n            else:\n                vals.append((name, None, val))\n        return {\'output\': functions.concatenateColumns(vals)}\n\n    def order(self):\n        return [str(self.tree.topLevelItem(i).text(0)) for i in range(self.tree.topLevelItemCount())]\n\n    def saveState(self):\n        state = Node.saveState(self)\n        state[\'order\'] = self.order()\n        return state\n        \n    def restoreState(self, state):\n        Node.restoreState(self, state)\n        inputs = self.inputs()\n\n        ## Node.restoreState should have created all of the terminals we need\n        ## However: to maintain support for some older flowchart files, we need\n        ## to manually add any terminals that were not taken care of.\n        for name in [n for n in state[\'order\'] if n not in inputs]:\n            Node.addInput(self, name, renamable=True, removable=True, multiable=True)\n        inputs = self.inputs()\n\n        order = [name for name in state[\'order\'] if name in inputs]\n        for name in inputs:\n            if name not in order:\n                order.append(name)\n        \n        self.tree.clear()\n        for name in order:\n            term = self[name]\n            item = QtGui.QTreeWidgetItem([name])\n            item.term = term\n            term.joinItem = item\n            #self.items.append((term, item))\n            self.tree.addTopLevelItem(item)\n\n    def terminalRenamed(self, term, oldName):\n        Node.terminalRenamed(self, term, oldName)\n        item = term.joinItem\n        item.setText(0, term.name())\n        self.update()\n        \n        \nclass Mean(CtrlNode):\n    """"""Calculate the mean of an array across an axis.\n    """"""\n    nodeName = \'Mean\'\n    uiTemplate = [\n        (\'axis\', \'intSpin\', {\'value\': 0, \'min\': -1, \'max\': 1000000}),\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        ax = None if s[\'axis\'] == -1 else s[\'axis\']\n        return data.mean(axis=ax)\n\n\nclass Max(CtrlNode):\n    """"""Calculate the maximum of an array across an axis.\n    """"""\n    nodeName = \'Max\'\n    uiTemplate = [\n        (\'axis\', \'intSpin\', {\'value\': 0, \'min\': -1, \'max\': 1000000}),\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        ax = None if s[\'axis\'] == -1 else s[\'axis\']\n        return data.max(axis=ax)\n\n\nclass Min(CtrlNode):\n    """"""Calculate the minimum of an array across an axis.\n    """"""\n    nodeName = \'Min\'\n    uiTemplate = [\n        (\'axis\', \'intSpin\', {\'value\': 0, \'min\': -1, \'max\': 1000000}),\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        ax = None if s[\'axis\'] == -1 else s[\'axis\']\n        return data.min(axis=ax)\n\n\nclass Stdev(CtrlNode):\n    """"""Calculate the standard deviation of an array across an axis.\n    """"""\n    nodeName = \'Stdev\'\n    uiTemplate = [\n        (\'axis\', \'intSpin\', {\'value\': -0, \'min\': -1, \'max\': 1000000}),\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        ax = None if s[\'axis\'] == -1 else s[\'axis\']\n        return data.std(axis=ax)\n\n\nclass Index(CtrlNode):\n    """"""Select an index from an array axis.\n    """"""\n    nodeName = \'Index\'\n    uiTemplate = [\n        (\'axis\', \'intSpin\', {\'value\': 0, \'min\': 0, \'max\': 1000000}),\n        (\'index\', \'intSpin\', {\'value\': 0, \'min\': 0, \'max\': 1000000}),\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        ax = s[\'axis\']\n        ind = s[\'index\']\n        if ax == 0:\n            # allow support for non-ndarray sequence types\n            return data[ind]\n        else:\n            return data.take(ind, axis=ax)\n        \n\nclass Slice(CtrlNode):\n    """"""Select a slice from an array axis.\n    """"""\n    nodeName = \'Slice\'\n    uiTemplate = [\n        (\'axis\', \'intSpin\', {\'value\': 0, \'min\': 0, \'max\': 1e6}),\n        (\'start\', \'intSpin\', {\'value\': 0, \'min\': -1e6, \'max\': 1e6}),\n        (\'stop\', \'intSpin\', {\'value\': -1, \'min\': -1e6, \'max\': 1e6}),\n        (\'step\', \'intSpin\', {\'value\': 1, \'min\': -1e6, \'max\': 1e6}),\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        ax = s[\'axis\']\n        start = s[\'start\']\n        stop = s[\'stop\']\n        step = s[\'step\']\n        if ax == 0:\n            # allow support for non-ndarray sequence types\n            return data[start:stop:step]\n        else:\n            sl = [slice(None) for i in range(data.ndim)]\n            sl[ax] = slice(start, stop, step)\n            return data[sl]\n        \n\nclass AsType(CtrlNode):\n    """"""Convert an array to a different dtype.\n    """"""\n    nodeName = \'AsType\'\n    uiTemplate = [\n        (\'dtype\', \'combo\', {\'values\': [\'float\', \'int\', \'float32\', \'float64\', \'float128\', \'int8\', \'int16\', \'int32\', \'int64\', \'uint8\', \'uint16\', \'uint32\', \'uint64\'], \'index\': 0}),\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        return data.astype(s[\'dtype\'])\n\n'"
src/third_party/pyqtgraph/flowchart/library/Display.py,1,"b'# -*- coding: utf-8 -*-\nfrom ..Node import Node\nimport weakref\nfrom ...Qt import QtCore, QtGui\nfrom ...graphicsItems.ScatterPlotItem import ScatterPlotItem\nfrom ...graphicsItems.PlotCurveItem import PlotCurveItem\nfrom ... import PlotDataItem, ComboBox\n\nfrom .common import *\nimport numpy as np\n\nclass PlotWidgetNode(Node):\n    """"""Connection to PlotWidget. Will plot arrays, metaarrays, and display event lists.""""""\n    nodeName = \'PlotWidget\'\n    sigPlotChanged = QtCore.Signal(object)\n    \n    def __init__(self, name):\n        Node.__init__(self, name, terminals={\'In\': {\'io\': \'in\', \'multi\': True}})\n        self.plot = None  # currently selected plot \n        self.plots = {}   # list of available plots user may select from\n        self.ui = None \n        self.items = {}\n        \n    def disconnected(self, localTerm, remoteTerm):\n        if localTerm is self[\'In\'] and remoteTerm in self.items:\n            self.plot.removeItem(self.items[remoteTerm])\n            del self.items[remoteTerm]\n        \n    def setPlot(self, plot):\n        #print ""======set plot""\n        if plot == self.plot:\n            return\n        \n        # clear data from previous plot\n        if self.plot is not None:\n            for vid in list(self.items.keys()):\n                self.plot.removeItem(self.items[vid])\n                del self.items[vid]\n\n        self.plot = plot\n        self.updateUi()\n        self.update()\n        self.sigPlotChanged.emit(self)\n        \n    def getPlot(self):\n        return self.plot\n        \n    def process(self, In, display=True):\n        if display and self.plot is not None:\n            items = set()\n            # Add all new input items to selected plot\n            for name, vals in In.items():\n                if vals is None:\n                    continue\n                if type(vals) is not list:\n                    vals = [vals]\n                    \n                for val in vals:\n                    vid = id(val)\n                    if vid in self.items and self.items[vid].scene() is self.plot.scene():\n                        # Item is already added to the correct scene\n                        #   possible bug: what if two plots occupy the same scene? (should\n                        #   rarely be a problem because items are removed from a plot before\n                        #   switching).\n                        items.add(vid)\n                    else:\n                        # Add the item to the plot, or generate a new item if needed.\n                        if isinstance(val, QtGui.QGraphicsItem):\n                            self.plot.addItem(val)\n                            item = val\n                        else:\n                            item = self.plot.plot(val)\n                        self.items[vid] = item\n                        items.add(vid)\n                        \n            # Any left-over items that did not appear in the input must be removed\n            for vid in list(self.items.keys()):\n                if vid not in items:\n                    self.plot.removeItem(self.items[vid])\n                    del self.items[vid]\n            \n    def processBypassed(self, args):\n        if self.plot is None:\n            return\n        for item in list(self.items.values()):\n            self.plot.removeItem(item)\n        self.items = {}\n        \n    def ctrlWidget(self):\n        if self.ui is None:\n            self.ui = ComboBox()\n            self.ui.currentIndexChanged.connect(self.plotSelected)\n            self.updateUi()\n        return self.ui\n    \n    def plotSelected(self, index):\n        self.setPlot(self.ui.value())\n    \n    def setPlotList(self, plots):\n        """"""\n        Specify the set of plots (PlotWidget or PlotItem) that the user may\n        select from.\n        \n        *plots* must be a dictionary of {name: plot} pairs.\n        """"""\n        self.plots = plots\n        self.updateUi()\n    \n    def updateUi(self):\n        # sets list and automatically preserves previous selection\n        self.ui.setItems(self.plots)\n        try:\n            self.ui.setValue(self.plot)\n        except ValueError:\n            pass\n        \n\nclass CanvasNode(Node):\n    """"""Connection to a Canvas widget.""""""\n    nodeName = \'CanvasWidget\'\n    \n    def __init__(self, name):\n        Node.__init__(self, name, terminals={\'In\': {\'io\': \'in\', \'multi\': True}})\n        self.canvas = None\n        self.items = {}\n        \n    def disconnected(self, localTerm, remoteTerm):\n        if localTerm is self.In and remoteTerm in self.items:\n            self.canvas.removeItem(self.items[remoteTerm])\n            del self.items[remoteTerm]\n        \n    def setCanvas(self, canvas):\n        self.canvas = canvas\n        \n    def getCanvas(self):\n        return self.canvas\n        \n    def process(self, In, display=True):\n        if display:\n            items = set()\n            for name, vals in In.items():\n                if vals is None:\n                    continue\n                if type(vals) is not list:\n                    vals = [vals]\n                \n                for val in vals:\n                    vid = id(val)\n                    if vid in self.items:\n                        items.add(vid)\n                    else:\n                        self.canvas.addItem(val)\n                        item = val\n                        self.items[vid] = item\n                        items.add(vid)\n            for vid in list(self.items.keys()):\n                if vid not in items:\n                    #print ""remove"", self.items[vid]\n                    self.canvas.removeItem(self.items[vid])\n                    del self.items[vid]\n\n\nclass PlotCurve(CtrlNode):\n    """"""Generates a plot curve from x/y data""""""\n    nodeName = \'PlotCurve\'\n    uiTemplate = [\n        (\'color\', \'color\'),\n    ]\n    \n    def __init__(self, name):\n        CtrlNode.__init__(self, name, terminals={\n            \'x\': {\'io\': \'in\'},\n            \'y\': {\'io\': \'in\'},\n            \'plot\': {\'io\': \'out\'}\n        })\n        self.item = PlotDataItem()\n    \n    def process(self, x, y, display=True):\n        #print ""scatterplot process""\n        if not display:\n            return {\'plot\': None}\n        \n        self.item.setData(x, y, pen=self.ctrls[\'color\'].color())\n        return {\'plot\': self.item}\n        \n        \n\n\nclass ScatterPlot(CtrlNode):\n    """"""Generates a scatter plot from a record array or nested dicts""""""\n    nodeName = \'ScatterPlot\'\n    uiTemplate = [\n        (\'x\', \'combo\', {\'values\': [], \'index\': 0}),\n        (\'y\', \'combo\', {\'values\': [], \'index\': 0}),\n        (\'sizeEnabled\', \'check\', {\'value\': False}),\n        (\'size\', \'combo\', {\'values\': [], \'index\': 0}),\n        (\'absoluteSize\', \'check\', {\'value\': False}),\n        (\'colorEnabled\', \'check\', {\'value\': False}),\n        (\'color\', \'colormap\', {}),\n        (\'borderEnabled\', \'check\', {\'value\': False}),\n        (\'border\', \'colormap\', {}),\n    ]\n    \n    def __init__(self, name):\n        CtrlNode.__init__(self, name, terminals={\n            \'input\': {\'io\': \'in\'},\n            \'plot\': {\'io\': \'out\'}\n        })\n        self.item = ScatterPlotItem()\n        self.keys = []\n        \n        #self.ui = QtGui.QWidget()\n        #self.layout = QtGui.QGridLayout()\n        #self.ui.setLayout(self.layout)\n        \n        #self.xCombo = QtGui.QComboBox()\n        #self.yCombo = QtGui.QComboBox()\n        \n        \n    \n    def process(self, input, display=True):\n        #print ""scatterplot process""\n        if not display:\n            return {\'plot\': None}\n            \n        self.updateKeys(input[0])\n        \n        x = str(self.ctrls[\'x\'].currentText())\n        y = str(self.ctrls[\'y\'].currentText())\n        size = str(self.ctrls[\'size\'].currentText())\n        pen = QtGui.QPen(QtGui.QColor(0,0,0,0))\n        points = []\n        for i in input:\n            pt = {\'pos\': (i[x], i[y])}\n            if self.ctrls[\'sizeEnabled\'].isChecked():\n                pt[\'size\'] = i[size]\n            if self.ctrls[\'borderEnabled\'].isChecked():\n                pt[\'pen\'] = QtGui.QPen(self.ctrls[\'border\'].getColor(i))\n            else:\n                pt[\'pen\'] = pen\n            if self.ctrls[\'colorEnabled\'].isChecked():\n                pt[\'brush\'] = QtGui.QBrush(self.ctrls[\'color\'].getColor(i))\n            points.append(pt)\n        self.item.setPxMode(not self.ctrls[\'absoluteSize\'].isChecked())\n            \n        self.item.setPoints(points)\n        \n        return {\'plot\': self.item}\n        \n        \n\n    def updateKeys(self, data):\n        if isinstance(data, dict):\n            keys = list(data.keys())\n        elif isinstance(data, list) or isinstance(data, tuple):\n            keys = data\n        elif isinstance(data, np.ndarray) or isinstance(data, np.void):\n            keys = data.dtype.names\n        else:\n            print(""Unknown data type:"", type(data), data)\n            return\n            \n        for c in self.ctrls.values():\n            c.blockSignals(True)\n        for c in [self.ctrls[\'x\'], self.ctrls[\'y\'], self.ctrls[\'size\']]:\n            cur = str(c.currentText())\n            c.clear()\n            for k in keys:\n                c.addItem(k)\n                if k == cur:\n                    c.setCurrentIndex(c.count()-1)\n        for c in [self.ctrls[\'color\'], self.ctrls[\'border\']]:\n            c.setArgList(keys)\n        for c in self.ctrls.values():\n            c.blockSignals(False)\n                \n        self.keys = keys\n        \n\n    def saveState(self):\n        state = CtrlNode.saveState(self)\n        return {\'keys\': self.keys, \'ctrls\': state}\n        \n    def restoreState(self, state):\n        self.updateKeys(state[\'keys\'])\n        CtrlNode.restoreState(self, state[\'ctrls\'])\n        \n#class ImageItem(Node):\n    #""""""Creates an ImageItem for display in a canvas from a file handle.""""""\n    #nodeName = \'Image\'\n    \n    #def __init__(self, name):\n        #Node.__init__(self, name, terminals={\n            #\'file\': {\'io\': \'in\'},\n            #\'image\': {\'io\': \'out\'}\n        #})\n        #self.imageItem = graphicsItems.ImageItem()\n        #self.handle = None\n        \n    #def process(self, file, display=True):\n        #if not display:\n            #return {\'image\': None}\n            \n        #if file != self.handle:\n            #self.handle = file\n            #data = file.read()\n            #self.imageItem.updateImage(data)\n            \n        #pos = file.\n        \n        \n        \n'"
src/third_party/pyqtgraph/flowchart/library/Filters.py,10,"b'# -*- coding: utf-8 -*-\nimport numpy as np\nfrom ...Qt import QtCore, QtGui\nfrom ..Node import Node\nfrom . import functions\nfrom ... import functions as pgfn\nfrom .common import *\nfrom ...python2_3 import xrange\nfrom ... import PolyLineROI\nfrom ... import Point\nfrom ... import metaarray as metaarray\n\n\nclass Downsample(CtrlNode):\n    """"""Downsample by averaging samples together.""""""\n    nodeName = \'Downsample\'\n    uiTemplate = [\n        (\'n\', \'intSpin\', {\'min\': 1, \'max\': 1000000})\n    ]\n    \n    def processData(self, data):\n        return functions.downsample(data, self.ctrls[\'n\'].value(), axis=0)\n\n\nclass Subsample(CtrlNode):\n    """"""Downsample by selecting every Nth sample.""""""\n    nodeName = \'Subsample\'\n    uiTemplate = [\n        (\'n\', \'intSpin\', {\'min\': 1, \'max\': 1000000})\n    ]\n    \n    def processData(self, data):\n        return data[::self.ctrls[\'n\'].value()]\n\n\nclass Bessel(CtrlNode):\n    """"""Bessel filter. Input data must have time values.""""""\n    nodeName = \'BesselFilter\'\n    uiTemplate = [\n        (\'band\', \'combo\', {\'values\': [\'lowpass\', \'highpass\'], \'index\': 0}),\n        (\'cutoff\', \'spin\', {\'value\': 1000., \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'Hz\', \'siPrefix\': True}),\n        (\'order\', \'intSpin\', {\'value\': 4, \'min\': 1, \'max\': 16}),\n        (\'bidir\', \'check\', {\'checked\': True})\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        if s[\'band\'] == \'lowpass\':\n            mode = \'low\'\n        else:\n            mode = \'high\'\n        return functions.besselFilter(data, bidir=s[\'bidir\'], btype=mode, cutoff=s[\'cutoff\'], order=s[\'order\'])\n\n\nclass Butterworth(CtrlNode):\n    """"""Butterworth filter""""""\n    nodeName = \'ButterworthFilter\'\n    uiTemplate = [\n        (\'band\', \'combo\', {\'values\': [\'lowpass\', \'highpass\'], \'index\': 0}),\n        (\'wPass\', \'spin\', {\'value\': 1000., \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'Hz\', \'siPrefix\': True}),\n        (\'wStop\', \'spin\', {\'value\': 2000., \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'Hz\', \'siPrefix\': True}),\n        (\'gPass\', \'spin\', {\'value\': 2.0, \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'dB\', \'siPrefix\': True}),\n        (\'gStop\', \'spin\', {\'value\': 20.0, \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'dB\', \'siPrefix\': True}),\n        (\'bidir\', \'check\', {\'checked\': True})\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        if s[\'band\'] == \'lowpass\':\n            mode = \'low\'\n        else:\n            mode = \'high\'\n        ret = functions.butterworthFilter(data, bidir=s[\'bidir\'], btype=mode, wPass=s[\'wPass\'], wStop=s[\'wStop\'], gPass=s[\'gPass\'], gStop=s[\'gStop\'])\n        return ret\n\n        \nclass ButterworthNotch(CtrlNode):\n    """"""Butterworth notch filter""""""\n    nodeName = \'ButterworthNotchFilter\'\n    uiTemplate = [\n        (\'low_wPass\', \'spin\', {\'value\': 1000., \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'Hz\', \'siPrefix\': True}),\n        (\'low_wStop\', \'spin\', {\'value\': 2000., \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'Hz\', \'siPrefix\': True}),\n        (\'low_gPass\', \'spin\', {\'value\': 2.0, \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'dB\', \'siPrefix\': True}),\n        (\'low_gStop\', \'spin\', {\'value\': 20.0, \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'dB\', \'siPrefix\': True}),\n        (\'high_wPass\', \'spin\', {\'value\': 3000., \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'Hz\', \'siPrefix\': True}),\n        (\'high_wStop\', \'spin\', {\'value\': 4000., \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'Hz\', \'siPrefix\': True}),\n        (\'high_gPass\', \'spin\', {\'value\': 2.0, \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'dB\', \'siPrefix\': True}),\n        (\'high_gStop\', \'spin\', {\'value\': 20.0, \'step\': 1, \'dec\': True, \'bounds\': [0.0, None], \'suffix\': \'dB\', \'siPrefix\': True}),\n        (\'bidir\', \'check\', {\'checked\': True})\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        \n        low = functions.butterworthFilter(data, bidir=s[\'bidir\'], btype=\'low\', wPass=s[\'low_wPass\'], wStop=s[\'low_wStop\'], gPass=s[\'low_gPass\'], gStop=s[\'low_gStop\'])\n        high = functions.butterworthFilter(data, bidir=s[\'bidir\'], btype=\'high\', wPass=s[\'high_wPass\'], wStop=s[\'high_wStop\'], gPass=s[\'high_gPass\'], gStop=s[\'high_gStop\'])\n        return low + high\n    \n\nclass Mean(CtrlNode):\n    """"""Filters data by taking the mean of a sliding window""""""\n    nodeName = \'MeanFilter\'\n    uiTemplate = [\n        (\'n\', \'intSpin\', {\'min\': 1, \'max\': 1000000})\n    ]\n    \n    @metaArrayWrapper\n    def processData(self, data):\n        n = self.ctrls[\'n\'].value()\n        return functions.rollingSum(data, n) / n\n\n\nclass Median(CtrlNode):\n    """"""Filters data by taking the median of a sliding window""""""\n    nodeName = \'MedianFilter\'\n    uiTemplate = [\n        (\'n\', \'intSpin\', {\'min\': 1, \'max\': 1000000})\n    ]\n    \n    @metaArrayWrapper\n    def processData(self, data):\n        try:\n            import scipy.ndimage\n        except ImportError:\n            raise Exception(""MedianFilter node requires the package scipy.ndimage."")\n        return scipy.ndimage.median_filter(data, self.ctrls[\'n\'].value())\n\nclass Mode(CtrlNode):\n    """"""Filters data by taking the mode (histogram-based) of a sliding window""""""\n    nodeName = \'ModeFilter\'\n    uiTemplate = [\n        (\'window\', \'intSpin\', {\'value\': 500, \'min\': 1, \'max\': 1000000}),\n    ]\n    \n    @metaArrayWrapper\n    def processData(self, data):\n        return functions.modeFilter(data, self.ctrls[\'window\'].value())\n\n\nclass Denoise(CtrlNode):\n    """"""Removes anomalous spikes from data, replacing with nearby values""""""\n    nodeName = \'DenoiseFilter\'\n    uiTemplate = [\n        (\'radius\', \'intSpin\', {\'value\': 2, \'min\': 0, \'max\': 1000000}),\n        (\'threshold\', \'doubleSpin\', {\'value\': 4.0, \'min\': 0, \'max\': 1000})\n    ]\n    \n    def processData(self, data):\n        #print ""DENOISE""\n        s = self.stateGroup.state()\n        return functions.denoise(data, **s)\n\n\nclass Gaussian(CtrlNode):\n    """"""Gaussian smoothing filter.""""""\n    nodeName = \'GaussianFilter\'\n    uiTemplate = [\n        (\'sigma\', \'doubleSpin\', {\'min\': 0, \'max\': 1000000})\n    ]\n    \n    @metaArrayWrapper\n    def processData(self, data):\n        sigma = self.ctrls[\'sigma\'].value()\n        try:\n            import scipy.ndimage\n            return scipy.ndimage.gaussian_filter(data, sigma)\n        except ImportError:\n            return pgfn.gaussianFilter(data, sigma)\n\n\nclass Derivative(CtrlNode):\n    """"""Returns the pointwise derivative of the input""""""\n    nodeName = \'DerivativeFilter\'\n    \n    def processData(self, data):\n        if hasattr(data, \'implements\') and data.implements(\'MetaArray\'):\n            info = data.infoCopy()\n            if \'values\' in info[0]:\n                info[0][\'values\'] = info[0][\'values\'][:-1]\n            return metaarray.MetaArray(data[1:] - data[:-1], info=info)\n        else:\n            return data[1:] - data[:-1]\n\n\nclass Integral(CtrlNode):\n    """"""Returns the pointwise integral of the input""""""\n    nodeName = \'IntegralFilter\'\n    \n    @metaArrayWrapper\n    def processData(self, data):\n        data[1:] += data[:-1]\n        return data\n\n\nclass Detrend(CtrlNode):\n    """"""Removes linear trend from the data""""""\n    nodeName = \'DetrendFilter\'\n    \n    @metaArrayWrapper\n    def processData(self, data):\n        try:\n            from scipy.signal import detrend\n        except ImportError:\n            raise Exception(""DetrendFilter node requires the package scipy.signal."")\n        return detrend(data)\n\nclass RemoveBaseline(PlottingCtrlNode):\n    """"""Remove an arbitrary, graphically defined baseline from the data.""""""\n    nodeName = \'RemoveBaseline\'\n    \n    def __init__(self, name):\n        ## define inputs and outputs (one output needs to be a plot)\n        PlottingCtrlNode.__init__(self, name)\n        self.line = PolyLineROI([[0,0],[1,0]])\n        self.line.sigRegionChanged.connect(self.changed)\n        \n        ## create a PolyLineROI, add it to a plot -- actually, I think we want to do this after the node is connected to a plot (look at EventDetection.ThresholdEvents node for ideas), and possible after there is data. We will need to update the end positions of the line each time the input data changes\n        #self.line = None ## will become a PolyLineROI\n        \n    def connectToPlot(self, node):\n        """"""Define what happens when the node is connected to a plot""""""\n\n        if node.plot is None:\n            return\n        node.getPlot().addItem(self.line)\n       \n    def disconnectFromPlot(self, plot):\n        """"""Define what happens when the node is disconnected from a plot""""""\n        plot.removeItem(self.line)    \n    \n    def processData(self, data):\n        ## get array of baseline (from PolyLineROI)\n        h0 = self.line.getHandles()[0]\n        h1 = self.line.getHandles()[-1]\n        \n        timeVals = data.xvals(0)\n        h0.setPos(timeVals[0], h0.pos()[1])\n        h1.setPos(timeVals[-1], h1.pos()[1])      \n        \n        pts = self.line.listPoints() ## lists line handles in same coordinates as data\n        pts, indices = self.adjustXPositions(pts, timeVals) ## maxe sure x positions match x positions of data points\n        \n        ## construct an array that represents the baseline\n        arr = np.zeros(len(data), dtype=float)\n        n = 1\n        arr[0] = pts[0].y()\n        for i in range(len(pts)-1):\n            x1 = pts[i].x()\n            x2 = pts[i+1].x()\n            y1 = pts[i].y()\n            y2 = pts[i+1].y()\n            m = (y2-y1)/(x2-x1)\n            b = y1\n            \n            times = timeVals[(timeVals > x1)*(timeVals <= x2)]\n            arr[n:n+len(times)] = (m*(times-times[0]))+b\n            n += len(times)\n                \n        return data - arr ## subract baseline from data\n        \n    def adjustXPositions(self, pts, data):\n        """"""Return a list of Point() where the x position is set to the nearest x value in *data* for each point in *pts*.""""""\n        points = []\n        timeIndices = []\n        for p in pts:\n            x = np.argwhere(abs(data - p.x()) == abs(data - p.x()).min())\n            points.append(Point(data[x], p.y()))\n            timeIndices.append(x)\n            \n        return points, timeIndices\n\n\n\nclass AdaptiveDetrend(CtrlNode):\n    """"""Removes baseline from data, ignoring anomalous events""""""\n    nodeName = \'AdaptiveDetrend\'\n    uiTemplate = [\n        (\'threshold\', \'doubleSpin\', {\'value\': 3.0, \'min\': 0, \'max\': 1000000})\n    ]\n    \n    def processData(self, data):\n        return functions.adaptiveDetrend(data, threshold=self.ctrls[\'threshold\'].value())\n\nclass HistogramDetrend(CtrlNode):\n    """"""Removes baseline from data by computing mode (from histogram) of beginning and end of data.""""""\n    nodeName = \'HistogramDetrend\'\n    uiTemplate = [\n        (\'windowSize\', \'intSpin\', {\'value\': 500, \'min\': 10, \'max\': 1000000, \'suffix\': \'pts\'}),\n        (\'numBins\', \'intSpin\', {\'value\': 50, \'min\': 3, \'max\': 1000000}),\n        (\'offsetOnly\', \'check\', {\'checked\': False}),\n    ]\n    \n    def processData(self, data):\n        s = self.stateGroup.state()\n        #ws = self.ctrls[\'windowSize\'].value()\n        #bn = self.ctrls[\'numBins\'].value()\n        #offset = self.ctrls[\'offsetOnly\'].checked()\n        return functions.histogramDetrend(data, window=s[\'windowSize\'], bins=s[\'numBins\'], offsetOnly=s[\'offsetOnly\'])\n\n\n    \nclass RemovePeriodic(CtrlNode):\n    nodeName = \'RemovePeriodic\'\n    uiTemplate = [\n        #(\'windowSize\', \'intSpin\', {\'value\': 500, \'min\': 10, \'max\': 1000000, \'suffix\': \'pts\'}),\n        #(\'numBins\', \'intSpin\', {\'value\': 50, \'min\': 3, \'max\': 1000000})\n        (\'f0\', \'spin\', {\'value\': 60, \'suffix\': \'Hz\', \'siPrefix\': True, \'min\': 0, \'max\': None}),\n        (\'harmonics\', \'intSpin\', {\'value\': 30, \'min\': 0}),\n        (\'samples\', \'intSpin\', {\'value\': 1, \'min\': 1}),\n    ]\n\n    def processData(self, data):\n        times = data.xvals(\'Time\')\n        dt = times[1]-times[0]\n        \n        data1 = data.asarray()\n        ft = np.fft.fft(data1)\n        \n        ## determine frequencies in fft data\n        df = 1.0 / (len(data1) * dt)\n        freqs = np.linspace(0.0, (len(ft)-1) * df, len(ft))\n        \n        ## flatten spikes at f0 and harmonics\n        f0 = self.ctrls[\'f0\'].value()\n        for i in xrange(1, self.ctrls[\'harmonics\'].value()+2):\n            f = f0 * i # target frequency\n            \n            ## determine index range to check for this frequency\n            ind1 = int(np.floor(f / df))\n            ind2 = int(np.ceil(f / df)) + (self.ctrls[\'samples\'].value()-1)\n            if ind1 > len(ft)/2.:\n                break\n            mag = (abs(ft[ind1-1]) + abs(ft[ind2+1])) * 0.5\n            for j in range(ind1, ind2+1):\n                phase = np.angle(ft[j])   ## Must preserve the phase of each point, otherwise any transients in the trace might lead to large artifacts.\n                re = mag * np.cos(phase)\n                im = mag * np.sin(phase)\n                ft[j] = re + im*1j\n                ft[len(ft)-j] = re - im*1j\n                \n        data2 = np.fft.ifft(ft).real\n        \n        ma = metaarray.MetaArray(data2, info=data.infoCopy())\n        return ma\n        \n        \n        \n'"
src/third_party/pyqtgraph/flowchart/library/Operators.py,0,"b'# -*- coding: utf-8 -*-\nfrom ..Node import Node\nfrom .common import CtrlNode\n\n\nclass UniOpNode(Node):\n    """"""Generic node for performing any operation like Out = In.fn()""""""\n    def __init__(self, name, fn):\n        self.fn = fn\n        Node.__init__(self, name, terminals={\n            \'In\': {\'io\': \'in\'},\n            \'Out\': {\'io\': \'out\', \'bypass\': \'In\'}\n        })\n        \n    def process(self, **args):\n        return {\'Out\': getattr(args[\'In\'], self.fn)()}\n\nclass BinOpNode(CtrlNode):\n    """"""Generic node for performing any operation like A.fn(B)""""""\n\n    _dtypes = [\n        \'float64\', \'float32\', \'float16\',\n        \'int64\', \'int32\', \'int16\', \'int8\',\n        \'uint64\', \'uint32\', \'uint16\', \'uint8\'\n    ]\n\n    uiTemplate = [\n        (\'outputType\', \'combo\', {\'values\': [\'no change\', \'input A\', \'input B\'] + _dtypes , \'index\': 0})\n    ]\n\n    def __init__(self, name, fn):\n        self.fn = fn\n        CtrlNode.__init__(self, name, terminals={\n            \'A\': {\'io\': \'in\'},\n            \'B\': {\'io\': \'in\'},\n            \'Out\': {\'io\': \'out\', \'bypass\': \'A\'}\n        })\n        \n    def process(self, **args):\n        if isinstance(self.fn, tuple):\n            for name in self.fn:\n                try:\n                    fn = getattr(args[\'A\'], name)\n                    break\n                except AttributeError:\n                    pass\n        else:\n            fn = getattr(args[\'A\'], self.fn)\n        out = fn(args[\'B\'])\n        if out is NotImplemented:\n            raise Exception(""Operation %s not implemented between %s and %s"" % (fn, str(type(args[\'A\'])), str(type(args[\'B\']))))\n        \n        # Coerce dtype if requested\n        typ = self.stateGroup.state()[\'outputType\']\n        if typ == \'no change\':\n            pass\n        elif typ == \'input A\':\n            out = out.astype(args[\'A\'].dtype)\n        elif typ == \'input B\':\n            out = out.astype(args[\'B\'].dtype)\n        else:\n            out = out.astype(typ)\n            \n        #print ""     "", fn, out\n        return {\'Out\': out}\n\n\nclass AbsNode(UniOpNode):\n    """"""Returns abs(Inp). Does not check input types.""""""\n    nodeName = \'Abs\'\n    def __init__(self, name):\n        UniOpNode.__init__(self, name, \'__abs__\')\n\nclass AddNode(BinOpNode):\n    """"""Returns A + B. Does not check input types.""""""\n    nodeName = \'Add\'\n    def __init__(self, name):\n        BinOpNode.__init__(self, name, \'__add__\')\n\nclass SubtractNode(BinOpNode):\n    """"""Returns A - B. Does not check input types.""""""\n    nodeName = \'Subtract\'\n    def __init__(self, name):\n        BinOpNode.__init__(self, name, \'__sub__\')\n\nclass MultiplyNode(BinOpNode):\n    """"""Returns A * B. Does not check input types.""""""\n    nodeName = \'Multiply\'\n    def __init__(self, name):\n        BinOpNode.__init__(self, name, \'__mul__\')\n\nclass DivideNode(BinOpNode):\n    """"""Returns A / B. Does not check input types.""""""\n    nodeName = \'Divide\'\n    def __init__(self, name):\n        # try truediv first, followed by div\n        BinOpNode.__init__(self, name, (\'__truediv__\', \'__div__\'))\n        \nclass FloorDivideNode(BinOpNode):\n    """"""Returns A // B. Does not check input types.""""""\n    nodeName = \'FloorDivide\'\n    def __init__(self, name):\n        BinOpNode.__init__(self, name, \'__floordiv__\')\n        \n\n'"
src/third_party/pyqtgraph/flowchart/library/__init__.py,0,"b""# -*- coding: utf-8 -*-\nfrom ...pgcollections import OrderedDict\nimport os, types\nfrom ...debug import printExc\nfrom ..NodeLibrary import NodeLibrary, isNodeClass\nfrom ... import reload as reload\n\n\n# Build default library\nLIBRARY = NodeLibrary()\n\n# For backward compatibility, expose the default library's properties here:\nNODE_LIST = LIBRARY.nodeList\nNODE_TREE = LIBRARY.nodeTree\nregisterNodeType = LIBRARY.addNodeType\ngetNodeTree = LIBRARY.getNodeTree\ngetNodeType = LIBRARY.getNodeType\n\n# Add all nodes to the default library\nfrom . import Data, Display, Filters, Operators\nfor mod in [Data, Display, Filters, Operators]:\n    nodes = [getattr(mod, name) for name in dir(mod) if isNodeClass(getattr(mod, name))]\n    for node in nodes:\n        LIBRARY.addNodeType(node, [(mod.__name__.split('.')[-1],)])\n    \n\n\n\n"""
src/third_party/pyqtgraph/flowchart/library/common.py,1,"b'# -*- coding: utf-8 -*-\nfrom ...Qt import QtCore, QtGui\nfrom ...widgets.SpinBox import SpinBox\n#from ...SignalProxy import SignalProxy\nfrom ...WidgetGroup import WidgetGroup\n#from ColorMapper import ColorMapper\nfrom ..Node import Node\nimport numpy as np\nfrom ...widgets.ColorButton import ColorButton\ntry:\n    import metaarray\n    HAVE_METAARRAY = True\nexcept:\n    HAVE_METAARRAY = False\n\n\ndef generateUi(opts):\n    """"""Convenience function for generating common UI types""""""\n    widget = QtGui.QWidget()\n    l = QtGui.QFormLayout()\n    l.setSpacing(0)\n    widget.setLayout(l)\n    ctrls = {}\n    row = 0\n    for opt in opts:\n        if len(opt) == 2:\n            k, t = opt\n            o = {}\n        elif len(opt) == 3:\n            k, t, o = opt\n        else:\n            raise Exception(""Widget specification must be (name, type) or (name, type, {opts})"")\n            \n        ## clean out these options so they don\'t get sent to SpinBox\n        hidden = o.pop(\'hidden\', False)\n        tip = o.pop(\'tip\', None)\n\n        if t == \'intSpin\':\n            w = QtGui.QSpinBox()\n            if \'max\' in o:\n                w.setMaximum(o[\'max\'])\n            if \'min\' in o:\n                w.setMinimum(o[\'min\'])\n            if \'value\' in o:\n                w.setValue(o[\'value\'])\n        elif t == \'doubleSpin\':\n            w = QtGui.QDoubleSpinBox()\n            if \'max\' in o:\n                w.setMaximum(o[\'max\'])\n            if \'min\' in o:\n                w.setMinimum(o[\'min\'])                \n            if \'value\' in o:\n                w.setValue(o[\'value\'])\n        elif t == \'spin\':\n            w = SpinBox()\n            w.setOpts(**o)\n        elif t == \'check\':\n            w = QtGui.QCheckBox()\n            if \'checked\' in o:\n                w.setChecked(o[\'checked\'])\n        elif t == \'combo\':\n            w = QtGui.QComboBox()\n            for i in o[\'values\']:\n                w.addItem(i)\n        #elif t == \'colormap\':\n            #w = ColorMapper()\n        elif t == \'color\':\n            w = ColorButton()\n        else:\n            raise Exception(""Unknown widget type \'%s\'"" % str(t))\n\n        if tip is not None:\n            w.setToolTip(tip)\n        w.setObjectName(k)\n        l.addRow(k, w)\n        if hidden:\n            w.hide()\n            label = l.labelForField(w)\n            label.hide()\n            \n        ctrls[k] = w\n        w.rowNum = row\n        row += 1\n    group = WidgetGroup(widget)\n    return widget, group, ctrls\n\n\nclass CtrlNode(Node):\n    """"""Abstract class for nodes with auto-generated control UI""""""\n    \n    sigStateChanged = QtCore.Signal(object)\n    \n    def __init__(self, name, ui=None, terminals=None):\n        if ui is None:\n            if hasattr(self, \'uiTemplate\'):\n                ui = self.uiTemplate\n            else:\n                ui = []\n        if terminals is None:\n            terminals = {\'In\': {\'io\': \'in\'}, \'Out\': {\'io\': \'out\', \'bypass\': \'In\'}}\n        Node.__init__(self, name=name, terminals=terminals)\n        \n        self.ui, self.stateGroup, self.ctrls = generateUi(ui)\n        self.stateGroup.sigChanged.connect(self.changed)\n       \n    def ctrlWidget(self):\n        return self.ui\n       \n    def changed(self):\n        self.update()\n        self.sigStateChanged.emit(self)\n\n    def process(self, In, display=True):\n        out = self.processData(In)\n        return {\'Out\': out}\n    \n    def saveState(self):\n        state = Node.saveState(self)\n        state[\'ctrl\'] = self.stateGroup.state()\n        return state\n    \n    def restoreState(self, state):\n        Node.restoreState(self, state)\n        if self.stateGroup is not None:\n            self.stateGroup.setState(state.get(\'ctrl\', {}))\n            \n    def hideRow(self, name):\n        w = self.ctrls[name]\n        l = self.ui.layout().labelForField(w)\n        w.hide()\n        l.hide()\n        \n    def showRow(self, name):\n        w = self.ctrls[name]\n        l = self.ui.layout().labelForField(w)\n        w.show()\n        l.show()\n\n\nclass PlottingCtrlNode(CtrlNode):\n    """"""Abstract class for CtrlNodes that can connect to plots.""""""\n    \n    def __init__(self, name, ui=None, terminals=None):\n        #print ""PlottingCtrlNode.__init__ called.""\n        CtrlNode.__init__(self, name, ui=ui, terminals=terminals)\n        self.plotTerminal = self.addOutput(\'plot\', optional=True)\n        \n    def connected(self, term, remote):\n        CtrlNode.connected(self, term, remote)\n        if term is not self.plotTerminal:\n            return\n        node = remote.node()\n        node.sigPlotChanged.connect(self.connectToPlot)\n        self.connectToPlot(node)    \n        \n    def disconnected(self, term, remote):\n        CtrlNode.disconnected(self, term, remote)\n        if term is not self.plotTerminal:\n            return\n        remote.node().sigPlotChanged.disconnect(self.connectToPlot)\n        self.disconnectFromPlot(remote.node().getPlot())   \n       \n    def connectToPlot(self, node):\n        """"""Define what happens when the node is connected to a plot""""""\n        raise Exception(""Must be re-implemented in subclass"")\n    \n    def disconnectFromPlot(self, plot):\n        """"""Define what happens when the node is disconnected from a plot""""""\n        raise Exception(""Must be re-implemented in subclass"")\n\n    def process(self, In, display=True):\n        out = CtrlNode.process(self, In, display)\n        out[\'plot\'] = None\n        return out\n\n\ndef metaArrayWrapper(fn):\n    def newFn(self, data, *args, **kargs):\n        if HAVE_METAARRAY and (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n            d1 = fn(self, data.view(np.ndarray), *args, **kargs)\n            info = data.infoCopy()\n            if d1.shape != data.shape:\n                for i in range(data.ndim):\n                    if \'values\' in info[i]:\n                        info[i][\'values\'] = info[i][\'values\'][:d1.shape[i]]\n            return metaarray.MetaArray(d1, info=info)\n        else:\n            return fn(self, data, *args, **kargs)\n    return newFn\n\n'"
src/third_party/pyqtgraph/flowchart/library/functions.py,34,"b'import numpy as np\nfrom ...metaarray import MetaArray\nfrom ...python2_3 import basestring, xrange\n\n\ndef downsample(data, n, axis=0, xvals=\'subsample\'):\n    """"""Downsample by averaging points together across axis.\n    If multiple axes are specified, runs once per axis.\n    If a metaArray is given, then the axis values can be either subsampled\n    or downsampled to match.\n    """"""\n    ma = None\n    if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        ma = data\n        data = data.view(np.ndarray)\n        \n    \n    if hasattr(axis, \'__len__\'):\n        if not hasattr(n, \'__len__\'):\n            n = [n]*len(axis)\n        for i in range(len(axis)):\n            data = downsample(data, n[i], axis[i])\n        return data\n    \n    nPts = int(data.shape[axis] / n)\n    s = list(data.shape)\n    s[axis] = nPts\n    s.insert(axis+1, n)\n    sl = [slice(None)] * data.ndim\n    sl[axis] = slice(0, nPts*n)\n    d1 = data[tuple(sl)]\n    #print d1.shape, s\n    d1.shape = tuple(s)\n    d2 = d1.mean(axis+1)\n    \n    if ma is None:\n        return d2\n    else:\n        info = ma.infoCopy()\n        if \'values\' in info[axis]:\n            if xvals == \'subsample\':\n                info[axis][\'values\'] = info[axis][\'values\'][::n][:nPts]\n            elif xvals == \'downsample\':\n                info[axis][\'values\'] = downsample(info[axis][\'values\'], n)\n        return MetaArray(d2, info=info)\n\n\ndef applyFilter(data, b, a, padding=100, bidir=True):\n    """"""Apply a linear filter with coefficients a, b. Optionally pad the data before filtering\n    and/or run the filter in both directions.""""""\n    try:\n        import scipy.signal\n    except ImportError:\n        raise Exception(""applyFilter() requires the package scipy.signal."")\n    \n    d1 = data.view(np.ndarray)\n    \n    if padding > 0:\n        d1 = np.hstack([d1[:padding], d1, d1[-padding:]])\n    \n    if bidir:\n        d1 = scipy.signal.lfilter(b, a, scipy.signal.lfilter(b, a, d1)[::-1])[::-1]\n    else:\n        d1 = scipy.signal.lfilter(b, a, d1)\n    \n    if padding > 0:\n        d1 = d1[padding:-padding]\n        \n    if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        return MetaArray(d1, info=data.infoCopy())\n    else:\n        return d1\n    \ndef besselFilter(data, cutoff, order=1, dt=None, btype=\'low\', bidir=True):\n    """"""return data passed through bessel filter""""""\n    try:\n        import scipy.signal\n    except ImportError:\n        raise Exception(""besselFilter() requires the package scipy.signal."")\n    \n    if dt is None:\n        try:\n            tvals = data.xvals(\'Time\')\n            dt = (tvals[-1]-tvals[0]) / (len(tvals)-1)\n        except:\n            dt = 1.0\n    \n    b,a = scipy.signal.bessel(order, cutoff * dt, btype=btype) \n    \n    return applyFilter(data, b, a, bidir=bidir)\n    #base = data.mean()\n    #d1 = scipy.signal.lfilter(b, a, data.view(ndarray)-base) + base\n    #if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        #return MetaArray(d1, info=data.infoCopy())\n    #return d1\n\ndef butterworthFilter(data, wPass, wStop=None, gPass=2.0, gStop=20.0, order=1, dt=None, btype=\'low\', bidir=True):\n    """"""return data passed through bessel filter""""""\n    try:\n        import scipy.signal\n    except ImportError:\n        raise Exception(""butterworthFilter() requires the package scipy.signal."")\n    \n    if dt is None:\n        try:\n            tvals = data.xvals(\'Time\')\n            dt = (tvals[-1]-tvals[0]) / (len(tvals)-1)\n        except:\n            dt = 1.0\n    \n    if wStop is None:\n        wStop = wPass * 2.0\n    ord, Wn = scipy.signal.buttord(wPass*dt*2., wStop*dt*2., gPass, gStop)\n    #print ""butterworth ord %f   Wn %f   c %f   sc %f"" % (ord, Wn, cutoff, stopCutoff)\n    b,a = scipy.signal.butter(ord, Wn, btype=btype) \n    \n    return applyFilter(data, b, a, bidir=bidir)\n\n\ndef rollingSum(data, n):\n    d1 = data.copy()\n    d1[1:] += d1[:-1]  # integrate\n    d2 = np.empty(len(d1) - n + 1, dtype=data.dtype)\n    d2[0] = d1[n-1]  # copy first point\n    d2[1:] = d1[n:] - d1[:-n]  # subtract\n    return d2\n\n\ndef mode(data, bins=None):\n    """"""Returns location max value from histogram.""""""\n    if bins is None:\n        bins = int(len(data)/10.)\n        if bins < 2:\n            bins = 2\n    y, x = np.histogram(data, bins=bins)\n    ind = np.argmax(y)\n    mode = 0.5 * (x[ind] + x[ind+1])\n    return mode\n    \ndef modeFilter(data, window=500, step=None, bins=None):\n    """"""Filter based on histogram-based mode function""""""\n    d1 = data.view(np.ndarray)\n    vals = []\n    l2 = int(window/2.)\n    if step is None:\n        step = l2\n    i = 0\n    while True:\n        if i > len(data)-step:\n            break\n        vals.append(mode(d1[i:i+window], bins))\n        i += step\n            \n    chunks = [np.linspace(vals[0], vals[0], l2)]\n    for i in range(len(vals)-1):\n        chunks.append(np.linspace(vals[i], vals[i+1], step))\n    remain = len(data) - step*(len(vals)-1) - l2\n    chunks.append(np.linspace(vals[-1], vals[-1], remain))\n    d2 = np.hstack(chunks)\n    \n    if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        return MetaArray(d2, info=data.infoCopy())\n    return d2\n\ndef denoise(data, radius=2, threshold=4):\n    """"""Very simple noise removal function. Compares a point to surrounding points,\n    replaces with nearby values if the difference is too large.""""""\n    \n    \n    r2 = radius * 2\n    d1 = data.view(np.ndarray)\n    d2 = d1[radius:] - d1[:-radius] #a derivative\n    #d3 = data[r2:] - data[:-r2]\n    #d4 = d2 - d3\n    stdev = d2.std()\n    #print ""denoise: stdev of derivative:"", stdev\n    mask1 = d2 > stdev*threshold #where derivative is large and positive\n    mask2 = d2 < -stdev*threshold #where derivative is large and negative\n    maskpos = mask1[:-radius] * mask2[radius:] #both need to be true\n    maskneg = mask1[radius:] * mask2[:-radius]\n    mask = maskpos + maskneg\n    d5 = np.where(mask, d1[:-r2], d1[radius:-radius]) #where both are true replace the value with the value from 2 points before\n    d6 = np.empty(d1.shape, dtype=d1.dtype) #add points back to the ends\n    d6[radius:-radius] = d5\n    d6[:radius] = d1[:radius]\n    d6[-radius:] = d1[-radius:]\n    \n    if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        return MetaArray(d6, info=data.infoCopy())\n    return d6\n\ndef adaptiveDetrend(data, x=None, threshold=3.0):\n    """"""Return the signal with baseline removed. Discards outliers from baseline measurement.""""""\n    try:\n        import scipy.signal\n    except ImportError:\n        raise Exception(""adaptiveDetrend() requires the package scipy.signal."")\n    \n    if x is None:\n        x = data.xvals(0)\n    \n    d = data.view(np.ndarray)\n    \n    d2 = scipy.signal.detrend(d)\n    \n    stdev = d2.std()\n    mask = abs(d2) < stdev*threshold\n    #d3 = where(mask, 0, d2)\n    #d4 = d2 - lowPass(d3, cutoffs[1], dt=dt)\n    \n    lr = scipy.stats.linregress(x[mask], d[mask])\n    base = lr[1] + lr[0]*x\n    d4 = d - base\n    \n    if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        return MetaArray(d4, info=data.infoCopy())\n    return d4\n    \n\ndef histogramDetrend(data, window=500, bins=50, threshold=3.0, offsetOnly=False):\n    """"""Linear detrend. Works by finding the most common value at the beginning and end of a trace, excluding outliers.\n    If offsetOnly is True, then only the offset from the beginning of the trace is subtracted.\n    """"""\n    \n    d1 = data.view(np.ndarray)\n    d2 = [d1[:window], d1[-window:]]\n    v = [0, 0]\n    for i in [0, 1]:\n        d3 = d2[i]\n        stdev = d3.std()\n        mask = abs(d3-np.median(d3)) < stdev*threshold\n        d4 = d3[mask]\n        y, x = np.histogram(d4, bins=bins)\n        ind = np.argmax(y)\n        v[i] = 0.5 * (x[ind] + x[ind+1])\n        \n    if offsetOnly:\n        d3 = data.view(np.ndarray) - v[0]\n    else:\n        base = np.linspace(v[0], v[1], len(data))\n        d3 = data.view(np.ndarray) - base\n    \n    if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        return MetaArray(d3, info=data.infoCopy())\n    return d3\n    \ndef concatenateColumns(data):\n    """"""Returns a single record array with columns taken from the elements in data. \n    data should be a list of elements, which can be either record arrays or tuples (name, type, data)\n    """"""\n    \n    ## first determine dtype\n    dtype = []\n    names = set()\n    maxLen = 0\n    for element in data:\n        if isinstance(element, np.ndarray):\n            ## use existing columns\n            for i in range(len(element.dtype)):\n                name = element.dtype.names[i]\n                dtype.append((name, element.dtype[i]))\n            maxLen = max(maxLen, len(element))\n        else:\n            name, type, d = element\n            if type is None:\n                type = suggestDType(d)\n            dtype.append((name, type))\n            if isinstance(d, list) or isinstance(d, np.ndarray):\n                maxLen = max(maxLen, len(d))\n        if name in names:\n            raise Exception(\'Name ""%s"" repeated\' % name)\n        names.add(name)\n            \n            \n    \n    ## create empty array\n    out = np.empty(maxLen, dtype)\n    \n    ## fill columns\n    for element in data:\n        if isinstance(element, np.ndarray):\n            for i in range(len(element.dtype)):\n                name = element.dtype.names[i]\n                try:\n                    out[name] = element[name]\n                except:\n                    print(""Column:"", name)\n                    print(""Input shape:"", element.shape, element.dtype)\n                    print(""Output shape:"", out.shape, out.dtype)\n                    raise\n        else:\n            name, type, d = element\n            out[name] = d\n            \n    return out\n    \ndef suggestDType(x):\n    """"""Return a suitable dtype for x""""""\n    if isinstance(x, list) or isinstance(x, tuple):\n        if len(x) == 0:\n            raise Exception(\'can not determine dtype for empty list\')\n        x = x[0]\n        \n    if hasattr(x, \'dtype\'):\n        return x.dtype\n    elif isinstance(x, float):\n        return float\n    elif isinstance(x, int):\n        return int\n    #elif isinstance(x, basestring):  ## don\'t try to guess correct string length; use object instead.\n        #return \'<U%d\' % len(x)\n    else:\n        return object\n\ndef removePeriodic(data, f0=60.0, dt=None, harmonics=10, samples=4):\n    if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        data1 = data.asarray()\n        if dt is None:\n            times = data.xvals(\'Time\')\n            dt = times[1]-times[0]\n    else:\n        data1 = data\n        if dt is None:\n            raise Exception(\'Must specify dt for this data\')\n    \n    ft = np.fft.fft(data1)\n    \n    ## determine frequencies in fft data\n    df = 1.0 / (len(data1) * dt)\n    freqs = np.linspace(0.0, (len(ft)-1) * df, len(ft))\n    \n    ## flatten spikes at f0 and harmonics\n    for i in xrange(1, harmonics + 2):\n        f = f0 * i # target frequency\n        \n        ## determine index range to check for this frequency\n        ind1 = int(np.floor(f / df))\n        ind2 = int(np.ceil(f / df)) + (samples-1)\n        if ind1 > len(ft)/2.:\n            break\n        mag = (abs(ft[ind1-1]) + abs(ft[ind2+1])) * 0.5\n        for j in range(ind1, ind2+1):\n            phase = np.angle(ft[j])   ## Must preserve the phase of each point, otherwise any transients in the trace might lead to large artifacts.\n            re = mag * np.cos(phase)\n            im = mag * np.sin(phase)\n            ft[j] = re + im*1j\n            ft[len(ft)-j] = re - im*1j\n            \n    data2 = np.fft.ifft(ft).real\n    \n    if (hasattr(data, \'implements\') and data.implements(\'MetaArray\')):\n        return metaarray.MetaArray(data2, info=data.infoCopy())\n    else:\n        return data2\n    \n    \n    '"
src/third_party/pyqtgraph/graphicsItems/PlotItem/PlotItem.py,4,"b'# -*- coding: utf-8 -*-\nimport sys\nimport weakref\nimport numpy as np\nimport os\nfrom ...Qt import QtGui, QtCore, QT_LIB\nfrom ... import pixmaps\nfrom ... import functions as fn\nfrom ...widgets.FileDialog import FileDialog\nfrom .. PlotDataItem import PlotDataItem\nfrom .. ViewBox import ViewBox\nfrom .. AxisItem import AxisItem\nfrom .. LabelItem import LabelItem\nfrom .. LegendItem import LegendItem\nfrom .. GraphicsWidget import GraphicsWidget\nfrom .. ButtonItem import ButtonItem\nfrom .. InfiniteLine import InfiniteLine\nfrom ...WidgetGroup import WidgetGroup\nfrom ...python2_3 import basestring\n\nif QT_LIB == \'PyQt4\':\n    from .plotConfigTemplate_pyqt import *\nelif QT_LIB == \'PySide\':\n    from .plotConfigTemplate_pyside import *\nelif QT_LIB == \'PyQt5\':\n    from .plotConfigTemplate_pyqt5 import *\nelif QT_LIB == \'PySide2\':\n    from .plotConfigTemplate_pyside2 import *\n\n__all__ = [\'PlotItem\']\n\ntry:\n    from metaarray import *\n    HAVE_METAARRAY = True\nexcept:\n    HAVE_METAARRAY = False\n\n\nclass PlotItem(GraphicsWidget):\n    """"""GraphicsWidget implementing a standard 2D plotting area with axes.\n\n    **Bases:** :class:`GraphicsWidget <pyqtgraph.GraphicsWidget>`\n    \n    This class provides the ViewBox-plus-axes that appear when using\n    :func:`pg.plot() <pyqtgraph.plot>`, :class:`PlotWidget <pyqtgraph.PlotWidget>`,\n    and :func:`GraphicsLayoutWidget.addPlot() <pyqtgraph.GraphicsLayoutWidget.addPlot>`.\n\n    It\'s main functionality is:\n\n    - Manage placement of ViewBox, AxisItems, and LabelItems\n    - Create and manage a list of PlotDataItems displayed inside the ViewBox\n    - Implement a context menu with commonly used display and analysis options\n\n    Use :func:`plot() <pyqtgraph.PlotItem.plot>` to create a new PlotDataItem and\n    add it to the view. Use :func:`addItem() <pyqtgraph.PlotItem.addItem>` to\n    add any QGraphicsItem to the view.\n    \n    This class wraps several methods from its internal ViewBox:\n    :func:`setXRange <pyqtgraph.ViewBox.setXRange>`,\n    :func:`setYRange <pyqtgraph.ViewBox.setYRange>`,\n    :func:`setRange <pyqtgraph.ViewBox.setRange>`,\n    :func:`autoRange <pyqtgraph.ViewBox.autoRange>`,\n    :func:`setXLink <pyqtgraph.ViewBox.setXLink>`,\n    :func:`setYLink <pyqtgraph.ViewBox.setYLink>`,\n    :func:`setAutoPan <pyqtgraph.ViewBox.setAutoPan>`,\n    :func:`setAutoVisible <pyqtgraph.ViewBox.setAutoVisible>`,\n    :func:`setLimits <pyqtgraph.ViewBox.setLimits>`,\n    :func:`viewRect <pyqtgraph.ViewBox.viewRect>`,\n    :func:`viewRange <pyqtgraph.ViewBox.viewRange>`,\n    :func:`setMouseEnabled <pyqtgraph.ViewBox.setMouseEnabled>`,\n    :func:`enableAutoRange <pyqtgraph.ViewBox.enableAutoRange>`,\n    :func:`disableAutoRange <pyqtgraph.ViewBox.disableAutoRange>`,\n    :func:`setAspectLocked <pyqtgraph.ViewBox.setAspectLocked>`,\n    :func:`invertY <pyqtgraph.ViewBox.invertY>`,\n    :func:`invertX <pyqtgraph.ViewBox.invertX>`,\n    :func:`register <pyqtgraph.ViewBox.register>`,\n    :func:`unregister <pyqtgraph.ViewBox.unregister>`\n    \n    The ViewBox itself can be accessed by calling :func:`getViewBox() <pyqtgraph.PlotItem.getViewBox>` \n    \n    ==================== =======================================================================\n    **Signals:**\n    sigYRangeChanged     wrapped from :class:`ViewBox <pyqtgraph.ViewBox>`\n    sigXRangeChanged     wrapped from :class:`ViewBox <pyqtgraph.ViewBox>`\n    sigRangeChanged      wrapped from :class:`ViewBox <pyqtgraph.ViewBox>`\n    ==================== =======================================================================\n    """"""\n    \n    sigRangeChanged = QtCore.Signal(object, object)    ## Emitted when the ViewBox range has changed\n    sigYRangeChanged = QtCore.Signal(object, object)   ## Emitted when the ViewBox Y range has changed\n    sigXRangeChanged = QtCore.Signal(object, object)   ## Emitted when the ViewBox X range has changed\n        \n    lastFileDir = None\n    \n    def __init__(self, parent=None, name=None, labels=None, title=None, viewBox=None, axisItems=None, enableMenu=True, **kargs):\n        """"""\n        Create a new PlotItem. All arguments are optional.\n        Any extra keyword arguments are passed to PlotItem.plot().\n        \n        ==============  ==========================================================================================\n        **Arguments:**\n        *title*         Title to display at the top of the item. Html is allowed.\n        *labels*        A dictionary specifying the axis labels to display::\n                   \n                            {\'left\': (args), \'bottom\': (args), ...}\n                     \n                        The name of each axis and the corresponding arguments are passed to \n                        :func:`PlotItem.setLabel() <pyqtgraph.PlotItem.setLabel>`\n                        Optionally, PlotItem my also be initialized with the keyword arguments left,\n                        right, top, or bottom to achieve the same effect.\n        *name*          Registers a name for this view so that others may link to it\n        *viewBox*       If specified, the PlotItem will be constructed with this as its ViewBox.\n        *axisItems*     Optional dictionary instructing the PlotItem to use pre-constructed items\n                        for its axes. The dict keys must be axis names (\'left\', \'bottom\', \'right\', \'top\')\n                        and the values must be instances of AxisItem (or at least compatible with AxisItem).\n        ==============  ==========================================================================================\n        """"""\n        \n        GraphicsWidget.__init__(self, parent)\n        \n        self.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)\n        \n        ## Set up control buttons\n        path = os.path.dirname(__file__)\n        self.autoBtn = ButtonItem(pixmaps.getPixmap(\'auto\'), 14, self)\n        self.autoBtn.mode = \'auto\'\n        self.autoBtn.clicked.connect(self.autoBtnClicked)\n        self.buttonsHidden = False ## whether the user has requested buttons to be hidden\n        self.mouseHovering = False\n        \n        self.layout = QtGui.QGraphicsGridLayout()\n        self.layout.setContentsMargins(1,1,1,1)\n        self.setLayout(self.layout)\n        self.layout.setHorizontalSpacing(0)\n        self.layout.setVerticalSpacing(0)\n        \n        if viewBox is None:\n            viewBox = ViewBox(parent=self)\n        self.vb = viewBox\n        self.vb.sigStateChanged.connect(self.viewStateChanged)\n        self.setMenuEnabled(enableMenu, enableMenu) ## en/disable plotitem and viewbox menus\n        \n        if name is not None:\n            self.vb.register(name)\n        self.vb.sigRangeChanged.connect(self.sigRangeChanged)\n        self.vb.sigXRangeChanged.connect(self.sigXRangeChanged)\n        self.vb.sigYRangeChanged.connect(self.sigYRangeChanged)\n        \n        self.layout.addItem(self.vb, 2, 1)\n        self.alpha = 1.0\n        self.autoAlpha = True\n        self.spectrumMode = False\n        \n        self.legend = None\n        \n        ## Create and place axis items\n        if axisItems is None:\n            axisItems = {}\n        self.axes = {}\n        for k, pos in ((\'top\', (1,1)), (\'bottom\', (3,1)), (\'left\', (2,0)), (\'right\', (2,2))):\n            if k in axisItems:\n                axis = axisItems[k]\n            else:\n                axis = AxisItem(orientation=k, parent=self)\n            axis.linkToView(self.vb)\n            self.axes[k] = {\'item\': axis, \'pos\': pos}\n            self.layout.addItem(axis, *pos)\n            axis.setZValue(-1000)\n            axis.setFlag(axis.ItemNegativeZStacksBehindParent)\n        \n        self.titleLabel = LabelItem(\'\', size=\'11pt\', parent=self)\n        self.layout.addItem(self.titleLabel, 0, 1)\n        self.setTitle(None)  ## hide\n        \n        for i in range(4):\n            self.layout.setRowPreferredHeight(i, 0)\n            self.layout.setRowMinimumHeight(i, 0)\n            self.layout.setRowSpacing(i, 0)\n            self.layout.setRowStretchFactor(i, 1)\n            \n        for i in range(3):\n            self.layout.setColumnPreferredWidth(i, 0)\n            self.layout.setColumnMinimumWidth(i, 0)\n            self.layout.setColumnSpacing(i, 0)\n            self.layout.setColumnStretchFactor(i, 1)\n        self.layout.setRowStretchFactor(2, 100)\n        self.layout.setColumnStretchFactor(1, 100)\n        \n\n        self.items = []\n        self.curves = []\n        self.itemMeta = weakref.WeakKeyDictionary()\n        self.dataItems = []\n        self.paramList = {}\n        self.avgCurves = {}\n        \n        ### Set up context menu\n        \n        w = QtGui.QWidget()\n        self.ctrl = c = Ui_Form()\n        c.setupUi(w)\n        dv = QtGui.QDoubleValidator(self)\n        \n        menuItems = [\n            (\'Transforms\', c.transformGroup),\n            (\'Downsample\', c.decimateGroup),\n            (\'Average\', c.averageGroup),\n            (\'Alpha\', c.alphaGroup),\n            (\'Grid\', c.gridGroup),\n            (\'Points\', c.pointsGroup),\n        ]\n        \n        \n        self.ctrlMenu = QtGui.QMenu()\n        \n        self.ctrlMenu.setTitle(\'Plot Options\')\n        self.subMenus = []\n        for name, grp in menuItems:\n            sm = QtGui.QMenu(name)\n            act = QtGui.QWidgetAction(self)\n            act.setDefaultWidget(grp)\n            sm.addAction(act)\n            self.subMenus.append(sm)\n            self.ctrlMenu.addMenu(sm)\n        \n        self.stateGroup = WidgetGroup()\n        for name, w in menuItems:\n            self.stateGroup.autoAdd(w)\n        \n        self.fileDialog = None\n        \n        c.alphaGroup.toggled.connect(self.updateAlpha)\n        c.alphaSlider.valueChanged.connect(self.updateAlpha)\n        c.autoAlphaCheck.toggled.connect(self.updateAlpha)\n\n        c.xGridCheck.toggled.connect(self.updateGrid)\n        c.yGridCheck.toggled.connect(self.updateGrid)\n        c.gridAlphaSlider.valueChanged.connect(self.updateGrid)\n\n        c.fftCheck.toggled.connect(self.updateSpectrumMode)\n        c.logXCheck.toggled.connect(self.updateLogMode)\n        c.logYCheck.toggled.connect(self.updateLogMode)\n\n        c.downsampleSpin.valueChanged.connect(self.updateDownsampling)\n        c.downsampleCheck.toggled.connect(self.updateDownsampling)\n        c.autoDownsampleCheck.toggled.connect(self.updateDownsampling)\n        c.subsampleRadio.toggled.connect(self.updateDownsampling)\n        c.meanRadio.toggled.connect(self.updateDownsampling)\n        c.clipToViewCheck.toggled.connect(self.updateDownsampling)\n\n        self.ctrl.avgParamList.itemClicked.connect(self.avgParamListClicked)\n        self.ctrl.averageGroup.toggled.connect(self.avgToggled)\n        \n        self.ctrl.maxTracesCheck.toggled.connect(self.updateDecimation)\n        self.ctrl.maxTracesSpin.valueChanged.connect(self.updateDecimation)\n        \n        self.hideAxis(\'right\')\n        self.hideAxis(\'top\')\n        self.showAxis(\'left\')\n        self.showAxis(\'bottom\')\n        \n        if labels is None:\n            labels = {}\n        for label in list(self.axes.keys()):\n            if label in kargs:\n                labels[label] = kargs[label]\n                del kargs[label]\n        for k in labels:\n            if isinstance(labels[k], basestring):\n                labels[k] = (labels[k],)\n            self.setLabel(k, *labels[k])\n                \n        if title is not None:\n            self.setTitle(title)\n        \n        if len(kargs) > 0:\n            self.plot(**kargs)        \n        \n    def implements(self, interface=None):\n        return interface in [\'ViewBoxWrapper\']\n\n    def getViewBox(self):\n        """"""Return the :class:`ViewBox <pyqtgraph.ViewBox>` contained within.""""""\n        return self.vb\n    \n    ## Wrap a few methods from viewBox. \n    #Important: don\'t use a settattr(m, getattr(self.vb, m)) as we\'d be leaving the viebox alive\n    #because we had a reference to an instance method (creating wrapper methods at runtime instead).\n    for m in [\'setXRange\', \'setYRange\', \'setXLink\', \'setYLink\', \'setAutoPan\',         # NOTE: \n              \'setAutoVisible\', \'setRange\', \'autoRange\', \'viewRect\', \'viewRange\',     # If you update this list, please \n              \'setMouseEnabled\', \'setLimits\', \'enableAutoRange\', \'disableAutoRange\',  # update the class docstring \n              \'setAspectLocked\', \'invertY\', \'invertX\', \'register\', \'unregister\']:                # as well.\n                \n        def _create_method(name):\n            def method(self, *args, **kwargs):\n                return getattr(self.vb, name)(*args, **kwargs)\n            method.__name__ = name\n            return method\n        \n        locals()[m] = _create_method(m)\n        \n    del _create_method\n        \n    def setLogMode(self, x=None, y=None):\n        """"""\n        Set log scaling for x and/or y axes.\n        This informs PlotDataItems to transform logarithmically and switches\n        the axes to use log ticking. \n        \n        Note that *no other items* in the scene will be affected by\n        this; there is (currently) no generic way to redisplay a GraphicsItem\n        with log coordinates.\n        \n        """"""\n        if x is not None:\n            self.ctrl.logXCheck.setChecked(x)\n        if y is not None:\n            self.ctrl.logYCheck.setChecked(y)\n        \n    def showGrid(self, x=None, y=None, alpha=None):\n        """"""\n        Show or hide the grid for either axis.\n        \n        ==============  =====================================\n        **Arguments:**\n        x               (bool) Whether to show the X grid\n        y               (bool) Whether to show the Y grid\n        alpha           (0.0-1.0) Opacity of the grid\n        ==============  =====================================\n        """"""\n        if x is None and y is None and alpha is None:\n            raise Exception(""Must specify at least one of x, y, or alpha."")  ## prevent people getting confused if they just call showGrid()\n        \n        if x is not None:\n            self.ctrl.xGridCheck.setChecked(x)\n        if y is not None:\n            self.ctrl.yGridCheck.setChecked(y)\n        if alpha is not None:\n            v = np.clip(alpha, 0, 1)*self.ctrl.gridAlphaSlider.maximum()\n            self.ctrl.gridAlphaSlider.setValue(v)\n        \n    def close(self):\n        ## Most of this crap is needed to avoid PySide trouble. \n        ## The problem seems to be whenever scene.clear() leads to deletion of widgets (either through proxies or qgraphicswidgets)\n        ## the solution is to manually remove all widgets before scene.clear() is called\n        if self.ctrlMenu is None: ## already shut down\n            return\n        self.ctrlMenu.setParent(None)\n        self.ctrlMenu = None\n        \n        self.autoBtn.setParent(None)\n        self.autoBtn = None\n        \n        for k in self.axes:\n            i = self.axes[k][\'item\']\n            i.close()\n            \n        self.axes = None\n        self.scene().removeItem(self.vb)\n        self.vb = None\n        \n    def registerPlot(self, name):   ## for backward compatibility\n        self.vb.register(name)\n        \n    def updateGrid(self, *args):\n        alpha = self.ctrl.gridAlphaSlider.value()\n        x = alpha if self.ctrl.xGridCheck.isChecked() else False\n        y = alpha if self.ctrl.yGridCheck.isChecked() else False\n        self.getAxis(\'top\').setGrid(x)\n        self.getAxis(\'bottom\').setGrid(x)\n        self.getAxis(\'left\').setGrid(y)\n        self.getAxis(\'right\').setGrid(y)\n\n    def viewGeometry(self):\n        """"""Return the screen geometry of the viewbox""""""\n        v = self.scene().views()[0]\n        b = self.vb.mapRectToScene(self.vb.boundingRect())\n        wr = v.mapFromScene(b).boundingRect()\n        pos = v.mapToGlobal(v.pos())\n        wr.adjust(pos.x(), pos.y(), pos.x(), pos.y())\n        return wr\n\n    def avgToggled(self, b):\n        if b:\n            self.recomputeAverages()\n        for k in self.avgCurves:\n            self.avgCurves[k][1].setVisible(b)\n        \n    def avgParamListClicked(self, item):\n        name = str(item.text())\n        self.paramList[name] = (item.checkState() == QtCore.Qt.Checked)\n        self.recomputeAverages()\n        \n    def recomputeAverages(self):\n        if not self.ctrl.averageGroup.isChecked():\n            return\n        for k in self.avgCurves:\n            self.removeItem(self.avgCurves[k][1])\n        self.avgCurves = {}\n        for c in self.curves:\n            self.addAvgCurve(c)\n        self.replot()\n        \n    def addAvgCurve(self, curve):\n        ## Add a single curve into the pool of curves averaged together\n        \n        ## If there are plot parameters, then we need to determine which to average together.\n        remKeys = []\n        addKeys = []\n        if self.ctrl.avgParamList.count() > 0:\n        \n            ### First determine the key of the curve to which this new data should be averaged\n            for i in range(self.ctrl.avgParamList.count()):\n                item = self.ctrl.avgParamList.item(i)\n                if item.checkState() == QtCore.Qt.Checked:\n                    remKeys.append(str(item.text()))\n                else:\n                    addKeys.append(str(item.text()))\n                    \n            if len(remKeys) < 1:  ## In this case, there would be 1 average plot for each data plot; not useful.\n                return\n                \n        p = self.itemMeta.get(curve,{}).copy()\n        for k in p:\n            if type(k) is tuple:\n                p[\'.\'.join(k)] = p[k]\n                del p[k]\n        for rk in remKeys:\n            if rk in p:\n                del p[rk]\n        for ak in addKeys:\n            if ak not in p:\n                p[ak] = None\n        key = tuple(p.items())\n        \n        ### Create a new curve if needed\n        if key not in self.avgCurves:\n            plot = PlotDataItem()\n            plot.setPen(fn.mkPen([0, 200, 0]))\n            plot.setShadowPen(fn.mkPen([0, 0, 0, 100], width=3))\n            plot.setAlpha(1.0, False)\n            plot.setZValue(100)\n            self.addItem(plot, skipAverage=True)\n            self.avgCurves[key] = [0, plot]\n        self.avgCurves[key][0] += 1\n        (n, plot) = self.avgCurves[key]\n        \n        ### Average data together\n        (x, y) = curve.getData()\n        stepMode = curve.opts[\'stepMode\']\n        if plot.yData is not None and y.shape == plot.yData.shape:\n            # note that if shapes do not match, then the average resets.\n            newData = plot.yData * (n-1) / float(n) + y * 1.0 / float(n)\n            plot.setData(plot.xData, newData, stepMode=stepMode)\n        else:\n            plot.setData(x, y, stepMode=stepMode)\n        \n    def autoBtnClicked(self):\n        if self.autoBtn.mode == \'auto\':\n            self.enableAutoRange()\n            self.autoBtn.hide()\n        else:\n            self.disableAutoRange()\n            \n    def viewStateChanged(self):\n        self.updateButtons()\n            \n    def enableAutoScale(self):\n        """"""\n        Enable auto-scaling. The plot will continuously scale to fit the boundaries of its data.\n        """"""\n        print(""Warning: enableAutoScale is deprecated. Use enableAutoRange(axis, enable) instead."")\n        self.vb.enableAutoRange(self.vb.XYAxes)\n\n    def addItem(self, item, *args, **kargs):\n        """"""\n        Add a graphics item to the view box. \n        If the item has plot data (PlotDataItem, PlotCurveItem, ScatterPlotItem), it may\n        be included in analysis performed by the PlotItem.\n        """"""\n        self.items.append(item)\n        vbargs = {}\n        if \'ignoreBounds\' in kargs:\n            vbargs[\'ignoreBounds\'] = kargs[\'ignoreBounds\']\n        self.vb.addItem(item, *args, **vbargs)\n        name = None\n        if hasattr(item, \'implements\') and item.implements(\'plotData\'):\n            name = item.name()\n            self.dataItems.append(item)\n            #self.plotChanged()\n            \n            params = kargs.get(\'params\', {})\n            self.itemMeta[item] = params\n            #item.setMeta(params)\n            self.curves.append(item)\n            #self.addItem(c)\n            \n        if hasattr(item, \'setLogMode\'):\n            item.setLogMode(self.ctrl.logXCheck.isChecked(), self.ctrl.logYCheck.isChecked())\n            \n        if isinstance(item, PlotDataItem):\n            ## configure curve for this plot\n            (alpha, auto) = self.alphaState()\n            item.setAlpha(alpha, auto)\n            item.setFftMode(self.ctrl.fftCheck.isChecked())\n            item.setDownsampling(*self.downsampleMode())\n            item.setClipToView(self.clipToViewMode())\n            item.setPointMode(self.pointMode())\n            \n            ## Hide older plots if needed\n            self.updateDecimation()\n            \n            ## Add to average if needed\n            self.updateParamList()\n            if self.ctrl.averageGroup.isChecked() and \'skipAverage\' not in kargs:\n                self.addAvgCurve(item)\n                \n            #c.connect(c, QtCore.SIGNAL(\'plotChanged\'), self.plotChanged)\n            #item.sigPlotChanged.connect(self.plotChanged)\n            #self.plotChanged()\n        #name = kargs.get(\'name\', getattr(item, \'opts\', {}).get(\'name\', None))\n        if name is not None and hasattr(self, \'legend\') and self.legend is not None:\n            self.legend.addItem(item, name=name)            \n\n    def addDataItem(self, item, *args):\n        print(""PlotItem.addDataItem is deprecated. Use addItem instead."")\n        self.addItem(item, *args)\n        \n    def listDataItems(self):\n        """"""Return a list of all data items (PlotDataItem, PlotCurveItem, ScatterPlotItem, etc)\n        contained in this PlotItem.""""""\n        return self.dataItems[:]\n        \n    def addCurve(self, c, params=None):\n        print(""PlotItem.addCurve is deprecated. Use addItem instead."")\n        self.addItem(c, params)\n\n    def addLine(self, x=None, y=None, z=None, **kwds):\n        """"""\n        Create an InfiniteLine and add to the plot. \n        \n        If *x* is specified,\n        the line will be vertical. If *y* is specified, the line will be\n        horizontal. All extra keyword arguments are passed to\n        :func:`InfiniteLine.__init__() <pyqtgraph.InfiniteLine.__init__>`.\n        Returns the item created.\n        """"""\n        pos = kwds.get(\'pos\', x if x is not None else y)\n        angle = kwds.get(\'angle\', 0 if x is None else 90)\n        line = InfiniteLine(pos, angle, **kwds)\n        self.addItem(line)\n        if z is not None:\n            line.setZValue(z)\n        return line        \n\n    def removeItem(self, item):\n        """"""\n        Remove an item from the internal ViewBox.\n        """"""\n        if not item in self.items:\n            return\n        self.items.remove(item)\n        if item in self.dataItems:\n            self.dataItems.remove(item)\n            \n        if item.scene() is not None:\n            self.vb.removeItem(item)\n        if item in self.curves:\n            self.curves.remove(item)\n            self.updateDecimation()\n            self.updateParamList()\n\n        if self.legend is not None:\n            self.legend.removeItem(item)\n\n    def clear(self):\n        """"""\n        Remove all items from the ViewBox.\n        """"""\n        for i in self.items[:]:\n            self.removeItem(i)\n        self.avgCurves = {}\n    \n    def clearPlots(self):\n        for i in self.curves[:]:\n            self.removeItem(i)\n        self.avgCurves = {}        \n    \n    def plot(self, *args, **kargs):\n        """"""\n        Add and return a new plot.\n        See :func:`PlotDataItem.__init__ <pyqtgraph.PlotDataItem.__init__>` for data arguments\n        \n        Extra allowed arguments are:\n            clear    - clear all plots before displaying new data\n            params   - meta-parameters to associate with this data\n        """"""\n        clear = kargs.get(\'clear\', False)\n        params = kargs.get(\'params\', None)\n          \n        if clear:\n            self.clear()\n            \n        item = PlotDataItem(*args, **kargs)\n            \n        if params is None:\n            params = {}\n        self.addItem(item, params=params)\n        \n        return item\n\n    def addLegend(self, size=None, offset=(30, 30)):\n        """"""\n        Create a new LegendItem and anchor it over the internal ViewBox.\n        Plots will be automatically displayed in the legend if they\n        are created with the \'name\' argument.\n\n        If a LegendItem has already been created using this method, that\n        item will be returned rather than creating a new one.\n        """"""\n        if self.legend is None:\n            self.legend = LegendItem(size, offset)\n            self.legend.setParentItem(self.vb)\n        return self.legend\n        \n    def scatterPlot(self, *args, **kargs):\n        if \'pen\' in kargs:\n            kargs[\'symbolPen\'] = kargs[\'pen\']\n        kargs[\'pen\'] = None\n            \n        if \'brush\' in kargs:\n            kargs[\'symbolBrush\'] = kargs[\'brush\']\n            del kargs[\'brush\']\n            \n        if \'size\' in kargs:\n            kargs[\'symbolSize\'] = kargs[\'size\']\n            del kargs[\'size\']\n\n        return self.plot(*args, **kargs)\n                \n    def replot(self):\n        self.update()\n\n    def updateParamList(self):\n        self.ctrl.avgParamList.clear()\n        ## Check to see that each parameter for each curve is present in the list\n        for c in self.curves:\n            for p in list(self.itemMeta.get(c, {}).keys()):\n                if type(p) is tuple:\n                    p = \'.\'.join(p)\n                    \n                ## If the parameter is not in the list, add it.\n                matches = self.ctrl.avgParamList.findItems(p, QtCore.Qt.MatchExactly)\n                if len(matches) == 0:\n                    i = QtGui.QListWidgetItem(p)\n                    if p in self.paramList and self.paramList[p] is True:\n                        i.setCheckState(QtCore.Qt.Checked)\n                    else:\n                        i.setCheckState(QtCore.Qt.Unchecked)\n                    self.ctrl.avgParamList.addItem(i)\n                else:\n                    i = matches[0]\n                    \n                self.paramList[p] = (i.checkState() == QtCore.Qt.Checked)\n\n    def writeSvgCurves(self, fileName=None):\n        if fileName is None:\n            self._chooseFilenameDialog(handler=self.writeSvg)\n            return\n\n        if isinstance(fileName, tuple):\n            raise Exception(""Not implemented yet.."")\n        fileName = str(fileName)\n        PlotItem.lastFileDir = os.path.dirname(fileName)\n        \n        rect = self.vb.viewRect()\n        xRange = rect.left(), rect.right() \n        \n        svg = """"\n        fh = open(fileName, \'w\')\n\n        dx = max(rect.right(),0) - min(rect.left(),0)\n        ymn = min(rect.top(), rect.bottom())\n        ymx = max(rect.top(), rect.bottom())\n        dy = max(ymx,0) - min(ymn,0)\n        sx = 1.\n        sy = 1.\n        while dx*sx < 10:\n            sx *= 1000\n        while dy*sy < 10:\n            sy *= 1000\n        sy *= -1\n\n        fh.write(\'<svg>\\n\')\n        fh.write(\'<path fill=""none"" stroke=""#000000"" stroke-opacity=""0.5"" stroke-width=""1"" d=""M%f,0 L%f,0""/>\\n\' % (rect.left()*sx, rect.right()*sx))\n        fh.write(\'<path fill=""none"" stroke=""#000000"" stroke-opacity=""0.5"" stroke-width=""1"" d=""M0,%f L0,%f""/>\\n\' % (rect.top()*sy, rect.bottom()*sy))\n\n        for item in self.curves:\n            if isinstance(item, PlotCurveItem):\n                color = fn.colorStr(item.pen.color())\n                opacity = item.pen.color().alpha() / 255.\n                color = color[:6]\n                x, y = item.getData()\n                mask = (x > xRange[0]) * (x < xRange[1])\n                mask[:-1] += mask[1:]\n                m2 = mask.copy()\n                mask[1:] += m2[:-1]\n                x = x[mask]\n                y = y[mask]\n                \n                x *= sx\n                y *= sy\n                \n                fh.write(\'<path fill=""none"" stroke=""#%s"" stroke-opacity=""%f"" stroke-width=""1"" d=""M%f,%f \' % (color, opacity, x[0], y[0]))\n                for i in range(1, len(x)):\n                    fh.write(\'L%f,%f \' % (x[i], y[i]))\n                \n                fh.write(\'""/>\')\n\n        for item in self.dataItems:\n            if isinstance(item, ScatterPlotItem):\n                \n                pRect = item.boundingRect()\n                vRect = pRect.intersected(rect)\n                \n                for point in item.points():\n                    pos = point.pos()\n                    if not rect.contains(pos):\n                        continue\n                    color = fn.colorStr(point.brush.color())\n                    opacity = point.brush.color().alpha() / 255.\n                    color = color[:6]\n                    x = pos.x() * sx\n                    y = pos.y() * sy\n                    \n                    fh.write(\'<circle cx=""%f"" cy=""%f"" r=""1"" fill=""#%s"" stroke=""none"" fill-opacity=""%f""/>\\n\' % (x, y, color, opacity))\n        \n        fh.write(""</svg>\\n"")\n    \n    def writeSvg(self, fileName=None):\n        if fileName is None:\n            self._chooseFilenameDialog(handler=self.writeSvg)\n            return\n\n        fileName = str(fileName)\n        PlotItem.lastFileDir = os.path.dirname(fileName)\n        \n        from ...exporters import SVGExporter\n        ex = SVGExporter(self)\n        ex.export(fileName)\n        \n    def writeImage(self, fileName=None):\n        if fileName is None:\n            self._chooseFilenameDialog(handler=self.writeImage)\n            return\n\n        from ...exporters import ImageExporter\n        ex = ImageExporter(self)\n        ex.export(fileName)\n        \n    def writeCsv(self, fileName=None):\n        if fileName is None:\n            self._chooseFilenameDialog(handler=self.writeCsv)\n            return\n\n        fileName = str(fileName)\n        PlotItem.lastFileDir = os.path.dirname(fileName)\n        \n        fd = open(fileName, \'w\')\n        data = [c.getData() for c in self.curves]\n        i = 0\n        while True:\n            done = True\n            for d in data:\n                if i < len(d[0]):\n                    fd.write(\'%g,%g,\'%(d[0][i], d[1][i]))\n                    done = False\n                else:\n                    fd.write(\' , ,\')\n            fd.write(\'\\n\')\n            if done:\n                break\n            i += 1\n        fd.close()\n\n    def saveState(self):\n        state = self.stateGroup.state()\n        state[\'paramList\'] = self.paramList.copy()\n        state[\'view\'] = self.vb.getState()\n        return state\n        \n    def restoreState(self, state):\n        if \'paramList\' in state:\n            self.paramList = state[\'paramList\'].copy()\n            \n        self.stateGroup.setState(state)\n        self.updateSpectrumMode()\n        self.updateDownsampling()\n        self.updateAlpha()\n        self.updateDecimation()\n        \n        if \'powerSpectrumGroup\' in state:\n            state[\'fftCheck\'] = state[\'powerSpectrumGroup\']\n        if \'gridGroup\' in state:\n            state[\'xGridCheck\'] = state[\'gridGroup\']\n            state[\'yGridCheck\'] = state[\'gridGroup\']\n            \n        self.stateGroup.setState(state)\n        self.updateParamList()\n        \n        if \'view\' not in state:\n            r = [[float(state[\'xMinText\']), float(state[\'xMaxText\'])], [float(state[\'yMinText\']), float(state[\'yMaxText\'])]]\n            state[\'view\'] = {\n                \'autoRange\': [state[\'xAutoRadio\'], state[\'yAutoRadio\']],\n                \'linkedViews\': [state[\'xLinkCombo\'], state[\'yLinkCombo\']],\n                \'targetRange\': r,\n                \'viewRange\': r,\n            }\n        self.vb.setState(state[\'view\'])\n\n    def widgetGroupInterface(self):\n        return (None, PlotItem.saveState, PlotItem.restoreState)\n      \n    def updateSpectrumMode(self, b=None):\n        if b is None:\n            b = self.ctrl.fftCheck.isChecked()\n        for c in self.curves:\n            c.setFftMode(b)\n        self.enableAutoRange()\n        self.recomputeAverages()\n            \n    def updateLogMode(self):\n        x = self.ctrl.logXCheck.isChecked()\n        y = self.ctrl.logYCheck.isChecked()\n        for i in self.items:\n            if hasattr(i, \'setLogMode\'):\n                i.setLogMode(x,y)\n        self.getAxis(\'bottom\').setLogMode(x)\n        self.getAxis(\'top\').setLogMode(x)\n        self.getAxis(\'left\').setLogMode(y)\n        self.getAxis(\'right\').setLogMode(y)\n        self.enableAutoRange()\n        self.recomputeAverages()\n        \n    def setDownsampling(self, ds=None, auto=None, mode=None):\n        """"""Change the default downsampling mode for all PlotDataItems managed by this plot.\n        \n        =============== =================================================================\n        **Arguments:**\n        ds              (int) Reduce visible plot samples by this factor, or\n                        (bool) To enable/disable downsampling without changing the value.\n        auto            (bool) If True, automatically pick *ds* based on visible range\n        mode            \'subsample\': Downsample by taking the first of N samples.\n                        This method is fastest and least accurate.\n                        \'mean\': Downsample by taking the mean of N samples.\n                        \'peak\': Downsample by drawing a saw wave that follows the min\n                        and max of the original data. This method produces the best\n                        visual representation of the data but is slower.\n        =============== =================================================================\n        """"""\n        if ds is not None:\n            if ds is False:\n                self.ctrl.downsampleCheck.setChecked(False)\n            elif ds is True:\n                self.ctrl.downsampleCheck.setChecked(True)\n            else:\n                self.ctrl.downsampleCheck.setChecked(True)\n                self.ctrl.downsampleSpin.setValue(ds)\n                \n        if auto is not None:\n            if auto and ds is not False:\n                self.ctrl.downsampleCheck.setChecked(True)\n            self.ctrl.autoDownsampleCheck.setChecked(auto)\n            \n        if mode is not None:\n            if mode == \'subsample\':\n                self.ctrl.subsampleRadio.setChecked(True)\n            elif mode == \'mean\':\n                self.ctrl.meanRadio.setChecked(True)\n            elif mode == \'peak\':\n                self.ctrl.peakRadio.setChecked(True)\n            else:\n                raise ValueError(""mode argument must be \'subsample\', \'mean\', or \'peak\'."")\n            \n    def updateDownsampling(self):\n        ds, auto, method = self.downsampleMode()\n        clip = self.ctrl.clipToViewCheck.isChecked()\n        for c in self.curves:\n            c.setDownsampling(ds, auto, method)\n            c.setClipToView(clip)\n        self.recomputeAverages()\n        \n    def downsampleMode(self):\n        if self.ctrl.downsampleCheck.isChecked():\n            ds = self.ctrl.downsampleSpin.value()\n        else:\n            ds = 1\n            \n        auto = self.ctrl.downsampleCheck.isChecked() and self.ctrl.autoDownsampleCheck.isChecked()\n            \n        if self.ctrl.subsampleRadio.isChecked():\n            method = \'subsample\' \n        elif self.ctrl.meanRadio.isChecked():\n            method = \'mean\'\n        elif self.ctrl.peakRadio.isChecked():\n            method = \'peak\'\n        \n        return ds, auto, method\n        \n    def setClipToView(self, clip):\n        """"""Set the default clip-to-view mode for all PlotDataItems managed by this plot.\n        If *clip* is True, then PlotDataItems will attempt to draw only points within the visible\n        range of the ViewBox.""""""\n        self.ctrl.clipToViewCheck.setChecked(clip)\n        \n    def clipToViewMode(self):\n        return self.ctrl.clipToViewCheck.isChecked()\n\n    def updateDecimation(self):\n        if self.ctrl.maxTracesCheck.isChecked():\n            numCurves = self.ctrl.maxTracesSpin.value()\n        else:\n            numCurves = -1\n            \n        curves = self.curves[:]\n        split = len(curves) - numCurves\n        for i in range(len(curves)):\n            if numCurves == -1 or i >= split:\n                curves[i].show()\n            else:\n                if self.ctrl.forgetTracesCheck.isChecked():\n                    curves[i].clear()\n                    self.removeItem(curves[i])\n                else:\n                    curves[i].hide()        \n      \n    def updateAlpha(self, *args):\n        (alpha, auto) = self.alphaState()\n        for c in self.curves:\n            c.setAlpha(alpha**2, auto)\n     \n    def alphaState(self):\n        enabled = self.ctrl.alphaGroup.isChecked()\n        auto = self.ctrl.autoAlphaCheck.isChecked()\n        alpha = float(self.ctrl.alphaSlider.value()) / self.ctrl.alphaSlider.maximum()\n        if auto:\n            alpha = 1.0  ## should be 1/number of overlapping plots\n        if not enabled:\n            auto = False\n            alpha = 1.0\n        return (alpha, auto)\n\n    def pointMode(self):\n        if self.ctrl.pointsGroup.isChecked():\n            if self.ctrl.autoPointsCheck.isChecked():\n                mode = None\n            else:\n                mode = True\n        else:\n            mode = False\n        return mode\n\n    def resizeEvent(self, ev):\n        if self.autoBtn is None:  ## already closed down\n            return\n        btnRect = self.mapRectFromItem(self.autoBtn, self.autoBtn.boundingRect())\n        y = self.size().height() - btnRect.height()\n        self.autoBtn.setPos(0, y)\n    \n    def getMenu(self):\n        return self.ctrlMenu\n    \n    def getContextMenus(self, event):\n        ## called when another item is displaying its context menu; we get to add extras to the end of the menu.\n        if self.menuEnabled():\n            return self.ctrlMenu\n        else:\n            return None\n    \n    def setMenuEnabled(self, enableMenu=True, enableViewBoxMenu=\'same\'):\n        """"""\n        Enable or disable the context menu for this PlotItem.\n        By default, the ViewBox\'s context menu will also be affected.\n        (use enableViewBoxMenu=None to leave the ViewBox unchanged)\n        """"""\n        self._menuEnabled = enableMenu\n        if enableViewBoxMenu is None:\n            return\n        if enableViewBoxMenu is \'same\':\n            enableViewBoxMenu = enableMenu \n        self.vb.setMenuEnabled(enableViewBoxMenu)\n    \n    def menuEnabled(self):\n        return self._menuEnabled\n    \n    def hoverEvent(self, ev):\n        if ev.enter:\n            self.mouseHovering = True\n        if ev.exit:\n            self.mouseHovering = False\n            \n        self.updateButtons()\n\n    def getLabel(self, key):\n        pass\n        \n    def _checkScaleKey(self, key):\n        if key not in self.axes:\n            raise Exception(""Scale \'%s\' not found. Scales are: %s"" % (key, str(list(self.axes.keys()))))\n        \n    def getScale(self, key):\n        return self.getAxis(key)\n        \n    def getAxis(self, name):\n        """"""Return the specified AxisItem. \n        *name* should be \'left\', \'bottom\', \'top\', or \'right\'.""""""\n        self._checkScaleKey(name)\n        return self.axes[name][\'item\']\n        \n    def setLabel(self, axis, text=None, units=None, unitPrefix=None, **args):\n        """"""\n        Set the label for an axis. Basic HTML formatting is allowed.\n        \n        ==============  =================================================================\n        **Arguments:**\n        axis            must be one of \'left\', \'bottom\', \'right\', or \'top\'\n        text            text to display along the axis. HTML allowed.\n        units           units to display after the title. If units are given,\n                        then an SI prefix will be automatically appended\n                        and the axis values will be scaled accordingly.\n                        (ie, use \'V\' instead of \'mV\'; \'m\' will be added automatically)\n        ==============  =================================================================\n        """"""\n        self.getAxis(axis).setLabel(text=text, units=units, **args)\n        self.showAxis(axis)\n        \n    def setLabels(self, **kwds):\n        """"""\n        Convenience function allowing multiple labels and/or title to be set in one call.\n        Keyword arguments can be \'title\', \'left\', \'bottom\', \'right\', or \'top\'.\n        Values may be strings or a tuple of arguments to pass to setLabel.\n        """"""\n        for k,v in kwds.items():\n            if k == \'title\':\n                self.setTitle(v)\n            else:\n                if isinstance(v, basestring):\n                    v = (v,)\n                self.setLabel(k, *v)\n        \n    def showLabel(self, axis, show=True):\n        """"""\n        Show or hide one of the plot\'s axis labels (the axis itself will be unaffected).\n        axis must be one of \'left\', \'bottom\', \'right\', or \'top\'\n        """"""\n        self.getScale(axis).showLabel(show)\n\n    def setTitle(self, title=None, **args):\n        """"""\n        Set the title of the plot. Basic HTML formatting is allowed.\n        If title is None, then the title will be hidden.\n        """"""\n        if title is None:\n            self.titleLabel.setVisible(False)\n            self.layout.setRowFixedHeight(0, 0)\n            self.titleLabel.setMaximumHeight(0)\n        else:\n            self.titleLabel.setMaximumHeight(30)\n            self.layout.setRowFixedHeight(0, 30)\n            self.titleLabel.setVisible(True)\n            self.titleLabel.setText(title, **args)\n\n    def showAxis(self, axis, show=True):\n        """"""\n        Show or hide one of the plot\'s axes.\n        axis must be one of \'left\', \'bottom\', \'right\', or \'top\'\n        """"""\n        s = self.getScale(axis)\n        p = self.axes[axis][\'pos\']\n        if show:\n            s.show()\n        else:\n            s.hide()\n            \n    def hideAxis(self, axis):\n        """"""Hide one of the PlotItem\'s axes. (\'left\', \'bottom\', \'right\', or \'top\')""""""\n        self.showAxis(axis, False)\n            \n    def showScale(self, *args, **kargs):\n        print(""Deprecated. use showAxis() instead"")\n        return self.showAxis(*args, **kargs)\n            \n    def hideButtons(self):\n        """"""Causes auto-scale button (\'A\' in lower-left corner) to be hidden for this PlotItem""""""\n        #self.ctrlBtn.hide()\n        self.buttonsHidden = True\n        self.updateButtons()\n        \n    def showButtons(self):\n        """"""Causes auto-scale button (\'A\' in lower-left corner) to be visible for this PlotItem""""""\n        #self.ctrlBtn.hide()\n        self.buttonsHidden = False\n        self.updateButtons()\n        \n    def updateButtons(self):\n        try:\n            if self._exportOpts is False and self.mouseHovering and not self.buttonsHidden and not all(self.vb.autoRangeEnabled()):\n                self.autoBtn.show()\n            else:\n                self.autoBtn.hide()\n        except RuntimeError:\n            pass  # this can happen if the plot has been deleted.\n            \n    def _plotArray(self, arr, x=None, **kargs):\n        if arr.ndim != 1:\n            raise Exception(""Array must be 1D to plot (shape is %s)"" % arr.shape)\n        if x is None:\n            x = np.arange(arr.shape[0])\n        if x.ndim != 1:\n            raise Exception(""X array must be 1D to plot (shape is %s)"" % x.shape)\n        c = PlotCurveItem(arr, x=x, **kargs)\n        return c\n        \n    def _plotMetaArray(self, arr, x=None, autoLabel=True, **kargs):\n        inf = arr.infoCopy()\n        if arr.ndim != 1:\n            raise Exception(\'can only automatically plot 1 dimensional arrays.\')\n        ## create curve\n        try:\n            xv = arr.xvals(0)\n        except:\n            if x is None:\n                xv = np.arange(arr.shape[0])\n            else:\n                xv = x\n        c = PlotCurveItem(**kargs)\n        c.setData(x=xv, y=arr.view(np.ndarray))\n        \n        if autoLabel:\n            name = arr._info[0].get(\'name\', None)\n            units = arr._info[0].get(\'units\', None)\n            self.setLabel(\'bottom\', text=name, units=units)\n            \n            name = arr._info[1].get(\'name\', None)\n            units = arr._info[1].get(\'units\', None)\n            self.setLabel(\'left\', text=name, units=units)\n            \n        return c\n      \n    def setExportMode(self, export, opts=None):\n        GraphicsWidget.setExportMode(self, export, opts)\n        self.updateButtons()\n    \n    def _chooseFilenameDialog(self, handler):\n        self.fileDialog = FileDialog()\n        if PlotItem.lastFileDir is not None:\n            self.fileDialog.setDirectory(PlotItem.lastFileDir)\n        self.fileDialog.setFileMode(QtGui.QFileDialog.AnyFile)\n        self.fileDialog.setAcceptMode(QtGui.QFileDialog.AcceptSave)\n        self.fileDialog.show()\n        self.fileDialog.fileSelected.connect(handler)\n'"
src/third_party/pyqtgraph/graphicsItems/PlotItem/__init__.py,0,b'from .PlotItem import PlotItem\n'
src/third_party/pyqtgraph/graphicsItems/PlotItem/plotConfigTemplate_pyqt.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/graphicsItems/PlotItem/plotConfigTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:51 2013\n#      by: PyQt4 UI code generator 4.10\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt4 import QtCore, QtGui\n\ntry:\n    _fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n    def _fromUtf8(s):\n        return s\n\ntry:\n    _encoding = QtGui.QApplication.UnicodeUTF8\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig, _encoding)\nexcept AttributeError:\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig)\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(""Form""))\n        Form.resize(481, 840)\n        self.averageGroup = QtGui.QGroupBox(Form)\n        self.averageGroup.setGeometry(QtCore.QRect(0, 640, 242, 182))\n        self.averageGroup.setCheckable(True)\n        self.averageGroup.setChecked(False)\n        self.averageGroup.setObjectName(_fromUtf8(""averageGroup""))\n        self.gridLayout_5 = QtGui.QGridLayout(self.averageGroup)\n        self.gridLayout_5.setMargin(0)\n        self.gridLayout_5.setSpacing(0)\n        self.gridLayout_5.setObjectName(_fromUtf8(""gridLayout_5""))\n        self.avgParamList = QtGui.QListWidget(self.averageGroup)\n        self.avgParamList.setObjectName(_fromUtf8(""avgParamList""))\n        self.gridLayout_5.addWidget(self.avgParamList, 0, 0, 1, 1)\n        self.decimateGroup = QtGui.QFrame(Form)\n        self.decimateGroup.setGeometry(QtCore.QRect(10, 140, 191, 171))\n        self.decimateGroup.setObjectName(_fromUtf8(""decimateGroup""))\n        self.gridLayout_4 = QtGui.QGridLayout(self.decimateGroup)\n        self.gridLayout_4.setMargin(0)\n        self.gridLayout_4.setSpacing(0)\n        self.gridLayout_4.setObjectName(_fromUtf8(""gridLayout_4""))\n        self.clipToViewCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.clipToViewCheck.setObjectName(_fromUtf8(""clipToViewCheck""))\n        self.gridLayout_4.addWidget(self.clipToViewCheck, 7, 0, 1, 3)\n        self.maxTracesCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.maxTracesCheck.setObjectName(_fromUtf8(""maxTracesCheck""))\n        self.gridLayout_4.addWidget(self.maxTracesCheck, 8, 0, 1, 2)\n        self.downsampleCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.downsampleCheck.setObjectName(_fromUtf8(""downsampleCheck""))\n        self.gridLayout_4.addWidget(self.downsampleCheck, 0, 0, 1, 3)\n        self.peakRadio = QtGui.QRadioButton(self.decimateGroup)\n        self.peakRadio.setChecked(True)\n        self.peakRadio.setObjectName(_fromUtf8(""peakRadio""))\n        self.gridLayout_4.addWidget(self.peakRadio, 6, 1, 1, 2)\n        self.maxTracesSpin = QtGui.QSpinBox(self.decimateGroup)\n        self.maxTracesSpin.setObjectName(_fromUtf8(""maxTracesSpin""))\n        self.gridLayout_4.addWidget(self.maxTracesSpin, 8, 2, 1, 1)\n        self.forgetTracesCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.forgetTracesCheck.setObjectName(_fromUtf8(""forgetTracesCheck""))\n        self.gridLayout_4.addWidget(self.forgetTracesCheck, 9, 0, 1, 3)\n        self.meanRadio = QtGui.QRadioButton(self.decimateGroup)\n        self.meanRadio.setObjectName(_fromUtf8(""meanRadio""))\n        self.gridLayout_4.addWidget(self.meanRadio, 3, 1, 1, 2)\n        self.subsampleRadio = QtGui.QRadioButton(self.decimateGroup)\n        self.subsampleRadio.setObjectName(_fromUtf8(""subsampleRadio""))\n        self.gridLayout_4.addWidget(self.subsampleRadio, 2, 1, 1, 2)\n        self.autoDownsampleCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.autoDownsampleCheck.setChecked(True)\n        self.autoDownsampleCheck.setObjectName(_fromUtf8(""autoDownsampleCheck""))\n        self.gridLayout_4.addWidget(self.autoDownsampleCheck, 1, 2, 1, 1)\n        spacerItem = QtGui.QSpacerItem(30, 20, QtGui.QSizePolicy.Maximum, QtGui.QSizePolicy.Minimum)\n        self.gridLayout_4.addItem(spacerItem, 2, 0, 1, 1)\n        self.downsampleSpin = QtGui.QSpinBox(self.decimateGroup)\n        self.downsampleSpin.setMinimum(1)\n        self.downsampleSpin.setMaximum(100000)\n        self.downsampleSpin.setProperty(""value"", 1)\n        self.downsampleSpin.setObjectName(_fromUtf8(""downsampleSpin""))\n        self.gridLayout_4.addWidget(self.downsampleSpin, 1, 1, 1, 1)\n        self.transformGroup = QtGui.QFrame(Form)\n        self.transformGroup.setGeometry(QtCore.QRect(0, 0, 154, 79))\n        self.transformGroup.setObjectName(_fromUtf8(""transformGroup""))\n        self.gridLayout = QtGui.QGridLayout(self.transformGroup)\n        self.gridLayout.setObjectName(_fromUtf8(""gridLayout""))\n        self.fftCheck = QtGui.QCheckBox(self.transformGroup)\n        self.fftCheck.setObjectName(_fromUtf8(""fftCheck""))\n        self.gridLayout.addWidget(self.fftCheck, 0, 0, 1, 1)\n        self.logXCheck = QtGui.QCheckBox(self.transformGroup)\n        self.logXCheck.setObjectName(_fromUtf8(""logXCheck""))\n        self.gridLayout.addWidget(self.logXCheck, 1, 0, 1, 1)\n        self.logYCheck = QtGui.QCheckBox(self.transformGroup)\n        self.logYCheck.setObjectName(_fromUtf8(""logYCheck""))\n        self.gridLayout.addWidget(self.logYCheck, 2, 0, 1, 1)\n        self.pointsGroup = QtGui.QGroupBox(Form)\n        self.pointsGroup.setGeometry(QtCore.QRect(10, 550, 234, 58))\n        self.pointsGroup.setCheckable(True)\n        self.pointsGroup.setObjectName(_fromUtf8(""pointsGroup""))\n        self.verticalLayout_5 = QtGui.QVBoxLayout(self.pointsGroup)\n        self.verticalLayout_5.setObjectName(_fromUtf8(""verticalLayout_5""))\n        self.autoPointsCheck = QtGui.QCheckBox(self.pointsGroup)\n        self.autoPointsCheck.setChecked(True)\n        self.autoPointsCheck.setObjectName(_fromUtf8(""autoPointsCheck""))\n        self.verticalLayout_5.addWidget(self.autoPointsCheck)\n        self.gridGroup = QtGui.QFrame(Form)\n        self.gridGroup.setGeometry(QtCore.QRect(10, 460, 221, 81))\n        self.gridGroup.setObjectName(_fromUtf8(""gridGroup""))\n        self.gridLayout_2 = QtGui.QGridLayout(self.gridGroup)\n        self.gridLayout_2.setObjectName(_fromUtf8(""gridLayout_2""))\n        self.xGridCheck = QtGui.QCheckBox(self.gridGroup)\n        self.xGridCheck.setObjectName(_fromUtf8(""xGridCheck""))\n        self.gridLayout_2.addWidget(self.xGridCheck, 0, 0, 1, 2)\n        self.yGridCheck = QtGui.QCheckBox(self.gridGroup)\n        self.yGridCheck.setObjectName(_fromUtf8(""yGridCheck""))\n        self.gridLayout_2.addWidget(self.yGridCheck, 1, 0, 1, 2)\n        self.gridAlphaSlider = QtGui.QSlider(self.gridGroup)\n        self.gridAlphaSlider.setMaximum(255)\n        self.gridAlphaSlider.setProperty(""value"", 128)\n        self.gridAlphaSlider.setOrientation(QtCore.Qt.Horizontal)\n        self.gridAlphaSlider.setObjectName(_fromUtf8(""gridAlphaSlider""))\n        self.gridLayout_2.addWidget(self.gridAlphaSlider, 2, 1, 1, 1)\n        self.label = QtGui.QLabel(self.gridGroup)\n        self.label.setObjectName(_fromUtf8(""label""))\n        self.gridLayout_2.addWidget(self.label, 2, 0, 1, 1)\n        self.alphaGroup = QtGui.QGroupBox(Form)\n        self.alphaGroup.setGeometry(QtCore.QRect(10, 390, 234, 60))\n        self.alphaGroup.setCheckable(True)\n        self.alphaGroup.setObjectName(_fromUtf8(""alphaGroup""))\n        self.horizontalLayout = QtGui.QHBoxLayout(self.alphaGroup)\n        self.horizontalLayout.setObjectName(_fromUtf8(""horizontalLayout""))\n        self.autoAlphaCheck = QtGui.QCheckBox(self.alphaGroup)\n        self.autoAlphaCheck.setChecked(False)\n        self.autoAlphaCheck.setObjectName(_fromUtf8(""autoAlphaCheck""))\n        self.horizontalLayout.addWidget(self.autoAlphaCheck)\n        self.alphaSlider = QtGui.QSlider(self.alphaGroup)\n        self.alphaSlider.setMaximum(1000)\n        self.alphaSlider.setProperty(""value"", 1000)\n        self.alphaSlider.setOrientation(QtCore.Qt.Horizontal)\n        self.alphaSlider.setObjectName(_fromUtf8(""alphaSlider""))\n        self.horizontalLayout.addWidget(self.alphaSlider)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(_translate(""Form"", ""Form"", None))\n        self.averageGroup.setToolTip(_translate(""Form"", ""Display averages of the curves displayed in this plot. The parameter list allows you to choose parameters to average over (if any are available)."", None))\n        self.averageGroup.setTitle(_translate(""Form"", ""Average"", None))\n        self.clipToViewCheck.setToolTip(_translate(""Form"", ""Plot only the portion of each curve that is visible. This assumes X values are uniformly spaced."", None))\n        self.clipToViewCheck.setText(_translate(""Form"", ""Clip to View"", None))\n        self.maxTracesCheck.setToolTip(_translate(""Form"", ""If multiple curves are displayed in this plot, check this box to limit the number of traces that are displayed."", None))\n        self.maxTracesCheck.setText(_translate(""Form"", ""Max Traces:"", None))\n        self.downsampleCheck.setText(_translate(""Form"", ""Downsample"", None))\n        self.peakRadio.setToolTip(_translate(""Form"", ""Downsample by drawing a saw wave that follows the min and max of the original data. This method produces the best visual representation of the data but is slower."", None))\n        self.peakRadio.setText(_translate(""Form"", ""Peak"", None))\n        self.maxTracesSpin.setToolTip(_translate(""Form"", ""If multiple curves are displayed in this plot, check \\""Max Traces\\"" and set this value to limit the number of traces that are displayed."", None))\n        self.forgetTracesCheck.setToolTip(_translate(""Form"", ""If MaxTraces is checked, remove curves from memory after they are hidden (saves memory, but traces can not be un-hidden)."", None))\n        self.forgetTracesCheck.setText(_translate(""Form"", ""Forget hidden traces"", None))\n        self.meanRadio.setToolTip(_translate(""Form"", ""Downsample by taking the mean of N samples."", None))\n        self.meanRadio.setText(_translate(""Form"", ""Mean"", None))\n        self.subsampleRadio.setToolTip(_translate(""Form"", ""Downsample by taking the first of N samples. This method is fastest and least accurate."", None))\n        self.subsampleRadio.setText(_translate(""Form"", ""Subsample"", None))\n        self.autoDownsampleCheck.setToolTip(_translate(""Form"", ""Automatically downsample data based on the visible range. This assumes X values are uniformly spaced."", None))\n        self.autoDownsampleCheck.setText(_translate(""Form"", ""Auto"", None))\n        self.downsampleSpin.setToolTip(_translate(""Form"", ""Downsample data before plotting. (plot every Nth sample)"", None))\n        self.downsampleSpin.setSuffix(_translate(""Form"", ""x"", None))\n        self.fftCheck.setText(_translate(""Form"", ""Power Spectrum (FFT)"", None))\n        self.logXCheck.setText(_translate(""Form"", ""Log X"", None))\n        self.logYCheck.setText(_translate(""Form"", ""Log Y"", None))\n        self.pointsGroup.setTitle(_translate(""Form"", ""Points"", None))\n        self.autoPointsCheck.setText(_translate(""Form"", ""Auto"", None))\n        self.xGridCheck.setText(_translate(""Form"", ""Show X Grid"", None))\n        self.yGridCheck.setText(_translate(""Form"", ""Show Y Grid"", None))\n        self.label.setText(_translate(""Form"", ""Opacity"", None))\n        self.alphaGroup.setTitle(_translate(""Form"", ""Alpha"", None))\n        self.autoAlphaCheck.setText(_translate(""Form"", ""Auto"", None))\n\n'"
src/third_party/pyqtgraph/graphicsItems/PlotItem/plotConfigTemplate_pyqt5.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/graphicsItems/PlotItem/plotConfigTemplate.ui\'\n#\n# Created: Wed Mar 26 15:09:28 2014\n#      by: PyQt5 UI code generator 5.0.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(481, 840)\n        self.averageGroup = QtWidgets.QGroupBox(Form)\n        self.averageGroup.setGeometry(QtCore.QRect(0, 640, 242, 182))\n        self.averageGroup.setCheckable(True)\n        self.averageGroup.setChecked(False)\n        self.averageGroup.setObjectName(""averageGroup"")\n        self.gridLayout_5 = QtWidgets.QGridLayout(self.averageGroup)\n        self.gridLayout_5.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_5.setSpacing(0)\n        self.gridLayout_5.setObjectName(""gridLayout_5"")\n        self.avgParamList = QtWidgets.QListWidget(self.averageGroup)\n        self.avgParamList.setObjectName(""avgParamList"")\n        self.gridLayout_5.addWidget(self.avgParamList, 0, 0, 1, 1)\n        self.decimateGroup = QtWidgets.QFrame(Form)\n        self.decimateGroup.setGeometry(QtCore.QRect(10, 140, 191, 171))\n        self.decimateGroup.setObjectName(""decimateGroup"")\n        self.gridLayout_4 = QtWidgets.QGridLayout(self.decimateGroup)\n        self.gridLayout_4.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_4.setSpacing(0)\n        self.gridLayout_4.setObjectName(""gridLayout_4"")\n        self.clipToViewCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.clipToViewCheck.setObjectName(""clipToViewCheck"")\n        self.gridLayout_4.addWidget(self.clipToViewCheck, 7, 0, 1, 3)\n        self.maxTracesCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.maxTracesCheck.setObjectName(""maxTracesCheck"")\n        self.gridLayout_4.addWidget(self.maxTracesCheck, 8, 0, 1, 2)\n        self.downsampleCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.downsampleCheck.setObjectName(""downsampleCheck"")\n        self.gridLayout_4.addWidget(self.downsampleCheck, 0, 0, 1, 3)\n        self.peakRadio = QtWidgets.QRadioButton(self.decimateGroup)\n        self.peakRadio.setChecked(True)\n        self.peakRadio.setObjectName(""peakRadio"")\n        self.gridLayout_4.addWidget(self.peakRadio, 6, 1, 1, 2)\n        self.maxTracesSpin = QtWidgets.QSpinBox(self.decimateGroup)\n        self.maxTracesSpin.setObjectName(""maxTracesSpin"")\n        self.gridLayout_4.addWidget(self.maxTracesSpin, 8, 2, 1, 1)\n        self.forgetTracesCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.forgetTracesCheck.setObjectName(""forgetTracesCheck"")\n        self.gridLayout_4.addWidget(self.forgetTracesCheck, 9, 0, 1, 3)\n        self.meanRadio = QtWidgets.QRadioButton(self.decimateGroup)\n        self.meanRadio.setObjectName(""meanRadio"")\n        self.gridLayout_4.addWidget(self.meanRadio, 3, 1, 1, 2)\n        self.subsampleRadio = QtWidgets.QRadioButton(self.decimateGroup)\n        self.subsampleRadio.setObjectName(""subsampleRadio"")\n        self.gridLayout_4.addWidget(self.subsampleRadio, 2, 1, 1, 2)\n        self.autoDownsampleCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.autoDownsampleCheck.setChecked(True)\n        self.autoDownsampleCheck.setObjectName(""autoDownsampleCheck"")\n        self.gridLayout_4.addWidget(self.autoDownsampleCheck, 1, 2, 1, 1)\n        spacerItem = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout_4.addItem(spacerItem, 2, 0, 1, 1)\n        self.downsampleSpin = QtWidgets.QSpinBox(self.decimateGroup)\n        self.downsampleSpin.setMinimum(1)\n        self.downsampleSpin.setMaximum(100000)\n        self.downsampleSpin.setProperty(""value"", 1)\n        self.downsampleSpin.setObjectName(""downsampleSpin"")\n        self.gridLayout_4.addWidget(self.downsampleSpin, 1, 1, 1, 1)\n        self.transformGroup = QtWidgets.QFrame(Form)\n        self.transformGroup.setGeometry(QtCore.QRect(0, 0, 154, 79))\n        self.transformGroup.setObjectName(""transformGroup"")\n        self.gridLayout = QtWidgets.QGridLayout(self.transformGroup)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.fftCheck = QtWidgets.QCheckBox(self.transformGroup)\n        self.fftCheck.setObjectName(""fftCheck"")\n        self.gridLayout.addWidget(self.fftCheck, 0, 0, 1, 1)\n        self.logXCheck = QtWidgets.QCheckBox(self.transformGroup)\n        self.logXCheck.setObjectName(""logXCheck"")\n        self.gridLayout.addWidget(self.logXCheck, 1, 0, 1, 1)\n        self.logYCheck = QtWidgets.QCheckBox(self.transformGroup)\n        self.logYCheck.setObjectName(""logYCheck"")\n        self.gridLayout.addWidget(self.logYCheck, 2, 0, 1, 1)\n        self.pointsGroup = QtWidgets.QGroupBox(Form)\n        self.pointsGroup.setGeometry(QtCore.QRect(10, 550, 234, 58))\n        self.pointsGroup.setCheckable(True)\n        self.pointsGroup.setObjectName(""pointsGroup"")\n        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.pointsGroup)\n        self.verticalLayout_5.setObjectName(""verticalLayout_5"")\n        self.autoPointsCheck = QtWidgets.QCheckBox(self.pointsGroup)\n        self.autoPointsCheck.setChecked(True)\n        self.autoPointsCheck.setObjectName(""autoPointsCheck"")\n        self.verticalLayout_5.addWidget(self.autoPointsCheck)\n        self.gridGroup = QtWidgets.QFrame(Form)\n        self.gridGroup.setGeometry(QtCore.QRect(10, 460, 221, 81))\n        self.gridGroup.setObjectName(""gridGroup"")\n        self.gridLayout_2 = QtWidgets.QGridLayout(self.gridGroup)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.xGridCheck = QtWidgets.QCheckBox(self.gridGroup)\n        self.xGridCheck.setObjectName(""xGridCheck"")\n        self.gridLayout_2.addWidget(self.xGridCheck, 0, 0, 1, 2)\n        self.yGridCheck = QtWidgets.QCheckBox(self.gridGroup)\n        self.yGridCheck.setObjectName(""yGridCheck"")\n        self.gridLayout_2.addWidget(self.yGridCheck, 1, 0, 1, 2)\n        self.gridAlphaSlider = QtWidgets.QSlider(self.gridGroup)\n        self.gridAlphaSlider.setMaximum(255)\n        self.gridAlphaSlider.setProperty(""value"", 128)\n        self.gridAlphaSlider.setOrientation(QtCore.Qt.Horizontal)\n        self.gridAlphaSlider.setObjectName(""gridAlphaSlider"")\n        self.gridLayout_2.addWidget(self.gridAlphaSlider, 2, 1, 1, 1)\n        self.label = QtWidgets.QLabel(self.gridGroup)\n        self.label.setObjectName(""label"")\n        self.gridLayout_2.addWidget(self.label, 2, 0, 1, 1)\n        self.alphaGroup = QtWidgets.QGroupBox(Form)\n        self.alphaGroup.setGeometry(QtCore.QRect(10, 390, 234, 60))\n        self.alphaGroup.setCheckable(True)\n        self.alphaGroup.setObjectName(""alphaGroup"")\n        self.horizontalLayout = QtWidgets.QHBoxLayout(self.alphaGroup)\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.autoAlphaCheck = QtWidgets.QCheckBox(self.alphaGroup)\n        self.autoAlphaCheck.setChecked(False)\n        self.autoAlphaCheck.setObjectName(""autoAlphaCheck"")\n        self.horizontalLayout.addWidget(self.autoAlphaCheck)\n        self.alphaSlider = QtWidgets.QSlider(self.alphaGroup)\n        self.alphaSlider.setMaximum(1000)\n        self.alphaSlider.setProperty(""value"", 1000)\n        self.alphaSlider.setOrientation(QtCore.Qt.Horizontal)\n        self.alphaSlider.setObjectName(""alphaSlider"")\n        self.horizontalLayout.addWidget(self.alphaSlider)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Form""))\n        self.averageGroup.setToolTip(_translate(""Form"", ""Display averages of the curves displayed in this plot. The parameter list allows you to choose parameters to average over (if any are available).""))\n        self.averageGroup.setTitle(_translate(""Form"", ""Average""))\n        self.clipToViewCheck.setToolTip(_translate(""Form"", ""Plot only the portion of each curve that is visible. This assumes X values are uniformly spaced.""))\n        self.clipToViewCheck.setText(_translate(""Form"", ""Clip to View""))\n        self.maxTracesCheck.setToolTip(_translate(""Form"", ""If multiple curves are displayed in this plot, check this box to limit the number of traces that are displayed.""))\n        self.maxTracesCheck.setText(_translate(""Form"", ""Max Traces:""))\n        self.downsampleCheck.setText(_translate(""Form"", ""Downsample""))\n        self.peakRadio.setToolTip(_translate(""Form"", ""Downsample by drawing a saw wave that follows the min and max of the original data. This method produces the best visual representation of the data but is slower.""))\n        self.peakRadio.setText(_translate(""Form"", ""Peak""))\n        self.maxTracesSpin.setToolTip(_translate(""Form"", ""If multiple curves are displayed in this plot, check \\""Max Traces\\"" and set this value to limit the number of traces that are displayed.""))\n        self.forgetTracesCheck.setToolTip(_translate(""Form"", ""If MaxTraces is checked, remove curves from memory after they are hidden (saves memory, but traces can not be un-hidden).""))\n        self.forgetTracesCheck.setText(_translate(""Form"", ""Forget hidden traces""))\n        self.meanRadio.setToolTip(_translate(""Form"", ""Downsample by taking the mean of N samples.""))\n        self.meanRadio.setText(_translate(""Form"", ""Mean""))\n        self.subsampleRadio.setToolTip(_translate(""Form"", ""Downsample by taking the first of N samples. This method is fastest and least accurate.""))\n        self.subsampleRadio.setText(_translate(""Form"", ""Subsample""))\n        self.autoDownsampleCheck.setToolTip(_translate(""Form"", ""Automatically downsample data based on the visible range. This assumes X values are uniformly spaced.""))\n        self.autoDownsampleCheck.setText(_translate(""Form"", ""Auto""))\n        self.downsampleSpin.setToolTip(_translate(""Form"", ""Downsample data before plotting. (plot every Nth sample)""))\n        self.downsampleSpin.setSuffix(_translate(""Form"", ""x""))\n        self.fftCheck.setText(_translate(""Form"", ""Power Spectrum (FFT)""))\n        self.logXCheck.setText(_translate(""Form"", ""Log X""))\n        self.logYCheck.setText(_translate(""Form"", ""Log Y""))\n        self.pointsGroup.setTitle(_translate(""Form"", ""Points""))\n        self.autoPointsCheck.setText(_translate(""Form"", ""Auto""))\n        self.xGridCheck.setText(_translate(""Form"", ""Show X Grid""))\n        self.yGridCheck.setText(_translate(""Form"", ""Show Y Grid""))\n        self.label.setText(_translate(""Form"", ""Opacity""))\n        self.alphaGroup.setTitle(_translate(""Form"", ""Alpha""))\n        self.autoAlphaCheck.setText(_translate(""Form"", ""Auto""))\n\n'"
src/third_party/pyqtgraph/graphicsItems/PlotItem/plotConfigTemplate_pyside.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/graphicsItems/PlotItem/plotConfigTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:52 2013\n#      by: pyside-uic 0.2.14 running on PySide 1.1.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide import QtCore, QtGui\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(481, 840)\n        self.averageGroup = QtGui.QGroupBox(Form)\n        self.averageGroup.setGeometry(QtCore.QRect(0, 640, 242, 182))\n        self.averageGroup.setCheckable(True)\n        self.averageGroup.setChecked(False)\n        self.averageGroup.setObjectName(""averageGroup"")\n        self.gridLayout_5 = QtGui.QGridLayout(self.averageGroup)\n        self.gridLayout_5.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_5.setSpacing(0)\n        self.gridLayout_5.setObjectName(""gridLayout_5"")\n        self.avgParamList = QtGui.QListWidget(self.averageGroup)\n        self.avgParamList.setObjectName(""avgParamList"")\n        self.gridLayout_5.addWidget(self.avgParamList, 0, 0, 1, 1)\n        self.decimateGroup = QtGui.QFrame(Form)\n        self.decimateGroup.setGeometry(QtCore.QRect(10, 140, 191, 171))\n        self.decimateGroup.setObjectName(""decimateGroup"")\n        self.gridLayout_4 = QtGui.QGridLayout(self.decimateGroup)\n        self.gridLayout_4.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_4.setSpacing(0)\n        self.gridLayout_4.setObjectName(""gridLayout_4"")\n        self.clipToViewCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.clipToViewCheck.setObjectName(""clipToViewCheck"")\n        self.gridLayout_4.addWidget(self.clipToViewCheck, 7, 0, 1, 3)\n        self.maxTracesCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.maxTracesCheck.setObjectName(""maxTracesCheck"")\n        self.gridLayout_4.addWidget(self.maxTracesCheck, 8, 0, 1, 2)\n        self.downsampleCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.downsampleCheck.setObjectName(""downsampleCheck"")\n        self.gridLayout_4.addWidget(self.downsampleCheck, 0, 0, 1, 3)\n        self.peakRadio = QtGui.QRadioButton(self.decimateGroup)\n        self.peakRadio.setChecked(True)\n        self.peakRadio.setObjectName(""peakRadio"")\n        self.gridLayout_4.addWidget(self.peakRadio, 6, 1, 1, 2)\n        self.maxTracesSpin = QtGui.QSpinBox(self.decimateGroup)\n        self.maxTracesSpin.setObjectName(""maxTracesSpin"")\n        self.gridLayout_4.addWidget(self.maxTracesSpin, 8, 2, 1, 1)\n        self.forgetTracesCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.forgetTracesCheck.setObjectName(""forgetTracesCheck"")\n        self.gridLayout_4.addWidget(self.forgetTracesCheck, 9, 0, 1, 3)\n        self.meanRadio = QtGui.QRadioButton(self.decimateGroup)\n        self.meanRadio.setObjectName(""meanRadio"")\n        self.gridLayout_4.addWidget(self.meanRadio, 3, 1, 1, 2)\n        self.subsampleRadio = QtGui.QRadioButton(self.decimateGroup)\n        self.subsampleRadio.setObjectName(""subsampleRadio"")\n        self.gridLayout_4.addWidget(self.subsampleRadio, 2, 1, 1, 2)\n        self.autoDownsampleCheck = QtGui.QCheckBox(self.decimateGroup)\n        self.autoDownsampleCheck.setChecked(True)\n        self.autoDownsampleCheck.setObjectName(""autoDownsampleCheck"")\n        self.gridLayout_4.addWidget(self.autoDownsampleCheck, 1, 2, 1, 1)\n        spacerItem = QtGui.QSpacerItem(30, 20, QtGui.QSizePolicy.Maximum, QtGui.QSizePolicy.Minimum)\n        self.gridLayout_4.addItem(spacerItem, 2, 0, 1, 1)\n        self.downsampleSpin = QtGui.QSpinBox(self.decimateGroup)\n        self.downsampleSpin.setMinimum(1)\n        self.downsampleSpin.setMaximum(100000)\n        self.downsampleSpin.setProperty(""value"", 1)\n        self.downsampleSpin.setObjectName(""downsampleSpin"")\n        self.gridLayout_4.addWidget(self.downsampleSpin, 1, 1, 1, 1)\n        self.transformGroup = QtGui.QFrame(Form)\n        self.transformGroup.setGeometry(QtCore.QRect(0, 0, 154, 79))\n        self.transformGroup.setObjectName(""transformGroup"")\n        self.gridLayout = QtGui.QGridLayout(self.transformGroup)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.fftCheck = QtGui.QCheckBox(self.transformGroup)\n        self.fftCheck.setObjectName(""fftCheck"")\n        self.gridLayout.addWidget(self.fftCheck, 0, 0, 1, 1)\n        self.logXCheck = QtGui.QCheckBox(self.transformGroup)\n        self.logXCheck.setObjectName(""logXCheck"")\n        self.gridLayout.addWidget(self.logXCheck, 1, 0, 1, 1)\n        self.logYCheck = QtGui.QCheckBox(self.transformGroup)\n        self.logYCheck.setObjectName(""logYCheck"")\n        self.gridLayout.addWidget(self.logYCheck, 2, 0, 1, 1)\n        self.pointsGroup = QtGui.QGroupBox(Form)\n        self.pointsGroup.setGeometry(QtCore.QRect(10, 550, 234, 58))\n        self.pointsGroup.setCheckable(True)\n        self.pointsGroup.setObjectName(""pointsGroup"")\n        self.verticalLayout_5 = QtGui.QVBoxLayout(self.pointsGroup)\n        self.verticalLayout_5.setObjectName(""verticalLayout_5"")\n        self.autoPointsCheck = QtGui.QCheckBox(self.pointsGroup)\n        self.autoPointsCheck.setChecked(True)\n        self.autoPointsCheck.setObjectName(""autoPointsCheck"")\n        self.verticalLayout_5.addWidget(self.autoPointsCheck)\n        self.gridGroup = QtGui.QFrame(Form)\n        self.gridGroup.setGeometry(QtCore.QRect(10, 460, 221, 81))\n        self.gridGroup.setObjectName(""gridGroup"")\n        self.gridLayout_2 = QtGui.QGridLayout(self.gridGroup)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.xGridCheck = QtGui.QCheckBox(self.gridGroup)\n        self.xGridCheck.setObjectName(""xGridCheck"")\n        self.gridLayout_2.addWidget(self.xGridCheck, 0, 0, 1, 2)\n        self.yGridCheck = QtGui.QCheckBox(self.gridGroup)\n        self.yGridCheck.setObjectName(""yGridCheck"")\n        self.gridLayout_2.addWidget(self.yGridCheck, 1, 0, 1, 2)\n        self.gridAlphaSlider = QtGui.QSlider(self.gridGroup)\n        self.gridAlphaSlider.setMaximum(255)\n        self.gridAlphaSlider.setProperty(""value"", 128)\n        self.gridAlphaSlider.setOrientation(QtCore.Qt.Horizontal)\n        self.gridAlphaSlider.setObjectName(""gridAlphaSlider"")\n        self.gridLayout_2.addWidget(self.gridAlphaSlider, 2, 1, 1, 1)\n        self.label = QtGui.QLabel(self.gridGroup)\n        self.label.setObjectName(""label"")\n        self.gridLayout_2.addWidget(self.label, 2, 0, 1, 1)\n        self.alphaGroup = QtGui.QGroupBox(Form)\n        self.alphaGroup.setGeometry(QtCore.QRect(10, 390, 234, 60))\n        self.alphaGroup.setCheckable(True)\n        self.alphaGroup.setObjectName(""alphaGroup"")\n        self.horizontalLayout = QtGui.QHBoxLayout(self.alphaGroup)\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.autoAlphaCheck = QtGui.QCheckBox(self.alphaGroup)\n        self.autoAlphaCheck.setChecked(False)\n        self.autoAlphaCheck.setObjectName(""autoAlphaCheck"")\n        self.horizontalLayout.addWidget(self.autoAlphaCheck)\n        self.alphaSlider = QtGui.QSlider(self.alphaGroup)\n        self.alphaSlider.setMaximum(1000)\n        self.alphaSlider.setProperty(""value"", 1000)\n        self.alphaSlider.setOrientation(QtCore.Qt.Horizontal)\n        self.alphaSlider.setObjectName(""alphaSlider"")\n        self.horizontalLayout.addWidget(self.alphaSlider)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtGui.QApplication.translate(""Form"", ""Form"", None, QtGui.QApplication.UnicodeUTF8))\n        self.averageGroup.setToolTip(QtGui.QApplication.translate(""Form"", ""Display averages of the curves displayed in this plot. The parameter list allows you to choose parameters to average over (if any are available)."", None, QtGui.QApplication.UnicodeUTF8))\n        self.averageGroup.setTitle(QtGui.QApplication.translate(""Form"", ""Average"", None, QtGui.QApplication.UnicodeUTF8))\n        self.clipToViewCheck.setToolTip(QtGui.QApplication.translate(""Form"", ""Plot only the portion of each curve that is visible. This assumes X values are uniformly spaced."", None, QtGui.QApplication.UnicodeUTF8))\n        self.clipToViewCheck.setText(QtGui.QApplication.translate(""Form"", ""Clip to View"", None, QtGui.QApplication.UnicodeUTF8))\n        self.maxTracesCheck.setToolTip(QtGui.QApplication.translate(""Form"", ""If multiple curves are displayed in this plot, check this box to limit the number of traces that are displayed."", None, QtGui.QApplication.UnicodeUTF8))\n        self.maxTracesCheck.setText(QtGui.QApplication.translate(""Form"", ""Max Traces:"", None, QtGui.QApplication.UnicodeUTF8))\n        self.downsampleCheck.setText(QtGui.QApplication.translate(""Form"", ""Downsample"", None, QtGui.QApplication.UnicodeUTF8))\n        self.peakRadio.setToolTip(QtGui.QApplication.translate(""Form"", ""Downsample by drawing a saw wave that follows the min and max of the original data. This method produces the best visual representation of the data but is slower."", None, QtGui.QApplication.UnicodeUTF8))\n        self.peakRadio.setText(QtGui.QApplication.translate(""Form"", ""Peak"", None, QtGui.QApplication.UnicodeUTF8))\n        self.maxTracesSpin.setToolTip(QtGui.QApplication.translate(""Form"", ""If multiple curves are displayed in this plot, check \\""Max Traces\\"" and set this value to limit the number of traces that are displayed."", None, QtGui.QApplication.UnicodeUTF8))\n        self.forgetTracesCheck.setToolTip(QtGui.QApplication.translate(""Form"", ""If MaxTraces is checked, remove curves from memory after they are hidden (saves memory, but traces can not be un-hidden)."", None, QtGui.QApplication.UnicodeUTF8))\n        self.forgetTracesCheck.setText(QtGui.QApplication.translate(""Form"", ""Forget hidden traces"", None, QtGui.QApplication.UnicodeUTF8))\n        self.meanRadio.setToolTip(QtGui.QApplication.translate(""Form"", ""Downsample by taking the mean of N samples."", None, QtGui.QApplication.UnicodeUTF8))\n        self.meanRadio.setText(QtGui.QApplication.translate(""Form"", ""Mean"", None, QtGui.QApplication.UnicodeUTF8))\n        self.subsampleRadio.setToolTip(QtGui.QApplication.translate(""Form"", ""Downsample by taking the first of N samples. This method is fastest and least accurate."", None, QtGui.QApplication.UnicodeUTF8))\n        self.subsampleRadio.setText(QtGui.QApplication.translate(""Form"", ""Subsample"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoDownsampleCheck.setToolTip(QtGui.QApplication.translate(""Form"", ""Automatically downsample data based on the visible range. This assumes X values are uniformly spaced."", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoDownsampleCheck.setText(QtGui.QApplication.translate(""Form"", ""Auto"", None, QtGui.QApplication.UnicodeUTF8))\n        self.downsampleSpin.setToolTip(QtGui.QApplication.translate(""Form"", ""Downsample data before plotting. (plot every Nth sample)"", None, QtGui.QApplication.UnicodeUTF8))\n        self.downsampleSpin.setSuffix(QtGui.QApplication.translate(""Form"", ""x"", None, QtGui.QApplication.UnicodeUTF8))\n        self.fftCheck.setText(QtGui.QApplication.translate(""Form"", ""Power Spectrum (FFT)"", None, QtGui.QApplication.UnicodeUTF8))\n        self.logXCheck.setText(QtGui.QApplication.translate(""Form"", ""Log X"", None, QtGui.QApplication.UnicodeUTF8))\n        self.logYCheck.setText(QtGui.QApplication.translate(""Form"", ""Log Y"", None, QtGui.QApplication.UnicodeUTF8))\n        self.pointsGroup.setTitle(QtGui.QApplication.translate(""Form"", ""Points"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoPointsCheck.setText(QtGui.QApplication.translate(""Form"", ""Auto"", None, QtGui.QApplication.UnicodeUTF8))\n        self.xGridCheck.setText(QtGui.QApplication.translate(""Form"", ""Show X Grid"", None, QtGui.QApplication.UnicodeUTF8))\n        self.yGridCheck.setText(QtGui.QApplication.translate(""Form"", ""Show Y Grid"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label.setText(QtGui.QApplication.translate(""Form"", ""Opacity"", None, QtGui.QApplication.UnicodeUTF8))\n        self.alphaGroup.setTitle(QtGui.QApplication.translate(""Form"", ""Alpha"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoAlphaCheck.setText(QtGui.QApplication.translate(""Form"", ""Auto"", None, QtGui.QApplication.UnicodeUTF8))\n\n'"
src/third_party/pyqtgraph/graphicsItems/PlotItem/plotConfigTemplate_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/graphicsItems/PlotItem/plotConfigTemplate.ui\'\n#\n# Created: Wed Mar 26 15:09:28 2014\n#      by: PyQt5 UI code generator 5.0.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide2 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(481, 840)\n        self.averageGroup = QtWidgets.QGroupBox(Form)\n        self.averageGroup.setGeometry(QtCore.QRect(0, 640, 242, 182))\n        self.averageGroup.setCheckable(True)\n        self.averageGroup.setChecked(False)\n        self.averageGroup.setObjectName(""averageGroup"")\n        self.gridLayout_5 = QtWidgets.QGridLayout(self.averageGroup)\n        self.gridLayout_5.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_5.setSpacing(0)\n        self.gridLayout_5.setObjectName(""gridLayout_5"")\n        self.avgParamList = QtWidgets.QListWidget(self.averageGroup)\n        self.avgParamList.setObjectName(""avgParamList"")\n        self.gridLayout_5.addWidget(self.avgParamList, 0, 0, 1, 1)\n        self.decimateGroup = QtWidgets.QFrame(Form)\n        self.decimateGroup.setGeometry(QtCore.QRect(10, 140, 191, 171))\n        self.decimateGroup.setObjectName(""decimateGroup"")\n        self.gridLayout_4 = QtWidgets.QGridLayout(self.decimateGroup)\n        self.gridLayout_4.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_4.setSpacing(0)\n        self.gridLayout_4.setObjectName(""gridLayout_4"")\n        self.clipToViewCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.clipToViewCheck.setObjectName(""clipToViewCheck"")\n        self.gridLayout_4.addWidget(self.clipToViewCheck, 7, 0, 1, 3)\n        self.maxTracesCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.maxTracesCheck.setObjectName(""maxTracesCheck"")\n        self.gridLayout_4.addWidget(self.maxTracesCheck, 8, 0, 1, 2)\n        self.downsampleCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.downsampleCheck.setObjectName(""downsampleCheck"")\n        self.gridLayout_4.addWidget(self.downsampleCheck, 0, 0, 1, 3)\n        self.peakRadio = QtWidgets.QRadioButton(self.decimateGroup)\n        self.peakRadio.setChecked(True)\n        self.peakRadio.setObjectName(""peakRadio"")\n        self.gridLayout_4.addWidget(self.peakRadio, 6, 1, 1, 2)\n        self.maxTracesSpin = QtWidgets.QSpinBox(self.decimateGroup)\n        self.maxTracesSpin.setObjectName(""maxTracesSpin"")\n        self.gridLayout_4.addWidget(self.maxTracesSpin, 8, 2, 1, 1)\n        self.forgetTracesCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.forgetTracesCheck.setObjectName(""forgetTracesCheck"")\n        self.gridLayout_4.addWidget(self.forgetTracesCheck, 9, 0, 1, 3)\n        self.meanRadio = QtWidgets.QRadioButton(self.decimateGroup)\n        self.meanRadio.setObjectName(""meanRadio"")\n        self.gridLayout_4.addWidget(self.meanRadio, 3, 1, 1, 2)\n        self.subsampleRadio = QtWidgets.QRadioButton(self.decimateGroup)\n        self.subsampleRadio.setObjectName(""subsampleRadio"")\n        self.gridLayout_4.addWidget(self.subsampleRadio, 2, 1, 1, 2)\n        self.autoDownsampleCheck = QtWidgets.QCheckBox(self.decimateGroup)\n        self.autoDownsampleCheck.setChecked(True)\n        self.autoDownsampleCheck.setObjectName(""autoDownsampleCheck"")\n        self.gridLayout_4.addWidget(self.autoDownsampleCheck, 1, 2, 1, 1)\n        spacerItem = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout_4.addItem(spacerItem, 2, 0, 1, 1)\n        self.downsampleSpin = QtWidgets.QSpinBox(self.decimateGroup)\n        self.downsampleSpin.setMinimum(1)\n        self.downsampleSpin.setMaximum(100000)\n        self.downsampleSpin.setProperty(""value"", 1)\n        self.downsampleSpin.setObjectName(""downsampleSpin"")\n        self.gridLayout_4.addWidget(self.downsampleSpin, 1, 1, 1, 1)\n        self.transformGroup = QtWidgets.QFrame(Form)\n        self.transformGroup.setGeometry(QtCore.QRect(0, 0, 154, 79))\n        self.transformGroup.setObjectName(""transformGroup"")\n        self.gridLayout = QtWidgets.QGridLayout(self.transformGroup)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.fftCheck = QtWidgets.QCheckBox(self.transformGroup)\n        self.fftCheck.setObjectName(""fftCheck"")\n        self.gridLayout.addWidget(self.fftCheck, 0, 0, 1, 1)\n        self.logXCheck = QtWidgets.QCheckBox(self.transformGroup)\n        self.logXCheck.setObjectName(""logXCheck"")\n        self.gridLayout.addWidget(self.logXCheck, 1, 0, 1, 1)\n        self.logYCheck = QtWidgets.QCheckBox(self.transformGroup)\n        self.logYCheck.setObjectName(""logYCheck"")\n        self.gridLayout.addWidget(self.logYCheck, 2, 0, 1, 1)\n        self.pointsGroup = QtWidgets.QGroupBox(Form)\n        self.pointsGroup.setGeometry(QtCore.QRect(10, 550, 234, 58))\n        self.pointsGroup.setCheckable(True)\n        self.pointsGroup.setObjectName(""pointsGroup"")\n        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.pointsGroup)\n        self.verticalLayout_5.setObjectName(""verticalLayout_5"")\n        self.autoPointsCheck = QtWidgets.QCheckBox(self.pointsGroup)\n        self.autoPointsCheck.setChecked(True)\n        self.autoPointsCheck.setObjectName(""autoPointsCheck"")\n        self.verticalLayout_5.addWidget(self.autoPointsCheck)\n        self.gridGroup = QtWidgets.QFrame(Form)\n        self.gridGroup.setGeometry(QtCore.QRect(10, 460, 221, 81))\n        self.gridGroup.setObjectName(""gridGroup"")\n        self.gridLayout_2 = QtWidgets.QGridLayout(self.gridGroup)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.xGridCheck = QtWidgets.QCheckBox(self.gridGroup)\n        self.xGridCheck.setObjectName(""xGridCheck"")\n        self.gridLayout_2.addWidget(self.xGridCheck, 0, 0, 1, 2)\n        self.yGridCheck = QtWidgets.QCheckBox(self.gridGroup)\n        self.yGridCheck.setObjectName(""yGridCheck"")\n        self.gridLayout_2.addWidget(self.yGridCheck, 1, 0, 1, 2)\n        self.gridAlphaSlider = QtWidgets.QSlider(self.gridGroup)\n        self.gridAlphaSlider.setMaximum(255)\n        self.gridAlphaSlider.setProperty(""value"", 128)\n        self.gridAlphaSlider.setOrientation(QtCore.Qt.Horizontal)\n        self.gridAlphaSlider.setObjectName(""gridAlphaSlider"")\n        self.gridLayout_2.addWidget(self.gridAlphaSlider, 2, 1, 1, 1)\n        self.label = QtWidgets.QLabel(self.gridGroup)\n        self.label.setObjectName(""label"")\n        self.gridLayout_2.addWidget(self.label, 2, 0, 1, 1)\n        self.alphaGroup = QtWidgets.QGroupBox(Form)\n        self.alphaGroup.setGeometry(QtCore.QRect(10, 390, 234, 60))\n        self.alphaGroup.setCheckable(True)\n        self.alphaGroup.setObjectName(""alphaGroup"")\n        self.horizontalLayout = QtWidgets.QHBoxLayout(self.alphaGroup)\n        self.horizontalLayout.setObjectName(""horizontalLayout"")\n        self.autoAlphaCheck = QtWidgets.QCheckBox(self.alphaGroup)\n        self.autoAlphaCheck.setChecked(False)\n        self.autoAlphaCheck.setObjectName(""autoAlphaCheck"")\n        self.horizontalLayout.addWidget(self.autoAlphaCheck)\n        self.alphaSlider = QtWidgets.QSlider(self.alphaGroup)\n        self.alphaSlider.setMaximum(1000)\n        self.alphaSlider.setProperty(""value"", 1000)\n        self.alphaSlider.setOrientation(QtCore.Qt.Horizontal)\n        self.alphaSlider.setObjectName(""alphaSlider"")\n        self.horizontalLayout.addWidget(self.alphaSlider)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Form""))\n        self.averageGroup.setToolTip(_translate(""Form"", ""Display averages of the curves displayed in this plot. The parameter list allows you to choose parameters to average over (if any are available).""))\n        self.averageGroup.setTitle(_translate(""Form"", ""Average""))\n        self.clipToViewCheck.setToolTip(_translate(""Form"", ""Plot only the portion of each curve that is visible. This assumes X values are uniformly spaced.""))\n        self.clipToViewCheck.setText(_translate(""Form"", ""Clip to View""))\n        self.maxTracesCheck.setToolTip(_translate(""Form"", ""If multiple curves are displayed in this plot, check this box to limit the number of traces that are displayed.""))\n        self.maxTracesCheck.setText(_translate(""Form"", ""Max Traces:""))\n        self.downsampleCheck.setText(_translate(""Form"", ""Downsample""))\n        self.peakRadio.setToolTip(_translate(""Form"", ""Downsample by drawing a saw wave that follows the min and max of the original data. This method produces the best visual representation of the data but is slower.""))\n        self.peakRadio.setText(_translate(""Form"", ""Peak""))\n        self.maxTracesSpin.setToolTip(_translate(""Form"", ""If multiple curves are displayed in this plot, check \\""Max Traces\\"" and set this value to limit the number of traces that are displayed.""))\n        self.forgetTracesCheck.setToolTip(_translate(""Form"", ""If MaxTraces is checked, remove curves from memory after they are hidden (saves memory, but traces can not be un-hidden).""))\n        self.forgetTracesCheck.setText(_translate(""Form"", ""Forget hidden traces""))\n        self.meanRadio.setToolTip(_translate(""Form"", ""Downsample by taking the mean of N samples.""))\n        self.meanRadio.setText(_translate(""Form"", ""Mean""))\n        self.subsampleRadio.setToolTip(_translate(""Form"", ""Downsample by taking the first of N samples. This method is fastest and least accurate.""))\n        self.subsampleRadio.setText(_translate(""Form"", ""Subsample""))\n        self.autoDownsampleCheck.setToolTip(_translate(""Form"", ""Automatically downsample data based on the visible range. This assumes X values are uniformly spaced.""))\n        self.autoDownsampleCheck.setText(_translate(""Form"", ""Auto""))\n        self.downsampleSpin.setToolTip(_translate(""Form"", ""Downsample data before plotting. (plot every Nth sample)""))\n        self.downsampleSpin.setSuffix(_translate(""Form"", ""x""))\n        self.fftCheck.setText(_translate(""Form"", ""Power Spectrum (FFT)""))\n        self.logXCheck.setText(_translate(""Form"", ""Log X""))\n        self.logYCheck.setText(_translate(""Form"", ""Log Y""))\n        self.pointsGroup.setTitle(_translate(""Form"", ""Points""))\n        self.autoPointsCheck.setText(_translate(""Form"", ""Auto""))\n        self.xGridCheck.setText(_translate(""Form"", ""Show X Grid""))\n        self.yGridCheck.setText(_translate(""Form"", ""Show Y Grid""))\n        self.label.setText(_translate(""Form"", ""Opacity""))\n        self.alphaGroup.setTitle(_translate(""Form"", ""Alpha""))\n        self.autoAlphaCheck.setText(_translate(""Form"", ""Auto""))\n\n'"
src/third_party/pyqtgraph/graphicsItems/ViewBox/ViewBox.py,7,"b'import weakref\nimport sys\nfrom copy import deepcopy\nimport numpy as np\nfrom ...Qt import QtGui, QtCore\nfrom ...python2_3 import sortList, basestring, cmp\nfrom ...Point import Point\nfrom ... import functions as fn\nfrom .. ItemGroup import ItemGroup\nfrom .. GraphicsWidget import GraphicsWidget\nfrom ... import debug as debug\nfrom ... import getConfigOption\nfrom ...Qt import isQObjectAlive\n\n__all__ = [\'ViewBox\']\n\nclass WeakList(object):\n\n    def __init__(self):\n        self._items = []\n\n    def append(self, obj):\n        #Add backwards to iterate backwards (to make iterating more efficient on removal).\n        self._items.insert(0, weakref.ref(obj))\n\n    def __iter__(self):\n        i = len(self._items)-1\n        while i >= 0:\n            ref = self._items[i]\n            d = ref()\n            if d is None:\n                del self._items[i]\n            else:\n                yield d\n            i -= 1\n\nclass ChildGroup(ItemGroup):\n    \n    def __init__(self, parent):\n        ItemGroup.__init__(self, parent)\n        \n        # Used as callback to inform ViewBox when items are added/removed from \n        # the group. \n        # Note 1: We would prefer to override itemChange directly on the \n        #         ViewBox, but this causes crashes on PySide.\n        # Note 2: We might also like to use a signal rather than this callback\n        #         mechanism, but this causes a different PySide crash.        \n        self.itemsChangedListeners = WeakList()\n \n        # excempt from telling view when transform changes\n        self._GraphicsObject__inform_view_on_change = False\n    \n    def itemChange(self, change, value):\n        ret = ItemGroup.itemChange(self, change, value)\n        if change == self.ItemChildAddedChange or change == self.ItemChildRemovedChange:\n            try:\n                itemsChangedListeners = self.itemsChangedListeners\n            except AttributeError:\n                # It\'s possible that the attribute was already collected when the itemChange happened\n                # (if it was triggered during the gc of the object).\n                pass\n            else:\n                for listener in itemsChangedListeners:\n                    listener.itemsChanged()\n        return ret\n\n\nclass ViewBox(GraphicsWidget):\n    """"""\n    **Bases:** :class:`GraphicsWidget <pyqtgraph.GraphicsWidget>`\n    \n    Box that allows internal scaling/panning of children by mouse drag. \n    This class is usually created automatically as part of a :class:`PlotItem <pyqtgraph.PlotItem>` or :class:`Canvas <pyqtgraph.canvas.Canvas>` or with :func:`GraphicsLayout.addViewBox() <pyqtgraph.GraphicsLayout.addViewBox>`.\n    \n    Features:\n    \n    * Scaling contents by mouse or auto-scale when contents change\n    * View linking--multiple views display the same data ranges\n    * Configurable by context menu\n    * Item coordinate mapping methods\n    \n    """"""\n    \n    sigYRangeChanged = QtCore.Signal(object, object)\n    sigXRangeChanged = QtCore.Signal(object, object)\n    sigRangeChangedManually = QtCore.Signal(object)\n    sigRangeChanged = QtCore.Signal(object, object)\n    sigStateChanged = QtCore.Signal(object)\n    sigTransformChanged = QtCore.Signal(object)\n    sigResized = QtCore.Signal(object)\n    \n    ## mouse modes\n    PanMode = 3\n    RectMode = 1\n    \n    ## axes\n    XAxis = 0\n    YAxis = 1\n    XYAxes = 2\n    \n    ## for linking views together\n    NamedViews = weakref.WeakValueDictionary()   # name: ViewBox\n    AllViews = weakref.WeakKeyDictionary()       # ViewBox: None\n    \n    def __init__(self, parent=None, border=None, lockAspect=False, enableMouse=True, invertY=False, enableMenu=True, name=None, invertX=False):\n        """"""\n        ==============  =============================================================\n        **Arguments:**\n        *parent*        (QGraphicsWidget) Optional parent widget\n        *border*        (QPen) Do draw a border around the view, give any\n                        single argument accepted by :func:`mkPen <pyqtgraph.mkPen>`\n        *lockAspect*    (False or float) The aspect ratio to lock the view\n                        coorinates to. (or False to allow the ratio to change)\n        *enableMouse*   (bool) Whether mouse can be used to scale/pan the view\n        *invertY*       (bool) See :func:`invertY <pyqtgraph.ViewBox.invertY>`\n        *invertX*       (bool) See :func:`invertX <pyqtgraph.ViewBox.invertX>`\n        *enableMenu*    (bool) Whether to display a context menu when \n                        right-clicking on the ViewBox background.\n        *name*          (str) Used to register this ViewBox so that it appears\n                        in the ""Link axis"" dropdown inside other ViewBox\n                        context menus. This allows the user to manually link\n                        the axes of any other view to this one. \n        ==============  =============================================================\n        """"""\n        \n        GraphicsWidget.__init__(self, parent)\n        self.name = None\n        self.linksBlocked = False\n        self.addedItems = []\n        self._matrixNeedsUpdate = True  ## indicates that range has changed, but matrix update was deferred\n        self._autoRangeNeedsUpdate = True ## indicates auto-range needs to be recomputed.\n\n        self._lastScene = None  ## stores reference to the last known scene this view was a part of.\n        \n        self.state = {\n            \n            ## separating targetRange and viewRange allows the view to be resized\n            ## while keeping all previously viewed contents visible\n            \'targetRange\': [[0,1], [0,1]],   ## child coord. range visible [[xmin, xmax], [ymin, ymax]]\n            \'viewRange\': [[0,1], [0,1]],     ## actual range viewed\n        \n            \'yInverted\': invertY,\n            \'xInverted\': invertX,\n            \'aspectLocked\': False,    ## False if aspect is unlocked, otherwise float specifies the locked ratio.\n            \'autoRange\': [True, True],  ## False if auto range is disabled, \n                                          ## otherwise float gives the fraction of data that is visible\n            \'autoPan\': [False, False],         ## whether to only pan (do not change scaling) when auto-range is enabled\n            \'autoVisibleOnly\': [False, False], ## whether to auto-range only to the visible portion of a plot \n            \'linkedViews\': [None, None],  ## may be None, ""viewName"", or weakref.ref(view)\n                                          ## a name string indicates that the view *should* link to another, but no view with that name exists yet.\n            \n            \'mouseEnabled\': [enableMouse, enableMouse],\n            \'mouseMode\': ViewBox.PanMode if getConfigOption(\'leftButtonPan\') else ViewBox.RectMode,  \n            \'enableMenu\': enableMenu,\n            \'wheelScaleFactor\': -1.0 / 8.0,\n\n            \'background\': None,\n            \n            # Limits\n            \'limits\': {\n                \'xLimits\': [None, None],   # Maximum and minimum visible X values \n                \'yLimits\': [None, None],   # Maximum and minimum visible Y values  \n                \'xRange\': [None, None],   # Maximum and minimum X range\n                \'yRange\': [None, None],   # Maximum and minimum Y range \n                }\n            \n        }\n        self._updatingRange = False  ## Used to break recursive loops. See updateAutoRange.\n        self._itemBoundsCache = weakref.WeakKeyDictionary()\n        \n        self.locateGroup = None  ## items displayed when using ViewBox.locate(item)\n        \n        self.setFlag(self.ItemClipsChildrenToShape)\n        self.setFlag(self.ItemIsFocusable, True)  ## so we can receive key presses\n        \n        ## childGroup is required so that ViewBox has local coordinates similar to device coordinates.\n        ## this is a workaround for a Qt + OpenGL bug that causes improper clipping\n        ## https://bugreports.qt.nokia.com/browse/QTBUG-23723\n        self.childGroup = ChildGroup(self)\n        self.childGroup.itemsChangedListeners.append(self)\n        \n        self.background = QtGui.QGraphicsRectItem(self.rect())\n        self.background.setParentItem(self)\n        self.background.setZValue(-1e6)\n        self.background.setPen(fn.mkPen(None))\n        self.updateBackground()\n        \n        ## Make scale box that is shown when dragging on the view\n        self.rbScaleBox = QtGui.QGraphicsRectItem(0, 0, 1, 1)\n        self.rbScaleBox.setPen(fn.mkPen((255,255,100), width=1))\n        self.rbScaleBox.setBrush(fn.mkBrush(255,255,0,100))\n        self.rbScaleBox.setZValue(1e9)\n        self.rbScaleBox.hide()\n        self.addItem(self.rbScaleBox, ignoreBounds=True)\n        \n        ## show target rect for debugging\n        self.target = QtGui.QGraphicsRectItem(0, 0, 1, 1)\n        self.target.setPen(fn.mkPen(\'r\'))\n        self.target.setParentItem(self)\n        self.target.hide()\n        \n        self.axHistory = [] # maintain a history of zoom locations\n        self.axHistoryPointer = -1 # pointer into the history. Allows forward/backward movement, not just ""undo""\n        \n        self.setZValue(-100)\n        self.setSizePolicy(QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding))\n        \n        self.setAspectLocked(lockAspect)\n        \n        self.border = fn.mkPen(border)\n        self.menu = ViewBoxMenu(self)\n        \n        self.register(name)\n        if name is None:\n            self.updateViewLists()\n        \n    def register(self, name):\n        """"""\n        Add this ViewBox to the registered list of views. \n        \n        This allows users to manually link the axes of any other ViewBox to\n        this one. The specified *name* will appear in the drop-down lists for \n        axis linking in the context menus of all other views.\n        \n        The same can be accomplished by initializing the ViewBox with the *name* attribute.\n        """"""\n        ViewBox.AllViews[self] = None\n        if self.name is not None:\n            del ViewBox.NamedViews[self.name]\n        self.name = name\n        if name is not None:\n            ViewBox.NamedViews[name] = self\n            ViewBox.updateAllViewLists()\n            sid = id(self)\n            self.destroyed.connect(lambda: ViewBox.forgetView(sid, name) if (ViewBox is not None and \'sid\' in locals() and \'name\' in locals()) else None)\n\n    def unregister(self):\n        """"""\n        Remove this ViewBox from the list of linkable views. (see :func:`register() <pyqtgraph.ViewBox.register>`)\n        """"""\n        del ViewBox.AllViews[self]\n        if self.name is not None:\n            del ViewBox.NamedViews[self.name]\n\n    def close(self):\n        self.clear()\n        self.unregister()\n\n    def implements(self, interface):\n        return interface == \'ViewBox\'\n        \n    # removed due to https://bugreports.qt-project.org/browse/PYSIDE-86\n    #def itemChange(self, change, value):\n        ## Note: Calling QWidget.itemChange causes segv in python 3 + PyQt\n        ##ret = QtGui.QGraphicsItem.itemChange(self, change, value)\n        #ret = GraphicsWidget.itemChange(self, change, value)\n        #if change == self.ItemSceneChange:\n            #scene = self.scene()\n            #if scene is not None and hasattr(scene, \'sigPrepareForPaint\'):\n                #scene.sigPrepareForPaint.disconnect(self.prepareForPaint)\n        #elif change == self.ItemSceneHasChanged:\n            #scene = self.scene()\n            #if scene is not None and hasattr(scene, \'sigPrepareForPaint\'):\n                #scene.sigPrepareForPaint.connect(self.prepareForPaint)\n        #return ret\n        \n    def checkSceneChange(self):\n        # ViewBox needs to receive sigPrepareForPaint from its scene before \n        # being painted. However, we have no way of being informed when the\n        # scene has changed in order to make this connection. The usual way\n        # to do this is via itemChange(), but bugs prevent this approach\n        # (see above). Instead, we simply check at every paint to see whether\n        # (the scene has changed.\n        scene = self.scene()\n        if scene == self._lastScene:\n            return\n        if self._lastScene is not None and hasattr(self.lastScene, \'sigPrepareForPaint\'):\n            self._lastScene.sigPrepareForPaint.disconnect(self.prepareForPaint)\n        if scene is not None and hasattr(scene, \'sigPrepareForPaint\'):\n            scene.sigPrepareForPaint.connect(self.prepareForPaint)\n        self.prepareForPaint()\n        self._lastScene = scene\n            \n    def prepareForPaint(self):\n        #autoRangeEnabled = (self.state[\'autoRange\'][0] is not False) or (self.state[\'autoRange\'][1] is not False)\n        # don\'t check whether auto range is enabled here--only check when setting dirty flag.\n        if self._autoRangeNeedsUpdate: # and autoRangeEnabled: \n            self.updateAutoRange()\n        self.updateMatrix()\n        \n    def getState(self, copy=True):\n        """"""Return the current state of the ViewBox. \n        Linked views are always converted to view names in the returned state.""""""\n        state = self.state.copy()\n        views = []\n        for v in state[\'linkedViews\']:\n            if isinstance(v, weakref.ref):\n                v = v()\n            if v is None or isinstance(v, basestring):\n                views.append(v)\n            else:\n                views.append(v.name)\n        state[\'linkedViews\'] = views\n        if copy:\n            return deepcopy(state)\n        else:\n            return state\n        \n    def setState(self, state):\n        """"""Restore the state of this ViewBox.\n        (see also getState)""""""\n        state = state.copy()\n        self.setXLink(state[\'linkedViews\'][0])\n        self.setYLink(state[\'linkedViews\'][1])\n        del state[\'linkedViews\']\n        \n        self.state.update(state)\n        self.updateViewRange()\n        self.sigStateChanged.emit(self)\n\n    def setBackgroundColor(self, color):\n        """"""\n        Set the background color of the ViewBox.\n        \n        If color is None, then no background will be drawn.\n        \n        Added in version 0.9.9\n        """"""\n        self.background.setVisible(color is not None)\n        self.state[\'background\'] = color\n        self.updateBackground()\n\n    def setMouseMode(self, mode):\n        """"""\n        Set the mouse interaction mode. *mode* must be either ViewBox.PanMode or ViewBox.RectMode.\n        In PanMode, the left mouse button pans the view and the right button scales.\n        In RectMode, the left button draws a rectangle which updates the visible region (this mode is more suitable for single-button mice)\n        """"""\n        if mode not in [ViewBox.PanMode, ViewBox.RectMode]:\n            raise Exception(""Mode must be ViewBox.PanMode or ViewBox.RectMode"")\n        self.state[\'mouseMode\'] = mode\n        self.sigStateChanged.emit(self)\n\n    def setLeftButtonAction(self, mode=\'rect\'):  ## for backward compatibility\n        if mode.lower() == \'rect\':\n            self.setMouseMode(ViewBox.RectMode)\n        elif mode.lower() == \'pan\':\n            self.setMouseMode(ViewBox.PanMode)\n        else:\n            raise Exception(\'graphicsItems:ViewBox:setLeftButtonAction: unknown mode = %s (Options are ""pan"" and ""rect"")\' % mode)\n            \n    def innerSceneItem(self):\n        return self.childGroup\n    \n    def setMouseEnabled(self, x=None, y=None):\n        """"""\n        Set whether each axis is enabled for mouse interaction. *x*, *y* arguments must be True or False.\n        This allows the user to pan/scale one axis of the view while leaving the other axis unchanged.\n        """"""\n        if x is not None:\n            self.state[\'mouseEnabled\'][0] = x\n        if y is not None:\n            self.state[\'mouseEnabled\'][1] = y\n        self.sigStateChanged.emit(self)\n            \n    def mouseEnabled(self):\n        return self.state[\'mouseEnabled\'][:]\n        \n    def setMenuEnabled(self, enableMenu=True):\n        self.state[\'enableMenu\'] = enableMenu\n        self.sigStateChanged.emit(self)\n\n    def menuEnabled(self):\n        return self.state.get(\'enableMenu\', True)       \n    \n    def addItem(self, item, ignoreBounds=False):\n        """"""\n        Add a QGraphicsItem to this view. The view will include this item when determining how to set its range\n        automatically unless *ignoreBounds* is True.\n        """"""\n        if item.zValue() < self.zValue():\n            item.setZValue(self.zValue()+1)\n        scene = self.scene()\n        if scene is not None and scene is not item.scene():\n            scene.addItem(item)  ## Necessary due to Qt bug: https://bugreports.qt-project.org/browse/QTBUG-18616\n        item.setParentItem(self.childGroup)\n        if not ignoreBounds:\n            self.addedItems.append(item)\n        self.updateAutoRange()\n        \n    def removeItem(self, item):\n        """"""Remove an item from this view.""""""\n        try:\n            self.addedItems.remove(item)\n        except:\n            pass\n        self.scene().removeItem(item)\n        self.updateAutoRange()\n\n    def clear(self):\n        for i in self.addedItems[:]:\n            self.removeItem(i)\n        for ch in self.childGroup.childItems():\n            ch.setParentItem(None)\n        \n    def resizeEvent(self, ev):\n        self._matrixNeedsUpdate = True\n        self.linkedXChanged()\n        self.linkedYChanged()\n        self.updateAutoRange()\n        self.updateViewRange()\n        self._matrixNeedsUpdate = True\n        self.sigStateChanged.emit(self)\n        self.background.setRect(self.rect())\n        self.sigResized.emit(self)\n        \n    def viewRange(self):\n        """"""Return a the view\'s visible range as a list: [[xmin, xmax], [ymin, ymax]]""""""\n        return [x[:] for x in self.state[\'viewRange\']]  ## return copy\n\n    def viewRect(self):\n        """"""Return a QRectF bounding the region visible within the ViewBox""""""\n        try:\n            vr0 = self.state[\'viewRange\'][0]\n            vr1 = self.state[\'viewRange\'][1]\n            return QtCore.QRectF(vr0[0], vr1[0], vr0[1]-vr0[0], vr1[1] - vr1[0])\n        except:\n            print(""make qrectf failed:"", self.state[\'viewRange\'])\n            raise\n    \n    def targetRange(self):\n        return [x[:] for x in self.state[\'targetRange\']]  ## return copy\n    \n    def targetRect(self):  \n        """"""\n        Return the region which has been requested to be visible. \n        (this is not necessarily the same as the region that is *actually* visible--\n        resizing and aspect ratio constraints can cause targetRect() and viewRect() to differ)\n        """"""\n        try:\n            tr0 = self.state[\'targetRange\'][0]\n            tr1 = self.state[\'targetRange\'][1]\n            return QtCore.QRectF(tr0[0], tr1[0], tr0[1]-tr0[0], tr1[1] - tr1[0])\n        except:\n            print(""make qrectf failed:"", self.state[\'targetRange\'])\n            raise\n\n    def _resetTarget(self):\n        # Reset target range to exactly match current view range.\n        # This is used during mouse interaction to prevent unpredictable\n        # behavior (because the user is unaware of targetRange).\n        if self.state[\'aspectLocked\'] is False: # (interferes with aspect locking)\n            self.state[\'targetRange\'] = [self.state[\'viewRange\'][0][:], self.state[\'viewRange\'][1][:]]\n\n    def setRange(self, rect=None, xRange=None, yRange=None, padding=None, update=True, disableAutoRange=True):\n        """"""\n        Set the visible range of the ViewBox.\n        Must specify at least one of *rect*, *xRange*, or *yRange*. \n        \n        ================== =====================================================================\n        **Arguments:**\n        *rect*             (QRectF) The full range that should be visible in the view box.\n        *xRange*           (min,max) The range that should be visible along the x-axis.\n        *yRange*           (min,max) The range that should be visible along the y-axis.\n        *padding*          (float) Expand the view by a fraction of the requested range. \n                           By default, this value is set between 0.02 and 0.1 depending on\n                           the size of the ViewBox.\n        *update*           (bool) If True, update the range of the ViewBox immediately. \n                           Otherwise, the update is deferred until before the next render.\n        *disableAutoRange* (bool) If True, auto-ranging is diabled. Otherwise, it is left\n                           unchanged.\n        ================== =====================================================================\n        \n        """"""\n        #print self.name, ""ViewBox.setRange"", rect, xRange, yRange, padding\n        #import traceback\n        #traceback.print_stack()\n        \n        changes = {}   # axes\n        setRequested = [False, False]\n        \n        if rect is not None:\n            changes = {0: [rect.left(), rect.right()], 1: [rect.top(), rect.bottom()]}\n            setRequested = [True, True]\n        if xRange is not None:\n            changes[0] = xRange\n            setRequested[0] = True\n        if yRange is not None:\n            changes[1] = yRange\n            setRequested[1] = True\n\n        if len(changes) == 0:\n            print(rect)\n            raise Exception(""Must specify at least one of rect, xRange, or yRange. (gave rect=%s)"" % str(type(rect)))\n        \n        # Update axes one at a time\n        changed = [False, False]\n        for ax, range in changes.items():\n            mn = min(range)\n            mx = max(range)\n            \n            # If we requested 0 range, try to preserve previous scale. \n            # Otherwise just pick an arbitrary scale.\n            if mn == mx:   \n                dy = self.state[\'viewRange\'][ax][1] - self.state[\'viewRange\'][ax][0]\n                if dy == 0:\n                    dy = 1\n                mn -= dy*0.5\n                mx += dy*0.5\n                xpad = 0.0\n                \n            # Make sure no nan/inf get through\n            if not all(np.isfinite([mn, mx])):\n                raise Exception(""Cannot set range [%s, %s]"" % (str(mn), str(mx)))\n            \n            # Apply padding\n            if padding is None:\n                xpad = self.suggestPadding(ax)\n            else:\n                xpad = padding\n            p = (mx-mn) * xpad\n            mn -= p\n            mx += p\n            \n            # Set target range\n            if self.state[\'targetRange\'][ax] != [mn, mx]:\n                self.state[\'targetRange\'][ax] = [mn, mx]\n                changed[ax] = True\n                \n        # Update viewRange to match targetRange as closely as possible while \n        # accounting for aspect ratio constraint\n        lockX, lockY = setRequested\n        if lockX and lockY:\n            lockX = False\n            lockY = False\n        self.updateViewRange(lockX, lockY)\n            \n        # Disable auto-range for each axis that was requested to be set\n        if disableAutoRange:\n            xOff = False if setRequested[0] else None\n            yOff = False if setRequested[1] else None\n            self.enableAutoRange(x=xOff, y=yOff)\n            changed.append(True)\n\n        # If nothing has changed, we are done.\n        if any(changed):\n            self.sigStateChanged.emit(self)\n            \n            # Update target rect for debugging\n            if self.target.isVisible():\n                self.target.setRect(self.mapRectFromItem(self.childGroup, self.targetRect()))\n                \n        # If ortho axes have auto-visible-only, update them now\n        # Note that aspect ratio constraints and auto-visible probably do not work together..\n        if changed[0] and self.state[\'autoVisibleOnly\'][1] and (self.state[\'autoRange\'][0] is not False):\n            self._autoRangeNeedsUpdate = True\n        elif changed[1] and self.state[\'autoVisibleOnly\'][0] and (self.state[\'autoRange\'][1] is not False):\n            self._autoRangeNeedsUpdate = True\n\n    def setYRange(self, min, max, padding=None, update=True):\n        """"""\n        Set the visible Y range of the view to [*min*, *max*]. \n        The *padding* argument causes the range to be set larger by the fraction specified.\n        (by default, this value is between 0.02 and 0.1 depending on the size of the ViewBox)\n        """"""\n        self.setRange(yRange=[min, max], update=update, padding=padding)\n        \n    def setXRange(self, min, max, padding=None, update=True):\n        """"""\n        Set the visible X range of the view to [*min*, *max*]. \n        The *padding* argument causes the range to be set larger by the fraction specified.\n        (by default, this value is between 0.02 and 0.1 depending on the size of the ViewBox)\n        """"""\n        self.setRange(xRange=[min, max], update=update, padding=padding)\n\n    def autoRange(self, padding=None, items=None, item=None):\n        """"""\n        Set the range of the view box to make all children visible.\n        Note that this is not the same as enableAutoRange, which causes the view to \n        automatically auto-range whenever its contents are changed.\n        \n        ==============  ============================================================\n        **Arguments:**\n        padding         The fraction of the total data range to add on to the final\n                        visible range. By default, this value is set between 0.02\n                        and 0.1 depending on the size of the ViewBox.\n        items           If specified, this is a list of items to consider when\n                        determining the visible range.\n        ==============  ============================================================\n        """"""\n        if item is None:\n            bounds = self.childrenBoundingRect(items=items)\n        else:\n            print(""Warning: ViewBox.autoRange(item=__) is deprecated. Use \'items\' argument instead."")\n            bounds = self.mapFromItemToView(item, item.boundingRect()).boundingRect()\n            \n        if bounds is not None:\n            self.setRange(bounds, padding=padding)\n            \n    def suggestPadding(self, axis):\n        l = self.width() if axis==0 else self.height()\n        if l > 0:\n            padding = np.clip(1./(l**0.5), 0.02, 0.1)\n        else:\n            padding = 0.02\n        return padding\n    \n    def setLimits(self, **kwds):\n        """"""\n        Set limits that constrain the possible view ranges.\n        \n        **Panning limits**. The following arguments define the region within the \n        viewbox coordinate system that may be accessed by panning the view.\n        \n        =========== ============================================================\n        xMin        Minimum allowed x-axis value\n        xMax        Maximum allowed x-axis value\n        yMin        Minimum allowed y-axis value\n        yMax        Maximum allowed y-axis value\n        =========== ============================================================        \n        \n        **Scaling limits**. These arguments prevent the view being zoomed in or\n        out too far.\n        \n        =========== ============================================================\n        minXRange   Minimum allowed left-to-right span across the view.\n        maxXRange   Maximum allowed left-to-right span across the view.\n        minYRange   Minimum allowed top-to-bottom span across the view.\n        maxYRange   Maximum allowed top-to-bottom span across the view.\n        =========== ============================================================\n        \n        Added in version 0.9.9\n        """"""\n        update = False\n        allowed = [\'xMin\', \'xMax\', \'yMin\', \'yMax\', \'minXRange\', \'maxXRange\', \'minYRange\', \'maxYRange\']\n        for kwd in kwds:\n            if kwd not in allowed:\n                raise ValueError(""Invalid keyword argument \'%s\'."" % kwd)\n        for axis in [0,1]:\n            for mnmx in [0,1]:\n                kwd = [[\'xMin\', \'xMax\'], [\'yMin\', \'yMax\']][axis][mnmx]\n                lname = [\'xLimits\', \'yLimits\'][axis]\n                if kwd in kwds and self.state[\'limits\'][lname][mnmx] != kwds[kwd]:\n                    self.state[\'limits\'][lname][mnmx] = kwds[kwd]\n                    update = True\n                kwd = [[\'minXRange\', \'maxXRange\'], [\'minYRange\', \'maxYRange\']][axis][mnmx]\n                lname = [\'xRange\', \'yRange\'][axis]\n                if kwd in kwds and self.state[\'limits\'][lname][mnmx] != kwds[kwd]:\n                    self.state[\'limits\'][lname][mnmx] = kwds[kwd]\n                    update = True\n                    \n        if update:\n            self.updateViewRange()\n            \n    def scaleBy(self, s=None, center=None, x=None, y=None):\n        """"""\n        Scale by *s* around given center point (or center of view).\n        *s* may be a Point or tuple (x, y).\n        \n        Optionally, x or y may be specified individually. This allows the other \n        axis to be left unaffected (note that using a scale factor of 1.0 may\n        cause slight changes due to floating-point error).\n        """"""\n        if s is not None:\n            x, y = s[0], s[1]\n        \n        affect = [x is not None, y is not None]\n        if not any(affect):\n            return\n        \n        scale = Point([1.0 if x is None else x, 1.0 if y is None else y])\n            \n        if self.state[\'aspectLocked\'] is not False:\n            scale[0] = scale[1]\n\n        vr = self.targetRect()\n        if center is None:\n            center = Point(vr.center())\n        else:\n            center = Point(center)\n        \n        tl = center + (vr.topLeft()-center) * scale\n        br = center + (vr.bottomRight()-center) * scale\n        \n        if not affect[0]:\n            self.setYRange(tl.y(), br.y(), padding=0)\n        elif not affect[1]:\n            self.setXRange(tl.x(), br.x(), padding=0)\n        else:\n            self.setRange(QtCore.QRectF(tl, br), padding=0)\n        \n    def translateBy(self, t=None, x=None, y=None):\n        """"""\n        Translate the view by *t*, which may be a Point or tuple (x, y).\n        \n        Alternately, x or y may be specified independently, leaving the other\n        axis unchanged (note that using a translation of 0 may still cause\n        small changes due to floating-point error).\n        """"""\n        vr = self.targetRect()\n        if t is not None:\n            t = Point(t)\n            self.setRange(vr.translated(t), padding=0)\n        else:\n            if x is not None:\n                x = vr.left()+x, vr.right()+x\n            if y is not None:\n                y = vr.top()+y, vr.bottom()+y\n            if x is not None or y is not None:\n                self.setRange(xRange=x, yRange=y, padding=0)\n        \n    def enableAutoRange(self, axis=None, enable=True, x=None, y=None):\n        """"""\n        Enable (or disable) auto-range for *axis*, which may be ViewBox.XAxis, ViewBox.YAxis, or ViewBox.XYAxes for both\n        (if *axis* is omitted, both axes will be changed).\n        When enabled, the axis will automatically rescale when items are added/removed or change their shape.\n        The argument *enable* may optionally be a float (0.0-1.0) which indicates the fraction of the data that should\n        be visible (this only works with items implementing a dataRange method, such as PlotDataItem).\n        """"""\n        # support simpler interface:\n        if x is not None or y is not None:\n            if x is not None:\n                self.enableAutoRange(ViewBox.XAxis, x)\n            if y is not None:\n                self.enableAutoRange(ViewBox.YAxis, y)\n            return\n        \n        if enable is True:\n            enable = 1.0\n        \n        if axis is None:\n            axis = ViewBox.XYAxes\n        \n        needAutoRangeUpdate = False\n        \n        if axis == ViewBox.XYAxes or axis == \'xy\':\n            axes = [0, 1]\n        elif axis == ViewBox.XAxis or axis == \'x\':\n            axes = [0]\n        elif axis == ViewBox.YAxis or axis == \'y\':\n            axes = [1]\n        else:\n            raise Exception(\'axis argument must be ViewBox.XAxis, ViewBox.YAxis, or ViewBox.XYAxes.\')\n        \n        for ax in axes:\n            if self.state[\'autoRange\'][ax] != enable:\n                # If we are disabling, do one last auto-range to make sure that\n                # previously scheduled auto-range changes are enacted\n                if enable is False and self._autoRangeNeedsUpdate:\n                    self.updateAutoRange()\n                \n                self.state[\'autoRange\'][ax] = enable\n                self._autoRangeNeedsUpdate |= (enable is not False)\n                self.update()\n        \n        self.sigStateChanged.emit(self)\n\n    def disableAutoRange(self, axis=None):\n        """"""Disables auto-range. (See enableAutoRange)""""""\n        self.enableAutoRange(axis, enable=False)\n\n    def autoRangeEnabled(self):\n        return self.state[\'autoRange\'][:]\n\n    def setAutoPan(self, x=None, y=None):\n        """"""Set whether automatic range will only pan (not scale) the view.\n        """"""\n        if x is not None:\n            self.state[\'autoPan\'][0] = x\n        if y is not None:\n            self.state[\'autoPan\'][1] = y\n        if None not in [x,y]:\n            self.updateAutoRange()\n\n    def setAutoVisible(self, x=None, y=None):\n        """"""Set whether automatic range uses only visible data when determining\n        the range to show.\n        """"""\n        if x is not None:\n            self.state[\'autoVisibleOnly\'][0] = x\n            if x is True:\n                self.state[\'autoVisibleOnly\'][1] = False\n        if y is not None:\n            self.state[\'autoVisibleOnly\'][1] = y\n            if y is True:\n                self.state[\'autoVisibleOnly\'][0] = False\n        \n        if x is not None or y is not None:\n            self.updateAutoRange()\n\n    def updateAutoRange(self):\n        ## Break recursive loops when auto-ranging.\n        ## This is needed because some items change their size in response \n        ## to a view change.\n        if self._updatingRange:\n            return\n        \n        self._updatingRange = True\n        try:\n            targetRect = self.viewRange()\n            if not any(self.state[\'autoRange\']):\n                return\n                \n            fractionVisible = self.state[\'autoRange\'][:]\n            for i in [0,1]:\n                if type(fractionVisible[i]) is bool:\n                    fractionVisible[i] = 1.0\n\n            childRange = None\n            \n            order = [0,1]\n            if self.state[\'autoVisibleOnly\'][0] is True:\n                order = [1,0]\n\n            args = {}\n            for ax in order:\n                if self.state[\'autoRange\'][ax] is False:\n                    continue\n                if self.state[\'autoVisibleOnly\'][ax]:\n                    oRange = [None, None]\n                    oRange[ax] = targetRect[1-ax]\n                    childRange = self.childrenBounds(frac=fractionVisible, orthoRange=oRange)\n                    \n                else:\n                    if childRange is None:\n                        childRange = self.childrenBounds(frac=fractionVisible)\n                \n                ## Make corrections to range\n                xr = childRange[ax]\n                if xr is not None:\n                    if self.state[\'autoPan\'][ax]:\n                        x = sum(xr) * 0.5\n                        w2 = (targetRect[ax][1]-targetRect[ax][0]) / 2.\n                        childRange[ax] = [x-w2, x+w2]\n                    else:\n                        padding = self.suggestPadding(ax)\n                        wp = (xr[1] - xr[0]) * padding\n                        childRange[ax][0] -= wp\n                        childRange[ax][1] += wp\n                    targetRect[ax] = childRange[ax]\n                    args[\'xRange\' if ax == 0 else \'yRange\'] = targetRect[ax]\n            \n             # check for and ignore bad ranges\n            for k in [\'xRange\', \'yRange\']:\n                if k in args:\n                    if not np.all(np.isfinite(args[k])):\n                        r = args.pop(k)\n                        #print(""Warning: %s is invalid: %s"" % (k, str(r))\n            \n            if len(args) == 0:\n                return\n            args[\'padding\'] = 0\n            args[\'disableAutoRange\'] = False\n                        \n            self.setRange(**args)\n        finally:\n            self._autoRangeNeedsUpdate = False\n            self._updatingRange = False\n        \n    def setXLink(self, view):\n        """"""Link this view\'s X axis to another view. (see LinkView)""""""\n        self.linkView(self.XAxis, view)\n        \n    def setYLink(self, view):\n        """"""Link this view\'s Y axis to another view. (see LinkView)""""""\n        self.linkView(self.YAxis, view)\n        \n    def linkView(self, axis, view):\n        """"""\n        Link X or Y axes of two views and unlink any previously connected axes. *axis* must be ViewBox.XAxis or ViewBox.YAxis.\n        If view is None, the axis is left unlinked.\n        """"""\n        if isinstance(view, basestring):\n            if view == \'\':\n                view = None\n            else:\n                view = ViewBox.NamedViews.get(view, view)  ## convert view name to ViewBox if possible\n\n        if hasattr(view, \'implements\') and view.implements(\'ViewBoxWrapper\'):\n            view = view.getViewBox()\n\n        ## used to connect/disconnect signals between a pair of views\n        if axis == ViewBox.XAxis:\n            signal = \'sigXRangeChanged\'\n            slot = self.linkedXChanged\n        else:\n            signal = \'sigYRangeChanged\'\n            slot = self.linkedYChanged\n\n\n        oldLink = self.linkedView(axis)\n        if oldLink is not None:\n            try:\n                getattr(oldLink, signal).disconnect(slot)\n                oldLink.sigResized.disconnect(slot)\n            except (TypeError, RuntimeError):\n                ## This can occur if the view has been deleted already\n                pass\n            \n        \n        if view is None or isinstance(view, basestring):\n            self.state[\'linkedViews\'][axis] = view\n        else:\n            self.state[\'linkedViews\'][axis] = weakref.ref(view)\n            getattr(view, signal).connect(slot)\n            view.sigResized.connect(slot)\n            if view.autoRangeEnabled()[axis] is not False:\n                self.enableAutoRange(axis, False)\n                slot()\n            else:\n                if self.autoRangeEnabled()[axis] is False:\n                    slot()\n        \n            \n        self.sigStateChanged.emit(self)\n        \n    def blockLink(self, b):\n        self.linksBlocked = b  ## prevents recursive plot-change propagation\n\n    def linkedXChanged(self):\n        ## called when x range of linked view has changed\n        view = self.linkedView(0)\n        self.linkedViewChanged(view, ViewBox.XAxis)\n\n    def linkedYChanged(self):\n        ## called when y range of linked view has changed\n        view = self.linkedView(1)\n        self.linkedViewChanged(view, ViewBox.YAxis)\n        \n    def linkedView(self, ax):\n        ## Return the linked view for axis *ax*.\n        ## this method _always_ returns either a ViewBox or None.\n        v = self.state[\'linkedViews\'][ax]\n        if v is None or isinstance(v, basestring):\n            return None\n        else:\n            return v()  ## dereference weakref pointer. If the reference is dead, this returns None\n\n    def linkedViewChanged(self, view, axis):\n        if self.linksBlocked or view is None:\n            return\n        \n        #print self.name, ""ViewBox.linkedViewChanged"", axis, view.viewRange()[axis]\n        vr = view.viewRect()\n        vg = view.screenGeometry()\n        sg = self.screenGeometry()\n        if vg is None or sg is None:\n            return\n        \n        view.blockLink(True)\n        try:\n            if axis == ViewBox.XAxis:\n                overlap = min(sg.right(), vg.right()) - max(sg.left(), vg.left())\n                if overlap < min(vg.width()/3, sg.width()/3):  ## if less than 1/3 of views overlap, \n                                                               ## then just replicate the view\n                    x1 = vr.left()\n                    x2 = vr.right()\n                else:  ## views overlap; line them up\n                    upp = float(vr.width()) / vg.width()\n                    if self.xInverted():\n                        x1 = vr.left()   + (sg.right()-vg.right()) * upp\n                    else:\n                        x1 = vr.left()   + (sg.x()-vg.x()) * upp\n                    x2 = x1 + sg.width() * upp\n                self.enableAutoRange(ViewBox.XAxis, False)\n                self.setXRange(x1, x2, padding=0)\n            else:\n                overlap = min(sg.bottom(), vg.bottom()) - max(sg.top(), vg.top())\n                if overlap < min(vg.height()/3, sg.height()/3):  ## if less than 1/3 of views overlap, \n                                                                 ## then just replicate the view\n                    y1 = vr.top()\n                    y2 = vr.bottom()\n                else:  ## views overlap; line them up\n                    upp = float(vr.height()) / vg.height()\n                    if self.yInverted():\n                        y2 = vr.bottom() + (sg.bottom()-vg.bottom()) * upp\n                    else:\n                        y2 = vr.bottom() + (sg.top()-vg.top()) * upp\n                    y1 = y2 - sg.height() * upp\n                self.enableAutoRange(ViewBox.YAxis, False)\n                self.setYRange(y1, y2, padding=0)\n        finally:\n            view.blockLink(False)\n        \n    def screenGeometry(self):\n        """"""return the screen geometry of the viewbox""""""\n        v = self.getViewWidget()\n        if v is None:\n            return None\n        b = self.sceneBoundingRect()\n        wr = v.mapFromScene(b).boundingRect()\n        pos = v.mapToGlobal(v.pos())\n        wr.adjust(pos.x(), pos.y(), pos.x(), pos.y())\n        return wr\n\n    def itemsChanged(self):\n        ## called when items are added/removed from self.childGroup\n        self.updateAutoRange()\n        \n    def itemBoundsChanged(self, item):\n        self._itemBoundsCache.pop(item, None)\n        if (self.state[\'autoRange\'][0] is not False) or (self.state[\'autoRange\'][1] is not False):\n            self._autoRangeNeedsUpdate = True\n            self.update()\n        #self.updateAutoRange()\n\n    def _invertAxis(self, ax, inv):\n        key = \'xy\'[ax] + \'Inverted\'\n        if self.state[key] == inv:\n            return\n        \n        self.state[key] = inv\n        self._matrixNeedsUpdate = True # updateViewRange won\'t detect this for us\n        self.updateViewRange()\n        self.update()\n        self.sigStateChanged.emit(self)\n        self.sigYRangeChanged.emit(self, tuple(self.state[\'viewRange\'][ax]))\n\n    def invertY(self, b=True):\n        """"""\n        By default, the positive y-axis points upward on the screen. Use invertY(True) to reverse the y-axis.\n        """"""\n        self._invertAxis(1, b)\n\n    def yInverted(self):\n        return self.state[\'yInverted\']\n        \n    def invertX(self, b=True):\n        """"""\n        By default, the positive x-axis points rightward on the screen. Use invertX(True) to reverse the x-axis.\n        """"""\n        self._invertAxis(0, b)\n\n    def xInverted(self):\n        return self.state[\'xInverted\']\n        \n    def setAspectLocked(self, lock=True, ratio=1):\n        """"""\n        If the aspect ratio is locked, view scaling must always preserve the aspect ratio.\n        By default, the ratio is set to 1; x and y both have the same scaling.\n        This ratio can be overridden (xScale/yScale), or use None to lock in the current ratio.\n        """"""\n        \n        if not lock:\n            if self.state[\'aspectLocked\'] == False:\n                return\n            self.state[\'aspectLocked\'] = False\n        else:\n            rect = self.rect()\n            vr = self.viewRect()\n            if rect.height() == 0 or vr.width() == 0 or vr.height() == 0:\n                currentRatio = 1.0\n            else:\n                currentRatio = (rect.width()/float(rect.height())) / (vr.width()/vr.height())\n            if ratio is None:\n                ratio = currentRatio\n            if self.state[\'aspectLocked\'] == ratio: # nothing to change\n                return\n            self.state[\'aspectLocked\'] = ratio\n            if ratio != currentRatio:  ## If this would change the current range, do that now\n                self.updateViewRange()\n        \n        self.updateAutoRange()\n        self.updateViewRange()\n        self.sigStateChanged.emit(self)\n        \n    def childTransform(self):\n        """"""\n        Return the transform that maps from child(item in the childGroup) coordinates to local coordinates.\n        (This maps from inside the viewbox to outside)\n        """""" \n        self.updateMatrix()\n        m = self.childGroup.transform()\n        return m\n\n    def mapToView(self, obj):\n        """"""Maps from the local coordinates of the ViewBox to the coordinate system displayed inside the ViewBox""""""\n        self.updateMatrix()\n        m = fn.invertQTransform(self.childTransform())\n        return m.map(obj)\n\n    def mapFromView(self, obj):\n        """"""Maps from the coordinate system displayed inside the ViewBox to the local coordinates of the ViewBox""""""\n        self.updateMatrix()\n        m = self.childTransform()\n        return m.map(obj)\n\n    def mapSceneToView(self, obj):\n        """"""Maps from scene coordinates to the coordinate system displayed inside the ViewBox""""""\n        self.updateMatrix()\n        return self.mapToView(self.mapFromScene(obj))\n\n    def mapViewToScene(self, obj):\n        """"""Maps from the coordinate system displayed inside the ViewBox to scene coordinates""""""\n        self.updateMatrix()\n        return self.mapToScene(self.mapFromView(obj))\n    \n    def mapFromItemToView(self, item, obj):\n        """"""Maps *obj* from the local coordinate system of *item* to the view coordinates""""""\n        self.updateMatrix()\n        return self.childGroup.mapFromItem(item, obj)\n        #return self.mapSceneToView(item.mapToScene(obj))\n\n    def mapFromViewToItem(self, item, obj):\n        """"""Maps *obj* from view coordinates to the local coordinate system of *item*.""""""\n        self.updateMatrix()\n        return self.childGroup.mapToItem(item, obj)\n\n    def mapViewToDevice(self, obj):\n        self.updateMatrix()\n        return self.mapToDevice(self.mapFromView(obj))\n        \n    def mapDeviceToView(self, obj):\n        self.updateMatrix()\n        return self.mapToView(self.mapFromDevice(obj))\n        \n    def viewPixelSize(self):\n        """"""Return the (width, height) of a screen pixel in view coordinates.""""""\n        o = self.mapToView(Point(0,0))\n        px, py = [Point(self.mapToView(v) - o) for v in self.pixelVectors()]\n        return (px.length(), py.length())\n        \n    def itemBoundingRect(self, item):\n        """"""Return the bounding rect of the item in view coordinates""""""\n        return self.mapSceneToView(item.sceneBoundingRect()).boundingRect()\n\n    def wheelEvent(self, ev, axis=None):\n        if axis in (0, 1):\n            mask = [False, False]\n            mask[axis] = self.state[\'mouseEnabled\'][axis]\n        else:\n            mask = self.state[\'mouseEnabled\'][:]\n        s = 1.02 ** (ev.delta() * self.state[\'wheelScaleFactor\']) # actual scaling factor\n        s = [(None if m is False else s) for m in mask]\n        center = Point(fn.invertQTransform(self.childGroup.transform()).map(ev.pos()))\n        \n        self._resetTarget()\n        self.scaleBy(s, center)\n        self.sigRangeChangedManually.emit(mask)\n        ev.accept()\n        \n    def mouseClickEvent(self, ev):\n        if ev.button() == QtCore.Qt.RightButton and self.menuEnabled():\n            ev.accept()\n            self.raiseContextMenu(ev)\n\n    def raiseContextMenu(self, ev):\n        menu = self.getMenu(ev)\n        self.scene().addParentContextMenus(self, menu, ev)\n        menu.popup(ev.screenPos().toPoint())\n\n    def getMenu(self, ev):\n        return self.menu\n\n    def getContextMenus(self, event):\n        return self.menu.actions() if self.menuEnabled() else []\n\n    def mouseDragEvent(self, ev, axis=None):\n        ## if axis is specified, event will only affect that axis.\n        ev.accept()  ## we accept all buttons\n        \n        pos = ev.pos()\n        lastPos = ev.lastPos()\n        dif = pos - lastPos\n        dif = dif * -1\n\n        ## Ignore axes if mouse is disabled\n        mouseEnabled = np.array(self.state[\'mouseEnabled\'], dtype=np.float)\n        mask = mouseEnabled.copy()\n        if axis is not None:\n            mask[1-axis] = 0.0\n\n        ## Scale or translate based on mouse button\n        if ev.button() & (QtCore.Qt.LeftButton | QtCore.Qt.MidButton):\n            if self.state[\'mouseMode\'] == ViewBox.RectMode:\n                if ev.isFinish():  ## This is the final move in the drag; change the view scale now\n                    #print ""finish""\n                    self.rbScaleBox.hide()\n                    ax = QtCore.QRectF(Point(ev.buttonDownPos(ev.button())), Point(pos))\n                    ax = self.childGroup.mapRectFromParent(ax)\n                    self.showAxRect(ax)\n                    self.axHistoryPointer += 1\n                    self.axHistory = self.axHistory[:self.axHistoryPointer] + [ax]\n                else:\n                    ## update shape of scale box\n                    self.updateScaleBox(ev.buttonDownPos(), ev.pos())\n            else:\n                tr = dif*mask\n                tr = self.mapToView(tr) - self.mapToView(Point(0,0))\n                x = tr.x() if mask[0] == 1 else None\n                y = tr.y() if mask[1] == 1 else None\n                \n                self._resetTarget()\n                if x is not None or y is not None:\n                    self.translateBy(x=x, y=y)\n                self.sigRangeChangedManually.emit(self.state[\'mouseEnabled\'])\n        elif ev.button() & QtCore.Qt.RightButton:\n            #print ""vb.rightDrag""\n            if self.state[\'aspectLocked\'] is not False:\n                mask[0] = 0\n            \n            dif = ev.screenPos() - ev.lastScreenPos()\n            dif = np.array([dif.x(), dif.y()])\n            dif[0] *= -1\n            s = ((mask * 0.02) + 1) ** dif\n            \n            tr = self.childGroup.transform()\n            tr = fn.invertQTransform(tr)\n            \n            x = s[0] if mouseEnabled[0] == 1 else None\n            y = s[1] if mouseEnabled[1] == 1 else None\n            \n            center = Point(tr.map(ev.buttonDownPos(QtCore.Qt.RightButton)))\n            self._resetTarget()\n            self.scaleBy(x=x, y=y, center=center)\n            self.sigRangeChangedManually.emit(self.state[\'mouseEnabled\'])\n\n    def keyPressEvent(self, ev):\n        """"""\n        This routine should capture key presses in the current view box.\n        Key presses are used only when mouse mode is RectMode\n        The following events are implemented:\n        ctrl-A : zooms out to the default ""full"" view of the plot\n        ctrl-+ : moves forward in the zooming stack (if it exists)\n        ctrl-- : moves backward in the zooming stack (if it exists)\n         \n        """"""\n        ev.accept()\n        if ev.text() == \'-\':\n            self.scaleHistory(-1)\n        elif ev.text() in [\'+\', \'=\']:\n            self.scaleHistory(1)\n        elif ev.key() == QtCore.Qt.Key_Backspace:\n            self.scaleHistory(len(self.axHistory))\n        else:\n            ev.ignore()\n\n    def scaleHistory(self, d):\n        if len(self.axHistory) == 0:\n            return\n        ptr = max(0, min(len(self.axHistory)-1, self.axHistoryPointer+d))\n        if ptr != self.axHistoryPointer:\n            self.axHistoryPointer = ptr\n            self.showAxRect(self.axHistory[ptr])\n\n    def updateScaleBox(self, p1, p2):\n        r = QtCore.QRectF(p1, p2)\n        r = self.childGroup.mapRectFromParent(r)\n        self.rbScaleBox.setPos(r.topLeft())\n        self.rbScaleBox.resetTransform()\n        self.rbScaleBox.scale(r.width(), r.height())\n        self.rbScaleBox.show()\n\n    def showAxRect(self, ax):\n        self.setRange(ax.normalized()) # be sure w, h are correct coordinates\n        self.sigRangeChangedManually.emit(self.state[\'mouseEnabled\'])\n\n    def allChildren(self, item=None):\n        """"""Return a list of all children and grandchildren of this ViewBox""""""\n        if item is None:\n            item = self.childGroup\n        \n        children = [item]\n        for ch in item.childItems():\n            children.extend(self.allChildren(ch))\n        return children\n        \n    def childrenBounds(self, frac=None, orthoRange=(None,None), items=None):\n        """"""Return the bounding range of all children.\n        [[xmin, xmax], [ymin, ymax]]\n        Values may be None if there are no specific bounds for an axis.\n        """"""\n        profiler = debug.Profiler()\n        if items is None:\n            items = self.addedItems\n        \n        ## measure pixel dimensions in view box\n        px, py = [v.length() if v is not None else 0 for v in self.childGroup.pixelVectors()]\n        \n        ## First collect all boundary information\n        itemBounds = []\n        for item in items:\n            if not item.isVisible() or not item.scene() is self.scene():\n                continue\n        \n            useX = True\n            useY = True\n            \n            if hasattr(item, \'dataBounds\'):\n                if frac is None:\n                    frac = (1.0, 1.0)\n                xr = item.dataBounds(0, frac=frac[0], orthoRange=orthoRange[0])\n                yr = item.dataBounds(1, frac=frac[1], orthoRange=orthoRange[1])\n                pxPad = 0 if not hasattr(item, \'pixelPadding\') else item.pixelPadding()\n                if xr is None or (xr[0] is None and xr[1] is None) or np.isnan(xr).any() or np.isinf(xr).any():\n                    useX = False\n                    xr = (0,0)\n                if yr is None or (yr[0] is None and yr[1] is None) or np.isnan(yr).any() or np.isinf(yr).any():\n                    useY = False\n                    yr = (0,0)\n\n                bounds = QtCore.QRectF(xr[0], yr[0], xr[1]-xr[0], yr[1]-yr[0])\n                bounds = self.mapFromItemToView(item, bounds).boundingRect()\n                \n                if not any([useX, useY]):\n                    continue\n                \n                ## If we are ignoring only one axis, we need to check for rotations\n                if useX != useY:  ##   !=  means  xor\n                    ang = round(item.transformAngle())\n                    if ang == 0 or ang == 180:\n                        pass\n                    elif ang == 90 or ang == 270:\n                        useX, useY = useY, useX \n                    else:\n                        ## Item is rotated at non-orthogonal angle, ignore bounds entirely.\n                        ## Not really sure what is the expected behavior in this case.\n                        continue  ## need to check for item rotations and decide how best to apply this boundary. \n                \n                \n                itemBounds.append((bounds, useX, useY, pxPad))\n            else:\n                if int(item.flags() & item.ItemHasNoContents) > 0:\n                    continue\n                else:\n                    bounds = item.boundingRect()\n                bounds = self.mapFromItemToView(item, bounds).boundingRect()\n                itemBounds.append((bounds, True, True, 0))\n        \n        ## determine tentative new range\n        range = [None, None]\n        for bounds, useX, useY, px in itemBounds:\n            if useY:\n                if range[1] is not None:\n                    range[1] = [min(bounds.top(), range[1][0]), max(bounds.bottom(), range[1][1])]\n                else:\n                    range[1] = [bounds.top(), bounds.bottom()]\n            if useX:\n                if range[0] is not None:\n                    range[0] = [min(bounds.left(), range[0][0]), max(bounds.right(), range[0][1])]\n                else:\n                    range[0] = [bounds.left(), bounds.right()]\n            profiler()\n        \n        ## Now expand any bounds that have a pixel margin\n        ## This must be done _after_ we have a good estimate of the new range\n        ## to ensure that the pixel size is roughly accurate.\n        w = self.width()\n        h = self.height()\n        if w > 0 and range[0] is not None:\n            pxSize = (range[0][1] - range[0][0]) / w\n            for bounds, useX, useY, px in itemBounds:\n                if px == 0 or not useX:\n                    continue\n                range[0][0] = min(range[0][0], bounds.left() - px*pxSize)\n                range[0][1] = max(range[0][1], bounds.right() + px*pxSize)\n        if h > 0 and range[1] is not None:\n            pxSize = (range[1][1] - range[1][0]) / h\n            for bounds, useX, useY, px in itemBounds:\n                if px == 0 or not useY:\n                    continue\n                range[1][0] = min(range[1][0], bounds.top() - px*pxSize)\n                range[1][1] = max(range[1][1], bounds.bottom() + px*pxSize)\n\n        return range\n        \n    def childrenBoundingRect(self, *args, **kwds):\n        range = self.childrenBounds(*args, **kwds)\n        tr = self.targetRange()\n        if range[0] is None:\n            range[0] = tr[0]\n        if range[1] is None:\n            range[1] = tr[1]\n            \n        bounds = QtCore.QRectF(range[0][0], range[1][0], range[0][1]-range[0][0], range[1][1]-range[1][0])\n        return bounds\n            \n    def updateViewRange(self, forceX=False, forceY=False):\n        ## Update viewRange to match targetRange as closely as possible, given \n        ## aspect ratio constraints. The *force* arguments are used to indicate \n        ## which axis (if any) should be unchanged when applying constraints.\n        viewRange = [self.state[\'targetRange\'][0][:], self.state[\'targetRange\'][1][:]]\n        changed = [False, False]\n        \n        #-------- Make correction for aspect ratio constraint ----------\n        \n        # aspect is (widget w/h) / (view range w/h)\n        aspect = self.state[\'aspectLocked\']  # size ratio / view ratio\n        tr = self.targetRect()\n        bounds = self.rect()\n        if aspect is not False and 0 not in [aspect, tr.height(), bounds.height(), bounds.width()]:\n            \n            ## This is the view range aspect ratio we have requested\n            targetRatio = tr.width() / tr.height() if tr.height() != 0 else 1\n            ## This is the view range aspect ratio we need to obey aspect constraint\n            viewRatio = (bounds.width() / bounds.height() if bounds.height() != 0 else 1) / aspect\n            viewRatio = 1 if viewRatio == 0 else viewRatio\n            \n            # Decide which range to keep unchanged\n            #print self.name, ""aspect:"", aspect, ""changed:"", changed, ""auto:"", self.state[\'autoRange\']\n            if forceX:\n                ax = 0\n            elif forceY:\n                ax = 1\n            else:\n                # if we are not required to keep a particular axis unchanged, \n                # then make the entire target range visible\n                ax = 0 if targetRatio > viewRatio else 1\n            \n            if ax == 0:  \n                ## view range needs to be taller than target\n                dy = 0.5 * (tr.width() / viewRatio - tr.height())\n                if dy != 0:\n                    changed[1] = True\n                viewRange[1] = [self.state[\'targetRange\'][1][0] - dy, self.state[\'targetRange\'][1][1] + dy]\n            else:\n                ## view range needs to be wider than target\n                dx = 0.5 * (tr.height() * viewRatio - tr.width())\n                if dx != 0:\n                    changed[0] = True\n                viewRange[0] = [self.state[\'targetRange\'][0][0] - dx, self.state[\'targetRange\'][0][1] + dx]\n\n            \n        # ----------- Make corrections for view limits -----------\n        \n        limits = (self.state[\'limits\'][\'xLimits\'], self.state[\'limits\'][\'yLimits\'])\n        minRng = [self.state[\'limits\'][\'xRange\'][0], self.state[\'limits\'][\'yRange\'][0]]\n        maxRng = [self.state[\'limits\'][\'xRange\'][1], self.state[\'limits\'][\'yRange\'][1]]\n        \n        for axis in [0, 1]:\n            if limits[axis][0] is None and limits[axis][1] is None and minRng[axis] is None and maxRng[axis] is None:\n                continue\n            \n            # max range cannot be larger than bounds, if they are given\n            if limits[axis][0] is not None and limits[axis][1] is not None:\n                if maxRng[axis] is not None:\n                    maxRng[axis] = min(maxRng[axis], limits[axis][1]-limits[axis][0])\n                else:\n                    maxRng[axis] = limits[axis][1]-limits[axis][0]\n            \n            #print ""\\nLimits for axis %d: range=%s min=%s max=%s"" % (axis, limits[axis], minRng[axis], maxRng[axis])\n            #print ""Starting range:"", viewRange[axis]\n            \n            # Apply xRange, yRange\n            diff = viewRange[axis][1] - viewRange[axis][0]\n            if maxRng[axis] is not None and diff > maxRng[axis]:\n                delta = maxRng[axis] - diff\n                changed[axis] = True\n            elif minRng[axis] is not None and diff < minRng[axis]:\n                delta = minRng[axis] - diff\n                changed[axis] = True\n            else:\n                delta = 0\n            \n            viewRange[axis][0] -= delta/2.\n            viewRange[axis][1] += delta/2.\n            \n            #print ""after applying min/max:"", viewRange[axis]\n               \n            # Apply xLimits, yLimits\n            mn, mx = limits[axis]\n            if mn is not None and viewRange[axis][0] < mn:\n                delta = mn - viewRange[axis][0]\n                viewRange[axis][0] += delta\n                viewRange[axis][1] += delta\n                changed[axis] = True\n            elif mx is not None and viewRange[axis][1] > mx:\n                delta = mx - viewRange[axis][1]\n                viewRange[axis][0] += delta\n                viewRange[axis][1] += delta\n                changed[axis] = True\n            \n            #print ""after applying edge limits:"", viewRange[axis]\n\n        changed = [(viewRange[i][0] != self.state[\'viewRange\'][i][0]) or (viewRange[i][1] != self.state[\'viewRange\'][i][1]) for i in (0,1)]\n        self.state[\'viewRange\'] = viewRange\n        \n        # emit range change signals\n        if changed[0]:\n            self.sigXRangeChanged.emit(self, tuple(self.state[\'viewRange\'][0]))\n        if changed[1]:\n            self.sigYRangeChanged.emit(self, tuple(self.state[\'viewRange\'][1]))\n        \n        if any(changed):\n            self._matrixNeedsUpdate = True\n            self.sigRangeChanged.emit(self, self.state[\'viewRange\'])\n            self.update()\n        \n            # Inform linked views that the range has changed\n            for ax in [0, 1]:\n                if not changed[ax]:\n                    continue\n                link = self.linkedView(ax)\n                if link is not None:\n                    link.linkedViewChanged(self, ax)\n        \n    def updateMatrix(self, changed=None):\n        if not self._matrixNeedsUpdate:\n            return\n\n        ## Make the childGroup\'s transform match the requested viewRange.\n        bounds = self.rect()\n        \n        vr = self.viewRect()\n        if vr.height() == 0 or vr.width() == 0:\n            return\n        scale = Point(bounds.width()/vr.width(), bounds.height()/vr.height())\n        if not self.state[\'yInverted\']:\n            scale = scale * Point(1, -1)\n        if self.state[\'xInverted\']:\n            scale = scale * Point(-1, 1)\n        m = QtGui.QTransform()\n        \n        ## First center the viewport at 0\n        center = bounds.center()\n        m.translate(center.x(), center.y())\n            \n        ## Now scale and translate properly\n        m.scale(scale[0], scale[1])\n        st = Point(vr.center())\n        m.translate(-st[0], -st[1])\n        \n        self.childGroup.setTransform(m)\n        \n        self.sigTransformChanged.emit(self)  ## segfaults here: 1\n        self._matrixNeedsUpdate = False\n\n    def paint(self, p, opt, widget):\n        self.checkSceneChange()\n        \n        if self.border is not None:\n            bounds = self.shape()\n            p.setPen(self.border)\n            #p.fillRect(bounds, QtGui.QColor(0, 0, 0))\n            p.drawPath(bounds)\n            \n        #p.setPen(fn.mkPen(\'r\'))\n        #path = QtGui.QPainterPath()\n        #path.addRect(self.targetRect())\n        #tr = self.mapFromView(path)\n        #p.drawPath(tr)\n\n    def updateBackground(self):\n        bg = self.state[\'background\']\n        if bg is None:\n            self.background.hide()\n        else:\n            self.background.show()\n            self.background.setBrush(fn.mkBrush(bg))\n            \n    def updateViewLists(self):\n        try:\n            self.window()\n        except RuntimeError:  ## this view has already been deleted; it will probably be collected shortly.\n            return\n            \n        def cmpViews(a, b):\n            wins = 100 * cmp(a.window() is self.window(), b.window() is self.window())\n            alpha = cmp(a.name, b.name)\n            return wins + alpha\n            \n        ## make a sorted list of all named views\n        nv = list(ViewBox.NamedViews.values())\n        sortList(nv, cmpViews) ## see pyqtgraph.python2_3.sortList\n        \n        if self in nv:\n            nv.remove(self)\n            \n        self.menu.setViewList(nv)\n        \n        for ax in [0,1]:\n            link = self.state[\'linkedViews\'][ax]\n            if isinstance(link, basestring):     ## axis has not been linked yet; see if it\'s possible now\n                for v in nv:\n                    if link == v.name:\n                        self.linkView(ax, v)\n\n    @staticmethod\n    def updateAllViewLists():\n        for v in ViewBox.AllViews:\n            v.updateViewLists()\n\n    @staticmethod\n    def forgetView(vid, name):\n        if ViewBox is None:     ## can happen as python is shutting down\n            return\n        if QtGui.QApplication.instance() is None:\n            return\n        ## Called with ID and name of view (the view itself is no longer available)\n        for v in list(ViewBox.AllViews.keys()):\n            if id(v) == vid:\n                ViewBox.AllViews.pop(v)\n                break\n        ViewBox.NamedViews.pop(name, None)\n        ViewBox.updateAllViewLists()\n\n    @staticmethod\n    def quit():\n        ## called when the application is about to exit.\n        ## this disables all callbacks, which might otherwise generate errors if invoked during exit.\n        for k in ViewBox.AllViews:\n            if isQObjectAlive(k) and getConfigOption(\'crashWarning\'):\n                sys.stderr.write(\'Warning: ViewBox should be closed before application exit.\\n\')\n                \n            try:\n                k.destroyed.disconnect()\n            except RuntimeError:  ## signal is already disconnected.\n                pass\n            except TypeError:  ## view has already been deleted (?)\n                pass\n            except AttributeError:  # PySide has deleted signal\n                pass\n            \n    def locate(self, item, timeout=3.0, children=False):\n        """"""\n        Temporarily display the bounding rect of an item and lines connecting to the center of the view.\n        This is useful for determining the location of items that may be out of the range of the ViewBox.\n        if allChildren is True, then the bounding rect of all item\'s children will be shown instead.\n        """"""\n        self.clearLocate()\n        \n        if item.scene() is not self.scene():\n            raise Exception(""Item does not share a scene with this ViewBox."")\n        \n        c = self.viewRect().center()\n        if children:\n            br = self.mapFromItemToView(item, item.childrenBoundingRect()).boundingRect()\n        else:\n            br = self.mapFromItemToView(item, item.boundingRect()).boundingRect()\n        \n        g = ItemGroup()\n        g.setParentItem(self.childGroup)\n        self.locateGroup = g\n        g.box = QtGui.QGraphicsRectItem(br)\n        g.box.setParentItem(g)\n        g.lines = []\n        for p in (br.topLeft(), br.bottomLeft(), br.bottomRight(), br.topRight()):\n            line = QtGui.QGraphicsLineItem(c.x(), c.y(), p.x(), p.y())\n            line.setParentItem(g)\n            g.lines.append(line)\n            \n        for item in g.childItems():\n            item.setPen(fn.mkPen(color=\'y\', width=3))\n        g.setZValue(1000000)\n        \n        if children:\n            g.path = QtGui.QGraphicsPathItem(g.childrenShape())\n        else:\n            g.path = QtGui.QGraphicsPathItem(g.shape())\n        g.path.setParentItem(g)\n        g.path.setPen(fn.mkPen(\'g\'))\n        g.path.setZValue(100)\n        \n        QtCore.QTimer.singleShot(timeout*1000, self.clearLocate)\n    \n    def clearLocate(self):\n        if self.locateGroup is None:\n            return\n        self.scene().removeItem(self.locateGroup)\n        self.locateGroup = None\n\n\nfrom .ViewBoxMenu import ViewBoxMenu\n'"
src/third_party/pyqtgraph/graphicsItems/ViewBox/ViewBoxMenu.py,0,"b'from ...Qt import QtCore, QtGui, QT_LIB\nfrom ...python2_3 import asUnicode\nfrom ...WidgetGroup import WidgetGroup\n\nif QT_LIB == \'PyQt4\':\n    from .axisCtrlTemplate_pyqt import Ui_Form as AxisCtrlTemplate\nelif QT_LIB == \'PySide\':\n    from .axisCtrlTemplate_pyside import Ui_Form as AxisCtrlTemplate\nelif QT_LIB == \'PyQt5\':\n    from .axisCtrlTemplate_pyqt5 import Ui_Form as AxisCtrlTemplate\nelif QT_LIB == \'PySide2\':\n    from .axisCtrlTemplate_pyside2 import Ui_Form as AxisCtrlTemplate\n\nimport weakref \n\nclass ViewBoxMenu(QtGui.QMenu):\n    def __init__(self, view):\n        QtGui.QMenu.__init__(self)\n        \n        self.view = weakref.ref(view)  ## keep weakref to view to avoid circular reference (don\'t know why, but this prevents the ViewBox from being collected)\n        self.valid = False  ## tells us whether the ui needs to be updated\n        self.viewMap = weakref.WeakValueDictionary()  ## weakrefs to all views listed in the link combos\n\n        self.setTitle(""ViewBox options"")\n        self.viewAll = QtGui.QAction(""View All"", self)\n        self.viewAll.triggered.connect(self.autoRange)\n        self.addAction(self.viewAll)\n        \n        self.axes = []\n        self.ctrl = []\n        self.widgetGroups = []\n        self.dv = QtGui.QDoubleValidator(self)\n        for axis in \'XY\':\n            m = QtGui.QMenu()\n            m.setTitle(""%s Axis"" % axis)\n            w = QtGui.QWidget()\n            ui = AxisCtrlTemplate()\n            ui.setupUi(w)\n            a = QtGui.QWidgetAction(self)\n            a.setDefaultWidget(w)\n            m.addAction(a)\n            self.addMenu(m)\n            self.axes.append(m)\n            self.ctrl.append(ui)\n            wg = WidgetGroup(w)\n            self.widgetGroups.append(w)\n            \n            connects = [\n                (ui.mouseCheck.toggled, \'MouseToggled\'),\n                (ui.manualRadio.clicked, \'ManualClicked\'),\n                (ui.minText.editingFinished, \'MinTextChanged\'),\n                (ui.maxText.editingFinished, \'MaxTextChanged\'),\n                (ui.autoRadio.clicked, \'AutoClicked\'),\n                (ui.autoPercentSpin.valueChanged, \'AutoSpinChanged\'),\n                (ui.linkCombo.currentIndexChanged, \'LinkComboChanged\'),\n                (ui.autoPanCheck.toggled, \'AutoPanToggled\'),\n                (ui.visibleOnlyCheck.toggled, \'VisibleOnlyToggled\')\n            ]\n            \n            for sig, fn in connects:\n                sig.connect(getattr(self, axis.lower()+fn))\n\n        self.ctrl[0].invertCheck.toggled.connect(self.xInvertToggled)\n        self.ctrl[1].invertCheck.toggled.connect(self.yInvertToggled)\n        ## exporting is handled by GraphicsScene now\n        #self.export = QtGui.QMenu(""Export"")\n        #self.setExportMethods(view.exportMethods)\n        #self.addMenu(self.export)\n        \n        self.leftMenu = QtGui.QMenu(""Mouse Mode"")\n        group = QtGui.QActionGroup(self)\n        \n        # This does not work! QAction _must_ be initialized with a permanent \n        # object as the parent or else it may be collected prematurely.\n        #pan = self.leftMenu.addAction(""3 button"", self.set3ButtonMode)\n        #zoom = self.leftMenu.addAction(""1 button"", self.set1ButtonMode)\n        pan = QtGui.QAction(""3 button"", self.leftMenu)\n        zoom = QtGui.QAction(""1 button"", self.leftMenu)\n        self.leftMenu.addAction(pan)\n        self.leftMenu.addAction(zoom)\n        pan.triggered.connect(self.set3ButtonMode)\n        zoom.triggered.connect(self.set1ButtonMode)\n        \n        pan.setCheckable(True)\n        zoom.setCheckable(True)\n        pan.setActionGroup(group)\n        zoom.setActionGroup(group)\n        self.mouseModes = [pan, zoom]\n        self.addMenu(self.leftMenu)\n        \n        self.view().sigStateChanged.connect(self.viewStateChanged)\n        \n        self.updateState()\n\n    def setExportMethods(self, methods):\n        self.exportMethods = methods\n        self.export.clear()\n        for opt, fn in methods.items():\n            self.export.addAction(opt, self.exportMethod)\n        \n\n    def viewStateChanged(self):\n        self.valid = False\n        if self.ctrl[0].minText.isVisible() or self.ctrl[1].minText.isVisible():\n            self.updateState()\n        \n    def updateState(self):\n        ## Something about the viewbox has changed; update the menu GUI\n        \n        state = self.view().getState(copy=False)\n        if state[\'mouseMode\'] == ViewBox.PanMode:\n            self.mouseModes[0].setChecked(True)\n        else:\n            self.mouseModes[1].setChecked(True)\n            \n        for i in [0,1]:  # x, y\n            tr = state[\'targetRange\'][i]\n            self.ctrl[i].minText.setText(""%0.5g"" % tr[0])\n            self.ctrl[i].maxText.setText(""%0.5g"" % tr[1])\n            if state[\'autoRange\'][i] is not False:\n                self.ctrl[i].autoRadio.setChecked(True)\n                if state[\'autoRange\'][i] is not True:\n                    self.ctrl[i].autoPercentSpin.setValue(state[\'autoRange\'][i]*100)\n            else:\n                self.ctrl[i].manualRadio.setChecked(True)\n            self.ctrl[i].mouseCheck.setChecked(state[\'mouseEnabled\'][i])\n            \n            ## Update combo to show currently linked view\n            c = self.ctrl[i].linkCombo\n            c.blockSignals(True)\n            try:\n                view = state[\'linkedViews\'][i]  ## will always be string or None\n                if view is None:\n                    view = \'\'\n                    \n                ind = c.findText(view)\n                    \n                if ind == -1:\n                    ind = 0\n                c.setCurrentIndex(ind)\n            finally:\n                c.blockSignals(False)\n            \n            self.ctrl[i].autoPanCheck.setChecked(state[\'autoPan\'][i])\n            self.ctrl[i].visibleOnlyCheck.setChecked(state[\'autoVisibleOnly\'][i])\n            xy = [\'x\', \'y\'][i]\n            self.ctrl[i].invertCheck.setChecked(state.get(xy+\'Inverted\', False))\n        \n        self.valid = True\n        \n    def popup(self, *args):\n        if not self.valid:\n            self.updateState()\n        QtGui.QMenu.popup(self, *args)\n        \n    def autoRange(self):\n        self.view().autoRange()  ## don\'t let signal call this directly--it\'ll add an unwanted argument\n\n    def xMouseToggled(self, b):\n        self.view().setMouseEnabled(x=b)\n\n    def xManualClicked(self):\n        self.view().enableAutoRange(ViewBox.XAxis, False)\n        \n    def xMinTextChanged(self):\n        self.ctrl[0].manualRadio.setChecked(True)\n        self.view().setXRange(float(self.ctrl[0].minText.text()), float(self.ctrl[0].maxText.text()), padding=0)\n\n    def xMaxTextChanged(self):\n        self.ctrl[0].manualRadio.setChecked(True)\n        self.view().setXRange(float(self.ctrl[0].minText.text()), float(self.ctrl[0].maxText.text()), padding=0)\n        \n    def xAutoClicked(self):\n        val = self.ctrl[0].autoPercentSpin.value() * 0.01\n        self.view().enableAutoRange(ViewBox.XAxis, val)\n        \n    def xAutoSpinChanged(self, val):\n        self.ctrl[0].autoRadio.setChecked(True)\n        self.view().enableAutoRange(ViewBox.XAxis, val*0.01)\n\n    def xLinkComboChanged(self, ind):\n        self.view().setXLink(str(self.ctrl[0].linkCombo.currentText()))\n\n    def xAutoPanToggled(self, b):\n        self.view().setAutoPan(x=b)\n    \n    def xVisibleOnlyToggled(self, b):\n        self.view().setAutoVisible(x=b)\n\n\n    def yMouseToggled(self, b):\n        self.view().setMouseEnabled(y=b)\n\n    def yManualClicked(self):\n        self.view().enableAutoRange(ViewBox.YAxis, False)\n        \n    def yMinTextChanged(self):\n        self.ctrl[1].manualRadio.setChecked(True)\n        self.view().setYRange(float(self.ctrl[1].minText.text()), float(self.ctrl[1].maxText.text()), padding=0)\n        \n    def yMaxTextChanged(self):\n        self.ctrl[1].manualRadio.setChecked(True)\n        self.view().setYRange(float(self.ctrl[1].minText.text()), float(self.ctrl[1].maxText.text()), padding=0)\n        \n    def yAutoClicked(self):\n        val = self.ctrl[1].autoPercentSpin.value() * 0.01\n        self.view().enableAutoRange(ViewBox.YAxis, val)\n        \n    def yAutoSpinChanged(self, val):\n        self.ctrl[1].autoRadio.setChecked(True)\n        self.view().enableAutoRange(ViewBox.YAxis, val*0.01)\n\n    def yLinkComboChanged(self, ind):\n        self.view().setYLink(str(self.ctrl[1].linkCombo.currentText()))\n\n    def yAutoPanToggled(self, b):\n        self.view().setAutoPan(y=b)\n    \n    def yVisibleOnlyToggled(self, b):\n        self.view().setAutoVisible(y=b)\n\n    def yInvertToggled(self, b):\n        self.view().invertY(b)\n\n    def xInvertToggled(self, b):\n        self.view().invertX(b)\n\n    def exportMethod(self):\n        act = self.sender()\n        self.exportMethods[str(act.text())]()\n\n    def set3ButtonMode(self):\n        self.view().setLeftButtonAction(\'pan\')\n        \n    def set1ButtonMode(self):\n        self.view().setLeftButtonAction(\'rect\')\n        \n    def setViewList(self, views):\n        names = [\'\']\n        self.viewMap.clear()\n        \n        ## generate list of views to show in the link combo\n        for v in views:\n            name = v.name\n            if name is None:  ## unnamed views do not show up in the view list (although they are linkable)\n                continue\n            names.append(name)\n            self.viewMap[name] = v\n            \n        for i in [0,1]:\n            c = self.ctrl[i].linkCombo\n            current = asUnicode(c.currentText())\n            c.blockSignals(True)\n            changed = True\n            try:\n                c.clear()\n                for name in names:\n                    c.addItem(name)\n                    if name == current:\n                        changed = False\n                        c.setCurrentIndex(c.count()-1)\n            finally:\n                c.blockSignals(False)\n                \n            if changed:\n                c.setCurrentIndex(0)\n                c.currentIndexChanged.emit(c.currentIndex())\n        \nfrom .ViewBox import ViewBox\n        \n    \n'"
src/third_party/pyqtgraph/graphicsItems/ViewBox/__init__.py,0,b'from .ViewBox import ViewBox\n'
src/third_party/pyqtgraph/graphicsItems/ViewBox/axisCtrlTemplate_pyqt.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/graphicsItems/ViewBox/axisCtrlTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:51 2013\n#      by: PyQt4 UI code generator 4.10\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom ...Qt import QtCore, QtGui\n\ntry:\n    _fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n    def _fromUtf8(s):\n        return s\n\ntry:\n    _encoding = QtGui.QApplication.UnicodeUTF8\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig, _encoding)\nexcept AttributeError:\n    def _translate(context, text, disambig):\n        return QtGui.QApplication.translate(context, text, disambig)\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(""Form""))\n        Form.resize(186, 154)\n        Form.setMaximumSize(QtCore.QSize(200, 16777215))\n        self.gridLayout = QtGui.QGridLayout(Form)\n        self.gridLayout.setMargin(0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(_fromUtf8(""gridLayout""))\n        self.label = QtGui.QLabel(Form)\n        self.label.setObjectName(_fromUtf8(""label""))\n        self.gridLayout.addWidget(self.label, 7, 0, 1, 2)\n        self.linkCombo = QtGui.QComboBox(Form)\n        self.linkCombo.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)\n        self.linkCombo.setObjectName(_fromUtf8(""linkCombo""))\n        self.gridLayout.addWidget(self.linkCombo, 7, 2, 1, 2)\n        self.autoPercentSpin = QtGui.QSpinBox(Form)\n        self.autoPercentSpin.setEnabled(True)\n        self.autoPercentSpin.setMinimum(1)\n        self.autoPercentSpin.setMaximum(100)\n        self.autoPercentSpin.setSingleStep(1)\n        self.autoPercentSpin.setProperty(""value"", 100)\n        self.autoPercentSpin.setObjectName(_fromUtf8(""autoPercentSpin""))\n        self.gridLayout.addWidget(self.autoPercentSpin, 2, 2, 1, 2)\n        self.autoRadio = QtGui.QRadioButton(Form)\n        self.autoRadio.setChecked(True)\n        self.autoRadio.setObjectName(_fromUtf8(""autoRadio""))\n        self.gridLayout.addWidget(self.autoRadio, 2, 0, 1, 2)\n        self.manualRadio = QtGui.QRadioButton(Form)\n        self.manualRadio.setObjectName(_fromUtf8(""manualRadio""))\n        self.gridLayout.addWidget(self.manualRadio, 1, 0, 1, 2)\n        self.minText = QtGui.QLineEdit(Form)\n        self.minText.setObjectName(_fromUtf8(""minText""))\n        self.gridLayout.addWidget(self.minText, 1, 2, 1, 1)\n        self.maxText = QtGui.QLineEdit(Form)\n        self.maxText.setObjectName(_fromUtf8(""maxText""))\n        self.gridLayout.addWidget(self.maxText, 1, 3, 1, 1)\n        self.invertCheck = QtGui.QCheckBox(Form)\n        self.invertCheck.setObjectName(_fromUtf8(""invertCheck""))\n        self.gridLayout.addWidget(self.invertCheck, 5, 0, 1, 4)\n        self.mouseCheck = QtGui.QCheckBox(Form)\n        self.mouseCheck.setChecked(True)\n        self.mouseCheck.setObjectName(_fromUtf8(""mouseCheck""))\n        self.gridLayout.addWidget(self.mouseCheck, 6, 0, 1, 4)\n        self.visibleOnlyCheck = QtGui.QCheckBox(Form)\n        self.visibleOnlyCheck.setObjectName(_fromUtf8(""visibleOnlyCheck""))\n        self.gridLayout.addWidget(self.visibleOnlyCheck, 3, 2, 1, 2)\n        self.autoPanCheck = QtGui.QCheckBox(Form)\n        self.autoPanCheck.setObjectName(_fromUtf8(""autoPanCheck""))\n        self.gridLayout.addWidget(self.autoPanCheck, 4, 2, 1, 2)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(_translate(""Form"", ""Form"", None))\n        self.label.setText(_translate(""Form"", ""Link Axis:"", None))\n        self.linkCombo.setToolTip(_translate(""Form"", ""<html><head/><body><p>Links this axis with another view. When linked, both views will display the same data range.</p></body></html>"", None))\n        self.autoPercentSpin.setToolTip(_translate(""Form"", ""<html><head/><body><p>Percent of data to be visible when auto-scaling. It may be useful to decrease this value for data with spiky noise.</p></body></html>"", None))\n        self.autoPercentSpin.setSuffix(_translate(""Form"", ""%"", None))\n        self.autoRadio.setToolTip(_translate(""Form"", ""<html><head/><body><p>Automatically resize this axis whenever the displayed data is changed.</p></body></html>"", None))\n        self.autoRadio.setText(_translate(""Form"", ""Auto"", None))\n        self.manualRadio.setToolTip(_translate(""Form"", ""<html><head/><body><p>Set the range for this axis manually. This disables automatic scaling. </p></body></html>"", None))\n        self.manualRadio.setText(_translate(""Form"", ""Manual"", None))\n        self.minText.setToolTip(_translate(""Form"", ""<html><head/><body><p>Minimum value to display for this axis.</p></body></html>"", None))\n        self.minText.setText(_translate(""Form"", ""0"", None))\n        self.maxText.setToolTip(_translate(""Form"", ""<html><head/><body><p>Maximum value to display for this axis.</p></body></html>"", None))\n        self.maxText.setText(_translate(""Form"", ""0"", None))\n        self.invertCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>Inverts the display of this axis. (+y points downward instead of upward)</p></body></html>"", None))\n        self.invertCheck.setText(_translate(""Form"", ""Invert Axis"", None))\n        self.mouseCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>Enables mouse interaction (panning, scaling) for this axis.</p></body></html>"", None))\n        self.mouseCheck.setText(_translate(""Form"", ""Mouse Enabled"", None))\n        self.visibleOnlyCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>When checked, the axis will only auto-scale to data that is visible along the orthogonal axis.</p></body></html>"", None))\n        self.visibleOnlyCheck.setText(_translate(""Form"", ""Visible Data Only"", None))\n        self.autoPanCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>When checked, the axis will automatically pan to center on the current data, but the scale along this axis will not change.</p></body></html>"", None))\n        self.autoPanCheck.setText(_translate(""Form"", ""Auto Pan Only"", None))\n\n'"
src/third_party/pyqtgraph/graphicsItems/ViewBox/axisCtrlTemplate_pyqt5.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/graphicsItems/ViewBox/axisCtrlTemplate.ui\'\n#\n# Created: Wed Mar 26 15:09:28 2014\n#      by: PyQt5 UI code generator 5.0.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(186, 154)\n        Form.setMaximumSize(QtCore.QSize(200, 16777215))\n        self.gridLayout = QtWidgets.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.label = QtWidgets.QLabel(Form)\n        self.label.setObjectName(""label"")\n        self.gridLayout.addWidget(self.label, 7, 0, 1, 2)\n        self.linkCombo = QtWidgets.QComboBox(Form)\n        self.linkCombo.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)\n        self.linkCombo.setObjectName(""linkCombo"")\n        self.gridLayout.addWidget(self.linkCombo, 7, 2, 1, 2)\n        self.autoPercentSpin = QtWidgets.QSpinBox(Form)\n        self.autoPercentSpin.setEnabled(True)\n        self.autoPercentSpin.setMinimum(1)\n        self.autoPercentSpin.setMaximum(100)\n        self.autoPercentSpin.setSingleStep(1)\n        self.autoPercentSpin.setProperty(""value"", 100)\n        self.autoPercentSpin.setObjectName(""autoPercentSpin"")\n        self.gridLayout.addWidget(self.autoPercentSpin, 2, 2, 1, 2)\n        self.autoRadio = QtWidgets.QRadioButton(Form)\n        self.autoRadio.setChecked(True)\n        self.autoRadio.setObjectName(""autoRadio"")\n        self.gridLayout.addWidget(self.autoRadio, 2, 0, 1, 2)\n        self.manualRadio = QtWidgets.QRadioButton(Form)\n        self.manualRadio.setObjectName(""manualRadio"")\n        self.gridLayout.addWidget(self.manualRadio, 1, 0, 1, 2)\n        self.minText = QtWidgets.QLineEdit(Form)\n        self.minText.setObjectName(""minText"")\n        self.gridLayout.addWidget(self.minText, 1, 2, 1, 1)\n        self.maxText = QtWidgets.QLineEdit(Form)\n        self.maxText.setObjectName(""maxText"")\n        self.gridLayout.addWidget(self.maxText, 1, 3, 1, 1)\n        self.invertCheck = QtWidgets.QCheckBox(Form)\n        self.invertCheck.setObjectName(""invertCheck"")\n        self.gridLayout.addWidget(self.invertCheck, 5, 0, 1, 4)\n        self.mouseCheck = QtWidgets.QCheckBox(Form)\n        self.mouseCheck.setChecked(True)\n        self.mouseCheck.setObjectName(""mouseCheck"")\n        self.gridLayout.addWidget(self.mouseCheck, 6, 0, 1, 4)\n        self.visibleOnlyCheck = QtWidgets.QCheckBox(Form)\n        self.visibleOnlyCheck.setObjectName(""visibleOnlyCheck"")\n        self.gridLayout.addWidget(self.visibleOnlyCheck, 3, 2, 1, 2)\n        self.autoPanCheck = QtWidgets.QCheckBox(Form)\n        self.autoPanCheck.setObjectName(""autoPanCheck"")\n        self.gridLayout.addWidget(self.autoPanCheck, 4, 2, 1, 2)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Form""))\n        self.label.setText(_translate(""Form"", ""Link Axis:""))\n        self.linkCombo.setToolTip(_translate(""Form"", ""<html><head/><body><p>Links this axis with another view. When linked, both views will display the same data range.</p></body></html>""))\n        self.autoPercentSpin.setToolTip(_translate(""Form"", ""<html><head/><body><p>Percent of data to be visible when auto-scaling. It may be useful to decrease this value for data with spiky noise.</p></body></html>""))\n        self.autoPercentSpin.setSuffix(_translate(""Form"", ""%""))\n        self.autoRadio.setToolTip(_translate(""Form"", ""<html><head/><body><p>Automatically resize this axis whenever the displayed data is changed.</p></body></html>""))\n        self.autoRadio.setText(_translate(""Form"", ""Auto""))\n        self.manualRadio.setToolTip(_translate(""Form"", ""<html><head/><body><p>Set the range for this axis manually. This disables automatic scaling. </p></body></html>""))\n        self.manualRadio.setText(_translate(""Form"", ""Manual""))\n        self.minText.setToolTip(_translate(""Form"", ""<html><head/><body><p>Minimum value to display for this axis.</p></body></html>""))\n        self.minText.setText(_translate(""Form"", ""0""))\n        self.maxText.setToolTip(_translate(""Form"", ""<html><head/><body><p>Maximum value to display for this axis.</p></body></html>""))\n        self.maxText.setText(_translate(""Form"", ""0""))\n        self.invertCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>Inverts the display of this axis. (+y points downward instead of upward)</p></body></html>""))\n        self.invertCheck.setText(_translate(""Form"", ""Invert Axis""))\n        self.mouseCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>Enables mouse interaction (panning, scaling) for this axis.</p></body></html>""))\n        self.mouseCheck.setText(_translate(""Form"", ""Mouse Enabled""))\n        self.visibleOnlyCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>When checked, the axis will only auto-scale to data that is visible along the orthogonal axis.</p></body></html>""))\n        self.visibleOnlyCheck.setText(_translate(""Form"", ""Visible Data Only""))\n        self.autoPanCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>When checked, the axis will automatically pan to center on the current data, but the scale along this axis will not change.</p></body></html>""))\n        self.autoPanCheck.setText(_translate(""Form"", ""Auto Pan Only""))\n\n'"
src/third_party/pyqtgraph/graphicsItems/ViewBox/axisCtrlTemplate_pyside.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/graphicsItems/ViewBox/axisCtrlTemplate.ui\'\n#\n# Created: Mon Dec 23 10:10:51 2013\n#      by: pyside-uic 0.2.14 running on PySide 1.1.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide import QtCore, QtGui\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(186, 154)\n        Form.setMaximumSize(QtCore.QSize(200, 16777215))\n        self.gridLayout = QtGui.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.label = QtGui.QLabel(Form)\n        self.label.setObjectName(""label"")\n        self.gridLayout.addWidget(self.label, 7, 0, 1, 2)\n        self.linkCombo = QtGui.QComboBox(Form)\n        self.linkCombo.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)\n        self.linkCombo.setObjectName(""linkCombo"")\n        self.gridLayout.addWidget(self.linkCombo, 7, 2, 1, 2)\n        self.autoPercentSpin = QtGui.QSpinBox(Form)\n        self.autoPercentSpin.setEnabled(True)\n        self.autoPercentSpin.setMinimum(1)\n        self.autoPercentSpin.setMaximum(100)\n        self.autoPercentSpin.setSingleStep(1)\n        self.autoPercentSpin.setProperty(""value"", 100)\n        self.autoPercentSpin.setObjectName(""autoPercentSpin"")\n        self.gridLayout.addWidget(self.autoPercentSpin, 2, 2, 1, 2)\n        self.autoRadio = QtGui.QRadioButton(Form)\n        self.autoRadio.setChecked(True)\n        self.autoRadio.setObjectName(""autoRadio"")\n        self.gridLayout.addWidget(self.autoRadio, 2, 0, 1, 2)\n        self.manualRadio = QtGui.QRadioButton(Form)\n        self.manualRadio.setObjectName(""manualRadio"")\n        self.gridLayout.addWidget(self.manualRadio, 1, 0, 1, 2)\n        self.minText = QtGui.QLineEdit(Form)\n        self.minText.setObjectName(""minText"")\n        self.gridLayout.addWidget(self.minText, 1, 2, 1, 1)\n        self.maxText = QtGui.QLineEdit(Form)\n        self.maxText.setObjectName(""maxText"")\n        self.gridLayout.addWidget(self.maxText, 1, 3, 1, 1)\n        self.invertCheck = QtGui.QCheckBox(Form)\n        self.invertCheck.setObjectName(""invertCheck"")\n        self.gridLayout.addWidget(self.invertCheck, 5, 0, 1, 4)\n        self.mouseCheck = QtGui.QCheckBox(Form)\n        self.mouseCheck.setChecked(True)\n        self.mouseCheck.setObjectName(""mouseCheck"")\n        self.gridLayout.addWidget(self.mouseCheck, 6, 0, 1, 4)\n        self.visibleOnlyCheck = QtGui.QCheckBox(Form)\n        self.visibleOnlyCheck.setObjectName(""visibleOnlyCheck"")\n        self.gridLayout.addWidget(self.visibleOnlyCheck, 3, 2, 1, 2)\n        self.autoPanCheck = QtGui.QCheckBox(Form)\n        self.autoPanCheck.setObjectName(""autoPanCheck"")\n        self.gridLayout.addWidget(self.autoPanCheck, 4, 2, 1, 2)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        Form.setWindowTitle(QtGui.QApplication.translate(""Form"", ""Form"", None, QtGui.QApplication.UnicodeUTF8))\n        self.label.setText(QtGui.QApplication.translate(""Form"", ""Link Axis:"", None, QtGui.QApplication.UnicodeUTF8))\n        self.linkCombo.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>Links this axis with another view. When linked, both views will display the same data range.</p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoPercentSpin.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>Percent of data to be visible when auto-scaling. It may be useful to decrease this value for data with spiky noise.</p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoPercentSpin.setSuffix(QtGui.QApplication.translate(""Form"", ""%"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoRadio.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>Automatically resize this axis whenever the displayed data is changed.</p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoRadio.setText(QtGui.QApplication.translate(""Form"", ""Auto"", None, QtGui.QApplication.UnicodeUTF8))\n        self.manualRadio.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>Set the range for this axis manually. This disables automatic scaling. </p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.manualRadio.setText(QtGui.QApplication.translate(""Form"", ""Manual"", None, QtGui.QApplication.UnicodeUTF8))\n        self.minText.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>Minimum value to display for this axis.</p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.minText.setText(QtGui.QApplication.translate(""Form"", ""0"", None, QtGui.QApplication.UnicodeUTF8))\n        self.maxText.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>Maximum value to display for this axis.</p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.maxText.setText(QtGui.QApplication.translate(""Form"", ""0"", None, QtGui.QApplication.UnicodeUTF8))\n        self.invertCheck.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>Inverts the display of this axis. (+y points downward instead of upward)</p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.invertCheck.setText(QtGui.QApplication.translate(""Form"", ""Invert Axis"", None, QtGui.QApplication.UnicodeUTF8))\n        self.mouseCheck.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>Enables mouse interaction (panning, scaling) for this axis.</p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.mouseCheck.setText(QtGui.QApplication.translate(""Form"", ""Mouse Enabled"", None, QtGui.QApplication.UnicodeUTF8))\n        self.visibleOnlyCheck.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>When checked, the axis will only auto-scale to data that is visible along the orthogonal axis.</p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.visibleOnlyCheck.setText(QtGui.QApplication.translate(""Form"", ""Visible Data Only"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoPanCheck.setToolTip(QtGui.QApplication.translate(""Form"", ""<html><head/><body><p>When checked, the axis will automatically pan to center on the current data, but the scale along this axis will not change.</p></body></html>"", None, QtGui.QApplication.UnicodeUTF8))\n        self.autoPanCheck.setText(QtGui.QApplication.translate(""Form"", ""Auto Pan Only"", None, QtGui.QApplication.UnicodeUTF8))\n\n'"
src/third_party/pyqtgraph/graphicsItems/ViewBox/axisCtrlTemplate_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'./pyqtgraph/graphicsItems/ViewBox/axisCtrlTemplate.ui\'\n#\n# Created: Wed Mar 26 15:09:28 2014\n#      by: PyQt5 UI code generator 5.0.1\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PySide2 import QtCore, QtGui, QtWidgets\n\nclass Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(""Form"")\n        Form.resize(186, 154)\n        Form.setMaximumSize(QtCore.QSize(200, 16777215))\n        self.gridLayout = QtWidgets.QGridLayout(Form)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.label = QtWidgets.QLabel(Form)\n        self.label.setObjectName(""label"")\n        self.gridLayout.addWidget(self.label, 7, 0, 1, 2)\n        self.linkCombo = QtWidgets.QComboBox(Form)\n        self.linkCombo.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)\n        self.linkCombo.setObjectName(""linkCombo"")\n        self.gridLayout.addWidget(self.linkCombo, 7, 2, 1, 2)\n        self.autoPercentSpin = QtWidgets.QSpinBox(Form)\n        self.autoPercentSpin.setEnabled(True)\n        self.autoPercentSpin.setMinimum(1)\n        self.autoPercentSpin.setMaximum(100)\n        self.autoPercentSpin.setSingleStep(1)\n        self.autoPercentSpin.setProperty(""value"", 100)\n        self.autoPercentSpin.setObjectName(""autoPercentSpin"")\n        self.gridLayout.addWidget(self.autoPercentSpin, 2, 2, 1, 2)\n        self.autoRadio = QtWidgets.QRadioButton(Form)\n        self.autoRadio.setChecked(True)\n        self.autoRadio.setObjectName(""autoRadio"")\n        self.gridLayout.addWidget(self.autoRadio, 2, 0, 1, 2)\n        self.manualRadio = QtWidgets.QRadioButton(Form)\n        self.manualRadio.setObjectName(""manualRadio"")\n        self.gridLayout.addWidget(self.manualRadio, 1, 0, 1, 2)\n        self.minText = QtWidgets.QLineEdit(Form)\n        self.minText.setObjectName(""minText"")\n        self.gridLayout.addWidget(self.minText, 1, 2, 1, 1)\n        self.maxText = QtWidgets.QLineEdit(Form)\n        self.maxText.setObjectName(""maxText"")\n        self.gridLayout.addWidget(self.maxText, 1, 3, 1, 1)\n        self.invertCheck = QtWidgets.QCheckBox(Form)\n        self.invertCheck.setObjectName(""invertCheck"")\n        self.gridLayout.addWidget(self.invertCheck, 5, 0, 1, 4)\n        self.mouseCheck = QtWidgets.QCheckBox(Form)\n        self.mouseCheck.setChecked(True)\n        self.mouseCheck.setObjectName(""mouseCheck"")\n        self.gridLayout.addWidget(self.mouseCheck, 6, 0, 1, 4)\n        self.visibleOnlyCheck = QtWidgets.QCheckBox(Form)\n        self.visibleOnlyCheck.setObjectName(""visibleOnlyCheck"")\n        self.gridLayout.addWidget(self.visibleOnlyCheck, 3, 2, 1, 2)\n        self.autoPanCheck = QtWidgets.QCheckBox(Form)\n        self.autoPanCheck.setObjectName(""autoPanCheck"")\n        self.gridLayout.addWidget(self.autoPanCheck, 4, 2, 1, 2)\n\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(""Form"", ""Form""))\n        self.label.setText(_translate(""Form"", ""Link Axis:""))\n        self.linkCombo.setToolTip(_translate(""Form"", ""<html><head/><body><p>Links this axis with another view. When linked, both views will display the same data range.</p></body></html>""))\n        self.autoPercentSpin.setToolTip(_translate(""Form"", ""<html><head/><body><p>Percent of data to be visible when auto-scaling. It may be useful to decrease this value for data with spiky noise.</p></body></html>""))\n        self.autoPercentSpin.setSuffix(_translate(""Form"", ""%""))\n        self.autoRadio.setToolTip(_translate(""Form"", ""<html><head/><body><p>Automatically resize this axis whenever the displayed data is changed.</p></body></html>""))\n        self.autoRadio.setText(_translate(""Form"", ""Auto""))\n        self.manualRadio.setToolTip(_translate(""Form"", ""<html><head/><body><p>Set the range for this axis manually. This disables automatic scaling. </p></body></html>""))\n        self.manualRadio.setText(_translate(""Form"", ""Manual""))\n        self.minText.setToolTip(_translate(""Form"", ""<html><head/><body><p>Minimum value to display for this axis.</p></body></html>""))\n        self.minText.setText(_translate(""Form"", ""0""))\n        self.maxText.setToolTip(_translate(""Form"", ""<html><head/><body><p>Maximum value to display for this axis.</p></body></html>""))\n        self.maxText.setText(_translate(""Form"", ""0""))\n        self.invertCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>Inverts the display of this axis. (+y points downward instead of upward)</p></body></html>""))\n        self.invertCheck.setText(_translate(""Form"", ""Invert Axis""))\n        self.mouseCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>Enables mouse interaction (panning, scaling) for this axis.</p></body></html>""))\n        self.mouseCheck.setText(_translate(""Form"", ""Mouse Enabled""))\n        self.visibleOnlyCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>When checked, the axis will only auto-scale to data that is visible along the orthogonal axis.</p></body></html>""))\n        self.visibleOnlyCheck.setText(_translate(""Form"", ""Visible Data Only""))\n        self.autoPanCheck.setToolTip(_translate(""Form"", ""<html><head/><body><p>When checked, the axis will automatically pan to center on the current data, but the scale along this axis will not change.</p></body></html>""))\n        self.autoPanCheck.setText(_translate(""Form"", ""Auto Pan Only""))\n\n'"
src/third_party/pyqtgraph/graphicsItems/tests/test_GraphicsItem.py,0,b'import gc\nimport weakref\ntry:\n    import faulthandler\n    faulthandler.enable()\nexcept ImportError:\n    pass\n\nimport pyqtgraph as pg\npg.mkQApp()\n\ndef test_getViewWidget():\n    view = pg.PlotWidget()\n    vref = weakref.ref(view)\n    item = pg.InfiniteLine()\n    view.addItem(item)\n    assert item.getViewWidget() is view\n    del view\n    gc.collect()\n    assert vref() is None\n    assert item.getViewWidget() is None\n\ndef test_getViewWidget_deleted():\n    view = pg.PlotWidget()\n    item = pg.InfiniteLine()\n    view.addItem(item)\n    assert item.getViewWidget() is view\n    \n    # Arrange to have Qt automatically delete the view widget\n    obj = pg.QtGui.QWidget()\n    view.setParent(obj)\n    del obj\n    gc.collect()\n\n    assert not pg.Qt.isQObjectAlive(view)\n    assert item.getViewWidget() is None\n'
src/third_party/pyqtgraph/graphicsItems/tests/test_ImageItem.py,12,"b'import time\nimport pytest\nfrom pyqtgraph.Qt import QtCore, QtGui, QtTest\nimport numpy as np\nimport pyqtgraph as pg\nfrom pyqtgraph.tests import assertImageApproved, TransposedImageItem\n\napp = pg.mkQApp()\n\n\ndef test_ImageItem(transpose=False):\n    \n    w = pg.GraphicsWindow()    \n    view = pg.ViewBox()\n    w.setCentralWidget(view)\n    w.resize(200, 200)\n    w.show()\n    img = TransposedImageItem(border=0.5, transpose=transpose)\n\n    view.addItem(img)\n    \n    # test mono float\n    np.random.seed(0)\n    data = np.random.normal(size=(20, 20))\n    dmax = data.max()\n    data[:10, 1] = dmax + 10\n    data[1, :10] = dmax + 12\n    data[3, :10] = dmax + 13\n    img.setImage(data)\n    \n    QtTest.QTest.qWaitForWindowShown(w)\n    time.sleep(0.1)\n    app.processEvents()\n    assertImageApproved(w, \'imageitem/init\', \'Init image item. View is auto-scaled, image axis 0 marked by 1 line, axis 1 is marked by 2 lines. Origin in bottom-left.\')\n    \n    # ..with colormap\n    cmap = pg.ColorMap([0, 0.25, 0.75, 1], [[0, 0, 0, 255], [255, 0, 0, 255], [255, 255, 0, 255], [255, 255, 255, 255]])\n    img.setLookupTable(cmap.getLookupTable())\n    assertImageApproved(w, \'imageitem/lut\', \'Set image LUT.\')\n    \n    # ..and different levels\n    img.setLevels([dmax+9, dmax+13])\n    assertImageApproved(w, \'imageitem/levels1\', \'Levels show only axis lines.\')\n\n    img.setLookupTable(None)\n\n    # test mono int\n    data = np.fromfunction(lambda x,y: x+y*10, (129, 128)).astype(np.int16)\n    img.setImage(data)\n    assertImageApproved(w, \'imageitem/gradient_mono_int\', \'Mono int gradient.\')\n    \n    img.setLevels([640, 641])\n    assertImageApproved(w, \'imageitem/gradient_mono_int_levels\', \'Mono int gradient w/ levels to isolate diagonal.\')\n\n    # test mono byte\n    data = np.fromfunction(lambda x,y: x+y, (129, 128)).astype(np.ubyte)\n    img.setImage(data)\n    assertImageApproved(w, \'imageitem/gradient_mono_byte\', \'Mono byte gradient.\')\n    \n    img.setLevels([127, 128])\n    assertImageApproved(w, \'imageitem/gradient_mono_byte_levels\', \'Mono byte gradient w/ levels to isolate diagonal.\')\n\n    # test monochrome image\n    data = np.zeros((10, 10), dtype=\'uint8\')\n    data[:5,:5] = 1\n    data[5:,5:] = 1\n    img.setImage(data)\n    assertImageApproved(w, \'imageitem/monochrome\', \'Ubyte image with only 0,1 values.\')\n    \n    # test bool\n    data = data.astype(bool)\n    img.setImage(data)\n    assertImageApproved(w, \'imageitem/bool\', \'Boolean mask.\')\n\n    # test RGBA byte\n    data = np.zeros((100, 100, 4), dtype=\'ubyte\')\n    data[..., 0] = np.linspace(0, 255, 100).reshape(100, 1)\n    data[..., 1] = np.linspace(0, 255, 100).reshape(1, 100)\n    data[..., 3] = 255\n    img.setImage(data)\n    assertImageApproved(w, \'imageitem/gradient_rgba_byte\', \'RGBA byte gradient.\')\n    \n    img.setLevels([[128, 129], [128, 255], [0, 1], [0, 255]])\n    assertImageApproved(w, \'imageitem/gradient_rgba_byte_levels\', \'RGBA byte gradient. Levels set to show x=128 and y>128.\')\n    \n    # test RGBA float\n    data = data.astype(float)\n    img.setImage(data / 1e9)\n    assertImageApproved(w, \'imageitem/gradient_rgba_float\', \'RGBA float gradient.\')\n\n    # checkerboard to test alpha\n    img2 = TransposedImageItem(transpose=transpose)\n    img2.setImage(np.fromfunction(lambda x,y: (x+y)%2, (10, 10)), levels=[-1,2])\n    view.addItem(img2)\n    img2.scale(10, 10)\n    img2.setZValue(-10)\n    \n    data[..., 0] *= 1e-9\n    data[..., 1] *= 1e9\n    data[..., 3] = np.fromfunction(lambda x,y: np.sin(0.1 * (x+y)), (100, 100))\n    img.setImage(data, levels=[[0, 128e-9],[0, 128e9],[0, 1],[-1, 1]])\n    assertImageApproved(w, \'imageitem/gradient_rgba_float_alpha\', \'RGBA float gradient with alpha.\')    \n\n    # test composition mode\n    img.setCompositionMode(QtGui.QPainter.CompositionMode_Plus)\n    assertImageApproved(w, \'imageitem/gradient_rgba_float_additive\', \'RGBA float gradient with alpha and additive composition mode.\')    \n    \n    img2.hide()\n    img.setCompositionMode(QtGui.QPainter.CompositionMode_SourceOver)\n    \n    # test downsampling\n    data = np.fromfunction(lambda x,y: np.cos(0.002 * x**2), (800, 100))\n    img.setImage(data, levels=[-1, 1])\n    assertImageApproved(w, \'imageitem/resolution_without_downsampling\', \'Resolution test without downsampling.\')\n    \n    img.setAutoDownsample(True)\n    assertImageApproved(w, \'imageitem/resolution_with_downsampling_x\', \'Resolution test with downsampling axross x axis.\')\n    assert img._lastDownsample == (4, 1)\n    \n    img.setImage(data.T, levels=[-1, 1])\n    assertImageApproved(w, \'imageitem/resolution_with_downsampling_y\', \'Resolution test with downsampling across y axis.\')\n    assert img._lastDownsample == (1, 4)\n    \n    view.hide()\n\ndef test_ImageItem_axisorder():\n    # All image tests pass again using the opposite axis order\n    origMode = pg.getConfigOption(\'imageAxisOrder\')\n    altMode = \'row-major\' if origMode == \'col-major\' else \'col-major\'\n    pg.setConfigOptions(imageAxisOrder=altMode)\n    try:\n        test_ImageItem(transpose=True)\n    finally:\n        pg.setConfigOptions(imageAxisOrder=origMode)\n\n\n@pytest.mark.skipif(pg.Qt.QT_LIB==\'PySide\', reason=""pyside does not have qWait"")\ndef test_dividebyzero():\n    import pyqtgraph as pg\n    im = pg.image(pg.np.random.normal(size=(100,100)))\n    im.imageItem.setAutoDownsample(True)\n    im.view.setRange(xRange=[-5+25, 5e+25],yRange=[-5e+25, 5e+25])\n    app.processEvents()\n    QtTest.QTest.qWait(1000)\n    # must manually call im.imageItem.render here or the exception\n    # will only exist on the Qt event loop\n    im.imageItem.render()\n'"
src/third_party/pyqtgraph/graphicsItems/tests/test_InfiniteLine.py,0,"b""import pyqtgraph as pg\nfrom pyqtgraph.Qt import QtGui, QtCore, QtTest\nfrom pyqtgraph.tests import mouseDrag, mouseMove\npg.mkQApp()\n\n\ndef test_InfiniteLine():\n    # Test basic InfiniteLine API\n    plt = pg.plot()\n    plt.setXRange(-10, 10)\n    plt.setYRange(-10, 10)\n    plt.resize(600, 600)\n    \n    # seemingly arbitrary requirements; might need longer wait time for some platforms..\n    QtTest.QTest.qWaitForWindowShown(plt)\n    QtTest.QTest.qWait(100)\n    \n    vline = plt.addLine(x=1)\n    assert vline.angle == 90\n    br = vline.mapToView(QtGui.QPolygonF(vline.boundingRect()))\n    assert br.containsPoint(pg.Point(1, 5), QtCore.Qt.OddEvenFill)\n    assert not br.containsPoint(pg.Point(5, 0), QtCore.Qt.OddEvenFill)\n    hline = plt.addLine(y=0)\n    assert hline.angle == 0\n    assert hline.boundingRect().contains(pg.Point(5, 0))\n    assert not hline.boundingRect().contains(pg.Point(0, 5))\n\n    vline.setValue(2)\n    assert vline.value() == 2\n    vline.setPos(pg.Point(4, -5))\n    assert vline.value() == 4\n    \n    oline = pg.InfiniteLine(angle=30)\n    plt.addItem(oline)\n    oline.setPos(pg.Point(1, -1))\n    assert oline.angle == 30\n    assert oline.pos() == pg.Point(1, -1)\n    assert oline.value() == [1, -1]\n    \n    # test bounding rect for oblique line\n    br = oline.mapToScene(oline.boundingRect())\n    pos = oline.mapToScene(pg.Point(2, 0))\n    assert br.containsPoint(pos, QtCore.Qt.OddEvenFill)\n    px = pg.Point(-0.5, -1.0 / 3**0.5)\n    assert br.containsPoint(pos + 5 * px, QtCore.Qt.OddEvenFill)\n    assert not br.containsPoint(pos + 7 * px, QtCore.Qt.OddEvenFill)\n    \n\ndef test_mouseInteraction():\n    plt = pg.plot()\n    plt.scene().minDragTime = 0  # let us simulate mouse drags very quickly.\n    vline = plt.addLine(x=0, movable=True)\n    plt.addItem(vline)\n    hline = plt.addLine(y=0, movable=True)\n    hline2 = plt.addLine(y=-1, movable=False)\n    plt.setXRange(-10, 10)\n    plt.setYRange(-10, 10)\n    \n    # test horizontal drag\n    pos = plt.plotItem.vb.mapViewToScene(pg.Point(0,5)).toPoint()\n    pos2 = pos - QtCore.QPoint(200, 200)\n    mouseMove(plt, pos)\n    assert vline.mouseHovering is True and hline.mouseHovering is False\n    mouseDrag(plt, pos, pos2, QtCore.Qt.LeftButton)\n    px = vline.pixelLength(pg.Point(1, 0), ortho=True)\n    assert abs(vline.value() - plt.plotItem.vb.mapSceneToView(pos2).x()) <= px\n\n    # test missed drag\n    pos = plt.plotItem.vb.mapViewToScene(pg.Point(5,0)).toPoint()\n    pos = pos + QtCore.QPoint(0, 6)\n    pos2 = pos + QtCore.QPoint(-20, -20)\n    mouseMove(plt, pos)\n    assert vline.mouseHovering is False and hline.mouseHovering is False\n    mouseDrag(plt, pos, pos2, QtCore.Qt.LeftButton)\n    assert hline.value() == 0\n\n    # test vertical drag\n    pos = plt.plotItem.vb.mapViewToScene(pg.Point(5,0)).toPoint()\n    pos2 = pos - QtCore.QPoint(50, 50)\n    mouseMove(plt, pos)\n    assert vline.mouseHovering is False and hline.mouseHovering is True\n    mouseDrag(plt, pos, pos2, QtCore.Qt.LeftButton)\n    px = hline.pixelLength(pg.Point(1, 0), ortho=True)\n    assert abs(hline.value() - plt.plotItem.vb.mapSceneToView(pos2).y()) <= px\n\n    # test non-interactive line\n    pos = plt.plotItem.vb.mapViewToScene(pg.Point(5,-1)).toPoint()\n    pos2 = pos - QtCore.QPoint(50, 50)\n    mouseMove(plt, pos)\n    assert hline2.mouseHovering == False\n    mouseDrag(plt, pos, pos2, QtCore.Qt.LeftButton)\n    assert hline2.value() == -1\n\n\nif __name__ == '__main__':\n    test_mouseInteraction()\n"""
src/third_party/pyqtgraph/graphicsItems/tests/test_PlotCurveItem.py,4,"b'import numpy as np\nimport pyqtgraph as pg\nfrom pyqtgraph.tests import assertImageApproved\n\n\ndef test_PlotCurveItem():\n    p = pg.GraphicsWindow()\n    p.ci.layout.setContentsMargins(4, 4, 4, 4)  # default margins vary by platform\n    v = p.addViewBox()\n    p.resize(200, 150)\n    data = np.array([1,4,2,3,np.inf,5,7,6,-np.inf,8,10,9,np.nan,-1,-2,0])\n    c = pg.PlotCurveItem(data)\n    v.addItem(c)\n    v.autoRange()\n    \n    # Check auto-range works. Some platform differences may be expected..\n    checkRange = np.array([[-1.1457564053237301, 16.145756405323731], [-3.076811473165955, 11.076811473165955]])\n    assert np.allclose(v.viewRange(), checkRange)\n    \n    assertImageApproved(p, \'plotcurveitem/connectall\', ""Plot curve with all points connected."")\n    \n    c.setData(data, connect=\'pairs\')\n    assertImageApproved(p, \'plotcurveitem/connectpairs\', ""Plot curve with pairs connected."")\n    \n    c.setData(data, connect=\'finite\')\n    assertImageApproved(p, \'plotcurveitem/connectfinite\', ""Plot curve with finite points connected."")\n    \n    c.setData(data, connect=np.array([1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0]))\n    assertImageApproved(p, \'plotcurveitem/connectarray\', ""Plot curve with connection array."")\n    \n\n\nif __name__ == \'__main__\':\n    test_PlotCurveItem()\n'"
src/third_party/pyqtgraph/graphicsItems/tests/test_PlotDataItem.py,14,"b""import numpy as np\nimport pyqtgraph as pg\n\npg.mkQApp()\n\n\ndef test_fft():\n    f = 20.\n    x = np.linspace(0, 1, 1000)\n    y = np.sin(2 * np.pi * f * x)\n    pd = pg.PlotDataItem(x, y)\n    pd.setFftMode(True)    \n    x, y = pd.getData()\n    assert abs(x[np.argmax(y)] - f) < 0.03\n    \n    x = np.linspace(0, 1, 1001)\n    y = np.sin(2 * np.pi * f * x)\n    pd.setData(x, y)\n    x, y = pd.getData()\n    assert abs(x[np.argmax(y)]- f) < 0.03\n    \n    pd.setLogMode(True, False)\n    x, y = pd.getData()\n    assert abs(x[np.argmax(y)] - np.log10(f)) < 0.01\n\ndef test_setData():\n    pdi = pg.PlotDataItem()\n\n    #test empty data\n    pdi.setData([])\n\n    #test y data\n    y = list(np.random.normal(size=100))\n    pdi.setData(y)\n    assert len(pdi.xData) == 100\n    assert len(pdi.yData) == 100\n\n    #test x, y data\n    y += list(np.random.normal(size=50))\n    x = np.linspace(5, 10, 150)\n\n    pdi.setData(x, y)\n    assert len(pdi.xData) == 150\n    assert len(pdi.yData) == 150\n\n    #test dict of x, y list\n    y += list(np.random.normal(size=50))\n    x = list(np.linspace(5, 10, 200))\n    pdi.setData({'x': x, 'y': y})\n    assert len(pdi.xData) == 200\n    assert len(pdi.yData) == 200\n\ndef test_clear():\n    y = list(np.random.normal(size=100))\n    x = np.linspace(5, 10, 100)\n    pdi = pg.PlotDataItem(x, y)\n    pdi.clear()\n\n    assert pdi.xData == None\n    assert pdi.yData == None\n"""
src/third_party/pyqtgraph/graphicsItems/tests/test_ROI.py,3,"b""import numpy as np\nimport pytest\nimport pyqtgraph as pg\nfrom pyqtgraph.Qt import QtCore, QtTest\nfrom pyqtgraph.tests import assertImageApproved, mouseMove, mouseDrag, mouseClick, TransposedImageItem, resizeWindow\n\n\napp = pg.mkQApp()\n\n\ndef test_getArrayRegion(transpose=False):\n    pr = pg.PolyLineROI([[0, 0], [27, 0], [0, 28]], closed=True)\n    pr.setPos(1, 1)\n    rois = [\n        (pg.ROI([1, 1], [27, 28], pen='y'), 'baseroi'),\n        (pg.RectROI([1, 1], [27, 28], pen='y'), 'rectroi'),\n        (pg.EllipseROI([1, 1], [27, 28], pen='y'), 'ellipseroi'),\n        (pr, 'polylineroi'),\n    ]\n    for roi, name in rois:\n        # For some ROIs, resize should not be used.\n        testResize = not isinstance(roi, pg.PolyLineROI)\n        \n        origMode = pg.getConfigOption('imageAxisOrder')\n        try:\n            if transpose:\n                pg.setConfigOptions(imageAxisOrder='row-major')\n                check_getArrayRegion(roi, 'roi/'+name, testResize, transpose=True)\n            else:\n                pg.setConfigOptions(imageAxisOrder='col-major')\n                check_getArrayRegion(roi, 'roi/'+name, testResize)\n        finally:\n            pg.setConfigOptions(imageAxisOrder=origMode)\n    \n\ndef test_getArrayRegion_axisorder():\n    test_getArrayRegion(transpose=True)\n\n    \ndef check_getArrayRegion(roi, name, testResize=True, transpose=False):\n    initState = roi.getState()\n    \n    #win = pg.GraphicsLayoutWidget()\n    win = pg.GraphicsView()\n    win.show()\n    resizeWindow(win, 200, 400)\n    # Don't use Qt's layouts for testing--these generate unpredictable results.\n    #vb1 = win.addViewBox()\n    #win.nextRow()\n    #vb2 = win.addViewBox()\n    \n    # Instead, place the viewboxes manually \n    vb1 = pg.ViewBox()\n    win.scene().addItem(vb1)\n    vb1.setPos(6, 6)\n    vb1.resize(188, 191)\n\n    vb2 = pg.ViewBox()\n    win.scene().addItem(vb2)\n    vb2.setPos(6, 203)\n    vb2.resize(188, 191)\n    \n    img1 = pg.ImageItem(border='w')\n    img2 = pg.ImageItem(border='w')\n\n    vb1.addItem(img1)\n    vb2.addItem(img2)\n    \n    np.random.seed(0)\n    data = np.random.normal(size=(7, 30, 31, 5))\n    data[0, :, :, :] += 10\n    data[:, 1, :, :] += 10\n    data[:, :, 2, :] += 10\n    data[:, :, :, 3] += 10\n    \n    if transpose:\n        data = data.transpose(0, 2, 1, 3)\n    \n    img1.setImage(data[0, ..., 0])\n    vb1.setAspectLocked()\n    vb1.enableAutoRange(True, True)\n    \n    roi.setZValue(10)\n    vb1.addItem(roi)\n\n    if isinstance(roi, pg.RectROI):\n        if transpose:\n            assert roi.getAffineSliceParams(data, img1, axes=(1, 2)) == ([28.0, 27.0], ((1.0, 0.0), (0.0, 1.0)), (1.0, 1.0))\n        else:\n            assert roi.getAffineSliceParams(data, img1, axes=(1, 2)) == ([27.0, 28.0], ((1.0, 0.0), (0.0, 1.0)), (1.0, 1.0))\n\n    rgn = roi.getArrayRegion(data, img1, axes=(1, 2))\n    #assert np.all((rgn == data[:, 1:-2, 1:-2, :]) | (rgn == 0))\n    img2.setImage(rgn[0, ..., 0])\n    vb2.setAspectLocked()\n    vb2.enableAutoRange(True, True)\n    \n    app.processEvents()\n    assertImageApproved(win, name+'/roi_getarrayregion', 'Simple ROI region selection.')\n\n    with pytest.raises(TypeError):\n        roi.setPos(0, False)\n\n    roi.setPos([0.5, 1.5])\n    rgn = roi.getArrayRegion(data, img1, axes=(1, 2))\n    img2.setImage(rgn[0, ..., 0])\n    app.processEvents()\n    assertImageApproved(win, name+'/roi_getarrayregion_halfpx', 'Simple ROI region selection, 0.5 pixel shift.')\n\n    roi.setAngle(45)\n    roi.setPos([3, 0])\n    rgn = roi.getArrayRegion(data, img1, axes=(1, 2))\n    img2.setImage(rgn[0, ..., 0])\n    app.processEvents()\n    assertImageApproved(win, name+'/roi_getarrayregion_rotate', 'Simple ROI region selection, rotation.')\n\n    if testResize:\n        roi.setSize([60, 60])\n        rgn = roi.getArrayRegion(data, img1, axes=(1, 2))\n        img2.setImage(rgn[0, ..., 0])\n        app.processEvents()\n        assertImageApproved(win, name+'/roi_getarrayregion_resize', 'Simple ROI region selection, resized.')\n\n    img1.scale(1, -1)\n    img1.setPos(0, img1.height())\n    img1.rotate(20)\n    rgn = roi.getArrayRegion(data, img1, axes=(1, 2))\n    img2.setImage(rgn[0, ..., 0])\n    app.processEvents()\n    assertImageApproved(win, name+'/roi_getarrayregion_img_trans', 'Simple ROI region selection, image transformed.')\n\n    vb1.invertY()\n    rgn = roi.getArrayRegion(data, img1, axes=(1, 2))\n    img2.setImage(rgn[0, ..., 0])\n    app.processEvents()\n    assertImageApproved(win, name+'/roi_getarrayregion_inverty', 'Simple ROI region selection, view inverted.')\n\n    roi.setState(initState)\n    img1.resetTransform()\n    img1.setPos(0, 0)\n    img1.scale(1, 0.5)\n    rgn = roi.getArrayRegion(data, img1, axes=(1, 2))\n    img2.setImage(rgn[0, ..., 0])\n    app.processEvents()\n    assertImageApproved(win, name+'/roi_getarrayregion_anisotropic', 'Simple ROI region selection, image scaled anisotropically.')\n    \n    # allow the roi to be re-used\n    roi.scene().removeItem(roi)\n\n\ndef test_PolyLineROI():\n    rois = [\n        (pg.PolyLineROI([[0, 0], [10, 0], [0, 15]], closed=True, pen=0.3), 'closed'),\n        (pg.PolyLineROI([[0, 0], [10, 0], [0, 15]], closed=False, pen=0.3), 'open')\n    ]\n    \n    #plt = pg.plot()\n    plt = pg.GraphicsView()\n    plt.show()\n    resizeWindow(plt, 200, 200)\n    vb = pg.ViewBox()\n    plt.scene().addItem(vb)\n    vb.resize(200, 200)\n    #plt.plotItem = pg.PlotItem()\n    #plt.scene().addItem(plt.plotItem)\n    #plt.plotItem.resize(200, 200)\n    \n\n    plt.scene().minDragTime = 0  # let us simulate mouse drags very quickly.\n\n    # seemingly arbitrary requirements; might need longer wait time for some platforms..\n    QtTest.QTest.qWaitForWindowShown(plt)\n    QtTest.QTest.qWait(100)\n    \n    for r, name in rois:\n        vb.clear()\n        vb.addItem(r)\n        vb.autoRange()\n        app.processEvents()\n        \n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_init', 'Init %s polyline.' % name)\n        initState = r.getState()\n        assert len(r.getState()['points']) == 3\n        \n        # hover over center\n        center = r.mapToScene(pg.Point(3, 3))\n        mouseMove(plt, center)\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_hover_roi', 'Hover mouse over center of ROI.')\n        \n        # drag ROI\n        mouseDrag(plt, center, center + pg.Point(10, -10), QtCore.Qt.LeftButton)\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_drag_roi', 'Drag mouse over center of ROI.')\n        \n        # hover over handle\n        pt = r.mapToScene(pg.Point(r.getState()['points'][2]))\n        mouseMove(plt, pt)\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_hover_handle', 'Hover mouse over handle.')\n        \n        # drag handle\n        mouseDrag(plt, pt, pt + pg.Point(5, 20), QtCore.Qt.LeftButton)\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_drag_handle', 'Drag mouse over handle.')\n        \n        # hover over segment \n        pt = r.mapToScene((pg.Point(r.getState()['points'][2]) + pg.Point(r.getState()['points'][1])) * 0.5)\n        mouseMove(plt, pt+pg.Point(0, 2))\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_hover_segment', 'Hover mouse over diagonal segment.')\n        \n        # click segment\n        mouseClick(plt, pt, QtCore.Qt.LeftButton)\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_click_segment', 'Click mouse over segment.')\n\n        # drag new handle\n        mouseMove(plt, pt+pg.Point(10, -10)) # pg bug: have to move the mouse off/on again to register hover\n        mouseDrag(plt, pt, pt + pg.Point(10, -10), QtCore.Qt.LeftButton)\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_drag_new_handle', 'Drag mouse over created handle.')\n        \n        # clear all points\n        r.clearPoints()\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_clear', 'All points cleared.')\n        assert len(r.getState()['points']) == 0\n        \n        # call setPoints\n        r.setPoints(initState['points'])\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_setpoints', 'Reset points to initial state.')\n        assert len(r.getState()['points']) == 3\n        \n        # call setState\n        r.setState(initState)\n        assertImageApproved(plt, 'roi/polylineroi/'+name+'_setstate', 'Reset ROI to initial state.')\n        assert len(r.getState()['points']) == 3\n        \n    """
src/third_party/pyqtgraph/graphicsItems/tests/test_ScatterPlotItem.py,7,"b""from pyqtgraph.Qt import QtGui, QtCore\nimport pyqtgraph as pg\nimport numpy as np\napp = pg.mkQApp()\napp.processEvents()\n\n\n\ndef test_scatterplotitem():\n    plot = pg.PlotWidget()\n    # set view range equal to its bounding rect.\n    # This causes plots to look the same regardless of pxMode.\n    plot.setRange(rect=plot.boundingRect())\n\n    # test SymbolAtlas accepts custom symbol\n    s = pg.ScatterPlotItem()\n    symbol = QtGui.QPainterPath()\n    symbol.addEllipse(QtCore.QRectF(-0.5, -0.5, 1, 1))\n    s.addPoints([{'pos': [0,0], 'data': 1, 'symbol': symbol}])\n\n    for i, pxMode in enumerate([True, False]):\n        for j, useCache in enumerate([True, False]):\n            s = pg.ScatterPlotItem()\n            s.opts['useCache'] = useCache\n            plot.addItem(s)\n            s.setData(x=np.array([10,40,20,30])+i*100, y=np.array([40,60,10,30])+j*100, pxMode=pxMode)\n            s.addPoints(x=np.array([60, 70])+i*100, y=np.array([60, 70])+j*100, size=[20, 30])\n\n            # Test uniform spot updates\n            s.setSize(10)\n            s.setBrush('r')\n            s.setPen('g')\n            s.setSymbol('+')\n            app.processEvents()\n\n            # Test list spot updates\n            s.setSize([10] * 6)\n            s.setBrush([pg.mkBrush('r')] * 6)\n            s.setPen([pg.mkPen('g')] * 6)\n            s.setSymbol(['+'] * 6)\n            s.setPointData([s] * 6)\n            app.processEvents()\n\n            # Test array spot updates\n            s.setSize(np.array([10] * 6))\n            s.setBrush(np.array([pg.mkBrush('r')] * 6))\n            s.setPen(np.array([pg.mkPen('g')] * 6))\n            s.setSymbol(np.array(['+'] * 6))\n            s.setPointData(np.array([s] * 6))\n            app.processEvents()\n\n            # Test per-spot updates\n            spot = s.points()[0]\n            spot.setSize(20)\n            spot.setBrush('b')\n            spot.setPen('g')\n            spot.setSymbol('o')\n            spot.setData(None)\n            app.processEvents()\n\n    plot.clear()\n\n\ndef test_init_spots():\n    plot = pg.PlotWidget()\n    # set view range equal to its bounding rect.\n    # This causes plots to look the same regardless of pxMode.\n    plot.setRange(rect=plot.boundingRect())\n    spots = [\n        {'x': 0, 'y': 1},\n        {'pos': (1, 2), 'pen': None, 'brush': None, 'data': 'zzz'},\n    ]\n    s = pg.ScatterPlotItem(spots=spots)\n\n    # Check we can display without errors\n    plot.addItem(s)\n    app.processEvents()\n    plot.clear()\n\n    # check data is correct\n    spots = s.points()\n\n    defPen = pg.mkPen(pg.getConfigOption('foreground'))\n\n    assert spots[0].pos().x() == 0\n    assert spots[0].pos().y() == 1\n    assert spots[0].pen() == defPen\n    assert spots[0].data() is None\n\n    assert spots[1].pos().x() == 1\n    assert spots[1].pos().y() == 2\n    assert spots[1].pen() == pg.mkPen(None)\n    assert spots[1].brush() == pg.mkBrush(None)\n    assert spots[1].data() == 'zzz'\n\n\nif __name__ == '__main__':\n    test_scatterplotitem()\n"""
src/third_party/pyqtgraph/imageview/tests/test_imageview.py,2,"b'import pyqtgraph as pg\nimport numpy as np\n\napp = pg.mkQApp()\n\ndef test_nan_image():\n    img = np.ones((10,10))\n    img[0,0] = np.nan\n    v = pg.image(img)\n    v.imageItem.getHistogram()\n    app.processEvents()\n    v.window().close()\n'"
src/third_party/pyqtgraph/opengl/items/GLAxisItem.py,0,"b'from OpenGL.GL import *\nfrom .. GLGraphicsItem import GLGraphicsItem\nfrom ... import QtGui\n\n__all__ = [\'GLAxisItem\']\n\nclass GLAxisItem(GLGraphicsItem):\n    """"""\n    **Bases:** :class:`GLGraphicsItem <pyqtgraph.opengl.GLGraphicsItem>`\n    \n    Displays three lines indicating origin and orientation of local coordinate system. \n    \n    """"""\n    \n    def __init__(self, size=None, antialias=True, glOptions=\'translucent\'):\n        GLGraphicsItem.__init__(self)\n        if size is None:\n            size = QtGui.QVector3D(1,1,1)\n        self.antialias = antialias\n        self.setSize(size=size)\n        self.setGLOptions(glOptions)\n    \n    def setSize(self, x=None, y=None, z=None, size=None):\n        """"""\n        Set the size of the axes (in its local coordinate system; this does not affect the transform)\n        Arguments can be x,y,z or size=QVector3D().\n        """"""\n        if size is not None:\n            x = size.x()\n            y = size.y()\n            z = size.z()\n        self.__size = [x,y,z]\n        self.update()\n        \n    def size(self):\n        return self.__size[:]\n    \n    \n    def paint(self):\n\n        #glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n        #glEnable( GL_BLEND )\n        #glEnable( GL_ALPHA_TEST )\n        self.setupGLState()\n        \n        if self.antialias:\n            glEnable(GL_LINE_SMOOTH)\n            glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)\n            \n        glBegin( GL_LINES )\n        \n        x,y,z = self.size()\n        glColor4f(0, 1, 0, .6)  # z is green\n        glVertex3f(0, 0, 0)\n        glVertex3f(0, 0, z)\n\n        glColor4f(1, 1, 0, .6)  # y is yellow\n        glVertex3f(0, 0, 0)\n        glVertex3f(0, y, 0)\n\n        glColor4f(0, 0, 1, .6)  # x is blue\n        glVertex3f(0, 0, 0)\n        glVertex3f(x, 0, 0)\n        glEnd()\n'"
src/third_party/pyqtgraph/opengl/items/GLBarGraphItem.py,3,"b'from .GLMeshItem import GLMeshItem\nfrom ..MeshData import MeshData\nimport numpy as np\n\nclass GLBarGraphItem(GLMeshItem):\n    def __init__(self, pos, size):\n        """"""\n        pos is (...,3) array of the bar positions (the corner of each bar)\n        size is (...,3) array of the sizes of each bar\n        """"""\n        nCubes = reduce(lambda a,b: a*b, pos.shape[:-1])\n        cubeVerts = np.mgrid[0:2,0:2,0:2].reshape(3,8).transpose().reshape(1,8,3)\n        cubeFaces = np.array([\n            [0,1,2], [3,2,1],\n            [4,5,6], [7,6,5],\n            [0,1,4], [5,4,1],\n            [2,3,6], [7,6,3],\n            [0,2,4], [6,4,2],\n            [1,3,5], [7,5,3]]).reshape(1,12,3)\n        size = size.reshape((nCubes, 1, 3))\n        pos = pos.reshape((nCubes, 1, 3))\n        verts = cubeVerts * size + pos\n        faces = cubeFaces + (np.arange(nCubes) * 8).reshape(nCubes,1,1)\n        md = MeshData(verts.reshape(nCubes*8,3), faces.reshape(nCubes*12,3))\n        \n        GLMeshItem.__init__(self, meshdata=md, shader=\'shaded\', smooth=False)\n\n        \n        '"
src/third_party/pyqtgraph/opengl/items/GLBoxItem.py,0,"b'from OpenGL.GL import *\nfrom .. GLGraphicsItem import GLGraphicsItem\nfrom ...Qt import QtGui\nfrom ... import functions as fn\n\n__all__ = [\'GLBoxItem\']\n\nclass GLBoxItem(GLGraphicsItem):\n    """"""\n    **Bases:** :class:`GLGraphicsItem <pyqtgraph.opengl.GLGraphicsItem>`\n    \n    Displays a wire-frame box.\n    """"""\n    def __init__(self, size=None, color=None, glOptions=\'translucent\'):\n        GLGraphicsItem.__init__(self)\n        if size is None:\n            size = QtGui.QVector3D(1,1,1)\n        self.setSize(size=size)\n        if color is None:\n            color = (255,255,255,80)\n        self.setColor(color)\n        self.setGLOptions(glOptions)\n    \n    def setSize(self, x=None, y=None, z=None, size=None):\n        """"""\n        Set the size of the box (in its local coordinate system; this does not affect the transform)\n        Arguments can be x,y,z or size=QVector3D().\n        """"""\n        if size is not None:\n            x = size.x()\n            y = size.y()\n            z = size.z()\n        self.__size = [x,y,z]\n        self.update()\n        \n    def size(self):\n        return self.__size[:]\n    \n    def setColor(self, *args):\n        """"""Set the color of the box. Arguments are the same as those accepted by functions.mkColor()""""""\n        self.__color = fn.Color(*args)\n        \n    def color(self):\n        return self.__color\n    \n    def paint(self):\n        #glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n        #glEnable( GL_BLEND )\n        #glEnable( GL_ALPHA_TEST )\n        ##glAlphaFunc( GL_ALWAYS,0.5 )\n        #glEnable( GL_POINT_SMOOTH )\n        #glDisable( GL_DEPTH_TEST )\n        self.setupGLState()\n        \n        glBegin( GL_LINES )\n        \n        glColor4f(*self.color().glColor())\n        x,y,z = self.size()\n        glVertex3f(0, 0, 0)\n        glVertex3f(0, 0, z)\n        glVertex3f(x, 0, 0)\n        glVertex3f(x, 0, z)\n        glVertex3f(0, y, 0)\n        glVertex3f(0, y, z)\n        glVertex3f(x, y, 0)\n        glVertex3f(x, y, z)\n\n        glVertex3f(0, 0, 0)\n        glVertex3f(0, y, 0)\n        glVertex3f(x, 0, 0)\n        glVertex3f(x, y, 0)\n        glVertex3f(0, 0, z)\n        glVertex3f(0, y, z)\n        glVertex3f(x, 0, z)\n        glVertex3f(x, y, z)\n        \n        glVertex3f(0, 0, 0)\n        glVertex3f(x, 0, 0)\n        glVertex3f(0, y, 0)\n        glVertex3f(x, y, 0)\n        glVertex3f(0, 0, z)\n        glVertex3f(x, 0, z)\n        glVertex3f(0, y, z)\n        glVertex3f(x, y, z)\n        \n        glEnd()\n        \n        '"
src/third_party/pyqtgraph/opengl/items/GLGridItem.py,2,"b'import numpy as np\n\nfrom OpenGL.GL import *\nfrom .. GLGraphicsItem import GLGraphicsItem\nfrom ... import QtGui\n\n__all__ = [\'GLGridItem\']\n\nclass GLGridItem(GLGraphicsItem):\n    """"""\n    **Bases:** :class:`GLGraphicsItem <pyqtgraph.opengl.GLGraphicsItem>`\n    \n    Displays a wire-frame grid. \n    """"""\n    \n    def __init__(self, size=None, color=(1, 1, 1, .3), antialias=True, glOptions=\'translucent\'):\n        GLGraphicsItem.__init__(self)\n        self.setGLOptions(glOptions)\n        self.antialias = antialias\n        if size is None:\n            size = QtGui.QVector3D(20,20,1)\n        self.setSize(size=size)\n        self.setSpacing(1, 1, 1)\n        self.color = color\n    \n    def setSize(self, x=None, y=None, z=None, size=None):\n        """"""\n        Set the size of the axes (in its local coordinate system; this does not affect the transform)\n        Arguments can be x,y,z or size=QVector3D().\n        """"""\n        if size is not None:\n            x = size.x()\n            y = size.y()\n            z = size.z()\n        self.__size = [x,y,z]\n        self.update()\n        \n    def size(self):\n        return self.__size[:]\n\n    def setSpacing(self, x=None, y=None, z=None, spacing=None):\n        """"""\n        Set the spacing between grid lines.\n        Arguments can be x,y,z or spacing=QVector3D().\n        """"""\n        if spacing is not None:\n            x = spacing.x()\n            y = spacing.y()\n            z = spacing.z()\n        self.__spacing = [x,y,z]\n        self.update() \n        \n    def spacing(self):\n        return self.__spacing[:]\n        \n    def paint(self):\n        self.setupGLState()\n        \n        if self.antialias:\n            glEnable(GL_LINE_SMOOTH)\n            glEnable(GL_BLEND)\n            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n            glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)\n            \n        glBegin( GL_LINES )\n        \n        x,y,z = self.size()\n        xs,ys,zs = self.spacing()\n        xvals = np.arange(-x/2., x/2. + xs*0.001, xs) \n        yvals = np.arange(-y/2., y/2. + ys*0.001, ys)\n        glColor4f(*self.color)\n        for x in xvals:\n            glVertex3f(x, yvals[0], 0)\n            glVertex3f(x,  yvals[-1], 0)\n        for y in yvals:\n            glVertex3f(xvals[0], y, 0)\n            glVertex3f(xvals[-1], y, 0)\n        \n        glEnd()\n'"
src/third_party/pyqtgraph/opengl/items/GLImageItem.py,0,"b'from OpenGL.GL import *\nfrom .. GLGraphicsItem import GLGraphicsItem\nfrom ...Qt import QtGui\nimport numpy as np\n\n__all__ = [\'GLImageItem\']\n\nclass GLImageItem(GLGraphicsItem):\n    """"""\n    **Bases:** :class:`GLGraphicsItem <pyqtgraph.opengl.GLGraphicsItem>`\n    \n    Displays image data as a textured quad.\n    """"""\n    \n    \n    def __init__(self, data, smooth=False, glOptions=\'translucent\'):\n        """"""\n        \n        ==============  =======================================================================================\n        **Arguments:**\n        data            Volume data to be rendered. *Must* be 3D numpy array (x, y, RGBA) with dtype=ubyte.\n                        (See functions.makeRGBA)\n        smooth          (bool) If True, the volume slices are rendered with linear interpolation \n        ==============  =======================================================================================\n        """"""\n        \n        self.smooth = smooth\n        self._needUpdate = False\n        GLGraphicsItem.__init__(self)\n        self.setData(data)\n        self.setGLOptions(glOptions)\n        \n    def initializeGL(self):\n        glEnable(GL_TEXTURE_2D)\n        self.texture = glGenTextures(1)\n        \n    def setData(self, data):\n        self.data = data\n        self._needUpdate = True\n        self.update()\n        \n    def _updateTexture(self):\n        glBindTexture(GL_TEXTURE_2D, self.texture)\n        if self.smooth:\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n        else:\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER)\n        #glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER)\n        shape = self.data.shape\n        \n        ## Test texture dimensions first\n        glTexImage2D(GL_PROXY_TEXTURE_2D, 0, GL_RGBA, shape[0], shape[1], 0, GL_RGBA, GL_UNSIGNED_BYTE, None)\n        if glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, 0, GL_TEXTURE_WIDTH) == 0:\n            raise Exception(""OpenGL failed to create 2D texture (%dx%d); too large for this hardware."" % shape[:2])\n        \n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, shape[0], shape[1], 0, GL_RGBA, GL_UNSIGNED_BYTE, self.data.transpose((1,0,2)))\n        glDisable(GL_TEXTURE_2D)\n        \n        #self.lists = {}\n        #for ax in [0,1,2]:\n            #for d in [-1, 1]:\n                #l = glGenLists(1)\n                #self.lists[(ax,d)] = l\n                #glNewList(l, GL_COMPILE)\n                #self.drawVolume(ax, d)\n                #glEndList()\n\n                \n    def paint(self):\n        if self._needUpdate:\n            self._updateTexture()\n        glEnable(GL_TEXTURE_2D)\n        glBindTexture(GL_TEXTURE_2D, self.texture)\n        \n        self.setupGLState()\n        \n        #glEnable(GL_DEPTH_TEST)\n        ##glDisable(GL_CULL_FACE)\n        #glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n        #glEnable( GL_BLEND )\n        #glEnable( GL_ALPHA_TEST )\n        glColor4f(1,1,1,1)\n\n        glBegin(GL_QUADS)\n        glTexCoord2f(0,0)\n        glVertex3f(0,0,0)\n        glTexCoord2f(1,0)\n        glVertex3f(self.data.shape[0], 0, 0)\n        glTexCoord2f(1,1)\n        glVertex3f(self.data.shape[0], self.data.shape[1], 0)\n        glTexCoord2f(0,1)\n        glVertex3f(0, self.data.shape[1], 0)\n        glEnd()\n        glDisable(GL_TEXTURE_3D)\n                \n'"
src/third_party/pyqtgraph/opengl/items/GLLinePlotItem.py,1,"b'from OpenGL.GL import *\nfrom OpenGL.arrays import vbo\nfrom .. GLGraphicsItem import GLGraphicsItem\nfrom .. import shaders\nfrom ... import QtGui\nfrom ... import functions as fn\nimport numpy as np\n\n__all__ = [\'GLLinePlotItem\']\n\nclass GLLinePlotItem(GLGraphicsItem):\n    """"""Draws line plots in 3D.""""""\n    \n    def __init__(self, **kwds):\n        """"""All keyword arguments are passed to setData()""""""\n        GLGraphicsItem.__init__(self)\n        glopts = kwds.pop(\'glOptions\', \'additive\')\n        self.setGLOptions(glopts)\n        self.pos = None\n        self.mode = \'line_strip\'\n        self.width = 1.\n        self.color = (1.0,1.0,1.0,1.0)\n        self.setData(**kwds)\n    \n    def setData(self, **kwds):\n        """"""\n        Update the data displayed by this item. All arguments are optional; \n        for example it is allowed to update vertex positions while leaving \n        colors unchanged, etc.\n        \n        ====================  ==================================================\n        **Arguments:**\n        ------------------------------------------------------------------------\n        pos                   (N,3) array of floats specifying point locations.\n        color                 (N,4) array of floats (0.0-1.0) or\n                              tuple of floats specifying\n                              a single color for the entire item.\n        width                 float specifying line width\n        antialias             enables smooth line drawing\n        mode                  \'lines\': Each pair of vertexes draws a single line\n                                       segment.\n                              \'line_strip\': All vertexes are drawn as a\n                                            continuous set of line segments.\n        ====================  ==================================================\n        """"""\n        args = [\'pos\', \'color\', \'width\', \'mode\', \'antialias\']\n        for k in kwds.keys():\n            if k not in args:\n                raise Exception(\'Invalid keyword argument: %s (allowed arguments are %s)\' % (k, str(args)))\n        self.antialias = False\n        for arg in args:\n            if arg in kwds:\n                setattr(self, arg, kwds[arg])\n                #self.vbo.pop(arg, None)\n        self.update()\n\n    def initializeGL(self):\n        pass\n        \n    def paint(self):\n        if self.pos is None:\n            return\n        self.setupGLState()\n        \n        glEnableClientState(GL_VERTEX_ARRAY)\n\n        try:\n            glVertexPointerf(self.pos)\n            \n            if isinstance(self.color, np.ndarray):\n                glEnableClientState(GL_COLOR_ARRAY)\n                glColorPointerf(self.color)\n            else:\n                if isinstance(self.color, (str, QtGui.QColor)):\n                    glColor4f(*fn.glColor(self.color))\n                else:\n                    glColor4f(*self.color)\n            glLineWidth(self.width)\n            \n            if self.antialias:\n                glEnable(GL_LINE_SMOOTH)\n                glEnable(GL_BLEND)\n                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n                glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)\n                \n            if self.mode == \'line_strip\':\n                glDrawArrays(GL_LINE_STRIP, 0, int(self.pos.size / self.pos.shape[-1]))\n            elif self.mode == \'lines\':\n                glDrawArrays(GL_LINES, 0, int(self.pos.size / self.pos.shape[-1]))\n            else:\n                raise Exception(""Unknown line mode \'%s\'. (must be \'lines\' or \'line_strip\')"" % self.mode)\n                \n        finally:\n            glDisableClientState(GL_COLOR_ARRAY)\n            glDisableClientState(GL_VERTEX_ARRAY)\n    \n        \n'"
src/third_party/pyqtgraph/opengl/items/GLMeshItem.py,2,"b'from OpenGL.GL import *\nfrom .. GLGraphicsItem import GLGraphicsItem\nfrom .. MeshData import MeshData\nfrom ...Qt import QtGui\nfrom .. import shaders\nfrom ... import functions as fn\nimport numpy as np\n\n\n\n__all__ = [\'GLMeshItem\']\n\nclass GLMeshItem(GLGraphicsItem):\n    """"""\n    **Bases:** :class:`GLGraphicsItem <pyqtgraph.opengl.GLGraphicsItem>`\n    \n    Displays a 3D triangle mesh. \n    """"""\n    def __init__(self, **kwds):\n        """"""\n        ============== =====================================================\n        **Arguments:**\n        meshdata       MeshData object from which to determine geometry for \n                       this item.\n        color          Default face color used if no vertex or face colors \n                       are specified.\n        edgeColor      Default edge color to use if no edge colors are\n                       specified in the mesh data.\n        drawEdges      If True, a wireframe mesh will be drawn. \n                       (default=False)\n        drawFaces      If True, mesh faces are drawn. (default=True)\n        shader         Name of shader program to use when drawing faces.\n                       (None for no shader)\n        smooth         If True, normal vectors are computed for each vertex\n                       and interpolated within each face.\n        computeNormals If False, then computation of normal vectors is \n                       disabled. This can provide a performance boost for \n                       meshes that do not make use of normals.\n        ============== =====================================================\n        """"""\n        self.opts = {\n            \'meshdata\': None,\n            \'color\': (1., 1., 1., 1.),\n            \'drawEdges\': False,\n            \'drawFaces\': True,\n            \'edgeColor\': (0.5, 0.5, 0.5, 1.0),\n            \'shader\': None,\n            \'smooth\': True,\n            \'computeNormals\': True,\n        }\n        \n        GLGraphicsItem.__init__(self)\n        glopts = kwds.pop(\'glOptions\', \'opaque\')\n        self.setGLOptions(glopts)\n        shader = kwds.pop(\'shader\', None)\n        self.setShader(shader)\n        \n        self.setMeshData(**kwds)\n        \n        ## storage for data compiled from MeshData object\n        self.vertexes = None\n        self.normals = None\n        self.colors = None\n        self.faces = None\n        \n    def setShader(self, shader):\n        """"""Set the shader used when rendering faces in the mesh. (see the GL shaders example)""""""\n        self.opts[\'shader\'] = shader\n        self.update()\n        \n    def shader(self):\n        shader = self.opts[\'shader\']\n        if isinstance(shader, shaders.ShaderProgram):\n            return shader\n        else:\n            return shaders.getShaderProgram(shader)\n        \n    def setColor(self, c):\n        """"""Set the default color to use when no vertex or face colors are specified.""""""\n        self.opts[\'color\'] = c\n        self.update()\n        \n    def setMeshData(self, **kwds):\n        """"""\n        Set mesh data for this item. This can be invoked two ways:\n        \n        1. Specify *meshdata* argument with a new MeshData object\n        2. Specify keyword arguments to be passed to MeshData(..) to create a new instance.\n        """"""\n        md = kwds.get(\'meshdata\', None)\n        if md is None:\n            opts = {}\n            for k in [\'vertexes\', \'faces\', \'edges\', \'vertexColors\', \'faceColors\']:\n                try:\n                    opts[k] = kwds.pop(k)\n                except KeyError:\n                    pass\n            md = MeshData(**opts)\n        \n        self.opts[\'meshdata\'] = md\n        self.opts.update(kwds)\n        self.meshDataChanged()\n        self.update()\n        \n    \n    def meshDataChanged(self):\n        """"""\n        This method must be called to inform the item that the MeshData object\n        has been altered.\n        """"""\n        \n        self.vertexes = None\n        self.faces = None\n        self.normals = None\n        self.colors = None\n        self.edges = None\n        self.edgeColors = None\n        self.update()\n    \n    def parseMeshData(self):\n        ## interpret vertex / normal data before drawing\n        ## This can:\n        ##   - automatically generate normals if they were not specified\n        ##   - pull vertexes/noormals/faces from MeshData if that was specified\n        \n        if self.vertexes is not None and self.normals is not None:\n            return\n        #if self.opts[\'normals\'] is None:\n            #if self.opts[\'meshdata\'] is None:\n                #self.opts[\'meshdata\'] = MeshData(vertexes=self.opts[\'vertexes\'], faces=self.opts[\'faces\'])\n        if self.opts[\'meshdata\'] is not None:\n            md = self.opts[\'meshdata\']\n            if self.opts[\'smooth\'] and not md.hasFaceIndexedData():\n                self.vertexes = md.vertexes()\n                if self.opts[\'computeNormals\']:\n                    self.normals = md.vertexNormals()\n                self.faces = md.faces()\n                if md.hasVertexColor():\n                    self.colors = md.vertexColors()\n                if md.hasFaceColor():\n                    self.colors = md.faceColors()\n            else:\n                self.vertexes = md.vertexes(indexed=\'faces\')\n                if self.opts[\'computeNormals\']:\n                    if self.opts[\'smooth\']:\n                        self.normals = md.vertexNormals(indexed=\'faces\')\n                    else:\n                        self.normals = md.faceNormals(indexed=\'faces\')\n                self.faces = None\n                if md.hasVertexColor():\n                    self.colors = md.vertexColors(indexed=\'faces\')\n                elif md.hasFaceColor():\n                    self.colors = md.faceColors(indexed=\'faces\')\n                    \n            if self.opts[\'drawEdges\']:\n                if not md.hasFaceIndexedData():\n                    self.edges = md.edges()\n                    self.edgeVerts = md.vertexes()\n                else:\n                    self.edges = md.edges()\n                    self.edgeVerts = md.vertexes(indexed=\'faces\')\n            return\n    \n    def paint(self):\n        self.setupGLState()\n        \n        self.parseMeshData()        \n        \n        if self.opts[\'drawFaces\']:\n            with self.shader():\n                verts = self.vertexes\n                norms = self.normals\n                color = self.colors\n                faces = self.faces\n                if verts is None:\n                    return\n                glEnableClientState(GL_VERTEX_ARRAY)\n                try:\n                    glVertexPointerf(verts)\n                    \n                    if self.colors is None:\n                        color = self.opts[\'color\']\n                        if isinstance(color, QtGui.QColor):\n                            glColor4f(*fn.glColor(color))\n                        else:\n                            glColor4f(*color)\n                    else:\n                        glEnableClientState(GL_COLOR_ARRAY)\n                        glColorPointerf(color)\n                    \n                    \n                    if norms is not None:\n                        glEnableClientState(GL_NORMAL_ARRAY)\n                        glNormalPointerf(norms)\n                    \n                    if faces is None:\n                        glDrawArrays(GL_TRIANGLES, 0, np.product(verts.shape[:-1]))\n                    else:\n                        faces = faces.astype(np.uint).flatten()\n                        glDrawElements(GL_TRIANGLES, faces.shape[0], GL_UNSIGNED_INT, faces)\n                finally:\n                    glDisableClientState(GL_NORMAL_ARRAY)\n                    glDisableClientState(GL_VERTEX_ARRAY)\n                    glDisableClientState(GL_COLOR_ARRAY)\n            \n        if self.opts[\'drawEdges\']:\n            verts = self.edgeVerts\n            edges = self.edges\n            glEnableClientState(GL_VERTEX_ARRAY)\n            try:\n                glVertexPointerf(verts)\n                \n                if self.edgeColors is None:\n                    color = self.opts[\'edgeColor\']\n                    if isinstance(color, QtGui.QColor):\n                        glColor4f(*fn.glColor(color))\n                    else:\n                        glColor4f(*color)\n                else:\n                    glEnableClientState(GL_COLOR_ARRAY)\n                    glColorPointerf(color)\n                edges = edges.flatten()\n                glDrawElements(GL_LINES, edges.shape[0], GL_UNSIGNED_INT, edges)\n            finally:\n                glDisableClientState(GL_VERTEX_ARRAY)\n                glDisableClientState(GL_COLOR_ARRAY)\n            \n'"
src/third_party/pyqtgraph/opengl/items/GLScatterPlotItem.py,9,"b'from OpenGL.GL import *\nfrom OpenGL.arrays import vbo\nfrom .. GLGraphicsItem import GLGraphicsItem\nfrom .. import shaders\nfrom ... import QtGui\nimport numpy as np\n\n__all__ = [\'GLScatterPlotItem\']\n\nclass GLScatterPlotItem(GLGraphicsItem):\n    """"""Draws points at a list of 3D positions.""""""\n    \n    def __init__(self, **kwds):\n        GLGraphicsItem.__init__(self)\n        glopts = kwds.pop(\'glOptions\', \'additive\')\n        self.setGLOptions(glopts)\n        self.pos = []\n        self.size = 10\n        self.color = [1.0,1.0,1.0,0.5]\n        self.pxMode = True\n        #self.vbo = {}      ## VBO does not appear to improve performance very much.\n        self.setData(**kwds)\n    \n    def setData(self, **kwds):\n        """"""\n        Update the data displayed by this item. All arguments are optional; \n        for example it is allowed to update spot positions while leaving \n        colors unchanged, etc.\n        \n        ====================  ==================================================\n        **Arguments:**\n        pos                   (N,3) array of floats specifying point locations.\n        color                 (N,4) array of floats (0.0-1.0) specifying\n                              spot colors OR a tuple of floats specifying\n                              a single color for all spots.\n        size                  (N,) array of floats specifying spot sizes or \n                              a single value to apply to all spots.\n        pxMode                If True, spot sizes are expressed in pixels. \n                              Otherwise, they are expressed in item coordinates.\n        ====================  ==================================================\n        """"""\n        args = [\'pos\', \'color\', \'size\', \'pxMode\']\n        for k in kwds.keys():\n            if k not in args:\n                raise Exception(\'Invalid keyword argument: %s (allowed arguments are %s)\' % (k, str(args)))\n            \n        args.remove(\'pxMode\')\n        for arg in args:\n            if arg in kwds:\n                setattr(self, arg, kwds[arg])\n                #self.vbo.pop(arg, None)\n                \n        self.pxMode = kwds.get(\'pxMode\', self.pxMode)\n        self.update()\n\n    def initializeGL(self):\n        \n        ## Generate texture for rendering points\n        w = 64\n        def fn(x,y):\n            r = ((x-w/2.)**2 + (y-w/2.)**2) ** 0.5\n            return 255 * (w/2. - np.clip(r, w/2.-1.0, w/2.))\n        pData = np.empty((w, w, 4))\n        pData[:] = 255\n        pData[:,:,3] = np.fromfunction(fn, pData.shape[:2])\n        #print pData.shape, pData.min(), pData.max()\n        pData = pData.astype(np.ubyte)\n        \n        if getattr(self, ""pointTexture"", None) is None:\n            self.pointTexture = glGenTextures(1)\n        glActiveTexture(GL_TEXTURE0)\n        glEnable(GL_TEXTURE_2D)\n        glBindTexture(GL_TEXTURE_2D, self.pointTexture)\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, pData.shape[0], pData.shape[1], 0, GL_RGBA, GL_UNSIGNED_BYTE, pData)\n        \n        self.shader = shaders.getShaderProgram(\'pointSprite\')\n        \n    #def getVBO(self, name):\n        #if name not in self.vbo:\n            #self.vbo[name] = vbo.VBO(getattr(self, name).astype(\'f\'))\n        #return self.vbo[name]\n        \n    #def setupGLState(self):\n        #""""""Prepare OpenGL state for drawing. This function is called immediately before painting.""""""\n        ##glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)  ## requires z-sorting to render properly.\n        #glBlendFunc(GL_SRC_ALPHA, GL_ONE)\n        #glEnable( GL_BLEND )\n        #glEnable( GL_ALPHA_TEST )\n        #glDisable( GL_DEPTH_TEST )\n        \n        ##glEnable( GL_POINT_SMOOTH )\n\n        ##glHint(GL_POINT_SMOOTH_HINT, GL_NICEST)\n        ##glPointParameterfv(GL_POINT_DISTANCE_ATTENUATION, (0, 0, -1e-3))\n        ##glPointParameterfv(GL_POINT_SIZE_MAX, (65500,))\n        ##glPointParameterfv(GL_POINT_SIZE_MIN, (0,))\n        \n    def paint(self):\n        self.setupGLState()\n        \n        glEnable(GL_POINT_SPRITE)\n        \n        glActiveTexture(GL_TEXTURE0)\n        glEnable( GL_TEXTURE_2D )\n        glBindTexture(GL_TEXTURE_2D, self.pointTexture)\n    \n        glTexEnvi(GL_POINT_SPRITE, GL_COORD_REPLACE, GL_TRUE)\n        #glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE)    ## use texture color exactly\n        #glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE )  ## texture modulates current color\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)\n        glEnable(GL_PROGRAM_POINT_SIZE)\n        \n            \n        with self.shader:\n            #glUniform1i(self.shader.uniform(\'texture\'), 0)  ## inform the shader which texture to use\n            glEnableClientState(GL_VERTEX_ARRAY)\n            try:\n                pos = self.pos\n                #if pos.ndim > 2:\n                    #pos = pos.reshape((reduce(lambda a,b: a*b, pos.shape[:-1]), pos.shape[-1]))\n                glVertexPointerf(pos)\n            \n                if isinstance(self.color, np.ndarray):\n                    glEnableClientState(GL_COLOR_ARRAY)\n                    glColorPointerf(self.color)\n                else:\n                    if isinstance(self.color, QtGui.QColor):\n                        glColor4f(*fn.glColor(self.color))\n                    else:\n                        glColor4f(*self.color)\n                \n                if not self.pxMode or isinstance(self.size, np.ndarray):\n                    glEnableClientState(GL_NORMAL_ARRAY)\n                    norm = np.empty(pos.shape)\n                    if self.pxMode:\n                        norm[...,0] = self.size\n                    else:\n                        gpos = self.mapToView(pos.transpose()).transpose()\n                        pxSize = self.view().pixelSize(gpos)\n                        norm[...,0] = self.size / pxSize\n                    \n                    glNormalPointerf(norm)\n                else:\n                    glNormal3f(self.size, 0, 0)  ## vertex shader uses norm.x to determine point size\n                    #glPointSize(self.size)\n                glDrawArrays(GL_POINTS, 0, int(pos.size / pos.shape[-1]))\n            finally:\n                glDisableClientState(GL_NORMAL_ARRAY)\n                glDisableClientState(GL_VERTEX_ARRAY)\n                glDisableClientState(GL_COLOR_ARRAY)\n                #posVBO.unbind()\n                ##fixes #145\n                glDisable( GL_TEXTURE_2D )\n                                \n        #for i in range(len(self.pos)):\n            #pos = self.pos[i]\n            \n            #if isinstance(self.color, np.ndarray):\n                #color = self.color[i]\n            #else:\n                #color = self.color\n            #if isinstance(self.color, QtGui.QColor):\n                #color = fn.glColor(self.color)\n                \n            #if isinstance(self.size, np.ndarray):\n                #size = self.size[i]\n            #else:\n                #size = self.size\n                \n            #pxSize = self.view().pixelSize(QtGui.QVector3D(*pos))\n            \n            #glPointSize(size / pxSize)\n            #glBegin( GL_POINTS )\n            #glColor4f(*color)  # x is blue\n            ##glNormal3f(size, 0, 0)\n            #glVertex3f(*pos)\n            #glEnd()\n\n        \n        \n        \n        \n'"
src/third_party/pyqtgraph/opengl/items/GLSurfacePlotItem.py,8,"b'from OpenGL.GL import *\nfrom .GLMeshItem import GLMeshItem\nfrom .. MeshData import MeshData\nfrom ...Qt import QtGui\nimport numpy as np\n\n\n\n__all__ = [\'GLSurfacePlotItem\']\n\nclass GLSurfacePlotItem(GLMeshItem):\n    """"""\n    **Bases:** :class:`GLMeshItem <pyqtgraph.opengl.GLMeshItem>`\n    \n    Displays a surface plot on a regular x,y grid\n    """"""\n    def __init__(self, x=None, y=None, z=None, colors=None, **kwds):\n        """"""\n        The x, y, z, and colors arguments are passed to setData().\n        All other keyword arguments are passed to GLMeshItem.__init__().\n        """"""\n        \n        self._x = None\n        self._y = None\n        self._z = None\n        self._color = None\n        self._vertexes = None\n        self._meshdata = MeshData()\n        GLMeshItem.__init__(self, meshdata=self._meshdata, **kwds)\n        \n        self.setData(x, y, z, colors)\n        \n        \n        \n    def setData(self, x=None, y=None, z=None, colors=None):\n        """"""\n        Update the data in this surface plot. \n        \n        ==============  =====================================================================\n        **Arguments:**\n        x,y             1D arrays of values specifying the x,y positions of vertexes in the\n                        grid. If these are omitted, then the values will be assumed to be\n                        integers.\n        z               2D array of height values for each grid vertex.\n        colors          (width, height, 4) array of vertex colors.\n        ==============  =====================================================================\n        \n        All arguments are optional.\n        \n        Note that if vertex positions are updated, the normal vectors for each triangle must \n        be recomputed. This is somewhat expensive if the surface was initialized with smooth=False\n        and very expensive if smooth=True. For faster performance, initialize with \n        computeNormals=False and use per-vertex colors or a normal-independent shader program.\n        """"""\n        if x is not None:\n            if self._x is None or len(x) != len(self._x):\n                self._vertexes = None\n            self._x = x\n        \n        if y is not None:\n            if self._y is None or len(y) != len(self._y):\n                self._vertexes = None\n            self._y = y\n        \n        if z is not None:\n            #if self._x is None:\n                #self._x = np.arange(z.shape[0])\n                #self._vertexes = None\n            #if self._y is None:\n                #self._y = np.arange(z.shape[1])\n                #self._vertexes = None\n                \n            if self._x is not None and z.shape[0] != len(self._x):\n                raise Exception(\'Z values must have shape (len(x), len(y))\')\n            if self._y is not None and z.shape[1] != len(self._y):\n                raise Exception(\'Z values must have shape (len(x), len(y))\')\n            self._z = z\n            if self._vertexes is not None and self._z.shape != self._vertexes.shape[:2]:\n                self._vertexes = None\n        \n        if colors is not None:\n            self._colors = colors\n            self._meshdata.setVertexColors(colors)\n        \n        if self._z is None:\n            return\n        \n        updateMesh = False\n        newVertexes = False\n        \n        ## Generate vertex and face array\n        if self._vertexes is None:\n            newVertexes = True\n            self._vertexes = np.empty((self._z.shape[0], self._z.shape[1], 3), dtype=float)\n            self.generateFaces()\n            self._meshdata.setFaces(self._faces)\n            updateMesh = True\n        \n        ## Copy x, y, z data into vertex array\n        if newVertexes or x is not None:\n            if x is None:\n                if self._x is None:\n                    x = np.arange(self._z.shape[0])\n                else:\n                    x = self._x\n            self._vertexes[:, :, 0] = x.reshape(len(x), 1)\n            updateMesh = True\n        \n        if newVertexes or y is not None:\n            if y is None:\n                if self._y is None:\n                    y = np.arange(self._z.shape[1])\n                else:\n                    y = self._y\n            self._vertexes[:, :, 1] = y.reshape(1, len(y))\n            updateMesh = True\n        \n        if newVertexes or z is not None:\n            self._vertexes[...,2] = self._z\n            updateMesh = True\n        \n        ## Update MeshData\n        if updateMesh:\n            self._meshdata.setVertexes(self._vertexes.reshape(self._vertexes.shape[0]*self._vertexes.shape[1], 3))\n            self.meshDataChanged()\n        \n        \n    def generateFaces(self):\n        cols = self._z.shape[1]-1\n        rows = self._z.shape[0]-1\n        faces = np.empty((cols*rows*2, 3), dtype=np.uint)\n        rowtemplate1 = np.arange(cols).reshape(cols, 1) + np.array([[0, 1, cols+1]])\n        rowtemplate2 = np.arange(cols).reshape(cols, 1) + np.array([[cols+1, 1, cols+2]])\n        for row in range(rows):\n            start = row * cols * 2 \n            faces[start:start+cols] = rowtemplate1 + row * (cols+1)\n            faces[start+cols:start+(cols*2)] = rowtemplate2 + row * (cols+1)\n        self._faces = faces\n'"
src/third_party/pyqtgraph/opengl/items/GLVolumeItem.py,5,"b'from OpenGL.GL import *\nfrom .. GLGraphicsItem import GLGraphicsItem\nfrom ...Qt import QtGui\nimport numpy as np\nfrom ... import debug\n\n__all__ = [\'GLVolumeItem\']\n\nclass GLVolumeItem(GLGraphicsItem):\n    """"""\n    **Bases:** :class:`GLGraphicsItem <pyqtgraph.opengl.GLGraphicsItem>`\n    \n    Displays volumetric data. \n    """"""\n    \n    \n    def __init__(self, data, sliceDensity=1, smooth=True, glOptions=\'translucent\'):\n        """"""\n        ==============  =======================================================================================\n        **Arguments:**\n        data            Volume data to be rendered. *Must* be 4D numpy array (x, y, z, RGBA) with dtype=ubyte.\n        sliceDensity    Density of slices to render through the volume. A value of 1 means one slice per voxel.\n        smooth          (bool) If True, the volume slices are rendered with linear interpolation \n        ==============  =======================================================================================\n        """"""\n        \n        self.sliceDensity = sliceDensity\n        self.smooth = smooth\n        self.data = None\n        self._needUpload = False\n        self.texture = None\n        GLGraphicsItem.__init__(self)\n        self.setGLOptions(glOptions)\n        self.setData(data)\n        \n    def setData(self, data):\n        self.data = data\n        self._needUpload = True\n        self.update()\n        \n    def _uploadData(self):\n        glEnable(GL_TEXTURE_3D)\n        if self.texture is None:\n            self.texture = glGenTextures(1)\n        glBindTexture(GL_TEXTURE_3D, self.texture)\n        if self.smooth:\n            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n        else:\n            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)\n            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)\n        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER)\n        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER)\n        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER)\n        shape = self.data.shape\n        \n        ## Test texture dimensions first\n        glTexImage3D(GL_PROXY_TEXTURE_3D, 0, GL_RGBA, shape[0], shape[1], shape[2], 0, GL_RGBA, GL_UNSIGNED_BYTE, None)\n        if glGetTexLevelParameteriv(GL_PROXY_TEXTURE_3D, 0, GL_TEXTURE_WIDTH) == 0:\n            raise Exception(""OpenGL failed to create 3D texture (%dx%dx%d); too large for this hardware."" % shape[:3])\n        \n        glTexImage3D(GL_TEXTURE_3D, 0, GL_RGBA, shape[0], shape[1], shape[2], 0, GL_RGBA, GL_UNSIGNED_BYTE, self.data.transpose((2,1,0,3)))\n        glDisable(GL_TEXTURE_3D)\n        \n        self.lists = {}\n        for ax in [0,1,2]:\n            for d in [-1, 1]:\n                l = glGenLists(1)\n                self.lists[(ax,d)] = l\n                glNewList(l, GL_COMPILE)\n                self.drawVolume(ax, d)\n                glEndList()\n        \n        self._needUpload = False\n        \n    def paint(self):\n        if self.data is None:\n            return\n        \n        if self._needUpload:\n            self._uploadData()\n        \n        self.setupGLState()\n        \n        glEnable(GL_TEXTURE_3D)\n        glBindTexture(GL_TEXTURE_3D, self.texture)\n        \n        #glEnable(GL_DEPTH_TEST)\n        #glDisable(GL_CULL_FACE)\n        #glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n        #glEnable( GL_BLEND )\n        #glEnable( GL_ALPHA_TEST )\n        glColor4f(1,1,1,1)\n\n        view = self.view()\n        center = QtGui.QVector3D(*[x/2. for x in self.data.shape[:3]])\n        cam = self.mapFromParent(view.cameraPosition()) - center\n        #print ""center"", center, ""cam"", view.cameraPosition(), self.mapFromParent(view.cameraPosition()), ""diff"", cam\n        cam = np.array([cam.x(), cam.y(), cam.z()])\n        ax = np.argmax(abs(cam))\n        d = 1 if cam[ax] > 0 else -1\n        glCallList(self.lists[(ax,d)])  ## draw axes\n        glDisable(GL_TEXTURE_3D)\n                \n    def drawVolume(self, ax, d):\n        N = 5\n        \n        imax = [0,1,2]\n        imax.remove(ax)\n        \n        tp = [[0,0,0],[0,0,0],[0,0,0],[0,0,0]]\n        vp = [[0,0,0],[0,0,0],[0,0,0],[0,0,0]]\n        nudge = [0.5/x for x in self.data.shape]\n        tp[0][imax[0]] = 0+nudge[imax[0]]\n        tp[0][imax[1]] = 0+nudge[imax[1]]\n        tp[1][imax[0]] = 1-nudge[imax[0]]\n        tp[1][imax[1]] = 0+nudge[imax[1]]\n        tp[2][imax[0]] = 1-nudge[imax[0]]\n        tp[2][imax[1]] = 1-nudge[imax[1]]\n        tp[3][imax[0]] = 0+nudge[imax[0]]\n        tp[3][imax[1]] = 1-nudge[imax[1]]\n        \n        vp[0][imax[0]] = 0\n        vp[0][imax[1]] = 0\n        vp[1][imax[0]] = self.data.shape[imax[0]]\n        vp[1][imax[1]] = 0\n        vp[2][imax[0]] = self.data.shape[imax[0]]\n        vp[2][imax[1]] = self.data.shape[imax[1]]\n        vp[3][imax[0]] = 0\n        vp[3][imax[1]] = self.data.shape[imax[1]]\n        slices = self.data.shape[ax] * self.sliceDensity\n        r = list(range(slices))\n        if d == -1:\n            r = r[::-1]\n            \n        glBegin(GL_QUADS)\n        tzVals = np.linspace(nudge[ax], 1.0-nudge[ax], slices)\n        vzVals = np.linspace(0, self.data.shape[ax], slices)\n        for i in r:\n            z = tzVals[i]\n            w = vzVals[i]\n            \n            tp[0][ax] = z\n            tp[1][ax] = z\n            tp[2][ax] = z\n            tp[3][ax] = z\n            \n            vp[0][ax] = w\n            vp[1][ax] = w\n            vp[2][ax] = w\n            vp[3][ax] = w\n            \n            \n            glTexCoord3f(*tp[0])\n            glVertex3f(*vp[0])\n            glTexCoord3f(*tp[1])\n            glVertex3f(*vp[1])\n            glTexCoord3f(*tp[2])\n            glVertex3f(*vp[2])\n            glTexCoord3f(*tp[3])\n            glVertex3f(*vp[3])\n        glEnd()\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ## Interesting idea:\n        ## remove projection/modelview matrixes, recreate in texture coords. \n        ## it _sorta_ works, but needs tweaking.\n        #mvm = glGetDoublev(GL_MODELVIEW_MATRIX)\n        #pm = glGetDoublev(GL_PROJECTION_MATRIX)\n        #m = QtGui.QMatrix4x4(mvm.flatten()).inverted()[0]\n        #p = QtGui.QMatrix4x4(pm.flatten()).inverted()[0]\n        \n        #glMatrixMode(GL_PROJECTION)\n        #glPushMatrix()\n        #glLoadIdentity()\n        #N=1\n        #glOrtho(-N,N,-N,N,-100,100)\n        \n        #glMatrixMode(GL_MODELVIEW)\n        #glLoadIdentity()\n        \n        \n        #glMatrixMode(GL_TEXTURE)\n        #glLoadIdentity()\n        #glMultMatrixf(m.copyDataTo())\n        \n        #view = self.view()\n        #w = view.width()\n        #h = view.height()\n        #dist = view.opts[\'distance\']\n        #fov = view.opts[\'fov\']\n        #nearClip = dist * .1\n        #farClip = dist * 5.\n        #r = nearClip * np.tan(fov)\n        #t = r * h / w\n        \n        #p = QtGui.QMatrix4x4()\n        #p.frustum( -r, r, -t, t, nearClip, farClip)\n        #glMultMatrixf(p.inverted()[0].copyDataTo())\n        \n        \n        #glBegin(GL_QUADS)\n        \n        #M=1\n        #for i in range(500):\n            #z = i/500.\n            #w = -i/500.\n            #glTexCoord3f(-M, -M, z)\n            #glVertex3f(-N, -N, w)\n            #glTexCoord3f(M, -M, z)\n            #glVertex3f(N, -N, w)\n            #glTexCoord3f(M, M, z)\n            #glVertex3f(N, N, w)\n            #glTexCoord3f(-M, M, z)\n            #glVertex3f(-N, N, w)\n        #glEnd()\n        #glDisable(GL_TEXTURE_3D)\n\n        #glMatrixMode(GL_PROJECTION)\n        #glPopMatrix()\n        \n        \n\n'"
src/third_party/pyqtgraph/opengl/items/__init__.py,0,b''
src/third_party/pyqtgraph/parametertree/tests/test_parametertypes.py,2,"b'# ~*~ coding: utf8 ~*~\nimport sys\nimport pytest\nfrom pyqtgraph.Qt import QtGui, QtCore\nimport pyqtgraph.parametertree as pt\nimport pyqtgraph as pg\nfrom pyqtgraph.python2_3 import asUnicode\nfrom pyqtgraph.functions import eq\nimport numpy as np\n\napp = pg.mkQApp()\n\ndef _getWidget(param):\n    return list(param.items.keys())[0].widget\n\n\ndef test_opts():\n    paramSpec = [\n        dict(name=\'bool\', type=\'bool\', readonly=True),\n        dict(name=\'color\', type=\'color\', readonly=True),\n    ]\n\n    param = pt.Parameter.create(name=\'params\', type=\'group\', children=paramSpec)\n    tree = pt.ParameterTree()\n    tree.setParameters(param)\n\n    assert _getWidget(param.param(\'bool\')).isEnabled() is False\n    assert _getWidget(param.param(\'bool\')).isEnabled() is False\n\n\ndef test_types():\n    paramSpec = [\n        dict(name=\'float\', type=\'float\'),\n        dict(name=\'int\', type=\'int\'),\n        dict(name=\'str\', type=\'str\'),\n        dict(name=\'list\', type=\'list\', values=[\'x\',\'y\',\'z\']),\n        dict(name=\'dict\', type=\'list\', values={\'x\':1, \'y\':3, \'z\':7}),\n        dict(name=\'bool\', type=\'bool\'),\n        dict(name=\'color\', type=\'color\'),\n    ]\n    \n    param = pt.Parameter.create(name=\'params\', type=\'group\', children=paramSpec)\n    tree = pt.ParameterTree()\n    tree.setParameters(param)\n\n    all_objs = {\n        \'int0\': 0, \'int\':7, \'float\': -0.35, \'bigfloat\': 1e129, \'npfloat\': np.float(5), \n        \'npint\': np.int(5),\'npinf\': np.inf, \'npnan\': np.nan, \'bool\': True, \n        \'complex\': 5+3j, \'str\': \'xxx\', \'unicode\': asUnicode(\'\xc2\xb5\'), \n        \'list\': [1,2,3], \'dict\': {\'1\': 2}, \'color\': pg.mkColor(\'k\'), \n        \'brush\': pg.mkBrush(\'k\'), \'pen\': pg.mkPen(\'k\'), \'none\': None\n    }\n    if hasattr(QtCore, \'QString\'):\n        all_objs[\'qstring\'] = QtCore.QString(\'xxx\xc2\xb5\')\n\n    # float\n    types = [\'int0\', \'int\', \'float\', \'bigfloat\', \'npfloat\', \'npint\', \'npinf\', \'npnan\', \'bool\']\n    check_param_types(param.child(\'float\'), float, float, 0.0, all_objs, types)\n\n    # int\n    types = [\'int0\', \'int\', \'float\', \'bigfloat\', \'npfloat\', \'npint\', \'bool\']\n    inttyps = int if sys.version[0] >= \'3\' else (int, long) \n    check_param_types(param.child(\'int\'), inttyps, int, 0, all_objs, types)\n    \n    # str  (should be able to make a string out of any type)\n    types = all_objs.keys()\n    strtyp = str if sys.version[0] >= \'3\' else unicode\n    check_param_types(param.child(\'str\'), strtyp, asUnicode, \'\', all_objs, types)\n    \n    # bool  (should be able to make a boolean out of any type?)\n    types = all_objs.keys()\n    check_param_types(param.child(\'bool\'), bool, bool, False, all_objs, types)\n\n    # color\n    types = [\'color\', \'int0\', \'int\', \'float\', \'npfloat\', \'npint\', \'list\']\n    init = QtGui.QColor(128, 128, 128, 255)\n    check_param_types(param.child(\'color\'), QtGui.QColor, pg.mkColor, init, all_objs, types)\n\n    \ndef check_param_types(param, types, map_func, init, objs, keys):\n    """"""Check that parameter setValue() accepts or rejects the correct types and\n    that value() returns the correct type.\n    \n    Parameters\n    ----------\n        param : Parameter instance\n        types : type or tuple of types\n            The allowed types for this parameter to return from value().\n        map_func : function\n            Converts an input value to the expected output value.\n        init : object\n            The expected initial value of the parameter\n        objs : dict\n            Contains a variety of objects that will be tested as arguments to\n            param.setValue().\n        keys : list\n            The list of keys indicating the valid objects in *objs*. When\n            param.setValue() is teasted with each value from *objs*, we expect\n            an exception to be raised if the associated key is not in *keys*.\n    """"""\n    val = param.value()\n    if not isinstance(types, tuple):\n        types = (types,)\n    assert val == init and type(val) in types\n    \n    # test valid input types\n    good_inputs = [objs[k] for k in keys if k in objs]\n    good_outputs = map(map_func, good_inputs)\n    for x,y in zip(good_inputs, good_outputs):\n        param.setValue(x)\n        val = param.value()\n        if not (eq(val, y) and type(val) in types):\n            raise Exception(""Setting parameter %s with value %r should have resulted in %r (types: %r), ""\n                ""but resulted in %r (type: %r) instead."" % (param, x, y, types, val, type(val)))\n        \n    # test invalid input types\n    for k,v in objs.items():\n        if k in keys:\n            continue\n        try:\n            param.setValue(v)\n        except (TypeError, ValueError, OverflowError):\n            continue\n        except Exception as exc:\n            raise Exception(""Setting %s parameter value to %r raised %r."" % (param, v, exc))\n        \n        raise Exception(""Setting %s parameter value to %r should have raised an exception."" % (param, v))\n        \n        \n        \n    \n    \n    \n    '"
src/third_party/pyqtgraph/util/colorama/__init__.py,0,b''
src/third_party/pyqtgraph/util/colorama/win32.py,0,"b'# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# from winbase.h\nSTDOUT = -11\nSTDERR = -12\n\ntry:\n    from ctypes import windll\n    from ctypes import wintypes\nexcept ImportError:\n    windll = None\n    SetConsoleTextAttribute = lambda *_: None\nelse:\n    from ctypes import (\n        byref, Structure, c_char, c_short, c_int, c_uint32, c_ushort, c_void_p, POINTER\n    )\n\n    class CONSOLE_SCREEN_BUFFER_INFO(Structure):\n        """"""struct in wincon.h.""""""\n        _fields_ = [\n            (""dwSize"", wintypes._COORD),\n            (""dwCursorPosition"", wintypes._COORD),\n            (""wAttributes"", wintypes.WORD),\n            (""srWindow"", wintypes.SMALL_RECT),\n            (""dwMaximumWindowSize"", wintypes._COORD),\n        ]\n        def __str__(self):\n            return \'(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)\' % (\n                self.dwSize.Y, self.dwSize.X\n                , self.dwCursorPosition.Y, self.dwCursorPosition.X\n                , self.wAttributes\n                , self.srWindow.Top, self.srWindow.Left, self.srWindow.Bottom, self.srWindow.Right\n                , self.dwMaximumWindowSize.Y, self.dwMaximumWindowSize.X\n            )\n\n    _GetStdHandle = windll.kernel32.GetStdHandle\n    _GetStdHandle.argtypes = [\n        wintypes.DWORD,\n    ]\n    _GetStdHandle.restype = wintypes.HANDLE\n\n    _GetConsoleScreenBufferInfo = windll.kernel32.GetConsoleScreenBufferInfo\n    _GetConsoleScreenBufferInfo.argtypes = [\n        wintypes.HANDLE,\n        c_void_p,\n        #POINTER(CONSOLE_SCREEN_BUFFER_INFO),\n    ]\n    _GetConsoleScreenBufferInfo.restype = wintypes.BOOL\n\n    _SetConsoleTextAttribute = windll.kernel32.SetConsoleTextAttribute\n    _SetConsoleTextAttribute.argtypes = [\n        wintypes.HANDLE,\n        wintypes.WORD,\n    ]\n    _SetConsoleTextAttribute.restype = wintypes.BOOL\n\n    _SetConsoleCursorPosition = windll.kernel32.SetConsoleCursorPosition\n    _SetConsoleCursorPosition.argtypes = [\n        wintypes.HANDLE,\n        c_int,\n        #wintypes._COORD,\n    ]\n    _SetConsoleCursorPosition.restype = wintypes.BOOL\n\n    _FillConsoleOutputCharacterA = windll.kernel32.FillConsoleOutputCharacterA\n    _FillConsoleOutputCharacterA.argtypes = [\n        wintypes.HANDLE,\n        c_char,\n        wintypes.DWORD,\n        wintypes._COORD,\n        POINTER(wintypes.DWORD),\n    ]\n    _FillConsoleOutputCharacterA.restype = wintypes.BOOL\n\n    _FillConsoleOutputAttribute = windll.kernel32.FillConsoleOutputAttribute\n    _FillConsoleOutputAttribute.argtypes = [\n        wintypes.HANDLE,\n        wintypes.WORD,\n        wintypes.DWORD,\n        c_int,\n        #wintypes._COORD,\n        POINTER(wintypes.DWORD),\n    ]\n    _FillConsoleOutputAttribute.restype = wintypes.BOOL\n\n    handles = {\n        STDOUT: _GetStdHandle(STDOUT),\n        STDERR: _GetStdHandle(STDERR),\n    }\n\n    def GetConsoleScreenBufferInfo(stream_id=STDOUT):\n        handle = handles[stream_id]\n        csbi = CONSOLE_SCREEN_BUFFER_INFO()\n        success = _GetConsoleScreenBufferInfo(\n            handle, byref(csbi))\n        return csbi\n\n    def SetConsoleTextAttribute(stream_id, attrs):\n        handle = handles[stream_id]\n        return _SetConsoleTextAttribute(handle, attrs)\n\n    def SetConsoleCursorPosition(stream_id, position):\n        position = wintypes._COORD(*position)\n        # If the position is out of range, do nothing.\n        if position.Y <= 0 or position.X <= 0:\n            return\n        # Adjust for Windows\' SetConsoleCursorPosition:\n        #    1. being 0-based, while ANSI is 1-based.\n        #    2. expecting (x,y), while ANSI uses (y,x).\n        adjusted_position = wintypes._COORD(position.Y - 1, position.X - 1)\n        # Adjust for viewport\'s scroll position\n        sr = GetConsoleScreenBufferInfo(STDOUT).srWindow\n        adjusted_position.Y += sr.Top\n        adjusted_position.X += sr.Left\n        # Resume normal processing\n        handle = handles[stream_id]\n        return _SetConsoleCursorPosition(handle, adjusted_position)\n\n    def FillConsoleOutputCharacter(stream_id, char, length, start):\n        handle = handles[stream_id]\n        char = c_char(char)\n        length = wintypes.DWORD(length)\n        num_written = wintypes.DWORD(0)\n        # Note that this is hard-coded for ANSI (vs wide) bytes.\n        success = _FillConsoleOutputCharacterA(\n            handle, char, length, start, byref(num_written))\n        return num_written.value\n\n    def FillConsoleOutputAttribute(stream_id, attr, length, start):\n        \'\'\' FillConsoleOutputAttribute( hConsole, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten )\'\'\'\n        handle = handles[stream_id]\n        attribute = wintypes.WORD(attr)\n        length = wintypes.DWORD(length)\n        num_written = wintypes.DWORD(0)\n        # Note that this is hard-coded for ANSI (vs wide) bytes.\n        return _FillConsoleOutputAttribute(\n            handle, attribute, length, start, byref(num_written))\n'"
src/third_party/pyqtgraph/util/colorama/winterm.py,0,"b""# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nfrom . import win32\n\n\n# from wincon.h\nclass WinColor(object):\n    BLACK   = 0\n    BLUE    = 1\n    GREEN   = 2\n    CYAN    = 3\n    RED     = 4\n    MAGENTA = 5\n    YELLOW  = 6\n    GREY    = 7\n\n# from wincon.h\nclass WinStyle(object):\n    NORMAL = 0x00 # dim text, dim background\n    BRIGHT = 0x08 # bright text, dim background\n\n\nclass WinTerm(object):\n\n    def __init__(self):\n        self._default = win32.GetConsoleScreenBufferInfo(win32.STDOUT).wAttributes\n        self.set_attrs(self._default)\n        self._default_fore = self._fore\n        self._default_back = self._back\n        self._default_style = self._style\n\n    def get_attrs(self):\n        return self._fore + self._back * 16 + self._style\n\n    def set_attrs(self, value):\n        self._fore = value & 7\n        self._back = (value >> 4) & 7\n        self._style = value & WinStyle.BRIGHT\n\n    def reset_all(self, on_stderr=None):\n        self.set_attrs(self._default)\n        self.set_console(attrs=self._default)\n\n    def fore(self, fore=None, on_stderr=False):\n        if fore is None:\n            fore = self._default_fore\n        self._fore = fore\n        self.set_console(on_stderr=on_stderr)\n\n    def back(self, back=None, on_stderr=False):\n        if back is None:\n            back = self._default_back\n        self._back = back\n        self.set_console(on_stderr=on_stderr)\n\n    def style(self, style=None, on_stderr=False):\n        if style is None:\n            style = self._default_style\n        self._style = style\n        self.set_console(on_stderr=on_stderr)\n\n    def set_console(self, attrs=None, on_stderr=False):\n        if attrs is None:\n            attrs = self.get_attrs()\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleTextAttribute(handle, attrs)\n\n    def get_position(self, handle):\n        position = win32.GetConsoleScreenBufferInfo(handle).dwCursorPosition\n        # Because Windows coordinates are 0-based,\n        # and win32.SetConsoleCursorPosition expects 1-based.\n        position.X += 1\n        position.Y += 1\n        return position\n    \n    def set_cursor_position(self, position=None, on_stderr=False):\n        if position is None:\n            #I'm not currently tracking the position, so there is no default.\n            #position = self.get_position()\n            return\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleCursorPosition(handle, position)\n\n    def cursor_up(self, num_rows=0, on_stderr=False):\n        if num_rows == 0:\n            return\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        position = self.get_position(handle)\n        adjusted_position = (position.Y - num_rows, position.X)\n        self.set_cursor_position(adjusted_position, on_stderr)\n\n    def erase_data(self, mode=0, on_stderr=False):\n        # 0 (or None) should clear from the cursor to the end of the screen.\n        # 1 should clear from the cursor to the beginning of the screen.\n        # 2 should clear the entire screen. (And maybe move cursor to (1,1)?)\n        #\n        # At the moment, I only support mode 2. From looking at the API, it\n        #    should be possible to calculate a different number of bytes to clear,\n        #    and to do so relative to the cursor position.\n        if mode[0] not in (2,):\n            return\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        # here's where we'll home the cursor\n        coord_screen = win32.COORD(0,0)\n        csbi = win32.GetConsoleScreenBufferInfo(handle)\n        # get the number of character cells in the current buffer\n        dw_con_size = csbi.dwSize.X * csbi.dwSize.Y\n        # fill the entire screen with blanks\n        win32.FillConsoleOutputCharacter(handle, ' ', dw_con_size, coord_screen)\n        # now set the buffer's attributes accordingly\n        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), dw_con_size, coord_screen )\n        # put the cursor at (0, 0)\n        win32.SetConsoleCursorPosition(handle, (coord_screen.X, coord_screen.Y))\n"""
src/third_party/pyqtgraph/util/tests/test_lru_cache.py,0,"b""from pyqtgraph.util.lru_cache import LRUCache\n\ndef testLRU():\n    lru = LRUCache(2, 1)\n    # check twice\n    checkLru(lru)\n    checkLru(lru)\n\ndef checkLru(lru):\n    lru[1] = 1\n    lru[2] = 2\n    lru[3] = 3\n\n    assert len(lru) == 2\n    assert set([2, 3]) == set(lru.keys())\n    assert set([2, 3]) == set(lru.values())\n\n    lru[2] = 2\n    assert set([2, 3]) == set(lru.values())\n    \n    lru[1] = 1\n    set([2, 1]) == set(lru.values())\n\n    #Iterates from the used in the last access to others based on access time.\n    assert [(2, 2), (1, 1)] == list(lru.items(accessTime=True))\n    lru[2] = 2\n    assert [(1, 1), (2, 2)] == list(lru.items(accessTime=True))\n\n    del lru[2]\n    assert [(1, 1), ] == list(lru.items(accessTime=True))\n\n    lru[2] = 2\n    assert [(1, 1), (2, 2)] == list(lru.items(accessTime=True))\n\n    _a = lru[1]\n    assert [(2, 2), (1, 1)] == list(lru.items(accessTime=True))\n\n    _a = lru[2]\n    assert [(1, 1), (2, 2)] == list(lru.items(accessTime=True))\n\n    assert lru.get(2) == 2\n    assert lru.get(3) == None\n    assert [(1, 1), (2, 2)] == list(lru.items(accessTime=True))\n\n    lru.clear()\n    assert [] == list(lru.items())\n\n\nif __name__ == '__main__':\n    testLRU()\n"""
src/third_party/pyqtgraph/widgets/tests/test_combobox.py,0,"b'import pyqtgraph as pg\npg.mkQApp()\n\ndef test_combobox():\n    cb = pg.ComboBox()\n    items = {\'a\': 1, \'b\': 2, \'c\': 3}\n    cb.setItems(items)\n    cb.setValue(2)\n    assert str(cb.currentText()) == \'b\'\n    assert cb.value() == 2\n    \n    # Clear item list; value should be None\n    cb.clear()\n    assert cb.value() == None\n    \n    # Reset item list; value should be set automatically\n    cb.setItems(items)\n    assert cb.value() == 2\n    \n    # Clear item list; repopulate with same names and new values\n    items = {\'a\': 4, \'b\': 5, \'c\': 6}\n    cb.clear()\n    cb.setItems(items)\n    assert cb.value() == 5\n    \n    # Set list instead of dict\n    cb.setItems(list(items.keys()))\n    assert str(cb.currentText()) == \'b\'\n    \n    cb.setValue(\'c\')\n    assert cb.value() == str(cb.currentText())\n    assert cb.value() == \'c\'\n    \n    cb.setItemValue(\'c\', 7)\n    assert cb.value() == 7\n    \n    \nif __name__ == \'__main__\':\n    cb = pg.ComboBox()\n    cb.show()\n    cb.setItems({\'\': None, \'a\': 1, \'b\': 2, \'c\': 3})\n    def fn(ind):\n        print(""New value: %s"" % cb.value())\n    cb.currentIndexChanged.connect(fn)'"
src/third_party/pyqtgraph/widgets/tests/test_spinbox.py,0,"b""import pyqtgraph as pg\npg.mkQApp()\n\n\ndef test_spinbox_formatting():\n    sb = pg.SpinBox()\n    assert sb.opts['decimals'] == 6\n    assert sb.opts['int'] is False\n    \n    # table  of test conditions:\n    # value, text, options\n    conds = [\n        (0, '0', dict(suffix='', siPrefix=False, dec=False, int=False)),\n        (100, '100', dict()),\n        (1000000, '1e+06', dict()),\n        (1000, '1e+03', dict(decimals=2)),\n        (1000000, '1e+06', dict(int=True, decimals=6)),\n        (12345678955, '12345678955', dict(int=True, decimals=100)),\n        (1.45e-9, '1.45e-09 A', dict(int=False, decimals=6, suffix='A', siPrefix=False)),\n        (1.45e-9, '1.45 nA', dict(int=False, decimals=6, suffix='A', siPrefix=True)),\n        (1.45, '1.45 PSI', dict(int=False, decimals=6, suffix='PSI', siPrefix=True)),\n        (1.45e-3, '1.45 mPSI', dict(int=False, decimals=6, suffix='PSI', siPrefix=True)),\n        (-2500.3427, '$-2500.34', dict(int=False, format='${value:0.02f}')),\n    ]\n    \n    for (value, text, opts) in conds:\n        sb.setOpts(**opts)\n        sb.setValue(value)\n        assert sb.value() == value\n        assert pg.asUnicode(sb.text()) == text\n\n        # test setting value\n        if not opts.get('int', False):\n            suf = sb.opts['suffix']\n            sb.lineEdit().setText('0.1' + suf)\n            sb.editingFinishedEvent()\n            assert sb.value() == 0.1\n            if suf != '':\n                sb.lineEdit().setText('0.1 m' + suf)\n                sb.editingFinishedEvent()\n                assert sb.value() == 0.1e-3\n"""
src/third_party/pyqtgraph/widgets/tests/test_tablewidget.py,2,"b'import pyqtgraph as pg\nimport numpy as np\nfrom pyqtgraph.pgcollections import OrderedDict\n\napp = pg.mkQApp()\n\n\nlistOfTuples = [(\'text_%d\' % i, i, i/9.) for i in range(12)]\nlistOfLists = [list(row) for row in listOfTuples]\nplainArray = np.array(listOfLists, dtype=object)\nrecordArray = np.array(listOfTuples, dtype=[(\'string\', object), \n                                            (\'integer\', int), \n                                            (\'floating\', float)])\ndictOfLists = OrderedDict([(name, list(recordArray[name])) for name in recordArray.dtype.names])\nlistOfDicts = [OrderedDict([(name, rec[name]) for name in recordArray.dtype.names]) for rec in recordArray]\ntransposed = [[row[col] for row in listOfTuples] for col in range(len(listOfTuples[0]))]\n\ndef assertTableData(table, data):\n    assert len(data) == table.rowCount()\n    rows = list(range(table.rowCount()))\n    columns = list(range(table.columnCount()))\n    for r in rows:\n        assert len(data[r]) == table.columnCount()\n        row = []\n        for c in columns:\n            item = table.item(r, c)\n            if item is not None:\n                row.append(item.value)\n            else:\n                row.append(None)\n        assert row == list(data[r])\n    \n\ndef test_TableWidget():\n    w = pg.TableWidget(sortable=False)\n    \n    # Test all input data types\n    w.setData(listOfTuples)\n    assertTableData(w, listOfTuples)\n    \n    w.setData(listOfLists)\n    assertTableData(w, listOfTuples)\n    \n    w.setData(plainArray)\n    assertTableData(w, listOfTuples)\n    \n    w.setData(recordArray)\n    assertTableData(w, listOfTuples)\n    \n    w.setData(dictOfLists)\n    assertTableData(w, transposed)\n    \n    w.appendData(dictOfLists)\n    assertTableData(w, transposed * 2)\n        \n    w.setData(listOfDicts)\n    assertTableData(w, listOfTuples)\n    \n    w.appendData(listOfDicts)\n    assertTableData(w, listOfTuples * 2)\n\n    # Test sorting\n    w.setData(listOfTuples)\n    w.sortByColumn(0, pg.QtCore.Qt.AscendingOrder)\n    assertTableData(w, sorted(listOfTuples, key=lambda a: a[0]))\n    \n    w.sortByColumn(1, pg.QtCore.Qt.AscendingOrder)\n    assertTableData(w, sorted(listOfTuples, key=lambda a: a[1]))\n    \n    w.sortByColumn(2, pg.QtCore.Qt.AscendingOrder)\n    assertTableData(w, sorted(listOfTuples, key=lambda a: a[2]))\n    \n    w.setSortMode(1, \'text\')\n    w.sortByColumn(1, pg.QtCore.Qt.AscendingOrder)\n    assertTableData(w, sorted(listOfTuples, key=lambda a: str(a[1])))\n\n    w.setSortMode(1, \'index\')\n    w.sortByColumn(1, pg.QtCore.Qt.AscendingOrder)\n    assertTableData(w, listOfTuples)\n\n    # Test formatting\n    item = w.item(0, 2)\n    assert item.text() == (\'%0.3g\' % item.value)\n    \n    w.setFormat(\'%0.6f\')\n    assert item.text() == (\'%0.6f\' % item.value)\n    \n    w.setFormat(\'X%0.7f\', column=2)\n    assert isinstance(item.value, float)\n    assert item.text() == (\'X%0.7f\' % item.value)\n    \n    # test setting items that do not exist yet\n    w.setFormat(\'X%0.7f\', column=3)\n    \n    # test append uses correct formatting\n    w.appendRow((\'x\', 10, 7.3))\n    item = w.item(w.rowCount()-1, 2)\n    assert isinstance(item.value, float)\n    assert item.text() == (\'X%0.7f\' % item.value)\n    \n    # test reset back to defaults\n    w.setFormat(None, column=2)\n    assert isinstance(item.value, float)\n    assert item.text() == (\'%0.6f\' % item.value)\n    \n    w.setFormat(None)\n    assert isinstance(item.value, float)\n    assert item.text() == (\'%0.3g\' % item.value)\n    \n    # test function formatter\n    def fmt(item):\n        if isinstance(item.value, float):\n            return ""%d %f"" % (item.index, item.value)\n        else:\n            return pg.asUnicode(item.value)\n    w.setFormat(fmt)\n    assert isinstance(item.value, float)\n    assert isinstance(item.index, int)\n    assert item.text() == (""%d %f"" % (item.index, item.value))\n    \n\n\nif __name__ == \'__main__\':\n    w = pg.TableWidget(editable=True)\n    w.setData(listOfTuples)\n    w.resize(600, 600)\n    w.show()\n\n'"
src/third_party/pyqtgraph/graphicsItems/ViewBox/tests/test_ViewBox.py,0,"b'#import PySide\nimport pyqtgraph as pg\nimport pytest\n\napp = pg.mkQApp()\nqtest = pg.Qt.QtTest.QTest\nQRectF = pg.QtCore.QRectF\n\ndef assertMapping(vb, r1, r2):\n    assert vb.mapFromView(r1.topLeft()) == r2.topLeft()\n    assert vb.mapFromView(r1.bottomLeft()) == r2.bottomLeft()\n    assert vb.mapFromView(r1.topRight()) == r2.topRight()\n    assert vb.mapFromView(r1.bottomRight()) == r2.bottomRight()\n\ndef init_viewbox():\n    """"""Helper function to init the ViewBox\n    """"""\n    global win, vb\n    \n    win = pg.GraphicsWindow()\n    win.ci.layout.setContentsMargins(0,0,0,0)\n    win.resize(200, 200)\n    win.show()\n    vb = win.addViewBox()\n    \n    # set range before viewbox is shown\n    vb.setRange(xRange=[0, 10], yRange=[0, 10], padding=0)\n    \n    # required to make mapFromView work properly.\n    qtest.qWaitForWindowShown(win)\n    \n    g = pg.GridItem()\n    vb.addItem(g)\n    \n    app.processEvents()\n    \ndef test_ViewBox():\n    init_viewbox()\n    \n    w = vb.geometry().width()\n    h = vb.geometry().height()\n    view1 = QRectF(0, 0, 10, 10)\n    size1 = QRectF(0, h, w, -h)\n    assertMapping(vb, view1, size1)\n    \n    # test resize\n    win.resize(400, 400)\n    app.processEvents()\n    w = vb.geometry().width()\n    h = vb.geometry().height()\n    size1 = QRectF(0, h, w, -h)\n    assertMapping(vb, view1, size1)\n    \n    # now lock aspect\n    vb.setAspectLocked()\n    \n    # test wide resize\n    win.resize(800, 400)\n    app.processEvents()\n    w = vb.geometry().width()\n    h = vb.geometry().height()\n    view1 = QRectF(-5, 0, 20, 10)\n    size1 = QRectF(0, h, w, -h)\n    assertMapping(vb, view1, size1)\n    \n    # test tall resize\n    win.resize(400, 800)\n    app.processEvents()\n    w = vb.geometry().width()\n    h = vb.geometry().height()\n    view1 = QRectF(0, -5, 10, 20)\n    size1 = QRectF(0, h, w, -h)\n    assertMapping(vb, view1, size1)\n\n\nskipreason = ""Skipping this test until someone has time to fix it.""\n@pytest.mark.skipif(True, reason=skipreason)\ndef test_limits_and_resize():\n    init_viewbox()\n\n    # now lock aspect\n    vb.setAspectLocked()\n    # test limits + resize  (aspect ratio constraint has priority over limits\n    win.resize(400, 400)\n    app.processEvents()\n    vb.setLimits(xMin=0, xMax=10, yMin=0, yMax=10)\n    win.resize(800, 400)\n    app.processEvents()\n    w = vb.geometry().width()\n    h = vb.geometry().height()\n    view1 = QRectF(-5, 0, 20, 10)\n    size1 = QRectF(0, h, w, -h)\n    assertMapping(vb, view1, size1)\n'"
