file_path,api_count,code
setup.py,0,"b'from __future__ import print_function\nimport sys\nfrom setuptools import setup\n\ntry:\n    import m2r\n    long_description = m2r.parse_from_file(\'README.md\')\nexcept(IOError, ImportError):\n    print(\'Markdown not converted to rst\')\n    long_description = open(\'README.md\').read()\n\nabout = {}\nwith open(""./oommftools/_about.py"") as fp:\n    exec(fp.read(), about)\n    \nsetup(\n    name=about[\'__title__\'].lower(),\n    version=about[\'__version__\'],\n    description=\'\'.join(about[\'__summary__\']),\n    long_description=long_description,\n    author=about[\'__author__\'],\n    maintainer=about[\'__maintainer__\'],\n    license=\'GPLv2\',\n    author_email=about[\'__email__\'],\n    url=about[\'__uri__\'],\n    packages=[\'oommftools\'],  # same as name\n    setup_requires=[\'pytest-runner\'],\n    install_requires=[\'scipy\', \'numpy\', \'future\', \'pytest\'] + (\n            [""wxpython""] if not sys.platform.startswith(""linux"") else []\n            ),  # external packages as dependencies\n    tests_require=[\'pytest\', \'pytest-cov\'],\n    classifiers=[\n                 \'Operating System :: MacOS :: MacOS X\',\n                 \'Operating System :: Microsoft :: Windows\',\n                 \'Operating System :: POSIX\',\n                 \'Programming Language :: Python :: 2.7\',\n                 \'Intended Audience :: Science/Research\',\n                 \'Topic :: Scientific/Engineering :: Physics\',\n                 \'Topic :: Scientific/Engineering :: Visualization\',\n                 \'License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)\'\n                ],\n)\n'"
oommftools/__init__.py,0,b''
oommftools/__main__.py,0,b'import oommftools\n\noommftools.main()'
oommftools/_about.py,0,"b'__title__ = ""OOMMFTools""\n__summary__ = (""OOMMFTools is a set of drag-and-drop GUI utilities "",\n    ""to assist in OOMMF postprocessing, including image"",\n    ""conversion and vector file manipulation."")\n__uri__ = \'https://github.com/deparkes/OOMMFTools\'\n__version__ = \'2.0.3.dev\'\n__author__ = ""Mark Mascaro and Contributors""\n__maintainer__ = ""Duncan Parkes""\n__email__ = ""deparkes@gmail.com""\n\n__license__ = (""OOMMFTools is free software; you can redistribute"",\n            ""it and/or modify it under the terms of the GNU "",\n            ""General Public License as published by the Free "",\n            ""Software Foundation, either version 2 of the License,""\n            ""or (at your option) any later version."")\n__copyright__ = ""2010 %s"" % __author__\n'"
oommftools/fnameutil.py,0,"b'def filterOnExtensions(extensions, inlist):\n\tworklist = []\n\t#Sadly, it\'s not possible to use filter itself here without a nasty eval setup. No thanks!\n\tfor item in inlist:\n\t\tif item.rsplit(""."",1)[-1] in extensions:\n\t\t\tworklist.append(item)\n\treturn worklist\n'"
oommftools/oommftools.py,0,"b'""""""\nMain GUI that manages singleton instances of the other windows\n""""""\nfrom __future__ import absolute_import\n\nimport sys\nfrom user_interfaces.gui import gui_main\nfrom user_interfaces.cli import cli_main\n\ndef main():\n    if len(sys.argv) <= 1:\n        gui_main()\n    else:\n        cli_main()\n\n\nif __name__ == \'__main__\':\n    main()'"
scripts/make-release.py,0,"b'#!/usr/bin/env python\n\n""""""\nCopyright (c) 2010 by the Pallets team.\nModifications (c) 2018 by Duncan Parkes\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms of the software as\nwell as documentation, with or without modification, are permitted\nprovided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the following disclaimer in the\n  documentation and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\nBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\nCOPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\nNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE AND DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n""""""\n\nfrom __future__ import print_function\n\nimport os\nimport re\nimport sys\nfrom datetime import date, datetime\nfrom subprocess import PIPE, Popen\n\n_date_strip_re = re.compile(r\'(?<=\\d)(st|nd|rd|th)\')\n\n\ndef parse_changelog():\n    with open(\'CHANGES.rst\') as f:\n        lineiter = iter(f)\n        for line in lineiter:\n            match = re.search(\'^Version\\s+(.*)\', line.strip())\n\n            if match is None:\n                continue\n\n            version = match.group(1).strip()\n\n            if next(lineiter).count(\'-\') != len(match.group(0)):\n                continue\n\n            while 1:\n                change_info = next(lineiter).strip()\n\n                if change_info:\n                    break\n\n            match = re.search(\n                r\'released on (\\w+\\s+\\d+\\w+\\s+\\d+)(?:, codename (.*))?\',\n                change_info,\n                flags=re.IGNORECASE\n            )\n\n            if match is None:\n                continue\n\n            datestr, codename = match.groups()\n            return version, parse_date(datestr), codename\n\n\ndef bump_version(version):\n    try:\n        parts = [int(i) for i in version.split(\'.\')]\n    except ValueError:\n        fail(\'Current version is not numeric\')\n\n    parts[-1] += 1\n    return \'.\'.join(map(str, parts))\n\n\ndef parse_date(string):\n    string = _date_strip_re.sub(\'\', string)\n    return datetime.strptime(string, \'%B %d %Y\')\n\n\ndef set_filename_version(filename, version_number, pattern):\n    assert os.path.isfile(filename)\n    changed = []\n\n    def inject_version(match):\n        before, old, after = match.groups()\n        changed.append(True)\n        return before + version_number + after\n\n    with open(filename) as f:\n        contents = re.sub(\n            r""^(\\s*%s\\s*=\\s*\')(.+?)(\')"" % pattern,\n            inject_version, f.read(),\n            flags=re.DOTALL | re.MULTILINE\n        )\n    if not changed:\n        fail(\'Could not find %s in %s\', pattern, filename)\n\n    with open(filename, \'w\') as f:\n        f.write(contents)\n\n\ndef set_init_version(version):\n    info(\'Setting _about.py version to %s\', version)\n    set_filename_version(\'oommftools/_about.py\', version, \'__version__\')\n\n\ndef build():\n    cmd = [sys.executable, \'setup.py\', \'release\', \'sdist\', \'bdist_wheel\']\n    Popen(cmd).wait()\n\n\ndef fail(message, *args):\n    print(\'Error:\', message % args, file=sys.stderr)\n    sys.exit(1)\n\n\ndef info(message, *args):\n    print(message % args, file=sys.stderr)\n\n\ndef get_git_tags():\n    return set(\n        Popen([\'git\', \'tag\'], stdout=PIPE).communicate()[0].splitlines()\n    )\n\n\ndef git_is_clean():\n    return Popen([\'git\', \'diff\', \'--quiet\']).wait() == 0\n\n\ndef make_git_commit(message, *args):\n    message = message % args\n    Popen([\'git\', \'commit\', \'-am\', message]).wait()\n\n\ndef make_git_tag(tag):\n    info(\'Tagging ""%s""\', tag)\n    Popen([\'git\', \'tag\', tag]).wait()\n\n\ndef main():\n    os.chdir(os.path.join(os.path.dirname(__file__), \'..\'))\n\n    rv = parse_changelog()\n\n    if rv is None:\n        fail(\'Could not parse changelog\')\n\n    version, release_date, codename = rv\n    dev_version = bump_version(version) + \'.dev\'\n\n    info(\n        \'Releasing %s (codename %s, release date %s)\',\n        version, codename, release_date.strftime(\'%d/%m/%Y\')\n    )\n    tags = get_git_tags()\n\n    if version in tags:\n        fail(\'Version ""%s"" is already tagged\', version)\n\n    if release_date.date() != date.today():\n        fail(\n            \'Release date is not today (%s != %s)\',\n            release_date.date(), date.today()\n        )\n\n    if not git_is_clean():\n        fail(\'You have uncommitted changes in git\')\n\n    try:\n        import wheel  # noqa: F401\n    except ImportError:\n        fail(\'You need to install the wheel package.\')\n\n    set_init_version(version)\n    make_git_commit(\'Bump version number to %s\', version)\n    make_git_tag(\'v\'+version)\n    build()\n    set_init_version(dev_version)\n\n\nif __name__ == \'__main__\':\n    main()\n'"
tests/__init__.py,0,b''
tests/test_fnameutil.py,0,"b'from __future__ import print_function\nimport sys, os\nTEST_DIR = os.path.dirname(os.path.abspath(__file__))\nPROJECT_DIR = os.path.abspath(os.path.join(TEST_DIR, os.pardir))\nsys.path.insert(0, PROJECT_DIR)\n\nimport unittest\nfrom oommftools import fnameutil\nclass Test_fnameutil(unittest.TestCase):\n    def test_filterOnExtensions(self):\n        \'\'\'\n        Test filteronExtensions functionality.\n        \'\'\'\n        test_output = fnameutil.filterOnExtensions([""ohf"", ""omf""],[""test_omf.omf"", ""test_ohf.ohf"", ""test_txt.txt""])\n        print(test_output)\n        self.assertEqual(test_output, [""test_omf.omf"", ""test_ohf.ohf""])'"
tests/test_odtchomp.py,15,"b'from __future__ import print_function\nfrom future import standard_library\nstandard_library.install_aliases()\nfrom builtins import str\nimport sys, os\nimport io\nimport tempfile\nTEST_DIR = os.path.dirname(os.path.abspath(__file__))\nPROJECT_DIR = os.path.abspath(os.path.join(TEST_DIR, os.pardir))\nsys.path.insert(0, PROJECT_DIR)\n\nimport unittest\nfrom oommftools.core import odtchomp\nimport numpy as np\nclass Test_headers_prettify(unittest.TestCase):\n    def test_headers_prettify(self):\n        \'\'\'\n        Test headers_prettify\n        key of dictionary made up of evolver, givenName, quantity\n        \'\'\'\n        test_dict = {\'key1:part1:part2\': \'Zed\', \'key2:part1:part2\': 39, \'key3:part1:part2\': 9}\n\n        test_output = odtchomp.headers_prettify(test_dict)\n        print(test_output)\n        self.assertEqual(test_output, {\'key1 part1 part2\': \'Zed\', \'key2 part1 part2\': 39, \'key3 part1 part2\': 9})\n\n    def test_headers_prettify_key_collision(self):\n        \'\'\'\n        There is something there about key collisions.\n        At the moment all it does is log the fact that a \'key collision\' has\n        happened.\n        \'\'\'\n        pass\n\nclass Test_list_prettify(unittest.TestCase):\n    def test_list_prettify(self):\n        \'\'\'\n        Test headers_prettify\n        key of dictionary made up of evolver, givenName, quantity\n        \'\'\'\n        test_list = [\'key1:part1:part2\', \'key2:part1:part2\', \'key3:part1:part2\']\n\n        test_output = odtchomp.list_prettify(test_list)\n        print(test_output)\n        self.assertEqual(test_output, [\'key1 part1 part2\', \'key2 part1 part2\', \'key3 part1 part2\'])\n\n\n\nclass Test_namepolish(unittest.TestCase):\n    \'\'\'\n    \n    \'\'\'\n    def test1_quantity(self):\n        \'\'\'\n        Name polish is called by headers_prettify.\n        \'\'\'\n        name = \'evolver:givenName:quantity\'\n        uniquenessCheck = [[\'evolver\', \'givenName\', \'quantity\'], [\'evolver\', \'givenName\', \'quantity2\']]\n        new_name = odtchomp.namepolish(name, uniquenessCheck)\n        self.assertEqual(new_name, \'quantity\')\n\n    def test2_givenName_quantity(self):\n        \'\'\'\n        Name polish is called by headers_prettify.\n        \'\'\'\n        name = \'evolver:givenName:quantity\'\n        uniquenessCheck = [[\'evolver\', \'givenName\', \'quantity\'], [\'evolver\', \'givenName2\', \'quantity\']]\n        new_name = odtchomp.namepolish(name, uniquenessCheck)\n        self.assertEqual(new_name, \'givenName quantity\')\n\n    def test3_evolver_givenName_quantity(self):\n        \'\'\'\n        Name polish is called by headers_prettify.\n        \'\'\'\n        name = \'evolver:givenName:quantity\'\n        uniquenessCheck = [[\'evolver\', \'givenName\', \'quantity\'], [\'evolver2\', \'givenName\', \'quantity\']]\n        new_name = odtchomp.namepolish(name, uniquenessCheck)\n        self.assertEqual(new_name, \'evolver givenName quantity\')\n\n    def test4_givenName_evolver_quantity(self):\n        \'\'\'\n        Name polish is called by headers_prettify.\n        \'\'\'\n        odtchomp.PROTECTED_NAMES = [""evolver_prot""]\n        name = \'evolver_prot:givenName:quantity\'\n        uniquenessCheck = [[\'evolver_prot\', \'givenName\', \'quantity\'], [\'evolver2\', \'givenName\', \'quantity\']]\n        new_name = odtchomp.namepolish(name, uniquenessCheck)\n        self.assertEqual(new_name, \'givenName evolver_prot quantity\')\n\n    def test5_givenName_evolver_quantity(self):\n        \'\'\'\n        Name polish is called by headers_prettify.\n        \'\'\'\n        odtchomp.PROTECTED_NAMES = [""evolver_prot""]\n        name = \'evolver_prot:givenName:quantity\'\n        uniquenessCheck = [[\'evolver_prot\', \'givenName\', \'quantity\'], [\'evolver2\', \'givenName2\', \'quantity\']]\n        new_name = odtchomp.namepolish(name, uniquenessCheck)\n        self.assertEqual(new_name, \'givenName evolver_prot quantity\')\n\n    def test6_evolver_quantity(self):\n        \'\'\'\n        Name polish is called by headers_prettify.\n        \'\'\'\n        name = \'evolver::quantity\'\n        uniquenessCheck = [[\'evolver\', \'\',\'quantity\'], [\'evolver\', \'\', \'quantity\']]\n        new_name = odtchomp.namepolish(name, uniquenessCheck)\n        self.assertEqual(new_name, \'evolver quantity\')\n\n    def test_remove_evolver_prefix(self):\n        \'\'\'\n        Name polish is called by headers_prettify.\n        \'\'\'\n        name = \'Oxs_evolver::quantity\'\n        uniquenessCheck = [[\'Oxs_evolver\', \'\',\'quantity\'], [\'Oxs_evolver\', \'\', \'quantity\']]\n        new_name = odtchomp.namepolish(name, uniquenessCheck)\n        self.assertEqual(new_name, \'evolver quantity\')\n        \nclass Test_filterOnPos(unittest.TestCase):\n    \'\'\'\n    Returns list if a string is found in a particular position in that list.\n    \'\'\'\n    def test_filterOnPos_item_in_two_sublists(self):\n        \'\'\'\n        \'\'\'\n        inList = [[\'item1\', \'item2\', \'item3\'], [\'item1\', \'item5\', \'item6\']]\n        item = \'item1\'\n        dex = 0\n        ret = odtchomp._filterOnPos(inList, item, dex)\n        print(len(ret))\n        # If the length of \'ret\' is more than 1, it means that there is a \n        # duplicate of the target item in the indicated position.\n        # It seems to be called \'filter on pos\' as it returns lists only\n        # if the target value is found in the position specified within\n        # the lists supplied.\n        self.assertEqual(ret, [[\'item1\', \'item2\', \'item3\'], [\'item1\', \'item5\', \'item6\']])\n        \n    def test_filterOnPos_item_in_one_of_two_sublists(self):\n        \'\'\'\n        Target item found in specified position in one of the input lists.\n        \'\'\'\n        inList = [[\'item1\', \'item2\', \'item3\'], [\'item4\', \'item5\', \'item6\']]\n        item = \'item1\'\n        dex = 0\n        ret = odtchomp._filterOnPos(inList, item, dex)\n        self.assertEqual(ret, [[\'item1\', \'item2\', \'item3\']])\n        \n    def test_filterOnPos_item_in_wrong_position(self):\n        \'\'\'\n        \'\'\'\n        inList = [[\'item1\', \'item2\', \'item3\'], [\'item4\', \'item5\', \'item6\']]\n        item = \'item1\'\n        dex = 1\n        ret = odtchomp._filterOnPos(inList, item, dex)\n        self.assertEqual(ret, [])\n\n    def test_filterOnPos_empty_lists(self):\n        \'\'\'\n        Needs to fail nicely when given empty lists\n        \'\'\'\n        pass\n        \nclass Test_prefix_punt(unittest.TestCase):\n    def test_prefix_punt_no_element(self):\n        data = ""Oxs_""\n        prefix = odtchomp.prefix_punt(data)\n        self.assertEqual(prefix, """")\n        \n    def test_prefix_punt_an_element(self):\n        data = ""Oxs_prefix""\n        prefix = odtchomp.prefix_punt(data)\n        self.assertEqual(prefix, ""prefix"")\n        \nclass Test_Interpreter(unittest.TestCase):\n        """"""\n        """"""\n        \n        def setUp(self):\n            self.interpreter = odtchomp.Interpreter({\'key1 part1 part2\': \'Zed\', \'key2 part1 part2\': 39, \'key3 part1 part2\': 9}, [\'key1 part1 part2\', \'key2 part1 part2\', \'key3 part1 part2\'])\n        \n           \n        def test_getNames(self):\n            keys = self.interpreter.getNames()\n            self.assertEqual(keys, [\'key1 part1 part2\', \'key2 part1 part2\', \'key3 part1 part2\'])\n        \n        def test_getData(self):\n            data = self.interpreter.getData()\n            self.assertEqual(data, {\'key1 part1 part2\': \'Zed\', \'key2 part1 part2\': 39, \'key3 part1 part2\': 9})\n            \n        def test_getDataLength(self):\n            dataLength = self.interpreter.getDataLength()\n            self.assertEqual(dataLength, 3)\n            \n        def test_mismatched_keys_and_dict(self):\n            # It seems like Interpreter assumes that keys and dict are \'matched\'\n            # as they are in the above tests. It may be possible for them to\n            # not be matched, and it would be good to test for behaviour in that\n            # case.\n            pass\n            \n        def test_values_as_list(self):\n            # This is how the data is stored for real.\n            pass\n            \nclass Test_chomp(unittest.TestCase):\n    """"""\n    """"""\n\n    def setUp(self):\n        with tempfile.NamedTemporaryFile(delete=False) as self.temp:\n            # odt output file from /local_tests/2dpbc_film.odt\n            self.temp.write(\'# ODT 1.0\\n# Table Start\\n# Title: mmArchive Data Table, Thu Dec 15 01:13:45 EST 2011\\n# Columns: {Oxs_EulerEvolve::Total energy} {Oxs_EulerEvolve::Energy calc count} {Oxs_EulerEvolve::Max dm/dt} Oxs_EulerEvolve::dE/dt {Oxs_EulerEvolve::Delta E} PBC_Exchange_2D::Energy PBC_Demag_2D::Energy Oxs_TimeDriver::Iteration {Oxs_TimeDriver::Stage iteration} Oxs_TimeDriver::Stage Oxs_TimeDriver::mx   Oxs_TimeDriver::my   Oxs_TimeDriver::mz   {Oxs_TimeDriver::Last time step} {Oxs_TimeDriver::Simulation time}\\n# Units:                  J                                 {}                             deg/ns                     J/s                       J                         J                     J                      {}                            {}                          {}                   {}                   {}                   {}                          s                                 s                \\n                 0                                  1                                0                         0                        0                        0                      0                      0                             0                           0                     1                    0                    0                          0                                0                         \\n# Table End\\n\'.encode())\n            self.temp.flush()\n\n        with tempfile.NamedTemporaryFile(delete=False) as self.temp_multiline:\n            # odt output file from /local_tests/cgtest_qdemag.odt\n            self.temp_multiline.write(""# ODT 1.0\\n# Table Start\\n# Title: mmArchive Data Table, Wed Aug 17 23:55:57 EDT 2011\\n# Columns: {Oxs_CGEvolve::Max mxHxm} {Oxs_CGEvolve::Total energy} {Oxs_CGEvolve::Delta E} {Oxs_CGEvolve::Bracket count} {Oxs_CGEvolve::Line min count} {Oxs_CGEvolve::Conjugate cycle count} {Oxs_CGEvolve::Cycle count} {Oxs_CGEvolve::Cycle sub count} {Oxs_CGEvolve::Energy calc count} Oxs_UniformExchange::Energy {Oxs_UniformExchange::Max Spin Ang} {Oxs_UniformExchange::Stage Max Spin Ang} {Oxs_UniformExchange::Run Max Spin Ang} Oxs_UZeeman::Energy  Oxs_UZeeman::B       Oxs_UZeeman::Bx      Oxs_UZeeman::By      Oxs_UZeeman::Bz      Oxs_QDemag::Energy   Oxs_MinDriver::Iteration {Oxs_MinDriver::Stage iteration} Oxs_MinDriver::Stage Oxs_MinDriver::mx    Oxs_MinDriver::my    Oxs_MinDriver::mz   \\n# Units:              A/m                         J                          J                         {}                             {}                                {}                               {}                            {}                               {}                              J                              deg                                    deg                                      deg                            J                 mT                   mT                   mT                   mT                     J                       {}                           {}                         {}                 {}                   {}                   {}           \\n              1746207.4553428555          3.217924418664379e-16       3.217924418664379e-16        0                              0                                 1                                1                             1                                1                              1.5600000000000002e-16             90                                     90                                       90                             0                    0                    0                    0                    0                    1.6579244186643904e-16    0                            0                          0                    0                    0                    0.093333333333333338\\n              1744975.7833005877          3.215582194547401e-16      -2.3422241169780424e-19        1                              0                                 1                                1                             1                                2                              1.557651828520484e-16             89.922852335181432                     90                                       90                             0                    0                    0                    0                    0                    1.6579303660269022e-16    1                            1                          0                   -1.531614341527327e-22  3.0681904819276596e-18  0.093339189685331531\\n              1736217.8420609126          3.199236505077561e-16      -1.6345689469839961e-18        2                              0                                 1                                1                             1                                3                              1.541270134531275e-16             89.382653405546762                     90                                       90                             0                    0                    0                    0                    0                    1.657966370546301e-16    2                            2                          0                   -2.5491115391357905e-21  1.4513110121091206e-18  0.093379696220933367\\n              1736798.4776375247          3.1992382281547448e-16       1.723077183773465e-22        2                              0                                 2                                2                             2                                4                              1.541270134531275e-16             89.382653405546762                     89.382653405546762                       90                             2.350988701644575e-38  25                   25                   0                    0                    1.6579680936234491e-16    3                            0                          1                   -2.5491115391357905e-21  1.4513110121091206e-18  0.093379696220933367\\n              1735542.5302981746          3.19690540828253e-16      -2.3328198722148531e-19        3                              0                                 2                                2                             0                                5                              1.5389400794809783e-16             89.305549519311413                     89.382653405546762                       90                            -7.1971516238468971e-22  25                   25                   0                    0                    1.657972525953178e-16    4                            1                          1                    9.9960439220095185e-06 -1.1641532182693482e-19  0.093385435223110741\\n              1726615.2345995705          3.1806259169067142e-16      -1.6279491375815754e-18        4                              0                                 2                                2                             0                                6                              1.5226855960236189e-16             88.765671856133352                     89.382653405546762                       90                            -5.7577146745565936e-21  25                   25                   0                    0                    1.6579978980298341e-16    5                            2                          1                    7.9968259368841892e-05 -2.276566293504503e-19  0.093425117917793343\\n              1727456.1584240147          3.1805700692414893e-16      -5.5847665224947569e-21        4                              0                                 3                                3                             1                                7                              1.5226855960236189e-16             88.765671856133352                     88.765671856133352                       90                            -1.1515429349113187e-20  50                   50                   0                    0                    1.6579996275113541e-16    6                            0                          2                    7.9968259368841892e-05 -2.276566293504503e-19  0.093425117917793343\\n              1726177.0394015557          3.178232423469609e-16      -2.3376457718802646e-19        5                              0                                 3                                3                             0                                8                              1.5203740114081541e-16             88.688628007966074                     88.765671856133352                       90                            -1.4410330576843686e-20  50                   50                   0                    0                    1.6580025153672314e-16    7                            1                          2                    0.00010007174011696985  2.3800465795728893e-19  0.09343073591332593\\n              1717088.1918065522          3.1619194720246485e-16      -1.6312951444960488e-18        6                              0                                 3                                3                             0                                9                              1.5042491867273622e-16             88.14918477645486                      88.765671856133352                       90                            -3.4674600281125716e-20  50                   50                   0                    0                    1.658017031300097e-16    8                            2                          2                    0.00024079583528559552 -6.3381675216886729e-19  0.093469568768023481\\n# Table End"".encode())\n            self.temp_multiline.flush()\n\n\n    def test_chomp_headers(self):\n        chomper = odtchomp.chomp(self.temp.name)\n        test_output = [\'Total energy\', \'Energy calc count\', \'Max dm/dt\', \'dE/dt\', \'Delta E\', \'PBC_Exchange_2D Energy\', \'PBC_Demag_2D Energy\', \'Iteration\', \'Stage iteration\', \'Stage\', \'mx\', \'my\', \'mz\', \'Last time step\', \'Simulation time\']\n        self.assertEqual(chomper.getNames(), test_output)\n\n    def test_chomp_data(self):\n        #chomper = odtchomp.chomp(f.name)\n        chomper = odtchomp.chomp(self.temp.name)\n        test_output = {\'Delta E\': np.array([ 0.]), \n                        \'Energy calc count\': np.array([ 1.]), \n                        \'Stage iteration\': np.array([ 0.]),\n                        \'Simulation time\': np.array([ 0.]), \n                        \'Iteration\': np.array([ 0.]), \n                        \'Last time step\': np.array([ 0.]), \n                        \'PBC_Demag_2D Energy\': np.array([ 0.]), \n                        \'PBC_Exchange_2D Energy\': np.array([ 0.]), \n                        \'Max dm/dt\': np.array([ 0.]), \n                        \'dE/dt\': np.array([ 0.]), \n                        \'Stage\': np.array([ 0.]), \n                        \'my\': np.array([ 0.]), \n                        \'mx\': np.array([ 1.]), \n                        \'Total energy\': np.array([ 0.]), \n                        \'mz\': np.array([ 0.])}\n        self.assertDictEqual(chomper.getData(), test_output)\n\n    def test_chomp_length_data(self):\n        chomper = odtchomp.chomp(self.temp.name)\n        test_output = ""1""\n        self.assertEqual(str(chomper.getDataLength()), test_output)\n\n    def test_chomp_length_data_multiline(self):\n        chomper = odtchomp.chomp(self.temp_multiline.name)\n        test_output = ""9""\n        self.assertEqual(str(chomper.getDataLength()), test_output)\n\n    def test_chomp_absolute_path(self):\n        """"""\n        There seemed to be a problem with loading files from abolute path\n        """"""\n        pass\n        \n    def test_chomp_with_parent(self):\n        """"""\n        There is the capability to load in from wx widget\n        """"""\n        pass\n        \nclass Test_log(unittest.TestCase):\n    """"""\n    log(str) is just a simple print function at the moment.\n    It could potentially be exented to more complete logging outputs, so I want\n    to put in some initial tests.\n    """"""\n    def test_print_to_console(self):\n        capturedOutput = io.StringIO()          # Create StringIO object\n        sys.stdout = capturedOutput                   #  and redirect stdout.\n        odtchomp.log(\'test\')                          # Call unchanged function.\n        self.assertEqual(capturedOutput.getvalue(), \'test\\n\')\n        sys.stdout = sys.__stdout__                   # Reset redirect.\n        \nclass Test_write(unittest.TestCase):\n    """"""\n    File IO etc.\n    """"""\n    def setUp(self):\n        self.interpreter = odtchomp.Interpreter({\'key1 part1 part2\': [1,2,3], \'key2 part1 part2\': [4,5,6], \'key3 part1 part2\': [7,8,9]}, [\'key1 part1 part2\', \'key2 part1 part2\', \'key3 part1 part2\'])\n    \n    \n    def test_write_print_to_screen(self):\n        pass\n    \n    def test_write_cleanup(self):\n        pass\n    \n    def test_write_log(self):\n        pass\n        \n    def test_write_outfile(self):\n        """"""\n        Not sure if this is dropping a line from the end...\n        """"""\n        outfile = tempfile.mkstemp()[1]\n        # NOTE: Alternatively, for Python 2.6+, you can use\n        # tempfile.SpooledTemporaryFile, e.g.,\n        #outfile = tempfile.SpooledTemporaryFile(10 ** 9)\n        odtchomp.write(outfile, self.interpreter, "","", [""key1 part1 part2"", ""key2 part1 part2"", ""key3 part1 part2""])\n        with open(outfile) as f:\n            content = f.read()\n        self.assertEqual(content, ""key1 part1 part2, key2 part1 part2, key3 part1 part2\\n1, 4, 7\\n2, 5, 8\\n"")\n        \nclass Test_resolve(unittest.TestCase):\n    """"""\n    """"""\n    def test_resolve_single_key(self):\n        out = odtchomp.resolve({""key"": ""value""}, [""key""])\n        self.assertEqual(out, [""value""])\n        \n    def test_resolve_two_keys(self):\n        out = odtchomp.resolve({""key1"": ""value1"", ""key2"": ""value2""}, [""key1"", ""key2""])\n        self.assertEqual(out, [""value1"", ""value2""])\n        \nclass Test_split_densify(unittest.TestCase):\n    """"""\n    """"""\n    def test_split_densify_default_delim(self):\n        rets = odtchomp.split_densify(""word1 word2 word3"")\n        self.assertEqual(rets, [""word1"", ""word2"", ""word3""])\n\n    def test_split_densify_extra_whitespace(self):\n        rets = odtchomp.split_densify(""word1\\t word2  word3"")\n        self.assertEqual(rets, [""word1"", ""word2"", ""word3""])\n        \n    def test_split_densify_tab_delim(self):\n        rets = odtchomp.split_densify(""word1\\tword2\\tword3"", ""\\t"")\n        self.assertEqual(rets, [""word1"", ""word2"", ""word3""])        '"
tests/test_oommfconvert.py,0,"b'from future import standard_library\nstandard_library.install_aliases()\nimport sys\nimport os\nimport io\nimport tempfile\nTEST_DIR = os.path.dirname(os.path.abspath(__file__))\nPROJECT_DIR = os.path.abspath(os.path.join(TEST_DIR, os.pardir))\nsys.path.insert(0, PROJECT_DIR)\n\nimport unittest\nfrom oommftools.core import oommfconvert as oommfconvert\n\n\nclass Test_getOOMMFPath(unittest.TestCase):\n    def setUp(self):\n        with tempfile.NamedTemporaryFile(delete=False, suffix=\'.tcl\') as self.tcl_path:\n            # Create dummy oommf.path file\n            self.tcl_path.write(\'tcl file\'.encode())\n            self.tcl_path.flush()\n\n        with tempfile.NamedTemporaryFile(delete=False) as self.valid_file:\n            # Create dummy oommf.path file\n            self.valid_file.write(self.tcl_path.name.encode())\n            self.valid_file.flush()\n\n        with tempfile.NamedTemporaryFile(delete=False) as self.invalid_path:\n            # Create dummy oommf.path file\n            self.invalid_path.write(r\'C:\\oommf-1.2a5bis\'.encode())\n            self.invalid_path.flush()\n\n    def test_valid_path(self):\n        path = oommfconvert.getOOMMFPath(self.valid_file.name)\n        self.assertEqual(path, self.tcl_path.name)\n\n    def test_invalid_path(self):\n        path = oommfconvert.getOOMMFPath(self.invalid_path.name)\n        self.assertEqual(path, None)\n\n    def test_no_file_found(self):\n        path = oommfconvert.getOOMMFPath(\'bad/path\')\n        self.assertEqual(path, None)\n\n\nclass Test_OOMMFConvert(unittest.TestCase):\n    def test_doImages(self):\n        pass\n\n    def test_resolveConfiguration(self):\n        pass\n\n    def test_spliceConfig(self):\n        pass\n\n    def test_doMovies(self):\n        pass\n\n\nclass Test_replaceConfigLines(unittest.TestCase):\n    def test_basic_operation(self):\n        oldConfigLines = [\'line1\', \'\\n\', \'line2\']\n        newMax = 10\n        percentMagnitude = 90\n        checkVectors = True\n        newConfig = oommfconvert.replaceConfigLines(oldConfigLines,\n                                                    newMax,\n                                                    percentMagnitude,\n                                                    checkVectors)\n        self.assertEqual(newConfig, oldConfigLines)\n\n    def test_misc_datascale(self):\n        oldConfigLines = [\'misc,datascale 10\\n\', \'\\n\', \'line2\\n\']\n        newMax = 10\n        percentMagnitude = 90\n        checkVectors = True\n        newConfig = oommfconvert.replaceConfigLines(oldConfigLines,\n                                                    newMax,\n                                                    percentMagnitude,\n                                                    checkVectors)\n        expectedNewline = \'    misc,datascale 10\\n\'\n        self.assertEqual(newConfig, [expectedNewline,  \'\\n\', \'line2\\n\'])\n\n    def test_misc_datascale_check_vectors_false(self):\n        oldConfigLines = [\'misc,datascale 10\\n\', \'\\n\', \'line2\\n\']\n        newMax = 10\n        percentMagnitude = 90\n        checkVectors = False\n        newConfig = oommfconvert.replaceConfigLines(oldConfigLines,\n                                                    newMax,\n                                                    percentMagnitude,\n                                                    checkVectors)\n        expectedNewline = \'misc,datascale 10\\n\'\n        self.assertEqual(newConfig, [expectedNewline,  \'\\n\', \'line2\\n\'])\n\n    def test_misc_datascale_clobber_zoom(self):\n        oldConfigLines = [\'misc,zoom 10\\n\', \'\\n\', \'line2\\n\']\n        newMax = 10\n        percentMagnitude = 90\n        checkVectors = False\n        newConfig = oommfconvert.replaceConfigLines(oldConfigLines,\n                                                    newMax,\n                                                    percentMagnitude,\n                                                    checkVectors)\n        expectedNewline = ""    misc,zoom 0\\n""\n        self.assertEqual(newConfig, [expectedNewline,  \'\\n\', \'line2\\n\'])\n\n    def test_misc_datascale_misc_height(self):\n        oldConfigLines = [\'misc,height 20\\n\', \'\\n\', \'line2\\n\']\n        newMax = 10\n        percentMagnitude = 90\n        checkVectors = False\n        newConfig = oommfconvert.replaceConfigLines(oldConfigLines,\n                                                    newMax,\n                                                    percentMagnitude,\n                                                    checkVectors)\n        expectedNewline = ""    misc,height 18.0\\n""\n        self.assertEqual(newConfig, [expectedNewline,  \'\\n\', \'line2\\n\'])\n\n    def test_misc_datascale_misc_width(self):\n        oldConfigLines = [\'misc,width 80\\n\', \'\\n\', \'line2\\n\']\n        newMax = 10\n        percentMagnitude = 90\n        checkVectors = False\n        newConfig = oommfconvert.replaceConfigLines(oldConfigLines,\n                                                    newMax,\n                                                    percentMagnitude,\n                                                    checkVectors)\n        expectedNewline = ""    misc,width 72.0\\n""\n        self.assertEqual(newConfig, [expectedNewline,  \'\\n\', \'line2\\n\'])\n\n    def test_misc_datascale_with_comment(self):\n        oldConfigLines = [\'#with comment\\n\',\n                          \'misc,width 80\\n\', \'\\n\', \'line2\\n\']\n        newMax = 10\n        percentMagnitude = 90\n        checkVectors = False\n        newConfig = oommfconvert.replaceConfigLines(oldConfigLines,\n                                                    newMax,\n                                                    percentMagnitude,\n                                                    checkVectors)\n        expectedNewline = ""    misc,width 72.0\\n""\n        self.assertEqual(\n            newConfig, [\'#with comment\\n\', expectedNewline,  \'\\n\', \'line2\\n\'])\n\n    def test_misc_datascale_with_braces(self):\n        oldConfigLines = [\'{\\n\', \'misc,width 80\\n\', \'\\n\', \'}\', \'line2\\n\']\n        newMax = 10\n        percentMagnitude = 90\n        checkVectors = False\n        newConfig = oommfconvert.replaceConfigLines(oldConfigLines,\n                                                    newMax,\n                                                    percentMagnitude,\n                                                    checkVectors)\n        expectedNewline = ""    misc,width 72.0\\n""\n        self.assertEqual(\n            newConfig, [\'{\\n\', expectedNewline,  \'\\n\', \'}\', \'line2\\n\'])\n'"
tests/test_oommfdecode.py,26,"b'from future import standard_library\nstandard_library.install_aliases()\nimport sys, os\nimport io\nimport tempfile\n\nTEST_DIR = os.path.dirname(os.path.abspath(__file__))\nPROJECT_DIR = os.path.abspath(os.path.join(TEST_DIR, os.pardir))\nsys.path.insert(0, PROJECT_DIR)\n\nimport unittest\nfrom oommftools.fnameutil import filterOnExtensions\nimport scipy.io as spio\nimport pickle as pickle\nimport struct\nimport numpy as np\nimport oommftools.core.oommfdecode as oommfdecode\n\n\nclass Test_oommfdecode_text(unittest.TestCase):\n    def setUp(self):\n        self.test_files_folder = \'testfiles\'\n        self.vector_file_text = os.path.join(TEST_DIR, \n                                        self.test_files_folder,\n                                        \'dw_edgefield_cut_cell4_160.ohf\')\n        self.headers_test = {\'ystepsize\': 4e-09, \'xnodes\': 1250.0, \'valuemultiplier\': 258967.81743932367, \'xbase\': 2e-09, \'zstepsize\': 8e-09, \'znodes\': 1.0, \'zbase\': 4e-09, \'ynodes\': 40.0, \'ybase\': 2e-09, \'xstepsize\': 4e-09}\n        self.extraCaptures_test =  {\'MIFSource\': \'C:/programs/oommf_old/simus/DW-150-8-transverse/DW_edgefield/dw_edgefield.mif\', \'Iteration\': 0.0, \'SimTime\': 0.0, \'Stage\': 0.0}\n        self.vector_file_binary = os.path.join(TEST_DIR, \n                                        self.test_files_folder,\n                                        \'h2h_leftedge_40x4.ohf\')\n\n        self.targetarray_pickle = os.path.join(TEST_DIR, \n                                        self.test_files_folder,\n                                        \'targetarray_text.npy\')\n    def test_unpackFile_text_targetarray(self):\n        (targetarray, headers, extraCaptures) = oommfdecode.unpackFile(self.vector_file_text)\n        #np.save(self.targetarray_pickle, targetarray)\n        np.testing.assert_array_equal(targetarray, np.load(self.targetarray_pickle))\n        \n    def test_unpackFile_text_headers(self):\n        (targetarray, headers, extraCaptures) = oommfdecode.unpackFile(self.vector_file_text)\n        self.assertEqual(headers, self.headers_test)\n\n    def test_unpackFile_headers_keys(self):\n        (targetarray, headers, extraCaptures) = oommfdecode.unpackFile(self.vector_file_text)\n        self.assertEqual(list(headers.keys()).sort(), list(self.headers_test.keys()).sort())\n        \n    def test_unpackFile_text_extracaptures(self):\n        (targetarray, headers, extraCaptures) = oommfdecode.unpackFile(self.vector_file_text)\n        self.assertEqual(extraCaptures, self.extraCaptures_test)\n\nclass Test_oommfdecode_binary(unittest.TestCase):\n    def setUp(self):\n        self.test_files_folder = \'testfiles\'\n        self.vector_file_binary = os.path.join(TEST_DIR, \n                                        self.test_files_folder,\n                                        \'h2h_leftedge_40x4.ohf\')\n        self.headers_test = {\'ystepsize\': 1e-08, \'xnodes\': 160.0, \'valuemultiplier\': 1.0, \'xbase\': 5e-09, \'zstepsize\': 1e-08, \'znodes\': 4.0, \'zbase\': 5e-09, \'ynodes\': 40.0, \'ybase\': 5e-09, \'xstepsize\': 1e-08}\n        \n        self.extraCaptures_test =  {\'MIFSource\': \'/local/home/donahue/oommf/app/oxs/examples/h2h_edgefield.mif\', \'Iteration\': 0.0, \'SimTime\': 0.0, \'Stage\': 0.0}\n                                        \n        self.targetarray_pickle = os.path.join(TEST_DIR, \n                                        self.test_files_folder,\n                                        \'targetarray_binary.npy\')                                        \n    def test_unpackFile_binary_targetarray(self):\n        (targetarray, headers, extraCaptures) = oommfdecode.unpackFile(self.vector_file_binary)\n        #np.save(self.targetarray_pickle, targetarray)\n        np.testing.assert_array_equal(targetarray, np.load(self.targetarray_pickle))\n        \n    def test_unpackFile_binary_headers(self):\n        (targetarray, headers, extraCaptures) = oommfdecode.unpackFile(self.vector_file_binary)\n        self.assertEqual(headers, self.headers_test)\n        \n    def test_unpackFile_binary_extraCaptures(self):\n        (targetarray, headers, extraCaptures) = oommfdecode.unpackFile(self.vector_file_binary)\n        self.assertEqual(extraCaptures, self.extraCaptures_test)\n        \n        \nclass Test_pickleArray(unittest.TestCase):\n    def setUp(self):\n        self.array = np.array([1., 2., 3.])\n        self.headers = {\'Name\': \'Headers\', \'Value\': 1}\n        self.extraCaptures = {\'Capture1\': 1, \'Capture2\': \'two\'}\n        self.filename = os.path.join(tempfile.gettempdir(),\n                                        \'test.npy\')\n        \n    def test_pickle_array(self):\n        oommfdecode.pickleArray(self.array, self.headers, self.extraCaptures, self.filename)\n        with open(self.filename, ""rb"") as input_file:\n            e = pickle.load(input_file)\n        np.testing.assert_array_equal(e[0], np.array([1., 2., 3.]))\n        self.assertEqual(e[1], dict(list(self.headers.items()) + list(self.extraCaptures.items())))\n \nclass Test_matlabifyArray(unittest.TestCase):\n    def setUp(self):\n        self.array = np.array([1., 2., 3.])\n        self.headers = {\'xstepsize\': 1, \'ystepsize\': 2, \'zstepsize\': 3}\n        self.extraCaptures = {\'Capture1\': 1, \'Capture2\': \'two\'}\n        self.filename = os.path.join(tempfile.gettempdir(),\n                                        \'test.mat\')\n        \n    def test_matlabify_array(self):\n        oommfdecode.matlabifyArray(self.array, self.headers, self.extraCaptures, self.filename)\n        e = spio.loadmat(self.filename)\n        np.testing.assert_array_equal(e[\'OOMMFData\'], np.array([[1., 2., 3.]]))\n        self.assertEqual(e[\'Capture2\'], np.array([\'two\']))\n        self.assertEqual(e[\'Capture1\'], np.array([[1]]))\n        np.testing.assert_array_equal(e[\'GridSize\'], np.array([[1., 2., 3.]]))\n        \nclass Test_textDecode(unittest.TestCase):\n    def setUp(self):\n        to_write = u\'-0.80  0.52  0.00\\n-0.35  0.27  0.00\\n-0.21  0.17  0.00\'\n        self.output = io.StringIO(to_write)\n        self.outArray = np.zeros((3, 3, 3, 3))\n        self.headers = {\'xnodes\': 1.0, \'znodes\': 1.0, \'ynodes\'                   : 3.0, \'valuemultiplier\': 2}\n        self.extraCaptures = {\'a\': 1, \'b\': 2, \'c\': 3}\n        self.test_array = np.array([[[[-1.6 ,  1.04,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[-0.7 ,  0.54,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[-0.42,  0.34,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]]],\n\n\n                                   [[[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]]],\n\n\n                                   [[[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]]]])\n    def test_textDecode(self):\n        (targetarray, headers, extraCaptures) = oommfdecode._textDecode(self.output, self.outArray, self.headers, self.extraCaptures)\n        #self.assertEqual(targetarray.all(), np.array(1))\n        np.testing.assert_array_equal(targetarray, self.test_array)\n\nclass Test_binaryDecode(unittest.TestCase):\n    def setUp(self):\n        self.outArray = np.zeros((3, 3, 3, 3))\n        self.headers = {\'xnodes\': 3.0,\n                        \'znodes\': 3.0,    \n                        \'ynodes\' : 3.0, \n                        \'valuemultiplier\': 2}\n        self.extraCaptures = {\'a\': 1, \'b\': 2, \'c\': 3}\n        self.chunksize_4 = 4\n        self.chunksize_8 = 8\n        self.test_array = np.array([[[[-1.6 ,  1.04,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ]],\n\n                                [[-0.7 ,  0.54,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ]],\n\n                                [[-0.42,  0.34,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ]]],\n\n\n                               [[[ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ]],\n\n                                [[ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ]],\n\n                                [[ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ]]],\n\n\n                               [[[ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ]],\n\n                                [[ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ]],\n\n                                [[ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ],\n                                 [ 0.  ,  0.  ,  0.  ]]]])\n        self.output_little = io.BytesIO(struct.pack(\'<%sf\' % self.test_array.size, *self.test_array.flatten(\'C\')))\n        self.output_little_8 = io.BytesIO(struct.pack(\'<%sd\' % self.test_array.size, *self.test_array.flatten(\'C\')))\n        self.output_big = io.BytesIO(struct.pack(\'>%sf\' % self.test_array.size, *self.test_array.flatten(\'C\'))) \n        self.output_big_8 = io.BytesIO(struct.pack(\'>%sd\' % self.test_array.size, *self.test_array.flatten(\'C\')))         \n        \n    def test_binaryDecode_little_4(self):\n        (targetarray, headers, extraCaptures) = oommfdecode._binaryDecode(self.output_little, \n                                  self.chunksize_4, \n                                  struct.Struct(""<f""), \n                                  self.outArray, \n                                  self.headers, \n                                  self.extraCaptures)\n        np.testing.assert_array_almost_equal(targetarray,2.0*self.test_array)\n\n    def test_binaryDecode_little_8(self):\n        (targetarray, headers, extraCaptures) = oommfdecode._binaryDecode(self.output_little_8, \n                                  self.chunksize_8, \n                                  struct.Struct(""<d""), \n                                  self.outArray, \n                                  self.headers, \n                                  self.extraCaptures)\n        np.testing.assert_array_almost_equal(targetarray,2.0*self.test_array)\n        \n    def test_binaryDecode_big_4(self):\n        (targetarray, headers, extraCaptures) = oommfdecode._binaryDecode(self.output_big, \n                                  self.chunksize_4, \n                                  struct.Struct("">f""), \n                                  self.outArray, \n                                  self.headers, \n                                  self.extraCaptures)\n        np.testing.assert_allclose(targetarray,2.0*self.test_array)\n        \n    def test_binaryDecode_big_8(self):\n        output_big_8 = io.BytesIO(struct.pack(\'>%sd\' % self.test_array.size, *self.test_array.flatten(\'C\')))\n        (targetarray, headers, extraCaptures) = oommfdecode._binaryDecode(filehandle=output_big_8, \n                                  chunksize=self.chunksize_8, \n                                  decoder=struct.Struct("">d""), \n                                  targetarray=self.outArray, \n                                  headers=self.headers, \n                                  extraCaptures=self.extraCaptures)\n        np.testing.assert_allclose(targetarray,2.0*self.test_array)        \nclass Test_slowlyPainfullyMaximise(unittest.TestCase):\n    def setUp(self):\n        self.test_files_folder = \'testfiles\'\n        self.vector_file_text = os.path.join(TEST_DIR, \n                                        self.test_files_folder,\n                                        \'dw_edgefield_cut_cell4_160.ohf\')\n\n        self.vector_file_binary = os.path.join(TEST_DIR, \n                                        self.test_files_folder,\n                                        \'h2h_leftedge_40x4.ohf\')\n                                        \n    def test_slowlyPainfullyMaximize_single_file(self):\n        max_mag = oommfdecode.slowlyPainfullyMaximize([self.vector_file_text])\n        np.testing.assert_almost_equal(max_mag, 258967.81743932364)\n        \n    def test_slowlyPainfullyMaximize_multifile(self):\n        max_mag = oommfdecode.slowlyPainfullyMaximize([self.vector_file_text, self.vector_file_binary])\n        np.testing.assert_almost_equal(max_mag, 349370.681891435)\n\n\nclass Test_sortBySimTime(unittest.TestCase):\n\n    def test_sortBySimTime_basic_operation(self):\n        self.arrays = [[1,1,1], [2,2,2]]\n        self.extra = {\'SimTime\': [1, 2], \'MIFSource\': [2], \'c\': [3]}\n        arrays, extra = oommfdecode.sortBySimTime(self.extra, self.arrays)\n        self.assertEqual(arrays, ([1,1,1], [2,2,2]))\n        self.assertEqual(extra, {\'SimTime\': (1, 2), \'MIFSource\': (2,), \'c\': (3,)})\n\n    def test_sortBySimTime_reverse_order(self):\n        self.arrays = [[1,1,1], [2,2,2]]\n        self.extra = {\'SimTime\': [2, 1], \'MIFSource\': [2], \'c\': [3]}\n        arrays, extra = oommfdecode.sortBySimTime(self.extra, self.arrays)\n        self.assertEqual(arrays, ([2,2,2], [1,1,1]))\n        self.assertEqual(extra, {\'SimTime\': (1, 2), \'MIFSource\': (2,), \'c\': (3,)})\n\n    def test_sortBySimTime_no_extra_keys(self):\n        self.arrays = [[1,1,1], [2,2,2]]\n        self.extra = {\'SimTime\': [2, 1], \'MIFSource\': [2]}\n        arrays, extra = oommfdecode.sortBySimTime(self.extra, self.arrays)\n        self.assertEqual(arrays, ([2,2,2], [1,1,1]))\n        self.assertEqual(extra, {\'SimTime\': (1, 2), \'MIFSource\': (2,)})\n\n    def test_sortBySimTime_len_mif_source_not_one(self):\n        self.arrays = ([1,1,1], [2,2,2])\n        self.extra = {\'SimTime\': (2, 1), \'MIFSource\': (1, 2)}\n        arrays, extra = oommfdecode.sortBySimTime(self.extra, self.arrays)\n        self.assertEqual(arrays, ([1,1,1], [2,2,2]))\n        self.assertEqual(extra, {\'SimTime\': (2, 1), \'MIFSource\': (1, 2)})\n\n    def test_sortBySimTime_sim_time_minus_one(self):\n        self.arrays = ([1,1,1], [2,2,2])\n        self.extra = {\'SimTime\': (2, -1), \'MIFSource\': (1, 1)}\n        arrays, extra = oommfdecode.sortBySimTime(self.extra, self.arrays)\n        self.assertEqual(arrays, ([1,1,1], [2,2,2]))\n        self.assertEqual(extra, {\'SimTime\': (2, -1), \'MIFSource\': (1, 1)})\n\n    def test_sortBySimTime_extra_keys(self):\n        self.arrays = ([1,1,1], [2,2,2])\n        self.extra = {\'SimTime\': (2, -1), \n                      \'MIFSource\': (1, 1),\n                      \'Extra1\': (1, 2),\n                      \'Extra2\': (\'1\')}\n        arrays, extra = oommfdecode.sortBySimTime(self.extra, self.arrays)\n        self.assertEqual(arrays, ([1,1,1], [2,2,2]))\n        self.assertEqual(extra, {\'SimTime\': (2, -1), \'MIFSource\': (1, 1), \'Extra1\': (1,2), \'Extra2\':\'1\'})\n\n\n    def test_sortBySimTime_numpy_array(self):        \n        self.test_array = np.array([[[[-1.6 ,  1.04,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[-0.7 ,  0.54,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[-0.42,  0.34,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]]],\n\n\n                                   [[[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]]],\n\n\n                                   [[[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]]]])\n        self.arrays = (self.test_array)\n        self.extra = {\'SimTime\': (2, -1), \n                      \'MIFSource\': (1, 1),\n                      \'Extra1\': (1, 2),\n                      \'Extra2\': (\'1\')}\n        arrays, extra = oommfdecode.sortBySimTime(self.extra, self.arrays)\n        np.testing.assert_array_equal(arrays, self.arrays)\n        self.assertEqual(extra, {\'SimTime\': (2, -1), \'MIFSource\': (1, 1), \'Extra1\': (1,2), \'Extra2\':\'1\'})\n\n\n    def test_sortBySimTime_two_numpy_arrays(self):        \n        self.test_array = np.array([[[[-1.6 ,  1.04,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[-0.7 ,  0.54,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[-0.42,  0.34,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]]],\n\n\n                                   [[[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]]],\n\n\n                                   [[[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]],\n\n                                    [[ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ],\n                                     [ 0.  ,  0.  ,  0.  ]]]])\n        self.arrays = (self.test_array, self.test_array)\n        self.extra = {\'SimTime\': (2, -1), \n                      \'MIFSource\': (1, 1),\n                      \'Extra1\': (1, 2),\n                      \'Extra2\': (\'1\')}\n        arrays, extra = oommfdecode.sortBySimTime(self.extra, self.arrays)\n        self.assertEqual(arrays, self.arrays)\n        self.assertEqual(extra, {\'SimTime\': (2, -1), \'MIFSource\': (1, 1), \'Extra1\': (1,2), \'Extra2\':\'1\'})'"
oommftools/core/__init__.py,0,b'#core'
oommftools/core/odtchomp.py,2,"b'from __future__ import print_function\nfrom __future__ import absolute_import\n\n\nimport numpy as np\n\n########\n# DECS #\n########\n\n#Readability magic below\nALWAYS_CLEAR = [""Oxs_""]\n\nPROTECTED_NAMES = [""Exchange""]\n\ndef write(filename, interpreter, delim, fields):\n    """"""\n    """"""\n    print(""Write out to:"", filename)\n    refdelim = delim\n    f = open(filename, ""w"")\n    #Do keys\n    if delim == "","":\n        delim = "", ""\n    if refdelim == "" "":\n        log(""Space delim override: Deleting spaces from field names."")\n        reffields = []\n        for field in fields:\n            reffields.append(field.replace("" "", ""_""))\n    else:\n        reffields = fields\n\n\n    line = delim.join(reffields) + ""\\n""\n    f.write(line)\n    #Do values\n    i = 0\n    while i < interpreter.getDataLength()-1:\n        line = """"\n        for key in fields:\n            line += str(interpreter.getData()[key][i]) + delim\n        line = line.rstrip(delim)\n        line += ""\\n""\n        f.write(line)\n        i += 1\n\n    #Cleanup\n    f.close()\n\ndef resolve(lst, keys):\n    """"""\n    Return a list of values from a dictionary corresponding to keys provided\n    """"""\n    out = []\n    for key in keys:\n        out.append(lst[key])\n    return out\n\ndef split_densify(a, delim="" ""):\n    """"""\n    """"""\n    rets = []\n    for p in a.split(delim):\n        if p:\n            rets.append(p.strip())\n    return rets\n\n\ndef log(evt):\n    """"""\n    """"""\n    try:\n        evt = unicode(evt)\n    except:\n        evt = str(evt)\n    \n    print(evt)\n\n\ndef chomp(odt, parent=None):\n    """"""\n    """"""\n    retHeaders = []\n    retDict = {}\n    log(""Opening %s"" % odt)\n    f = open(odt, ""r"")\n    data = f.readlines()\n    log(""File length: %d lines."" % len(data))\n    InData = False\n    if parent:\n        parent.progstart(len(data))\n    for i, line in enumerate(data):\n        if parent:\n            parent.progreport(i)\n        line = line.strip()\n        #Look out for multiple table headers in the parse!\n        if line[0] == ""#"":\n            InData = False\n            #Comment or table parse\n            if ""Columns"" in line:\n                log(""Absorbing header data: Identifying coumns."")\n                #Clobber header table\n                retHeaders = []\n                #Begin slow parse\n                line = line.split(""Columns:"")[1].strip()\n                while line:\n                    grab = """"\n                    line = line.strip()\n                    if line[0] == ""{"":\n                        #Group match!\n                        grab, line = line.split(""}"", 1)\n                        line = line.strip() #Must clear trailing spaces\n                        grab = grab.strip(""{}"")\n                        log(""Matching title field by symbol: %s"" % grab)\n                    else:\n                        #Spacesplit match\n                        print(""In spacesplit match:"")\n                        check = line.split("" "", 1)\n                        if len(check) == 1:\n                            grab = check[0]\n                            line = """"\n                        else:\n                            grab, line = check\n                        grab = grab.strip()\n                        log(""Matching title field by space: %s"" % grab)\n                    if grab:\n                        log(""Indexing %s at point %d"" % (grab, len(retHeaders)))\n                        retHeaders.append(grab)\n                        if not grab in retDict:\n                            log(""Identifying new header: %s"" % grab)\n                            retDict[grab] = np.array([])\n            else:\n                pass #Currently do nothing on other header lines\n        else:\n            if not InData:\n                log(""Processing data block."")\n                InData = True\n            #Chew actual data\n            fields = split_densify(line)\n            for i, v in enumerate(fields):\n                fieldname = retHeaders[i]\n                retDict[fieldname] = np.append(retDict[fieldname], float(v))\n    f.close()\n    return Interpreter(headers_prettify(retDict), list_prettify(retHeaders))\n\nclass Interpreter(object):\n    """"""\n    """"""\n    def __init__(self, idict, keys=None):\n        self.keys = keys\n        if not self.keys:\n            self.keys = list(idict.keys())\n\n        self.dict = idict\n\n    def getNames(self):\n        return self.keys\n\n    def getData(self):\n        return self.dict\n\n    def getDataLength(self):\n        return len(self.dict[self.keys[0]])\n\ndef list_prettify(inList):\n    """"""\n    """"""\n    out = []\n    uniquenessCheck = []\n    for key in inList:\n        uniquenessCheck.append(key.split("":""))\n    for key in inList:\n        fixedkey = namepolish(key, uniquenessCheck)\n        if fixedkey in out:\n            log(""Uh-oh, you might have caused a key collision! This should be impossible."")\n        out.append(fixedkey)\n    return out\n\ndef headers_prettify(inDict):\n    """"""\n    """"""\n    outDict = {}\n    uniquenessCheck = []\n    for key in list(inDict.keys()):\n        uniquenessCheck.append(key.split("":""))\n    for key in list(inDict.keys()):\n        fixedkey = namepolish(key, uniquenessCheck)\n        if fixedkey in outDict:\n            log(""Uh-oh, you might have caused a key collision! This should be impossible."")\n        outDict[fixedkey] = inDict[key]\n    return outDict\n\ndef namepolish(name, uniquenessCheck):\n    """"""Uniquely identify quantity fields.\n\n    This is pretty ugly, but the key point is this: it filters\n    down to the minimum amount of information necessary to uniquely identify a quantity\n    It makes things more human-readable\n\n    Parameters\n    ----------\n    name : str\n        One particular \'key\' from header output\n    uniquenessCheck : list[[list]]\n        A list of lists of strings where there are duplicates.\n\n    Returns\n    -------\n    str\n        A string of simplified field headers.\n\n    Examples\n    --------\n    >>> namepolish(\'evolver:givenName:quantity\',\n                    [[\'evolver\', \'givenName\', \'quantity\'],\n                    [\'evolver\', \'givenName\', \'quantity2\']])\n    \'quantity\'\n    """"""\n    evolver, givenName, quantity = name.split("":"")\n\n    protectEvolver = False\n\n    for item in PROTECTED_NAMES:\n        if item in evolver:\n            protectEvolver = True\n\n    #This is pretty ugly, but the key point is this: it filters\n    #down to the minimum amount of information necessary to uniquely identify a quantity\n    #It makes things more human-readable\n    # If the quantity is duplicated\n    if len(_filterOnPos(uniquenessCheck, quantity, 2)) > 1:\n        # If there is a givenName present\n        if givenName:\n            # Take the output from the quantity filter (which we know is > 1 now)\n            # filter this output and check for duplicates of the givenName.\n            if len(_filterOnPos(_filterOnPos(uniquenessCheck, quantity, 2), givenName, 1)) > 1:\n                # Quantity and givenName are both duplicated. We need to keep\n                # the evolver name to distinguish between fields.\n                # If the evolver should be protected, put it second.\n                # It\'s not clear why the evolver should be first or second\n                # position.\n                if protectEvolver:\n                    newname = givenName + "" "" + evolver + "" "" + quantity\n                # if evolver should not be protected, put it first.\n                else:\n                    newname = evolver + "" "" + givenName + "" "" + quantity\n            # There is a given name present, but no duplicates found.\n            # As there are no givenName duplicates, we should be able to\n            # uniquely identify the fields without the evolver.\n            # We may want to protect the evolver - in this case, include it\n            # after the givenName\n            elif protectEvolver:\n                newname = givenName + "" "" + evolver + "" "" + quantity\n            # If there are no duplicates in the givenName (the \'quantity\' is\n            # duplicated), and the evolver is not protected, drop the evolver.\n            else:\n                newname = givenName + "" "" + quantity\n        # givenName not present. In this case just output evolver and quantity.\n        else:\n            newname = evolver + "" "" + quantity\n    # Quantity is not duplicated. Each quantity label is unique, so can identify\n    # the field usuing quantity alone.\n    else:\n        newname = quantity\n    for item in ALWAYS_CLEAR:\n        # Remove evolver prefixes to improve readability\n        newname = newname.replace(item, """")\n    log(""Readability adaptation: %s to %s"" % (name, newname))\n    return newname\n\ndef _filterOnPos(inList, item, dex):\n    """"""Return list (of lists) if a string is found in a particular position in\n    that list.\n\n    If the length of \'ret\' is more than 1, it means that there is a\n    duplicate of the target item in the indicated position.\n    It seems to be called \'filter on pos\' as it returns lists only\n    if the target value is found in the position specified within\n    the lists supplied.\n    """"""\n    ret = []\n    for compare in inList:\n        if compare[dex] == item:\n            ret.append(compare)\n    return ret\n\ndef prefix_punt(data):\n    """"""\n    """"""\n    # Drop prefix (with _ separator)\n    return data.split(""_"")[-1]'"
oommftools/core/oommfconvert.py,0,"b'import os\nimport subprocess\nimport shutil\nimport tempfile\nimport math\nfrom past.utils import old_div\nfrom .oommfdecode import slowlyPainfullyMaximize\nimport re\n\ndef getOOMMFPath(pathFileToCheck):\n    # Check if we have a saved OOMMF path to use as config data\n    if os.path.exists(pathFileToCheck):\n        f = open(pathFileToCheck)\n        lines = f.readlines()\n        f.close()\n        path = lines[-1].strip()\n        # But we also have to validate the path on this particular computer\n        if os.path.exists(path) and path.rsplit(""."")[-1] == ""tcl"":\n            return path\n        else:\n            return None\n            # Cleanup bogus config file\n            os.remove(pathFileToCheck)\n    else:\n        # No file at all!\n        return None\n\n\ndef spliceConfig(percentMagnitude, checkVectors=False, filenames=[], configPath=None):\n    print(checkVectors)\n    # Rewrite the file\n    oldconf = open(configPath, ""r"")\n    oldconflines = oldconf.readlines()\n    oldconf.close()\n    print(""Getting temporary file handle for modconfig."")\n    oshandle, newconfdir = tempfile.mkstemp(suffix="".tmp"", dir=""."")\n    try:\n        os.close(oshandle)\n    except:\n        print(""Error: Windows failed all over closing the file handle."")\n    newMax = slowlyPainfullyMaximize(filenames)\n    newconf = replaceConfigLines(oldconflines, \n                                 newMax, \n                                 percentMagnitude,\n                                 checkVectors)\n    \n    with open(newconfdir, \'w\') as confFile:\n        for line in newconf:\n            confFile.write(""%s"" % line)\n\n    return newconfdir\n\n\ndef replaceConfigLines(oldconflines, newMax, percentMagnitude, checkVectors):\n    newconf = []\n    for line in oldconflines:\n        # Only one data point for line. Let\'s deal with our cases.\n        if ""misc,datascale"" in line and checkVectors:\n            newconf.append(""    misc,datascale "" + str(newMax) + ""\\n"")\n        elif not percentMagnitude == 100:\n            if ""misc,zoom"" in line:\n                # newconf.write(line)\n                # Don\'t stop clobbering zoom!\n                newconf.append(""    misc,zoom 0\\n"")\n            elif ""misc,default"" in line:\n                # This was not nearly as true as I\'d hoped\n                # Just in case this ever looks at the viewport, clobber the viewport.\n                pass\n            elif ""misc,height"" in line:\n                newval = int(re.findall(r""[0-9]+"", line)\n                             [0]) * percentMagnitude / 100.0\n                newconf.append(""    misc,height "" + str(newval) + ""\\n"")\n            elif ""misc,width"" in line:\n                newval = int(re.findall(r""[0-9]+"", line)\n                             [0]) * percentMagnitude / 100.0\n                newconf.append(""    misc,width "" + str(newval) + ""\\n"")\n            else:\n                newconf.append(line)\n        else:\n            newconf.append(line)\n\n    return newconf\n        \n\ndef resolveConfiguration(filenames, magnifierSpin, autoMaxVectors, configPath):\n    if magnifierSpin != 100 or autoMaxVectors:\n        configPath = spliceConfig(\n            magnifierSpin, autoMaxVectors, filenames, configPath)\n        cleanconfig = True\n    else:\n        cleanconfig = False\n    return (configPath, cleanconfig)\n\n\ndef convertOmfToImage(omf, tclCall, oommfPath, confpath, stdinRedirect, mode=\'advanced\'):\n    command = build_avf2ppm_command(tclCall, oommfPath, confpath, omf)\n    runSubProcess(command, stdinRedirect, mode, omf)\n\ndef build_avf2ppm_command(tclCall, oommfPath, confPath, omf):\n    return tclCall + \' ""\' + oommfPath + \\\n        \'"" avf2ppm -f -v 2 -format b24 -config ""\' + confPath + \'"" ""\' + omf + \'""\'\n\ndef runSubProcess(command, stdinRedirect, mode, checkPath):\n    if mode == ""basic"":\n        os.system(command)\n    elif mode == \'advanced\':\n        pipe = subprocess.Popen(command, **getSubProcessArgs(command,\n                                                    stdinRedirect, \n                                                    checkPath,\n                                                    os.name)).stdout\n        a = pipe.readlines()\n        # THIS should at least use STDout\n        if a:\n            for line in a:\n                print(line.strip())\n\ndef getSubProcessArgs(command, stdinRedirect, checkPath, osName=\'nt\'):\n    if osName == \'nt\':\n        print(""Watching stdin redirect:"", stdinRedirect)\n        if not r"":\\\\"" in checkPath:\n            subProcessArgs = {\n                                \'shell\': True,\n                                \'stdin\': stdinRedirect,\n                                \'stdout\': subprocess.PIPE,\n                                \'stderr\': subprocess.STDOUT\n                                }\n        else:\n            # Avoid network stupidity.\n            subProcessArgs = {\n                                \'shell\': False,\n                                \'stdin\': stdinRedirect,\n                                \'stdout\': subprocess.PIPE,\n                                \'stderr\': subprocess.STDOUT\n                                }\n    else:\n        print(""probably posix mode."")\n        subProcessArgs = {\n                            \'shell\': True,\n                            \'stdin\': sys.stdin,\n                            \'stdout\': subprocess.PIPE,\n                            \'stderr\':subprocess.STDOUT\n                            }\n    \n    return subProcessArgs\n\n\ndef makeMovieFromImages(moviePath, pathTo, maxDigits, movieCodec, stdinRedirect, codecs, mode=\'advanced\'):\n    command = buildMovieCommand(moviePath, pathTo, maxDigits, codecs[movieCodec])\n    runSubProcess(command, stdinRedirect, mode, pathTo)\n\n\ndef buildMovieCommand(moviePath, pathTo, maxDigits, movieCodec):\n    """"""Build movie command.\n\n    CODECS[movieCodec]:\n    ""MPEG4"": (r"" -sameq "","".mp4"",""MPEG4"")\n    """"""\n    outname = ""[""+movieCodec[2]+""]"" + movieCodec[1]\n    command = r\'ffmpeg -f image2 -an -y -i \' + moviePath + os.path.sep + \\\n        r\'%0\' + str(maxDigits) + r\'d.bmp \' + movieCodec[0]\n    command += \' ""\' + os.path.join(pathTo, outname) + \'""\'\n    return command\n\n\ndef createTempImagesForMovie(targetList, moviepath, framedupes, maxdigits, tclCall, OOMMFPath, confpath, stdinRedirect, removeImages=False):\n    print(""Temporary directory obtained."")\n\n    for i, omf in enumerate(sorted(targetList)):\n        frameRepeatOffset = 0\n        convertOmfToImage(omf, tclCall, OOMMFPath, confpath, stdinRedirect)\n        # Copy and duplicate image, placing files in the movie temp directory\n        print(\'copying files to temp directory\')\n        fname = omf.rsplit(""."", 1)[0] + "".bmp""\n        for j in range(framedupes):\n            shutil.copy(*buildShutilSourceDestination(fname,\n                                                      moviepath, \n                                                      framedupes*i + j, \n                                                      maxdigits,\n                                                      ))\n            j += 1\n        # Housecleaning - if not making images, you should clean this up.\n        if not removeImages:\n            os.remove(fname)\n\n\ndef buildShutilSourceDestination(fname, moviepath, framedupes, maxdigits):\n    return (fname, moviepath+os.path.sep + \n                        str(framedupes).rjust(maxdigits, ""0"") + "".bmp"")\n\ndef doImages(targetList, stdinRedirect, config_parent, tclCall, OOMMFPath):\n    confpath, cleanconfig = resolveConfiguration(targetList, \n                                                 config_parent[\'magnifierSpin\'],\n                                                 config_parent[\'autoMaxVectors\'],\n                                                 config_parent[\'config\'])\n    for i, omf in enumerate(sorted(targetList)):\n        convertOmfToImage(omf, tclCall, OOMMFPath, confpath, stdinRedirect)\n    # Clean up temporaries\n    if cleanconfig:\n        cleanupConfig(confpath)\n\n\ndef doMovies(targetList, stdinRedirect, config_parent, movieCodec, movieFPS, tclCall, OOMMFPath, doImages, codecs):\n    # Make temporary directory\n    moviepath = tempfile.mkdtemp()\n    # Deal with overload-options by writing a temporary configuration file\n    confpath, cleanconfig = resolveConfiguration(targetList, \n                                                 config_parent[\'magnifierSpin\'],\n                                                 config_parent[\'autoMaxVectors\'],\n                                                 config_parent[\'config\'])\n    # Identify filename length, and perform AWFUL HACK to sidestep ffmpeg restrictions\n    framedupes = int(old_div(25, movieFPS))\n    maxdigits = int(math.ceil(math.log10(len(targetList) * framedupes)))\n    createTempImagesForMovie(targetList, moviepath, framedupes, maxdigits,\n                             tclCall, OOMMFPath, confpath, stdinRedirect, doImages)\n\n    pathTo = targetList[0].rsplit(os.path.sep, 1)\n    # Finally, make the actual movie!\n    # You know, we should steal the last pathto as a place to put the movie, and perhaps also the basename\n    # This is bad use of scoping blah blah\n\n    makeMovieFromImages(\n        moviepath, pathTo[0], maxdigits, movieCodec, stdinRedirect, codecs)\n    # Clean up temporaries\n    shutil.rmtree(moviepath)\n    if cleanconfig:\n        cleanupConfig(confpath)\n\n\ndef cleanupConfig(configPath):\n    try:\n        os.remove(configPath)\n    except:\n        print(""Can\'t let go for some reason... you should probably tell doublemark@mit.edu"")\n'"
oommftools/core/oommfdecode.py,4,"b'import numpy as np\nimport struct\nimport pickle\nimport scipy.io as spio\nfrom collections import defaultdict\n\ndef unpackFile(filename):\n    """"""\n    """"""\n    with open(filename, \'rb\') as f:\n        headers = {} #I know valuemultiplier isn\'t always present. This is checked later.\n        extraCaptures = {\'SimTime\':-1, \'Iteration\':-1, \'Stage\':-1, ""MIFSource"":""""}\n        #Parse headers\n        a = """"\n        while not ""Begin: Data"" in a:\n            \n            a = f.readline().strip().decode()\n            #Determine if it\'s actually something we need as header data\n            for key in [""xbase"",\n                        ""ybase"",\n                        ""zbase"",\n                        ""xstepsize"",\n                        ""ystepsize"",\n                        ""zstepsize"",\n                        ""xnodes"",\n                        ""ynodes"",\n                        ""znodes"",\n                        ""valuemultiplier""]:\n                if key in a:\n                    headers[key] = float(a.split()[2]) #Known position FTW\n            #All right, it may also be time data, which we should capture\n            if ""Total simulation time"" in a:\n                #Split on the colon to get the time with units;\n                #strip spaces and split on the space to separate time and units\n                #Finally, pluck out the time, stripping defensively\n                #(which should be unnecessary).\n                extraCaptures[\'SimTime\'] = float(a.split("":"")[-1].strip().split()[0].strip())\n            if ""Iteration:"" in a:\n                #Another tricky split...\n                extraCaptures[\'Iteration\'] = float(a.split("":"")[2].split("","")[0].strip())\n            if ""Stage:"" in a:\n                extraCaptures[\'Stage\'] = float(a.split("":"")[2].split("","")[0].strip())\n            if ""MIF source file"" in a:\n                extraCaptures[\'MIFSource\'] = a.split("":"", 2)[2].strip()\n\n\n        #Initialize array to be populated\n        outArray = np.zeros((int(headers[""xnodes""]),\n                             int(headers[""ynodes""]),\n                             int(headers[""znodes""]),\n                             3))\n\n        #Determine decoding mode and use that to populate the array\n        print(""Data indicator:"", a)\n        decode = a.split()\n        if decode[3] == ""Text"":\n            return _textDecode(f, outArray, headers, extraCaptures)\n        elif decode[3] == ""Binary"" and decode[4] == ""4"":\n            #Determine endianness\n            endianflag = f.read(4)\n            if struct.unpack("">f"", endianflag)[0] == 1234567.0:\n                print(""Big-endian 4-byte detected."")\n                dc = struct.Struct("">f"")\n            elif struct.unpack(""<f"", endianflag)[0] == 1234567.0:\n                print(""Little-endian 4-byte detected."")\n                dc = struct.Struct(""<f"")\n            else:\n                raise Exception(""Can\'t decode 4-byte byte order mark: "" + hex(endianflag))\n            return _binaryDecode(f, 4, dc, outArray, headers, extraCaptures)\n        elif decode[3] == ""Binary"" and decode[4] == ""8"":\n            #Determine endianness\n            endianflag = f.read(8)\n            if struct.unpack("">d"", endianflag)[0] == 123456789012345.0:\n                print(""Big-endian 8-byte detected."")\n                dc = struct.Struct("">d"")\n            elif struct.unpack(""<d"", endianflag)[0] == 123456789012345.0:\n                print(""Little-endian 8-byte detected."")\n                dc = struct.Struct(""<d"")\n            else:\n                raise Exception(""Can\'t decode 8-byte byte order mark: "" + hex(endianflag))\n            return _binaryDecode(f, 8, dc, outArray, headers, extraCaptures)\n        else:\n            raise Exception(""Unknown OOMMF data format:"" + decode[3] + "" "" + decode[4])\n\n\n\ndef _textDecode(filehandle, targetarray, headers, extraCaptures):\n    """"""\n    """"""\n    valm = headers.get(""valuemultiplier"", 1)\n    for k in range(int(headers[""znodes""])):\n        for j in range(int(headers[""ynodes""])):\n            for i in range(int(headers[""xnodes""])):\n                #numpy is fantastic - splice in a tuple\n                text = filehandle.readline().strip().split()\n                targetarray[i, j, k] = (float(text[0])*valm,\n                                        float(text[1])*valm,\n                                        float(text[2])*valm)\n    print(""Decode complete."")\n    return (targetarray, headers, extraCaptures)\n\n\ndef _binaryDecode(filehandle, chunksize, decoder, targetarray, headers, extraCaptures):\n    """"""\n    """"""\n    valm = headers.get(""valuemultiplier"", 1)\n    for k in range(int(headers[""znodes""])):\n        for j in range(int(headers[""ynodes""])):\n            for i in range(int(headers[""xnodes""])):\n                for coord in range(3): #Slowly populate, coordinate by coordinate\n                    targetarray[i, j, k, coord] = decoder.unpack(filehandle.read(chunksize))[0] * valm\n    print(""Decode complete."")\n    return (targetarray, headers, extraCaptures)\n\ndef pickleArray(array, headers, extraCaptures, filename):\n    """"""\n    """"""\n    temp = dict(headers)\n    temp.update(extraCaptures)\n    f = open(filename, \'wb\')\n    pickle.dump((array, temp), f)\n    f.close()\n\ndef matlabifyArray(array, headers, extraCaptures, filename):\n    """"""\n    """"""\n    GridSize = np.array([float(headers[""xstepsize""]),\n                         float(headers[""ystepsize""]),\n                         float(headers[""zstepsize""])])\n    OutDict = {""OOMMFData"":array, ""GridSize"":GridSize}\n    OutDict.update(extraCaptures)\n    spio.savemat(filename, OutDict)\n\ndef slowlyPainfullyMaximize(filenames):\n    """"""\n    This is a special utility function used by OOMMFConvert to find the single largest-magnitude\n    vector in a set of vector files\n    """"""\n    #There is no nice way to do this.\n    def mag(a, b, c):\n        """"""\n        """"""\n        return np.sqrt(a**2 + b**2 + c**2)\n    maxmag = 0\n\n    for filename in filenames:\n        thisArray, headers, extraCaps = unpackFile(filename)\n        for k in range(int(headers[""znodes""])):\n            for j in range(int(headers[""ynodes""])):\n                for i in range(int(headers[""xnodes""])):\n                    maxmag = max(maxmag, mag(*thisArray[i, j, k]))\n    return maxmag\n\n\ndef sortBySimTime(extra, arrays):\n\n    # We do some enumeration later on that needs \'arrays\'\n    # to be an iterable.\n    if len(arrays) < 1:\n        arrays = (arrays,)\n    originalTimeIndex = list(extra[""SimTime""])\n    if len(set(extra[""MIFSource""])) == 1:\n        if not -1 in extra[""SimTime""]:\n            # Rather than sort / zip the arrays themselves\n            # we do it with indices. This is because python\n            # didn\'t like sorting / zipping numpy arrays.\n            array_indices = [i for i,j in enumerate(arrays)]\n            sorted_arrays = []\n            zipped = zip(originalTimeIndex, array_indices)\n            sorted_zipped = sorted(zipped) # problem here\n            zipped_sorted_zipped = zip(*sorted_zipped)\n            extra[""SimTime""], array_order = list(zipped_sorted_zipped)\n            #Sadly, the cleverness ends here - the rest must be bruteforced.\n            for key in extra:\n                if not key == ""SimTime"": #We did that one.\n                    junk, extra[key] = list(zip(*sorted(zip(originalTimeIndex, extra[key]))))\n            for count, array in enumerate(arrays):\n                sorted_arrays.append(arrays[array_order[count]])\n            arrays = tuple(sorted_arrays)\n    return arrays, extra\n\n\ndef groupUnpack(targetList):\n    decodedArrays = []\n    headers = {}\n    extraData = defaultdict(list)\n    firstTime = True\n    for target in targetList:\n        collect = unpackFile(target)\n        if firstTime:\n            firstTime = False\n            headers = collect[1]\n        decodedArrays.append(collect[0])\n        #Unpack extra collected data\n        for key, value in list(collect[2].items()):\n            extraData[key].append(value)\n\n    return (np.array(decodedArrays), headers, extraData)'"
oommftools/user_interfaces/__init__.py,0,b''
oommftools/user_interfaces/cli/__init__.py,0,b'from .main import *'
oommftools/user_interfaces/cli/main.py,0,"b'from core import oommfdecode\nimport os\nimport argparse\n\ndef cli_main():\n    # Create the parser\n    main_parser = argparse.ArgumentParser(prog=\'OOMMFTools\',\n                                          description=\'A command line interface to OOMMFTools\')\n    main_parser.add_argument(\n        \'--debug\',\n        action=\'store_true\',\n        help=\'Print debug info\'\n    )\n    # Add the arguments\n    subparsers = main_parser.add_subparsers(dest=\'tool_selection\', help=\'Tools Available\')\n    decode_parser = subparsers.add_parser(""decode"")\n    decode_parser.add_argument(\'--pickle\', \'-p\', dest=""pickle"", action=\'store_true\')\n    decode_parser.add_argument(\'--matlab\', \'-m\', dest=""matlab"", action=\'store_true\')\n    decode_parser.add_argument(""files"", help=""Input file"", nargs=""+"")\n    decode_parser.add_argument(""--output"", ""-o"", help=""Output filename"", nargs=1)\n    convert_parser = subparsers.add_parser(""convert"")\n    chomp_parser = subparsers.add_parser(""chomp"")\n\n    args = main_parser.parse_args()\n\n\n    if args.tool_selection == \'decode\':\n        for filename in args.files:\n            if args.output:\n                basename = args.output[0]\n            else:\n                basename = os.path.basename(os.path.splitext(filename)[0])\n\n            array, headers, extraCaptures = oommfdecode.unpackFile(filename)\n            if args.pickle is True:\n                oommfdecode.pickleArray(array, headers, extraCaptures, basename + \'.pkl\')\n            if args.matlab is True:\n                oommfdecode.matlabifyArray(array, headers, extraCaptures, basename + \'.mat\')\n\n    if args.tool_selection == \'convert\':\n        print(""Not yet implemented"")\n    if args.tool_selection == \'chomp\':\n        print(""Not yet implemented"")\n'"
oommftools/user_interfaces/gui/__init__.py,0,b'from .main import *'
oommftools/user_interfaces/gui/main.py,0,"b'import wx\n\nfrom user_interfaces.gui import odtchomp, oommfconvert, oommfdecode\nimport _about as about\n\n__version__ = about.__version__\nVERSION = about.__version__\nNAME = about.__title__\nLICENSE = about.__license__\nCOPYRIGHT = about.__copyright__\nWEBSITE = about.__uri__\nDESC = about.__summary__\n\ndef gui_main():\n    APP = wx.App(None)\n    q = MainFrame()\n    APP.MainLoop()\n\n\nclass MainFrame(wx.Frame):\n    """"""The main oommftools window.\n\n    Creates main window with buttons to open the oommftools sub-\n    tools.\n\n    """"""\n    def __init__(self):\n        wx.Frame.__init__(self, None, -1, ""OOMMFTools"", size=(400, 200))\n\n        self.oommfconvert = None\n        self.oommfdecode = None\n        self.odtchomp = None\n\n        #A very simple menubar\n        menubar = wx.MenuBar()\n        about = wx.Menu()\n        about.Append(999, \'About\', \'Program information and license\')\n        menubar.Append(about, ""About"")\n        self.SetMenuBar(menubar)\n\n        self.Bind(wx.EVT_MENU, self.showAbout, id=999)\n\n        panel = wx.Panel(self, -1)\n        self.panel = panel\n\n        mainsizer = wx.FlexGridSizer(3, 2, 8, 12)\n\n        mainsizer.Add(wx.Button(panel, 10, ""OOMMFDecode""),\n                      0, wx.EXPAND | wx.ALIGN_CENTER | wx.TOP | wx.LEFT, 20)\n        mainsizer.Add(wx.StaticText(panel, -1,\n                                    ""Create numpy and MATLAB data""),\n                      1, wx.ALIGN_CENTER_VERTICAL | wx.TOP, 20)\n        self.Bind(wx.EVT_BUTTON, self.makeDecode, id=10)\n\n        mainsizer.Add(wx.Button(panel, 20, ""OOMMFConvert""),\n                      0, wx.EXPAND | wx.ALIGN_CENTER | wx.LEFT, 20)\n        mainsizer.Add(wx.StaticText(panel, -1,\n                                    ""Create bitmaps and movies""),\n                      1, wx.ALIGN_CENTER_VERTICAL)\n        self.Bind(wx.EVT_BUTTON, self.makeConvert, id=20)\n\n        mainsizer.Add(wx.Button(panel, 30, ""ODTChomp""),\n                      0, wx.EXPAND | wx.ALIGN_CENTER | wx.BOTTOM | wx.LEFT, 20)\n        mainsizer.Add(wx.StaticText(panel, -1,\n                                    ""Manage, reduce and convert ODT files""),\n                      1, wx.ALIGN_CENTER_VERTICAL | wx.BOTTOM, 20)\n        self.Bind(wx.EVT_BUTTON, self.makeChomp, id=30)\n\n        mainsizer.AddGrowableCol(1, 1)\n\n        panel.SetSizer(mainsizer)\n        panel.Fit()\n        self.Center()\n        self.Show(True)\n\n    def makeDecode(self, evt):\n        """"""Open oommfdecode window\n        """"""\n        if not self.oommfdecode:\n            self.oommfdecode = oommfdecode.MainFrame(self)\n\n    def makeConvert(self, evt):\n        """"""Open oommfconvert window\n        """"""\n        if not self.oommfconvert:\n            self.oommfconvert = oommfconvert.MainFrame(self)\n\n    def makeChomp(self, evt):\n        """"""Open odtchomp window.\n        """"""\n        if not self.odtchomp:\n            self.odtchomp = odtchomp.MainFrame(self)\n\n    def droppedWindow(self, window):\n        """"""Not sure what this does. It\'s not called by main window.\n        """"""\n        if self.oommfdecode == window:\n            self.oommfdecode = None\n        elif self.oommfconvert == window:\n            self.oommfconvert = None\n        elif self.odtchomp == window:\n            self.odtchomp = None\n\n    def showAbout(self, evt):\n        """"""Show \'About\' information\n        """"""\n        info = wx.adv.AboutDialogInfo()\n        mydesc = (DESC)\n        mylicense = (LICENSE)\n        info.SetName((NAME))\n        info.SetVersion((VERSION))\n        info.SetDescription(\'\\n\'.join(mydesc))\n        info.SetLicense(\'\\n\'.join(mylicense))\n        info.SetCopyright((COPYRIGHT))\n        info.SetWebSite(WEBSITE)\n        wx.adv.AboutBox(info)'"
oommftools/user_interfaces/gui/odtchomp.py,0,"b'\n""""""\nODTChomp\nCopyright (C) 2010  Mark Mascaro\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\n""""""\nfrom __future__ import print_function\nfrom __future__ import absolute_import\n\n\n\nfrom builtins import str\nfrom builtins import object\nimport os\nfrom wx import adv\nimport wx\nimport numpy as np\nfrom fnameutil import filterOnExtensions\nimport _about as about\nfrom core import odtchomp\n\n#########\n# About #\n#########\n\nVERSION = about.__version__\nNAME = ""ODTChomp""\nLICENSE = about.__license__\nCOPYRIGHT = about.__copyright__\nWEBSITE = about.__uri__\nDESCRIPTION = """"""ODTChomp is an OOMMF postprocessing tool for\nextracting columns from and unifying delimitation\nof ODT table files.\n\\nODTChomp is part of OOMMFTools.""""""\n\n\n\n########\n# DECS #\n########\n\n#Readability magic below\nALWAYS_CLEAR = [""Oxs_""]\n\nPROTECTED_NAMES = [""Exchange""]\n\n#######\n# GUI #\n#######\n\nclass MainFrame(wx.Frame):\n    """"""Main frame for odtchomp\n    """"""\n    def __init__(self, manager=None):\n        wx.Frame.__init__(self, None, -1, ""ODT Chomper 0.9"", size=(900, 500))\n        self.watching = []\n        self.delim = "" ""\n\n        #Let\'s try to get a proto-digest from a file to memorize the ODT layout\n        if os.path.exists(""."" + os.path.sep + ""odt.layout""):\n            f = open(""."" + os.path.sep + ""odt.layout"")\n            lines = f.readlines()\n            f.close()\n            lines = [line.strip() for line in lines]\n            self.digest = odtchomp.Interpreter({}, keys=lines)\n        else:\n            #No file at all!\n            self.digest = None\n\n        self.exportPath = os.getcwd()\n\n        self.dt = ODTDropTarget(self)\n        self.SetDropTarget(self.dt)\n        self.manager = manager\n\n        self.Bind(wx.EVT_CLOSE, self.onClose)\n\n        #A very simple menubar\n        menubar = wx.MenuBar()\n        about = wx.Menu()\n        about.Append(999, \'About\', \'Program information and license\')\n        menubar.Append(about, ""About"")\n        self.SetMenuBar(menubar)\n\n        self.Bind(wx.EVT_MENU, self.showAbout, id=999)\n\n        panel = wx.Panel(self, -1)\n        self.panel = panel #OK, I do need a reference to this to send size events later\n        #Point Zero: Major Box Sizer\n        sizer = wx.BoxSizer(wx.VERTICAL)\n\n        #Deal with import button\n        self.importButton = wx.Button(panel, 1, ""Import"")\n        sizer.Add(self.importButton, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)\n        self.Bind(wx.EVT_BUTTON, self.importFile, id=1)\n\n\n        #Deal with active label\n        self.fileLabel = wx.StaticText(panel, -1, ""No File Loaded"", style=wx.ALIGN_CENTER)\n        sizer.Add(self.fileLabel, 0, wx.ALIGN_CENTER | wx.BOTTOM, 10)\n        sizer.Add(wx.StaticLine(panel, -1), 0, wx.EXPAND | wx.BOTTOM, 15)\n\n        #Listboxes! Prepare horizontal sizer\n        tsizer = wx.BoxSizer()\n\n        #Do left listbox\n        llbsizer = wx.BoxSizer(wx.VERTICAL)\n        lefttitle = wx.StaticText(panel, -1, ""Available Data Fields"", style=wx.ALIGN_CENTER)\n        self.leftbox = wx.ListBox(panel, 10, choices=[], style=wx.LB_SINGLE)\n        llbsizer.Add(lefttitle, 0, wx.ALIGN_CENTER)\n        llbsizer.Add(self.leftbox, 1, wx.ALIGN_CENTER | wx.EXPAND | wx.TOP, 10)\n        tsizer.Add(llbsizer, 1, wx.ALIGN_CENTER | wx.EXPAND | wx.LEFT | wx.RIGHT, 10)\n\n        self.leftbox.Bind(wx.EVT_LEFT_DCLICK, self.takeData)\n\n        midbsizer = wx.BoxSizer(wx.VERTICAL)\n\n        #Add/Remove Buttons\n        a = wx.Button(panel, 20, ""-->"")\n        self.Bind(wx.EVT_BUTTON, self.takeData, id=20)\n        b = wx.Button(panel, 21, ""<--"")\n        self.Bind(wx.EVT_BUTTON, self.puntData, id=21)\n        c = wx.Button(panel, 22, ""+All"")\n        self.Bind(wx.EVT_BUTTON, self.takeAll, id=22)\n        d = wx.Button(panel, 23, ""-All"")\n        self.Bind(wx.EVT_BUTTON, self.puntAll, id=23)\n\n        midbsizer.Add(a, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM, 10)\n        midbsizer.Add(b, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM, 10)\n        midbsizer.Add(c, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM, 10)\n        midbsizer.Add(d, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM, 10)\n\n        #Radio Controls\n\n        label = wx.StaticText(panel, -1, ""File Delimiter"")\n        self.spaceDelim = wx.RadioButton(panel, 30, ""Space"", style=wx.RB_GROUP)\n        self.tabDelim = wx.RadioButton(panel, 31, ""Tab"")\n        self.commaDelim = wx.RadioButton(panel, 32, ""Comma"")\n        self.Bind(wx.EVT_RADIOBUTTON, self.setDelim, id=30)\n        self.Bind(wx.EVT_RADIOBUTTON, self.setDelim, id=31)\n        self.Bind(wx.EVT_RADIOBUTTON, self.setDelim, id=32)\n        self.spaceDelim.SetValue(True)\n\n        midbsizer.Add((-1, 10))\n        midbsizer.Add(label, 0, wx.ALIGN_CENTER | wx.BOTTOM | wx.TOP, 10)\n        midbsizer.Add(self.spaceDelim, 0, wx.LEFT | wx.BOTTOM, 2)\n        midbsizer.Add(self.tabDelim, 0, wx.LEFT | wx.BOTTOM, 2)\n        midbsizer.Add(self.commaDelim, 0, wx.LEFT | wx.BOTTOM, 2)\n\n        tsizer.Add(midbsizer, 0, wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 10)\n\n        #Final Listbox\n        rlbsizer = wx.BoxSizer(wx.VERTICAL)\n        righttitle = wx.StaticText(panel, -1, ""Exported Data Fields"", style=wx.ALIGN_CENTER)\n        self.rightbox = wx.ListBox(panel, 11, choices=[], style=wx.LB_SINGLE)\n        rlbsizer.Add(righttitle, 0, wx.ALIGN_CENTER)\n        rlbsizer.Add(self.rightbox, 1, wx.ALIGN_CENTER | wx.EXPAND | wx.TOP, 10)\n        tsizer.Add(rlbsizer, 1, wx.ALIGN_CENTER | wx.EXPAND | wx.LEFT | wx.RIGHT, 10)\n\n        self.rightbox.Bind(wx.EVT_LEFT_DCLICK, self.puntData)\n\n\n        #U/D buttons\n        udbsizer = wx.BoxSizer(wx.VERTICAL)\n        a = wx.Button(panel, 50, ""Move Up"")\n        b = wx.Button(panel, 51, ""Move Down"")\n\n        self.Bind(wx.EVT_BUTTON, self.bumpUp, id=50)\n        self.Bind(wx.EVT_BUTTON, self.bumpDown, id=51)\n\n        udbsizer.Add(a, 0, wx.CENTER | wx.BOTTOM, 10)\n        udbsizer.Add(b, 0, wx.CENTER | wx.BOTTOM, 10)\n        tsizer.Add(udbsizer, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT | wx.RIGHT, 10)\n\n\n        #Clean up horizontal sizers\n        sizer.Add(tsizer, 1, wx.EXPAND | wx.BOTTOM, 20)\n\n        # Export!\n        sizer.Add(wx.StaticLine(panel, -1), 0, wx.EXPAND | wx.BOTTOM, 15)\n\n        self.batchModeCheckbox = wx.CheckBox(panel, 60, ""Drag-Drop Batch Mode"")\n        self.batchModeCheckbox.SetValue(False)\n        sizer.Add(self.batchModeCheckbox, 0, wx.ALIGN_CENTER | wx.TOP, 10)\n        self.Bind(wx.EVT_CHECKBOX, self.fixBatchMode, id=60)\n\n        self.exportButton = wx.Button(panel, 70, ""Export"")\n        self.exportButton._secondLevelEnable = False\n        sizer.Add(self.exportButton, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)\n        self.Bind(wx.EVT_BUTTON, self.exportFile, id=70)\n        self.exportButton.Disable()\n\n        #Late-game setup\n        if self.digest:\n            self.leftbox.Set(self.digest.getNames())\n\n        #Cleanup\n        panel.SetSizer(sizer)\n        if self.manager:\n            self.CenterOnParent()\n        self.Show()\n\n    def onClose(self, evt):\n        """"""\n        """"""\n        if self.manager:\n            self.manager.droppedWindow(self)\n        self.Destroy()\n\n    def setDelim(self, evt):\n        """"""\n        """"""\n        if self.spaceDelim.GetValue():\n            self.delim = "" ""\n        elif self.tabDelim.GetValue():\n            self.delim = ""\\t""\n        elif self.commaDelim.GetValue():\n            self.delim = "",""\n\n    def fixBatchMode(self, evt):\n        """"""\n        """"""\n        if self.batchModeCheckbox.GetValue():\n            print(""Batch mode disable."")\n            self.importButton.Disable()\n            self.exportButton.Disable()\n        else:\n            print(""Batch mode enable."")\n            self.importButton.Enable()\n            if self.exportButton._secondLevelEnable:\n                self.exportButton.Enable()\n\n    def importFile(self, evt):\n        """"""\n        """"""\n        dlg = wx.FileDialog(self, ""Import ODT File"",\n                            os.getcwd(), """",\n                            ""OOMMF ODT Data (*.odt)|*.odt"",\n                            wx.FD_OPEN)\n        if dlg.ShowModal() == wx.ID_OK and dlg.GetPath():\n            #self.fileLabel.SetLabel(""Open: "" + os.getcwd() + os.path.sep + dlg.GetFilename())\n            self._importFile(dlg.GetPath())\n\n    def _importFile(self, filename):\n        """"""\n        """"""\n        print(""Import enable."")\n        self.fileLabel.SetLabel(""Open: "" + filename)\n        self.digest = odtchomp.chomp(filename)\n        self.leftbox.Set(self.digest.getNames())\n        self.panel.SendSizeEvent()\n        self.exportPath = os.path.dirname(filename)\n        self.exportButton._secondLevelEnable = True\n        self.exportButton.Enable()\n        #Cache the autolayout\n        f = open(""."" + os.path.sep + ""odt.layout"", ""w"")\n        f.write(""\\n"".join(self.digest.getNames()))\n        f.close()\n\n    def _lightImportFile(self, filename):\n        """"""\n        """"""\n        #returns (Interpreter, exportPathname)\n        return (odtchomp.chomp(filename), os.path.dirname(filename))\n\n    def exportFile(self, evt):\n        """"""\n        """"""\n        dlg = wx.FileDialog(self,\n                            \'Export Translated File\',\n                            self.exportPath, """",\n                            ""Plaintext ODT Data (*.txt)|*.txt"",\n                            wx.FD_SAVE)\n        if dlg.ShowModal() == wx.ID_OK and dlg.GetPath():\n            filename = dlg.GetPath()\n            self.exportPath = os.path.dirname(dlg.GetPath())\n            odtchomp.write(filename, self.digest, self.delim, self.watching)\n\n    def takeData(self, evt):\n        """"""\n        """"""\n        if self.digest and self.leftbox.GetSelections():\n            sel = self.leftbox.GetSelections()[0]\n            keys = self.digest.getNames()\n            if not keys[sel] in self.watching:\n                self.watching.append(keys[sel])\n                self.rightbox.Set(self.watching)\n\n    def takeAll(self, evt):\n        """"""\n        """"""\n        if self.digest:\n            self.watching = self.digest.getNames()\n            self.rightbox.Set(self.watching)\n\n    def puntData(self, evt):\n        """"""\n        """"""\n        if self.digest and self.rightbox.GetSelections():\n            self.watching.pop(self.rightbox.GetSelections()[0])\n            self.rightbox.Set(self.watching)\n\n    def puntAll(self, evt):\n        """"""\n        """"""\n        if self.digest:\n            self.watching = []\n            self.rightbox.Set(self.watching)\n            #self.leftbox.Set(self.digest.getNames())\n\n    def bumpUp(self, evt):\n        """"""\n        """"""\n        if self.digest and self.rightbox.GetSelections() and self.rightbox.GetSelections()[0] > 0:\n            dex = self.rightbox.GetSelections()[0]\n            pull = self.watching.pop(dex)\n            self.watching.insert(dex-1, pull)\n            self.rightbox.Set(self.watching)\n            self.rightbox.SetSelection(dex-1)\n\n    def bumpDown(self, evt):\n        """"""\n        """"""\n        if self.digest and self.rightbox.GetSelections() and self.rightbox.GetSelections()[0] < len(self.watching)-1:\n            dex = self.rightbox.GetSelections()[0]\n            pull = self.watching.pop(dex)\n            self.watching.insert(dex+1, pull)\n            self.rightbox.Set(self.watching)\n            self.rightbox.SetSelection(dex+1)\n\n    def showAbout(self, evt):\n        """"""\n        """"""\n        info = wx.adv.AboutDialogInfo()\n        mydesc = DESCRIPTION\n        mylicense = LICENSE\n        info.SetName(NAME)\n        info.SetVersion(VERSION)\n        info.SetDescription("""".join(mydesc))\n        info.SetLicense("""".join(mylicense))\n        info.SetCopyright(COPYRIGHT)\n        info.SetWebSite(WEBSITE)\n        wx.adv.AboutBox(info)\n\n###########\n# BACKEND #\n###########\n\nclass ODTDropTarget(wx.FileDropTarget):\n    """"""\n    """"""\n    def __init__(self, parent):\n        wx.FileDropTarget.__init__(self)\n        self.parent = parent\n\n    def OnDropFiles(self, x, y, filenames):\n        """"""\n        """"""\n        namepotential = filterOnExtensions([""odt""], filenames)\n        if not self.parent.batchModeCheckbox.GetValue() or not self.parent.digest:\n            #normal mode\n            if namepotential:\n                self.parent._importFile(namepotential[0])\n            return 0\n        else:\n            #batch mode\n            for fname in namepotential:\n                interp, outDir = self.parent._lightImportFile(fname)\n                outfname = fname.rsplit(os.path.sep, 1)[1].split(""."")[0] + "".txt""\n                print(outDir, outfname)\n                odtchomp.write(outDir + os.path.sep + outfname, interp, self.parent.delim, self.parent.watching)\n            return 1\n\n\n\n########\n# MAIN #\n########\nif __name__ == ""__main__"":\n    app = wx.App(None)\n    BigBoss = MainFrame()\n    app.MainLoop()\n'"
oommftools/user_interfaces/gui/oommfconvert.py,0,"b'\n""""""\nOOMMFConvert\nCopyright (C) 2010  Mark Mascaro\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\n""""""\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import absolute_import\n\nfrom builtins import str\nfrom builtins import range\nfrom past.utils import old_div\nfrom wx import adv\nimport wx, os, sys, subprocess, shutil, tempfile, math, re, time, imp\nfrom fnameutil import filterOnExtensions\nfrom core.oommfdecode import slowlyPainfullyMaximize\nimport _about as about\nfrom core import oommfconvert as oommfconvert\n\n#########\n# About #\n#########\n\nVERSION = about.__version__\nNAME = ""OOMMFConvert""\nLICENSE = about.__license__\nCOPYRIGHT = about.__copyright__\nWEBSITE = about.__uri__\nDESCRIPTION = """"""OOMMFConvert is an OOMMF postprocessing tool for\ngenerating bitmap and movie files from OMF files\nusing a simple drag-and-drop interface.\nIt uses OOMMF\'s own avf2ppm utility\nand employs FFmpeg to link images.\n\\nOOMMFConvert is part of OOMMFTools.""""""\n\n########\n# DECS #\n########\n\nMODE = \'advanced\'\n#Determine if workarounds are necessary\nPY2EXE_COMPENSATION = hasattr(sys, ""frozen"") or hasattr(sys, ""importers"") or imp.is_frozen(""__main__"")\n#Codecs: ffmpeg signature, file extension, short name\nCODECS = {""HuffYUV"": (r"" -vcodec huffyuv "","".avi"", ""HuffYUV""),\n          ""MPEG4"": (r"" -sameq "","".mp4"",""MPEG4""),\n          ""DivX 3"": (r"" -sameq -vcodec msmpeg4 "","".avi"",""DivX3""),\n          ""H263+"": (r"" -vcodec h263p "","".avi"",""H263+"")}\n\nif __name__ == ""__main__"":\n    app = wx.App(None)\n    #app = wx.App(redirect=True)\n    #app = wx.App(redirect=True, filename=""oommfconvert.log"")\n\n    #app.SetOutputWindowAttributes(""OOMMF Console Log"", (-1,-1), (550, 400))\n\nSETUP_LOAD = 5\nRENDER_LOAD = 10\nCLEANUP_LOAD = 5\nFRAMEDUPE_LOAD = 1\nMOVIE_LOAD = 50\n\nif PY2EXE_COMPENSATION:\n    print(""Py2EXE detected. Will perform defensive stdin redirection."")\n\n############\n# GUI BODY #\n############\n\nclass MainFrame(wx.Frame):\n    def __init__(self, manager=None):\n        wx.Frame.__init__(self, manager, -1, "" "".join([NAME, VERSION]), size=(700,700))\n\n        BigFont = wx.Font(16, wx.FONTFAMILY_DEFAULT, style=wx.NORMAL, weight=wx.FONTWEIGHT_BOLD)\n        TinyFont = wx.Font(8, wx.FONTFAMILY_DEFAULT, style=wx.NORMAL, weight=wx.FONTWEIGHT_NORMAL)\n\n        self.dt = OOMMFSelectiveTarget(self)\n        self.SetDropTarget(self.dt)\n        self.config = None\n        self.manager = manager\n        self.Bind(wx.EVT_CLOSE, self.onClose)\n        self.OOMMFPath = oommfconvert.getOOMMFPath(""."" + os.path.sep + ""oommf.path"")\n\n        #A very simple menubar\n        menubar = wx.MenuBar()\n        about = wx.Menu()\n        about.Append(999, \'About\', \'Program information and license\')\n        menubar.Append(about, ""About"")\n        self.SetMenuBar(menubar)\n\n        self.Bind(wx.EVT_MENU, self.showAbout, id=999)\n\n        #NOW we can deal with actual GUI stuff\n        panel = wx.Panel(self, -1)\n\n        #Oops, safety for resize events\n        self.panel = panel\n\n        #TODO : Deal with DropTarget\n\n        #Main sizer\n        sizer = wx.BoxSizer(wx.VERTICAL)\n\n        #OOMMF configuration part\n\n        #Need to block this out so we can have the script call overloaded. I blame ActiveTcl. A lot.\n\n        titleText = wx.StaticText(panel, -1, ""Path to OOMMF"")\n        titleText.SetFont(BigFont)\n        sizer.Add(titleText, 0, wx.ALIGN_CENTER | wx.TOP, 10)\n\n\n        hsizer = wx.BoxSizer(wx.HORIZONTAL)\n        self.TclCall = wx.ComboBox(panel, 101, choices=[""tclsh"",""tclsh85""])\n        self.TclCall.SetStringSelection(""tclsh"")\n        hsizer.Add(self.TclCall, 0, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, 20)\n\n        self.OOMMFPathLabel = wx.StaticText(panel, -1, ""OOMMF not located."", style = wx.ALIGN_CENTER | wx.ST_NO_AUTORESIZE | wx.ALIGN_CENTER_VERTICAL)\n        if self.OOMMFPath: self.OOMMFPathLabel.SetLabel(self.OOMMFPath)\n        hsizer.Add(self.OOMMFPathLabel, 0, wx.ALIGN_CENTER | wx.ALIGN_CENTER_VERTICAL)\n\n        sizer.Add(hsizer, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)\n\n        hsizer = wx.BoxSizer(wx.HORIZONTAL)\n        hsizer.Add(wx.StaticText(panel, -1, ""Drag and drop or"", style=wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL), 0, wx.ALIGN_RIGHT | wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 6)\n        self.LoadOOMMFButton = wx.Button(panel, 10, ""Load OOMMF"")\n        self.Bind(wx.EVT_BUTTON, self.GUILocateOOMMF, id=10)\n        hsizer.Add(self.LoadOOMMFButton, 0)\n        sizer.Add(hsizer, 0, wx.ALIGN_CENTER | wx.BOTTOM, 10)\n\n\n\n        sizer.Add(wx.StaticLine(panel, -1), 0, wx.EXPAND | wx.BOTTOM, 10)\n\n        #Conf-file configuration part\n\n\n        titleText = wx.StaticText(panel, -1, ""Configuration File"")\n        titleText.SetFont(BigFont)\n        sizer.Add(titleText, 0, wx.ALIGN_CENTER | wx.TOP, 10)\n\n        #Now we need a pile of intermediate sizers, sadly\n        self.ConfPathLabel = wx.StaticText(panel, -1, ""No config loaded."", style = wx.EXPAND | wx.ALIGN_CENTER | wx.ST_NO_AUTORESIZE)\n        sizer.Add(self.ConfPathLabel, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)\n\n        self.autoMaxVectors = wx.CheckBox(panel, -1, ""Generate Vector Field Maxima"")\n        self.autoMaxVectors.SetValue(False)\n        sizer.Add(self.autoMaxVectors, 0, wx.ALIGN_CENTER | wx.BOTTOM, 10)\n\n        psizer = wx.BoxSizer(wx.HORIZONTAL)\n        psizer.Add(wx.StaticText(panel, -1, ""Drag and drop or"", style=wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL), 0, wx.ALIGN_RIGHT | wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 6)\n        self.LoadConfButton = wx.Button(panel, 20, ""Load Config"")\n        self.Bind(wx.EVT_BUTTON, self.GUILocateConf, id=20)\n        psizer.Add(self.LoadConfButton, 0)\n\n        sizer.Add(psizer, 0, wx.ALIGN_CENTER | wx.BOTTOM | wx.BOTTOM, 10)\n        sizer.Add(wx.StaticLine(panel, -1), 0, wx.EXPAND | wx.BOTTOM, 10)\n\n        # Fancy Stuff\n        titleText = wx.StaticText(panel, -1, ""Images"")\n        titleText.SetFont(BigFont)\n        sizer.Add(titleText, 0, wx.ALIGN_CENTER | wx.TOP, 10)\n\n        imsizer = wx.BoxSizer(wx.HORIZONTAL)\n\n        self.doImages = wx.CheckBox(panel, -1, ""Make Bitmaps"")\n        self.doImages.SetValue(True)\n        imsizer.Add(self.doImages, 0, wx.ALIGN_CENTER | wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, 30)\n\n        hsizer = wx.BoxSizer(wx.HORIZONTAL)\n        hsizer.Add(wx.StaticText(panel, -1, ""Image Magnify%"", style=wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL), 0, wx.ALIGN_RIGHT | wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 6)\n        self.magnifierSpin = wx.SpinCtrl(panel, 100, ""100"", min=100, max=1000, size=(50,-1))\n        hsizer.Add(self.magnifierSpin, 0)\n        imsizer.Add(hsizer, 0)\n\n\n        sizer.Add(imsizer, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)\n        sizer.Add(wx.StaticLine(panel, -1), 0, wx.EXPAND | wx.BOTTOM, 10)\n\n        # Fancy Stuff\n        titleText = wx.StaticText(panel, -1, ""Movies"")\n        titleText.SetFont(BigFont)\n        sizer.Add(titleText, 0, wx.ALIGN_CENTER | wx.TOP, 10)\n\n        hsizer = wx.GridSizer(2,3,7,7)\n\n        self.doMovie = wx.CheckBox(panel, -1, ""Make Movies"")\n        hsizer.Add(self.doMovie, 0, wx.ALIGN_CENTER | wx.ALIGN_CENTER_VERTICAL)\n\n        joiner = wx.BoxSizer(wx.VERTICAL)\n        a = wx.StaticText(panel, -1, ""HuffYUV is superior."")\n        a.SetFont(TinyFont)\n        joiner.Add(a, 0, wx.ALIGN_CENTER)\n        a = wx.StaticText(panel, -1, ""Consider installing it."")\n        a.SetFont(TinyFont)\n        joiner.Add(a, 0, wx.ALIGN_CENTER)\n        hsizer.Add(joiner, 0, wx.ALIGN_CENTER)\n\n        joiner = wx.BoxSizer(wx.VERTICAL)\n        a = wx.StaticText(panel, -1, ""Magnifying video may fail"")\n        a.SetFont(TinyFont)\n        joiner.Add(a, 0, wx.ALIGN_CENTER)\n        a = wx.StaticText(panel, -1, ""violently. User\'s risk."")\n        a.SetFont(TinyFont)\n        joiner.Add(a, 0, wx.ALIGN_CENTER)\n        hsizer.Add(joiner)\n\n\n        joiner = wx.BoxSizer()\n        self.movieFPS = wx.SpinCtrl(panel, 201, ""25"", min=1, max=25, size=(50,-1))\n        joiner.Add(self.movieFPS, 0, wx.RIGHT, 10)\n        joiner.Add(wx.StaticText(panel, -1, ""FPS""), 0, wx.ALIGN_CENTER_VERTICAL)\n        hsizer.Add(joiner, 0, wx.ALIGN_CENTER)\n\n        self.movieCodec = wx.ComboBox(panel, 200, choices = list(CODECS.keys()), style=wx.CB_READONLY)\n        self.movieCodec.SetStringSelection(""HuffYUV"")\n        hsizer.Add(self.movieCodec, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALIGN_CENTER)\n\n        bsizer = wx.BoxSizer(wx.HORIZONTAL)\n        bsizer.Add(wx.StaticText(panel, -1, ""Movie Magnify%"", style=wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL), 0, wx.ALIGN_RIGHT | wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 6)\n        self.movieMagnifierSpin = wx.SpinCtrl(panel, 300, ""100"", min=100, max=300, size=(50,-1))\n        bsizer.Add(self.movieMagnifierSpin, 0, wx.ALIGN_CENTER_VERTICAL)\n        hsizer.Add(bsizer, 0, wx.ALIGN_CENTER_VERTICAL)\n\n\n        sizer.Add(hsizer, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)\n        sizer.Add(wx.StaticLine(panel, -1), 0, wx.EXPAND | wx.BOTTOM, 10)\n\n\n        #Clarification\n\n        ins = wx.StaticText(panel, -1, ""Drop OOMMF Files Here!"")\n        ins.SetFont(BigFont)\n        sizer.Add(ins, 0, wx.ALIGN_CENTER | wx.ALIGN_CENTER_VERTICAL | wx.BOTTOM | wx.TOP, 60)\n\n        #Cleanup initialization\n        panel.SetSizer(sizer)\n\n        if self.manager:\n            self.CenterOnParent()\n        panel.Fit()\n        self.Show()\n\n    def onClose(self, evt):\n        if self.manager:\n            self.manager.droppedWindow(self)\n        self.Destroy()\n\n    def showAbout(self, evt):\n        info = wx.adv.AboutDialogInfo()\n        mydesc = DESCRIPTION\n        mylicense = LICENSE\n        info.SetName(NAME)\n        info.SetVersion(VERSION)\n        info.SetDescription(\'\'.join(mydesc))\n        info.SetLicense(\'\'.join(mylicense))\n        info.SetCopyright(COPYRIGHT)\n        info.SetWebSite(WEBSITE)\n        wx.adv.AboutBox(info)\n\n    def GUILocateOOMMF(self, evt):\n        dlg = wx.FileDialog(self, ""Find OOMMF Location"", os.getcwd(), """", ""OOMMF TCL File (*.tcl)|*.tcl"",wx.FD_OPEN)\n        if dlg.ShowModal() == wx.ID_OK and dlg.GetFilename():\n            filename = dlg.GetPath()\n            #self.fileLabel.SetLabel(""Open: "" + os.getcwd() + os.path.sep + dlg.GetFilename())\n            #self.digest = chomp(dlg.GetPath())\n            #self.leftbox.Set(self.digest.getNames())\n            self.locateOOMMF(filename)\n\n    def locateOOMMF(self, path):\n        self.OOMMFPath = path\n        self.OOMMFPathLabel.SetLabel(path)\n        f = open(""oommf.path"", ""w"")\n        f.write(path)\n        f.close()\n        try:\n            self.panel.SendSizeEvent()\n        except:\n            print(""wx.Panel.SendSizeEvent() missed - probably using old wxPython. Cosmetic bug will result."")\n\n    def GUILocateConf(self, evt):\n        dlg = wx.FileDialog(self, ""Select Configuration File"", os.getcwd(), """", ""mmDisp Config File (*.config)|*.config"",wx.FD_OPEN)\n        if dlg.ShowModal() == wx.ID_OK and dlg.GetFilename():\n            filename = dlg.GetPath()\n            #self.fileLabel.SetLabel(""Open: "" + os.getcwd() + os.path.sep + dlg.GetFilename())\n            #self.digest = chomp(dlg.GetPath())\n            #self.leftbox.Set(self.digest.getNames())\n            self.locateConf(filename)\n\n    def locateConf(self, path):\n        self.config = path\n        self.ConfPathLabel.SetLabel(path)\n        try:\n            self.panel.SendSizeEvent()\n        except:\n            print(""wx.Panel.SendSizeEvent() missed - probably using old wxPython. Cosmetic bug will result."")\n\n\n###########\n# BACKEND #\n###########\n\nclass OOMMFSelectiveTarget(wx.FileDropTarget):\n    def __init__(self, parent):\n        wx.FileDropTarget.__init__(self)\n        self.parent = parent\n\n    def OnDropFiles(self, x, y, filenames):\n        #Find OOMMF, then a config, then files\n        oommf = filterOnExtensions([""tcl""], filenames)\n        if oommf:\n            #What did you DO? Only the last one counts!\n            self.parent.locateOOMMF(oommf[-1])\n        config = filterOnExtensions([""conf"", ""config"", ""cnf""], filenames)\n        if config:\n            #Again, only the last conf file dropped counts.\n            self.parent.locateConf(config[-1])\n\n        if not (self.parent.config and self.parent.OOMMFPath):\n            return 0\n\n        #Try to save a lot of work - only do magic if OMF-type files were dropped.\n        targets = filterOnExtensions([""omf"",""ovf"",""oef"",""ohf""], filenames)\n        if not targets: return 0\n\n        #Save more work by verifying that the user actually wants to make some sort of thing.\n        if not self.parent.doImages.GetValue() and not self.parent.doMovie.GetValue():\n            #Er... you don\'t want to do anything?\n            return 0\n\n        #Convince user that everything is OK, and provide me with entertainment.\n        #Set up a dialog box that will track progress.\n\n        dial = self.initializeProgressBar(targets)\n\n        #To avoid some Py2EXE funkiness, we may need to redirect stdin.\n        #Figure out where it needs to go, and catch that.\n\n        childstd = self.findStandardIn()\n\n        #We are now in the danger zone where the progress bar can get locked, and we\n        #are going to shield that with some top-level exception handling\n\n        try:\n\n            dial.workDone(SETUP_LOAD, ""Checking for Movies"")\n\n\n            #The first thing to do is try to make movies - in some cases, this process will leave behind\n            #the images we need, and we can skip the image step entirely.\n\n            print(""Entering movie mode."")\n            if self.parent.doMovie.GetValue():\n                #Make some movies. This also hands off the progressDialog, so it can be updated.\n                self.doMovies(targets, childstd, dial)\n                #Finish making some movies.\n                dial.workDone(CLEANUP_LOAD, ""Doing Images"")\n\n            #Awkward short-circuit - If you made movies and they have the same magnification as the images, you get to keep the images!\n            if self.parent.doMovie.GetValue() and self.parent.movieMagnifierSpin.GetValue() == self.parent.magnifierSpin.GetValue():\n                dial.finish()\n                return 1\n\n            if self.parent.doImages.GetValue():\n                #Oh well, I guess you\'re stuck making images. Make them!\n                self.doImages(targets, childstd, dial)\n\n\n            dial.workDone(CLEANUP_LOAD, ""All Done!"")\n        except Exception as e:\n            wx.MessageBox(\'Unpacking error: \' + repr(e), ""Error"")\n            print(e)\n        finally:\n            dial.finish()\n            return 1\n\n\n    def findStandardIn(self):\n        #Py2EXE is bad. Failing to set this correctly can cause the packaged version to explode on failure to\n        #correctly grab a handle to a shell-like thing, so we deflect that by redirecting stdin to a file, which will always be empty. ""Oops.""\n        if PY2EXE_COMPENSATION:\n            childstd = file(\'null_data\', \'a\') #Detection methods unreliable\n            print(""Enforced running windows - py2exe mode. Using dump file stdin."")\n        elif hasattr(sys.stdin, \'fileno\'):\n            childstd = sys.stdin\n            print(""Using standard stdin"")\n        elif hasattr(sys.stdin, \'_file\') and hasattr(sys.stdin._file, \'fileno\'):\n            childstd = sys.stdin._file\n            print(""Using hacked stdin adjustment - probably running Windows."")\n        else:\n            childstderr = file(\'null_data\', \'a\')\n            print(""Definitely using Windows. Using fake stdin."")\n        return childstd\n\n    def initializeProgressBar(self, targetList):\n        #Cost of setup\n        workload = SETUP_LOAD\n        #Cost of a single avf2ppm render\n        workload += RENDER_LOAD * len(targetList)\n        workload += CLEANUP_LOAD\n        if self.parent.doMovie.GetValue():\n            #Cost of making a movie with ffmpeg; may add cleanup\n            workload += MOVIE_LOAD\n            if self.parent.doImages.GetValue() and not self.parent.movieMagnifierSpin.GetValue() == self.parent.magnifierSpin.GetValue():\n                #Surprise! You get to rerender at a different magnification!\n                workload += RENDER_LOAD * len(targetList) + CLEANUP_LOAD #And cleanup\n            #Cost of frameduping\n            workload += FRAMEDUPE_LOAD * (int(old_div(25, self.parent.movieFPS.GetValue())) * len(targetList))\n\n        dial = SupportDialog(""Render In Progress"", """", maximum=workload,parent=self.parent)\n        dial.Update(0, ""This is a suitably long message to ensure the window title renders correctly"") #Because this class lacks a size control!\n        dial.Fit()\n        dial.Update(0, ""Initializing Render"")\n        dial.CenterOnParent()\n        return dial\n\n   \n    def doImages(self, targetList, stdinRedirect, dial):\n        dial.workDone(0, ""Rendering"")\n        imageConfig = {\'magnifierSpin\': self.parent.magnifierSpin.GetValue(),\n                       \'autoMaxVectors\': self.parent.autoMaxVectors.GetValue(),\n                       \'config\': self.parent.config}\n        oommfconvert.doImages(targetList, stdinRedirect, imageConfig, self.parent.TclCall.GetValue(), self.parent.OOMMFPath)\n        dial.workDone(RENDER_LOAD, ""Rendering"")\n        dial.workDone(0, ""Cleaning Up"")\n\n    def doMovies(self, targetList, stdinRedirect, dial):\n        print(\'in the movie function (not core)\')\n        dial.workDone(0, ""Rendering"")\n        imageConfig = {\'magnifierSpin\': self.parent.magnifierSpin.GetValue(),\n                       \'autoMaxVectors\': self.parent.autoMaxVectors.GetValue(),\n                       \'config\': self.parent.config}\n        oommfconvert.doMovies(targetList, stdinRedirect, imageConfig,self.parent.movieCodec.GetValue(), self.parent.movieFPS.GetValue(), self.parent.TclCall.GetValue(), self.parent.OOMMFPath, self.parent.doImages.GetValue(), CODECS)\n        dial.workDone(0, ""Rendering Movie"")\n        dial.workDone(MOVIE_LOAD, ""Cleaning"")\n        return None\n\n\nclass SupportDialog(wx.ProgressDialog):\n    def __init__(self, title, message, **kwargs):\n        wx.ProgressDialog.__init__(self, title, message, **kwargs)\n        self._workDone = 0\n        self.workmax = kwargs[""maximum""]\n\n    def workDone(self, delta, newmsg):\n        self._workDone += delta\n        self.Update(self._workDone, newmsg)\n\n    def finish(self):\n        self.Update(self.workmax, ""Done!"")\n        self.Destroy()\n########\n# MAIN #\n########\nif __name__ == ""__main__"":\n\tBigBoss = MainFrame()\n\tapp.MainLoop()\n'"
oommftools/user_interfaces/gui/oommfdecode.py,0,"b'\n""""""\nOOMMFDecode\nCopyright (C) 2010  Mark Mascaro\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\n""""""\nfrom __future__ import print_function\nfrom __future__ import absolute_import\n\nfrom future import standard_library\nstandard_library.install_aliases()\nfrom builtins import hex\nfrom builtins import zip\nfrom builtins import range\nimport time\nfrom collections import defaultdict\nimport pickle as pickle\nfrom wx import adv\nimport os\nimport wx\nimport struct\nimport numpy as np\nimport scipy.io as spio\nfrom fnameutil import filterOnExtensions\nimport _about as about\nfrom core import oommfdecode\n\n#########\n# About #\n#########\n\nVERSION = about.__version__\nNAME = ""OOMMFDecode""\nLICENSE = about.__license__\nCOPYRIGHT = about.__copyright__\nWEBSITE = about.__uri__\nDESCRIPTION = """"""OOMMFDecode is an OOMMF postprocessing tool for\nconverting OVF files or batches of same into numpy\narrays or MATLAB data files. Just drag and drop.\n\\nOOMMFDecode is part of OOMMFTools.""""""\n\n\n########\n# DECS #\n########\n\nLASTPATH = os.getcwd()\nif __name__ == ""__main__"":\n    #app = wx.App(None)\n    #app = wx.App(None)\n    #app = wx.App(redirect=True)\n    app = wx.App(redirect=True, filename=""oommfdecode.log"")\n\n#######\n# GUI #\n#######\n\nclass MainFrame(wx.Frame):\n    """"""Main oommfdecode frame\n    """"""\n    def __init__(self, manager=None):\n        \n        wx.Frame.__init__(self, None, -1, "" "".join([NAME, VERSION]), size=(340, 400))\n\n        BigFont = wx.Font(16, wx.FONTFAMILY_DEFAULT, style=wx.NORMAL, weight=wx.FONTWEIGHT_BOLD)\n        TinyFont = wx.Font(8, wx.FONTFAMILY_DEFAULT, style=wx.NORMAL, weight=wx.FONTWEIGHT_NORMAL)\n\n        self.dt = OOMMFSelectiveTarget(self)\n        self.SetDropTarget(self.dt)\n        self.manager = manager\n\n        self.Bind(wx.EVT_CLOSE, self.onClose)\n\n        #A very simple menubar\n        menubar = wx.MenuBar()\n        about = wx.Menu()\n        about.Append(999, \'About\', \'Program information and license\')\n        menubar.Append(about, ""About"")\n        self.SetMenuBar(menubar)\n\n        self.Bind(wx.EVT_MENU, self.showAbout, id=999)\n\n        #NOW we can deal with actual GUI stuff - store a reference for forced resize, if it comes up\n        panel = wx.Panel(self, -1)\n        self.panel = panel\n\n        sizer = wx.BoxSizer(wx.VERTICAL)\n\n        titleText = wx.StaticText(panel, -1, ""OMF File Decoding"")\n        titleText.SetFont(BigFont)\n        sizer.Add(titleText, 0, wx.ALIGN_CENTER | wx.TOP, 24)\n\n        sizer.Add(wx.StaticLine(panel, -1), 0, wx.EXPAND | wx.TOP | wx.BOTTOM, 18)\n\n        self.doNumpy = wx.CheckBox(panel, -1, ""Create pickled numpy"")\n        sizer.Add(self.doNumpy, 0, wx.ALIGN_CENTER | wx.ALIGN_CENTER_VERTICAL)\n\n        self.doMATLAB = wx.CheckBox(panel, -1, ""Create MATLAB data"")\n        sizer.Add(self.doMATLAB, 0, wx.ALIGN_CENTER | wx.ALIGN_CENTER_VERTICAL)\n\n        sizer.Add(wx.StaticLine(panel, -1), 0, wx.EXPAND | wx.TOP, 18)\n\n        ins = wx.StaticText(panel, -1, ""Drop OOMMF Files Here!"")\n        ins.SetFont(BigFont)\n        sizer.Add(ins, 0, wx.ALIGN_CENTER | wx.ALIGN_CENTER_VERTICAL | wx.BOTTOM | wx.TOP, 80)\n\n        panel.SetSizer(sizer)\n        if self.manager:\n            self.CenterOnParent()\n        panel.Fit()\n        self.Show()\n\n    def gatherData(self, data, headers, extraData):\n        """"""\n        """"""\n        global LASTPATH\n        #Outputs are array, headers, filenam\n        if self.doNumpy.GetValue():\n            with wx.FileDialog(self, \'Export Pickled numpy Data\',\n                               LASTPATH, """", ""Pickled Data (*.pnp)|*.pnp"",\n                               wx.FD_SAVE) as dlg:\n                if dlg.ShowModal() == wx.ID_OK and dlg.GetFilename():\n                    filename = dlg.GetPath()\n                    LASTPATH = os.path.dirname(filename)\n                    oommfdecode.pickleArray(data, headers, extraData, filename)\n                elif dlg.ShowModal() == wx.ID_CANCEL:\n                    return # the user changed their mind\n\n        if self.doMATLAB.GetValue():\n            with wx.FileDialog(self, \'Export MATLAB Data\', LASTPATH, """",\n                               ""MATLAB Data (*.mat)|*.mat"",\n                               wx.FD_SAVE) as dlg:\n                if dlg.ShowModal() == wx.ID_OK and dlg.GetFilename():\n                    filename = dlg.GetPath()\n                    LASTPATH = os.path.dirname(filename)\n                    oommfdecode.matlabifyArray(data, headers, extraData, filename)\n                elif dlg.ShowModal() == wx.ID_CANCEL:\n                    return # the user changed their mind\n\n    def showAbout(self, evt):\n        """"""\n        """"""\n        info = wx.adv.AboutDialogInfo()\n        mydesc = DESCRIPTION\n        mylicense = LICENSE\n        info.SetName(NAME)\n        info.SetVersion(VERSION)\n        info.SetDescription(\'\'.join(mydesc))\n        info.SetLicense(\'\'.join(mylicense))\n        info.SetCopyright(COPYRIGHT)\n        info.SetWebSite(WEBSITE)\n        wx.adv.AboutBox(info)\n\n    def onClose(self, evt):\n        """"""\n        """"""\n        if self.manager:\n            self.manager.droppedWindow(self)\n        self.Destroy()\n\nclass SupportDialog(wx.ProgressDialog):\n    """"""\n    """"""\n    def __init__(self, title, message, **kwargs):\n        wx.ProgressDialog.__init__(self, title, message, **kwargs)\n        self._workDone = 0\n        self.workmax = kwargs[""maximum""]\n\n    def workDone(self, delta, newmsg):\n        """"""\n        """"""\n        self._workDone += delta\n        self.Update(self._workDone, newmsg)\n\n    def finish(self):\n        """"""\n        """"""\n        self.Update(self.workmax, ""Done!"")\n\n####################\n# BACKEND DECODING #\n####################\n\nclass OOMMFSelectiveTarget(wx.FileDropTarget):\n    """"""\n    """"""\n    def __init__(self, parent):\n        wx.FileDropTarget.__init__(self)\n        self.parent = parent\n\n    def OnDropFiles(self, x, y, filenames):\n        """"""\n        """"""\n        oommf = filterOnExtensions([""omf"", ""ovf"", ""oef"", ""ohf""], filenames)\n        if not oommf or not (self.parent.doNumpy.GetValue() or self.parent.doMATLAB.GetValue()):\n            return 0 #You got dropped some bad files!\n        global LASTPATH\n        LASTPATH = os.path.dirname(oommf[0])\n        arrays, headers, extra = self.groupUnpack(oommf,\n                                             SupportDialog(""Decode in Progress"",\n                                                           ""Decoding..."",\n                                                           maximum=len(oommf)))\n\n        #One final step before we\'re done - let\'s try to sort based on the sim time\n        #using a standard decorate-sort-undecorate, with a twist for the variable number of keys\n\n        #Let\'s start by finding the original indices - making a copy is key\n\n        arrays, extra = oommfdecode.sortBySimTime(extra, arrays)\n\n        self.parent.gatherData(arrays, headers, extra)\n        return 1\n\n\n    def groupUnpack(self, targetlist, progdialog=None):\n        """"""\n        """"""\n        try:\n            (decodedArrays, headers, extraData) = oommfdecode.groupUnpack(targetlist)\n            if progdialog:\n                progdialog.workDone(1, ""Decoding..."")\n                time.sleep(0.01) #Should facilitate redraw thread coming to life\n        except Exception as e:\n            if progdialog: progdialog.finish()\n            wx.MessageBox(\'Unpacking error: \' + repr(e), ""Error"")\n            print(e)\n        else:\n            if progdialog: progdialog.finish()\n        return (decodedArrays, headers, extraData)\n\n########\n# MAIN #\n########\nif __name__ == ""__main__"":\n    BigBoss = MainFrame()\n    app.MainLoop()\n'"
