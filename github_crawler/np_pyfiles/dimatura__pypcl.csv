file_path,api_count,code
setup.py,0,"b'import os\nimport re\nimport sys\nimport platform\nimport subprocess\n\nfrom setuptools import setup, Extension\nfrom setuptools.command.build_ext import build_ext\nfrom distutils.version import LooseVersion\n\n\nclass CMakeExtension(Extension):\n    def __init__(self, name, sourcedir=\'\'):\n        Extension.__init__(self, name, sources=[])\n        self.sourcedir = os.path.abspath(sourcedir)\n\n\nclass CMakeBuild(build_ext):\n    def run(self):\n        try:\n            out = subprocess.check_output([\'cmake\', \'--version\'])\n        except OSError:\n            raise RuntimeError(""CMake must be installed to build the following extensions: "" +\n                               "", "".join(e.name for e in self.extensions))\n\n        if platform.system() == ""Windows"":\n            cmake_version = LooseVersion(re.search(r\'version\\s*([\\d.]+)\', out.decode()).group(1))\n            if cmake_version < \'3.1.0\':\n                raise RuntimeError(""CMake >= 3.1.0 is required on Windows"")\n\n        for ext in self.extensions:\n            self.build_extension(ext)\n\n    def build_extension(self, ext):\n        extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.name)))\n        cmake_args = [\'-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=\' + extdir,\n                      \'-DPYTHON_EXECUTABLE=\' + sys.executable]\n\n        cfg = \'Debug\' if self.debug else \'Release\'\n        build_args = [\'--config\', cfg]\n\n        if platform.system() == ""Windows"":\n            cmake_args += [\'-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}\'.format(cfg.upper(), extdir)]\n            if sys.maxsize > 2**32:\n                cmake_args += [\'-A\', \'x64\']\n            build_args += [\'--\', \'/m\']\n        else:\n            cmake_args += [\'-DCMAKE_BUILD_TYPE=\' + cfg]\n            build_args += [\'--\', \'-j2\']\n\n        env = os.environ.copy()\n        env[\'CXXFLAGS\'] = \'{} -DVERSION_INFO=\\\\""{}\\\\""\'.format(env.get(\'CXXFLAGS\', \'\'),\n                                                              self.distribution.get_version())\n        if not os.path.exists(self.build_temp):\n            os.makedirs(self.build_temp)\n        subprocess.check_call([\'cmake\', ext.sourcedir] + cmake_args, cwd=self.build_temp, env=env)\n        subprocess.check_call([\'cmake\', \'--build\', \'.\'] + build_args, cwd=self.build_temp)\n\nsetup(\n    name=\'pypcl\',\n    version=\'0.0.1\',\n    author=\'Daniel Maturana\',\n    author_email=\'dimatura@cmu.edu\',\n    description=\'A pybind11-based wrapper for a subset of PCL\',\n    long_description=\'\',\n    packages=[\'pypcl\'],\n    ext_modules=[CMakeExtension(\'libpypcl\')],\n    cmdclass=dict(build_ext=CMakeBuild),\n    zip_safe=False,\n)\n'"
pypcl/__init__.py,0,b'\nimport libpypcl\nfrom libpypcl import *\n\nfrom utils import *\n'
pypcl/utils.py,3,"b""import numpy as np\n\nimport libpypcl\n\n\n__all__ = ['pclpc2_from_ndarray',\n           'xyz_from_structured_array',\n           'rgb_from_structured_array',\n           ]\n\n\ndef pclpc2_from_ndarray(arr):\n    # TODO for some reason can't do this entirely in c++\n    fields = [(n,)+arr.dtype.fields[n] for n in arr.dtype.names]\n    return libpypcl._pclpc2_from_ndarray(arr, fields)\n\n\ndef xyz_from_structured_array(arr):\n    for fld in 'xyz':\n        if not fld in arr.dtype.fields:\n            raise ValueError('input lacks %s field' % fld)\n    out = np.empty((len(arr), 3), dtype='f4')\n    out[:, 0] = arr['x']\n    out[:, 1] = arr['y']\n    out[:, 2] = arr['z']\n    return out\n\n\ndef rgb_from_structured_array(arr, decode_rgb=True):\n\n    def has_encoded_rgb(_arr):\n        return 'rgb' in _arr.dtype.fields\n\n    def has_separate_rgb(_arr):\n        for fld in 'rgb':\n            if fld not in arr.dtype:\n                return False\n        return True\n\n    if not (has_encoded_rgb(arr) or has_separate_rgb(arr)):\n        return ValueError('input lacks rgb')\n\n    if decode_rgb:\n        if has_encoded_rgb(arr):\n            rgbtmp = arr['rgb'].copy().view('u1')\n            rgbdec = rgbtmp.reshape((-1, 4))[:, :3][:, ::-1]\n            return rgbdec.copy()\n        else:\n            out = np.empty((len(arr), 3), dtype='u1')\n            out[:, 0] = arr['r']\n            out[:, 1] = arr['g']\n            out[:, 2] = arr['b']\n            return out\n    else:\n        if has_encoded_rgb(arr):\n            return arr['rgb'].copy()\n        else:\n            r = arr['r'].astype('u4')\n            g = arr['g'].astype('u4')\n            b = arr['b'].astype('u4')\n            rgb = np.array((r << 16) | (g << 8) | d,\n                           dtype='u4')\n            return rgb\n"""
tests/test_pointcloud.py,0,"b""import pytest\n\nimport pypcl\n\ndef test_pointcloudxyz():\n    pc = pypcl.PointCloudXYZ()\n\n\ndef test_pointcloudxyz():\n    pc = pypcl.PointCloudXYZRGB()\n\n\ndef test_load():\n    pc = pypcl.load_pcd_pcxyz('test_data/bincomp.pcd')\n    assert(pc.size() == 3157)\n    assert(pc.width == 3157)\n    assert(pc.height == 1)\n"""
