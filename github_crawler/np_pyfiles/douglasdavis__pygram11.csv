file_path,api_count,code
setup.py,0,"b'# MIT License\n#\n# Copyright (c) 2020 Douglas Davis\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport codecs\nimport glob\nimport os\nimport re\nimport pathlib\nimport subprocess\nimport sys\nimport tempfile\n\nimport setuptools\nfrom setuptools import setup\nfrom setuptools.extension import Extension\n\n\ndef has_flag(compiler, flag):\n    """"""check if compiler has compatibility with the flag""""""\n    with tempfile.NamedTemporaryFile(""w"", suffix="".cpp"") as f:\n        f.write(""int main (int argc, char** argv) { return 0; }"")\n        try:\n            compiler.compile([f.name], extra_postargs=[flag])\n        except setuptools.distutils.errors.CompileError:\n            return False\n    return True\n\n\ndef get_cpp_std_flag():\n    compiler = setuptools.distutils.ccompiler.new_compiler()\n    setuptools.distutils.sysconfig.customize_compiler(compiler)\n    if has_flag(compiler, ""-std=c++14""):\n        return ""-std=c++14""\n    elif has_flag(compiler, ""-std=c++11""):\n        return ""-std=c++11""\n    else:\n        raise RuntimeError(""C++11 (or later) compatible compiler required"")\n\n\ndef get_compile_flags(is_cpp=False):\n    """"""get the compile flags""""""\n    if is_cpp:\n        cpp_std = get_cpp_std_flag()\n    cflags = [""-Wall"", ""-Wextra""]\n    debug_env = os.getenv(""PYGRAM11_DEBUG"")\n    if debug_env is None:\n        cflags += [""-g0""]\n    else:\n        cflags += [""-g""]\n    if sys.platform.startswith(""darwin""):\n        if is_cpp:\n            cflags += [""-fvisibility=hidden"", ""-stdlib=libc++"", cpp_std]\n        cflags += [""-Xpreprocessor"", ""-fopenmp""]\n    else:\n        if is_cpp:\n            cflags += [""-fvisibility=hidden"", cpp_std]\n        cflags += [""-fopenmp""]\n    return cflags\n\n\ndef get_link_flags(is_cpp=False):\n    envPREFIX = os.getenv(""PREFIX"")\n    lflags = []\n    if sys.platform.startswith(""darwin""):\n        if envPREFIX is not None:\n            lflags += [""-Wl,-rpath,{}/lib"".format(envPREFIX)]\n        lflags += [""-lomp""]\n    else:\n        lflags += [""-lgomp""]\n    return lflags\n\n\ndef has_openmp():\n    test_code = """"""\n    #include <omp.h>\n    #include <stdio.h>\n    int main() {\n      #pragma omp parallel\n      printf(""nthreads=%d\\\\n"", omp_get_num_threads());\n      return 0;\n    }\n    """"""\n    has_omp = False\n    compiler = setuptools.distutils.ccompiler.new_compiler()\n    setuptools.distutils.sysconfig.customize_compiler(compiler)\n    cflags = get_compile_flags()\n    lflags = get_link_flags()\n    tmp_dir = tempfile.mkdtemp()\n    start_dir = pathlib.PosixPath.cwd()\n    try:\n        os.chdir(tmp_dir)\n        with open(""test_openmp.c"", ""w"") as f:\n            f.write(test_code)\n        os.mkdir(""obj"")\n        compiler.compile([""test_openmp.c""], output_dir=""obj"", extra_postargs=cflags)\n        objs = glob.glob(os.path.join(""obj"", ""*{}"".format(compiler.obj_extension)))\n        compiler.link_executable(objs, ""test_openmp"", extra_postargs=lflags)\n        output = subprocess.check_output(""./test_openmp"")\n        output = output.decode(sys.stdout.encoding or ""utf-8"").splitlines()\n        if ""nthreads="" in output[0]:\n            nthreads = int(output[0].strip().split(""="")[1])\n            if len(output) == nthreads:\n                has_omp = True\n            else:\n                has_omp = False\n        else:\n            has_omp = False\n    except (\n        setuptools.distutils.errors.CompileError,\n        setuptools.distutils.errors.LinkError,\n    ):\n        has_omp = False\n    finally:\n        os.chdir(start_dir)\n\n    return has_omp\n\n\ndef get_extensions():\n    c_cflags = get_compile_flags()\n    c_lflags = get_link_flags()\n    cpp_cflags = get_compile_flags(is_cpp=True)\n    cpp_lflags = get_link_flags(is_cpp=True)\n    extenmods = []\n    extenmods += [\n        Extension(\n            ""pygram11._backend1d"",\n            [os.path.join(""src"", ""_backend1d.cpp"")],\n            language=""c++"",\n            include_dirs=[""extern/pybind11/include""],\n            extra_compile_args=cpp_cflags,\n            extra_link_args=cpp_lflags,\n        ),\n        Extension(\n            ""pygram11._backend2d"",\n            [os.path.join(""src"", ""_backend2d.cpp"")],\n            language=""c++"",\n            include_dirs=[""extern/pybind11/include""],\n            extra_compile_args=cpp_cflags,\n            extra_link_args=cpp_lflags,\n        ),\n    ]\n    return extenmods\n\n\ndef read_files(*parts):\n    here = os.path.abspath(os.path.dirname(__file__))\n    with codecs.open(os.path.join(here, *parts), ""r"") as fp:\n        return fp.read()\n\n\ndef get_version(*file_paths):\n    version_file = read_files(*file_paths)\n    version_match = re.search(r""^__version__ = [\'\\""]([^\'\\""]*)[\'\\""]"", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(""Unable to find version string."")\n\n\nif not has_openmp():\n    sys.exit(\n        ""\\n""\n        ""****************************************************\\n""\n        ""* OpenMP not available, aborting installation.     *\\n""\n        ""* On macOS you can install `libomp` with Homebrew. *\\n""\n        ""* On Linux check your GCC installation.            *\\n""\n        ""****************************************************""\n    )\n\n\nsetup(\n    version=get_version(""src"", ""pygram11"", ""__init__.py""),\n    ext_modules=get_extensions(),\n    zip_safe=False,\n)\n'"
docs/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath(""..""))\n\nimport pygram11\n\n# -- Project information -----------------------------------------------------\n\nproject = ""pygram11""\ncopyright = ""2020, Doug Davis""\nauthor = ""Doug Davis""\n\n\nversion = pygram11.__version__\nrelease = pygram11.__version__\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    ""sphinx.ext.autodoc"",\n    ""sphinx.ext.autosummary"",\n    ""sphinx.ext.napoleon"",\n    ""sphinx.ext.intersphinx"",\n    ""sphinx.ext.mathjax"",\n    ""sphinx.ext.viewcode"",\n    ""pallets_sphinx_themes"",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [""_templates""]\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = "".rst""\n\n# The master toctree document.\nmaster_doc = ""index""\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [""_build"", ""Thumbs.db"", "".DS_Store""]\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = ""default""\n\nautodoc_typehints = ""none""\n\nhtml_logo = ""_static/logo.svg""\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = ""click""\n# html_theme = ""alabaster""\n# html_theme = ""sphinx_rtd_theme""\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {\n#     #""collapse_navigation"": False,\n#     ""display_version"": True,\n#     ""sticky_navigation"": True,\n# }\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [""_static""]\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = ""pygram11doc""\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, ""pygram11.tex"", ""pygram11 Documentation"", ""Douglas Davis"", ""manual"")\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, ""pygram11"", ""pygram11 Documentation"", [author], 1)]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        ""pygram11"",\n        ""pygram11 Documentation"",\n        author,\n        ""pygram11"",\n        ""One line description of project."",\n        ""Miscellaneous"",\n    )\n]\n\n\n# -- Options for Epub output -------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#\n# epub_identifier = \'\'\n\n# A unique identification for the text.\n#\n# epub_uid = \'\'\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [""search.html""]\n\n\n# -- Extension configuration -------------------------------------------------\n\n# -- Options for intersphinx extension ---------------------------------------\n\nintersphinx_mapping = {\n    ""python"": (""http://docs.python.org/"", None),\n    ""numpy"": (""http://docs.scipy.org/doc/numpy"", None),\n}\n'"
tests/test_onedim.py,176,"b'# MIT License\n#\n# Copyright (c) 2020 Douglas Davis\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport os\nimport multiprocessing\nfrom pathlib import PosixPath\n\nimport pygram11 as pg\nimport numpy as np\nimport pytest\n\ndata_file = PosixPath(__file__).parent / ""data"" / ""test_data.npz""\ntest_data = np.load(data_file)\n\nx_f64 = test_data[""data_f64""]\nx_f32 = x_f64.astype(np.float32)\nx_ui32 = test_data[""data_ui32""]\nx_i32 = x_ui32.astype(np.int32)\n\nw_f32 = test_data[""weights_f32""] * 0.5\nw_f64 = w_f32.astype(np.float64)\n\nx_f32_snx = np.random.choice(x_f32, 1234)\nw_f32_snx = np.random.choice(w_f32, 1234)\n\n\nclass TestMisc:\n    def test_omp_get_max_threads(self):\n        nthreads = os.getenv(""OMP_NUM_THREADS"")\n        if nthreads is None:\n            nthreads = multiprocessing.cpu_count()\n        assert int(nthreads) == pg.omp_get_max_threads()\n\n\nclass TestFixedNoFlow:\n    def test_fixed_noflow_f32f32(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f32, weights=w_f32, bins=nbins, range=(xmin, xmax), flow=False\n        )\n        np_res = np.histogram(x_f32, bins=nbins, range=(xmin, xmax), weights=w_f32)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_f64f32(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f64, weights=w_f32, bins=nbins, range=(xmin, xmax), flow=False\n        )\n        np_res = np.histogram(x_f64, bins=nbins, range=(xmin, xmax), weights=w_f32)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_f64f64(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f64, weights=w_f64, bins=nbins, range=(xmin, xmax), flow=False\n        )\n        np_res = np.histogram(x_f64, bins=nbins, range=(xmin, xmax), weights=w_f64)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_f32f64(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f32, weights=w_f64, bins=nbins, range=(xmin, xmax), flow=False\n        )\n        np_res = np.histogram(x_f32, bins=nbins, range=(xmin, xmax), weights=w_f64)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_ui32f64(self):\n        nbins, xmin, xmax = (6, -0.5, 5.5)\n        hm_res = pg.histogram(\n            x_ui32, weights=w_f64, bins=nbins, range=(xmin, xmax), flow=False\n        )\n        np_res = np.histogram(x_ui32, bins=nbins, range=(xmin, xmax), weights=w_f64)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_ui32f32(self):\n        nbins, xmin, xmax = (6, -0.5, 5.5)\n        hm_res = pg.histogram(\n            x_ui32, weights=w_f32, bins=nbins, range=(xmin, xmax), flow=False\n        )\n        np_res = np.histogram(x_ui32, bins=nbins, range=(xmin, xmax), weights=w_f32)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_flow_f32f32_snx(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f32_snx, weights=w_f32_snx, bins=nbins, range=(xmin, xmax), flow=False\n        )\n        np_res = np.histogram(\n            x_f32_snx, bins=nbins, range=(xmin, xmax), weights=w_f32_snx\n        )\n        assert np.allclose(hm_res[0], np_res[0])\n\n\nclass TestFixedNoFlowDensity:\n    def test_fixed_noflow_f32f32(self):\n        nbins, xmin, xmax = (22, 30, 185)\n        hm_res = pg.histogram(\n            x_f32,\n            weights=w_f32,\n            bins=nbins,\n            range=(xmin, xmax),\n            density=True,\n            flow=False,\n        )\n        np_res = np.histogram(\n            x_f32, bins=nbins, range=(xmin, xmax), weights=w_f32, density=True\n        )\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_f64f32(self):\n        nbins, xmin, xmax = (22, 50, 150)\n        hm_res = pg.histogram(\n            x_f64,\n            weights=w_f32,\n            bins=nbins,\n            range=(xmin, xmax),\n            density=True,\n            flow=False,\n        )\n        np_res = np.histogram(\n            x_f64, bins=nbins, range=(xmin, xmax), weights=w_f32, density=True\n        )\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_f64f64(self):\n        nbins, xmin, xmax = (40, 30, 170)\n        hm_res = pg.histogram(\n            x_f64,\n            weights=w_f64,\n            bins=nbins,\n            range=(xmin, xmax),\n            density=True,\n            flow=False,\n        )\n        np_res = np.histogram(\n            x_f64, bins=nbins, range=(xmin, xmax), weights=w_f64, density=True\n        )\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_f32f64(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f32,\n            weights=w_f64,\n            bins=nbins,\n            range=(xmin, xmax),\n            density=True,\n            flow=False,\n        )\n        np_res = np.histogram(\n            x_f32, bins=nbins, range=(xmin, xmax), weights=w_f64, density=True\n        )\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_ui32f64(self):\n        nbins, xmin, xmax = (3, 0.5, 3.5)\n        hm_res = pg.histogram(\n            x_ui32,\n            weights=w_f64,\n            bins=nbins,\n            range=(xmin, xmax),\n            density=True,\n            flow=False,\n        )\n        np_res = np.histogram(\n            x_ui32, bins=nbins, range=(xmin, xmax), weights=w_f64, density=True\n        )\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_noflow_ui32f32(self):\n        nbins, xmin, xmax = (4, -0.5, 3.5)\n        hm_res = pg.histogram(\n            x_ui32,\n            weights=w_f32,\n            bins=nbins,\n            range=(xmin, xmax),\n            density=True,\n            flow=False,\n        )\n        np_res = np.histogram(\n            x_ui32, bins=nbins, range=(xmin, xmax), weights=w_f32, density=True\n        )\n        assert np.allclose(hm_res[0], np_res[0],)\n\n    def test_fixed_noflow_f32f32_snx(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f32_snx,\n            weights=w_f32_snx,\n            bins=nbins,\n            range=(xmin, xmax),\n            density=True,\n            flow=False,\n        )\n        np_res = np.histogram(\n            x_f32_snx, bins=nbins, range=(xmin, xmax), weights=w_f32_snx, density=True\n        )\n        assert np.allclose(hm_res[0], np_res[0])\n\n\nclass TestFixedFlow:\n    def test_fixed_flow_f32f32(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f32, weights=w_f32, bins=nbins, range=(xmin, xmax), flow=True\n        )\n        np_res = np.histogram(x_f32, bins=nbins, range=(xmin, xmax), weights=w_f32)\n        underflow = np.sum(w_f32[x_f32 < xmin])\n        overflow = np.sum(w_f32[x_f32 > xmax])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_flow_f64f32(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f64, weights=w_f32, bins=nbins, range=(xmin, xmax), flow=True\n        )\n        np_res = np.histogram(x_f64, bins=nbins, range=(xmin, xmax), weights=w_f32)\n        underflow = np.sum(w_f32[x_f64 < xmin])\n        overflow = np.sum(w_f32[x_f64 > xmax])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_flow_f64f64(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f64, weights=w_f64, bins=nbins, range=(xmin, xmax), flow=True\n        )\n        np_res = np.histogram(x_f64, bins=nbins, range=(xmin, xmax), weights=w_f64)\n        underflow = np.sum(w_f64[x_f64 < xmin])\n        overflow = np.sum(w_f64[x_f64 > xmax])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0])\n\n    # def test_fixed_flow_except(self):\n    #     x = x_f64.astype(np.int16)\n    #     nbins, xmin, xmax = (3, 1.5, 4.5)\n    #     with pytest.raises(TypeError) as excinfo:\n    #         hm_res = pg.histogram(\n    #             x, weights=w_f64, bins=nbins, range=(xmin, xmax), flow=True\n    #         )\n    #     assert str(excinfo.value) == ""dtype of input arrays unsupported""\n    #     w = w_f64.astype(np.int8)\n    #     with pytest.raises(TypeError) as excinfo:\n    #         hm_res = pg.histogram(\n    #             x_f64, weights=w, bins=nbins, range=(xmin, xmax), flow=True\n    #         )\n    #     assert str(excinfo.value) == ""dtype of input arrays unsupported""\n\n    def test_fixed_flow_f32f64(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f32, weights=w_f64, bins=nbins, range=(xmin, xmax), flow=True\n        )\n        np_res = np.histogram(x_f32, bins=nbins, range=(xmin, xmax), weights=w_f64)\n        underflow = np.sum(w_f64[x_f32 < xmin])\n        overflow = np.sum(w_f64[x_f32 > xmax])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_flow_ui32f64(self):\n        nbins, xmin, xmax = (3, 0.5, 3.5)\n        hm_res = pg.histogram(\n            x_ui32, weights=w_f64, bins=nbins, range=(xmin, xmax), flow=True\n        )\n        np_res = np.histogram(x_ui32, bins=nbins, range=(xmin, xmax), weights=w_f64)\n        underflow = np.sum(w_f64[x_ui32 < xmin])\n        overflow = np.sum(w_f64[x_ui32 > xmax])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_fixed_flow_ui32f32(self):\n        nbins, xmin, xmax = (3, 1.5, 4.5)\n        hm_res = pg.histogram(\n            x_ui32, weights=w_f32, bins=nbins, range=(xmin, xmax), flow=True\n        )\n        np_res = np.histogram(x_ui32, bins=nbins, range=(xmin, xmax), weights=w_f32)\n        underflow = np.sum(w_f32[x_ui32 < xmin])\n        overflow = np.sum(w_f32[x_ui32 > xmax])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_fixed_flow_f32f32_snx(self):\n        nbins, xmin, xmax = 25, 40, 180\n        hm_res = pg.histogram(\n            x_f32_snx, weights=w_f32_snx, bins=nbins, range=(xmin, xmax), flow=True\n        )\n        np_res = np.histogram(\n            x_f32_snx, bins=nbins, range=(xmin, xmax), weights=w_f32_snx\n        )\n        underflow = np.sum(w_f32_snx[x_f32_snx < xmin])\n        overflow = np.sum(w_f32_snx[x_f32_snx > xmax])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0])\n\n\nclass TestVarNoFlow:\n    def test_var_noflow_f32f32(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f32, weights=w_f32, bins=edges, flow=False)\n        np_res = np.histogram(x_f32, bins=edges, weights=w_f32)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_noflow_f64f32(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f64, weights=w_f32, bins=edges, flow=False)\n        np_res = np.histogram(x_f64, bins=edges, weights=w_f32)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_noflow_f64f64(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f64, weights=w_f64, bins=edges, flow=False)\n        np_res = np.histogram(x_f64, bins=edges, weights=w_f64)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_noflow_f32f64(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f32, weights=w_f64, bins=edges, flow=False)\n        np_res = np.histogram(x_f32, bins=edges, weights=w_f64)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_noflow_ui32f64(self):\n        edges = np.array([-0.5, 1.5, 2.5, 4.5])\n        hm_res = pg.histogram(x_ui32, weights=w_f64, bins=edges, flow=False)\n        np_res = np.histogram(x_ui32, bins=edges, weights=w_f64)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_noflow_ui32f32(self):\n        edges = np.array([-0.5, 1.5, 2.5, 4.5])\n        hm_res = pg.histogram(x_ui32, weights=w_f32, bins=edges, flow=False)\n        np_res = np.histogram(x_ui32, bins=edges, weights=w_f32)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_noflow_f32f32_lu(self):\n        edges = np.linspace(30, 155, 25)\n        hm_res = pg.histogram(x_f32, weights=w_f32, bins=edges, flow=False)\n        np_res = np.histogram(x_f32, bins=edges, weights=w_f32)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_noflow_f64f32_lu(self):\n        edges = np.linspace(30, 155, 25)\n        hm_res = pg.histogram(x_f64, weights=w_f32, bins=edges, flow=False)\n        np_res = np.histogram(x_f64, bins=edges, weights=w_f32)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_noflow_f64f64_lu(self):\n        edges = np.linspace(30, 155, 25)\n        hm_res = pg.histogram(x_f64, weights=w_f64, bins=edges, flow=False)\n        np_res = np.histogram(x_f64, bins=edges, weights=w_f64)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_noflow_f32f64_lu(self):\n        edges = np.linspace(30, 155, 25)\n        hm_res = pg.histogram(x_f32, weights=w_f64, bins=edges, flow=False)\n        np_res = np.histogram(x_f32, bins=edges, weights=w_f64)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_noflow_f32f32_snx(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f32_snx, weights=w_f32_snx, bins=edges, flow=False)\n        np_res = np.histogram(x_f32_snx, bins=edges, weights=w_f32_snx)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n\nclass TestVarNoFlowDensity:\n    def test_var_noflow_f32f32(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(\n            x_f32, weights=w_f32, bins=edges, density=True, flow=False\n        )\n        np_res = np.histogram(x_f32, bins=edges, weights=w_f32, density=True)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_noflow_f64f32(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(\n            x_f64, weights=w_f32, bins=edges, density=True, flow=False\n        )\n        np_res = np.histogram(x_f64, bins=edges, weights=w_f32, density=True)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_noflow_f64f64(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(\n            x_f64, weights=w_f64, bins=edges, density=True, flow=False\n        )\n        np_res = np.histogram(x_f64, bins=edges, weights=w_f64, density=True)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_noflow_f32f64(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(\n            x_f32, weights=w_f64, bins=edges, density=True, flow=False\n        )\n        np_res = np.histogram(x_f32, bins=edges, weights=w_f64, density=True)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_noflow_ui32f64(self):\n        edges = np.array([-0.5, 1.5, 2.5, 4.5])\n        hm_res = pg.histogram(\n            x_ui32, weights=w_f64, bins=edges, density=True, flow=False\n        )\n        np_res = np.histogram(x_ui32, bins=edges, weights=w_f64, density=True)\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_noflow_ui32f32(self):\n        edges = np.array([-0.5, 1.5, 2.5, 4.5])\n        hm_res = pg.histogram(\n            x_ui32, weights=w_f32, bins=edges, density=True, flow=False\n        )\n        np_res = np.histogram(x_ui32, bins=edges, weights=w_f32, density=True)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_noflow_f32f32_snx(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(\n            x_f32_snx, weights=w_f32_snx, bins=edges, flow=False, density=True\n        )\n        np_res = np.histogram(x_f32_snx, bins=edges, weights=w_f32_snx, density=True)\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n\nclass TestVarFlow:\n    def test_var_flow_f32f32(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f32, weights=w_f32, bins=edges, flow=True)\n        np_res = np.histogram(x_f32, bins=edges, weights=w_f32)\n        underflow = np.sum(w_f32[x_f32 < edges[0]])\n        overflow = np.sum(w_f32[x_f32 > edges[-1]])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_flow_f64f32(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f64, weights=w_f32, bins=edges, flow=True)\n        np_res = np.histogram(x_f64, bins=edges, weights=w_f32)\n        underflow = np.sum(w_f32[x_f64 < edges[0]])\n        overflow = np.sum(w_f32[x_f64 > edges[-1]])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    # def test_var_flow_except(self):\n    #     edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n    #     x = x_f64.astype(np.int16)\n    #     with pytest.raises(TypeError) as excinfo:\n    #         hm_res = pg.histogram(x, weights=w_f64, bins=edges, flow=True)\n    #     assert str(excinfo.value) == ""dtype of input arrays unsupported""\n    #     w = w_f64.astype(np.int8)\n    #     with pytest.raises(TypeError) as excinfo:\n    #         hm_res = pg.histogram(x_f64, weights=w, bins=edges, flow=True)\n    #     assert str(excinfo.value) == ""dtype of input arrays unsupported""\n\n    def test_var_flow_f64f64(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f64, weights=w_f64, bins=edges, flow=True)\n        np_res = np.histogram(x_f64, bins=edges, weights=w_f64)\n        underflow = np.sum(w_f64[x_f64 < edges[0]])\n        overflow = np.sum(w_f64[x_f64 > edges[-1]])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_flow_f32f64(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f32, weights=w_f64, bins=edges, flow=True)\n        np_res = np.histogram(x_f32, bins=edges, weights=w_f64)\n        underflow = np.sum(w_f64[x_f32 < edges[0]])\n        overflow = np.sum(w_f64[x_f32 > edges[-1]])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_flow_ui32f64(self):\n        edges = np.array([-0.5, 1.5, 2.5, 4.5])\n        hm_res = pg.histogram(x_ui32, weights=w_f64, bins=edges, flow=True)\n        np_res = np.histogram(x_ui32, bins=edges, weights=w_f64)\n        underflow = np.sum(w_f64[x_ui32 < edges[0]])\n        overflow = np.sum(w_f64[x_ui32 > edges[-1]])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0])\n\n    def test_var_flow_ui32f32(self):\n        edges = np.array([-0.5, 1.5, 2.5, 4.5])\n        hm_res = pg.histogram(x_ui32, weights=w_f32, bins=edges, flow=True)\n        np_res = np.histogram(x_ui32, bins=edges, weights=w_f32)\n        underflow = np.sum(w_f32[x_ui32 < edges[0]])\n        overflow = np.sum(w_f32[x_ui32 > edges[-1]])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n    def test_var_flow_f32f32_snx(self):\n        edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n        hm_res = pg.histogram(x_f32_snx, weights=w_f32_snx, bins=edges, flow=True)\n        np_res = np.histogram(x_f32_snx, bins=edges, weights=w_f32_snx)\n        underflow = np.sum(w_f32_snx[x_f32_snx < edges[0]])\n        overflow = np.sum(w_f32_snx[x_f32_snx > edges[-1]])\n        np_res[0][0] += underflow\n        np_res[0][-1] += overflow\n        assert np.allclose(hm_res[0], np_res[0], rtol=1.0e-04, atol=1.0e-05)\n\n\nclass TestMutiWeight:\n    x_f64 = test_data[""data_f64""]\n    x_f32 = x_f64.astype(np.float32)\n    w_f32 = np.array([np.random.uniform(0.5, 1.5, x_f32.shape[0]) for i in range(13)]).T\n    w_f64 = w_f32.astype(np.float64)\n    edges = np.array([30, 40, 50, 60, 70, 90, 110, 130, 160, 200, 250.0])\n\n    def test_fixed_mw_f32f32(self):\n        nbins, xmin, xmax = (34, -3, 3)\n        hm_res_n, hm_res_e = pg.histogram(\n            self.x_f32, weights=self.w_f32, bins=nbins, range=(xmin, xmax), flow=False\n        )\n        for i in range(self.w_f32.shape[1]):\n            hm_res_i = hm_res_n.T[i]\n            np_res_i, __ = np.histogram(\n                self.x_f32, weights=self.w_f32.T[i], bins=nbins, range=(xmin, xmax)\n            )\n            assert np.allclose(hm_res_i, np_res_i)\n\n    def test_fixed_mw_f64f64(self):\n        nbins, xmin, xmax = (34, -3, 3)\n        hm_res_n, hm_res_e = pg.histogram(\n            self.x_f64, weights=self.w_f64, bins=nbins, range=(xmin, xmax), flow=False\n        )\n        for i in range(self.w_f64.shape[1]):\n            hm_res_i = hm_res_n.T[i]\n            np_res_i, __ = np.histogram(\n                self.x_f64, weights=self.w_f64.T[i], bins=nbins, range=(xmin, xmax)\n            )\n            assert np.allclose(hm_res_i, np_res_i)\n\n    def test_var_mw_f32f32(self):\n        hm_res_n, hm_res_e = pg.histogram(\n            self.x_f32, weights=self.w_f32, bins=self.edges, flow=False\n        )\n        for i in range(self.w_f32.shape[1]):\n            hm_res_i = hm_res_n.T[i]\n            np_res_i, __ = np.histogram(\n                self.x_f32, weights=self.w_f32.T[i], bins=self.edges\n            )\n            # assert np.allclose(np.around(hm_res_i, 2), np.around(np_res_i, 2))\n            np.testing.assert_allclose(hm_res_i, np_res_i, rtol=1.0e-3)\n\n    def test_var_mw_f64f64(self):\n        hm_res_n, hm_res_e = pg.histogram(\n            self.x_f64, weights=self.w_f64, bins=self.edges, flow=False\n        )\n        for i in range(self.w_f64.shape[1]):\n            hm_res_i = hm_res_n.T[i]\n            np_res_i, __ = np.histogram(\n                self.x_f64, weights=self.w_f64.T[i], bins=self.edges\n            )\n            assert np.allclose(hm_res_i, np_res_i)\n\n    def test_var_mw_f32f32_lu(self):\n        fedges = np.linspace(-2.0, 2.0, 19)\n        hm_res_n, hm_res_e = pg.histogram(\n            self.x_f32, weights=self.w_f32, bins=fedges, flow=False\n        )\n        for i in range(self.w_f32.shape[1]):\n            hm_res_i = hm_res_n.T[i]\n            np_res_i, __ = np.histogram(\n                self.x_f32, weights=self.w_f32.T[i], bins=fedges\n            )\n            # assert np.allclose(np.around(hm_res_i, 2), np.around(np_res_i, 2))\n            np.testing.assert_allclose(hm_res_i, np_res_i, rtol=1.0e-3)\n\n    def test_var_mw_f64f64_lu(self):\n        fedges = np.linspace(-2.0, 2.0, 19)\n        hm_res_n, hm_res_e = pg.histogram(\n            self.x_f64, weights=self.w_f64, bins=fedges, flow=False\n        )\n        for i in range(self.w_f64.shape[1]):\n            hm_res_i = hm_res_n.T[i]\n            np_res_i, __ = np.histogram(\n                self.x_f64, weights=self.w_f64.T[i], bins=fedges\n            )\n            assert np.allclose(hm_res_i, np_res_i)\n'"
tests/test_onedim_mw.py,37,"b'# MIT License\n#\n# Copyright (c) 2020 Douglas Davis\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nfrom pathlib import PosixPath\n\nimport pygram11 as pg\nimport numpy as np\nimport pytest\n\ndata_file = PosixPath(__file__).parent / ""data"" / ""test_data.npz""\ntest_data = np.load(data_file)\n\nx = test_data[""data_f64""]\nw = test_data[""weights_f32""].astype(np.float64) * 0.5\nw_1 = np.copy(w) * 1.5\nw_2 = np.copy(w) * 2.5\nw_3 = np.copy(w) * 0.3\nmw = np.transpose(np.array([w_1, w_2, w_3]))\n\nx_snx = np.random.choice(x, 1234)\nw_snx = np.random.choice(w, 1234)\nw_snx_1 = np.copy(w_snx) * 0.1\nw_snx_2 = np.copy(w_snx) * 0.75\nw_snx_3 = np.copy(w_snx) * 2.0\nmw_snx = np.transpose(np.array([w_snx_1, w_snx_2, w_snx_3]))\n\nnbins, xmin, xmax = 25, 40, 180\n\nedges = np.array([27.5, 35, 40, 50, 57, 60, 64, 70, 90, 98, 110, 120, 130, 160, 200, 250.0])\n\n\ndef test_fixed_manyweight_noflow():\n    res, err = pg.histogram(x, weights=mw, bins=nbins, range=(xmin, xmax), flow=False)\n    for i in range(res.shape[1]):\n        c, _ = np.histogram(x, weights=mw[:, i], bins=nbins, range=(xmin, xmax))\n        assert np.allclose(res[:, i], c)\n\ndef test_fixed_manyweight_flow():\n    res, err = pg.histogram(x, weights=mw, bins=nbins, range=(xmin, xmax), flow=True)\n    for i in range(res.shape[1]):\n        c, _ = np.histogram(x, weights=mw[:, i], bins=nbins, range=(xmin, xmax))\n        under = np.sum(mw[:, i][x < xmin])\n        over = np.sum(mw[:, i][x >= xmax])\n        c[0] += under\n        c[-1] += over\n        assert np.allclose(res[:, i], c)\n\ndef test_fixed_manyweight_noflow_snx():\n    res, err = pg.histogram(x_snx, weights=mw_snx, bins=nbins, range=(xmin, xmax), flow=False)\n    for i in range(res.shape[1]):\n        c, _ = np.histogram(x_snx, weights=mw_snx[:, i], bins=nbins, range=(xmin, xmax))\n        assert np.allclose(res[:, i], c)\n\ndef test_fixed_manyweight_flow_snx():\n    res, err = pg.histogram(x_snx, weights=mw_snx, bins=nbins, range=(xmin, xmax), flow=True)\n    for i in range(res.shape[1]):\n        c, _ = np.histogram(x_snx, weights=mw_snx[:, i], bins=nbins, range=(xmin, xmax))\n        under = np.sum(mw_snx[:, i][x_snx < xmin])\n        over = np.sum(mw_snx[:, i][x_snx >= xmax])\n        c[0] += under\n        c[-1] += over\n        assert np.allclose(res[:, i], c)\n\ndef test_var_manyweight_noflow():\n    res, err = pg.histogram(x, weights=mw, bins=edges, flow=False)\n    for i in range(res.shape[1]):\n        c, _ = np.histogram(x, weights=mw[:, i], bins=edges)\n        assert np.allclose(res[:, i], c)\n\ndef test_var_manyweight_flow():\n    res, err = pg.histogram(x, weights=mw, bins=edges, flow=True)\n    for i in range(res.shape[1]):\n        c, _ = np.histogram(x, weights=mw[:, i], bins=edges)\n        under = np.sum(mw[:, i][x < edges[0]])\n        over = np.sum(mw[:, i][x >= edges[-1]])\n        c[0] += under\n        c[-1] += over\n        assert np.allclose(res[:, i], c)\n\ndef test_var_manyweight_noflow_snx():\n    res, err = pg.histogram(x_snx, weights=mw_snx, bins=edges, flow=False)\n    for i in range(res.shape[1]):\n        c, _ = np.histogram(x_snx, weights=mw_snx[:, i], bins=edges)\n        assert np.allclose(res[:, i], c)\n\ndef test_var_manyweight_flow_snx():\n    res, err = pg.histogram(x_snx, weights=mw_snx, bins=edges, flow=True)\n    for i in range(res.shape[1]):\n        c, _ = np.histogram(x_snx, weights=mw_snx[:, i], bins=edges)\n        under = np.sum(mw_snx[:, i][x_snx < edges[0]])\n        over = np.sum(mw_snx[:, i][x_snx >= edges[-1]])\n        c[0] += under\n        c[-1] += over\n        assert np.allclose(res[:, i], c)\n'"
tests/test_twodim.py,28,"b'# MIT License\n#\n# Copyright (c) 2020 Douglas Davis\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport os\nfrom pathlib import PosixPath\n\nimport pygram11 as pg\nimport numpy as np\nimport numpy.testing as npt\nimport pytest\n\ndata_file = PosixPath(__file__).parent / ""data"" / ""test_data.npz""\ntest_data = np.load(data_file)\n\nx = test_data[""data_f64""]\ny = np.random.normal(np.mean(x), np.std(x), x.shape[0])\nw = test_data[""weights_f32""].astype(np.float64) * 0.5\n\nx_snx = np.random.choice(x, 1234)\ny_snx = np.random.choice(y, 1234)\nw_snx = np.random.choice(w, 1234)\n\nnbinsx, xmin, xmax = 25, 40, 180\nnbinsy, ymin, ymax = 35, 75, 380\n\nxx = np.random.randn(100000)\nyy = np.random.randn(100000)\nxxedges = [-3.1, -2.5, -2.2, -2.0, -1.0, -0.25, 0.25, 0.4, 0.5, 0.6, 1.1, 2.2]\nyyedges = [-3.1, -2.3, -2.1, -2.0, -0.9, -0.20, 0.22, 0.3, 0.4, 0.7, 1.2, 2.1]\nww = np.random.uniform(0.5, 0.9, xx.shape[0])\nxx_snx = np.random.choice(x_snx, 1234)\nyy_snx = np.random.choice(y_snx, 1234)\nww_snx = np.random.choice(y_snx, 1234)\n\n\nclass TestFix2D:\n    def test_paralel(self):\n        pygram_h, __ = pg.fix2d(\n            x, y, bins=(nbinsx, nbinsy), range=((xmin, xmax), (ymin, ymax)), weights=w\n        )\n        numpy_h, __, __ = np.histogram2d(\n            x,\n            y,\n            bins=[\n                np.linspace(xmin, xmax, nbinsx + 1),\n                np.linspace(ymin, ymax, nbinsy + 1),\n            ],\n            weights=w,\n        )\n        npt.assert_almost_equal(pygram_h, numpy_h, 5)\n\n    def test_serial(self):\n        pygram_h, __ = pg.fix2d(\n            x_snx,\n            y_snx,\n            bins=(nbinsx, nbinsy),\n            range=((xmin, xmax), (ymin, ymax)),\n            weights=w_snx,\n        )\n        numpy_h, __, __ = np.histogram2d(\n            x_snx,\n            y_snx,\n            bins=[\n                np.linspace(xmin, xmax, nbinsx + 1),\n                np.linspace(ymin, ymax, nbinsy + 1),\n            ],\n            weights=w_snx,\n        )\n        npt.assert_almost_equal(pygram_h, numpy_h, 5)\n\n\nclass TestVar2D:\n    def test_paralel(self):\n        pygram_h, __ = pg.var2d(xx, yy, xxedges, yyedges, weights=ww)\n        numpy_h, __, __ = np.histogram2d(xx, yy, bins=[xxedges, yyedges], weights=ww)\n        npt.assert_almost_equal(pygram_h, numpy_h, 3)\n\n    def test_serial(self):\n        pygram_h, __ = pg.var2d(xx_snx, yy_snx, xxedges, yyedges, weights=ww_snx)\n        numpy_h, __, __ = np.histogram2d(\n            xx_snx, yy_snx, bins=[xxedges, yyedges], weights=ww_snx,\n        )\n        npt.assert_almost_equal(pygram_h, numpy_h, 5)\n\n\nclass TestFix2DNPAPI:\n    def test_paralel(self):\n        pygram_h, __ = pg.histogram2d(\n            x, y, bins=(nbinsx, nbinsy), range=((xmin, xmax), (ymin, ymax)), weights=w\n        )\n        numpy_h, __, __ = np.histogram2d(\n            x,\n            y,\n            bins=[\n                np.linspace(xmin, xmax, nbinsx + 1),\n                np.linspace(ymin, ymax, nbinsy + 1),\n            ],\n            weights=w,\n        )\n        npt.assert_almost_equal(pygram_h, numpy_h, 5)\n\n    def test_serial(self):\n        pygram_h, __ = pg.histogram2d(\n            x_snx,\n            y_snx,\n            bins=(nbinsx, nbinsy),\n            range=((xmin, xmax), (ymin, ymax)),\n            weights=w_snx,\n        )\n        numpy_h, __, __ = np.histogram2d(\n            x_snx,\n            y_snx,\n            bins=[\n                np.linspace(xmin, xmax, nbinsx + 1),\n                np.linspace(ymin, ymax, nbinsy + 1),\n            ],\n            weights=w_snx,\n        )\n        npt.assert_almost_equal(pygram_h, numpy_h, 5)\n\n\nclass TestVar2DNPAPI:\n    def test_paralel(self):\n        pygram_h, __ = pg.histogram2d(xx, yy, bins=[xxedges, yyedges], weights=ww)\n        numpy_h, __, __ = np.histogram2d(xx, yy, bins=[xxedges, yyedges], weights=ww)\n        npt.assert_almost_equal(pygram_h, numpy_h, 3)\n\n    def test_serial(self):\n        pygram_h, __ = pg.histogram2d(\n            xx_snx, yy_snx, bins=[xxedges, yyedges], weights=ww_snx,\n        )\n        numpy_h, __, __ = np.histogram2d(\n            xx_snx, yy_snx, bins=[xxedges, yyedges], weights=ww_snx,\n        )\n        npt.assert_almost_equal(pygram_h, numpy_h, 5)\n'"
utils/benchmark.py,20,"b'import matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nmpl.use(""Agg"")\n\nimport json\nimport sys\nfrom timeit import timeit, repeat\nimport pygram11 as pg\nimport numpy as np\n\nSETUP_F_1D = """"""\nimport numpy as np\nimport boost_histogram as bh\nfrom numpy import histogram as np_hist\nfrom pygram11 import histogram as pg_hist\nfrom fast_histogram import histogram1d as fh_hist\nx = np.random.randn({size})\nw = np.random.uniform(0.4, 0.8, {size})\nbh_hist = bh.Histogram(bh.axis.Regular(25, -3, 3), storage=bh.storage.Weight())\n""""""\n\nNP_F_1D = ""np_hist(x, bins=25, range=(-3, 3), weights=w)""\nPG_F_1D = ""pg_hist(x, bins=25, range=(-3, 3), weights=w)""\nFH_F_1D = ""fh_hist(x, bins=25, range=(-3, 3), weights=w)""\nBH_F_1D = ""bh_hist.fill(x, weight=w)""\n\n################################################################\n\nSETUP_V_1D = """"""\nimport numpy as np\nimport boost_histogram as bh\nfrom numpy import histogram as np_hist\nfrom pygram11 import histogram as pg_hist\nedges = np.unique(np.round(sorted(np.random.uniform(-3, 3, 26)), 2))\nx = np.random.randn({size})\nw = np.random.uniform(0.4, 0.8, {size})\nbh_hist = bh.Histogram(bh.axis.Variable(edges), storage=bh.storage.Weight())\n""""""\n\nNP_V_1D = ""np_hist(x, bins=edges, weights=w)""\nPG_V_1D = ""pg_hist(x, bins=edges, weights=w)""\nBH_V_1D = ""bh_hist.fill(x, weight=w)""\n\n################################################################\n\nSETUP_F_2D = """"""\nimport numpy as np\nimport boost_histogram as bh\nfrom numpy import histogram2d as np_hist\nfrom pygram11 import histogram2d as pg_hist\nfrom fast_histogram import histogram2d as fh_hist\nx = np.random.randn({size})\ny = np.random.randn({size})\nw = np.random.uniform(0.4, 0.8, {size})\nbh_hist = bh.Histogram(bh.axis.Regular(25, -3, 3),\n                       bh.axis.Regular(25, -3, 3),\n                       storage=bh.storage.Weight())\n""""""\n\nNP_F_2D = ""np_hist(x, y, bins=[25, 25], range=[[-3, 3], [-3, 3]], weights=w)""\nPG_F_2D = ""pg_hist(x, y, bins=[25, 25], range=[[-3, 3], [-3, 3]], weights=w)""\nFH_F_2D = ""fh_hist(x, y, bins=[25, 25], range=[[-3, 3], [-3, 3]], weights=w)""\nBH_F_2D = ""bh_hist.fill(x, y, weight=w)""\n\n################################################################\n\nSETUP_V_2D = """"""\nimport numpy as np\nimport boost_histogram as bh\nfrom numpy import histogram as np_hist\nfrom pygram11 import histogram as pg_hist\nedges = np.unique(np.round(sorted(np.random.uniform(-3, 3, 26)), 2))\nx = np.random.randn({size})\ny = np.random.randn({size})\nw = np.random.uniform(0.4, 0.8, {size})\nbh_hist = bh.Histogram(bh.axis.Variable(edges),\n                       bh.axis.Variable(edges),\n                       storage=bh.storage.Weight())\n""""""\n\nNP_V_2D = ""np_hist(x, bins=edges, weights=w)""\nPG_V_2D = ""pg_hist(x, bins=edges, weights=w)""\nBH_V_2D = ""bh_hist.fill(x, y, weight=w)""\n\n################################################################\n\nexpos1d = [2, 3, 4, 5, 6, 7, 8]\nexpos2d = [2, 3, 4, 5, 6, 7, 8]\n\n\ndef time_stats(stmt=None, setup=None):\n    time_single = timeit(stmt=stmt, setup=setup, number=1)\n    number = max(3, int(1.0 / time_single))\n    print(\n        "" -> estimated time to complete test: {0:.1f}s"".format(\n            time_single * 10 * number\n        )\n    )\n    times = repeat(stmt=stmt, setup=setup, repeat=10, number=number)\n    return np.min(times) / number, np.mean(times) / number, np.median(times) / number\n\n\ndef run_4(expos, stmt_pg, stmt_np, stmt_bh, stmt_fh, setup, outname):\n    pg_means = []\n    np_means = []\n    fh_means = []\n    bh_means = []\n    for exponent in expos:\n        size = int(10 ** exponent)\n        print(f""Running 10^{exponent}"")\n        pg_min, pg_mean, pg_median = time_stats(stmt=stmt_pg, setup=setup.format(size=size))\n        np_min, np_mean, np_median = time_stats(stmt=stmt_np, setup=setup.format(size=size))\n        fh_min, fh_mean, fh_median = time_stats(stmt=stmt_fh, setup=setup.format(size=size))\n        bh_min, bh_mean, bh_median = time_stats(stmt=stmt_bh, setup=setup.format(size=size))\n        np_means.append(np_mean)\n        pg_means.append(pg_mean)\n        fh_means.append(fh_mean)\n        bh_means.append(bh_mean)\n        print(exponent, np_min, np_mean, np_median)\n        print(exponent, pg_min, pg_mean, pg_median)\n        print(exponent, fh_min, fh_mean, fh_median)\n        print(exponent, bh_min, bh_mean, bh_median)\n    res = {\n        ""pg_means"": pg_means,\n        ""np_means"": np_means,\n        ""fh_means"": fh_means,\n        ""bh_means"": bh_means,\n    }\n    with open(outname, ""w"") as f:\n        json.dump(res, f, indent=4)\n\n\ndef run_3(expos, stmt_pg, stmt_np, stmt_bh, setup, outname):\n    pg_means = []\n    np_means = []\n    bh_means = []\n    for exponent in expos:\n        size = int(10 ** exponent)\n        print(f""Running 10^{exponent}"")\n        pg_min, pg_mean, pg_median = time_stats(stmt=stmt_pg, setup=setup.format(size=size))\n        np_min, np_mean, np_median = time_stats(stmt=stmt_np, setup=setup.format(size=size))\n        bh_min, bh_mean, bh_median = time_stats(stmt=stmt_bh, setup=setup.format(size=size))\n        np_means.append(np_mean)\n        pg_means.append(pg_mean)\n        bh_means.append(bh_mean)\n        print(exponent, np_min, np_mean, np_median)\n        print(exponent, pg_min, pg_mean, pg_median)\n        print(exponent, bh_min, bh_mean, bh_median)\n    res = {\n        ""pg_means"": pg_means,\n        ""np_means"": np_means,\n        ""bh_means"": bh_means,\n    }\n    with open(outname, ""w"") as f:\n        json.dump(res, f, indent=3)\n\n\ndef plots_4(inname, title, logscale=True):\n    with open(inname, ""r"") as f:\n        res = json.load(f)\n    np_means = np.array(res[""np_means""])\n    fh_means = np.array(res[""fh_means""])\n    bh_means = np.array(res[""bh_means""])\n    pg_means = np.array(res[""pg_means""])\n    fig, ax = plt.subplots()\n    ax.plot(expos1d, np_means / pg_means, label=""over numpy"")\n    ax.plot(expos1d, fh_means / pg_means, label=""over fast_histogram"")\n    ax.plot(expos1d, bh_means / pg_means, label=""over boost_histogram"")\n    ax.grid()\n    if logscale:\n        ax.set_yscale(""log"")\n    ax.set_title(title)\n    ax.set_ylabel(""Speedup"")\n    ax.set_xlabel(""Array Size"")\n    ax.set_xticks(expos1d)\n    ax.set_xticklabels([f""$10^{n}$"" for n in expos1d])\n    ax.legend(loc=""best"")\n    fig.savefig(f""bm_{inname}.png"")\n\n\ndef plots_3(inname, title, logscale=True):\n    with open(inname, ""r"") as f:\n        res = json.load(f)\n    np_means = np.array(res[""np_means""])\n    bh_means = np.array(res[""bh_means""])\n    pg_means = np.array(res[""pg_means""])\n    fig, ax = plt.subplots()\n    ax.plot(expos1d, np_means / pg_means, label=""over numpy"")\n    ax.plot(expos1d, bh_means / pg_means, label=""over boost_histogram"")\n    ax.grid()\n    if logscale:\n        ax.set_yscale(""log"")\n    ax.set_title(title)\n    ax.set_ylabel(""Speedup"")\n    ax.set_xlabel(""Array Size"")\n    ax.set_xticks(expos1d)\n    ax.set_xticklabels([f""$10^{n}$"" for n in expos1d])\n    ax.legend(loc=""best"")\n    fig.savefig(f""bm_{inname}.png"")\n\n\nif len(sys.argv) < 2:\n    print(""what do you want to do"")\n    exit(1)\nif ""fixed1d"" in sys.argv:\n    run_4(expos1d, PG_F_1D, NP_F_1D, BH_F_1D, FH_F_1D, SETUP_F_1D, ""fixed1d.json"")\nif ""var1d"" in sys.argv:\n    run_3(expos1d, PG_V_1D, NP_V_1D, BH_V_1D, SETUP_V_1D, ""var1d.json"")\nif ""fixed2d"" in sys.argv:\n    run_4(expos2d, PG_F_2D, NP_F_2D, BH_F_2D, FH_F_2D, SETUP_F_2D, ""fixed2d.json"")\nif ""var2d"" in sys.argv:\n    run_3(expos2d, PG_V_2D, NP_V_2D, BH_V_2D, SETUP_V_2D, ""var2d.json"")\nif ""plotvar1d"" in sys.argv:\n    plots_3(""var1d.json"", ""Variable Width 1D Histograms"")\nif ""plotfixed1d"" in sys.argv:\n    plots_4(""fixed1d.json"", ""Fixed Width 1D Histograms"")\nif ""plotfixed2d"" in sys.argv:\n    plots_4(""fixed2d.json"", ""Fixed Width 2D Histograms"")\nif ""plotvar2d"" in sys.argv:\n    plots_3(""var2d.json"", ""Variable Width 2D Histograms"")\n'"
src/pygram11/__init__.py,0,"b'""""""Simple and fast histogramming in Python.\n\nMIT License\n\nCopyright (c) 2020 Douglas Davis\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation files\n(the ""Software""), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software,\nand to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n""""""\n\nfrom pygram11._backend1d import _omp_get_max_threads\n\nfrom .histogram import fix1d, fix1dmw, var1d, var1dmw\nfrom .histogram import fix2d, var2d\nfrom .histogram import histogram, histogram2d\n\n__version__ = ""0.9.2.dev0""\nversion_info = tuple(__version__.split("".""))\n\n\n__all__ = [\n    ""fix1d"",\n    ""fix1dmw"",\n    ""var1d"",\n    ""var1dmw"",\n    ""fix2d"",\n    ""var2d"",\n    ""histogram"",\n    ""histogram2d"",\n    ""omp_get_max_threads"",\n]\n\n\ndef omp_get_max_threads():\n    """"""Get the number of threads available to OpenMP.\n\n    This returns the result of calling the OpenMP C API function `of\n    the same name\n    <https://www.openmp.org/spec-html/5.0/openmpsu112.html>`_.\n\n    Returns\n    -------\n    int\n        the maximum number of available threads\n\n    """"""\n    return _omp_get_max_threads()\n'"
src/pygram11/histogram.py,46,"b'""""""pygram11 Histogram API.""""""\n\n# MIT License\n#\n# Copyright (c) 2020 Douglas Davis\n#\n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation files\n# (the ""Software""), to deal in the Software without restriction,\n# including without limitation the rights to use, copy, modify, merge,\n# publish, distribute, sublicense, and/or sell copies of the Software,\n# and to permit persons to whom the Software is furnished to do so,\n# subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport numpy as np\nimport numbers\n\nfrom pygram11._backend1d import _v1dw, _f1dw, _f1dmw, _v1dmw\nfrom pygram11._backend2d import _f2dw, _v2dw\n\n\ndef _likely_uniform_bins(edges):\n    """"""Test if bin edges describe a set of fixed width bins.""""""\n    diffs = np.ediff1d(edges)\n    ones = np.ones_like(diffs)\n    max_close = np.allclose(ones, diffs / np.amax(diffs))\n    min_close = np.allclose(ones, diffs / np.amin(diffs))\n    return max_close and min_close\n\n\ndef fix1d(x, bins=10, range=None, weights=None, density=False, flow=False):\n    r""""""Histogram data with fixed (uniform) bin widths.\n\n    Parameters\n    ----------\n    x : array_like\n        Data to histogram.\n    bins : int\n        The number of bins.\n    range : (float, float), optional\n        The minimum and maximum of the histogram axis.\n    weights : array_like, optional\n        The weights for each element of ``x``.\n    density : bool\n        If True, normalize histogram bins as value of PDF such that\n        the integral over the range is one.\n    flow : bool\n        If True, the under and overflow bin contents are added to the\n        first and last bins, respectively.\n\n    Returns\n    -------\n    :py:obj:`numpy.ndarray`\n        The bin counts.\n    :py:obj:`numpy.ndarray`\n        The standard error of each bin count, :math:`\\sqrt{\\sum_i w_i^2}`.\n\n    Examples\n    --------\n    A histogram of ``x`` with 20 bins between 0 and 100:\n\n    >>> h, __ = fix1d(x, bins=20, range=(0, 100))\n\n    The same data, now histogrammed with weights:\n\n    >>> w = np.abs(np.random.randn(x.shape[0]))\n    >>> h, h_err = fix1d(x, bins=20, range=(0, 100), weights=w)\n\n    """"""\n    x = np.ascontiguousarray(x)\n    if weights is not None:\n        weights = np.ascontiguousarray(weights)\n    else:\n        weights = np.ones_like(x, order=""C"")\n        if not (weights.dtype == np.float32 or weights.dtype == np.float64):\n            weights = weights.astype(np.float64)\n\n    if range is not None:\n        start, stop = range[0], range[1]\n    else:\n        start, stop = np.amin(x), np.amax(x)\n\n    return _f1dw(x, weights, bins, start, stop, flow, density, True)\n\n\ndef fix1dmw(x, weights, bins=10, range=None, flow=False):\n    r""""""Histogram data with multiple weight variations and fixed width bins.\n\n    Parameters\n    ----------\n    x : array_like\n        data to histogram.\n    weights : array_like\n        The weight variations for the elements of ``x``, first\n        dimension is the length of ``x``, second dimension is the\n        number of weights variations.\n    bins : int\n        The number of bins.\n    range : (float, float), optional\n        The minimum and maximumm of the histogram axis.\n    flow : bool\n        If True, the under and overflow bin contents are added to the\n        first and last bins, respectively.\n\n    Returns\n    -------\n    :py:obj:`numpy.ndarray`\n        The bin counts.\n    :py:obj:`numpy.ndarray`\n        The standard error of each bin count, :math:`\\sqrt{\\sum_i w_i^2}`.\n\n    Examples\n    --------\n    Multiple histograms of ``x`` with 50 bins between 0 and 100; using\n    20 different weight variations:\n\n    >>> x = np.random.randn(10000)\n    >>> twenty_weights = np.random.rand(x.shape[0], 20)\n    >>> h, err = fix1dmw(x, w, bins=50, range=(-3, 3))\n\n    ``h`` and ``err`` are now shape ``(50, 20)``. Each column\n    represents the histogram of the data using its respective weight.\n\n    """"""\n    x = np.ascontiguousarray(x)\n    weights = np.ascontiguousarray(weights)\n    if not (weights.dtype == np.float32 or weights.dtype == np.float64):\n        weights = weights.astype(np.float64)\n\n    if range is not None:\n        start, stop = range[0], range[1]\n    else:\n        start, stop = np.amin(x), np.amax(x)\n\n    return _f1dmw(x, weights, bins, start, stop, flow, True)\n\n\ndef var1d(x, bins, weights=None, density=False, flow=False):\n    r""""""Histogram data with variable bin widths.\n\n    Parameters\n    ----------\n    x : array_like\n        data to histogram\n    bins : array_like\n        bin edges\n    weights : array_like, optional\n        weight for each element of ``x``\n    density : bool\n        normalize histogram bins as value of PDF such that the integral\n        over the range is 1.\n    flow : bool\n        if ``True`` the under and overflow bin contents are added to the first\n        and last bins, respectively\n\n    Returns\n    -------\n    :py:obj:`numpy.ndarray`\n        The bin counts.\n    :py:obj:`numpy.ndarray`\n        The standard error of each bin count, :math:`\\sqrt{\\sum_i w_i^2}`.\n\n    Examples\n    --------\n    A simple histogram with variable width bins:\n\n    >>> x = np.random.randn(10000)\n    >>> bin_edges = [-3.0, -2.5, -1.5, -0.25, 0.25, 2.0, 3.0]\n    >>> h, __ = var1d(x, bin_edges)\n\n    """"""\n    x = np.ascontiguousarray(x)\n    if weights is not None:\n        weights = np.ascontiguousarray(weights)\n    else:\n        weights = np.ones_like(x, order=""C"")\n        if not (weights.dtype == np.float32 or weights.dtype == np.float64):\n            weights = weights.astype(np.float64)\n\n    bins = np.ascontiguousarray(bins)\n    if not np.all(bins[1:] >= bins[:-1]):\n        raise ValueError(""bins sequence must monotonically increase"")\n\n    if _likely_uniform_bins(bins):\n        return _f1dw(x, weights, len(bins) - 1, bins[0], bins[-1], flow, density, True)\n\n    return _v1dw(x, weights, bins, flow, density, True)\n\n\ndef var1dmw(x, weights, bins, flow=False):\n    r""""""Histogram data with multiple weight variations and variable width bins.\n\n    Parameters\n    ----------\n    x : array_like\n        data to histogram\n    bins : array_like\n        bin edges\n    weights : array_like\n        weight variations for the elements of ``x``, first dimension\n        is the shape of ``x``, second dimension is the number of weights.\n    density : bool\n        normalize histogram bins as value of PDF such that the integral\n        over the range is 1.\n    flow : bool\n        if ``True`` the under and overflow bin contents are added to the first\n        and last bins, respectively\n\n    Returns\n    -------\n    :py:obj:`numpy.ndarray`\n        The bin counts.\n    :py:obj:`numpy.ndarray`\n        The standard error of each bin count, :math:`\\sqrt{\\sum_i w_i^2}`.\n\n    Examples\n    --------\n    Using three different weight variations:\n\n    >>> x = np.random.randn(10000)\n    >>> weights = np.abs(np.random.randn(x.shape[0], 3))\n    >>> bin_edges = [-3.0, -2.5, -1.5, -0.25, 0.25, 2.0, 3.0]\n    >>> h, err = var1dmw(x, weights, bin_edges)\n    >>> h.shape\n    (6, 3)\n    >>> err.shape\n    (6, 3)\n\n    """"""\n    x = np.ascontiguousarray(x)\n    weights = np.ascontiguousarray(weights)\n    if not (weights.dtype == np.float32 or weights.dtype == np.float64):\n        weights = weights.astype(np.float64)\n\n    bins = np.ascontiguousarray(bins)\n    if not np.all(bins[1:] >= bins[:-1]):\n        raise ValueError(""bins sequence must monotonically increase"")\n\n    if _likely_uniform_bins(bins):\n        return _f1dmw(x, weights, len(bins) - 1, bins[0], bins[-1], flow, True)\n\n    return _v1dmw(x, weights, bins, flow, True)\n\n\ndef histogram(x, bins=10, range=None, weights=None, density=False, flow=False):\n    r""""""Histogram data in one dimension.\n\n    Parameters\n    ----------\n    x : array_like\n        data to histogram.\n    bins : int or array_like\n        if int: the number of bins; if array_like: the bin edges.\n    range : tuple(float, float), optional\n        the definition of the edges of the bin range (start, stop).\n    weights : array_like, optional\n        a set of weights associated with the elements of ``x``. This\n        can also be a two dimensional set of multiple weights\n        varitions with shape (len(x), n_weight_variations).\n    density : bool\n        normalize counts such that the integral over the range is\n        equal to 1. If ``weights`` is two dimensional this argument is\n        ignored.\n    flow : bool\n        if ``True``, include under/overflow in the first/last bins.\n\n    Returns\n    -------\n    :py:obj:`numpy.ndarray`\n        The bin counts.\n    :py:obj:`numpy.ndarray`\n        The standard error of each bin count, :math:`\\sqrt{\\sum_i w_i^2}`.\n\n    Examples\n    --------\n    A simple fixed width histogram:\n\n    >>> h, __ = histogram(x, bins=20, range=(0, 100))\n\n    And with variable width histograms and weights:\n\n    >>> h, err = histogram(x, bins=[-3, -2, -1.5, 1.5, 3.5], weights=w)\n\n    """"""\n    # fixed bins\n    if isinstance(bins, numbers.Integral):\n        if weights is not None:\n            if weights.shape != x.shape:\n                return fix1dmw(x, weights, bins=bins, range=range, flow=flow)\n        return fix1d(\n            x, weights=weights, bins=bins, range=range, density=density, flow=flow\n        )\n\n    # variable bins\n    else:\n        if range is not None:\n            raise TypeError(""range must be None if bins is non-int"")\n        if weights is not None:\n            if weights.shape != x.shape:\n                return var1dmw(x, weights, bins=bins, flow=flow)\n        return var1d(x, weights=weights, bins=bins, density=density, flow=flow)\n\n\ndef fix2d(x, y, bins=10, range=None, weights=None):\n    r""""""Histogram the ``x``, ``y`` data with fixed (uniform) binning.\n\n    Parameters\n    ----------\n    x : array_like\n       first entries in data pairs to histogram\n    y : array_like\n       second entries in data pairs to histogram\n    bins : int or iterable\n       if int, both dimensions will have that many bins,\n       if iterable, the number of bins for each dimension\n    range : iterable, optional\n       axis limits to histogram over in the form [(xmin, xmax), (ymin, ymax)]\n    weights : array_like, optional\n       weight for each :math:`(x_i, y_i)` pair.\n\n    Returns\n    -------\n    :py:obj:`numpy.ndarray`\n        The bin counts.\n    :py:obj:`numpy.ndarray`\n        The standard error of each bin count, :math:`\\sqrt{\\sum_i w_i^2}`.\n\n    Examples\n    --------\n    A histogram of (``x``, ``y``) with 20 bins between 0 and 100 in\n    the ``x`` dimention and 10 bins between 0 and 50 in the ``y``\n    dimension:\n\n    >>> h, __ = fix2d(x, y, bins=(20, 10), range=((0, 100), (0, 50)))\n\n    The same data, now histogrammed weighted (via ``w``):\n\n    >>> h, err = fix2d(x, y, bins=(20, 10), range=((0, 100), (0, 50)), weights=w)\n\n    """"""\n    x = np.ascontiguousarray(x)\n    y = np.ascontiguousarray(y)\n    if x.shape != y.shape:\n        raise ValueError(""x and y must be the same shape"")\n    if weights is None:\n        weights = np.ones_like(x, dtype=np.float64)\n    else:\n        weights = np.ascontiguousarray(weights)\n\n    if isinstance(bins, numbers.Integral):\n        nx = ny = bins\n    else:\n        nx, ny = bins\n\n    if range is None:\n        range = [(x.min(), x.max()), (y.min(), y.max())]\n    (xmin, xmax), (ymin, ymax) = range\n\n    return _f2dw(x, y, weights, nx, xmin, xmax, ny, ymin, ymax, False, True)\n\n\ndef var2d(x, y, xbins, ybins, weights=None):\n    r""""""Histogram the ``x``, ``y`` data with variable width binning.\n\n    Parameters\n    ----------\n    x : array_like\n       first entries in the data pairs to histogram\n    y : array_like\n       second entries in the data pairs to histogram\n    xbins : array_like\n       bin edges for the ``x`` dimension\n    ybins : array_like\n       bin edges for the ``y`` dimension\n    weights : array_like, optional\n       weights for each :math:`(x_i, y_i)` pair.\n\n    Returns\n    -------\n    :py:obj:`numpy.ndarray`\n        The bin counts.\n    :py:obj:`numpy.ndarray`\n        The standard error of each bin count, :math:`\\sqrt{\\sum_i w_i^2}`.\n\n    Examples\n    --------\n    A histogram of (``x``, ``y``) where the edges are defined by a\n    :func:`numpy.logspace` in both dimensions:\n\n    >>> bins = numpy.logspace(0.1, 1.0, 10, endpoint=True)\n    >>> h, __ = var2d(x, y, bins, bins)\n\n    """"""\n    x = np.ascontiguousarray(x)\n    y = np.ascontiguousarray(y)\n    if x.shape != y.shape:\n        raise ValueError(""x and y must be the same shape"")\n    xbins = np.ascontiguousarray(xbins)\n    ybins = np.ascontiguousarray(ybins)\n    if not np.all(xbins[1:] >= xbins[:-1]):\n        raise ValueError(""xbins sequence must monotonically increase"")\n    if not np.all(ybins[1:] >= ybins[:-1]):\n        raise ValueError(""ybins sequence must monotonically increase"")\n\n    if weights is None:\n        weights = np.ones_like(x, dtype=np.float64)\n    else:\n        weights = np.ascontiguousarray(weights)\n\n    return _v2dw(x, y, weights, xbins, ybins, False, True)\n\n\ndef histogram2d(x, y, bins=10, range=None, weights=None):\n    r""""""Histogram data in two dimensions.\n\n    This function provides an API very simiar to\n    :func:`numpy.histogram2d`. Keep in mind that the returns are\n    different.\n\n    Parameters\n    ----------\n    x: array_like\n       Array representing the ``x`` coordinate of the data to histogram.\n    y: array_like\n       Array representing the ``y`` coordinate of the data to histogram.\n    bins: int or array_like or [int, int] or [array, array], optional\n       The bin specification:\n          * If `int`, the number of bins for the two dimensions\n            (``nx = ny = bins``).\n          * If `array_like`, the bin edges for the two dimensions\n            (``x_edges = y_edges = bins``).\n          * If [int, int], the number of bins in each dimension\n            (``nx, ny = bins``).\n          * If [`array_like`, `array_like`], the bin edges in each\n            dimension (``x_edges, y_edges = bins``).\n    range: array_like, shape(2,2), optional\n       The edges of this histogram along each dimension. If ``bins``\n       is not integral, then this parameter is ignored. If None, the\n       default is ``[[x.min(), x.max()], [y.min(), y.max()]]``.\n    weights: array_like\n       An array of weights associated to each element :math:`(x_i,\n       y_i)` pair.  Each pair of the data will contribute its\n       associated weight to the bin count.\n\n    Returns\n    -------\n    :py:obj:`numpy.ndarray`\n        The bin counts.\n    :py:obj:`numpy.ndarray`\n        The standard error of each bin count, :math:`\\sqrt{\\sum_i w_i^2}`.\n\n    Examples\n    --------\n    >>> h, err = histogram2d(x, y, weights=w)\n\n    """"""\n    try:\n        N = len(bins)\n    except TypeError:\n        N = 1\n\n    if N != 1 and N != 2:\n        return var2d(x, y, bins, bins, weights=weights)\n\n    if N == 1:\n        return fix2d(x, y, bins=bins, range=range, weights=weights)\n\n    if N == 2:\n        if isinstance(bins[0], numbers.Integral) and isinstance(\n            bins[1], numbers.Integral\n        ):\n            return fix2d(x, y, bins=bins, range=range, weights=weights)\n        else:\n            return var2d(x, y, bins[0], bins[1], weights=weights)\n'"
