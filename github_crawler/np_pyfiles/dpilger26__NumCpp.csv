file_path,api_count,code
docs/sphinx/conf.py,0,"b'# Configuration file for the Sphinx documentation builder.\r\n#\r\n# This file only contains a selection of the most common options. For a full\r\n# list see the documentation:\r\n# http://www.sphinx-doc.org/en/master/config\r\n\r\n# -- Path setup --------------------------------------------------------------\r\n\r\n# If extensions (or modules to document with autodoc) are in another directory,\r\n# add these directories to sys.path here. If the directory is relative to the\r\n# documentation root, use os.path.abspath to make it absolute, like shown here.\r\n#\r\n# import os\r\n# import sys\r\n# sys.path.insert(0, os.path.abspath(\'.\'))\r\n\r\n\r\n# -- Project information -----------------------------------------------------\r\n\r\nproject = \'NumCpp\'\r\ncopyright = \'2019, David Pilger\'\r\nauthor = \'David Pilger\'\r\n\r\n# The full version, including alpha/beta/rc tags\r\nrelease = \'1.0\'\r\n\r\n\r\n# -- General configuration ---------------------------------------------------\r\n\r\n# Add any Sphinx extension module names here, as strings. They can be\r\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\r\n# ones.\r\nextensions = [\'breathe\']\r\n\r\n# Breathe Configuration\r\nbreathe_projects = { project: \'../doxygen/xml\' }\r\nbreathe_default_project = project\r\n\r\n# Add any paths that contain templates here, relative to this directory.\r\ntemplates_path = [\'_templates\']\r\n\r\n# List of patterns, relative to source directory, that match files and\r\n# directories to ignore when looking for source files.\r\n# This pattern also affects html_static_path and html_extra_path.\r\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\']\r\n\r\n\r\n# -- Options for HTML output -------------------------------------------------\r\n\r\n# The theme to use for HTML and HTML Help pages.  See the documentation for\r\n# a list of builtin themes.\r\n#\r\nhtml_theme = \'sphinx_rtd_theme\'\r\n\r\n# Add any paths that contain custom static files (such as style sheets) here,\r\n# relative to this directory. They are copied after the builtin static files,\r\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\r\nhtml_static_path = [\'_static\']\r\n'"
unitTests/testScripts/TestAll.py,0,"b""import TestConstants\nimport TestCoordinates\nimport TestDataCube\nimport TestDtypeInfo\nimport TestFilters\nimport TestFunctions\nimport TestImageProcessing\nimport TestIntegrate\nimport TestLinalg\nimport TestNdArray\nimport TestPolynomial\nimport TestRandom\nimport TestRotations\nimport TestRoots\nimport TestShape\nimport TestSlice\nimport TestSpecial\nimport TestTimer\nimport TestUtils\nimport TestVector\n\n\n#################################################################################\ndef doTest():\n    TestConstants.doTest()\n    TestCoordinates.doTest()\n    TestDataCube.doTest()\n    TestDtypeInfo.doTest()\n    TestFilters.doTest()\n    TestFunctions.doTest()\n    TestImageProcessing.doTest()\n    TestIntegrate.doTest()\n    TestLinalg.doTest()\n    TestNdArray.doTest()\n    TestPolynomial.doTest()\n    TestRandom.doTest()\n    TestRotations.doTest()\n    TestRoots.doTest()\n    TestShape.doTest()\n    TestSlice.doTest()\n    TestSpecial.doTest()\n    TestTimer.doTest()\n    TestUtils.doTest()\n    TestVector.doTest()\n\n\n#################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestConstants.py,4,"b""import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Constants Module', 'magenta'))\n\n    NUM_DECIMALS_ROUND = 10\n\n    print(colored('Testing c', 'cyan'))\n    if round(NumCpp.c, NUM_DECIMALS_ROUND) == round(3e8, 10):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing e', 'cyan'))\n    if round(NumCpp.e, NUM_DECIMALS_ROUND) == round(np.e, 10):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing inf', 'cyan'))\n    if np.isinf(NumCpp.inf):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing pi', 'cyan'))\n    if round(NumCpp.pi, NUM_DECIMALS_ROUND) == round(np.pi, 10):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing nan', 'cyan'))\n    if np.isnan(NumCpp.nan):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing VERSION', 'cyan'))\n    if NumCpp.VERSION == '1.3':\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestCoordinates.py,36,"b""import numpy as np\nfrom astropy.coordinates import SkyCoord\nfrom astropy.coordinates import Angle, Latitude, Longitude  # Angles\nimport astropy.units as u\nfrom termcolor import colored\nimport sys\nimport os\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Coordinates Module', 'magenta'))\n\n    print(colored('Testing Ra', 'magenta'))\n    print(colored('Testing Default Constructor', 'cyan'))\n    ra = NumCpp.Ra()\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing Degree Constructor', 'cyan'))\n    randDegrees = np.random.rand(1).item() * 360\n    ra = NumCpp.Ra(randDegrees)\n    raPy = Longitude(randDegrees, unit=u.deg)\n    if (round(ra.degrees(), 9) == round(randDegrees, 9) and\n        ra.hours() == raPy.hms.h and\n        ra.minutes() == raPy.hms.m and\n        round(ra.seconds(), 9) == round(raPy.hms.s, 9) and\n        round(ra.radians(), 9) == round(np.deg2rad(randDegrees), 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing hms Constructor', 'cyan'))\n    hours = np.random.randint(0, 24, [1,], dtype=np.uint8).item()\n    minutes = np.random.randint(0, 60, [1, ], dtype=np.uint8).item()\n    seconds = np.random.rand(1).astype(np.double).item() * 60\n    ra = NumCpp.Ra(hours, minutes, seconds)\n    degreesPy = (hours + minutes / 60 + seconds / 3600) * 15\n    if (round(ra.degrees(), 9) == round(degreesPy, 9) and\n        ra.hours() == hours and\n        ra.minutes() == minutes and\n        round(ra.seconds(), 9) == round(seconds, 9) and\n        round(ra.radians(), 9) == round(np.deg2rad(degreesPy), 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing equality operator', 'cyan'))\n    ra2 = NumCpp.Ra(ra)\n    if ra == ra2:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing not equality operator', 'cyan'))\n    randDegrees = np.random.rand(1).item() * 360\n    ra2 = NumCpp.Ra(randDegrees)\n    if ra != ra2:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing print', 'cyan'))\n    ra.print()\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing Dec', 'magenta'))\n    print(colored('Testing Default Constructor', 'cyan'))\n    dec = NumCpp.Dec()\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing Degree Constructor', 'cyan'))\n    randDegrees = np.random.rand(1).item() * 180 - 90\n    dec = NumCpp.Dec(randDegrees)\n    decPy = Latitude(randDegrees, unit=u.deg)\n    sign = NumCpp.Sign.NEGATIVE if randDegrees < 0 else NumCpp.Sign.POSITIVE\n    if (round(dec.degrees(), 8) == round(randDegrees, 8) and\n        dec.sign() == sign and\n        dec.degreesWhole() == abs(decPy.dms.d) and\n        dec.minutes() == abs(decPy.dms.m) and\n        round(dec.seconds(), 8) == round(abs(decPy.dms.s), 8) and\n        round(dec.radians(), 8) == round(np.deg2rad(randDegrees), 8)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing dms Constructor', 'cyan'))\n    sign = NumCpp.Sign.POSITIVE if np.random.randint(-1, 1) == 0 else NumCpp.Sign.NEGATIVE\n    degrees = np.random.randint(0, 91, [1, ], dtype=np.uint8).item()\n    minutes = np.random.randint(0, 60, [1, ], dtype=np.uint8).item()\n    seconds = np.random.rand(1).astype(np.double).item() * 60\n    dec = NumCpp.Dec(sign, degrees, minutes, seconds)\n    degreesPy = degrees + minutes / 60 + seconds / 3600\n    if sign == NumCpp.Sign.NEGATIVE:\n        degreesPy *= -1\n    if (dec.sign() == sign and\n        round(dec.degrees(), 9) == round(degreesPy, 9) and\n        dec.degreesWhole() == degrees and\n        dec.minutes() == minutes and\n        round(dec.seconds(), 9) == round(seconds, 9) and\n        round(dec.radians(), 8) == round(np.deg2rad(degreesPy), 8)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing equality operator', 'cyan'))\n    dec2 = NumCpp.Dec(dec)\n    if dec == dec2:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing not equality operator', 'cyan'))\n    randDegrees = np.random.rand(1).item() * 180 - 90\n    dec2 = NumCpp.Dec(randDegrees)\n    if dec != dec2:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing print', 'cyan'))\n    dec.print()\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing Coordinate', 'magenta'))\n    print(colored('Testing Default Constructor', 'cyan'))\n    coord = NumCpp.Coordinate()\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing Degree Constructor', 'cyan'))\n    raDegrees = np.random.rand(1).item() * 360\n    ra = NumCpp.Ra(raDegrees)\n    decDegrees = np.random.rand(1).item() * 180 - 90\n    dec = NumCpp.Dec(decDegrees)\n\n    pyCoord = SkyCoord(raDegrees, decDegrees, unit=u.deg)\n    cCoord = NumCpp.Coordinate(raDegrees, decDegrees)\n    if (cCoord.ra() == ra and\n        cCoord.dec() == dec and\n        round(cCoord.x(), 10) == round(pyCoord.cartesian.x.value, 10) and\n        round(cCoord.y(), 10) == round(pyCoord.cartesian.y.value, 10) and\n        round(cCoord.z(), 10) == round(pyCoord.cartesian.z.value, 10)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Ra/Dec Constructor', 'cyan'))\n    raDegrees = np.random.rand(1).item() * 360\n    ra = NumCpp.Ra(raDegrees)\n    decDegrees = np.random.rand(1).item() * 180 - 90\n    dec = NumCpp.Dec(decDegrees)\n\n    pyCoord = SkyCoord(raDegrees, decDegrees, unit=u.deg)\n    cCoord = NumCpp.Coordinate(ra, dec)\n    if (cCoord.ra() == ra and\n        cCoord.dec() == dec and\n        round(cCoord.x(), 10) == round(pyCoord.cartesian.x.value, 10) and\n        round(cCoord.y(), 10) == round(pyCoord.cartesian.y.value, 10) and\n        round(cCoord.z(), 10) == round(pyCoord.cartesian.z.value, 10)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing x/y/z Constructor', 'cyan'))\n    raDegrees = np.random.rand(1).item() * 360\n    ra = NumCpp.Ra(raDegrees)\n    decDegrees = np.random.rand(1).item() * 180 - 90\n    dec = NumCpp.Dec(decDegrees)\n    pyCoord = SkyCoord(raDegrees, decDegrees, unit=u.deg)\n    cCoord = NumCpp.Coordinate(pyCoord.cartesian.x.value, pyCoord.cartesian.y.value, pyCoord.cartesian.z.value)\n    if (round(cCoord.ra().degrees(), 9) == round(ra.degrees(), 9) and\n        round(cCoord.dec().degrees(), 9) == round(dec.degrees(), 9) and\n        round(cCoord.x(), 9) == round(pyCoord.cartesian.x.value, 9) and\n        round(cCoord.y(), 9) == round(pyCoord.cartesian.y.value, 9) and\n        round(cCoord.z(), 9) == round(pyCoord.cartesian.z.value, 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing NdArray Constructor', 'cyan'))\n    raDegrees = np.random.rand(1).item() * 360\n    ra = NumCpp.Ra(raDegrees)\n    decDegrees = np.random.rand(1).item() * 180 - 90\n    dec = NumCpp.Dec(decDegrees)\n    pyCoord = SkyCoord(raDegrees, decDegrees, unit=u.deg)\n    vec = np.asarray([pyCoord.cartesian.x.value, pyCoord.cartesian.y.value, pyCoord.cartesian.z.value])\n    cVec = NumCpp.NdArray(1, 3)\n    cVec.setArray(vec)\n    cCoord = NumCpp.Coordinate(cVec)\n    if (round(cCoord.ra().degrees(), 9) == round(ra.degrees(), 9) and\n        round(cCoord.dec().degrees(), 9) == round(dec.degrees(), 9) and\n        round(cCoord.x(), 9) == round(pyCoord.cartesian.x.value, 9) and\n        round(cCoord.y(), 9) == round(pyCoord.cartesian.y.value, 9) and\n        round(cCoord.z(), 9) == round(pyCoord.cartesian.z.value, 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing hms/dms Constructor', 'cyan'))\n    raHours = np.random.randint(0, 24, [1, ], dtype=np.uint8).item()\n    raMinutes = np.random.randint(0, 60, [1, ], dtype=np.uint8).item()\n    raSeconds = np.random.rand(1).astype(np.double).item() * 60\n    raDegreesPy = (raHours + raMinutes / 60 + raSeconds / 3600) * 15\n\n    decSign = NumCpp.Sign.POSITIVE if np.random.randint(-1, 1) == 0 else NumCpp.Sign.NEGATIVE\n    decDegrees = np.random.randint(0, 90, [1, ], dtype=np.uint8).item()\n    decMinutes = np.random.randint(0, 60, [1, ], dtype=np.uint8).item()\n    decSeconds = np.random.rand(1).astype(np.double).item() * 60\n    decDegreesPy = decDegrees + decMinutes / 60 + decSeconds / 3600\n    if decSign == NumCpp.Sign.NEGATIVE:\n        decDegreesPy *= -1\n\n    cCoord = NumCpp.Coordinate(raHours, raMinutes, raSeconds, decSign, decDegrees, decMinutes, decSeconds)\n    cRa = cCoord.ra()\n    cDec = cCoord.dec()\n    pyCoord = SkyCoord(raDegreesPy, decDegreesPy, unit=u.deg)\n    if (round(cRa.degrees(), 9) == round(raDegreesPy, 9) and\n        cRa.hours() == raHours and\n        cRa.minutes() == raMinutes and\n        round(cRa.seconds(), 9) == round(raSeconds, 9) and\n        cDec.sign() == decSign and\n        round(cDec.degrees(), 9) == round(decDegreesPy, 9) and\n        cDec.degreesWhole() == decDegrees and\n        cDec.minutes() == decMinutes and\n        round(cDec.seconds(), 9) == round(decSeconds, 9) and\n        round(cCoord.x(), 9) == round(pyCoord.cartesian.x.value, 9) and\n        round(cCoord.y(), 9) == round(pyCoord.cartesian.y.value, 9) and\n        round(cCoord.z(), 9) == round(pyCoord.cartesian.z.value, 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing equality operator', 'cyan'))\n    cCoord2 = NumCpp.Coordinate(cCoord)\n    if cCoord2 == cCoord:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing not equality operator', 'cyan'))\n    raDegrees = np.random.rand(1).item() * 360\n    decDegrees = np.random.rand(1).item() * 180 - 90\n    cCoord2 = NumCpp.Coordinate(raDegrees, decDegrees)\n    if cCoord2 != cCoord:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing xyz', 'cyan'))\n    xyz = [cCoord.x(), cCoord.y(), cCoord.z()]\n    if np.array_equal(cCoord.xyz().getNumpyArray().flatten(), xyz):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing degreeSeperation Coordinate', 'cyan'))\n    pyCoord2 = SkyCoord(cCoord2.ra().degrees(), cCoord2.dec().degrees(), unit=u.deg)\n    cDegSep = cCoord.degreeSeperation(cCoord2)\n    pyDegSep = pyCoord.separation(pyCoord2).value\n    if round(cDegSep, 9) == round(pyDegSep, 9):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing radianSeperation Coordinate', 'cyan'))\n    cRadSep = cCoord.radianSeperation(cCoord2)\n    pyRadSep = np.deg2rad(pyDegSep)\n    if round(cRadSep, 9) == round(pyRadSep, 9):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing degreeSeperation Vector', 'cyan'))\n    vec2 = np.asarray([pyCoord2.cartesian.x, pyCoord2.cartesian.y, pyCoord2.cartesian.z])\n    cArray = NumCpp.NdArray(1, 3)\n    cArray.setArray(vec2)\n    cDegSep = cCoord.degreeSeperation(cArray)\n    if round(cDegSep, 9) == round(pyDegSep, 9):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing radianSeperation Vector', 'cyan'))\n    cArray = NumCpp.NdArray(1, 3)\n    cArray.setArray(vec2)\n    cDegSep = cCoord.radianSeperation(cArray)\n    if round(cDegSep, 9) == round(pyRadSep, 9):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing print', 'cyan'))\n    cCoord.print()\n    print(colored('\\tPASS', 'green'))\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestDataCube.py,7,"b""import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing DataCube Module', 'magenta'))\n\n    print(colored('Testing Default Constructor', 'cyan'))\n    dataCube = NumCpp.DataCube()\n    if dataCube.isempty():\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Size Constructor', 'cyan'))\n    size = np.random.randint(10, 20, [1,]).item()\n    dataCube = NumCpp.DataCube(size)\n    if dataCube.size() == size:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing push_front/push_back', 'cyan'))\n    shape = np.random.randint(10, 100, [3,])\n    cShape = NumCpp.Shape(shape[0].item(), shape[1].item())\n    data = np.random.randint(0, 100, shape)\n    dataCube = NumCpp.DataCube()\n    frameOrder = list()\n    for frame in range(shape[-1]):\n        cArray = NumCpp.NdArray(cShape)\n        cArray.setArray(data[:, :, frame])\n        if frame % 2 == 0:\n            dataCube.push_back(cArray)\n            frameOrder.append(frame)\n        else:\n            dataCube.push_front(cArray)\n            frameOrder = [frame] + frameOrder\n    if not dataCube.isempty() and dataCube.size() == shape[-1]:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing shape', 'cyan'))\n    if dataCube.shape() == cShape:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing back', 'cyan'))\n    if np.array_equal(dataCube.back().getNumpyArray(), data[:, :, frameOrder[-1]]):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing front', 'cyan'))\n    if np.array_equal(dataCube.front().getNumpyArray(), data[:, :, frameOrder[0]]):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing [] operator', 'cyan'))\n    allPass = True\n    for idx, frame in enumerate(frameOrder):\n        if not np.array_equal(dataCube[idx].getNumpyArray(), data[:, :, frame]):\n            allPass = False\n            break\n    if allPass:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing at', 'cyan'))\n    for idx, frame in enumerate(frameOrder):\n        if not np.array_equal(dataCube.at(idx).getNumpyArray(), data[:, :, frame]):\n            allPass = False\n            break\n    if allPass:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing dump', 'cyan'))\n    tempDir = r'C:\\Temp'\n    if not os.path.exists(tempDir):\n        os.mkdir(tempDir)\n    tempFile = os.path.join(tempDir, 'DataCube.bin')\n    dataCube.dump(tempFile)\n    if os.path.exists(tempFile):\n        filesize = os.path.getsize(tempFile)\n        if filesize == data.size * 8:\n            print(colored('\\tPASS', 'green'))\n        else:\n            print(colored('\\tFAIL', 'red'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n    os.remove(tempFile)\n\n    print(colored('Testing pop_front/pop_back', 'cyan'))\n    sizeInitial = dataCube.size()\n    sizeNow = sizeInitial\n    allPass = True\n    for idx in range(sizeInitial):\n        if idx % 2 == 0:\n            dataCube.pop_front()\n        else:\n            dataCube.pop_back()\n\n        sizeNow -= 1\n\n        if dataCube.size() != sizeNow:\n            allPass = False\n\n    if dataCube.isempty() and allPass:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestDtypeInfo.py,2,"b""import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing DtypeInfo Class', 'magenta'))\n\n    print(colored('Testing bits', 'cyan'))\n    if NumCpp.DtypeIntoUint32.bits() == 32:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing epsilon', 'cyan'))\n    if NumCpp.DtypeIntoUint32.epsilon() == 0:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing isInteger', 'cyan'))\n    if NumCpp.DtypeIntoUint32.isInteger():\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing max', 'cyan'))\n    if NumCpp.DtypeIntoUint32.max() == np.iinfo(np.uint32).max:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing min', 'cyan'))\n    if NumCpp.DtypeIntoUint32.min() == np.iinfo(np.uint32).min:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestFilters.py,108,"b""import numpy as np\r\nfrom termcolor import colored\r\nimport scipy.ndimage.filters as filters\r\nimport os\r\nimport sys\r\nif sys.platform == 'linux':\r\n    sys.path.append(r'../lib')\r\nelse:\r\n    sys.path.append(os.path.abspath('../build/x64/Release'))\r\nimport NumCpp\r\n\r\n####################################################################################\r\ndef doTest():\r\n    print(colored('Testing Filters', 'magenta'))\r\n    test1D()\r\n    test2D()\r\n\r\n####################################################################################\r\ndef test1D():\r\n    modes = {'reflect' : NumCpp.Mode.REFLECT,\r\n             'constant': NumCpp.Mode.CONSTANT,\r\n             'nearest': NumCpp.Mode.NEAREST,\r\n             'mirror': NumCpp.Mode.MIRROR,\r\n             'wrap': NumCpp.Mode.WRAP}\r\n\r\n    for mode in modes.keys():\r\n        print(colored(f'Testing complementaryMedianFilter1d: mode = {mode}', 'cyan'))\r\n        size = np.random.randint(1000, 2000, [1,]).item()\r\n        cShape = NumCpp.Shape(1, size)\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, [size,])\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.complementaryMedianFilter1d(cArray, kernalSize, modes[mode], constantValue).getNumpyArray().flatten()\r\n        dataOutPy = data - filters.generic_filter(data, np.median, footprint=np.ones([kernalSize,]), mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing convolve1d: mode = {mode}', 'cyan'))\r\n        size = np.random.randint(1000, 2000, [1,]).item()\r\n        cShape = NumCpp.Shape(1, size)\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, [size,]).astype(np.double)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        weights = np.random.randint(1, 5, [kernalSize,])\r\n        cWeights = NumCpp.NdArray(1, kernalSize)\r\n        cWeights.setArray(weights)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.convolve1d(cArray, cWeights, modes[mode], constantValue).getNumpyArray().flatten()\r\n        dataOutPy = filters.convolve(data, weights, mode=mode, cval=constantValue)\r\n        if np.array_equal(np.round(dataOutC, 8), np.round(dataOutPy, 8)):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing gaussianFilter1d: mode = {mode}', 'cyan'))\r\n        size = np.random.randint(1000, 2000, [1,]).item()\r\n        cShape = NumCpp.Shape(1, size)\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, [size,]).astype(np.double)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        sigma = np.random.rand(1).item() * 2\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.gaussianFilter1d(cArray, sigma, modes[mode], constantValue).getNumpyArray().flatten()\r\n        dataOutPy = filters.gaussian_filter(data, sigma, mode=mode, cval=constantValue)\r\n        if np.array_equal(np.round(dataOutC, 7), np.round(dataOutPy, 7)):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing maximumFilter1d: mode = {mode}', 'cyan'))\r\n        size = np.random.randint(1000, 2000, [1,]).item()\r\n        cShape = NumCpp.Shape(1, size)\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, [size,])\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.maximumFilter1d(cArray, kernalSize, modes[mode], constantValue).getNumpyArray().flatten()\r\n        dataOutPy = filters.generic_filter(data, np.max, footprint=np.ones([kernalSize,]), mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing medianFilter1d: mode = {mode}', 'cyan'))\r\n        size = np.random.randint(1000, 2000, [1,]).item()\r\n        cShape = NumCpp.Shape(1, size)\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, [size,])\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.medianFilter1d(cArray, kernalSize, modes[mode], constantValue).getNumpyArray().flatten()\r\n        dataOutPy = filters.generic_filter(data, np.median, footprint=np.ones([kernalSize,]), mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing minumumFilter1d: mode = {mode}', 'cyan'))\r\n        size = np.random.randint(1000, 2000, [1,]).item()\r\n        cShape = NumCpp.Shape(1, size)\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, [size,])\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.minumumFilter1d(cArray, kernalSize, modes[mode], constantValue).getNumpyArray().flatten()\r\n        dataOutPy = filters.generic_filter(data, np.min, footprint=np.ones([kernalSize,]), mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing percentileFilter1d: mode = {mode}', 'cyan'))\r\n        size = np.random.randint(1000, 2000, [1,]).item()\r\n        cShape = NumCpp.Shape(1, size)\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, [size,]).astype(np.double)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        percentile = np.random.randint(0, 101, [1,]).item()\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.percentileFilter1d(cArray, kernalSize, percentile, modes[mode], constantValue).getNumpyArray().flatten()\r\n        dataOutPy = filters.generic_filter(data, np.percentile, footprint=np.ones([kernalSize,]), mode=mode, cval=constantValue, extra_arguments=(percentile,))\r\n        if np.array_equal(np.round(dataOutC, 7), np.round(dataOutPy, 7)):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing rankFilter1d: mode = {mode}', 'cyan'))\r\n        size = np.random.randint(1000, 2000, [1,]).item()\r\n        cShape = NumCpp.Shape(1, size)\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, [size,]).astype(np.double)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        rank = np.random.randint(0, kernalSize - 1, [1, ]).item()\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.rankFilter1d(cArray, kernalSize, rank, modes[mode], constantValue).getNumpyArray().flatten()\r\n        dataOutPy = filters.rank_filter(data, rank, footprint=np.ones([kernalSize,]), mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing uniformFilter1d: mode = {mode}', 'cyan'))\r\n        size = np.random.randint(1000, 2000, [1,]).item()\r\n        cShape = NumCpp.Shape(1, size)\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, [size,]).astype(np.double)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.uniformFilter1d(cArray, kernalSize, modes[mode], constantValue).getNumpyArray().flatten()\r\n        dataOutPy = filters.generic_filter(data, np.mean, footprint=np.ones([kernalSize,]), mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n####################################################################################\r\ndef test2D():\r\n    modes = {'reflect' : NumCpp.Mode.REFLECT,\r\n             'constant': NumCpp.Mode.CONSTANT,\r\n             'nearest': NumCpp.Mode.NEAREST,\r\n             'mirror': NumCpp.Mode.MIRROR,\r\n             'wrap': NumCpp.Mode.WRAP}\r\n\r\n    for mode in modes.keys():\r\n        print(colored(f'Testing complementaryMedianFilter: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, shape)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.complementaryMedianFilter(cArray, kernalSize, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = data - filters.median_filter(data, size=kernalSize, mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing convolve: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(10, 20, shape).astype(np.double)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        weights = np.random.randint(-2, 3, [kernalSize, kernalSize]).astype(np.double)\r\n        cWeights = NumCpp.NdArray(kernalSize)\r\n        cWeights.setArray(weights)\r\n        dataOutC = NumCpp.convolve(cArray, kernalSize, cWeights, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = filters.convolve(data, weights, mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing gaussianFilter: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, shape).astype(np.double)\r\n        cArray.setArray(data)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        sigma = np.random.rand(1).item() * 2\r\n        dataOutC = NumCpp.gaussianFilter(cArray, sigma, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = filters.gaussian_filter(data, sigma, mode=mode, cval=constantValue)\r\n        if np.array_equal(np.round(dataOutC, 2), np.round(dataOutPy, 2)):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing laplaceFilter: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, shape).astype(np.double)\r\n        cArray.setArray(data)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.laplaceFilter(cArray, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = filters.laplace(data, mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing maximumFilter: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, shape)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.maximumFilter(cArray, kernalSize, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = filters.maximum_filter(data, size=kernalSize, mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing medianFilter: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, shape)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.medianFilter(cArray, kernalSize, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = filters.median_filter(data, size=kernalSize, mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing minimumFilter: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, shape)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.minimumFilter(cArray, kernalSize, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = filters.minimum_filter(data, size=kernalSize, mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing percentileFilter: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, shape)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        percentile = np.random.randint(0, 101, [1,]).item()\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.percentileFilter(cArray, kernalSize, percentile, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = filters.percentile_filter(data, percentile, size=kernalSize, mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing rankFilter: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, shape)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        rank = np.random.randint(0, kernalSize**2 - 1, [1,]).item()\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.rankFilter(cArray, kernalSize, rank, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = filters.rank_filter(data, rank, size=kernalSize, mode=mode, cval=constantValue)\r\n        if np.array_equal(dataOutC, dataOutPy):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n        print(colored(f'Testing uniformFilter: mode = {mode}', 'cyan'))\r\n        shape = np.random.randint(100, 200, [2,]).tolist()\r\n        cShape = NumCpp.Shape(shape[0], shape[1])\r\n        cArray = NumCpp.NdArray(cShape)\r\n        data = np.random.randint(100, 1000, shape).astype(np.double)\r\n        cArray.setArray(data)\r\n        kernalSize = 0\r\n        while kernalSize % 2 == 0:\r\n            kernalSize = np.random.randint(5, 15)\r\n        constantValue = np.random.randint(0, 5, [1,]).item() # only actaully needed for constant boundary condition\r\n        dataOutC = NumCpp.uniformFilter(cArray, kernalSize, modes[mode], constantValue).getNumpyArray()\r\n        dataOutPy = filters.uniform_filter(data, size=kernalSize, mode=mode, cval=constantValue)\r\n        if np.array_equal(np.round(dataOutC, 8), np.round(dataOutPy, 8)):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n\r\n####################################################################################\r\nif __name__ == '__main__':\r\n    # test1D()\r\n    # test2D()\r\n    doTest()\r\n"""
unitTests/testScripts/TestFunctions.py,1568,"b'import os\nimport getpass\nimport numpy as np\nimport scipy.ndimage.measurements as meas\nfrom functools import reduce\nfrom termcolor import colored\nimport sys\nif sys.platform == \'linux\':\n    sys.path.append(r\'../lib\')\nelse:\n    sys.path.append(os.path.abspath(\'../build/x64/Release\'))\nimport NumCpp\n\n####################################################################################\ndef factors(n):\n    return set(reduce(list.__add__,\n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\n####################################################################################\ndef doTest():\n    print(colored(\'Testing Functions Module\', \'magenta\'))\n\n    print(colored(\'Testing abs scaler\', \'cyan\'))\n    randValue = np.random.randint(-100, -1, [1,]).astype(np.double).item()\n    if NumCpp.absScaler(randValue) == np.abs(randValue):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing abs array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.absArray(cArray), np.abs(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing add\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.add(cArray1, cArray2), data1 + data2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing alen array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.alen(cArray) == shape.rows:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing all: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.all(cArray, NumCpp.Axis.NONE).astype(np.bool).item() == np.all(data).item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing all: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.all(cArray, NumCpp.Axis.ROW).flatten().astype(np.bool), np.all(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing all: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.all(cArray, NumCpp.Axis.COL).flatten().astype(np.bool), np.all(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing allclose\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    cArray3 = NumCpp.NdArray(shape)\n    tolerance = 1e-5\n    data1 = np.random.randn(shape.rows, shape.cols)\n    data2 = data1 + tolerance / 10\n    data3 = data1 + 1\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    if NumCpp.allclose(cArray1, cArray2, tolerance) and not NumCpp.allclose(cArray1, cArray3, tolerance):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing amax: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.amax(cArray, NumCpp.Axis.NONE).item() == np.max(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing amax: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.amax(cArray, NumCpp.Axis.ROW).flatten(), np.max(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing amax: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.amax(cArray, NumCpp.Axis.COL).flatten(), np.max(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing amin: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.amin(cArray, NumCpp.Axis.NONE).item() == np.min(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing amin: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.amin(cArray, NumCpp.Axis.ROW).flatten(), np.min(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing amin: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.amin(cArray, NumCpp.Axis.COL).flatten(), np.min(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing any: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.any(cArray, NumCpp.Axis.NONE).astype(np.bool).item() == np.any(data).item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing any: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.any(cArray, NumCpp.Axis.ROW).flatten().astype(np.bool), np.any(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing any: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.any(cArray, NumCpp.Axis.COL).flatten().astype(np.bool), np.any(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing append: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.append(cArray1, cArray2, NumCpp.Axis.NONE).getNumpyArray().flatten(), np.append(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing append: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    numRows = np.random.randint(1, 100, [1, ]).item()\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[0].item() + numRows, shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    data1 = np.random.randint(0, 100, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(0, 100, [shape2.rows, shape2.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.append(cArray1, cArray2, NumCpp.Axis.ROW).getNumpyArray(), np.append(data1, data2, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing append: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    NumCppols = np.random.randint(1, 100, [1, ]).item()\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + NumCppols)\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    data1 = np.random.randint(0, 100, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(0, 100, [shape2.rows, shape2.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.append(cArray1, cArray2, NumCpp.Axis.COL).getNumpyArray(), np.append(data1, data2, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arange\', \'cyan\'))\n    start = np.random.randn(1).item()\n    stop = np.random.randn(1).item() * 100\n    step = np.abs(np.random.randn(1).item())\n    if stop < start:\n        step *= -1\n    data = np.arange(start, stop, step)\n    if np.array_equal(np.round(NumCpp.arange(start, stop, step).flatten(), 9), np.round(data, 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arccos scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.arccosScaler(value), 9) == np.round(np.arccos(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arccos array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.arccosArray(cArray), 9), np.round(np.arccos(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arccosh scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item()) + 1\n    if np.round(NumCpp.arccoshScaler(value), 9) == np.round(np.arccosh(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arccosh array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols) + 1\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.arccoshArray(cArray), 9), np.round(np.arccosh(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arcsin scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.arcsinScaler(value), 9) == np.round(np.arcsin(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arcsin array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.arcsinArray(cArray), 9), np.round(np.arcsin(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arcsinh scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.arcsinhScaler(value), 9) == np.round(np.arcsinh(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arcsinh array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.arcsinhArray(cArray), 9), np.round(np.arcsinh(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arctan scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.arctanScaler(value), 9) == np.round(np.arctan(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arctan array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.arctanArray(cArray), 9), np.round(np.arctan(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arctan2 scaler\', \'cyan\'))\n    xy = NumCpp.uniformOnSphere(1, 2).getNumpyArray().flatten()\n    if np.round(NumCpp.arctan2Scaler(xy[1], xy[0]), 9) == np.round(np.arctan2(xy[1], xy[0]), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arctan2 array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArrayX = NumCpp.NdArray(shape)\n    cArrayY = NumCpp.NdArray(shape)\n    xy = NumCpp.uniformOnSphere(np.prod(shapeInput).item(), 2).getNumpyArray()\n    xData = xy[:, 0].reshape(shapeInput)\n    yData = xy[:, 1].reshape(shapeInput)\n    cArrayX.setArray(xData)\n    cArrayY.setArray(yData)\n    if np.array_equal(np.round(NumCpp.arctan2Array(cArrayY, cArrayX), 9), np.round(np.arctan2(yData, xData), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arctanh scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.arctanhScaler(value), 9) == np.round(np.arctanh(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing arctanh array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.arctanhArray(cArray), 9), np.round(np.arctanh(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argmax: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.argmax(cArray, NumCpp.Axis.NONE).item(), np.argmax(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argmax: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.argmax(cArray, NumCpp.Axis.ROW).flatten(), np.argmax(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argmax: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.argmax(cArray, NumCpp.Axis.COL).flatten(), np.argmax(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argmin: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.argmin(cArray, NumCpp.Axis.NONE).item(), np.argmin(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argmin: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.argmin(cArray, NumCpp.Axis.ROW).flatten(), np.argmin(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argmin: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.argmin(cArray, NumCpp.Axis.COL).flatten(), np.argmin(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argsort: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    dataFlat = data.flatten()\n    if np.array_equal(dataFlat[NumCpp.argsort(cArray, NumCpp.Axis.NONE).flatten().astype(np.uint32)], dataFlat[np.argsort(data, axis=None)]):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argsort: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    pIdx = np.argsort(data, axis=0)\n    cIdx = NumCpp.argsort(cArray, NumCpp.Axis.ROW).astype(np.uint16)\n    allPass = True\n    for idx, row in enumerate(data.T):\n        if not np.array_equal(row[cIdx[:, idx]], row[pIdx[:, idx]]):\n            allPass = False\n            break\n    if allPass:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argsort: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    pIdx = np.argsort(data, axis=1)\n    cIdx = NumCpp.argsort(cArray, NumCpp.Axis.COL).astype(np.uint16)\n    allPass = True\n    for idx, row in enumerate(data):\n        if not np.array_equal(row[cIdx[idx, :]], row[pIdx[idx, :]]):\n            allPass = False\n            break\n    if allPass:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing argwhere\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    randValue = np.random.randint(0,100, [1,]).item()\n    data2 = data > randValue\n    cArray.setArray(data2)\n    if np.array_equal(NumCpp.argwhere(cArray).flatten(), np.argwhere(data.flatten() > randValue).flatten()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing around scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item()) * np.random.randint(1, 10, [1,]).item()\n    numDecimalsRound = np.random.randint(0, 10, [1,]).astype(np.uint8).item()\n    if NumCpp.aroundScaler(value, numDecimalsRound) == np.round(value, numDecimalsRound):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing around array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols) * np.random.randint(1, 10, [1,]).item()\n    cArray.setArray(data)\n    numDecimalsRound = np.random.randint(0, 10, [1,]).astype(np.uint8).item()\n    if np.array_equal(NumCpp.aroundArray(cArray, numDecimalsRound), np.round(data, numDecimalsRound)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing array_equal\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    cArray3 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 100, shapeInput)\n    data2 = np.random.randint(1, 100, shapeInput)\n    cArray1.setArray(data1)\n    cArray2.setArray(data1)\n    cArray3.setArray(data2)\n    if NumCpp.array_equal(cArray1, cArray2) and not NumCpp.array_equal(cArray1, cArray3):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing array_equiv\', \'cyan\'))\n    shapeInput1 = np.random.randint(1, 100, [2, ])\n    shapeInput3 = np.random.randint(1, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput1[0].item(), shapeInput1[1].item())\n    shape2 = NumCpp.Shape(shapeInput1[1].item(), shapeInput1[0].item())\n    shape3 = NumCpp.Shape(shapeInput3[0].item(), shapeInput3[1].item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    cArray3 = NumCpp.NdArray(shape3)\n    data1 = np.random.randint(1, 100, shapeInput1)\n    data3 = np.random.randint(1, 100, shapeInput3)\n    cArray1.setArray(data1)\n    cArray2.setArray(data1.reshape([shapeInput1[1].item(), shapeInput1[0].item()]))\n    cArray3.setArray(data3)\n    if NumCpp.array_equiv(cArray1, cArray2) and not NumCpp.array_equiv(cArray1, cArray3):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing average: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.average(cArray, NumCpp.Axis.NONE).item() == np.average(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing average: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.average(cArray, NumCpp.Axis.ROW).flatten(), np.average(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing average: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.average(cArray, NumCpp.Axis.COL).flatten(), np.average(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing average weighted: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    cWeights = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    weights = np.random.randint(1, 5, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    cWeights.setArray(weights)\n    if NumCpp.averageWeighted(cArray, cWeights, NumCpp.Axis.NONE).item() == np.average(data, weights=weights):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing average weighted: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    cWeights = NumCpp.NdArray(1, shape.cols)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    weights = np.random.randint(1, 5, [1, shape.rows])\n    cArray.setArray(data)\n    cWeights.setArray(weights)\n    if np.array_equal(NumCpp.averageWeighted(cArray, cWeights, NumCpp.Axis.ROW).flatten(), np.average(data, weights=weights.flatten(), axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing average weighted: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    cWeights = NumCpp.NdArray(1, shape.rows)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    weights = np.random.randint(1, 5, [1, shape.cols])\n    cWeights.setArray(weights)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.averageWeighted(cArray, cWeights, NumCpp.Axis.COL).flatten(), np.average(data, weights=weights.flatten(), axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing binary\', \'cyan\'))\n    value = np.random.randint(0, np.iinfo(np.uint64).max, [1,], dtype=np.uint64).item()\n    if NumCpp.binaryRepr(np.uint64(value)) == np.binary_repr(value, np.iinfo(np.uint64).bits):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing bincount\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArrayInt(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint16)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.bincount(cArray, 0).flatten(), np.bincount(data.flatten(), minlength=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing bincount with minLength\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArrayInt(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint16)\n    cArray.setArray(data)\n    minLength = int(data.max() + 10)\n    if np.array_equal(NumCpp.bincount(cArray, minLength).flatten(), np.bincount(data.flatten(), minlength=minLength)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing bincount weighted\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArrayInt(shape)\n    cWeights = NumCpp.NdArrayInt(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint16)\n    weights = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint16)\n    cArray.setArray(data)\n    cWeights.setArray(weights)\n    if np.array_equal(NumCpp.bincountWeighted(cArray, cWeights, 0).flatten(), np.bincount(data.flatten(), minlength=0, weights=weights.flatten())):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing bincount weighted with minLength\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArrayInt(shape)\n    cWeights = NumCpp.NdArrayInt(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint16)\n    weights = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint16)\n    cArray.setArray(data)\n    cWeights.setArray(weights)\n    minLength = int(data.max() + 10)\n    if np.array_equal(NumCpp.bincountWeighted(cArray, cWeights, minLength).flatten(), np.bincount(data.flatten(), minlength=minLength, weights=weights.flatten())):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing bitwise_and\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArrayInt64(shape)\n    cArray2 = NumCpp.NdArrayInt64(shape)\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint64)\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint64)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.bitwise_and(cArray1, cArray2), np.bitwise_and(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing bitwise_not\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArrayInt64(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint64)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.bitwise_not(cArray), np.bitwise_not(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing bitwise_or\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArrayInt64(shape)\n    cArray2 = NumCpp.NdArrayInt64(shape)\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint64)\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint64)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.bitwise_or(cArray1, cArray2), np.bitwise_or(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing bitwise_xor\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArrayInt64(shape)\n    cArray2 = NumCpp.NdArrayInt64(shape)\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint64)\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint64)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.bitwise_xor(cArray1, cArray2), np.bitwise_xor(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cbrt\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.cbrtArray(cArray), 9), np.round(np.cbrt(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ceil\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols).astype(np.double) * 1000\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.ceilArray(cArray), 9), np.round(np.ceil(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing centerOfMass Axis = NONE\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols).astype(np.double) * 1000\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.centerOfMass(cArray, NumCpp.Axis.NONE).flatten(), 9),\n                      np.round(meas.center_of_mass(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing centerOfMass Axis = ROW\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols).astype(np.double) * 1000\n    cArray.setArray(data)\n\n    coms = list()\n    for col in range(data.shape[1]):\n        coms.append(np.round(meas.center_of_mass(data[:, col])[0], 9))\n\n    if np.array_equal(np.round(NumCpp.centerOfMass(cArray, NumCpp.Axis.ROW).flatten(), 9), np.round(coms, 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing centerOfMass Axis = COL\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols).astype(np.double) * 1000\n    cArray.setArray(data)\n\n    coms = list()\n    for row in range(data.shape[0]):\n        coms.append(np.round(meas.center_of_mass(data[row, :])[0], 9))\n\n    if np.array_equal(np.round(NumCpp.centerOfMass(cArray, NumCpp.Axis.COL).flatten(), 9), np.round(coms, 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing clip scaler\', \'cyan\'))\n    value = np.random.randint(0, 100, [1, ]).item()\n    minValue = np.random.randint(0, 10, [1, ]).item()\n    maxValue = np.random.randint(90, 100, [1, ]).item()\n    if NumCpp.clipScaler(value, minValue, maxValue) == np.clip(value, minValue, maxValue):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing clip array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    minValue = np.random.randint(0, 10, [1, ]).item()\n    maxValue = np.random.randint(90, 100, [1, ]).item()\n    if np.array_equal(NumCpp.clipArray(cArray, minValue, maxValue), np.clip(data, minValue, maxValue)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing column_stack\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    shape3 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    shape4 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    cArray3 = NumCpp.NdArray(shape3)\n    cArray4 = NumCpp.NdArray(shape4)\n    data1 = np.random.randint(1, 100, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(1, 100, [shape2.rows, shape2.cols])\n    data3 = np.random.randint(1, 100, [shape3.rows, shape3.cols])\n    data4 = np.random.randint(1, 100, [shape4.rows, shape4.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(NumCpp.column_stack(cArray1, cArray2, cArray3, cArray4),\n                      np.column_stack([data1, data2, data3, data4])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing concatenate: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    shape3 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    shape4 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    cArray3 = NumCpp.NdArray(shape3)\n    cArray4 = NumCpp.NdArray(shape4)\n    data1 = np.random.randint(1, 100, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(1, 100, [shape2.rows, shape2.cols])\n    data3 = np.random.randint(1, 100, [shape3.rows, shape3.cols])\n    data4 = np.random.randint(1, 100, [shape4.rows, shape4.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(NumCpp.concatenate(cArray1, cArray2, cArray3, cArray4, NumCpp.Axis.NONE).flatten(),\n                      np.concatenate([data1.flatten(), data2.flatten(), data3.flatten(), data4.flatten()])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing concatenate: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[0].item() + np.random.randint(1, 10, [1,]).item(), shapeInput[1].item())\n    shape3 = NumCpp.Shape(shapeInput[0].item() + np.random.randint(1, 10, [1,]).item(), shapeInput[1].item())\n    shape4 = NumCpp.Shape(shapeInput[0].item() + np.random.randint(1, 10, [1,]).item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    cArray3 = NumCpp.NdArray(shape3)\n    cArray4 = NumCpp.NdArray(shape4)\n    data1 = np.random.randint(1, 100, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(1, 100, [shape2.rows, shape2.cols])\n    data3 = np.random.randint(1, 100, [shape3.rows, shape3.cols])\n    data4 = np.random.randint(1, 100, [shape4.rows, shape4.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(NumCpp.concatenate(cArray1, cArray2, cArray3, cArray4, NumCpp.Axis.ROW),\n                      np.concatenate([data1, data2, data3, data4], axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing concatenate: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    shape3 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    shape4 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    cArray3 = NumCpp.NdArray(shape3)\n    cArray4 = NumCpp.NdArray(shape4)\n    data1 = np.random.randint(1, 100, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(1, 100, [shape2.rows, shape2.cols])\n    data3 = np.random.randint(1, 100, [shape3.rows, shape3.cols])\n    data4 = np.random.randint(1, 100, [shape4.rows, shape4.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(NumCpp.concatenate(cArray1, cArray2, cArray3, cArray4, NumCpp.Axis.COL),\n                      np.concatenate([data1, data2, data3, data4], axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing contains: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    value = np.random.randint(0, 100, [1, ]).item()\n    cArray.setArray(data)\n    if NumCpp.contains(cArray, value, NumCpp.Axis.NONE).getNumpyArray().item() == (value in data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing contains: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    value = np.random.randint(0, 100, [1, ]).item()\n    cArray.setArray(data)\n    truth = list()\n    for row in data:\n        truth.append(value in row)\n    if np.array_equal(NumCpp.contains(cArray, value, NumCpp.Axis.COL).getNumpyArray().flatten(), np.asarray(truth)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing contains: Axis = ROW\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    value = np.random.randint(0, 100, [1, ]).item()\n    cArray.setArray(data)\n    truth = list()\n    for row in data.T:\n        truth.append(value in row)\n    if np.array_equal(NumCpp.contains(cArray, value, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.asarray(truth)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing copy\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.copy(cArray), data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing copysign\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.copysign(cArray1, cArray2), np.copysign(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing copyto\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray()\n    data1 = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    if np.array_equal(NumCpp.copyto(cArray2, cArray1), data1):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cos scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.cosScaler(value), 9) == np.round(np.cos(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cos array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.cosArray(cArray), 9), np.round(np.cos(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cosh scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.cosScaler(value), 9) == np.round(np.cos(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cosh array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.coshArray(cArray), 9), np.round(np.cosh(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing count_nonzero: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 3, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if NumCpp.count_nonzero(cArray, NumCpp.Axis.NONE) == np.count_nonzero(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing count_nonzero: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 3, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.count_nonzero(cArray, NumCpp.Axis.ROW).flatten(), np.count_nonzero(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing count_nonzero: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 3, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.count_nonzero(cArray, NumCpp.Axis.COL).flatten(), np.count_nonzero(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cross 2D: Axis = None\', \'cyan\'))\n    shape = NumCpp.Shape(1, 2)\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    data2 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if NumCpp.cross(cArray1, cArray2, NumCpp.Axis.NONE).item() == np.cross(data1, data2).item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cross 2D: Axis = ROW\', \'cyan\'))\n    shape = NumCpp.Shape(2, np.random.randint(1, 100, [1, ]).item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    data2 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.cross(cArray1, cArray2, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.cross(data1, data2, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cross 2D: Axis = COL\', \'cyan\'))\n    shape = NumCpp.Shape(np.random.randint(1, 100, [1, ]).item(), 2)\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    data2 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.cross(cArray1, cArray2, NumCpp.Axis.COL).getNumpyArray().flatten(), np.cross(data1, data2, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cross 3D: Axis = None\', \'cyan\'))\n    shape = NumCpp.Shape(1, 3)\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    data2 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.cross(cArray1, cArray2, NumCpp.Axis.NONE).getNumpyArray().flatten(), np.cross(data1, data2).flatten()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cross 3D: Axis = ROW\', \'cyan\'))\n    shape = NumCpp.Shape(3, np.random.randint(1,100, [1, ]).item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    data2 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.cross(cArray1, cArray2, NumCpp.Axis.ROW).getNumpyArray(), np.cross(data1, data2, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cross 3D: Axis = COL\', \'cyan\'))\n    shape = NumCpp.Shape(np.random.randint(1,100, [1, ]).item(), 3)\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    data2 = np.random.randint(1, 10, [shape.rows, shape.cols]).astype(np.double)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.cross(cArray1, cArray2, NumCpp.Axis.COL).getNumpyArray(), np.cross(data1, data2, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cube array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.cube(cArray), 9), np.round(data * data * data, 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cumprod: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(1, 5, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 4, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.cumprod(cArray, NumCpp.Axis.NONE).flatten().astype(np.uint32), data.cumprod()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cumprod: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 5, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 4, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.cumprod(cArray, NumCpp.Axis.ROW).astype(np.uint32), data.cumprod(axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cumprod: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 5, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 4, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.cumprod(cArray, NumCpp.Axis.COL).astype(np.uint32), data.cumprod(axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cumsum: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.cumsum(cArray, NumCpp.Axis.NONE).flatten().astype(np.uint32), data.cumsum()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cumsum: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.cumsum(cArray, NumCpp.Axis.ROW).astype(np.uint32), data.cumsum(axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing cumsum: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.cumsum(cArray, NumCpp.Axis.COL).astype(np.uint32), data.cumsum(axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing deg2rad scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item()) * 360\n    if np.round(NumCpp.deg2radScaler(value), 9) == np.round(np.deg2rad(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing deg2rad array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols) * 360\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.deg2radArray(cArray), 9), np.round(np.deg2rad(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing degrees scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item()) * 2 * np.pi\n    if np.round(NumCpp.degreesScaler(value), 9) == np.round(np.degrees(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing degrees array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols) * 2 * np.pi\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.degreesArray(cArray), 9), np.round(np.degrees(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing deleteIndices Slice: Axis = NONE\', \'cyan\'))\n    shapeInput = np.asarray([100,100])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    indices = NumCpp.Slice(0, 100, 4)\n    indicesPy = slice(0, 99, 4)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.deleteIndicesSlice(cArray, indices, NumCpp.Axis.NONE).flatten(), np.delete(data, indicesPy, axis=None)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing deleteIndices Slice: Axis = Row\', \'cyan\'))\n    shapeInput = np.asarray([100,100])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    indices = NumCpp.Slice(0, 100, 4)\n    indicesPy = slice(0, 99, 4)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.deleteIndicesSlice(cArray, indices, NumCpp.Axis.ROW), np.delete(data, indicesPy, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing deleteIndices Slice: Axis = Col\', \'cyan\'))\n    shapeInput = np.asarray([100,100])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    indices = NumCpp.Slice(0, 100, 4)\n    indicesPy = slice(0, 99, 4)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.deleteIndicesSlice(cArray, indices, NumCpp.Axis.COL), np.delete(data, indicesPy, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing deleteIndices Scaler: Axis = NONE\', \'cyan\'))\n    shapeInput = np.asarray([100,100])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    index = np.random.randint(0, shape.size(), [1, ]).item()\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.deleteIndicesScaler(cArray, index, NumCpp.Axis.NONE).flatten(), np.delete(data, index, axis=None)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing deleteIndices Slice: Axis = Row\', \'cyan\'))\n    shapeInput = np.asarray([100,100])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    index = np.random.randint(0, 100, [1, ]).item()\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.deleteIndicesScaler(cArray, index, NumCpp.Axis.ROW), np.delete(data, index, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing deleteIndices Slice: Axis = Col\', \'cyan\'))\n    shapeInput = np.asarray([100,100])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    index = np.random.randint(0, 100, [1, ]).item()\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.deleteIndicesScaler(cArray, index, NumCpp.Axis.COL), np.delete(data, index, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing diag extract\', \'cyan\'))\n    shapeInput = np.random.randint(2, 25, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    k = np.random.randint(0, np.min(shapeInput), [1,]).item()\n    elements = np.random.randint(1, 100, shapeInput)\n    cElements = NumCpp.NdArray(shape)\n    cElements.setArray(elements)\n    if np.array_equal(NumCpp.diag(cElements, k).flatten(), np.diag(elements, k)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing diag make\', \'cyan\'))\n    numElements = np.random.randint(2, 25, [1, ]).item()\n    shape = NumCpp.Shape(1, numElements)\n    k = np.random.randint(0, 10, [1,]).item()\n    elements = np.random.randint(1, 100, [numElements,])\n    cElements = NumCpp.NdArray(shape)\n    cElements.setArray(elements)\n    if np.array_equal(NumCpp.diagflat(cElements, k), np.diagflat(elements, k)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing diagflat\', \'cyan\'))\n    numElements = np.random.randint(1, 25, [1, ]).item()\n    shape = NumCpp.Shape(1, numElements)\n    k = np.random.randint(0, 10, [1,]).item()\n    elements = np.random.randint(1, 100, [numElements,])\n    cElements = NumCpp.NdArray(shape)\n    cElements.setArray(elements)\n    if np.array_equal(NumCpp.diagflat(cElements, k), np.diagflat(elements, k)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing diagonal: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    offset = np.random.randint(0, min(shape.rows, shape.cols), [1, ]).item()\n    if np.array_equal(NumCpp.diagonal(cArray, offset, NumCpp.Axis.ROW).astype(np.uint32).flatten(),\n                      np.diagonal(data, offset, axis1=0, axis2=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing diagonal: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    offset = np.random.randint(0, min(shape.rows, shape.cols), [1, ]).item()\n    if np.array_equal(NumCpp.diagonal(cArray, offset, NumCpp.Axis.COL).astype(np.uint32).flatten(),\n                      np.diagonal(data, offset, axis1=1, axis2=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing diff: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.diff(cArray, NumCpp.Axis.NONE).flatten().astype(np.uint32), np.diff(data.flatten())):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing diff: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.diff(cArray, NumCpp.Axis.ROW).astype(np.uint32), np.diff(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing diff: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.diff(cArray, NumCpp.Axis.COL).astype(np.uint32), np.diff(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(data)\n        print(NumCpp.diff(cArray, NumCpp.Axis.COL).astype(np.uint32))\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing divide\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.double)\n    data2 = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.double)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(np.round(NumCpp.divide(cArray1, cArray2), 9), np.round(np.divide(data1, data2), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing dot vector\', \'cyan\'))\n    size = np.random.randint(1, 100, [1,]).item()\n    shape = NumCpp.Shape(1, size)\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    data2 = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if NumCpp.dot(cArray1, cArray2).astype(np.uint32).item() == np.dot(data1, data2.T).item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing dot array\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[1].item(), np.random.randint(1, 100, [1,]).item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    data1 = np.random.randint(1, 50, [shape1.rows, shape1.cols], dtype=np.uint32)\n    data2 = np.random.randint(1, 50, [shape2.rows, shape2.cols], dtype=np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.dot(cArray1, cArray2).astype(np.uint32), np.dot(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing dump\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    tempDir = r\'C:\\Temp\'\n    if not os.path.exists(tempDir):\n        os.mkdir(tempDir)\n    tempFile = os.path.join(tempDir, \'NdArrayDump.bin\')\n    NumCpp.dump(cArray, tempFile)\n    if os.path.exists(tempFile):\n        data2 = np.fromfile(tempFile, dtype=np.double).reshape(shapeInput)\n        if np.array_equal(data, data2):\n            print(colored(\'\\tPASS\', \'green\'))\n        else:\n            print(colored(\'\\tFAIL\', \'red\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n    os.remove(tempFile)\n\n    print(colored(\'Testing empty rectangle\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    cArray = NumCpp.emptyRowCol(shapeInput[0].item(), shapeInput[1].item())\n    if (cArray.shape[0] == shapeInput[0] and cArray.shape[1] == shapeInput[1] and\n            cArray.size == shapeInput.prod()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing empty Shape\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.emptyShape(shape)\n    if (cArray.shape[0] == shape.rows and cArray.shape[1] == shape.cols and\n            cArray.size == shapeInput.prod()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing empty_like\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.empty_like(cArray1)\n    if (cArray2.shape().rows == shape.rows and cArray2.shape().cols == shape.cols and\n            cArray2.size() == shapeInput.prod()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing endianess\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    if NumCpp.endianess(cArray) == NumCpp.Endian.NATIVE:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing equal\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(0, 10, [shape.rows, shape.cols])\n    data2 = np.random.randint(0, 10, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.equal(cArray1, cArray2), np.equal(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing exp scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.expScaler(value), 9) == np.round(np.exp(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing exp array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.expArray(cArray), 9), np.round(np.exp(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing exp2 scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.exp2Scaler(value), 9) == np.round(np.exp2(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing exp2 array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.exp2Array(cArray), 9), np.round(np.exp2(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing expm1 scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item())\n    if np.round(NumCpp.expm1Scaler(value), 9) == np.round(np.expm1(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing expm1 array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.expm1Array(cArray), 9), np.round(np.expm1(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing eye 1D\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [1, ]).item()\n    randK = np.random.randint(0, shapeInput, [1, ]).item()\n    if np.array_equal(NumCpp.eye1D(shapeInput, randK), np.eye(shapeInput, k=randK)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing eye 2D\', \'cyan\'))\n    shapeInput = np.random.randint(10, 100, [2, ])\n    randK = np.random.randint(0, shapeInput.min(), [1, ]).item()\n    if np.array_equal(NumCpp.eye2D(shapeInput[0].item(), shapeInput[1].item(), randK), np.eye(shapeInput[0].item(), shapeInput[1].item(), k=randK)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing eye Shape\', \'cyan\'))\n    shapeInput = np.random.randint(10, 100, [2, ])\n    cShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    randK = np.random.randint(0, shapeInput.min(), [1, ]).item()\n    if np.array_equal(NumCpp.eyeShape(cShape, randK), np.eye(shapeInput[0].item(), shapeInput[1].item(), k=randK)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fillDiagonal\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100\n    cArray.setArray(data)\n    NumCpp.fillDiagonal(cArray, 666)\n    np.fill_diagonal(data, 666)\n    if np.array_equal(cArray.getNumpyArray(), data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing find\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100\n    cArray.setArray(data)\n    value = data.mean()\n    cMask = cArray.operatorGreater(value)\n    cMaskArray = NumCpp.NdArrayBool(cMask.shape[0], cMask.shape[1])\n    cMaskArray.setArray(cMask)\n    idxs = NumCpp.find(cMaskArray).astype(np.int64)\n    idxsPy = np.nonzero((data > value).flatten())[0]\n    if np.array_equal(idxs.flatten(), idxsPy):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing findN\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100\n    cArray.setArray(data)\n    value = data.mean()\n    cMask = cArray.operatorGreater(value)\n    cMaskArray = NumCpp.NdArrayBool(cMask.shape[0], cMask.shape[1])\n    cMaskArray.setArray(cMask)\n    idxs = NumCpp.findN(cMaskArray, 8).astype(np.int64)\n    idxsPy = np.nonzero((data > value).flatten())[0]\n    if np.array_equal(idxs.flatten(), idxsPy[:8]):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fix scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100\n    if NumCpp.fixScaler(value) == np.fix(value):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fix array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.fixArray(cArray), np.fix(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing flatten\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.flatten(cArray).getNumpyArray(), np.resize(data, [1, data.size])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing flatnonzero\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.flatnonzero(cArray).getNumpyArray().flatten(), np.flatnonzero(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing flip\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.flip(cArray, NumCpp.Axis.NONE).getNumpyArray(), np.flip(data.reshape(1, data.size), axis=1).reshape(shapeInput)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fliplr\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.fliplr(cArray).getNumpyArray(), np.fliplr(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing flipud\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.flipud(cArray).getNumpyArray(), np.flipud(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing floor scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100\n    if NumCpp.floorScaler(value) == np.floor(value):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing floor array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.floorArray(cArray), np.floor(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing floor_divide scaler\', \'cyan\'))\n    value1 = np.random.randn(1).item() * 100 + 1000\n    value2 = np.random.randn(1).item() * 100 + 1000\n    if NumCpp.floor_divideScaler(value1, value2) == np.floor_divide(value1, value2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing floor_divide array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    data2 = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.floor_divideArray(cArray1, cArray2), np.floor_divide(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fmax scaler\', \'cyan\'))\n    value1 = np.random.randn(1).item() * 100 + 1000\n    value2 = np.random.randn(1).item() * 100 + 1000\n    if NumCpp.fmaxScaler(value1, value2) == np.fmax(value1, value2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fmax array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    data2 = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.fmaxArray(cArray1, cArray2), np.fmax(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fmin scaler\', \'cyan\'))\n    value1 = np.random.randn(1).item() * 100 + 1000\n    value2 = np.random.randn(1).item() * 100 + 1000\n    if NumCpp.fminScaler(value1, value2) == np.fmin(value1, value2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fmin array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    data2 = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.fminArray(cArray1, cArray2), np.fmin(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fmod scaler\', \'cyan\'))\n    value1 = np.random.randint(1, 100, [1, ]).item() * 100 + 1000\n    value2 = np.random.randint(1, 100, [1, ]).item() * 100 + 1000\n    if NumCpp.fmodScaler(value1, value2) == np.fmod(value1, value2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fmod array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArrayInt(shape)\n    cArray2 = NumCpp.NdArrayInt(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]) * 100 + 1000\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]) * 100 + 1000\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.fmodArray(cArray1, cArray2), np.fmod(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fromfile: bin\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    tempDir = r\'C:\\Temp\'\n    if not os.path.exists(tempDir):\n        os.mkdir(tempDir)\n    tempFile = os.path.join(tempDir, \'NdArrayDump.bin\')\n    NumCpp.dump(cArray, tempFile)\n    data2 = NumCpp.fromfile(tempFile, \'\').reshape(shape)\n    if np.array_equal(data, data2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n    os.remove(tempFile)\n\n    print(colored(\'Testing fromfile: txt\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    tempDir = r\'C:\\Temp\'\n    if not os.path.exists(tempDir):\n        os.mkdir(tempDir)\n    tempFile = os.path.join(tempDir, \'NdArrayDump\')\n    NumCpp.tofile(cArray, tempFile, \'\\n\')\n    data2 = NumCpp.fromfile(tempFile + \'.txt\', \'\\n\').reshape(shape)\n    if np.array_equal(data, data2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n    os.remove(tempFile + \'.txt\')\n\n    print(colored(\'Testing full square\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [1,]).item()\n    value = np.random.randint(1, 100, [1, ]).item()\n    cArray = NumCpp.fullSquare(shapeInput, value)\n    if (cArray.shape[0] == shapeInput and cArray.shape[1] == shapeInput and\n            cArray.size == shapeInput**2 and np.all(cArray == value)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing full rectangle\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    value = np.random.randint(1, 100, [1, ]).item()\n    cArray = NumCpp.fullRowCol(shapeInput[0].item(), shapeInput[1].item(), value)\n    if (cArray.shape[0] == shapeInput[0] and cArray.shape[1] == shapeInput[1] and\n            cArray.size == shapeInput.prod() and np.all(cArray == value)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing full Shape\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    value = np.random.randint(1, 100, [1, ]).item()\n    cArray = NumCpp.fullShape(shape, value)\n    if (cArray.shape[0] == shape.rows and cArray.shape[1] == shape.cols and\n            cArray.size == shapeInput.prod() and np.all(cArray == value)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing full_like\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    value = np.random.randint(1, 100, [1, ]).item()\n    cArray2 = NumCpp.full_like(cArray1, value)\n    if (cArray2.shape().rows == shape.rows and cArray2.shape().cols == shape.cols and\n            cArray2.size() == shapeInput.prod() and np.all(cArray2.getNumpyArray() == value)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing gcd scaler\', \'cyan\'))\n    value1 = np.random.randint(1, 1000, [1, ]).item()\n    value2 = np.random.randint(1, 1000, [1, ]).item()\n    if NumCpp.gcdScaler(value1, value2) == np.gcd(value1, value2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing gcd array\', \'cyan\'))\n    size = np.random.randint(20, 100, [1, ]).item()\n    cArray = NumCpp.NdArrayInt32(1, size)\n    data = np.random.randint(1, 1000, [size,])\n    cArray.setArray(data)\n    if NumCpp.gcdArray(cArray) == np.gcd.reduce(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing gradient: Axis::ROW\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 1000, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.gradient(cArray, NumCpp.Axis.ROW).getNumpyArray(), np.gradient(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing gradient: Axis::COL\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 1000, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.gradient(cArray, NumCpp.Axis.COL).getNumpyArray(), np.gradient(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing gradient: Axis::None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 1000, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.gradient(cArray, NumCpp.Axis.NONE).getNumpyArray().flatten(), np.gradient(data.flatten(), axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing greater\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.greater(cArray1, cArray2).getNumpyArray(), np.greater(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing greater_equal array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.greater_equal(cArray1, cArray2).getNumpyArray(), np.greater_equal(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing histogram\', \'cyan\'))\n    shape = NumCpp.Shape(1024, 1024)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(1024, 1024) * np.random.randint(1, 10, [1, ]).item() + np.random.randint(1, 10, [1, ]).item()\n    cArray.setArray(data)\n    numBins = np.random.randint(10, 30, [1,]).item()\n    histogram, bins = NumCpp.histogram(cArray, numBins)\n    h, b = np.histogram(data, numBins)\n    if np.array_equal(histogram.getNumpyArray().flatten().astype(np.int32), h) and \\\n            np.array_equal(np.round(bins.getNumpyArray().flatten(), 9), np.round(b, 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing hstack\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    shape3 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    shape4 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + np.random.randint(1, 10, [1,]).item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    cArray3 = NumCpp.NdArray(shape3)\n    cArray4 = NumCpp.NdArray(shape4)\n    data1 = np.random.randint(1, 100, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(1, 100, [shape2.rows, shape2.cols])\n    data3 = np.random.randint(1, 100, [shape3.rows, shape3.cols])\n    data4 = np.random.randint(1, 100, [shape4.rows, shape4.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(NumCpp.hstack(cArray1, cArray2, cArray3, cArray4),\n                      np.hstack([data1, data2, data3, data4])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing hypot scaler\', \'cyan\'))\n    value1 = np.random.randn(1).item() * 100 + 1000\n    value2 = np.random.randn(1).item() * 100 + 1000\n    if NumCpp.hypotScaler(value1, value2) == np.hypot(value1, value2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing hypot triple scaler\', \'cyan\'))\n    value1 = np.random.randn(1).item() * 100 + 1000\n    value2 = np.random.randn(1).item() * 100 + 1000\n    value3 = np.random.randn(1).item() * 100 + 1000\n    if (NumCpp.hypotScalerTriple(value1, value2, value3) ==\n            np.sqrt(value1**2 + value2**2 + value3**2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing hypot array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    data2 = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.hypotArray(cArray1, cArray2), np.hypot(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing identity\', \'cyan\'))\n    squareSize = np.random.randint(10, 100, [1, ]).item()\n    if np.array_equal(NumCpp.identity(squareSize).getNumpyArray(), np.identity(squareSize)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing interp\', \'cyan\'))\n    endPoint = np.random.randint(10, 20, [1,]).item()\n    numPoints = np.random.randint(50, 100, [1,]).item()\n    resample = np.random.randint(2, 5, [1,]).item()\n    xpData = np.linspace(0, endPoint, numPoints, endpoint=True)\n    fpData = np.sin(xpData)\n    xData = np.linspace(0, endPoint, numPoints * resample, endpoint=True)\n    cXp = NumCpp.NdArray(1, numPoints)\n    cFp = NumCpp.NdArray(1, numPoints)\n    cX = NumCpp.NdArray(1, numPoints * resample)\n    cXp.setArray(xpData)\n    cFp.setArray(fpData)\n    cX.setArray(xData)\n    if np.array_equal(np.round(NumCpp.interp(cX, cXp, cFp).flatten(), 9),\n                      np.round(np.interp(xData, xpData, fpData), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing intersect1d\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArrayInt(shape)\n    cArray2 = NumCpp.NdArrayInt(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.intersect1d(cArray1, cArray2).getNumpyArray().flatten(), np.intersect1d(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing invert\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArrayInt(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.invert(cArray).getNumpyArray(), np.invert(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing isclose\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.rand(shape.rows, shape.cols)\n    data2 = data1 + np.random.randn(shape.rows, shape.cols) * 1e-5\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    rtol = 1e-5\n    atol = 1e-8\n    if np.array_equal(NumCpp.isclose(cArray1, cArray2, rtol, atol).getNumpyArray(), np.isclose(data1, data2, rtol=rtol, atol=atol)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing isinf scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100 + 1000\n    if NumCpp.isinfScaler(value) == np.isinf(value):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing isinf array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    data[data > 1000] = np.inf\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.isinfArray(cArray), np.isinf(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing isnan scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100 + 1000\n    if NumCpp.isnanScaler(value) == np.isnan(value):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing isnan array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    data[data > 1000] = np.nan\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.isnanArray(cArray), np.isnan(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing lcm scaler\', \'cyan\'))\n    value1 = np.random.randint(1, 1000, [1, ]).item()\n    value2 = np.random.randint(1, 1000, [1, ]).item()\n    if NumCpp.lcmScaler(value1, value2) == np.lcm(value1, value2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing lcm array\', \'cyan\'))\n    size = np.random.randint(2, 10, [1, ]).item()\n    cArray = NumCpp.NdArrayInt32(1, size)\n    data = np.random.randint(1, 100, [size, ])\n    cArray.setArray(data)\n    if NumCpp.lcmArray(cArray) == np.lcm.reduce(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ldexp scaler\', \'cyan\'))\n    value1 = np.random.randn(1).item() * 100\n    value2 = np.random.randint(1, 20, [1,]).item()\n    if np.round(NumCpp.ldexpScaler(value1, value2), 9) == np.round(np.ldexp(value1, value2), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ldexp array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArrayInt8(shape)\n    data1 = np.random.randn(shape.rows, shape.cols) * 100\n    data2 = np.random.randint(1, 20, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(np.round(NumCpp.ldexpArray(cArray1, cArray2), 9), np.round(np.ldexp(data1, data2), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing left_shift\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    bitsToShift = np.random.randint(1, 32, [1, ]).item()\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArrayInt(shape)\n    data = np.random.randint(1, np.iinfo(np.uint32).max, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.left_shift(cArray, bitsToShift).getNumpyArray(), np.left_shift(data, bitsToShift)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing less\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.less(cArray1, cArray2).getNumpyArray(), np.less(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing less_equal array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.less_equal(cArray1, cArray2).getNumpyArray(), np.less_equal(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing load\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    tempDir = r\'C:\\Temp\'\n    if not os.path.exists(tempDir):\n        os.mkdir(tempDir)\n    tempFile = os.path.join(tempDir, \'NdArrayDump.bin\')\n    NumCpp.dump(cArray, tempFile)\n    data2 = NumCpp.load(tempFile).reshape(shape)\n    if np.array_equal(data, data2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n    os.remove(tempFile)\n\n    print(colored(\'Testing linspace: include endPoint True\', \'cyan\'))\n    start = np.random.randint(1, 10, [1, ]).item()\n    end = np.random.randint(start + 10, 100, [1, ]).item()\n    numPoints = np.random.randint(1, 100, [1, ]).item()\n    if np.array_equal(np.round(NumCpp.linspace(start, end, numPoints, True).getNumpyArray().flatten(), 9),\n                      np.round(np.linspace(start, end, numPoints, endpoint=True), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing linspace: include endPoint False\', \'cyan\'))\n    start = np.random.randint(1, 10, [1, ]).item()\n    end = np.random.randint(start + 10, 100, [1, ]).item()\n    numPoints = np.random.randint(1, 100, [1, ]).item()\n    if np.array_equal(np.round(NumCpp.linspace(start, end, numPoints, False).getNumpyArray().flatten(), 9),\n                      np.round(np.linspace(start, end, numPoints, endpoint=False), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing log scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100 + 1000\n    if np.round(NumCpp.logScaler(value), 9) == np.round(np.log(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing log array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.logArray(cArray), 9), np.round(np.log(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing log10 scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100 + 1000\n    if np.round(NumCpp.log10Scaler(value), 9) == np.round(np.log10(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing log10 array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.log10Array(cArray), 9), np.round(np.log10(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing log1p scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100 + 1000\n    if np.round(NumCpp.log1pScaler(value), 9) == np.round(np.log1p(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing log1p array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.log1pArray(cArray), 9), np.round(np.log1p(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing log2 scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100 + 1000\n    if np.round(NumCpp.log2Scaler(value), 9) == np.round(np.log2(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing log2 array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100 + 1000\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.log2Array(cArray), 9), np.round(np.log2(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing logical_and\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(0, 20, [shape.rows, shape.cols])\n    data2 = np.random.randint(0, 20, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.logical_and(cArray1, cArray2).getNumpyArray(), np.logical_and(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing logical_not\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 20, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.logical_not(cArray).getNumpyArray(), np.logical_not(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing logical_or\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(0, 20, [shape.rows, shape.cols])\n    data2 = np.random.randint(0, 20, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.logical_or(cArray1, cArray2).getNumpyArray(), np.logical_or(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing logical_xor\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(0, 20, [shape.rows, shape.cols])\n    data2 = np.random.randint(0, 20, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.logical_xor(cArray1, cArray2).getNumpyArray(), np.logical_xor(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing matmult\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[1].item(), shapeInput[0].item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    data1 = np.random.randint(0, 20, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(0, 20, [shape2.rows, shape2.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.matmul(cArray1, cArray2).getNumpyArray(), np.matmul(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing max: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.max(cArray, NumCpp.Axis.NONE).item() == np.max(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing max: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.max(cArray, NumCpp.Axis.ROW).getNumpyArray().astype(np.uint32).flatten(), np.max(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing max: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.max(cArray, NumCpp.Axis.COL).getNumpyArray().astype(np.uint32).flatten(), np.max(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing maximum\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.maximum(cArray1, cArray2).getNumpyArray(), np.maximum(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing mean: axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.mean(cArray, NumCpp.Axis.NONE).getNumpyArray().flatten().item() == np.mean(data, axis=None).item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing mean: axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.mean(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.mean(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing mean: axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.mean(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), np.mean(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing median: axis = None\', \'cyan\'))\n    isEven = True\n    while isEven:\n        shapeInput = np.random.randint(20, 100, [2, ])\n        isEven = shapeInput.prod().item() % 2 == 0\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.median(cArray, NumCpp.Axis.NONE).getNumpyArray().flatten().item() == np.median(data, axis=None).item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing median: axis = Row\', \'cyan\'))\n    isEven = True\n    while isEven:\n        shapeInput = np.random.randint(20, 100, [2, ])\n        isEven = shapeInput.prod().item() % 2 == 0\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.median(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.median(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing median: axis = Col\', \'cyan\'))\n    isEven = True\n    while isEven:\n        shapeInput = np.random.randint(20, 100, [2, ])\n        isEven = shapeInput.prod().item() % 2 == 0\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.median(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), np.median(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing meshgrid\', \'cyan\'))\n    start = np.random.randint(0, 20, [1,]).item()\n    end = np.random.randint(30, 100, [1,]).item()\n    step = np.random.randint(1, 5, [1, ]).item()\n    dataI = np.arange(start, end, step)\n    iSlice = NumCpp.Slice(start, end, step)\n    start = np.random.randint(0, 20, [1,]).item()\n    end = np.random.randint(30, 100, [1,]).item()\n    step = np.random.randint(1, 5, [1, ]).item()\n    dataJ = np.arange(start, end, step)\n    jSlice = NumCpp.Slice(start, end, step)\n    iMesh, jMesh = np.meshgrid(dataI, dataJ)\n    meshData = NumCpp.meshgrid(iSlice, jSlice)\n    if (np.array_equal(meshData.first.getNumpyArray(), iMesh) and\n        np.array_equal(meshData.second.getNumpyArray(), jMesh)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing min: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.min(cArray, NumCpp.Axis.NONE).item() == np.min(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing min: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.min(cArray, NumCpp.Axis.ROW).getNumpyArray().astype(np.uint32).flatten(), np.min(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing min: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.min(cArray, NumCpp.Axis.COL).getNumpyArray().astype(np.uint32).flatten(), np.min(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing minimum\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.minimum(cArray1, cArray2).getNumpyArray(), np.minimum(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing mod\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArrayInt(shape)\n    cArray2 = NumCpp.NdArrayInt(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.mod(cArray1, cArray2).getNumpyArray(), np.mod(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing multiply\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.multiply(cArray1, cArray2).getNumpyArray(), np.multiply(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanargmax: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(10, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if NumCpp.nanargmax(cArray, NumCpp.Axis.NONE).item() == np.nanargmax(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanargmax: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(10, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanargmax(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.nanargmax(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanargmax: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(10, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanargmax(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), np.nanargmax(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanargmin: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(10, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if NumCpp.nanargmin(cArray, NumCpp.Axis.NONE).item() == np.nanargmin(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanargmin: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(10, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanargmin(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.nanargmin(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanargmin: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(10, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanargmin(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), np.nanargmin(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nancumprod: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(1, 5, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 4, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nancumprod(cArray, NumCpp.Axis.NONE).getNumpyArray().flatten(), np.nancumprod(data, axis=None)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nancumprod: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 5, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 4, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nancumprod(cArray, NumCpp.Axis.ROW).getNumpyArray(), np.nancumprod(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nancumprod: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 5, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 4, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nancumprod(cArray, NumCpp.Axis.COL).getNumpyArray(), np.nancumprod(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nancumsum: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nancumsum(cArray, NumCpp.Axis.NONE).getNumpyArray().flatten(), np.nancumsum(data, axis=None)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nancumsum: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nancumsum(cArray, NumCpp.Axis.ROW).getNumpyArray(), np.nancumsum(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nancumsum: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nancumsum(cArray, NumCpp.Axis.COL).getNumpyArray(), np.nancumsum(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmax: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if NumCpp.nanmax(cArray, NumCpp.Axis.NONE).item() == np.nanmax(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmax: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanmax(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(),\n                      np.nanmax(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmax: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanmax(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(),\n                      np.nanmax(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmean: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10, ])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if NumCpp.nanmean(cArray, NumCpp.Axis.NONE).item() == np.nanmean(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmean: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10, ])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanmean(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(),\n                      np.nanmean(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmean: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10, ])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanmean(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(),\n                      np.nanmean(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmedian: axis = None\', \'cyan\'))\n    isEven = True\n    while isEven:\n        shapeInput = np.random.randint(20, 100, [2, ])\n        isEven = shapeInput.prod().item() % 2 == 0\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if NumCpp.nanmedian(cArray, NumCpp.Axis.NONE).getNumpyArray().flatten().item() == np.nanmedian(data, axis=None).item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    # print(colored(\'Testing nanmedian: axis = Row\', \'cyan\'))\n    # isEven = True\n    # while isEven:\n    #     shapeInput = np.random.randint(20, 100, [2, ])\n    #     isEven = shapeInput[0].item() % 2 == 0\n    # shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    # cArray = NumCpp.NdArray(shape)\n    # data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    # data = data.flatten()\n    # data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    # data = data.reshape(shapeInput)\n    # cArray.setArray(data)\n    # if np.array_equal(NumCpp.nanmedian(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.nanmedian(data, axis=0)):\n    #     print(colored(\'\\tPASS\', \'green\'))\n    # else:\n    #     print(colored(\'\\tFAIL\', \'red\'))\n    #\n    # print(colored(\'Testing nanmedian: axis = Col\', \'cyan\'))\n    # isEven = True\n    # while isEven:\n    #     shapeInput = np.random.randint(20, 100, [2, ])\n    #     isEven = shapeInput[1].item() % 2 == 0\n    # shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    # cArray = NumCpp.NdArray(shape)\n    # data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    # data = data.flatten()\n    # data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    # data = data.reshape(shapeInput)\n    # cArray.setArray(data)\n    # if np.array_equal(NumCpp.nanmedian(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), np.nanmedian(data, axis=1)):\n    #     print(colored(\'\\tPASS\', \'green\'))\n    # else:\n    #     print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmin: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if NumCpp.nanmin(cArray, NumCpp.Axis.NONE).item() == np.nanmin(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmin: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanmin(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(),\n                      np.nanmin(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanmin: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanmin(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(),\n                      np.nanmin(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = None, method = lower\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.NONE, \'lower\').item() == np.nanpercentile(data, percentile, axis=None, interpolation=\'lower\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = None, method = higher\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.NONE, \'higher\').item() == np.nanpercentile(data, percentile,\n                                                                                                       axis=None,\n                                                                                                       interpolation=\'higher\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = None, method = nearest\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.NONE, \'nearest\').item() == np.nanpercentile(data, percentile,\n                                                                                              axis=None,\n                                                                                              interpolation=\'nearest\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = None, method = midpoint\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.NONE, \'midpoint\').item() == np.nanpercentile(data, percentile,\n                                                                                               axis=None,\n                                                                                               interpolation=\'midpoint\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = None, method = linear\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.NONE, \'linear\').item() == np.nanpercentile(data, percentile,\n                                                                                             axis=None,\n                                                                                             interpolation=\'linear\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Row, method = lower\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.ROW, \'lower\').getNumpyArray().flatten(),\n                      np.nanpercentile(data, percentile, axis=0, interpolation=\'lower\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Row, method = higher\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.ROW, \'higher\').getNumpyArray().flatten(),\n                      np.nanpercentile(data, percentile, axis=0, interpolation=\'higher\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Row, method = nearest\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.ROW, \'nearest\').getNumpyArray().flatten(),\n                      np.nanpercentile(data, percentile, axis=0, interpolation=\'nearest\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Row, method = midpoint\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(\n            np.round(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.ROW, \'midpoint\').getNumpyArray().flatten(), 9),\n            np.round(np.nanpercentile(data, percentile, axis=0, interpolation=\'midpoint\'), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Row, method = linear\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(\n            np.round(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.ROW, \'linear\').getNumpyArray().flatten(), 9),\n            np.round(np.nanpercentile(data, percentile, axis=0, interpolation=\'linear\'), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Col, method = lower\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.COL, \'lower\').getNumpyArray().flatten(),\n                      np.nanpercentile(data, percentile, axis=1, interpolation=\'lower\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Col, method = higher\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.COL, \'higher\').getNumpyArray().flatten(),\n                      np.nanpercentile(data, percentile, axis=1, interpolation=\'higher\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Col, method = nearest\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.COL, \'nearest\').getNumpyArray().flatten(),\n                      np.nanpercentile(data, percentile, axis=1, interpolation=\'nearest\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Col, method = midpoint\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(\n            np.round(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.COL, \'midpoint\').getNumpyArray().flatten(), 9),\n            np.round(np.nanpercentile(data, percentile, axis=1, interpolation=\'midpoint\'), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanpercentile: Axis = Col, method = linear\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(\n            np.round(NumCpp.nanpercentile(cArray, percentile, NumCpp.Axis.COL, \'linear\').getNumpyArray().flatten(), 9),\n            np.round(np.nanpercentile(data, percentile, axis=1, interpolation=\'linear\'), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanprod: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 15, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if NumCpp.nanprod(cArray, NumCpp.Axis.NONE).item() == np.nanprod(data, axis=None):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanprod: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 15, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanprod(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.nanprod(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanprod: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 15, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nanprod(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), np.nanprod(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nans square\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [1, ]).item()\n    cArray = NumCpp.nansSquare(shapeInput)\n    if (cArray.shape[0] == shapeInput and cArray.shape[1] == shapeInput and\n            cArray.size == shapeInput ** 2 and np.all(np.isnan(cArray))):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nans rectangle\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    cArray = NumCpp.nansRowCol(shapeInput[0].item(), shapeInput[1].item())\n    if (cArray.shape[0] == shapeInput[0] and cArray.shape[1] == shapeInput[1] and\n            cArray.size == shapeInput.prod() and np.all(np.isnan(cArray))):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nans Shape\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.nansShape(shape)\n    if (cArray.shape[0] == shape.rows and cArray.shape[1] == shape.cols and\n            cArray.size == shapeInput.prod() and np.all(np.isnan(cArray))):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nans_like\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.nans_like(cArray1)\n    if (cArray2.shape().rows == shape.rows and cArray2.shape().cols == shape.cols and\n            cArray2.size() == shapeInput.prod() and np.all(np.isnan(cArray2.getNumpyArray()))):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanstdev: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.round(NumCpp.nanstdev(cArray, NumCpp.Axis.NONE).item(), 9) == np.round(np.nanstd(data), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanstdev: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.nanstdev(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), 9),\n                      np.round(np.nanstd(data, axis=0), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanstdev: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.nanstdev(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), 9),\n                      np.round(np.nanstd(data, axis=1), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nansum: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if NumCpp.nansum(cArray, NumCpp.Axis.NONE).item() == np.nansum(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nansum: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nansum(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.nansum(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nansum: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.nansum(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), np.nansum(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanvar: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.round(NumCpp.nanvar(cArray, NumCpp.Axis.NONE).item(), 9) == np.round(np.nanvar(data), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanvar: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.nanvar(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), 9),\n                      np.round(np.nanvar(data, axis=0), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nanvar: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    data = data.flatten()\n    data[np.random.randint(0, shape.size(), [shape.size() // 10,])] = np.nan\n    data = data.reshape(shapeInput)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.nanvar(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), 9),\n                      np.round(np.nanvar(data, axis=1), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nbytes\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(-100, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if NumCpp.nbytes(cArray) == data.size * 8:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing newbyteorder scaler\', \'cyan\'))\n    value = np.random.randint(1, 100, [1,]).item()\n    if NumCpp.newbyteorderScaler(value, NumCpp.Endian.BIG) == np.asarray([value], dtype=np.uint32).newbyteorder().item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing newbyteorder array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArrayInt(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.newbyteorderArray(cArray, NumCpp.Endian.BIG), data.newbyteorder()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing negative array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.negative(cArray).getNumpyArray(), 9), np.round(np.negative(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing none: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.none(cArray, NumCpp.Axis.NONE).astype(np.bool).item() == np.logical_not(np.any(data).item()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing none: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.none(cArray, NumCpp.Axis.ROW).flatten().astype(np.bool), np.logical_not(np.any(data, axis=0))):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing none: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.none(cArray, NumCpp.Axis.COL).flatten().astype(np.bool), np.logical_not(np.any(data, axis=1))):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nonzero\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    row, col = np.nonzero(data)\n    rowCol = NumCpp.nonzero(cArray)\n    rowC = rowCol.first.getNumpyArray().flatten()\n    colC = rowCol.second.getNumpyArray().flatten()\n    if np.array_equal(rowC, row) and np.array_equal(colC, col):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing norm: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.norm(cArray, NumCpp.Axis.NONE).flatten() == np.linalg.norm(data.flatten()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing norm: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    norms = NumCpp.norm(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten()\n    allPass = True\n    for idx, row in enumerate(data.transpose()):\n        if norms[idx] != np.linalg.norm(row):\n            allPass = False\n            break\n    if allPass:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing norm: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    norms = NumCpp.norm(cArray, NumCpp.Axis.COL).getNumpyArray().flatten()\n    allPass = True\n    for idx, row in enumerate(data):\n        if norms[idx] != np.linalg.norm(row):\n            allPass = False\n            break\n    if allPass:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing not_equal\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.not_equal(cArray1, cArray2).getNumpyArray(), np.not_equal(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ones square\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [1, ]).item()\n    cArray = NumCpp.onesSquare(shapeInput)\n    if (cArray.shape[0] == shapeInput and cArray.shape[1] == shapeInput and\n            cArray.size == shapeInput ** 2 and np.all(cArray == 1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ones rectangle\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    cArray = NumCpp.onesRowCol(shapeInput[0].item(), shapeInput[1].item())\n    if (cArray.shape[0] == shapeInput[0] and cArray.shape[1] == shapeInput[1] and\n            cArray.size == shapeInput.prod() and np.all(cArray == 1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ones Shape\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.onesShape(shape)\n    if (cArray.shape[0] == shape.rows and cArray.shape[1] == shape.cols and\n            cArray.size == shapeInput.prod() and np.all(cArray == 1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ones_like\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.ones_like(cArray1)\n    if (cArray2.shape().rows == shape.rows and cArray2.shape().cols == shape.cols and\n            cArray2.size() == shapeInput.prod() and np.all(cArray2.getNumpyArray() == 1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing outer\', \'cyan\'))\n    size = np.random.randint(1, 100, [1,]).item()\n    shape = NumCpp.Shape(1, size)\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    data2 = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.outer(cArray1, cArray2).astype(np.uint32), np.outer(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing pad\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    padWidth = np.random.randint(1, 10, [1, ]).item()\n    padValue = np.random.randint(1, 100, [1, ]).item()\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray = NumCpp.NdArray(shape)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.pad(cArray, padWidth, padValue).getNumpyArray(),\n                      np.pad(data, padWidth, mode=\'constant\', constant_values=padValue)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing partition: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    kthElement = np.random.randint(0, shapeInput.prod(), [1,], dtype=np.uint32).item()\n    partitionedArray = NumCpp.partition(cArray, kthElement, NumCpp.Axis.NONE).getNumpyArray().flatten()\n    if (np.all(partitionedArray[:kthElement] <= partitionedArray[kthElement]) and\n        np.all(partitionedArray[kthElement:] >= partitionedArray[kthElement])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing partition: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    kthElement = np.random.randint(0, shapeInput[0], [1,], dtype=np.uint32).item()\n    partitionedArray = NumCpp.partition(cArray, kthElement, NumCpp.Axis.ROW).getNumpyArray().transpose()\n    allPass = True\n    for row in partitionedArray:\n        if not (np.all(row[:kthElement] <= row[kthElement]) and\n                np.all(row[kthElement:] >= row[kthElement])):\n            allPass = False\n            break\n    if allPass:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing partition: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    kthElement = np.random.randint(0, shapeInput[1], [1,], dtype=np.uint32).item()\n    partitionedArray = NumCpp.partition(cArray, kthElement, NumCpp.Axis.COL).getNumpyArray()\n    allPass = True\n    for row in partitionedArray:\n        if not (np.all(row[:kthElement] <= row[kthElement]) and\n                np.all(row[kthElement:] >= row[kthElement])):\n            allPass = False\n            break\n    if allPass:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = None, method = lower\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.percentile(cArray, percentile, NumCpp.Axis.NONE, \'lower\').item() == np.percentile(data, percentile, axis=None, interpolation=\'lower\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = None, method = higher\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.percentile(cArray, percentile, NumCpp.Axis.NONE, \'higher\').item() == np.percentile(data, percentile, axis=None, interpolation=\'higher\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = None, method = nearest\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.percentile(cArray, percentile, NumCpp.Axis.NONE, \'nearest\').item() == np.percentile(data, percentile, axis=None, interpolation=\'nearest\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = None, method = midpoint\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.percentile(cArray, percentile, NumCpp.Axis.NONE, \'midpoint\').item() == np.percentile(data, percentile, axis=None, interpolation=\'midpoint\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = None, method = linear\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if NumCpp.percentile(cArray, percentile, NumCpp.Axis.NONE, \'linear\').item() == np.percentile(data, percentile, axis=None, interpolation=\'linear\'):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Row, method = lower\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.percentile(cArray, percentile, NumCpp.Axis.ROW, \'lower\').getNumpyArray().flatten(),\n                      np.percentile(data, percentile, axis=0, interpolation=\'lower\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Row, method = higher\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.percentile(cArray, percentile, NumCpp.Axis.ROW, \'higher\').getNumpyArray().flatten(),\n                      np.percentile(data, percentile, axis=0, interpolation=\'higher\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Row, method = nearest\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.percentile(cArray, percentile, NumCpp.Axis.ROW, \'nearest\').getNumpyArray().flatten(),\n                      np.percentile(data, percentile, axis=0, interpolation=\'nearest\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Row, method = midpoint\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(np.round(NumCpp.percentile(cArray, percentile, NumCpp.Axis.ROW, \'midpoint\').getNumpyArray().flatten(), 9),\n                      np.round(np.percentile(data, percentile, axis=0, interpolation=\'midpoint\'), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Row, method = linear\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(np.round(NumCpp.percentile(cArray, percentile, NumCpp.Axis.ROW, \'linear\').getNumpyArray().flatten(), 9),\n                      np.round(np.percentile(data, percentile, axis=0, interpolation=\'linear\'), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Col, method = lower\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.percentile(cArray, percentile, NumCpp.Axis.COL, \'lower\').getNumpyArray().flatten(),\n                      np.percentile(data, percentile, axis=1, interpolation=\'lower\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Col, method = higher\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.percentile(cArray, percentile, NumCpp.Axis.COL, \'higher\').getNumpyArray().flatten(),\n                      np.percentile(data, percentile, axis=1, interpolation=\'higher\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Col, method = nearest\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(NumCpp.percentile(cArray, percentile, NumCpp.Axis.COL, \'nearest\').getNumpyArray().flatten(),\n                      np.percentile(data, percentile, axis=1, interpolation=\'nearest\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Col, method = midpoint\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(np.round(NumCpp.percentile(cArray, percentile, NumCpp.Axis.COL, \'midpoint\').getNumpyArray().flatten(), 9),\n                      np.round(np.percentile(data, percentile, axis=1, interpolation=\'midpoint\'), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing percentile: Axis = Col, method = linear\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    percentile = np.random.rand(1).item() * 100\n    if np.array_equal(np.round(NumCpp.percentile(cArray, percentile, NumCpp.Axis.COL, \'linear\').getNumpyArray().flatten(), 9),\n                      np.round(np.percentile(data, percentile, axis=1, interpolation=\'linear\'), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing power array scaler\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    exponent = np.random.randint(0, 5, [1, ]).item()\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.powerArrayScaler(cArray, exponent), 9), np.round(np.power(data, exponent), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing power array array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    cExponents = NumCpp.NdArrayInt8(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    exponents = np.random.randint(0, 5, [shape.rows, shape.cols]).astype(np.uint8)\n    cArray.setArray(data)\n    cExponents.setArray(exponents)\n    if np.array_equal(np.round(NumCpp.powerArrayArray(cArray, cExponents), 9), np.round(np.power(data, exponents), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing powerf array scaler\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    exponent = np.random.rand(1).item() * 3\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.powerfArrayScaler(cArray, exponent), 9), np.round(np.power(data, exponent), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing powerf array array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    cExponents = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 20, [shape.rows, shape.cols])\n    exponents = np.random.rand(shape.rows, shape.cols) * 3\n    cArray.setArray(data)\n    cExponents.setArray(exponents)\n    if np.array_equal(np.round(NumCpp.powerfArrayArray(cArray, cExponents), 9), np.round(np.power(data, exponents), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing prod: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 15, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if NumCpp.prod(cArray, NumCpp.Axis.NONE).item() == data.prod():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing prod: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 15, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.prod(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), data.prod(axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing prod: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 15, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.prod(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), data.prod(axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ptp: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 15, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if NumCpp.ptp(cArray, NumCpp.Axis.NONE).getNumpyArray().astype(np.uint32).item() == data.ptp():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ptp: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 15, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.ptp(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten().astype(np.uint32), data.ptp(axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ptp: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 15, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.ptp(cArray, NumCpp.Axis.COL).getNumpyArray().flatten().astype(np.uint32), data.ptp(axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing put\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    numIndices = np.random.randint(0, shape.size())\n    indices = np.asarray(range(numIndices))\n    values = np.random.randint(1, 500, [numIndices, ])\n    cIndices = NumCpp.NdArrayInt(1, numIndices)\n    cValues = NumCpp.NdArray(1, numIndices)\n    cIndices.setArray(indices)\n    cValues.setArray(values)\n    NumCpp.put(cArray, cIndices, cValues)\n    data.put(indices, values)\n    if np.array_equal(cArray.getNumpyArray(), data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing rad2deg scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item()) * 2 * np.pi\n    if np.round(NumCpp.rad2degScaler(value), 9) == np.round(np.rad2deg(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing rad2deg array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols) * 2 * np.pi\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.rad2degArray(cArray), 9), np.round(np.rad2deg(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing radians scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item()) * 360\n    if np.round(NumCpp.radiansScaler(value), 9) == np.round(np.radians(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing radians array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols) * 360\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.radiansArray(cArray), 9), np.round(np.radians(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ravel\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    cArray2 = NumCpp.ravel(cArray)\n    if np.array_equal(cArray2.getNumpyArray().flatten(), np.ravel(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing reciprocal array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols) * 100\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.reciprocal(cArray).getNumpyArray(), 9), np.round(np.reciprocal(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    # numpy and cmath remainders are calculated differently, so convert for testing purposes\n    print(colored(\'Testing remainder scaler\', \'cyan\'))\n    values = np.random.rand(2) * 100\n    values = np.sort(values)\n    res = NumCpp.remainderScaler(values[1].item(), values[0].item())\n    if res < 0:\n        res += values[0].item()\n    if np.round(res, 9) == np.round(np.remainder(values[1], values[0]), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    # numpy and cmath remainders are calculated differently, so convert for testing purposes\n    print(colored(\'Testing remainder array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.rand(shape.rows, shape.cols) * 100 + 10\n    data2 = data1 - np.random.rand(shape.rows, shape.cols) * 10\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    res = NumCpp.remainderArray(cArray1, cArray2)\n    res[res < 0] = res[res < 0] + data2[res < 0]\n    if np.array_equal(np.round(res, 9), np.round(np.remainder(data1, data2), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing replace\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    oldValue = np.random.randint(1, 100, 1).item()\n    newValue = np.random.randint(1, 100, 1).item()\n    dataCopy = data.copy()\n    dataCopy[dataCopy == oldValue] = newValue\n    if np.array_equal(NumCpp.replace(cArray, oldValue, newValue), dataCopy):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing reshapeInt\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    newShape = data.size\n    NumCpp.reshape(cArray, newShape)\n    if np.array_equal(cArray.getNumpyArray(), data.reshape(1, newShape)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing reshapeShape\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    newShape = NumCpp.Shape(shapeInput[1].item(), shapeInput[0].item())\n    NumCpp.reshape(cArray, newShape)\n    if np.array_equal(cArray.getNumpyArray(), data.reshape(shapeInput[::-1])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing reshapeList\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    newShape = NumCpp.Shape(shapeInput[1].item(), shapeInput[0].item())\n    NumCpp.reshapeList(cArray, newShape)\n    if np.array_equal(cArray.getNumpyArray(), data.reshape(shapeInput[::-1])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing reshapeValues negative rows\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    newNumCols = np.random.choice(np.array(list(factors(data.size))), 1).item()\n    NumCpp.reshape(cArray, -1, newNumCols)\n    if np.array_equal(cArray.getNumpyArray(), data.reshape(-1, newNumCols)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing reshapeValues negative cols\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    newNumRows = np.random.choice(np.array(list(factors(data.size))), 1).item()\n    NumCpp.reshape(cArray, newNumRows, -1)\n    if np.array_equal(cArray.getNumpyArray(), data.reshape(newNumRows, -1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing resizeFast\', \'cyan\'))\n    shapeInput1 = np.random.randint(1, 100, [2, ])\n    shapeInput2 = np.random.randint(1, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput1[0].item(), shapeInput1[1].item())\n    shape2 = NumCpp.Shape(shapeInput2[0].item(), shapeInput2[1].item())\n    cArray = NumCpp.NdArray(shape1)\n    data = np.random.randint(1, 100, [shape1.rows, shape1.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    NumCpp.resizeFast(cArray, shape2)\n    if np.all(cArray.getNumpyArray() == 0) and cArray.shape().rows == shape2.rows and cArray.shape().cols == shape2.cols:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing resizeSlow\', \'cyan\'))\n    shapeInput1 = np.random.randint(1, 100, [2, ])\n    shapeInput2 = np.random.randint(1, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput1[0].item(), shapeInput1[1].item())\n    shape2 = NumCpp.Shape(shapeInput2[0].item(), shapeInput2[1].item())\n    cArray = NumCpp.NdArray(shape1)\n    data = np.random.randint(1, 100, [shape1.rows, shape1.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    NumCpp.resizeSlow(cArray, shape2)\n    if cArray.shape().rows == shape2.rows and cArray.shape().cols == shape2.cols and not np.all(cArray.getNumpyArray() == 0):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing right_shift\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    bitsToShift = np.random.randint(1, 32, [1, ]).item()\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArrayInt(shape)\n    data = np.random.randint(1, np.iinfo(np.uint32).max, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.right_shift(cArray, bitsToShift).getNumpyArray(), np.right_shift(data, bitsToShift)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing rint scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item()) * 2 * np.pi\n    if NumCpp.rintScaler(value) == np.rint(value):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing rint array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols) * 2 * np.pi\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.rintArray(cArray), np.rint(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing roll: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    amount = np.random.randint(0, data.size, [1,]).item()\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.roll(cArray, amount, NumCpp.Axis.NONE).getNumpyArray(), np.roll(data, amount, axis=None)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing roll: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    amount = np.random.randint(0, shape.cols, [1,]).item()\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.roll(cArray, amount, NumCpp.Axis.ROW).getNumpyArray(), np.roll(data, amount, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing rms: axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.rms(cArray, NumCpp.Axis.NONE).getNumpyArray().flatten().item() == np.sqrt(np.mean(np.square(data), axis=None)).item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing rms: axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.rms(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.sqrt(np.mean(np.square(data), axis=0))):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing rms: axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.rms(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), np.sqrt(np.mean(np.square(data), axis=1))):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing roll: Axis = Col\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    amount = np.random.randint(0, shape.rows, [1,]).item()\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.roll(cArray, amount, NumCpp.Axis.COL).getNumpyArray(), np.roll(data, amount, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing rot90\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    amount = np.random.randint(1, 4, [1,]).item()\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.rot90(cArray, amount).getNumpyArray(), np.rot90(data, amount)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing round scaler\', \'cyan\'))\n    value = np.abs(np.random.rand(1).item()) * 2 * np.pi\n    if NumCpp.roundScaler(value, 10) == np.round(value, 10):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing round array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols) * 2 * np.pi\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.roundArray(cArray, 9), np.round(data, 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing row_stack\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[0].item() + np.random.randint(1, 10, [1,]).item(), shapeInput[1].item())\n    shape3 = NumCpp.Shape(shapeInput[0].item() + np.random.randint(1, 10, [1,]).item(), shapeInput[1].item())\n    shape4 = NumCpp.Shape(shapeInput[0].item() + np.random.randint(1, 10, [1,]).item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    cArray3 = NumCpp.NdArray(shape3)\n    cArray4 = NumCpp.NdArray(shape4)\n    data1 = np.random.randint(1, 100, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(1, 100, [shape2.rows, shape2.cols])\n    data3 = np.random.randint(1, 100, [shape3.rows, shape3.cols])\n    data4 = np.random.randint(1, 100, [shape4.rows, shape4.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(NumCpp.row_stack(cArray1, cArray2, cArray3, cArray4),\n                      np.row_stack([data1, data2, data3, data4])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing setdiff1d\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArrayInt(shape)\n    cArray2 = NumCpp.NdArrayInt(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.setdiff1d(cArray1, cArray2).getNumpyArray().flatten(), np.setdiff1d(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing shape array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    if cArray.shape().rows == shape.rows and cArray.shape().cols == shape.cols:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sign scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100\n    if NumCpp.signScaler(value) == np.sign(value):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sign array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.signArray(cArray), np.sign(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing signbit scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 100\n    if NumCpp.signbitScaler(value) == np.signbit(value):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing signbit array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols) * 100\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.signbitArray(cArray), np.signbit(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sin scaler\', \'cyan\'))\n    value = np.random.randn(1).item()\n    if np.round(NumCpp.sinScaler(value), 9) == np.round(np.sin(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sin array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.sinArray(cArray), 9), np.round(np.sin(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sinc scaler\', \'cyan\'))\n    value = np.random.randn(1).item()\n    if np.round(NumCpp.sincScaler(value), 9) == np.round(np.sinc(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sinc array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.sincArray(cArray), 9), np.round(np.sinc(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sinh scaler\', \'cyan\'))\n    value = np.random.randn(1).item()\n    if np.round(NumCpp.sinhScaler(value), 9) == np.round(np.sinh(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sinh array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randn(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.sinhArray(cArray), 9), np.round(np.sinh(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing size\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    if cArray.size() == shapeInput.prod().item():\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sort: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    d = data.flatten()\n    d.sort()\n    if np.array_equal(NumCpp.sort(cArray, NumCpp.Axis.NONE).getNumpyArray().flatten(), d):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sort: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols], dtype=np.uint32)\n    cArray.setArray(data)\n    pSorted = np.sort(data, axis=0)\n    cSorted = NumCpp.sort(cArray, NumCpp.Axis.ROW).getNumpyArray().astype(np.uint32)\n    if np.array_equal(cSorted, pSorted):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sort: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    pSorted = np.sort(data, axis=1)\n    cSorted = NumCpp.sort(cArray, NumCpp.Axis.COL).getNumpyArray().astype(np.uint32)\n    if np.array_equal(cSorted, pSorted):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sqrt scaler\', \'cyan\'))\n    value = np.random.randint(1, 100, [1,]).item()\n    if np.round(NumCpp.sqrtScaler(value), 9) == np.round(np.sqrt(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sqrt array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.sqrtArray(cArray), 9), np.round(np.sqrt(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing square scaler\', \'cyan\'))\n    value = np.random.randint(1, 100, [1, ]).item()\n    if np.round(NumCpp.squareScaler(value), 9) == np.round(np.square(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing square array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.squareArray(cArray), 9), np.round(np.square(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing stack: Axis::ROW\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    cArray3 = NumCpp.NdArray(shape)\n    cArray4 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data3 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data4 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(NumCpp.stack(cArray1, cArray2, cArray3, cArray4, NumCpp.Axis.ROW),\n                      np.vstack([data1, data2, data3, data4])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing stack: Axis::COL\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    cArray3 = NumCpp.NdArray(shape)\n    cArray4 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data3 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data4 = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(NumCpp.stack(cArray1, cArray2, cArray3, cArray4, NumCpp.Axis.COL),\n                      np.hstack([data1, data2, data3, data4])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing stddev: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.round(NumCpp.stdev(cArray, NumCpp.Axis.NONE).item(), 9) == np.round(np.std(data), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing stddev: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.stdev(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), 9), np.round(np.std(data, axis=0), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing stddev: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.stdev(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), 9), np.round(np.std(data, axis=1), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing subtract\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.NdArray(shape)\n    data1 = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    data2 = np.random.randint(-100, 100, [shape.rows, shape.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.subtract(cArray1, cArray2), data1 - data2):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sum: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if NumCpp.sum(cArray, NumCpp.Axis.NONE).item() == np.sum(data):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sum: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.sum(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), np.sum(data, axis=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing sum: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.sum(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), np.sum(data, axis=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing swap\', \'cyan\'))\n    shapeInput1 = np.random.randint(20, 100, [2, ])\n    shapeInput2 = np.random.randint(20, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput1[0].item(), shapeInput1[1].item())\n    shape2 = NumCpp.Shape(shapeInput2[0].item(), shapeInput2[1].item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    data1 = np.random.randint(0, 100, [shape1.rows, shape1.cols]).astype(np.double)\n    data2 = np.random.randint(0, 100, [shape2.rows, shape2.cols]).astype(np.double)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    NumCpp.swap(cArray1, cArray2)\n    if (np.array_equal(cArray1.getNumpyArray(), data2) and\n            np.array_equal(cArray2.getNumpyArray(), data1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing swapaxes\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.swapaxes(cArray).getNumpyArray(), data.T):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tan scaler\', \'cyan\'))\n    value = np.random.rand(1).item() * np.pi\n    if np.round(NumCpp.tanScaler(value), 9) == np.round(np.tan(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tan array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.tanArray(cArray), 9), np.round(np.tan(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tanh scaler\', \'cyan\'))\n    value = np.random.rand(1).item() * np.pi\n    if np.round(NumCpp.tanhScaler(value), 9) == np.round(np.tanh(value), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tanh array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.tanhArray(cArray), 9), np.round(np.tanh(data), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tile rectangle\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shapeRepeat = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shapeR = NumCpp.Shape(shapeRepeat[0].item(), shapeRepeat[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.tileRectangle(cArray, shapeR.rows, shapeR.cols), np.tile(data, shapeRepeat)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tile shape\', \'cyan\'))\n    shapeInput = np.random.randint(1, 10, [2, ])\n    shapeRepeat = np.random.randint(1, 10, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shapeR = NumCpp.Shape(shapeRepeat[0].item(), shapeRepeat[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.tileShape(cArray, shapeR), np.tile(data, shapeRepeat)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tofile bin\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if sys.platform == \'linux\':\n        tempDir = r\'/home/\' + getpass.getuser() + r\'/Desktop/\'\n        filename = os.path.join(tempDir, \'temp.bin\')\n    else:\n        filename = r\'C:\\Temp\\temp.bin\'\n    NumCpp.tofile(cArray, filename, \'\')\n    if os.path.exists(filename):\n        data2 = np.fromfile(filename, np.double).reshape(shapeInput)\n        if np.array_equal(data, data2):\n            print(colored(\'\\tPASS\', \'green\'))\n        else:\n            print(colored(\'\\tFAIL\', \'red\'))\n        os.remove(filename)\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tofile txt\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if sys.platform == \'linux\':\n        tempDir = r\'/home/\' + getpass.getuser() + r\'/Desktop/\'\n        filename = os.path.join(tempDir, \'temp.txt\')\n    else:\n        filename = r\'C:\\Temp\\temp.txt\'\n    NumCpp.tofile(cArray, filename, \'\\n\')\n    if os.path.exists(filename):\n        data2 = np.fromfile(filename, dtype=np.double, sep=\'\\n\').reshape(shapeInput)\n        if np.array_equal(data, data2):\n            print(colored(\'\\tPASS\', \'green\'))\n        else:\n            print(colored(\'\\tFAIL\', \'red\'))\n        os.remove(filename)\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing toStlVector\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    out = np.asarray(NumCpp.toStlVector(cArray))\n    if np.array_equal(out, data.flatten()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trace: Offset=Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    offset = np.random.randint(0, shape.rows, [1, ]).item()\n    if np.array_equal(NumCpp.trace(cArray, offset, NumCpp.Axis.ROW), data.trace(offset, axis1=1, axis2=0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trace: Offset=Col\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    offset = np.random.randint(0, shape.rows, [1, ]).item()\n    if np.array_equal(NumCpp.trace(cArray, offset, NumCpp.Axis.COL), data.trace(offset, axis1=0, axis2=1)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing transpose\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.transpose(cArray).getNumpyArray(), np.transpose(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trapz: Axis = None with constant dx\', \'cyan\'))\n    shape = NumCpp.Shape(np.random.randint(10, 20, [1,]).item(), 1)\n    cArray = NumCpp.NdArray(shape)\n    coeffs = np.random.randint(0, 10, [2, ])\n    dx = np.random.rand(1).item()\n    data = np.array([x ** 2 - coeffs[0] * x + coeffs[1] for x in range(shape.size())])\n    cArray.setArray(data)\n    integralC = NumCpp.trapzDx(cArray, dx, NumCpp.Axis.NONE).item()\n    integralPy = np.trapz(data, dx=dx)\n    if np.round(integralC, 9) == np.round(integralPy, 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trapz: Axis = Row with constant dx\', \'cyan\'))\n    shape = NumCpp.Shape(np.random.randint(10, 20, [1,]).item(), np.random.randint(10, 20, [1,]).item())\n    cArray = NumCpp.NdArray(shape)\n    coeffs = np.random.randint(0, 10, [2, ])\n    dx = np.random.rand(1).item()\n    data = np.array([x ** 2 - coeffs[0] * x - coeffs[1] for x in range(shape.size())]).reshape(shape.rows, shape.cols)\n    cArray.setArray(data)\n    integralC = NumCpp.trapzDx(cArray, dx, NumCpp.Axis.ROW).flatten()\n    integralPy = np.trapz(data, dx=dx, axis=0)\n    if np.array_equal(np.round(integralC, 8), np.round(integralPy, 8)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trapz: Axis = Col with constant dx\', \'cyan\'))\n    shape = NumCpp.Shape(np.random.randint(10, 20, [1,]).item(), np.random.randint(10, 20, [1,]).item())\n    cArray = NumCpp.NdArray(shape)\n    coeffs = np.random.randint(0, 10, [2, ])\n    dx = np.random.rand(1).item()\n    data = np.array([x ** 2 - coeffs[0] * x - coeffs[1] for x in range(shape.size())]).reshape(shape.rows, shape.cols)\n    cArray.setArray(data)\n    integralC = NumCpp.trapzDx(cArray, dx, NumCpp.Axis.COL).flatten()\n    integralPy = np.trapz(data, dx=dx, axis=1)\n    if np.array_equal(np.round(integralC, 8), np.round(integralPy, 8)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trapz: Axis = None with variable dx\', \'cyan\'))\n    shape = NumCpp.Shape(1, np.random.randint(10, 20, [1,]).item())\n    cArrayY = NumCpp.NdArray(shape)\n    cArrayX = NumCpp.NdArray(shape)\n    coeffs = np.random.randint(0, 10, [2, ])\n    dx = np.random.rand(shape.rows, shape.cols)\n    data = np.array([x ** 2 - coeffs[0] * x + coeffs[1] for x in range(shape.size())])\n    cArrayY.setArray(data)\n    cArrayX.setArray(dx)\n    integralC = NumCpp.trapz(cArrayY, cArrayX, NumCpp.Axis.NONE).item()\n    integralPy = np.trapz(data, x=dx)\n    if np.round(integralC, 9) == np.round(integralPy, 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trapz: Axis = Row with variable dx\', \'cyan\'))\n    shape = NumCpp.Shape(np.random.randint(10, 20, [1,]).item(), np.random.randint(10, 20, [1,]).item())\n    cArrayY = NumCpp.NdArray(shape)\n    cArrayX = NumCpp.NdArray(shape)\n    coeffs = np.random.randint(0, 10, [2, ])\n    dx = np.random.rand(shape.rows, shape.cols)\n    data = np.array([x ** 2 - coeffs[0] * x + coeffs[1] for x in range(shape.size())]).reshape(shape.rows, shape.cols)\n    cArrayY.setArray(data)\n    cArrayX.setArray(dx)\n    integralC = NumCpp.trapz(cArrayY, cArrayX, NumCpp.Axis.ROW).flatten()\n    integralPy = np.trapz(data, x=dx, axis=0)\n    if np.array_equal(np.round(integralC, 8), np.round(integralPy, 8)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trapz: Axis = Col with variable dx\', \'cyan\'))\n    shape = NumCpp.Shape(np.random.randint(10, 20, [1,]).item(), np.random.randint(10, 20, [1,]).item())\n    cArrayY = NumCpp.NdArray(shape)\n    cArrayX = NumCpp.NdArray(shape)\n    coeffs = np.random.randint(0, 10, [2, ])\n    dx = np.random.rand(shape.rows, shape.cols)\n    data = np.array([x ** 2 - coeffs[0] * x + coeffs[1] for x in range(shape.size())]).reshape(shape.rows, shape.cols)\n    cArrayY.setArray(data)\n    cArrayX.setArray(dx)\n    integralC = NumCpp.trapz(cArrayY, cArrayX, NumCpp.Axis.COL).flatten()\n    integralPy = np.trapz(data, x=dx, axis=1)\n    if np.array_equal(np.round(integralC, 8), np.round(integralPy, 8)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tril: square\', \'cyan\'))\n    squareSize = np.random.randint(10, 100, [1, ]).item()\n    offset = np.random.randint(0, squareSize, [1, ]).item()\n    if np.array_equal(NumCpp.trilSquare(squareSize, offset), np.tri(squareSize, k=offset)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tril: rectangle\', \'cyan\'))\n    shapeInput = np.random.randint(10, 100, [2, ])\n    offset = np.random.randint(0, shapeInput.min(), [1, ]).item()\n    if np.array_equal(NumCpp.trilRect(shapeInput[0].item(), shapeInput[1].item(), offset),\n                      np.tri(shapeInput[0].item(), shapeInput[1].item(), k=offset)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing tril: array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    offset = np.random.randint(0, shape.rows, [1, ]).item()\n    if np.array_equal(NumCpp.trilArray(cArray, offset), np.tril(data, k=offset)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing triu: square\', \'cyan\'))\n    squareSize = np.random.randint(10, 100, [1, ]).item()\n    offset = np.random.randint(0, squareSize, [1, ]).item()\n    if np.array_equal(NumCpp.triuSquare(squareSize, offset), np.tri(squareSize, k=-offset).T):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    # print(colored(\'Testing triu: rectangle\', \'cyan\'))\n    # shapeInput = np.random.randint(10, 100, [2, ])\n    # offset = np.random.randint(0, shapeInput.min(), [1, ]).item()\n    # if np.array_equal(NumCpp.triuRect(shapeInput[0].item(), shapeInput[1].item(), offset),\n    #                   np.tri(shapeInput[0].item(), shapeInput[1].item(), k=-offset)):\n    #     print(colored(\'\\tPASS\', \'green\'))\n    # else:\n    #     print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing triu: array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    offset = np.random.randint(0, shape.rows, [1, ]).item()\n    if np.array_equal(NumCpp.triuArray(cArray, offset), np.triu(data, k=offset)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n        \n    print(colored(\'Testing trim_zeros: ""f""\', \'cyan\'))\n    numElements = np.random.randint(50, 100, [1, ]).item()\n    offsetBeg = np.random.randint(0, 10, [1, ]).item()\n    offsetEnd = np.random.randint(10, numElements, [1, ]).item()\n    shape = NumCpp.Shape(1, numElements)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data[0, :offsetBeg] = 0\n    data[0, -offsetEnd:] = 0\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.trim_zeros(cArray, \'f\').getNumpyArray().flatten(),\n                      np.trim_zeros(data.flatten(), \'f\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trim_zeros: ""b""\', \'cyan\'))\n    numElements = np.random.randint(50, 100, [1, ]).item()\n    offsetBeg = np.random.randint(0, 10, [1, ]).item()\n    offsetEnd = np.random.randint(10, numElements, [1, ]).item()\n    shape = NumCpp.Shape(1, numElements)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data[0, :offsetBeg] = 0\n    data[0, -offsetEnd:] = 0\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.trim_zeros(cArray, \'b\').getNumpyArray().flatten(),\n                      np.trim_zeros(data.flatten(), \'b\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trim_zeros: ""fb""\', \'cyan\'))\n    numElements = np.random.randint(50, 100, [1, ]).item()\n    offsetBeg = np.random.randint(0, 10, [1, ]).item()\n    offsetEnd = np.random.randint(10, numElements, [1, ]).item()\n    shape = NumCpp.Shape(1, numElements)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    data[0, :offsetBeg] = 0\n    data[0, -offsetEnd:] = 0\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.trim_zeros(cArray, \'fb\').getNumpyArray().flatten(),\n                      np.trim_zeros(data.flatten(), \'fb\')):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trunc scaler\', \'cyan\'))\n    value = np.random.rand(1).item() * np.pi\n    if NumCpp.truncScaler(value) == np.trunc(value):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing trunc array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.truncArray(cArray), np.trunc(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing union1d\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArrayInt(shape)\n    cArray2 = NumCpp.NdArrayInt(shape)\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    if np.array_equal(NumCpp.union1d(cArray1, cArray2).getNumpyArray().flatten(), np.union1d(data1, data2)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing unique array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.unique(cArray).getNumpyArray().flatten(), np.unique(data)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing unwrap scaler\', \'cyan\'))\n    value = np.random.randn(1).item() * 3 * np.pi\n    if np.round(NumCpp.unwrapScaler(value), 9) == np.round(np.arctan2(np.sin(value), np.cos(value)), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing unwrap array\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.unwrapArray(cArray), 9), np.round(np.arctan2(np.sin(data), np.cos(data)), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing var: Axis = None\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.round(NumCpp.var(cArray, NumCpp.Axis.NONE).item(), 9) == np.round(np.var(data), 9):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing var: Axis = Row\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.var(cArray, NumCpp.Axis.ROW).getNumpyArray().flatten(), 9), np.round(np.var(data, axis=0), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing var: Axis = Column\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.var(cArray, NumCpp.Axis.COL).getNumpyArray().flatten(), 9), np.round(np.var(data, axis=1), 9)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing vstack\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shapeInput[0].item() + np.random.randint(1, 10, [1,]).item(), shapeInput[1].item())\n    shape3 = NumCpp.Shape(shapeInput[0].item() + np.random.randint(1, 10, [1,]).item(), shapeInput[1].item())\n    shape4 = NumCpp.Shape(shapeInput[0].item() + np.random.randint(1, 10, [1,]).item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    cArray3 = NumCpp.NdArray(shape3)\n    cArray4 = NumCpp.NdArray(shape4)\n    data1 = np.random.randint(1, 100, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(1, 100, [shape2.rows, shape2.cols])\n    data3 = np.random.randint(1, 100, [shape3.rows, shape3.cols])\n    data4 = np.random.randint(1, 100, [shape4.rows, shape4.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(NumCpp.vstack(cArray1, cArray2, cArray3, cArray4),\n                      np.vstack([data1, data2, data3, data4])):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing where\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArrayMask = NumCpp.NdArrayBool(shape)\n    cArrayA = NumCpp.NdArray(shape)\n    cArrayB = NumCpp.NdArray(shape)\n    dataMask = np.random.randint(0, 2, [shape.rows, shape.cols], dtype=bool)\n    dataA = np.random.randint(1, 100, [shape.rows, shape.cols])\n    dataB = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArrayMask.setArray(dataMask)\n    cArrayA.setArray(dataA)\n    cArrayB.setArray(dataB)\n    if np.array_equal(NumCpp.where(cArrayMask, cArrayA, cArrayB), np.where(dataMask, dataA, dataB)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing zeros square\', \'cyan\'))\n    shapeInput = np.random.randint(1, 100, [1, ]).item()\n    cArray = NumCpp.zerosSquare(shapeInput)\n    if (cArray.shape[0] == shapeInput and cArray.shape[1] == shapeInput and\n            cArray.size == shapeInput ** 2 and np.all(cArray == 0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing zeros rectangle\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    cArray = NumCpp.zerosRowCol(shapeInput[0].item(), shapeInput[1].item())\n    if (cArray.shape[0] == shapeInput[0] and cArray.shape[1] == shapeInput[1] and\n            cArray.size == shapeInput.prod() and np.all(cArray == 0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing zeros Shape\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.zerosShape(shape)\n    if (cArray.shape[0] == shape.rows and cArray.shape[1] == shape.cols and\n            cArray.size == shapeInput.prod() and np.all(cArray == 0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing zeros_like\', \'cyan\'))\n    shapeInput = np.random.randint(20, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray1 = NumCpp.NdArray(shape)\n    cArray2 = NumCpp.zeros_like(cArray1)\n    if (cArray2.shape().rows == shape.rows and cArray2.shape().cols == shape.cols and\n            cArray2.size() == shapeInput.prod() and np.all(cArray2.getNumpyArray() == 0)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n\n####################################################################################\nif __name__ == \'__main__\':\n    doTest()\n'"
unitTests/testScripts/TestImageProcessing.py,15,"b""import numpy as np\nimport matplotlib.pyplot as plt\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Image Processing Module', 'magenta'))\n\n    # generate a random noise\n    imageSize = 512\n    noiseStd = np.random.rand(1) * 4\n    noiseMean = np.random.randint(75, 100, [1, ]).item()\n    noise = np.round(np.random.randn(imageSize, imageSize) * noiseStd + noiseMean)\n\n    # scatter some point sources on it\n    pointSize = 5\n    pointHalfSize = pointSize // 2\n    pointSource = np.asarray([[1,1,1,1,1],[1,5,30,5,1],[1,30,100,30,1],[1,5,30,5,1],[1,1,1,1,1]])\n\n    scene = noise.copy()\n    numPointSources = 3000\n    for point in range(numPointSources):\n        row = np.random.randint(pointHalfSize, imageSize - pointHalfSize, [1, ]).item()\n        col = np.random.randint(pointHalfSize, imageSize - pointHalfSize, [1, ]).item()\n\n        cutout = scene[row - pointHalfSize: row + pointHalfSize + 1, col - pointHalfSize: col + pointHalfSize + 1]\n        cutout = cutout + pointSource\n        scene[row - pointHalfSize: row + pointHalfSize + 1, col - pointHalfSize: col + pointHalfSize + 1] = cutout\n\n    # generate centroids from the image\n    thresholdRate = 0.014\n    borderWidth = np.random.randint(0, 4, [1,]).item()\n    cScene = NumCpp.NdArray(imageSize)\n    cScene.setArray(scene)\n\n    threshold = NumCpp.generateThreshold(cScene, thresholdRate)\n    print(f'Scene Min = {scene.min()}')\n    print(f'Scene Max = {scene.max()}')\n    print(f'Threshold = {threshold}')\n    print(f'Desired Rate = {thresholdRate}')\n    print(f'Actual Rate(Threshold) = {np.count_nonzero(scene > threshold) / scene.size}')\n    print(f'Actual Rate(Threshold - 1) = {np.count_nonzero(scene > threshold - 1) / scene.size}')\n\n    centroids = list(NumCpp.generateCentroids(cScene, thresholdRate, 'pre', borderWidth))\n    print(f'Window Pre Number of Centroids (Border = {borderWidth}) = {len(centroids)}')\n\n    # plt the results\n    plt.figure()\n    plt.imshow(scene)\n    plt.colorbar()\n    plt.clim([threshold, threshold + 1])\n    plt.xlabel('Rows')\n    plt.ylabel('Cols')\n    plt.title(f'Window Pre Centroids\\nNumber of Centroids = {len(centroids)}')\n\n    for centroid in centroids:\n        plt.plot(centroid.col(), centroid.row(), 'og', fillstyle='none')\n\n    plt.show()\n\n    centroidInfo = np.asarray([[centroid.intensity(), centroid.eod()] for centroid in centroids])\n\n    plt.figure()\n    plt.plot(np.sort(centroidInfo[:,0].flatten()))\n    plt.title('Window Pre Centroid Intensities')\n    plt.xlabel('Centroid #')\n    plt.ylabel('Counts')\n    plt.show()\n\n    plt.figure()\n    plt.plot(np.sort(centroidInfo[:,1].flatten() * 100))\n    plt.title('Window Pre Centroid EOD')\n    plt.xlabel('Centroid #')\n    plt.ylabel('EOD (%)')\n    plt.show()\n\n    centroids = list(NumCpp.generateCentroids(cScene, thresholdRate, 'post', borderWidth))\n    print(f'Window Post Number of Centroids (Border = {borderWidth}) = {len(centroids)}')\n\n    # plt the results\n    plt.figure()\n    plt.imshow(scene)\n    plt.colorbar()\n    plt.clim([threshold, threshold + 1])\n    plt.xlabel('Rows')\n    plt.ylabel('Cols')\n    plt.title(f'Window Post Centroids\\nNumber of Centroids = {len(centroids)}')\n\n    for centroid in centroids:\n        plt.plot(centroid.col(), centroid.row(), 'og', fillstyle='none')\n\n    plt.show()\n\n    centroidInfo = np.asarray([[centroid.intensity(), centroid.eod()] for centroid in centroids])\n\n    plt.figure()\n    plt.plot(np.sort(centroidInfo[:,0].flatten()))\n    plt.title('Window Post Centroid Intensities')\n    plt.xlabel('Centroid #')\n    plt.ylabel('Counts')\n    plt.show()\n\n    plt.figure()\n    plt.plot(np.sort(centroidInfo[:,1].flatten() * 100))\n    plt.title('Window Post Centroid EOD')\n    plt.xlabel('Centroid #')\n    plt.ylabel('EOD (%)')\n    plt.show()\n\n    print(colored('\\tPASS', 'green'))\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestIntegrate.py,25,"b""import numpy as np\nimport scipy.special as sp\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n\n####################################################################################\nNUM_DECIMALS_ROUND = 1\n\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Integration Module', 'magenta'))\n\n    print(colored('Testing gauss_legendre', 'cyan'))\n    numCoefficients = np.random.randint(2, 5, [1, ]).item()\n    coefficients = np.random.randint(-20, 20, [numCoefficients, ])\n    coefficientsC = NumCpp.NdArray(1, numCoefficients)\n    coefficientsC.setArray(coefficients)\n    poly = np.poly1d(np.flipud(coefficients), False)\n    polyIntegral = poly.integ()\n    polyC = NumCpp.Poly1d(coefficientsC, False)\n    a, b = np.sort(np.random.rand(2) * 100 - 50)\n    area = np.round(polyIntegral(b) - polyIntegral(a), NUM_DECIMALS_ROUND)\n    areaC = np.round(NumCpp.integrate_gauss_legendre(polyC, a, b), NUM_DECIMALS_ROUND)\n    if area == areaC:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(area)\n        print(areaC)\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing romberg', 'cyan'))\n    PERCENT_LEEWAY = 0.1\n    numCoefficients = np.random.randint(2, 5, [1, ]).item()\n    coefficients = np.random.randint(-20, 20, [numCoefficients, ])\n    coefficientsC = NumCpp.NdArray(1, numCoefficients)\n    coefficientsC.setArray(coefficients)\n    poly = np.poly1d(np.flipud(coefficients), False)\n    polyIntegral = poly.integ()\n    polyC = NumCpp.Poly1d(coefficientsC, False)\n    a, b = np.sort(np.random.rand(2) * 100 - 50)\n    area = np.round(polyIntegral(b) - polyIntegral(a), NUM_DECIMALS_ROUND)\n    areaC = np.round(NumCpp.integrate_romberg(polyC, a, b), NUM_DECIMALS_ROUND)\n    # romberg is much less acurate so let's give it some leeway\n    areaLow, areaHigh = np.sort([area * (1 - PERCENT_LEEWAY), area * (1 + PERCENT_LEEWAY)])\n    if areaLow < areaC < areaHigh:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(area)\n        print(areaC)\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing simpson', 'cyan'))\n    numCoefficients = np.random.randint(2, 5, [1, ]).item()\n    coefficients = np.random.randint(-20, 20, [numCoefficients, ])\n    coefficientsC = NumCpp.NdArray(1, numCoefficients)\n    coefficientsC.setArray(coefficients)\n    poly = np.poly1d(np.flipud(coefficients), False)\n    polyIntegral = poly.integ()\n    polyC = NumCpp.Poly1d(coefficientsC, False)\n    a, b = np.sort(np.random.rand(2) * 100 - 50)\n    area = np.round(polyIntegral(b) - polyIntegral(a), NUM_DECIMALS_ROUND)\n    areaC = np.round(NumCpp.integrate_simpson(polyC, a, b), NUM_DECIMALS_ROUND)\n    if area == areaC:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(area)\n        print(areaC)\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing trapazoidal', 'cyan'))\n    numCoefficients = np.random.randint(2, 5, [1, ]).item()\n    coefficients = np.random.randint(-20, 20, [numCoefficients, ])\n    coefficientsC = NumCpp.NdArray(1, numCoefficients)\n    coefficientsC.setArray(coefficients)\n    poly = np.poly1d(np.flipud(coefficients), False)\n    polyIntegral = poly.integ()\n    polyC = NumCpp.Poly1d(coefficientsC, False)\n    a, b = np.sort(np.random.rand(2) * 100 - 50)\n    area = np.round(polyIntegral(b) - polyIntegral(a), NUM_DECIMALS_ROUND)\n    areaC = np.round(NumCpp.integrate_trapazoidal(polyC, a, b), NUM_DECIMALS_ROUND)\n    if area == areaC:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(area)\n        print(areaC)\n        print(colored('\\tFAIL', 'red'))\n\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestLinalg.py,58,"b""import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Linalg Module', 'magenta'))\n\n    print(colored('Testing cholesky', 'cyan'))\n    shapeInput = np.random.randint(5, 50, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    a = np.random.randint(1, 100, [shape.rows, shape.cols]).flatten()\n    aL = np.tril(a)\n    b = aL.dot(aL.transpose())\n    cArray.setArray(b)\n    if np.array_equal(np.round(NumCpp.cholesky(cArray).getNumpyArray()), np.round(aL)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing det: 2x2', 'cyan'))\n    order = 2\n    shape = NumCpp.Shape(order)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if round(NumCpp.det(cArray)) == round(np.linalg.det(data).item()):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing det: 3x3', 'cyan'))\n    order = 3\n    shape = NumCpp.Shape(order)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if round(NumCpp.det(cArray)) == round(np.linalg.det(data).item()):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing det: NxN', 'cyan'))\n    order = np.random.randint(4, 8, [1,]).item()\n    shape = NumCpp.Shape(order)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    if round(NumCpp.det(cArray)) == round(np.linalg.det(data).item()):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing hat', 'cyan'))\n    shape = NumCpp.Shape(1, 3)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).flatten()\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.hat(cArray), hat(data)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing inv', 'cyan'))\n    order = np.random.randint(5, 50, [1,]).item()\n    shape = NumCpp.Shape(order)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.inv(cArray).getNumpyArray(), 9), np.round(np.linalg.inv(data), 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing lstsq', 'cyan'))\n    shapeInput = np.random.randint(5, 50, [2,])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    aArray = NumCpp.NdArray(shape)\n    bArray = NumCpp.NdArray(1, shape.rows)\n    aData = np.random.randint(1, 100, [shape.rows, shape.cols])\n    bData = np.random.randint(1, 100, [shape.rows,])\n    aArray.setArray(aData)\n    bArray.setArray(bData)\n    x = NumCpp.lstsq(aArray, bArray, 1e-12).getNumpyArray().flatten()\n    if np.array_equal(np.round(x, 9), np.round(np.linalg.lstsq(aData, bData, rcond=None)[0], 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing lu_decompostion', 'cyan'))\n    sizeInput = np.random.randint(5, 50)\n    shape = NumCpp.Shape(sizeInput)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    lu = NumCpp.lu_decomposition(cArray)\n    l = lu.first\n    u = lu.second\n    p = np.round(np.dot(l.getNumpyArray(), u.getNumpyArray())).astype(np.int)\n    if np.array_equal(p, data):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing matrix_power: power = 0', 'cyan'))\n    order = np.random.randint(5, 50, [1, ]).item()\n    shape = NumCpp.Shape(order)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.matrix_power(cArray, 0).getNumpyArray(), np.linalg.matrix_power(data, 0)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing matrix_power: power = 1', 'cyan'))\n    order = np.random.randint(5, 50, [1, ]).item()\n    shape = NumCpp.Shape(order)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(NumCpp.matrix_power(cArray, 1).getNumpyArray(), np.linalg.matrix_power(data, 1)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing matrix_power: power = -1', 'cyan'))\n    order = np.random.randint(5, 50, [1, ]).item()\n    shape = NumCpp.Shape(order)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    if np.array_equal(np.round(NumCpp.matrix_power(cArray, -1).getNumpyArray(), 8), np.round(np.linalg.matrix_power(data, -1), 8)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing matrix_power: power > 1', 'cyan'))\n    order = np.random.randint(5, 50, [1, ]).item()\n    shape = NumCpp.Shape(order)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 5, [shape.rows, shape.cols]).astype(np.double)\n    cArray.setArray(data)\n    power = np.random.randint(2, 9, [1,]).item()\n    if np.array_equal(NumCpp.matrix_power(cArray, power).getNumpyArray(), np.linalg.matrix_power(data, power)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing matrix_power: power < -1', 'cyan'))\n    order = np.random.randint(5, 50, [1,]).item()\n    shape = NumCpp.Shape(order)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    power = np.random.randint(2, 9, [1, ]).item() * -1\n    if np.array_equal(np.round(NumCpp.matrix_power(cArray, power).getNumpyArray(), 9), np.round(np.linalg.matrix_power(data, power), 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing multi_dot', 'cyan'))\n    shapeInput = np.random.randint(5, 50, [2, ])\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape2 = NumCpp.Shape(shape1.cols, np.random.randint(5, 50, [1, ]).item())\n    shape3 = NumCpp.Shape(shape2.cols, np.random.randint(5, 50, [1, ]).item())\n    shape4 = NumCpp.Shape(shape3.cols, np.random.randint(5, 50, [1, ]).item())\n    cArray1 = NumCpp.NdArray(shape1)\n    cArray2 = NumCpp.NdArray(shape2)\n    cArray3 = NumCpp.NdArray(shape3)\n    cArray4 = NumCpp.NdArray(shape4)\n    data1 = np.random.randint(1, 10, [shape1.rows, shape1.cols])\n    data2 = np.random.randint(1, 10, [shape2.rows, shape2.cols])\n    data3 = np.random.randint(1, 10, [shape3.rows, shape3.cols])\n    data4 = np.random.randint(1, 10, [shape4.rows, shape4.cols])\n    cArray1.setArray(data1)\n    cArray2.setArray(data2)\n    cArray3.setArray(data3)\n    cArray4.setArray(data4)\n    if np.array_equal(np.round(NumCpp.multi_dot(cArray1, cArray2, cArray3, cArray4), 9), np.round(np.linalg.multi_dot([data1, data2, data3, data4]), 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing pivotlu_decompostion', 'cyan'))\n    sizeInput = np.random.randint(5, 50)\n    shape = NumCpp.Shape(sizeInput)\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    l, u, p = NumCpp.pivotLU_decomposition(cArray)\n    lhs = p.dot(data)\n    rhs = l.dot(u)\n    if np.array_equal(np.round(lhs, 10), np.round(rhs, 10)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing svd', 'cyan'))\n    shapeInput = np.random.randint(5, 50, [2,])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    uArray = NumCpp.NdArray()\n    sArray = NumCpp.NdArray()\n    vArray = NumCpp.NdArray()\n    NumCpp.svd(cArray, uArray, sArray, vArray)\n    data2 = np.dot(uArray.getNumpyArray(), np.dot(sArray.getNumpyArray(), vArray.getNumpyArray()))\n    if np.array_equal(np.round(data, 9), np.round(data2, 9)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n####################################################################################\ndef hat(inVec):\n    mat = np.zeros([3,3])\n    mat[0, 1] = -inVec[2]\n    mat[0, 2] = inVec[1]\n    mat[1, 0] = inVec[2]\n    mat[1, 2] = -inVec[0]\n    mat[2, 0] = -inVec[1]\n    mat[2, 1] = inVec[0]\n\n    return mat\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestNdArray.py,665,"b""import numpy as np\r\nfrom termcolor import colored\r\nfrom functools import reduce\r\nimport os\r\nimport getpass\r\nimport sys\r\nif sys.platform == 'linux':\r\n    sys.path.append(r'../lib')\r\nelse:\r\n    sys.path.append(os.path.abspath('../build/x64/Release'))\r\nimport NumCpp\r\n\r\n####################################################################################\r\ndef factors(n):\r\n    return set(reduce(list.__add__,\r\n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\r\n\r\n####################################################################################\r\ndef doTest():\r\n    print(colored('Testing NdArray Class', 'magenta'))\r\n\r\n    print(colored('Testing Default Constructor', 'cyan'))\r\n    cArray = NumCpp.NdArray()\r\n    if cArray.shape().rows == 0 and cArray.shape().cols == 0 and cArray.size() == 0:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing Square Constructor', 'cyan'))\r\n    numRowsCols = np.random.randint(1, 100, [1,]).item()\r\n    cArray = NumCpp.NdArray(numRowsCols)\r\n    if (cArray.shape().rows == numRowsCols and cArray.shape().cols == numRowsCols and\r\n            cArray.size() == numRowsCols**2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing Rectangle Constructor', 'cyan'))\r\n    numRowsCols = np.random.randint(1, 100, [2,])\r\n    cArray = NumCpp.NdArray(numRowsCols[0].item(), numRowsCols[1].item())\r\n    if (cArray.shape().rows == numRowsCols[0] and cArray.shape().cols == numRowsCols[1] and\r\n            cArray.size() == numRowsCols.prod()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing Shape Constructor', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2,])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    if (cArray.shape().rows == shape.rows and cArray.shape().cols == shape.cols and\r\n            cArray.size() == shape.rows * shape.cols):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing 1D List Constructor', 'cyan'))\r\n    if NumCpp.NdArray.test1DListContructor():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing 2D List Constructor', 'cyan'))\r\n    if NumCpp.NdArray.test2DListContructor():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing Copy Constructor', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2,])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    cArray.setArray(np.random.randint(1, 100, [shape.rows, shape.cols]))\r\n    cArray2 = NumCpp.NdArray(cArray)\r\n    if np.array_equal(np.round(cArray2.getNumpyArray(), 10), np.round(cArray.getNumpyArray(), 10)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing at flat', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    randomIdx = np.random.randint(0, shapeInput.prod(), [1,]).item()\r\n    if cArray.get(randomIdx) == data.flatten()[randomIdx]:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing at row/col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    randomRowIdx = np.random.randint(0, shapeInput[0], [1,]).item()\r\n    randomColIdx = np.random.randint(0, shapeInput[1], [1,]).item()\r\n    if cArray.get(randomRowIdx, randomColIdx) == data[randomRowIdx, randomColIdx]:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing at slice 1D', 'cyan'))\r\n    shapeInput = np.random.randint(100, 500, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    start = np.random.randint(0, shapeInput.prod() // 10, [1,]).item()\r\n    stop = np.random.randint(start + 1, shapeInput.prod(), [1,]).item()\r\n    step = np.random.randint(1, shapeInput.prod() // 10, [1,]).item()\r\n    if np.array_equal(cArray.get(NumCpp.Slice(start, stop, step)).flatten().astype(np.uint32), data.flatten()[start:stop:step]):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing at slice 2D', 'cyan'))\r\n    shapeInput = np.random.randint(100, 500, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    startRow = np.random.randint(0, shapeInput[0] // 10, [1,]).item()\r\n    stopRow = np.random.randint(startRow + 1, shapeInput[0], [1,]).item()\r\n    stepRow = np.random.randint(1, shapeInput[0] // 10, [1,]).item()\r\n    startCol = np.random.randint(0, shapeInput[1] // 10, [1,]).item()\r\n    stopCol = np.random.randint(startCol + 1, shapeInput[1], [1,]).item()\r\n    stepCol = np.random.randint(1, shapeInput[1] // 10, [1,]).item()\r\n    if np.array_equal(cArray.get(NumCpp.Slice(startRow, stopRow, stepRow), NumCpp.Slice(startCol, stopCol, stepCol)).astype(np.uint32),\r\n                      data[startRow:stopRow:stepRow, startCol:stopCol:stepCol]):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing all: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.all(NumCpp.Axis.NONE).astype(np.bool).item() == np.all(data).item():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing all: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.all(NumCpp.Axis.ROW).flatten().astype(np.bool), np.all(data, axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing all: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.all(NumCpp.Axis.COL).flatten().astype(np.bool), np.all(data, axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing any: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.any(NumCpp.Axis.NONE).astype(np.bool).item() == np.any(data).item():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing any: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.any(NumCpp.Axis.ROW).flatten().astype(np.bool), np.any(data, axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing any: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.any(NumCpp.Axis.COL).flatten().astype(np.bool), np.any(data, axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing argmax: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.argmax(NumCpp.Axis.NONE).item(), np.argmax(data)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing argmax: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.argmax(NumCpp.Axis.ROW).flatten(), np.argmax(data, axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing argmax: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.argmax(NumCpp.Axis.COL).flatten(), np.argmax(data, axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing argmin: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.argmin(NumCpp.Axis.NONE).item(), np.argmin(data)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing argmin: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.argmin(NumCpp.Axis.ROW).flatten(), np.argmin(data, axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing argmin: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.argmin(NumCpp.Axis.COL).flatten(), np.argmin(data, axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing argsort: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    dataFlat = data.flatten()\r\n    if np.array_equal(dataFlat[cArray.argsort(NumCpp.Axis.NONE).flatten().astype(np.uint32)], dataFlat[np.argsort(data, axis=None)]):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing argsort: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    pIdx = np.argsort(data, axis=0)\r\n    cIdx = cArray.argsort(NumCpp.Axis.ROW).astype(np.uint16)\r\n    allPass = True\r\n    for idx, row in enumerate(data.T):\r\n        if not np.array_equal(row[cIdx[:, idx]], row[pIdx[:, idx]]):\r\n            allPass = False\r\n            break\r\n    if allPass:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing argsort: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    pIdx = np.argsort(data, axis=1)\r\n    cIdx = cArray.argsort(NumCpp.Axis.COL).astype(np.uint16)\r\n    allPass = True\r\n    for idx, row in enumerate(data):\r\n        if not np.array_equal(row[cIdx[idx, :]], row[pIdx[idx, :]]):\r\n            allPass = False\r\n            break\r\n    if allPass:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing back', 'cyan'))\r\n    if cArray.back() == data.flatten()[-1]:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing back reference', 'cyan'))\r\n    if cArray.backReference() == data.flatten()[-1]:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing byteswap', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    oldEndianess = cArray.endianess()\r\n    cArray.byteswap()\r\n    if np.array_equal(cArray.getNumpyArray().astype(np.uint32), data.byteswap()) and cArray.endianess() != oldEndianess:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing clip', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.clip(5, 90).astype(np.ushort), data.clip(5, 90)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    colIdx = np.random.randint(0, shape.cols, [1,]).item()\r\n    if np.array_equal(cArray.column(colIdx).getNumpyArray().flatten(), data[:, colIdx].flatten()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing contains: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    value = np.random.randint(0, 100, [1, ]).item()\r\n    cArray.setArray(data)\r\n    if cArray.contains(value, NumCpp.Axis.NONE) == (value in data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing contains: Axis = Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    value = np.random.randint(0, 100, [1, ]).item()\r\n    cArray.setArray(data)\r\n    truth = list()\r\n    for row in data:\r\n        truth.append(value in row)\r\n    if np.array_equal(cArray.contains(value, NumCpp.Axis.COL).flatten(), np.asarray(truth)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing contains: Axis = ROW', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    value = np.random.randint(0, 100, [1, ]).item()\r\n    cArray.setArray(data)\r\n    truth = list()\r\n    for row in data.T:\r\n        truth.append(value in row)\r\n    if np.array_equal(cArray.contains(value, NumCpp.Axis.ROW).flatten(), np.asarray(truth)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing copy', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.copy(), data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cumprod: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 5, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 4, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.cumprod(NumCpp.Axis.NONE).flatten().astype(np.uint32), data.cumprod()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cumprod: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 5, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 4, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.cumprod(NumCpp.Axis.ROW).astype(np.uint32), data.cumprod(axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cumprod: Axis = Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 5, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 4, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.cumprod(NumCpp.Axis.COL).astype(np.uint32), data.cumprod(axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cumsum: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.cumsum(NumCpp.Axis.NONE).flatten().astype(np.uint32), data.cumsum()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cumsum: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.cumsum(NumCpp.Axis.ROW).astype(np.uint32), data.cumsum(axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cumsum: Axis = Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.cumsum(NumCpp.Axis.COL).astype(np.uint32), data.cumsum(axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing diagonal: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    offset = np.random.randint(-min(shape.rows, shape.cols), min(shape.rows, shape.cols), [1,]).item()\r\n    if np.array_equal(cArray.diagonal(offset, NumCpp.Axis.ROW).astype(np.uint32).flatten(), data.diagonal(offset, axis1=0, axis2=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing diagonal: Axis = Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    offset = np.random.randint(-min(shape.rows, shape.cols), min(shape.rows, shape.cols), [1,]).item()\r\n    if np.array_equal(cArray.diagonal(offset, NumCpp.Axis.COL).astype(np.uint32).flatten(), data.diagonal(offset, axis1=1, axis2=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing dot vector', 'cyan'))\r\n    size = np.random.randint(1, 100, [1,]).item()\r\n    shape = NumCpp.Shape(1, size)\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    data2 = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if cArray1.dot(cArray2).item() == np.dot(data1, data2.T).item():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing dot array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2,])\r\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    shape2 = NumCpp.Shape(shapeInput[1].item(), np.random.randint(1, 100, [1,]).item())\r\n    cArray1 = NumCpp.NdArray(shape1)\r\n    cArray2 = NumCpp.NdArray(shape2)\r\n    data1 = np.random.randint(1, 50, [shape1.rows, shape1.cols], dtype=np.uint32)\r\n    data2 = np.random.randint(1, 50, [shape2.rows, shape2.cols], dtype=np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.dot(cArray2), np.dot(data1, data2)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing dump', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    tempDir = r'C:\\Temp'\r\n    if not os.path.exists(tempDir):\r\n        os.mkdir(tempDir)\r\n    tempFile = os.path.join(tempDir, 'NdArrayDump.bin')\r\n    cArray.dump(tempFile)\r\n    if os.path.exists(tempFile):\r\n        filesize = os.path.getsize(tempFile)\r\n        if filesize == data.size * 8:\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n    os.remove(tempFile)\r\n\r\n    print(colored('Testing fill', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    fillValue = np.random.randint(1,100, [1,]).item()\r\n    ret = cArray.fill(fillValue)\r\n    if np.all(ret == fillValue):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing flatnonzero', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 10, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.flatnonzero().flatten().astype(np.uint32), np.flatnonzero(data)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing flatten', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.flatten().astype(np.uint32), data.reshape([1, data.size])):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing front', 'cyan'))\r\n    if cArray.front() == data.flatten()[0]:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing front reference', 'cyan'))\r\n    if cArray.frontReference() == data.flatten()[0]:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing getByIndices', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2,])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, shapeInput)\r\n    cArray.setArray(data)\r\n    numIndices = np.random.randint(0, shape.size(), [1, ]).item()\r\n    indices = np.random.randint(0, shape.size(), [numIndices, ])\r\n    cIndices = NumCpp.NdArrayInt(1, numIndices)\r\n    cIndices.setArray(indices)\r\n    if np.array_equal(cArray.getByIndices(cIndices).flatten(), data.flatten()[indices]):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing getByMask', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2,])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, shapeInput)\r\n    cArray.setArray(data)\r\n    mask = data > np.random.randint(1, data.max(), [1, ]).item()\r\n    cMask = NumCpp.NdArrayBool(shape)\r\n    cMask.setArray(mask)\r\n    if np.array_equal(cArray.getByMask(cMask).flatten(), data[mask].flatten()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n        \r\n    print(colored('Testing isflat', 'cyan'))\r\n    shapeInput = np.random.randint(2, 100, [2, ])\r\n    sizeInput = np.random.randint(2, 100, [1, ]).item()\r\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    shape2 = NumCpp.Shape(1, sizeInput)\r\n    cArray1 = NumCpp.NdArray(shape1)\r\n    cArray2 = NumCpp.NdArray(shape2)\r\n    if not cArray1.isflat() and cArray2.isflat():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing issorted: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    dataSorted = np.sort(data.flatten()).reshape(data.shape)\r\n    cArray.setArray(data)\r\n    if not cArray.issorted(NumCpp.Axis.NONE).item():\r\n        cArray.setArray(dataSorted)\r\n        if cArray.issorted(NumCpp.Axis.NONE).item():\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing issorted: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    dataSorted = np.sort(data, axis=0).reshape(data.shape)\r\n    cArray.setArray(data)\r\n    if not np.all(cArray.issorted(NumCpp.Axis.ROW)):\r\n        cArray.setArray(dataSorted)\r\n        if np.all(cArray.issorted(NumCpp.Axis.ROW)):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing issorted: Axis = Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    dataSorted = np.sort(data, axis=1).reshape(data.shape)\r\n    cArray.setArray(data)\r\n    if not np.all(cArray.issorted(NumCpp.Axis.COL)):\r\n        cArray.setArray(dataSorted)\r\n        if np.all(cArray.issorted(NumCpp.Axis.COL)):\r\n            print(colored('\\tPASS', 'green'))\r\n        else:\r\n            print(colored('\\tFAIL', 'red'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing issquare', 'cyan'))\r\n    while True:\r\n        shapeInput = np.random.randint(2, 100, [2, ])\r\n        if np.prod(shapeInput) != np.square(shapeInput[0]):\r\n            break\r\n    sizeInput = np.random.randint(2, 100, [1, ]).item()\r\n    shape1 = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    shape2 = NumCpp.Shape(sizeInput, sizeInput)\r\n    cArray1 = NumCpp.NdArray(shape1)\r\n    cArray2 = NumCpp.NdArray(shape2)\r\n    if not cArray1.issquare() and cArray2.issquare():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing item', 'cyan'))\r\n    shape = NumCpp.Shape(1, 1)\r\n    cArray = NumCpp.NdArray(shape)\r\n    fillValue = np.random.randint(1, 100, [1, ]).item()\r\n    cArray.fill(fillValue)\r\n    if cArray.item() == fillValue:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing max: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.max(NumCpp.Axis.NONE).item() == np.max(data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing max: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.max(NumCpp.Axis.ROW).flatten(), np.max(data, axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing max: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.max(NumCpp.Axis.COL).flatten(), np.max(data, axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing min: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.min(NumCpp.Axis.NONE).item() == np.min(data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing min: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.min(NumCpp.Axis.ROW).flatten(), np.min(data, axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing min: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.min(NumCpp.Axis.COL).flatten(), np.min(data, axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing mean: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.mean(NumCpp.Axis.NONE).item() == np.mean(data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing mean: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.mean(NumCpp.Axis.ROW).flatten(), np.mean(data, axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing mean: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.mean(NumCpp.Axis.COL).flatten(), np.mean(data, axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing median: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.median(NumCpp.Axis.NONE).item() == np.median(data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing median: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.median(NumCpp.Axis.ROW).flatten(), np.median(data, axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing median: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.median(NumCpp.Axis.COL).flatten(), np.median(data, axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing nans', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    cArray.nans()\r\n    if np.all(np.isnan(cArray.getNumpyArray())):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing nbytes', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.nbytes() == 8 * data.size:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing newbyteorder', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.newbyteorder(NumCpp.Endian.BIG).astype(np.uint32), data.newbyteorder()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing none: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.none(NumCpp.Axis.NONE).astype(np.bool).item() == np.logical_not(np.any(data).item()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing none: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.none(NumCpp.Axis.ROW).flatten().astype(np.bool), np.logical_not(np.any(data, axis=0))):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing none: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.none(NumCpp.Axis.COL).flatten().astype(np.bool), np.logical_not(np.any(data, axis=1))):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing nonzero', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 10, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    rowsC, colsC = cArray.nonzero()\r\n    rows, cols = data.nonzero()\r\n    if np.array_equal(rowsC.flatten(), rows) and np.array_equal(colsC.flatten(), cols):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing norm: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.norm(NumCpp.Axis.NONE).item() == np.linalg.norm(data.flatten()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing norm: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    norms = cArray.norm(NumCpp.Axis.ROW).flatten()\r\n    allPass = True\r\n    for idx, row in enumerate(data.transpose()):\r\n        if norms[idx] != np.linalg.norm(row):\r\n            allPass = False\r\n            break\r\n    if allPass:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing norm: Axis = Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    norms = cArray.norm(NumCpp.Axis.COL).flatten()\r\n    allPass = True\r\n    for idx, row in enumerate(data):\r\n        if norms[idx] != np.linalg.norm(row):\r\n            allPass = False\r\n            break\r\n    if allPass:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing ones', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    ret = cArray.ones()\r\n    if np.all(ret == 1):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing partition: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    kthElement = np.random.randint(0, shapeInput.prod(), [1,], dtype=np.uint32).item()\r\n    partitionedArray = cArray.partition(kthElement, NumCpp.Axis.NONE).flatten()\r\n    if (np.all(partitionedArray[:kthElement] <= partitionedArray[kthElement]) and\r\n        np.all(partitionedArray[kthElement:] >= partitionedArray[kthElement])):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing partition: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    kthElement = np.random.randint(0, shapeInput[0], [1,], dtype=np.uint32).item()\r\n    partitionedArray = cArray.partition(kthElement, NumCpp.Axis.ROW).transpose()\r\n    allPass = True\r\n    for row in partitionedArray:\r\n        if not (np.all(row[:kthElement] <= row[kthElement]) and\r\n                np.all(row[kthElement:] >= row[kthElement])):\r\n            allPass = False\r\n            break\r\n    if allPass:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing partition: Axis = Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    kthElement = np.random.randint(0, shapeInput[1], [1,], dtype=np.uint32).item()\r\n    partitionedArray = cArray.partition(kthElement, NumCpp.Axis.COL)\r\n    allPass = True\r\n    for row in partitionedArray:\r\n        if not (np.all(row[:kthElement] <= row[kthElement]) and\r\n                np.all(row[kthElement:] >= row[kthElement])):\r\n            allPass = False\r\n            break\r\n    if allPass:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing prod: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 10, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 15, [shape.rows, shape.cols], dtype=np.uint32).astype(np.double)\r\n    cArray.setArray(data)\r\n    if cArray.prod(NumCpp.Axis.NONE).item() == data.prod():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing prod: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 10, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 15, [shape.rows, shape.cols], dtype=np.uint32).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.prod(NumCpp.Axis.ROW).flatten(), data.prod(axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing prod: Axis = Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 10, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 15, [shape.rows, shape.cols], dtype=np.uint32).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.prod(NumCpp.Axis.COL).flatten(), data.prod(axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing ptp: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 10, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 15, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if cArray.ptp(NumCpp.Axis.NONE).astype(np.uint32).item() == data.ptp():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing ptp: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 10, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 15, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.ptp(NumCpp.Axis.ROW).flatten().astype(np.uint32), data.ptp(axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing ptp: Axis = Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 10, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 15, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.ptp(NumCpp.Axis.COL).flatten().astype(np.uint32), data.ptp(axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing put flat', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    randomIdx = np.random.randint(0, shapeInput.prod(), [1,]).item()\r\n    randomValue = np.random.randint(1, 500, [1, ]).item()\r\n    cArray.put(randomIdx, randomValue)\r\n    if cArray.get(randomIdx) == randomValue:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing put row/col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 50, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    randomRowIdx = np.random.randint(0, shapeInput[0], [1,]).item()\r\n    randomColIdx = np.random.randint(0, shapeInput[1], [1,]).item()\r\n    randomValue = np.random.randint(1, 500, [1, ]).item()\r\n    cArray.put(randomRowIdx, randomColIdx, randomValue)\r\n    if cArray.get(randomRowIdx, randomColIdx) == randomValue:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing put slice 1D value', 'cyan'))\r\n    shapeInput = np.random.randint(100, 500, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    start = np.random.randint(0, shapeInput.prod() // 4, [1,]).item()\r\n    stop = np.random.randint(start + 1, shapeInput.prod(), [1,]).item()\r\n    step = np.random.randint(1, shapeInput.prod() // 10, [1,]).item()\r\n    randomValue = np.random.randint(1, 500, [1, ]).item()\r\n    inputSlice = NumCpp.Slice(start, stop, step)\r\n    cArray.put(inputSlice, randomValue)\r\n    if np.all(cArray.get(inputSlice).astype(np.uint32) == randomValue):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing put slice 1D values', 'cyan'))\r\n    shapeInput = np.random.randint(100, 500, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    start = np.random.randint(0, shapeInput.prod() // 4, [1,]).item()\r\n    stop = np.random.randint(start + 1, shapeInput.prod(), [1,]).item()\r\n    step = np.random.randint(1, shapeInput.prod() // 10, [1,]).item()\r\n    inputSlice = NumCpp.Slice(start, stop, step)\r\n    randomValues = np.random.randint(1, 500, [inputSlice.numElements(cArray.size()), ])\r\n    cArray.put(inputSlice, randomValues)\r\n    if np.array_equal(cArray.get(inputSlice).flatten().astype(np.uint32), randomValues):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing put slice 2D value', 'cyan'))\r\n    shapeInput = np.random.randint(100, 500, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    startRow = np.random.randint(0, shapeInput[0] // 10, [1,]).item()\r\n    stopRow = np.random.randint(startRow + 1, shapeInput[0], [1,]).item()\r\n    stepRow = np.random.randint(1, shapeInput[0] // 10, [1,]).item()\r\n    startCol = np.random.randint(0, shapeInput[1] // 10, [1,]).item()\r\n    stopCol = np.random.randint(startCol + 1, shapeInput[1], [1,]).item()\r\n    stepCol = np.random.randint(1, shapeInput[1] // 10, [1,]).item()\r\n    inputRowSlice = NumCpp.Slice(startRow, stopRow, stepRow)\r\n    inputColSlice = NumCpp.Slice(startCol, stopCol, stepCol)\r\n    randomValue = np.random.randint(1, 500, [1, ]).item()\r\n    cArray.put(inputRowSlice, inputColSlice, randomValue)\r\n    if np.all(cArray.get(inputRowSlice, inputColSlice).astype(np.uint32) == randomValue):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing put slice 2D values', 'cyan'))\r\n    shapeInput = np.random.randint(100, 500, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    startRow = np.random.randint(0, shapeInput[0] // 10, [1,]).item()\r\n    stopRow = np.random.randint(startRow + 1, shapeInput[0], [1,]).item()\r\n    stepRow = np.random.randint(1, shapeInput[0] // 10, [1,]).item()\r\n    startCol = np.random.randint(0, shapeInput[1] // 10, [1,]).item()\r\n    stopCol = np.random.randint(startCol + 1, shapeInput[1], [1,]).item()\r\n    stepCol = np.random.randint(1, shapeInput[1] // 10, [1,]).item()\r\n    inputRowSlice = NumCpp.Slice(startRow, stopRow, stepRow)\r\n    inputColSlice = NumCpp.Slice(startCol, stopCol, stepCol)\r\n    randomValues = np.random.randint(1, 500, [inputRowSlice.numElements(shape.rows), inputColSlice.numElements(shape.cols)])\r\n    cArray.put(inputRowSlice, inputColSlice, randomValues)\r\n    if np.array_equal(cArray.get(inputRowSlice, inputColSlice).astype(np.uint32), randomValues):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing putMask: Single Value', 'cyan'))\r\n    shapeInput = np.random.randint(100, 500, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    mask = data > np.random.randint(0, data.max(), [1, ]).item()\r\n    inputValue = np.random.randint(0, 666, [1, ]).item()\r\n    cArray.putMask(mask, inputValue)\r\n    data[mask] = inputValue\r\n    if np.array_equal(cArray.getNumpyArray().astype(np.uint32), data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing putMask: Multiple Values', 'cyan'))\r\n    shapeInput = np.random.randint(100, 500, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 50, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    mask = data > np.random.randint(0, data.max(), [1, ]).item()\r\n    inputValues = np.random.randint(0, 666, [np.count_nonzero(mask), ])\r\n    cArray.putMask(mask, inputValues)\r\n    data[mask] = inputValues\r\n    if np.array_equal(cArray.getNumpyArray().astype(np.uint32), data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing ravel', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.ravel().flatten(), data.ravel()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing replace', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt32(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    oldValue = np.random.randint(1, 100, 1).item()\r\n    newValue = np.random.randint(1, 100, 1).item()\r\n    dataCopy = data.copy()\r\n    dataCopy[dataCopy == oldValue] = newValue\r\n    if np.array_equal(cArray.replace(oldValue, newValue), dataCopy):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing reshapeInt', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    newShape = data.size\r\n    if np.array_equal(cArray.reshape(newShape), data.reshape(1, newShape)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing reshapeShape', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    newShape = NumCpp.Shape(shapeInput[1].item(), shapeInput[0].item())\r\n    if np.array_equal(cArray.reshape(newShape), data.reshape(shapeInput[::-1])):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing reshapeList', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    newShape = NumCpp.Shape(shapeInput[1].item(), shapeInput[0].item())\r\n    if np.array_equal(cArray.reshapeList(newShape), data.reshape(shapeInput[::-1])):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing reshapeValues negative rows', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    newNumCols = np.random.choice(np.array(list(factors(data.size))), 1).item()\r\n    if np.array_equal(cArray.reshape(-1, newNumCols), data.reshape(-1, newNumCols)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing reshapeValues negative cols', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    newNumRows = np.random.choice(np.array(list(factors(data.size))), 1).item()\r\n    if np.array_equal(cArray.reshape(newNumRows, -1), data.reshape(newNumRows, -1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing resizeFast', 'cyan'))\r\n    shapeInput1 = np.random.randint(1, 100, [2, ])\r\n    shapeInput2 = np.random.randint(1, 100, [2, ])\r\n    shape1 = NumCpp.Shape(shapeInput1[0].item(), shapeInput1[1].item())\r\n    shape2 = NumCpp.Shape(shapeInput2[0].item(), shapeInput2[1].item())\r\n    cArray = NumCpp.NdArray(shape1)\r\n    data = np.random.randint(1, 100, [shape1.rows, shape1.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    res = cArray.resizeFast(shape2)\r\n    if np.all(res == 0) and cArray.shape().rows == shape2.rows and cArray.shape().cols == shape2.cols:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing resizeSlow', 'cyan'))\r\n    shapeInput1 = np.random.randint(1, 100, [2, ])\r\n    shapeInput2 = np.random.randint(1, 100, [2, ])\r\n    shape1 = NumCpp.Shape(shapeInput1[0].item(), shapeInput1[1].item())\r\n    shape2 = NumCpp.Shape(shapeInput2[0].item(), shapeInput2[1].item())\r\n    cArray = NumCpp.NdArray(shape1)\r\n    data = np.random.randint(1, 100, [shape1.rows, shape1.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    res = cArray.resizeSlow(shape2)\r\n    if cArray.shape().rows == shape2.rows and cArray.shape().cols == shape2.cols and not np.all(res == 0):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing rms: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.rms(NumCpp.Axis.NONE).item() == np.sqrt(np.mean(np.square(data))):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing rms: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.rms(NumCpp.Axis.ROW).flatten(), np.sqrt(np.mean(np.square(data), axis=0))):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing rms: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.rms(NumCpp.Axis.COL).flatten(), np.sqrt(np.mean(np.square(data), axis=1))):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    rowIdx = np.random.randint(0, shape.rows, [1,]).item()\r\n    if np.array_equal(cArray.row(rowIdx).getNumpyArray().flatten(), data[rowIdx, :].flatten()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing round', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randn(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    numRoundDecimals = np.random.randint(0, 10, [1,]).item()\r\n    if np.array_equal(cArray.round(numRoundDecimals), np.round(data, numRoundDecimals)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing shape', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    if cArray.shape().rows == shape.rows and cArray.shape().cols == shape.cols:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing size', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    if cArray.size() == shapeInput.cumprod()[-1].item():\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing sort: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    d = data.flatten()\r\n    d.sort()\r\n    if np.array_equal(cArray.sort(NumCpp.Axis.NONE).flatten(), d):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing sort: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols], dtype=np.uint32)\r\n    cArray.setArray(data)\r\n    pSorted = np.sort(data, axis=0)\r\n    cSorted = cArray.sort(NumCpp.Axis.ROW).astype(np.uint32)\r\n    if np.array_equal(cSorted, pSorted):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing sort: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    pSorted = np.sort(data, axis=1)\r\n    cSorted = cArray.sort(NumCpp.Axis.COL).astype(np.uint32)\r\n    if np.array_equal(cSorted, pSorted):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing stddev: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.round(cArray.stdev(NumCpp.Axis.NONE).item(), 10) == np.round(np.std(data), 10):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing stddev: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(np.round(cArray.stdev(NumCpp.Axis.ROW).flatten(), 10), np.round(np.std(data, axis=0), 10)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing stddev: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(np.round(cArray.stdev(NumCpp.Axis.COL).flatten(), 10), np.round(np.std(data, axis=1), 10)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing sum: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if cArray.sum(NumCpp.Axis.NONE).item() == np.sum(data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing sum: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.sum(NumCpp.Axis.ROW).flatten(), np.sum(data, axis=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing sum: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.sum(NumCpp.Axis.COL).flatten(), np.sum(data, axis=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing swapaxes', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.swapaxes(), data.T):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing tofile bin', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if sys.platform == 'linux':\r\n        tempDir = r'/home/' + getpass.getuser() + r'/Desktop/'\r\n        filename = os.path.join(tempDir, 'temp.bin')\r\n    else:\r\n        filename = r'C:\\Temp\\temp.bin'\r\n    cArray.tofile(filename, '')\r\n    if os.path.exists(filename):\r\n        print(colored('\\tPASS', 'green'))\r\n        os.remove(filename)\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing tofile txt', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if sys.platform == 'linux':\r\n        tempDir = r'/home/' + getpass.getuser() + r'/Desktop/'\r\n        filename = os.path.join(tempDir, 'temp.txt')\r\n    else:\r\n        filename = r'C:\\Temp\\temp.txt'\r\n    cArray.tofile(filename, '\\n')\r\n    if os.path.exists(filename):\r\n        print(colored('\\tPASS', 'green'))\r\n        os.remove(filename)\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing toStlVector', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    out = np.asarray(cArray.toStlVector())\r\n    if np.array_equal(out, data.flatten()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing trace: Offset=Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    offset = np.random.randint(0, shape.rows, [1,]).item()\r\n    if np.array_equal(cArray.trace(offset, NumCpp.Axis.ROW), data.trace(offset, axis1=1, axis2=0)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing trace: Offset=Col', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    offset = np.random.randint(0, shape.rows, [1,]).item()\r\n    if np.array_equal(cArray.trace(offset, NumCpp.Axis.COL), data.trace(offset, axis1=0, axis2=1)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing transpose', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.transpose(), data.T):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing var: Axis = None', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.round(cArray.var(NumCpp.Axis.NONE).item(), 9) == np.round(np.var(data), 9):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing var: Axis = Row', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(np.round(cArray.var(NumCpp.Axis.ROW).flatten(), 9), np.round(np.var(data, axis=0), 9)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing var: Axis = Column', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(np.round(cArray.var(NumCpp.Axis.COL).flatten(), 9), np.round(np.var(data, axis=1), 9)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing zeros', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    cArray.zeros()\r\n    if np.all(cArray.getNumpyArray() == 0):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator + scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorPlusScaler(randScaler), data + randScaler):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator + scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorPlusScalerReversed(randScaler), data + randScaler):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator + array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorPlusArray(cArray2), data1 + data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator -', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorNegative(), -data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator - scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorMinusScaler(randScaler), data - randScaler):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator - scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorMinusScalerReversed(randScaler), randScaler - data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator - array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorMinusArray(cArray2), data1 - data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator * scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorMultiplyScaler(randScaler), data * randScaler):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator * scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorMultiplyScalerReversed(randScaler), data * randScaler):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator * array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    data2 = np.random.randint(0, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorMultiplyArray(cArray2), data1 * data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator / scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorDivideScaler(randScaler), data / randScaler):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator / scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorDivideScalerReversed(randScaler), randScaler / data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator / array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.double)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorDivideArray(cArray2), data1 / data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator % scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorModulusScaler(randScaler), data % randScaler):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator % scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorModulusScalerReversed(randScaler), randScaler % data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator % array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArrayInt(shape)\r\n    cArray2 = NumCpp.NdArrayInt(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols])\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols])\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorModulusArray(cArray2), data1 % data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator | scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorBitwiseOrScaler(randScaler), np.bitwise_or(data, randScaler)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator | scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorBitwiseOrScalerReversed(randScaler), np.bitwise_or(data, randScaler)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator | array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArrayInt(shape)\r\n    cArray2 = NumCpp.NdArrayInt(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorBitwiseOrArray(cArray2), np.bitwise_or(data1, data2)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator & scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorBitwiseAndScaler(randScaler), np.bitwise_and(data, randScaler)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator & scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorBitwiseAndScalerReversed(randScaler), np.bitwise_and(data, randScaler)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator & array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArrayInt(shape)\r\n    cArray2 = NumCpp.NdArrayInt(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorBitwiseAndArray(cArray2), np.bitwise_and(data1, data2)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator ^ scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorBitwiseXorScaler(randScaler), np.bitwise_xor(data, randScaler)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator ^ scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 100, [1,]).item()\r\n    if np.array_equal(cArray.operatorBitwiseXorScalerReversed(randScaler), np.bitwise_xor(data, randScaler)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator ^ array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArrayInt(shape)\r\n    cArray2 = NumCpp.NdArrayInt(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorBitwiseXorArray(cArray2), np.bitwise_xor(data1, data2)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator ~', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorBitwiseNot(), ~data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator && array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArrayInt(shape)\r\n    cArray2 = NumCpp.NdArrayInt(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorLogicalAndArray(cArray2), np.logical_and(data1, data2)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator && scalar', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScalar = np.random.randint(1, 100, [1, ]).item()\r\n    if np.array_equal(cArray.operatorLogicalAndScalar(randScalar), np.logical_and(data, randScalar)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator && scalar reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScalar = np.random.randint(1, 100, [1, ]).item()\r\n    if np.array_equal(cArray.operatorLogicalAndScalarReversed(randScalar), np.logical_and(data, randScalar)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator || array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArrayInt(shape)\r\n    cArray2 = NumCpp.NdArrayInt(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorLogicalOrArray(cArray2), np.logical_or(data1, data2)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator || scalar', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScalar = np.random.randint(1, 100, [1, ]).item()\r\n    if np.array_equal(cArray.operatorLogicalOrScalar(randScalar), np.logical_or(data, randScalar)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator || scalar reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScalar = np.random.randint(1, 100, [1, ]).item()\r\n    if np.array_equal(cArray.operatorLogicalOrScalarReversed(randScalar), np.logical_or(data, randScalar)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator !', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorNot(), np.logical_not(data)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator == scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorEquality(value), data == value):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator == scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorEqualityReversed(value), data == value):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator == array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorEquality(cArray2), data1 == data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator != scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorNotEquality(value), data != value):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator != scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorNotEqualityReversed(value), data != value):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator != array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorNotEquality(cArray2), data1 != data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator < scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorLess(value), data < value):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator < scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorLessReversed(value), value < data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator < array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorLess(cArray2), data1 < data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator > scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorGreater(value), data > value):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator > scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorGreaterReversed(value), value > data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator > array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorGreater(cArray2), data1 > data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator <= scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorLessEqual(value), data <= value):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator <= scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorLessEqualReversed(value), value <= data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator <= array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorLessEqual(cArray2), data1 <= data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator >= scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorGreaterEqual(value), data >= value):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator >= scaler reversed', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    value = np.random.randint(1, 100, [1, ]).astype(np.uint32).item()\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorGreaterEqualReversed(value), value >= data):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator >= array', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray1 = NumCpp.NdArray(shape)\r\n    cArray2 = NumCpp.NdArray(shape)\r\n    data1 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    data2 = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray1.setArray(data1)\r\n    cArray2.setArray(data2)\r\n    if np.array_equal(cArray1.operatorGreaterEqual(cArray2), data1 >= data2):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator << scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 10, [1,]).item()\r\n    if np.array_equal(cArray.operatorBitshiftLeft(randScaler), data << randScaler):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator >> scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayInt(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    randScaler = np.random.randint(1, 10, [1,]).item()\r\n    if np.array_equal(cArray.operatorBitshiftRight(randScaler), data >> randScaler):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator post++ scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorPostPlusPlus(), data) and np.array_equal(cArray.getNumpyArray(), data + 1):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator post-- scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorPostMinusMinus(), data) and np.array_equal(cArray.getNumpyArray(), data - 1):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator pre++ scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorPrePlusPlus(), data + 1):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator pre-- scaler', 'cyan'))\r\n    shapeInput = np.random.randint(1, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.randint(1, 100, [shape.rows, shape.cols]).astype(np.uint32)\r\n    cArray.setArray(data)\r\n    if np.array_equal(cArray.operatorPreMinusMinus(), data - 1):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n####################################################################################\r\nif __name__ == '__main__':\r\n    doTest()\r\n"""
unitTests/testScripts/TestPolynomial.py,73,"b""import numpy as np\nimport scipy.special as sp\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n\n####################################################################################\ndef doTest():\n    testPoly1D()\n    testFunctions()\n\n\n####################################################################################\ndef testPoly1D():\n    print(colored('Testing Polynomial Module', 'magenta'))\n\n    print(colored('Testing Poly1d class', 'magenta'))\n\n    print(colored('Testing Constructor', 'cyan'))\n    numCoefficients = np.random.randint(3, 10, [1, ]).item()\n    coefficients = np.random.randint(-20, 20, [numCoefficients, ])\n    coefficientsC = NumCpp.NdArray(1, numCoefficients)\n    coefficientsC.setArray(coefficients)\n    polyC = NumCpp.Poly1d(coefficientsC, False)\n    if np.array_equal(polyC.coefficients().getNumpyArray().flatten(), coefficients):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Constructor Roots', 'cyan'))\n    numRoots = np.random.randint(3, 10, [1, ]).item()\n    roots = np.random.randint(-20, 20, [numRoots, ])\n    rootsC = NumCpp.NdArray(1, numRoots)\n    rootsC.setArray(roots)\n    poly = np.poly1d(roots, True)\n    polyC = NumCpp.Poly1d(rootsC, True)\n    if np.array_equal(np.fliplr(polyC.coefficients().getNumpyArray()).flatten().astype(np.int), poly.coefficients):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing area', 'cyan'))\n    bounds = np.random.rand(2) * 100 - 50\n    bounds = np.sort(bounds)\n    polyIntegral = poly.integ()\n    if np.round(polyC.area(*bounds), 3) == np.round(polyIntegral(bounds[1]) - polyIntegral(bounds[0]), 3):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(np.round(polyC.area(*bounds), 3))\n        print(np.round(polyIntegral(bounds[1]) - polyIntegral(bounds[0]), 3))\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing deriv', 'cyan'))\n    if np.array_equal(polyC.deriv().coefficients().getNumpyArray().flatten(), np.flipud(poly.deriv().coefficients)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing integ', 'cyan'))\n    if np.array_equal(polyC.integ().coefficients().getNumpyArray().flatten(), np.flipud(poly.integ().coefficients)):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing order', 'cyan'))\n    if polyC.order() == roots.size:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing operator()', 'cyan'))\n    value = np.random.randint(-20, 20, [1, ]).item()\n    if polyC[value] == poly(value):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing addition', 'cyan'))\n    numCoefficients = np.random.randint(3, 10, [1, ]).item()\n    coefficients = np.random.randint(-20, 20, [numCoefficients, ])\n    coefficientsC = NumCpp.NdArray(1, numCoefficients)\n    coefficientsC.setArray(coefficients)\n    polyC2 = NumCpp.Poly1d(coefficientsC, False)\n    poly2 = np.poly1d(np.flip(coefficients))\n    if np.array_equal(np.fliplr((polyC + polyC2).coefficients().getNumpyArray()).flatten(),\n                      (poly + poly2).coefficients):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing subtraction', 'cyan'))\n    if np.array_equal(np.fliplr((polyC - polyC2).coefficients().getNumpyArray()).flatten(),\n                      (poly - poly2).coefficients):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing multiplication', 'cyan'))\n    if np.array_equal(np.fliplr((polyC * polyC2).coefficients().getNumpyArray()).flatten(),\n                      (poly * poly2).coefficients):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing power', 'cyan'))\n    exponent = np.random.randint(0, 5, [1, ]).item()\n    if np.array_equal(np.fliplr((polyC2 ** exponent).coefficients().getNumpyArray()).flatten(),\n                      (poly2 ** exponent).coefficients):\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing print', 'cyan'))\n    polyC.print()\n\n\n####################################################################################\ndef testFunctions():\n    print(colored('Testing Polynomial functions', 'magenta'))\n    ORDER_MAX = 5\n    DECIMALS_ROUND = 7\n\n    print(colored('Testing chebyshev_t_Scaler', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        x = np.random.rand(1).item()\n        valuePy = sp.eval_chebyt(order, x)\n        valueCpp = NumCpp.chebyshev_t_Scaler(order, x)\n        if np.round(valuePy, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing chebyshev_t_Array', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        shapeInput = np.random.randint(10, 100, [2, ], dtype=np.uint32)\n        shape = NumCpp.Shape(*shapeInput)\n        cArray = NumCpp.NdArray(shape)\n        x = np.random.rand(*shapeInput)\n        cArray.setArray(x)\n        valuePy = sp.eval_chebyt(order, x)\n        valueCpp = NumCpp.chebyshev_t_Array(order, cArray)\n        if not np.array_equal(np.round(valuePy, DECIMALS_ROUND), np.round(valueCpp, DECIMALS_ROUND)):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing chebyshev_u_Scaler', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        x = np.random.rand(1).item()\n        valuePy = sp.eval_chebyu(order, x)\n        valueCpp = NumCpp.chebyshev_u_Scaler(order, x)\n        if np.round(valuePy, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing chebyshev_u_Array', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        shapeInput = np.random.randint(10, 100, [2, ], dtype=np.uint32)\n        shape = NumCpp.Shape(*shapeInput)\n        cArray = NumCpp.NdArray(shape)\n        x = np.random.rand(*shapeInput)\n        cArray.setArray(x)\n        valuePy = sp.eval_chebyu(order, x)\n        valueCpp = NumCpp.chebyshev_u_Array(order, cArray)\n        if not np.array_equal(np.round(valuePy, DECIMALS_ROUND), np.round(valueCpp, DECIMALS_ROUND)):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing hermite_Scaler', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        x = np.random.rand(1).item()\n        valuePy = sp.eval_hermite(order, x)\n        valueCpp = NumCpp.hermite_Scaler(order, x)\n        if np.round(valuePy, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing hermite_Array', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        shapeInput = np.random.randint(10, 100, [2, ], dtype=np.uint32)\n        shape = NumCpp.Shape(*shapeInput)\n        cArray = NumCpp.NdArray(shape)\n        x = np.random.rand(*shapeInput)\n        cArray.setArray(x)\n        valuePy = sp.eval_hermite(order, x)\n        valueCpp = NumCpp.hermite_Array(order, cArray)\n        if not np.array_equal(np.round(valuePy, DECIMALS_ROUND), np.round(valueCpp, DECIMALS_ROUND)):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing laguerre_Scaler1', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        x = np.random.rand(1).item()\n        valuePy = sp.eval_laguerre(order, x)\n        valueCpp = NumCpp.laguerre_Scaler1(order, x)\n        if np.round(valuePy, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing laguerre_Array1', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        shapeInput = np.random.randint(10, 100, [2, ], dtype=np.uint32)\n        shape = NumCpp.Shape(*shapeInput)\n        cArray = NumCpp.NdArray(shape)\n        x = np.random.rand(*shapeInput)\n        cArray.setArray(x)\n        valuePy = sp.eval_laguerre(order, x)\n        valueCpp = NumCpp.laguerre_Array1(order, cArray)\n        if not np.array_equal(np.round(valuePy, DECIMALS_ROUND), np.round(valueCpp, DECIMALS_ROUND)):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing laguerre_Scaler2', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        degree = np.random.randint(0, 10, [1, ]).item()\n        x = np.random.rand(1).item()\n        valuePy = sp.eval_genlaguerre(degree, order, x)\n        valueCpp = NumCpp.laguerre_Scaler2(order, degree, x)\n        if np.round(valuePy, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing laguerre_Array2', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        degree = np.random.randint(0, 10, [1, ]).item()\n        shapeInput = np.random.randint(10, 100, [2, ], dtype=np.uint32)\n        shape = NumCpp.Shape(*shapeInput)\n        cArray = NumCpp.NdArray(shape)\n        x = np.random.rand(*shapeInput)\n        cArray.setArray(x)\n        valuePy = sp.eval_genlaguerre(degree, order, x)\n        valueCpp = NumCpp.laguerre_Array2(order, degree, cArray)\n        if not np.array_equal(np.round(valuePy, DECIMALS_ROUND), np.round(valueCpp, DECIMALS_ROUND)):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing legendre_p_Scaler1', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        x = np.random.rand(1).item()\n        valuePy = sp.eval_legendre(order, x)\n        valueCpp = NumCpp.legendre_p_Scaler1(order, x)\n        if np.round(valuePy, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing legendre_p_Array1', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        shapeInput = np.random.randint(10, 100, [2, ], dtype=np.uint32)\n        shape = NumCpp.Shape(*shapeInput)\n        cArray = NumCpp.NdArray(shape)\n        x = np.random.rand(*shapeInput)\n        cArray.setArray(x)\n        valuePy = sp.eval_legendre(order, x)\n        valueCpp = NumCpp.legendre_p_Array1(order, cArray)\n        if not np.array_equal(np.round(valuePy, DECIMALS_ROUND), np.round(valueCpp, DECIMALS_ROUND)):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing legendre_p_Scaler2', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        x = np.random.rand(1).item()\n        degree = np.random.randint(order, ORDER_MAX)\n        valuePy = sp.lpmn(order, degree, x)[0][order, degree]\n        valueCpp = NumCpp.legendre_p_Scaler2(order, degree, x)\n        if np.round(valuePy, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing legendre_q_Scaler', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        x = np.random.rand(1).item()\n        valuePy = sp.lqn(order, x)[0][order]\n        valueCpp = NumCpp.legendre_q_Scaler(order, x)\n        if np.round(valuePy, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing spherical_harmonic', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        degree = np.random.randint(order, ORDER_MAX)\n        theta = np.random.rand(1).item() * np.pi * 2\n        phi = np.random.rand(1).item() * np.pi\n        valuePy = sp.sph_harm(order, degree, theta, phi)\n        valueCpp = NumCpp.spherical_harmonic(order, degree, theta, phi)\n        if (np.round(valuePy.real, DECIMALS_ROUND) != np.round(valueCpp[0], DECIMALS_ROUND) or\n                np.round(valuePy.imag, DECIMALS_ROUND) != np.round(valueCpp[1], DECIMALS_ROUND)):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing spherical_harmonic_r', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        degree = np.random.randint(order, ORDER_MAX)\n        theta = np.random.rand(1).item() * np.pi * 2\n        phi = np.random.rand(1).item() * np.pi\n        valuePy = sp.sph_harm(order, degree, theta, phi)\n        valueCpp = NumCpp.spherical_harmonic_r(order, degree, theta, phi)\n        if np.round(valuePy.real, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n    print(colored('Testing spherical_harmonic_i', 'cyan'))\n    allTrue = True\n    for order in range(ORDER_MAX):\n        degree = np.random.randint(order, ORDER_MAX)\n        theta = np.random.rand(1).item() * np.pi * 2\n        phi = np.random.rand(1).item() * np.pi\n        valuePy = sp.sph_harm(order, degree, theta, phi)\n        valueCpp = NumCpp.spherical_harmonic_i(order, degree, theta, phi)\n        if np.round(valuePy.imag, DECIMALS_ROUND) != np.round(valueCpp, DECIMALS_ROUND):\n            allTrue = False\n\n    if allTrue:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n        print(f'valuePy = {valuePy}, valueCpp = {valueCpp}')\n\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestRandom.py,72,"b""import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Random Module', 'magenta'))\n\n    # it is kind of hard to test randomness so my criteria for passing will\n    # simply be whether or not it crashes\n\n    print(colored('Testing bernoulli', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    p = np.random.rand()\n    r = NumCpp.bernoulli(inShape, p)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing bernoulli scalar', 'cyan'))\n    r = NumCpp.bernoulli(p)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing beta', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    alpha = np.random.rand()\n    beta = np.random.rand()\n    r = NumCpp.beta(inShape, alpha, beta)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing beta scalar', 'cyan'))\n    r = NumCpp.beta(alpha, beta)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing binomial', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    n = np.random.randint(1, 100, [1,]).item()\n    p = np.random.rand()\n    r = NumCpp.binomial(inShape, n, p)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing binomial scalar', 'cyan'))\n    r = NumCpp.binomial(n, p)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing cauchy', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    mean = np.random.randn() * 10\n    sigma = np.random.rand() * 10\n    r = NumCpp.cauchy(inShape, mean, sigma)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing cauchy scalar', 'cyan'))\n    r = NumCpp.cauchy( mean, sigma)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing chiSquare', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    dof = np.random.randint(1, 100, [1,]).item()\n    r = NumCpp.chiSquare(inShape, dof)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing chiSquare scalar', 'cyan'))\n    r = NumCpp.chiSquare(dof)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing choice: Single', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    r = NumCpp.choiceSingle(cArray)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing choice: Multiple', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.rand(shape.rows, shape.cols)\n    cArray.setArray(data)\n    num = np.random.randint(1, data.size, [1,]).item()\n    r = NumCpp.choiceMultiple(cArray, num)\n    if r.size == num:\n        print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing discrete', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    weights = np.random.randint(1, 10, [shape.rows, shape.cols])\n    cArray.setArray(weights)\n    r = NumCpp.discrete(inShape, cArray)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing discrete scalar', 'cyan'))\n    r = NumCpp.discrete(cArray)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing exponential', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    scale = np.random.rand() * 10\n    r = NumCpp.exponential(inShape, scale)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing exponential scalar', 'cyan'))\n    r = NumCpp.exponential(scale)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing extremeValue', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    a = np.random.rand() * 10\n    b = np.random.rand() * 100\n    r = NumCpp.extremeValue(inShape, a, b)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing extremeValue scalar', 'cyan'))\n    r = NumCpp.extremeValue(a, b)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing f', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    dofN = np.random.rand() * 10\n    dofD = np.random.rand() * 100\n    r = NumCpp.f(inShape, dofN, dofD)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing f scalar', 'cyan'))\n    r = NumCpp.f(dofN, dofD)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing gamma', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    shape = np.random.rand() * 10\n    scale = np.random.rand() * 100\n    r = NumCpp.gamma(inShape, shape, scale)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing gamma scalar', 'cyan'))\n    r = NumCpp.gamma(shape, scale)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing geometric', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    p = np.random.rand()\n    r = NumCpp.geometric(inShape, p)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing geometric scalar', 'cyan'))\n    r = NumCpp.geometric(p)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing laplace', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    loc = np.random.rand() * 10\n    scale = np.random.rand() * 100\n    r = NumCpp.laplace(inShape, loc, scale)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing laplace scalar', 'cyan'))\n    r = NumCpp.laplace(loc, scale)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing lognormal', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    mean = np.random.randn() * 10\n    sigma = np.random.rand() * 10\n    r = NumCpp.lognormal(inShape, mean, sigma)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing lognormal scalar', 'cyan'))\n    r = NumCpp.lognormal(mean, sigma)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing negativeBinomial', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    n = np.random.randint(1, 100, [1,]).item()\n    p = np.random.rand()\n    r = NumCpp.negativeBinomial(inShape, n, p)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing negativeBinomial scalar', 'cyan'))\n    r = NumCpp.negativeBinomial(n, p)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing nonCentralChiSquared', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    k = np.random.rand() * 10\n    l = np.random.rand() * 100\n    r = NumCpp.nonCentralChiSquared(inShape, k, l)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing nonCentralChiSquared scalar', 'cyan'))\n    r = NumCpp.nonCentralChiSquared(k, l)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing normal', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    mean = np.random.randn() * 10\n    sigma = np.random.rand() * 10\n    r = NumCpp.normal(inShape, mean, sigma)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing normal scalar', 'cyan'))\n    r = NumCpp.normal(mean, sigma)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing permutation scalar', 'cyan'))\n    r = NumCpp.permutationScaler(np.random.randint(1,100, [1,]).item())\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing permutation array', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 10, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    r = NumCpp.permutationArray(cArray)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing poisson', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    mean = np.random.rand() * 10\n    r = NumCpp.poisson(inShape, mean)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing poisson scalar', 'cyan'))\n    r = NumCpp.poisson(mean)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing rand', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    r = NumCpp.rand(inShape)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing rand scalar', 'cyan'))\n    r = NumCpp.rand()\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing randFloat', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    values = np.random.randint(1, 100, [2, ])\n    values.sort()\n    r = NumCpp.randFloat(inShape, values[0].item(), values[1].item() + 1)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing randFloat scalar', 'cyan'))\n    r = NumCpp.randFloat(values[0].item(), values[1].item() + 1)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing randInt', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item() + 1)\n    values = np.random.randint(1, 100, [2, ])\n    values.sort()\n    r = NumCpp.randInt(inShape, values[0].item(), values[1].item())\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing randInt scalar', 'cyan'))\n    r = NumCpp.randInt(values[0].item(), values[1].item() + 1)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing randN', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    r = NumCpp.randN(inShape)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing randN scalar', 'cyan'))\n    r = NumCpp.randN()\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing seed', 'cyan'))\n    NumCpp.seed(np.random.randint(0, 100000, [1,]).item())\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing shuffle array', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2, ])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    cArray = NumCpp.NdArray(shape)\n    data = np.random.randint(1, 10, [shape.rows, shape.cols])\n    cArray.setArray(data)\n    NumCpp.shuffle(cArray)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing standardNormal', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    r = NumCpp.standardNormal(inShape)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing standardNormal scalar', 'cyan'))\n    r = NumCpp.standardNormal()\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing studentT', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    dof = np.random.randint(1, 100, [1, ]).item()\n    r = NumCpp.studentT(inShape, dof)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing studentT scalar', 'cyan'))\n    r = NumCpp.studentT(dof)\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing triangle', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    values = np.random.rand(3)\n    values.sort()\n    r = NumCpp.triangle(inShape, values[0].item(), values[1].item(), values[2].item())\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing triangle scalar', 'cyan'))\n    r = NumCpp.triangle(values[0].item(), values[1].item(), values[2].item())\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing uniform', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    values = np.random.randint(1, 100, [2, ])\n    values.sort()\n    r = NumCpp.uniform(inShape, values[0].item(), values[1].item())\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing uniform scalar', 'cyan'))\n    r = NumCpp.uniform(values[0].item(), values[1].item())\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing uniformOnSphere', 'cyan'))\n    inputs = np.random.randint(1, 100, [2,])\n    r = NumCpp.uniformOnSphere(inputs[0].item(), inputs[1].item())\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing weibull', 'cyan'))\n    shapeInput = np.random.randint(1, 100, [2,])\n    inShape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    inputs = np.random.rand(2)\n    r = NumCpp.weibull(inShape, inputs[0].item(), inputs[1].item())\n    print(colored('\\tPASS', 'green'))\n\n    print(colored('Testing weibull scalar', 'cyan'))\n    r = NumCpp.weibull(inputs[0].item(), inputs[1].item())\n    print(colored('\\tPASS', 'green'))\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestRoots.py,15,"b""import numpy as np\nimport scipy.special as sp\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Roots Module', 'magenta'))\n\n    print(colored('Testing bisection', 'cyan'))\n    root = np.random.randint(-50, 50, [1,]).item()\n    roots = np.array([root, root + np.random.randint(5, 50, [1,]).item()])\n    largestRoot = roots.max().item()\n    rootsC = NumCpp.NdArray(1, roots.size)\n    rootsC.setArray(roots)\n    polyC = NumCpp.Poly1d(rootsC, True)\n    rootC = int(np.round(NumCpp.bisection_roots(polyC, largestRoot - 1, largestRoot + 1)))\n    if rootC == largestRoot:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing brent', 'cyan'))\n    root = np.random.randint(-50, 50, [1,]).item()\n    roots = np.array([root, root + np.random.randint(5, 50, [1,]).item()])\n    largestRoot = roots.max().item()\n    rootsC = NumCpp.NdArray(1, roots.size)\n    rootsC.setArray(roots)\n    polyC = NumCpp.Poly1d(rootsC, True)\n    rootC = int(np.round(NumCpp.brent_roots(polyC, largestRoot - 1, largestRoot + 1)))\n    if rootC == largestRoot:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing dekker', 'cyan'))\n    root = np.random.randint(-50, 50, [1,]).item()\n    roots = np.array([root, root + np.random.randint(5, 50, [1,]).item()])\n    largestRoot = roots.max().item()\n    rootsC = NumCpp.NdArray(1, roots.size)\n    rootsC.setArray(roots)\n    polyC = NumCpp.Poly1d(rootsC, True)\n    rootC = int(np.round(NumCpp.dekker_roots(polyC, largestRoot - 1, largestRoot + 1)))\n    if rootC == largestRoot:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing newton', 'cyan'))\n    root = np.random.randint(-50, 50, [1,]).item()\n    roots = np.array([root, root + np.random.randint(5, 50, [1,]).item()])\n    largestRoot = roots.max().item()\n    rootsC = NumCpp.NdArray(1, roots.size)\n    rootsC.setArray(roots)\n    polyC = NumCpp.Poly1d(rootsC, True)\n    rootC = int(np.round(NumCpp.newton_roots(polyC, largestRoot)))\n    if rootC == largestRoot:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing secant', 'cyan'))\n    root = np.random.randint(-50, 50, [1,]).item()\n    roots = np.array([root, root + np.random.randint(5, 50, [1,]).item()])\n    largestRoot = roots.max().item()\n    rootsC = NumCpp.NdArray(1, roots.size)\n    rootsC.setArray(roots)\n    polyC = NumCpp.Poly1d(rootsC, True)\n    rootC = int(np.round(NumCpp.secant_roots(polyC, largestRoot - 1, largestRoot + 1)))\n    if rootC == largestRoot:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestRotations.py,148,"b'import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == \'linux\':\n    sys.path.append(r\'../lib\')\nelse:\n    sys.path.append(os.path.abspath(\'../build/x64/Release\'))\nimport NumCpp\n\n\n####################################################################################\ndef doTest():\n    testQuaternion()\n    testDcm()\n    testFunctions()\n\n\n####################################################################################\ndef testQuaternion():\n    print(colored(\'Testing Rotations Module\', \'magenta\'))\n\n    print(colored(\'Testing Quaternion\', \'magenta\'))\n\n    print(colored(\'Testing Default Constructor\', \'cyan\'))\n    NumCpp.Quaternion()\n    print(colored(\'\\tPASS\', \'green\'))\n\n    print(colored(\'Testing Value Constructor\', \'cyan\'))\n    quat = np.random.randint(1,10, [4,])\n    unitQuat = quat / np.linalg.norm(quat)\n    quat = NumCpp.Quaternion(quat[0].item(), quat[1].item(), quat[2].item(), quat[3].item())\n    if (quat.i() == unitQuat[0].item() and\n        quat.j() == unitQuat[1].item() and\n        quat.k() == unitQuat[2].item() and\n        quat.s() == unitQuat[3].item()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing Array Constructor\', \'cyan\'))\n    quat = np.random.randint(1,10, [4, ])\n    unitQuat = quat / np.linalg.norm(quat)\n    cArray = NumCpp.NdArray(1, 4)\n    cArray.setArray(quat)\n    quat = NumCpp.Quaternion(cArray)\n    if (quat.i() == unitQuat[0].item() and\n        quat.j() == unitQuat[1].item() and\n        quat.k() == unitQuat[2].item() and\n        quat.s() == unitQuat[3].item()):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing roll/pitch/yaw Constructor\', \'cyan\'))\n    roll = np.random.rand(1).item() * np.pi * 2 - np.pi  # [-pi, pi]\n    pitch = np.random.rand(1).item() * np.pi - np.pi / 2  # [-pi/2, pi/2]\n    yaw = np.random.rand(1).item() * np.pi * 2 - np.pi  # [-pi, pi]\n    quat = NumCpp.Quaternion(roll, pitch, yaw)\n    if (np.round(quat.roll(), 10) == np.round(roll, 10) and\n            np.round(quat.pitch(), 10) == np.round(pitch, 10) and\n            np.round(quat.yaw(), 10) == np.round(yaw, 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing angleAxisRotationArray\', \'cyan\'))\n    axis = np.random.randint(1,10, [3,])\n    angle = np.random.rand(1).item() * np.pi\n    cAxis = NumCpp.NdArray(1, 3)\n    cAxis.setArray(axis)\n    if np.array_equal(np.round(NumCpp.Quaternion.angleAxisRotationNdArray(cAxis, angle).flatten(), 10),\n                      np.round(quatRotateAngleAxis(axis, angle), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing angleAxisRotationVec3\', \'cyan\'))\n    axis = np.random.randint(1,10, [3,])\n    angle = np.random.rand(1).item() * np.pi\n    cAxis = NumCpp.NdArray(1, 3)\n    cAxis.setArray(axis)\n    if np.array_equal(np.round(NumCpp.Quaternion.angleAxisRotationVec3(cAxis, angle).flatten(), 10),\n                      np.round(quatRotateAngleAxis(axis, angle), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing angularVelocity\', \'cyan\'))\n    time = np.abs(np.random.randn(1) * 5).item()\n    x1 = np.random.rand(3, 1).flatten()\n    x1 = x1 / np.linalg.norm(x1)\n    x2 = np.random.rand(3, 1).flatten()\n    x2 = x2 / np.linalg.norm(x2)\n\n    theta0 = np.random.rand(1).item() * 2 * np.pi\n    theta = np.arccos(np.dot(x1, x2))\n    theta1 = theta0 + theta\n    cross = np.cross(x1, x2)\n    cross = cross / np.linalg.norm(cross)\n    cCross = NumCpp.NdArray(3, 1)\n    cCross.setArray(np.reshape(cross,[3,1]))\n\n    q0 = np.asarray([cross[0] * np.sin(theta0 / 2), cross[1] * np.sin(theta0 / 2), cross[2] * np.sin(theta0 / 2), np.cos(theta0 / 2)])\n    q1 = np.asarray([cross[0] * np.sin(theta1 / 2), cross[1] * np.sin(theta1 / 2), cross[2] * np.sin(theta1 / 2), np.cos(theta1 / 2)])\n    quat0 = NumCpp.Quaternion(q0[0], q0[1], q0[2], q0[3])\n    quat1 = NumCpp.Quaternion(q1[0], q1[1], q1[2], q1[3])\n    crossTo = quat0.rotateNdArray(cCross).flatten()\n\n    w = quat0.angularVelocity(quat1, time).flatten()\n    angularVelocity = np.linalg.norm(w)\n    axis = w / angularVelocity\n\n    # round to 1 decimal place because C is an approximation on magnitude\n    if (np.round(angularVelocity * time - theta, 1) == 0 and\n        np.all(np.round(axis, 9) == np.round(crossTo, 9))):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing conjugate\', \'cyan\'))\n    quat = np.random.randint(1,10, [4,])\n    unitQuat = quat / np.linalg.norm(quat)\n    cArray = NumCpp.NdArray(1, 4)\n    cArray.setArray(quat)\n    quat = NumCpp.Quaternion(cArray)\n    conjQuat = quat.conjugate()\n    if (np.round(conjQuat.i(), 10) == np.round(-unitQuat[0].item(), 10) and\n        np.round(conjQuat.j(), 10) == np.round(-unitQuat[1].item(), 10) and\n        np.round(conjQuat.k(), 10) == np.round(-unitQuat[2].item(), 10) and\n        np.round(conjQuat.s(), 10) == np.round(unitQuat[3].item(), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing fromDCM\', \'cyan\'))\n    quat = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat = NumCpp.Quaternion(quat[0].item(), quat[1].item(), quat[2].item(), quat[3].item())\n    dcm = cQuat.toDCM()\n    cArray = NumCpp.NdArray(3)\n    cArray.setArray(dcm)\n    if np.array_equal(np.round(NumCpp.Quaternion(cArray).toNdArray().getNumpyArray().flatten(), 10),\n                      np.round(quat / quatNorm(quat), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing identity\', \'cyan\'))\n    quat = NumCpp.Quaternion.identity()\n    if quat.i() == 0 and quat.j() == 0 and quat.k() == 0 and quat.s() == 1:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing inverse\', \'cyan\'))\n    quat = np.random.randint(1,10, [4,])\n    unitQuat = quat / np.linalg.norm(quat)\n    cArray = NumCpp.NdArray(1, 4)\n    cArray.setArray(quat)\n    quat = NumCpp.Quaternion(cArray)\n    conjQuat = quat.inverse()\n    if (np.round(conjQuat.i(), 10) == np.round(-unitQuat[0].item(), 10) and\n        np.round(conjQuat.j(), 10) == np.round(-unitQuat[1].item(), 10) and\n        np.round(conjQuat.k(), 10) == np.round(-unitQuat[2].item(), 10) and\n        np.round(conjQuat.s(), 10) == np.round(unitQuat[3].item(), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing nlerp\', \'cyan\'))\n    myQuat1 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    myQuat2 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat1 = NumCpp.Quaternion(myQuat1[0].item(), myQuat1[1].item(), myQuat1[2].item(), myQuat1[3].item())\n    cQuat2 = NumCpp.Quaternion(myQuat2[0].item(), myQuat2[1].item(), myQuat2[2].item(), myQuat2[3].item())\n    t = np.random.rand(1).item()\n    interpQuat = cQuat1.nlerp(cQuat2, t).flatten()\n    if np.array_equal(np.round(interpQuat, 10), np.round(nlerp(myQuat1, myQuat2, t), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing print\', \'cyan\'))\n    cQuat1.print()\n    print(colored(\'\\tPASS\', \'green\'))\n\n    print(colored(\'Testing rotateNdArray\', \'cyan\'))\n    myQuat = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat = NumCpp.Quaternion(myQuat[0].item(), myQuat[1].item(), myQuat[2].item(), myQuat[3].item())\n    vec = np.random.rand(3, 1) * 10\n    cVec = NumCpp.NdArray(3, 1)\n    cVec.setArray(vec)\n    newVec = cQuat.rotateNdArray(cVec)\n    newVecPy = np.asarray(np.matrix(cQuat.toDCM()) * np.matrix(vec))\n    if np.array_equal(np.round(newVec.flatten(), 10), np.round(newVecPy.flatten(), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing rotateVec3\', \'cyan\'))\n    myQuat = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat = NumCpp.Quaternion(myQuat[0].item(), myQuat[1].item(), myQuat[2].item(), myQuat[3].item())\n    vec = np.random.rand(3, 1) * 10\n    cVec = NumCpp.NdArray(3, 1)\n    cVec.setArray(vec)\n    newVec = cQuat.rotateVec3(cVec)\n    newVecPy = np.asarray(np.matrix(cQuat.toDCM()) * np.matrix(vec))\n    if np.array_equal(np.round(newVec.flatten(), 10), np.round(newVecPy.flatten(), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing slerp\', \'cyan\'))\n    myQuat1 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    myQuat2 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat1 = NumCpp.Quaternion(myQuat1[0].item(), myQuat1[1].item(), myQuat1[2].item(), myQuat1[3].item())\n    cQuat2 = NumCpp.Quaternion(myQuat2[0].item(), myQuat2[1].item(), myQuat2[2].item(), myQuat2[3].item())\n    t = np.random.rand(1).item()\n    interpQuatSlerp = cQuat1.slerp(cQuat2, t).flatten()\n    interpQuatNlerp = cQuat1.nlerp(cQuat2, t).flatten()\n    if np.array_equal(np.round(interpQuatSlerp, 1), np.round(interpQuatNlerp, 1)): # not a very good check but i don\'t feel like coding slerp in python\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing toDCM\', \'cyan\'))\n    quat = np.random.randint(1, 5, [4, ]).astype(np.double)\n    unitQuat = quat / quatNorm(quat)\n    cQuat = NumCpp.Quaternion(quat[0].item(), quat[1].item(), quat[2].item(), quat[3].item())\n    dcmPy = quat2dcm(unitQuat)\n    dcm = cQuat.toDCM()\n    if np.array_equal(np.round(dcm, 10), np.round(dcmPy, 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing X Rotation\', \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    quat = NumCpp.Quaternion.xRotation(radians.item()).toNdArray().getNumpyArray().flatten()\n    if np.array_equal(np.round(quat, 10), np.round(quatRotateX(radians.item()), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing Y Rotation\', \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    quat = NumCpp.Quaternion.yRotation(radians.item()).toNdArray().getNumpyArray().flatten()\n    if np.array_equal(np.round(quat, 10), np.round(quatRotateY(radians.item()), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing Z Rotation\', \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    quat = NumCpp.Quaternion.zRotation(radians.item()).toNdArray().getNumpyArray().flatten()\n    if np.array_equal(np.round(quat, 10), np.round(quatRotateZ(radians.item()), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing ==\', \'cyan\'))\n    quat1 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat1 = NumCpp.Quaternion(quat1[0].item(), quat1[1].item(), quat1[2].item(), quat1[3].item())\n    cQuat2 = NumCpp.Quaternion(quat1[0].item(), quat1[1].item(), quat1[2].item(), quat1[3].item())\n    if cQuat1 == cQuat2:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing !=\', \'cyan\'))\n    quat1 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    quat2 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat1 = NumCpp.Quaternion(quat1[0].item(), quat1[1].item(), quat1[2].item(), quat1[3].item())\n    cQuat2 = NumCpp.Quaternion(quat2[0].item(), quat2[1].item(), quat2[2].item(), quat2[3].item())\n    if cQuat1 != cQuat2:\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing addition\', \'cyan\'))\n    quat1 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    quat2 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat1 = NumCpp.Quaternion(quat1[0].item(), quat1[1].item(), quat1[2].item(), quat1[3].item())\n    cQuat2 = NumCpp.Quaternion(quat2[0].item(), quat2[1].item(), quat2[2].item(), quat2[3].item())\n    resPy = quatAdd(quat1, quat2)\n    res = cQuat1 + cQuat2\n    if np.array_equal(np.round(res.toNdArray().getNumpyArray().flatten(), 10), np.round(resPy, 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing subtraction\', \'cyan\'))\n    quat1 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    quat2 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat1 = NumCpp.Quaternion(quat1[0].item(), quat1[1].item(), quat1[2].item(), quat1[3].item())\n    cQuat2 = NumCpp.Quaternion(quat2[0].item(), quat2[1].item(), quat2[2].item(), quat2[3].item())\n    resPy = quatSub(quat1, quat2)\n    res = cQuat1 - cQuat2\n    if np.array_equal(np.round(res.flatten(), 10), np.round(resPy, 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing negative\', \'cyan\'))\n    quat = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat = NumCpp.Quaternion(quat[0].item(), quat[1].item(), quat[2].item(), quat[3].item())\n    if np.array_equal(np.round((-cQuat).flatten(), 10), np.round(-quat/np.linalg.norm(quat), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing multiplication: Scalar\', \'cyan\'))\n    quat = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat = NumCpp.Quaternion(quat[0].item(), quat[1].item(), quat[2].item(), quat[3].item())\n    res = cQuat * -1\n    if np.array_equal(np.round(res.flatten(), 10), np.round(-quat / quatNorm(quat), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing multiplication: Quaternion\', \'cyan\'))\n    quat1 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    quat2 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat1 = NumCpp.Quaternion(quat1[0].item(), quat1[1].item(), quat1[2].item(), quat1[3].item())\n    cQuat2 = NumCpp.Quaternion(quat2[0].item(), quat2[1].item(), quat2[2].item(), quat2[3].item())\n    resPy = quatMult(quat1, quat2)\n    res = cQuat1 * cQuat2\n    if np.array_equal(np.round(res.flatten(), 10), np.round(resPy, 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing multiplication: Array\', \'cyan\'))\n    quat = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat = NumCpp.Quaternion(quat[0].item(), quat[1].item(), quat[2].item(), quat[3].item())\n    array = np.random.randint(1, 5, [3, 1])\n    cArray = NumCpp.NdArray(3, 1)\n    cArray.setArray(array)\n    res = cQuat * cArray\n    if np.array_equal(np.round(res.flatten(), 10), np.round(np.dot(cQuat.toDCM(), array).flatten(), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing division\', \'cyan\'))\n    quat1 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    quat2 = np.random.randint(1, 5, [4, ]).astype(np.double)\n    cQuat1 = NumCpp.Quaternion(quat1[0].item(), quat1[1].item(), quat1[2].item(), quat1[3].item())\n    cQuat2 = NumCpp.Quaternion(quat2[0].item(), quat2[1].item(), quat2[2].item(), quat2[3].item())\n    resPy = quatDiv(quat1, quat2)\n    res = cQuat1 / cQuat2\n    if np.array_equal(np.round(res.toNdArray().getNumpyArray().flatten(), 10), np.round(resPy, 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n\n####################################################################################\ndef testDcm():\n    print(colored(\'Testing DCM\', \'magenta\'))\n\n    print(colored(\'Testing angleAxisRotationNdArray\', \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    axis = np.random.rand(3)\n    cAxis = NumCpp.NdArray(1, 3)\n    cAxis.setArray(axis)\n    rot = NumCpp.DCM.angleAxisRotationNdArray(cAxis, radians.item())\n    if np.all(np.round(rot, 10) == np.round(angleAxisRotation(axis, radians.item()), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing angleAxisRotationVec3\', \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    axis = np.random.rand(3)\n    cAxis = NumCpp.NdArray(1, 3)\n    cAxis.setArray(axis)\n    rot = NumCpp.DCM.angleAxisRotationVec3(cAxis, radians.item())\n    if np.all(np.round(rot, 10) == np.round(angleAxisRotation(axis, radians.item()), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing isValidDCM\', \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    rot = NumCpp.DCM.xRotation(radians.item()).getNumpyArray()\n    cArray = NumCpp.NdArray(3)\n    cArray.setArray(rot)\n    if NumCpp.DCM.isValid(cArray):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing xRotationDCM\', \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    rot = NumCpp.DCM.xRotation(radians.item()).getNumpyArray()\n    if np.all(np.round(rot, 10) == np.round(rotateX(radians.item()), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing yRotationDCM\', \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    rot = NumCpp.DCM.yRotation(radians.item()).getNumpyArray()\n    if np.all(np.round(rot, 10) == np.round(rotateY(radians.item()), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(\'Testing zRotationDCM\', \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    rot = NumCpp.DCM.zRotation(radians.item()).getNumpyArray()\n    if np.all(np.round(rot, 10) == np.round(rotateZ(radians.item()), 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n\n####################################################################################\ndef testFunctions():\n    print(colored(\'Testing Functions\', \'magenta\'))\n\n    print(colored(\'Testing rodriques rotation\', \'cyan\'))\n    k = np.random.randint(1, 5, [3, 1]).astype(np.double)\n    v = np.random.randint(1, 5, [3, 1]).astype(np.double)\n    theta = np.random.rand(1).item() * np.pi * 2\n    vec = NumCpp.rodriguesRotation(k, theta, v).flatten()\n\n    dcm = angleAxisRotation(k, theta)\n    vecPy = dcm.dot(v).flatten()\n\n    if np.array_equal(np.round(vec, 10), np.round(vecPy, 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(""Testing Wahba\'s Problem"", \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    axis = np.random.rand(3)\n    cAxis = NumCpp.NdArray(1, 3)\n    cAxis.setArray(axis)\n    rot = NumCpp.DCM.angleAxisRotationNdArray(cAxis, radians.item())\n\n    vecBody = list()\n    vecInertial = list()\n    for _ in range(1000):\n        vec = np.random.randint(1, 100, [3, 1])\n        vec = vec / np.linalg.norm(vec)\n        vecBody.append(vec.flatten())\n\n        vecInertial.append(rot.dot(vec).flatten())\n\n    vecBody = np.array(vecBody)\n    vecInertial = np.array(vecInertial)\n\n    rotWahba = NumCpp.wahbasProblem(vecInertial, vecBody)\n\n    if np.array_equal(np.round(rotWahba, 10), np.round(rot, 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n    print(colored(""Testing Wahba\'s Problem weigted"", \'cyan\'))\n    radians = np.random.rand(1) * 2 * np.pi\n    axis = np.random.rand(3)\n    cAxis = NumCpp.NdArray(1, 3)\n    cAxis.setArray(axis)\n    rot = NumCpp.DCM.angleAxisRotationNdArray(cAxis, radians.item())\n\n    vecBody = list()\n    vecInertial = list()\n    for _ in range(1000):\n        vec = np.random.randint(1, 100, [3, 1])\n        vec = vec / np.linalg.norm(vec)\n        vecBody.append(vec.flatten())\n\n        vecInertial.append(rot.dot(vec).flatten())\n\n    vecBody = np.array(vecBody)\n    vecInertial = np.array(vecInertial)\n\n    weights = np.random.randint(1, 100) * np.ones([vecBody.shape[0]])  # all the same weight for simplicity...\n\n    rotWahba = NumCpp.wahbasProblemWeighted(vecInertial, vecBody, weights)\n\n    if np.array_equal(np.round(rotWahba, 10), np.round(rot, 10)):\n        print(colored(\'\\tPASS\', \'green\'))\n    else:\n        print(colored(\'\\tFAIL\', \'red\'))\n\n########################################################################################################################\ndef quatNorm(quat):\n    return np.linalg.norm(quat)\n\n\n########################################################################################################################\ndef dcm2quat(dcm):\n    # http://www.vectornav.com/docs/default-source/documentation/vn-100-documentation/AN002.pdf?sfvrsn=19ee6b9_10\n\n    q3 = 0.5 * np.sqrt(dcm[0, 0] + dcm[1, 1] + dcm[2, 2] + 1)\n    q0 = (dcm[1, 2] - dcm[2, 1]) / (4 * q3)\n    q1 = (dcm[2, 0] - dcm[0, 2]) / (4 * q3)\n    q2 = (dcm[0, 1] - dcm[1, 0]) / (4 * q3)\n\n    quat = np.asarray([q0, q1, q2, q3])\n    quat = quat / np.linalg.norm(quat)\n\n    return quat\n\n\n########################################################################################################################\ndef quat2dcm(quat):\n    # http://www.vectornav.com/docs/default-source/documentation/vn-100-documentation/AN002.pdf?sfvrsn=19ee6b9_10\n\n    q0 = quat[0]\n    q1 = quat[1]\n    q2 = quat[2]\n    q3 = quat[3]\n\n    dcm = np.zeros([3, 3])\n    dcm[0, 0] = q3**2 + q0**2 - q1**2 - q2**2\n    dcm[0, 1] = 2 * (q0 * q1 - q3 * q2)\n    dcm[0, 2] = 2 * (q0 * q2 + q3 * q1)\n    dcm[1, 0] = 2 * (q0 * q1 + q3 * q2)\n    dcm[1, 1] = q3**2 - q0**2 + q1**2 - q2**2\n    dcm[1, 2] = 2 * (q1 * q2 - q3 * q0)\n    dcm[2, 0] = 2 * (q0 * q2 - q3 * q1)\n    dcm[2, 1] = 2 * (q1 * q2 + q3 * q0)\n    dcm[2, 2] = q3**2 - q0**2 - q1**2 + q2**2\n\n    return dcm\n\n\n########################################################################################################################\ndef quatAdd(quat1, quat2):\n    quat = quat1 / quatNorm(quat1) + quat2 / quatNorm(quat2)\n    return quat / np.linalg.norm(quat)\n\n\n########################################################################################################################\ndef quatSub(quat1, quat2):\n    quat = quat1 / quatNorm(quat1) - quat2 / quatNorm(quat2)\n    return quat / np.linalg.norm(quat)\n\n\n########################################################################################################################\ndef quatMult(quat1, quat2):\n    quat1N = quat1 / np.linalg.norm(quat1)\n    quat2N = quat2 / np.linalg.norm(quat2)\n\n    q0 = quat2N[3] * quat1N[0] + quat2N[0] * quat1N[3] - quat2N[1] * quat1N[2] + quat2N[2] * quat1N[1]\n    q1 = quat2N[3] * quat1N[1] + quat2N[0] * quat1N[2] + quat2N[1] * quat1N[3] - quat2N[2] * quat1N[0]\n    q2 = quat2N[3] * quat1N[2] - quat2N[0] * quat1N[1] + quat2N[1] * quat1N[0] + quat2N[2] * quat1N[3]\n    q3 = quat2N[3] * quat1N[3] - quat2N[0] * quat1N[0] - quat2N[1] * quat1N[1] - quat2N[2] * quat1N[2]\n\n    quat = np.asarray([q0, q1, q2, q3])\n    return quat / np.linalg.norm(quat)\n\n\n########################################################################################################################\ndef quatDiv(quat1, quat2):\n    quat2Inv = -quat2\n    quat2Inv[-1] *= -1\n    return quatMult(quat1, quat2Inv)\n\n\n########################################################################################################################\ndef nlerp(quat1, quat2, inT):\n    quat1 = quat1 / np.linalg.norm(quat1)\n    quat2 = quat2 / np.linalg.norm(quat2)\n\n    oneMinusT = 1 - inT\n\n    outQuat = np.zeros([4,])\n\n    outQuat[0] = oneMinusT * quat1[0] + inT * quat2[0]\n    outQuat[1] = oneMinusT * quat1[1] + inT * quat2[1]\n    outQuat[2] = oneMinusT * quat1[2] + inT * quat2[2]\n    outQuat[3] = oneMinusT * quat1[3] + inT * quat2[3]\n\n    outQuat = outQuat / np.linalg.norm(outQuat)\n\n    return outQuat\n\n\n########################################################################################################################\ndef quatRotateAngleAxis(axis, radians):\n    axis = axis / np.linalg.norm(axis)\n    halfRadians = radians / 2\n    quat = np.asarray([axis[0] * np.sin(halfRadians), axis[1] * np.sin(halfRadians), axis[2] * np.sin(halfRadians), np.cos(halfRadians)])\n    return quat / np.linalg.norm(quat)\n\n\n########################################################################################################################\ndef quatRotateX(radians):\n    return quatRotateAngleAxis([1,0,0], radians)\n\n\n########################################################################################################################\ndef quatRotateY(radians):\n    return quatRotateAngleAxis([0,1,0], radians)\n\n\n########################################################################################################################\ndef quatRotateZ(radians):\n    return quatRotateAngleAxis([0,0,1], radians)\n\n\n########################################################################################################################\ndef angleAxisRotation(axis, radians):\n    return quat2dcm(quatRotateAngleAxis(axis, radians))\n\n\n########################################################################################################################\ndef rotateX(radians):\n    return np.matrix([[1, 0, 0],[0, np.cos(radians), -np.sin(radians)],[0, np.sin(radians), np.cos(radians)]])\n\n\n########################################################################################################################\ndef rotateY(radians):\n    return np.matrix([[np.cos(radians), 0, np.sin(radians)],[0, 1, 0],[-np.sin(radians), 0, np.cos(radians)]])\n\n\n########################################################################################################################\ndef rotateZ(radians):\n    return np.matrix([[np.cos(radians), -np.sin(radians), 0],[np.sin(radians), np.cos(radians), 0],[0, 0, 1]])\n\n\n########################################################################################################################\ndef hat(xyz):\n    return np.asarray([[0, -xyz[2], xyz[1]], [xyz[2], 0, -xyz[0]], [-xyz[1], xyz[0], 0]])\n\n\n####################################################################################\nif __name__ == \'__main__\':\n    doTest()\n\n\n\n\n\n'"
unitTests/testScripts/TestShape.py,3,"b""import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Shape Class', 'magenta'))\n\n    print(colored('Testing Default Constructor', 'cyan'))\n    shape = NumCpp.Shape()\n    if shape.rows == 0 and shape.cols == 0:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Square Constructor', 'cyan'))\n    shapeInput = np.random.randint(0, 100, [1,]).item()\n    shape = NumCpp.Shape(shapeInput)\n    if shape.rows == shapeInput and shape.cols == shapeInput:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Rectangle Constructor', 'cyan'))\n    shapeInput = np.random.randint(0, 100, [2,])\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\n    if shape.rows == shapeInput[0] and shape.cols == shapeInput[1]:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Copy Constructor', 'cyan'))\n    shape2 = NumCpp.Shape(shape)\n    if shape2.rows == shape.rows and shape2.cols == shape.cols:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Member Setting', 'cyan'))\n    shape = NumCpp.Shape()\n    shapeInput = np.random.randint(0, 100, [2, ])\n    shape.rows = shapeInput[0].item()\n    shape.cols = shapeInput[1].item()\n    if shape.rows == shapeInput[0] and shape.cols == shapeInput[1]:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Print', 'cyan'))\n    shape.print()\n    print(colored('\\tPASS', 'green'))\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestSlice.py,9,"b""import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Slice Class', 'magenta'))\n\n    print(colored('Testing Default Constructor', 'cyan'))\n    cSlice = NumCpp.Slice()\n    if cSlice.start == 0 and cSlice.stop == 1 and cSlice.step == 1:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Stop Only Constructor', 'cyan'))\n    stop = np.random.randint(0, 100, [1,]).item()\n    cSlice = NumCpp.Slice(stop)\n    if cSlice.start == 0 and cSlice.stop == stop and cSlice.step == 1:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Start/Stop Constructor', 'cyan'))\n    start = np.random.randint(0, 100, [1,]).item()\n    stop = np.random.randint(100, 200, [1,]).item()\n    cSlice = NumCpp.Slice(start, stop)\n    if cSlice.start == start and cSlice.stop == stop and cSlice.step == 1:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Start/Stop/Step Constructor', 'cyan'))\n    start = np.random.randint(0, 100, [1,]).item()\n    stop = np.random.randint(100, 200, [1,]).item()\n    step = np.random.randint(0, 50, [1, ]).item()\n    cSlice = NumCpp.Slice(start, stop, step)\n    if cSlice.start == start and cSlice.stop == stop and cSlice.step == step:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Copy Constructor', 'cyan'))\n    cSlice2 = NumCpp.Slice(cSlice)\n    if cSlice2.start == cSlice.start and cSlice2.stop == cSlice.stop and cSlice2.step == cSlice.step:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing Setting members', 'cyan'))\n    start = np.random.randint(0, 100, [1,]).item()\n    stop = np.random.randint(100, 200, [1,]).item()\n    step = np.random.randint(0, 50, [1, ]).item()\n    cSlice = NumCpp.Slice()\n    cSlice.start = start\n    cSlice.stop = stop\n    cSlice.step = step\n    if cSlice.start == start and cSlice.stop == stop and cSlice.step == step:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    print(colored('Testing print', 'cyan'))\n    cSlice.print()\n    print(colored('\\tPASS', 'green'))\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestSpecial.py,158,"b""import numpy as np\r\nimport scipy.special as sp\r\nfrom termcolor import colored\r\nimport os\r\nimport sys\r\nif sys.platform == 'linux':\r\n    sys.path.append(r'../lib')\r\nelse:\r\n    sys.path.append(os.path.abspath('../build/x64/Release'))\r\nimport NumCpp\r\n\r\n\r\nNUM_DECIMALS_ROUND = 7\r\n\r\n\r\n####################################################################################\r\ndef doTest():\r\n    print(colored('Testing Special Module', 'magenta'))\r\n\r\n    print(colored('Testing airy_ai scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.airy_ai_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.airy(value)[0].item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing airy_ai array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.airy_ai_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.airy(data)[0], NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing airy_ai_prime scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.airy_ai_prime_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.airy(value)[1].item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing airy_ai_prime array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.airy_ai_prime_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.airy(data)[1], NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing airy_bi scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.airy_bi_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.airy(value)[2].item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing airy_bi array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.airy_bi_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.airy(data)[2], NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing airy_bi_prime scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.airy_bi_prime_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.airy(value)[3].item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing airy_bi_prime array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.airy_bi_prime_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.airy(data)[3], NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bernoulli scaler', 'cyan'))\r\n    value = np.random.randint(0, 20)\r\n    if (roundScaler(NumCpp.bernoulli_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.bernoulli(value)[-1], NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_in scaler', 'cyan'))\r\n    order = np.random.randint(0, 10)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.bessel_in_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.iv(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_in array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 10)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.bessel_in_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.iv(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_in_prime scaler', 'cyan'))\r\n    order = np.random.randint(0, 10)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.bessel_in_prime_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.ivp(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_in_prime array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 10)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.bessel_in_prime_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.ivp(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_jn scaler', 'cyan'))\r\n    order = np.random.randint(0, 10)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.bessel_jn_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.jv(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_jn array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 10)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.bessel_jn_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.jv(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_jn_prime scaler', 'cyan'))\r\n    order = np.random.randint(0, 10)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.bessel_jn_prime_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.jvp(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_jn_prime array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 10)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.bessel_jn_prime_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.jvp(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_kn scaler', 'cyan'))\r\n    order = np.random.randint(0, 10)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.bessel_kn_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.kn(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_kn array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 5)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.bessel_kn_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.kn(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_kn_prime scaler', 'cyan'))\r\n    order = np.random.randint(0, 5)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.bessel_kn_prime_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.kvp(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_kn_prime array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 5)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.bessel_kn_prime_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.kvp(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_yn scaler', 'cyan'))\r\n    order = np.random.randint(0, 5)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.bessel_yn_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.yn(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_yn array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 5)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.bessel_yn_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.yn(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_yn_prime scaler', 'cyan'))\r\n    order = np.random.randint(0, 5)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.bessel_yn_prime_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.yvp(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing bessel_yn_prime array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 5)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.bessel_yn_prime_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.yvp(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing beta scaler', 'cyan'))\r\n    a = np.random.rand(1).item() * 10\r\n    b = np.random.rand(1).item() * 10\r\n    if (roundScaler(NumCpp.beta_Scaler(a, b), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.beta(a, b).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing beta array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    aArray = NumCpp.NdArray(shape)\r\n    bArray = NumCpp.NdArray(shape)\r\n    a = np.random.rand(shape.rows, shape.cols) * 10\r\n    b = np.random.rand(shape.rows, shape.cols) * 10\r\n    aArray.setArray(a)\r\n    bArray.setArray(b)\r\n    if np.array_equal(roundArray(NumCpp.beta_Array(aArray, bArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.beta(a, b), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cnr', 'cyan'))\r\n    n = np.random.randint(0, 50)\r\n    r = np.random.randint(0, n + 1)\r\n    if round(NumCpp.cnr(n, r)) == round(sp.comb(n, r)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cyclic_hankel_1', 'cyan'))\r\n    order = np.random.randint(0, 6)\r\n    value = np.random.rand(1).item() * 10\r\n    if (roundComplex(complex(NumCpp.cyclic_hankel_1(order, value)), NUM_DECIMALS_ROUND) ==\r\n            roundComplex(sp.hankel1(order, value), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cyclic_hankel_2', 'cyan'))\r\n    order = np.random.randint(0, 6)\r\n    value = np.random.rand(1).item() * 10\r\n    if (roundComplex(complex(NumCpp.cyclic_hankel_2(order, value)), NUM_DECIMALS_ROUND) ==\r\n            roundComplex(sp.hankel2(order, value), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing digamma scaler', 'cyan'))\r\n    value = np.random.rand(1).item() * 10\r\n    if (roundScaler(NumCpp.digamma_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.digamma(value), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing digamma array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols) * 10\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.digamma_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.digamma(data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing erf scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.erf_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.erf(value), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing erf array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.erf_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.erf(data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing erf_inv scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.erf_inv_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.erfinv(value), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing erf_inv array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.erf_inv_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.erfinv(data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing erfc scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.erfc_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.erfc(value), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing erfc array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.erfc_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.erfc(data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing erfc_inv scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.erfc_inv_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.erfcinv(value), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing erfc_inv array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.erfc_inv_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.erfcinv(data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing factorial scaler', 'cyan'))\r\n    n = np.random.randint(0, 170)\r\n    if (roundScaler(NumCpp.factorial_Scaler(n), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.factorial(n).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing factorial array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayUInt32(shape)\r\n    data = np.random.randint(0, 170, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.factorial_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.factorial(data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing gamma scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.gamma_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.gamma(value), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing gamma array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.gamma_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.gamma(data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    # There is no scipy equivalent to this function\r\n    print(colored('Testing gamma1pm1 scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    answer = NumCpp.gamma1pm1_Scaler(value)\r\n    print(colored('\\tPASS', 'green'))\r\n\r\n    print(colored('Testing gamma1pm1 array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    answer = NumCpp.gamma1pm1_Array(cArray)\r\n    print(colored('\\tPASS', 'green'))\r\n\r\n    print(colored('Testing log_gamma scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.log_gamma_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.loggamma(value), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing log_gamma array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.log_gamma_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.loggamma(data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing pnr', 'cyan'))\r\n    n = np.random.randint(0, 10)\r\n    r = np.random.randint(0, n + 1)\r\n    if round(NumCpp.pnr(n, r)) == round(sp.perm(n, r)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing polygamma scaler', 'cyan'))\r\n    order = np.random.randint(1, 5)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.polygamma_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.polygamma(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing polygamma array', 'cyan'))\r\n    order = np.random.randint(1, 5)\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.polygamma_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.polygamma(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    # There is no scipy equivalent to this function\r\n    print(colored('Testing prime scaler', 'cyan'))\r\n    value = np.random.randint(10000)\r\n    answer = NumCpp.prime_Scaler(value)\r\n    print(colored('\\tPASS', 'green'))\r\n\r\n    print(colored('Testing prime array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArrayUInt32(shape)\r\n    data = np.random.randint(0, 10000, [shape.rows, shape.cols])\r\n    cArray.setArray(data)\r\n    answer = NumCpp.prime_Array(cArray)\r\n    print(colored('\\tPASS', 'green'))\r\n\r\n    print(colored('Testing riemann_zeta scaler', 'cyan'))\r\n    value = np.random.rand(1).item() * 5 + 1\r\n    if (roundScaler(NumCpp.riemann_zeta_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.zeta(value, 1).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing riemann_zeta array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols) * 5 + 1\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.riemann_zeta_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.zeta(data, 1), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing softmax Axis::None', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.softmax(cArray, NumCpp.Axis.NONE), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.softmax(data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing softmax Axis::ROW', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.softmax(cArray, NumCpp.Axis.ROW), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.softmax(data, axis=0), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing softmax Axis::COL', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.softmax(cArray, NumCpp.Axis.COL), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.softmax(data, axis=1), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing spherical_bessel_jn scaler', 'cyan'))\r\n    order = np.random.randint(0, 10)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.spherical_bessel_jn_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.spherical_jn(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing spherical_bessel_jn array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 10)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.spherical_bessel_jn_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.spherical_jn(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing spherical_bessel_yn scaler', 'cyan'))\r\n    order = np.random.randint(0, 10)\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.spherical_bessel_yn_Scaler(order, value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.spherical_yn(order, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing spherical_bessel_yn array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    order = np.random.randint(0, 10)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.spherical_bessel_yn_Array(order, cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.spherical_yn(order, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    # There is no equivalent scipy functions\r\n    print(colored('Testing spherical_hankel_1 scaler', 'cyan'))\r\n    order = np.random.randint(0, 10)\r\n    value = np.random.rand(1).item()\r\n    result = NumCpp.spherical_hankel_1(order, value)\r\n    print(colored('\\tPASS', 'green'))\r\n\r\n    print(colored('Testing spherical_hankel_2 scaler', 'cyan'))\r\n    order = np.random.randint(0, 10)\r\n    value = np.random.rand(1).item()\r\n    result = NumCpp.spherical_hankel_2(order, value)\r\n    print(colored('\\tPASS', 'green'))\r\n\r\n    print(colored('Testing trigamma scaler', 'cyan'))\r\n    value = np.random.rand(1).item()\r\n    if (roundScaler(NumCpp.trigamma_Scaler(value), NUM_DECIMALS_ROUND) ==\r\n            roundScaler(sp.polygamma(1, value).item(), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing trigamma array', 'cyan'))\r\n    shapeInput = np.random.randint(20, 100, [2, ])\r\n    shape = NumCpp.Shape(shapeInput[0].item(), shapeInput[1].item())\r\n    cArray = NumCpp.NdArray(shape)\r\n    data = np.random.rand(shape.rows, shape.cols)\r\n    cArray.setArray(data)\r\n    if np.array_equal(roundArray(NumCpp.trigamma_Array(cArray), NUM_DECIMALS_ROUND),\r\n                      roundArray(sp.polygamma(1, data), NUM_DECIMALS_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n\r\n####################################################################################\r\ndef roundScaler(value: float, numDecimals: int) -> float:\r\n    return float(f'{{:.{numDecimals}g}}'.format(value))\r\n\r\n\r\n####################################################################################\r\ndef roundArray(values: np.ndarray, numDecimals: int) -> np.ndarray:\r\n    func = np.vectorize(roundScaler)\r\n    return func(values, numDecimals)\r\n\r\n\r\n####################################################################################\r\ndef roundComplex(value: complex, numDecimals: int) -> complex:\r\n    return complex(roundScaler(value.real, numDecimals),\r\n                   roundScaler(value.imag, numDecimals))\r\n\r\n\r\n####################################################################################\r\nif __name__ == '__main__':\r\n    doTest()\r\n"""
unitTests/testScripts/TestTimer.py,4,"b""import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Timer Class', 'magenta'))\n\n    SLEEP_TIME = int(np.random.randint(0, 10, [1, ]).item() * 1e6)  # microseconds\n    print(colored(f'Sleeping for {SLEEP_TIME} microseconds with default Constructor', 'cyan'))\n    timer = NumCpp.Timer()\n    timer.tic()\n    timer.sleep(SLEEP_TIME)\n    elapsedTime = timer.toc(True)  # microseconds\n\n    if np.abs(elapsedTime - SLEEP_TIME) < 0.1e6:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n    SLEEP_TIME = int(np.random.randint(0, 10, [1, ]).item() * 1e6)  # microseconds\n    print(colored(f'Sleeping for {SLEEP_TIME} microseconds with Named Constructor', 'cyan'))\n    timer = NumCpp.Timer('Python Test Case')\n    timer.tic()\n    timer.sleep(SLEEP_TIME)\n    elapsedTime = timer.toc(True)  # microseconds\n\n    if np.abs(elapsedTime - SLEEP_TIME) < 0.1e6:\n        print(colored('\\tPASS', 'green'))\n    else:\n        print(colored('\\tFAIL', 'red'))\n\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestUtils.py,50,"b""import numpy as np\nfrom termcolor import colored\nimport os\nimport sys\nif sys.platform == 'linux':\n    sys.path.append(r'../lib')\nelse:\n    sys.path.append(os.path.abspath('../build/x64/Release'))\nimport NumCpp\n\n####################################################################################\ndef doTest():\n    print(colored('Testing Utils', 'magenta'))\n    print(colored('Testing num2str', 'cyan'))\n    value = np.random.randint(1, 100, [1, ], dtype=np.int8).item()\n    if NumCpp.num2str(value) == str(value):\n        print(colored('\\tPASS int8', 'green'))\n    else:\n        print(colored('\\tFAIL int8', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.int16).item()\n    if NumCpp.num2str(value) == str(value):\n        print(colored('\\tPASS int16', 'green'))\n    else:\n        print(colored('\\tFAIL int16', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.int32).item()\n    if NumCpp.num2str(value) == str(value):\n        print(colored('\\tPASS int32', 'green'))\n    else:\n        print(colored('\\tFAIL int32', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.int64).item()\n    if NumCpp.num2str(value) == str(value):\n        print(colored('\\tPASS int64', 'green'))\n    else:\n        print(colored('\\tFAIL int64', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.uint8).item()\n    if NumCpp.num2str(value) == str(value):\n        print(colored('\\tPASS uint8', 'green'))\n    else:\n        print(colored('\\tFAIL uint8', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.uint16).item()\n    if NumCpp.num2str(value) == str(value):\n        print(colored('\\tPASS uint16', 'green'))\n    else:\n        print(colored('\\tFAIL uint16', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.uint32).item()\n    if NumCpp.num2str(value) == str(value):\n        print(colored('\\tPASS uint32', 'green'))\n    else:\n        print(colored('\\tFAIL uint32', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.uint64).item()\n    if NumCpp.num2str(value) == str(value):\n        print(colored('\\tPASS uint64', 'green'))\n    else:\n        print(colored('\\tFAIL uint64', 'red'))\n\n    print(colored('Testing sqr', 'cyan'))\n    value = np.random.randint(1, 12, [1, ], dtype=np.int8).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS int8', 'green'))\n    else:\n        print(colored('\\tFAIL int8', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.int16).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS int16', 'green'))\n    else:\n        print(colored('\\tFAIL int16', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.int32).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS int32', 'green'))\n    else:\n        print(colored('\\tFAIL int32', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.int64).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS int64', 'green'))\n    else:\n        print(colored('\\tFAIL int64', 'red'))\n\n    value = np.random.randint(1, 15, [1, ], dtype=np.uint8).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS uint8', 'green'))\n    else:\n        print(colored('\\tFAIL uint8', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.uint16).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS uint16', 'green'))\n    else:\n        print(colored('\\tFAIL uint16', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.uint32).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS uint32', 'green'))\n    else:\n        print(colored('\\tFAIL uint32', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.uint64).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS uint64', 'green'))\n    else:\n        print(colored('\\tFAIL uint64', 'red'))\n\n    value = np.random.randint(1, 100, [1, ]).astype(np.double).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS double', 'green'))\n    else:\n        print(colored('\\tFAIL double', 'red'))\n\n    value = np.random.randint(1, 100, [1, ]).astype(np.float32).item()\n    if NumCpp.sqr(value) == value ** 2:\n        print(colored('\\tPASS float', 'green'))\n    else:\n        print(colored('\\tFAIL float', 'red'))\n\n    print(colored('Testing cube', 'cyan'))\n    value = np.random.randint(1, 6, [1, ], dtype=np.int8).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS int8', 'green'))\n    else:\n        print(colored('\\tFAIL int8', 'red'))\n\n    value = np.random.randint(1, 32, [1, ], dtype=np.int16).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS int16', 'green'))\n    else:\n        print(colored('\\tFAIL int16', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.int32).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS int32', 'green'))\n    else:\n        print(colored('\\tFAIL int32', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.int64).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS int64', 'green'))\n    else:\n        print(colored('\\tFAIL int64', 'red'))\n\n    value = np.random.randint(1, 7, [1, ], dtype=np.uint8).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS uint8', 'green'))\n    else:\n        print(colored('\\tFAIL uint8', 'red'))\n\n    value = np.random.randint(1, 41, [1, ], dtype=np.uint16).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS uint16', 'green'))\n    else:\n        print(colored('\\tFAIL uint16', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.uint32).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS uint32', 'green'))\n    else:\n        print(colored('\\tFAIL uint32', 'red'))\n\n    value = np.random.randint(1, 100, [1, ], dtype=np.uint64).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS uint64', 'green'))\n    else:\n        print(colored('\\tFAIL uint64', 'red'))\n\n    value = np.random.randint(1, 100, [1, ]).astype(np.double).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS double', 'green'))\n    else:\n        print(colored('\\tFAIL double', 'red'))\n\n    value = np.random.randint(1, 100, [1, ]).astype(np.float32).item()\n    if NumCpp.cube(value) == value ** 3:\n        print(colored('\\tPASS float', 'green'))\n    else:\n        print(colored('\\tFAIL float', 'red'))\n\n    print(colored('Testing power', 'cyan'))\n    value = np.random.randint(1, 4, [1, ], dtype=np.int8).item()\n    power = np.random.randint(1, 4, dtype=np.uint8).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS int8', 'green'))\n    else:\n        print(colored('\\tFAIL int8', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.int16).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS int16', 'green'))\n    else:\n        print(colored('\\tFAIL int16', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.int32).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS int32', 'green'))\n    else:\n        print(colored('\\tFAIL int32', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.int64).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS int64', 'green'))\n    else:\n        print(colored('\\tFAIL int64', 'red'))\n\n    value = np.random.randint(1, 4, [1, ], dtype=np.uint8).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS uint8', 'green'))\n    else:\n        print(colored('\\tFAIL uint8', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.uint16).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS uint16', 'green'))\n    else:\n        print(colored('\\tFAIL uint16', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.uint32).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS uint32', 'green'))\n    else:\n        print(colored('\\tFAIL uint32', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.uint64).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS uint64', 'green'))\n    else:\n        print(colored('\\tFAIL uint64', 'red'))\n\n    value = np.random.randint(1, 10, [1, ]).astype(np.double).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS double', 'green'))\n    else:\n        print(colored('\\tFAIL double', 'red'))\n\n    value = np.random.randint(1, 10, [1, ]).astype(np.float32).item()\n    if NumCpp.power(value, power) == value ** power:\n        print(colored('\\tPASS float', 'green'))\n    else:\n        print(colored('\\tFAIL float', 'red'))\n\n    print(colored('Testing powerf', 'cyan'))\n    value = np.random.randint(1, 4, [1, ], dtype=np.int8).item()\n    power = np.random.rand(1).item() * 10\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS int8', 'green'))\n    else:\n        print(colored('\\tFAIL int8', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.int16).item()\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS int16', 'green'))\n    else:\n        print(colored('\\tFAIL int16', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.int32).item()\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS int32', 'green'))\n    else:\n        print(colored('\\tFAIL int32', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.int64).item()\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS int64', 'green'))\n    else:\n        print(colored('\\tFAIL int64', 'red'))\n\n    value = np.random.randint(1, 4, [1, ], dtype=np.uint8).item()\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS uint8', 'green'))\n    else:\n        print(colored('\\tFAIL uint8', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.uint16).item()\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS uint16', 'green'))\n    else:\n        print(colored('\\tFAIL uint16', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.uint32).item()\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS uint32', 'green'))\n    else:\n        print(colored('\\tFAIL uint32', 'red'))\n\n    value = np.random.randint(1, 10, [1, ], dtype=np.uint64).item()\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS uint64', 'green'))\n    else:\n        print(colored('\\tFAIL uint64', 'red'))\n\n    value = np.random.randint(1, 10, [1, ]).astype(np.double).item()\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS double', 'green'))\n    else:\n        print(colored('\\tFAIL double', 'red'))\n\n    value = np.random.randint(1, 10, [1, ]).astype(np.float32).item()\n    if NumCpp.powerf(value, power) == value ** power:\n        print(colored('\\tPASS float', 'green'))\n    else:\n        print(colored('\\tFAIL float', 'red'))\n\n####################################################################################\nif __name__ == '__main__':\n    doTest()\n"""
unitTests/testScripts/TestVector.py,158,"b""import numpy as np\r\nfrom termcolor import colored\r\nimport vectormath\r\nimport os\r\nimport sys\r\nif sys.platform == 'linux':\r\n    sys.path.append(r'../lib')\r\nelse:\r\n    sys.path.append(os.path.abspath('../build/x64/Release'))\r\nimport NumCpp\r\n\r\nDECIMALS_TO_ROUND = 9\r\n\r\n\r\n####################################################################################\r\ndef doTest():\r\n    print(colored('Testing Vector Module', 'magenta'))\r\n\r\n    testVec2()\r\n    testVec3()\r\n\r\n\r\n####################################################################################\r\ndef testVec2():\r\n    print(colored('Testing Vec2 Class', 'magenta'))\r\n\r\n    print(colored('Testing Default Constructor', 'cyan'))\r\n    NumCpp.Vec2()\r\n    print(colored('\\tPASS', 'green'))\r\n\r\n    print(colored('Testing Value Constructor', 'cyan'))\r\n    components = np.random.rand(2)\r\n    vec2 = NumCpp.Vec2(*components)\r\n    if (vec2.x == components[0].item() and\r\n            vec2.y == components[1].item()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing NdArray Constructor', 'cyan'))\r\n    components = np.random.rand(2)\r\n    shape = NumCpp.Shape(1, 2)\r\n    cArray = NumCpp.NdArray(shape)\r\n    cArray.setArray(components)\r\n    vec2 = NumCpp.Vec2(cArray)\r\n    if (vec2.x == components[0].item() and\r\n            vec2.y == components[1].item()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing angle', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    components2 = np.random.rand(2)\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_2py = vectormath.Vector2(*components2)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_2cpp = NumCpp.Vec2(*components2)\r\n    if (round(vec2_1py.angle(vec2_2py), DECIMALS_TO_ROUND) ==\r\n            round(vec2_1cpp.angle(vec2_2cpp), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing up', 'cyan'))\r\n    vec2 = NumCpp.Vec2.up()\r\n    if vec2.x == 0 and vec2.y == 1:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing down', 'cyan'))\r\n    vec2 = NumCpp.Vec2.down()\r\n    if vec2.x == 0 and vec2.y == -1:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing right', 'cyan'))\r\n    vec2 = NumCpp.Vec2.right()\r\n    if vec2.x == 1 and vec2.y == 0:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing down', 'cyan'))\r\n    vec2 = NumCpp.Vec2.left()\r\n    if vec2.x == -1 and vec2.y == -0:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing clampMagnitude', 'cyan'))\r\n    components = np.random.rand(2) + 10\r\n    clampMag = np.random.randint(1, 10, [1, ]).item()\r\n    vec2 = NumCpp.Vec2(*components)\r\n    clampedVec = vec2.clampMagnitude(float(clampMag))\r\n    if (np.round(clampedVec.norm(), DECIMALS_TO_ROUND) == clampMag and\r\n            np.round(vec2.dot(clampedVec) / vec2.norm() / clampedVec.norm(), DECIMALS_TO_ROUND) == 1):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing distance', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    components2 = np.random.rand(2)\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_2py = vectormath.Vector2(*components2)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_2cpp = NumCpp.Vec2(*components2)\r\n    if (round((vec2_2py - vec2_1py).length, DECIMALS_TO_ROUND) ==\r\n            round(vec2_1cpp.distance(vec2_2cpp), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing dot', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    components2 = np.random.rand(2)\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_2py = vectormath.Vector2(*components2)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_2cpp = NumCpp.Vec2(*components2)\r\n    if (round(vec2_1py.dot(vec2_2py), DECIMALS_TO_ROUND) ==\r\n            round(vec2_1cpp.dot(vec2_2cpp), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing norm', 'cyan'))\r\n    components = np.random.rand(2)\r\n    vec2py = vectormath.Vector2(*components)\r\n    vec2cpp = NumCpp.Vec2(*components)\r\n    if (round(vec2py.length, DECIMALS_TO_ROUND) ==\r\n            round(vec2cpp.norm(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing normalize', 'cyan'))\r\n    components = np.random.rand(2)\r\n    vec2py = vectormath.Vector2(*components)\r\n    vec2cpp = NumCpp.Vec2(*components)\r\n    if np.array_equal(np.round(vec2py.normalize(), DECIMALS_TO_ROUND),\r\n                      np.round(vec2cpp.normalize().toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator==', 'cyan'))\r\n    components = np.random.rand(2)\r\n    vec2_1cpp = NumCpp.Vec2(*components)\r\n    vec2_2cpp = NumCpp.Vec2(*components)\r\n    if vec2_1cpp == vec2_2cpp:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator!=', 'cyan'))\r\n    if not (vec2_1cpp != vec2_2cpp):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator+= Vec2', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    components2 = np.random.rand(2)\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_2py = vectormath.Vector2(*components2)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_2cpp = NumCpp.Vec2(*components2)\r\n    vec2_1cpp += vec2_2cpp\r\n    if np.array_equal(np.round(vec2_1py + vec2_2py, DECIMALS_TO_ROUND),\r\n                      np.round(vec2_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator+= scaler', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_1cpp += scaler\r\n    if np.array_equal(np.round(vec2_1py + scaler, DECIMALS_TO_ROUND),\r\n                      np.round(vec2_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator-=', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    components2 = np.random.rand(2)\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_2py = vectormath.Vector2(*components2)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_2cpp = NumCpp.Vec2(*components2)\r\n    vec2_1cpp -= vec2_2cpp\r\n    if np.array_equal(np.round(vec2_1py - vec2_2py, DECIMALS_TO_ROUND),\r\n                      np.round(vec2_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator-= scaler', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_1cpp -= scaler\r\n    if np.array_equal(np.round(vec2_1py - scaler, DECIMALS_TO_ROUND),\r\n                      np.round(vec2_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator*=', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_1cpp *= scaler\r\n    if np.array_equal(np.round(vec2_1py * scaler, DECIMALS_TO_ROUND),\r\n                      np.round(vec2_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator/=', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_1cpp /= scaler\r\n    if np.array_equal(np.round(vec2_1py / scaler, DECIMALS_TO_ROUND),\r\n                      np.round(vec2_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator+ Vec2', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    components2 = np.random.rand(2)\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_2py = vectormath.Vector2(*components2)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_2cpp = NumCpp.Vec2(*components2)\r\n    if np.array_equal(np.round(vec2_1py + vec2_2py, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec2_addVec2(vec2_1cpp, vec2_2cpp)).toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator+ scaler', 'cyan'))\r\n    components = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2py = vectormath.Vector2(*components)\r\n    vec2cpp = NumCpp.Vec2(*components)\r\n    if np.array_equal(np.round(vec2py + scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec2_addVec2Scaler(vec2cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing scaler operator+ Vec2', 'cyan'))\r\n    components = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2py = vectormath.Vector2(*components)\r\n    vec2cpp = NumCpp.Vec2(*components)\r\n    if np.array_equal(np.round(vec2py + scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec2_addScalerVec2(vec2cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator- Vec2', 'cyan'))\r\n    components1 = np.random.rand(2)\r\n    components2 = np.random.rand(2)\r\n    vec2_1py = vectormath.Vector2(*components1)\r\n    vec2_2py = vectormath.Vector2(*components2)\r\n    vec2_1cpp = NumCpp.Vec2(*components1)\r\n    vec2_2cpp = NumCpp.Vec2(*components2)\r\n    if np.array_equal(np.round(vec2_1py - vec2_2py, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec2_minusVec2(vec2_1cpp, vec2_2cpp)).toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator- scaler', 'cyan'))\r\n    components = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2py = vectormath.Vector2(*components)\r\n    vec2cpp = NumCpp.Vec2(*components)\r\n    if np.array_equal(np.round(vec2py - scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec2_minusVec2Scaler(vec2cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing scaler operator- Vec2', 'cyan'))\r\n    components = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2py = vectormath.Vector2(*components)\r\n    vec2cpp = NumCpp.Vec2(*components)\r\n    if np.array_equal(np.round(-vec2py + scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec2_minusScalerVec2(vec2cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator* scaler', 'cyan'))\r\n    components = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2py = vectormath.Vector2(*components)\r\n    vec2cpp = NumCpp.Vec2(*components)\r\n    if np.array_equal(np.round(vec2py * scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec2_multVec2Scaler(vec2cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing scaler operator* Vec2', 'cyan'))\r\n    components = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2py = vectormath.Vector2(*components)\r\n    vec2cpp = NumCpp.Vec2(*components)\r\n    if np.array_equal(np.round(vec2py * scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec2_multScalerVec2(vec2cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator/ scaler', 'cyan'))\r\n    components = np.random.rand(2)\r\n    scaler = np.random.rand(1).item()\r\n    vec2py = vectormath.Vector2(*components)\r\n    vec2cpp = NumCpp.Vec2(*components)\r\n    if np.array_equal(np.round(vec2py / scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec2_divVec2Scaler(vec2cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing print', 'cyan'))\r\n    NumCpp.Vec2_print(vec2cpp)\r\n\r\n\r\n####################################################################################\r\ndef testVec3():\r\n    print(colored('Testing Vec3 Class', 'magenta'))\r\n\r\n    print(colored('Testing Default Constructor', 'cyan'))\r\n    NumCpp.Vec3()\r\n    print(colored('\\tPASS', 'green'))\r\n\r\n    print(colored('Testing Value Constructor', 'cyan'))\r\n    components = np.random.rand(3)\r\n    vec2 = NumCpp.Vec3(*components)\r\n    if (vec2.x == components[0].item() and\r\n            vec2.y == components[1].item() and\r\n            vec2.z == components[2].item()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing NdArray Constructor', 'cyan'))\r\n    components = np.random.rand(3)\r\n    shape = NumCpp.Shape(1, 3)\r\n    cArray = NumCpp.NdArray(shape)\r\n    cArray.setArray(components)\r\n    vec3 = NumCpp.Vec3(cArray)\r\n    if (vec3.x == components[0].item() and\r\n            vec3.y == components[1].item() and\r\n            vec3.z == components[2].item()):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing angle', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    components2 = np.random.rand(3)\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_2py = vectormath.Vector3(*components2)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_2cpp = NumCpp.Vec3(*components2)\r\n    if (round(vec3_1py.angle(vec3_2py), DECIMALS_TO_ROUND) ==\r\n            round(vec3_1cpp.angle(vec3_2cpp), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing up', 'cyan'))\r\n    vec3 = NumCpp.Vec3.up()\r\n    if vec3.x == 0 and vec3.y == 1 and vec3.z == 0:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing down', 'cyan'))\r\n    vec3 = NumCpp.Vec3.down()\r\n    if vec3.x == 0 and vec3.y == -1 and vec3.z == 0:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing right', 'cyan'))\r\n    vec3 = NumCpp.Vec3.right()\r\n    if vec3.x == 1 and vec3.y == 0 and vec3.z == 0:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing down', 'cyan'))\r\n    vec3 = NumCpp.Vec3.left()\r\n    if vec3.x == -1 and vec3.y == -0 and vec3.z == 0:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing forward', 'cyan'))\r\n    vec3 = NumCpp.Vec3.forward()\r\n    if vec3.x == 0 and vec3.y == 0 and vec3.z == 1:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing back', 'cyan'))\r\n    vec3 = NumCpp.Vec3.back()\r\n    if vec3.x == 0 and vec3.y == -0 and vec3.z == -1:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing clampMagnitude', 'cyan'))\r\n    components = np.random.rand(3) + 10\r\n    clampMag = np.random.randint(1, 10, [1, ]).item()\r\n    vec3 = NumCpp.Vec3(*components)\r\n    clampedVec = vec3.clampMagnitude(float(clampMag))\r\n    if (np.round(clampedVec.norm(), DECIMALS_TO_ROUND) == clampMag and\r\n            np.round(vec3.dot(clampedVec) / vec3.norm() / clampedVec.norm(), DECIMALS_TO_ROUND) == 1):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing distance', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    components2 = np.random.rand(3)\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_2py = vectormath.Vector3(*components2)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_2cpp = NumCpp.Vec3(*components2)\r\n    if (round((vec3_2py - vec3_1py).length, DECIMALS_TO_ROUND) ==\r\n            round(vec3_1cpp.distance(vec3_2cpp), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing dot', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    components2 = np.random.rand(3)\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_2py = vectormath.Vector3(*components2)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_2cpp = NumCpp.Vec3(*components2)\r\n    if (round(vec3_1py.dot(vec3_2py), DECIMALS_TO_ROUND) ==\r\n            round(vec3_1cpp.dot(vec3_2cpp), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing cross', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    components2 = np.random.rand(3)\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_2py = vectormath.Vector3(*components2)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_2cpp = NumCpp.Vec3(*components2)\r\n    if np.array_equal(np.round(vec3_1py.cross(vec3_2py), DECIMALS_TO_ROUND),\r\n                      np.round(vec3_1cpp.cross(vec3_2cpp).toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing norm', 'cyan'))\r\n    components = np.random.rand(3)\r\n    vec3py = vectormath.Vector3(*components)\r\n    vec3cpp = NumCpp.Vec3(*components)\r\n    if (round(vec3py.length, DECIMALS_TO_ROUND) ==\r\n            round(vec3cpp.norm(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing normalize', 'cyan'))\r\n    components = np.random.rand(3)\r\n    vec3py = vectormath.Vector3(*components)\r\n    vec3cpp = NumCpp.Vec3(*components)\r\n    if np.array_equal(np.round(vec3py.normalize(), DECIMALS_TO_ROUND),\r\n                      np.round(vec3cpp.normalize().toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator==', 'cyan'))\r\n    components = np.random.rand(3)\r\n    vec3_1cpp = NumCpp.Vec3(*components)\r\n    vec3_2cpp = NumCpp.Vec3(*components)\r\n    if vec3_1cpp == vec3_2cpp:\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator!=', 'cyan'))\r\n    if not (vec3_1cpp != vec3_2cpp):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator+= Vec3', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    components2 = np.random.rand(3)\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_2py = vectormath.Vector3(*components2)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_2cpp = NumCpp.Vec3(*components2)\r\n    vec3_1cpp += vec3_2cpp\r\n    if np.array_equal(np.round(vec3_1py + vec3_2py, DECIMALS_TO_ROUND),\r\n                      np.round(vec3_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator+= scaler', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_1cpp += scaler\r\n    if np.array_equal(np.round(vec3_1py + scaler, DECIMALS_TO_ROUND),\r\n                      np.round(vec3_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator-=', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    components2 = np.random.rand(3)\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_2py = vectormath.Vector3(*components2)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_2cpp = NumCpp.Vec3(*components2)\r\n    vec3_1cpp -= vec3_2cpp\r\n    if np.array_equal(np.round(vec3_1py - vec3_2py, DECIMALS_TO_ROUND),\r\n                      np.round(vec3_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator-= scaler', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_1cpp -= scaler\r\n    if np.array_equal(np.round(vec3_1py - scaler, DECIMALS_TO_ROUND),\r\n                      np.round(vec3_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator*=', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_1cpp *= scaler\r\n    if np.array_equal(np.round(vec3_1py * scaler, DECIMALS_TO_ROUND),\r\n                      np.round(vec3_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator/=', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_1cpp /= scaler\r\n    if np.array_equal(np.round(vec3_1py / scaler, DECIMALS_TO_ROUND),\r\n                      np.round(vec3_1cpp.toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator+ Vec3', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    components2 = np.random.rand(3)\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_2py = vectormath.Vector3(*components2)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_2cpp = NumCpp.Vec3(*components2)\r\n    if np.array_equal(np.round(vec3_1py + vec3_2py, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec3_addVec3(vec3_1cpp, vec3_2cpp)).toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator+ scaler', 'cyan'))\r\n    components = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3py = vectormath.Vector3(*components)\r\n    vec3cpp = NumCpp.Vec3(*components)\r\n    if np.array_equal(np.round(vec3py + scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec3_addVec3Scaler(vec3cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing scaler operator+ Vec3', 'cyan'))\r\n    components = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3py = vectormath.Vector3(*components)\r\n    vec3cpp = NumCpp.Vec3(*components)\r\n    if np.array_equal(np.round(vec3py + scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec3_addScalerVec3(vec3cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator- Vec3', 'cyan'))\r\n    components1 = np.random.rand(3)\r\n    components2 = np.random.rand(3)\r\n    vec3_1py = vectormath.Vector3(*components1)\r\n    vec3_2py = vectormath.Vector3(*components2)\r\n    vec3_1cpp = NumCpp.Vec3(*components1)\r\n    vec3_2cpp = NumCpp.Vec3(*components2)\r\n    if np.array_equal(np.round(vec3_1py - vec3_2py, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec3_minusVec3(vec3_1cpp, vec3_2cpp)).toNdArray().flatten(), DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator- scaler', 'cyan'))\r\n    components = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3py = vectormath.Vector3(*components)\r\n    vec3cpp = NumCpp.Vec3(*components)\r\n    if np.array_equal(np.round(vec3py - scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec3_minusVec3Scaler(vec3cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing scaler operator- Vec3', 'cyan'))\r\n    components = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3py = vectormath.Vector3(*components)\r\n    vec3cpp = NumCpp.Vec3(*components)\r\n    if np.array_equal(np.round(-vec3py + scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec3_minusScalerVec3(vec3cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator* scaler', 'cyan'))\r\n    components = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3py = vectormath.Vector3(*components)\r\n    vec3cpp = NumCpp.Vec3(*components)\r\n    if np.array_equal(np.round(vec3py * scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec3_multVec3Scaler(vec3cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing scaler operator* Vec3', 'cyan'))\r\n    components = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3py = vectormath.Vector3(*components)\r\n    vec3cpp = NumCpp.Vec3(*components)\r\n    if np.array_equal(np.round(vec3py * scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec3_multScalerVec3(vec3cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing operator/ scaler', 'cyan'))\r\n    components = np.random.rand(3)\r\n    scaler = np.random.rand(1).item()\r\n    vec3py = vectormath.Vector3(*components)\r\n    vec3cpp = NumCpp.Vec3(*components)\r\n    if np.array_equal(np.round(vec3py / scaler, DECIMALS_TO_ROUND),\r\n                      np.round((NumCpp.Vec3_divVec3Scaler(vec3cpp, scaler)).toNdArray().flatten(),\r\n                               DECIMALS_TO_ROUND)):\r\n        print(colored('\\tPASS', 'green'))\r\n    else:\r\n        print(colored('\\tFAIL', 'red'))\r\n\r\n    print(colored('Testing print', 'cyan'))\r\n    NumCpp.Vec3_print(vec3cpp)\r\n\r\n\r\n####################################################################################\r\nif __name__ == '__main__':\r\n    doTest()\r\n"""
