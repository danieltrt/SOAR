file_path,api_count,code
plyfile.py,22,"b'#   Copyright 2014 Darsh Ranjan\n#\n#   This file is part of python-plyfile.\n#\n#   python-plyfile is free software: you can redistribute it and/or\n#   modify it under the terms of the GNU General Public License as\n#   published by the Free Software Foundation, either version 3 of the\n#   License, or (at your option) any later version.\n#\n#   python-plyfile is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#   General Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License\n#   along with python-plyfile.  If not, see\n#       <http://www.gnu.org/licenses/>.\n\nfrom itertools import islice as _islice\n\nimport numpy as _np\nfrom sys import byteorder as _byteorder\n\n\ntry:\n    _range = xrange\nexcept NameError:\n    _range = range\n\n\n# Many-many relation\n_data_type_relation = [\n    (\'int8\', \'i1\'),\n    (\'char\', \'i1\'),\n    (\'uint8\', \'u1\'),\n    (\'uchar\', \'b1\'),\n    (\'uchar\', \'u1\'),\n    (\'int16\', \'i2\'),\n    (\'short\', \'i2\'),\n    (\'uint16\', \'u2\'),\n    (\'ushort\', \'u2\'),\n    (\'int32\', \'i4\'),\n    (\'int\', \'i4\'),\n    (\'uint32\', \'u4\'),\n    (\'uint\', \'u4\'),\n    (\'float32\', \'f4\'),\n    (\'float\', \'f4\'),\n    (\'float64\', \'f8\'),\n    (\'double\', \'f8\')\n]\n\n_data_types = dict(_data_type_relation)\n_data_type_reverse = dict((b, a) for (a, b) in _data_type_relation)\n\n_types_list = []\n_types_set = set()\nfor (_a, _b) in _data_type_relation:\n    if _a not in _types_set:\n        _types_list.append(_a)\n        _types_set.add(_a)\n    if _b not in _types_set:\n        _types_list.append(_b)\n        _types_set.add(_b)\n\n\n_byte_order_map = {\n    \'ascii\': \'=\',\n    \'binary_little_endian\': \'<\',\n    \'binary_big_endian\': \'>\'\n}\n\n_byte_order_reverse = {\n    \'<\': \'binary_little_endian\',\n    \'>\': \'binary_big_endian\'\n}\n\n_native_byte_order = {\'little\': \'<\', \'big\': \'>\'}[_byteorder]\n\n\ndef _lookup_type(type_str):\n    if type_str not in _data_type_reverse:\n        try:\n            type_str = _data_types[type_str]\n        except KeyError:\n            raise ValueError(""field type %r not in %r"" %\n                             (type_str, _types_list))\n\n    return _data_type_reverse[type_str]\n\n\ndef make2d(array, cols=None, dtype=None):\n    \'\'\'\n    Make a 2D array from an array of arrays.  The `cols\' and `dtype\'\n    arguments can be omitted if the array is not empty.\n\n    \'\'\'\n    if not len(array):\n        if cols is None or dtype is None:\n            raise RuntimeError(\n                ""cols and dtype must be specified for empty array""\n            )\n        return _np.empty((0, cols), dtype=dtype)\n    return _np.vstack(array)\n\n\nclass _PlyHeaderParser(object):\n    def __init__(self):\n        self.format = None\n        self.elements = []\n        self.comments = []\n        self.obj_info = []\n        self.lines = 0\n        self._allowed = [\'ply\']\n\n    def consume(self, raw_line):\n        self.lines += 1\n        if not raw_line:\n            self._error(""early end-of-file"")\n\n        line = raw_line.decode(\'ascii\').strip()\n        try:\n            keyword = line.split(None, 1)[0]\n        except IndexError:\n            self._error()\n\n        if keyword not in self._allowed:\n            self._error(""expected one of {%s}"" %\n                        "", "".join(self._allowed))\n\n        getattr(self, \'parse_\' + keyword)(line[len(keyword)+1:])\n        return self._allowed\n\n    def _error(self, message=""parse error""):\n        raise PlyHeaderParseError(message, self.lines)\n\n    def parse_ply(self, data):\n        if data:\n            self._error(""unexpected characters after \'ply\'"")\n        self._allowed = [\'format\', \'comment\', \'obj_info\']\n\n    def parse_format(self, data):\n        fields = data.strip().split()\n        if len(fields) != 2:\n            self._error(""expected \\""format {format} 1.0\\"""")\n\n        self.format = fields[0]\n        if self.format not in _byte_order_map:\n            self._error(""don\'t understand format %r"" % format)\n\n        if fields[1] != \'1.0\':\n            self._error(""expected version \'1.0\'"")\n\n        self._allowed = [\'element\', \'comment\', \'obj_info\', \'end_header\']\n\n    def parse_comment(self, data):\n        if not self.elements:\n            self.comments.append(data)\n        else:\n            self.elements[-1][3].append(data)\n\n    def parse_obj_info(self, data):\n        self.obj_info.append(data)\n\n    def parse_element(self, data):\n        fields = data.strip().split()\n        if len(fields) != 2:\n            self._error(""expected \\""element {name} {count}\\"""")\n\n        name = fields[0]\n        try:\n            count = int(fields[1])\n        except ValueError:\n            self._error(""expected integer count"")\n\n        self.elements.append((name, [], count, []))\n        self._allowed = [\'element\', \'comment\', \'property\', \'end_header\']\n\n    def parse_property(self, data):\n        properties = self.elements[-1][1]\n        fields = data.strip().split()\n        if len(fields) < 2:\n            self._error(""bad \'property\' line"")\n\n        if fields[0] == \'list\':\n            if len(fields) != 4:\n                self._error(""expected \\""property list ""\n                            ""{len_type} {val_type} {name}\\"""")\n\n            try:\n                properties.append(\n                    PlyListProperty(fields[3], fields[1], fields[2])\n                )\n            except ValueError as e:\n                self._error(str(e))\n\n        else:\n            if len(fields) != 2:\n                self._error(""expected \\""property {type} {name}\\"""")\n\n            try:\n                properties.append(\n                    PlyProperty(fields[1], fields[0])\n                )\n            except ValueError as e:\n                self._error(str(e))\n\n    def parse_end_header(self, data):\n        if data:\n            self._error(""unexpected data after \'end_header\'"")\n        self._allowed = []\n\n\nclass PlyParseError(Exception):\n\n    \'\'\'\n    Base class for PLY parsing errors.\n\n    \'\'\'\n\n    pass\n\n\nclass PlyElementParseError(PlyParseError):\n\n    \'\'\'\n    Raised when a PLY element cannot be parsed.\n\n    The attributes `element\', `row\', `property\', and `message\' give\n    additional information.\n\n    \'\'\'\n\n    def __init__(self, message, element=None, row=None, prop=None):\n        self.message = message\n        self.element = element\n        self.row = row\n        self.prop = prop\n\n        s = \'\'\n        if self.element:\n            s += \'element %r: \' % self.element.name\n        if self.row is not None:\n            s += \'row %d: \' % self.row\n        if self.prop:\n            s += \'property %r: \' % self.prop.name\n        s += self.message\n\n        Exception.__init__(self, s)\n\n    def __repr__(self):\n        return (\'%s(%r, element=%r, row=%r, prop=%r)\' %\n                (self.__class__.__name__,\n                 self.message, self.element, self.row, self.prop))\n\n\nclass PlyHeaderParseError(PlyParseError):\n\n    \'\'\'\n    Raised when a PLY header cannot be parsed.\n\n    The attribute `line\' provides additional information.\n\n    \'\'\'\n\n    def __init__(self, message, line=None):\n        self.message = message\n        self.line = line\n\n        s = \'\'\n        if self.line:\n            s += \'line %r: \' % self.line\n        s += self.message\n\n        Exception.__init__(self, s)\n\n    def __repr__(self):\n        return (\'%s(%r, line=%r)\' %\n                (self.__class__.__name__,\n                 self.message, self.line))\n\n\nclass PlyData(object):\n\n    \'\'\'\n    PLY file header and data.\n\n    A PlyData instance is created in one of two ways: by the static\n    method PlyData.read (to read a PLY file), or directly from __init__\n    given a sequence of elements (which can then be written to a PLY\n    file).\n\n    \'\'\'\n\n    def __init__(self, elements=[], text=False, byte_order=\'=\',\n                 comments=[], obj_info=[]):\n        \'\'\'\n        elements: sequence of PlyElement instances.\n\n        text: whether the resulting PLY file will be text (True) or\n            binary (False).\n\n        byte_order: \'<\' for little-endian, \'>\' for big-endian, or \'=\'\n            for native.  This is only relevant if `text\' is False.\n\n        comments: sequence of strings that will be placed in the header\n            between the \'ply\' and \'format ...\' lines.\n\n        obj_info: like comments, but will be placed in the header with\n            ""obj_info ..."" instead of ""comment ..."".\n\n        \'\'\'\n        if byte_order == \'=\' and not text:\n            byte_order = _native_byte_order\n\n        self.byte_order = byte_order\n        self.text = text\n\n        self.comments = comments\n        self.obj_info = obj_info\n        self.elements = elements\n\n    def _get_elements(self):\n        return self._elements\n\n    def _set_elements(self, elements):\n        self._elements = tuple(elements)\n        self._index()\n\n    elements = property(_get_elements, _set_elements)\n\n    def _get_byte_order(self):\n        return self._byte_order\n\n    def _set_byte_order(self, byte_order):\n        if byte_order not in [\'<\', \'>\', \'=\']:\n            raise ValueError(""byte order must be \'<\', \'>\', or \'=\'"")\n\n        self._byte_order = byte_order\n\n    byte_order = property(_get_byte_order, _set_byte_order)\n\n    def _index(self):\n        self._element_lookup = dict((elt.name, elt) for elt in\n                                    self._elements)\n        if len(self._element_lookup) != len(self._elements):\n            raise ValueError(""two elements with same name"")\n\n    def _get_comments(self):\n        return list(self._comments)\n\n    def _set_comments(self, comments):\n        _check_comments(comments)\n        self._comments = list(comments)\n\n    comments = property(_get_comments, _set_comments)\n\n    def _get_obj_info(self):\n        return list(self._obj_info)\n\n    def _set_obj_info(self, obj_info):\n        _check_comments(obj_info)\n        self._obj_info = list(obj_info)\n\n    obj_info = property(_get_obj_info, _set_obj_info)\n\n    @staticmethod\n    def _parse_header(stream):\n        \'\'\'\n        Parse a PLY header from a readable file-like stream.\n\n        \'\'\'\n        parser = _PlyHeaderParser()\n        while parser.consume(stream.readline()):\n            pass\n\n        return PlyData(\n            [PlyElement(*e) for e in parser.elements],\n            parser.format == \'ascii\',\n            _byte_order_map[parser.format],\n            parser.comments,\n            parser.obj_info\n        )\n\n    @staticmethod\n    def read(stream):\n        \'\'\'\n        Read PLY data from a readable file-like object or filename.\n\n        \'\'\'\n        (must_close, stream) = _open_stream(stream, \'read\')\n        try:\n            data = PlyData._parse_header(stream)\n            for elt in data:\n                elt._read(stream, data.text, data.byte_order)\n        finally:\n            if must_close:\n                stream.close()\n\n        return data\n\n    def write(self, stream):\n        \'\'\'\n        Write PLY data to a writeable file-like object or filename.\n\n        \'\'\'\n        (must_close, stream) = _open_stream(stream, \'write\')\n        try:\n            stream.write(self.header.encode(\'ascii\'))\n            stream.write(b\'\\n\')\n            for elt in self:\n                elt._write(stream, self.text, self.byte_order)\n        finally:\n            if must_close:\n                stream.close()\n\n    @property\n    def header(self):\n        \'\'\'\n        Provide PLY-formatted metadata for the instance.\n\n        \'\'\'\n        lines = [\'ply\']\n\n        if self.text:\n            lines.append(\'format ascii 1.0\')\n        else:\n            lines.append(\'format \' +\n                         _byte_order_reverse[self.byte_order] +\n                         \' 1.0\')\n\n        # Some information is lost here, since all comments are placed\n        # between the \'format\' line and the first element.\n        for c in self.comments:\n            lines.append(\'comment \' + c)\n\n        for c in self.obj_info:\n            lines.append(\'obj_info \' + c)\n\n        lines.extend(elt.header for elt in self.elements)\n        lines.append(\'end_header\')\n        return \'\\n\'.join(lines)\n\n    def __iter__(self):\n        return iter(self.elements)\n\n    def __len__(self):\n        return len(self.elements)\n\n    def __contains__(self, name):\n        return name in self._element_lookup\n\n    def __getitem__(self, name):\n        return self._element_lookup[name]\n\n    def __str__(self):\n        return self.header\n\n    def __repr__(self):\n        return (\'PlyData(%r, text=%r, byte_order=%r, \'\n                \'comments=%r, obj_info=%r)\' %\n                (self.elements, self.text, self.byte_order,\n                 self.comments, self.obj_info))\n\n\ndef _open_stream(stream, read_or_write):\n    if hasattr(stream, read_or_write):\n        return (False, stream)\n    try:\n        return (True, open(stream, read_or_write[0] + \'b\'))\n    except TypeError:\n        raise RuntimeError(""expected open file or filename"")\n\n\nclass PlyElement(object):\n\n    \'\'\'\n    PLY file element.\n\n    A client of this library doesn\'t normally need to instantiate this\n    directly, so the following is only for the sake of documenting the\n    internals.\n\n    Creating a PlyElement instance is generally done in one of two ways:\n    as a byproduct of PlyData.read (when reading a PLY file) and by\n    PlyElement.describe (before writing a PLY file).\n\n    \'\'\'\n\n    def __init__(self, name, properties, count, comments=[]):\n        \'\'\'\n        This is not part of the public interface.  The preferred methods\n        of obtaining PlyElement instances are PlyData.read (to read from\n        a file) and PlyElement.describe (to construct from a numpy\n        array).\n\n        \'\'\'\n        _check_name(name)\n        self._name = str(name)\n        self._count = count\n\n        self._properties = tuple(properties)\n        self._index()\n\n        self.comments = comments\n\n        self._have_list = any(isinstance(p, PlyListProperty)\n                              for p in self.properties)\n\n    @property\n    def count(self):\n        return self._count\n\n    def _get_data(self):\n        return self._data\n\n    def _set_data(self, data):\n        self._data = data\n        self._count = len(data)\n        self._check_sanity()\n\n    data = property(_get_data, _set_data)\n\n    def _check_sanity(self):\n        for prop in self.properties:\n            if prop.name not in self._data.dtype.fields:\n                raise ValueError(""dangling property %r"" % prop.name)\n\n    def _get_properties(self):\n        return self._properties\n\n    def _set_properties(self, properties):\n        self._properties = tuple(properties)\n        self._check_sanity()\n        self._index()\n\n    properties = property(_get_properties, _set_properties)\n\n    def _get_comments(self):\n        return list(self._comments)\n\n    def _set_comments(self, comments):\n        _check_comments(comments)\n        self._comments = list(comments)\n\n    comments = property(_get_comments, _set_comments)\n\n    def _index(self):\n        self._property_lookup = dict((prop.name, prop)\n                                     for prop in self._properties)\n        if len(self._property_lookup) != len(self._properties):\n            raise ValueError(""two properties with same name"")\n\n    def ply_property(self, name):\n        return self._property_lookup[name]\n\n    @property\n    def name(self):\n        return self._name\n\n    def dtype(self, byte_order=\'=\'):\n        \'\'\'\n        Return the numpy dtype of the in-memory representation of the\n        data.  (If there are no list properties, and the PLY format is\n        binary, then this also accurately describes the on-disk\n        representation of the element.)\n\n        \'\'\'\n        return _np.dtype([(prop.name, prop.dtype(byte_order))\n                          for prop in self.properties])\n\n    @staticmethod\n    def describe(data, name, len_types={}, val_types={},\n                 comments=[]):\n        \'\'\'\n        Construct a PlyElement from an array\'s metadata.\n\n        len_types and val_types can be given as mappings from list\n        property names to type strings (like \'u1\', \'f4\', etc., or\n        \'int8\', \'float32\', etc.). These can be used to define the length\n        and value types of list properties.  List property lengths\n        always default to type \'u1\' (8-bit unsigned integer), and value\n        types default to \'i4\' (32-bit integer).\n\n        \'\'\'\n        if not isinstance(data, _np.ndarray):\n            raise TypeError(""only numpy arrays are supported"")\n\n        if len(data.shape) != 1:\n            raise ValueError(""only one-dimensional arrays are ""\n                             ""supported"")\n\n        count = len(data)\n\n        properties = []\n        descr = data.dtype.descr\n\n        for t in descr:\n            if not isinstance(t[1], str):\n                raise ValueError(""nested records not supported"")\n\n            if not t[0]:\n                raise ValueError(""field with empty name"")\n\n            if len(t) != 2 or t[1][1] == \'O\':\n                # non-scalar field, which corresponds to a list\n                # property in PLY.\n\n                if t[1][1] == \'O\':\n                    if len(t) != 2:\n                        raise ValueError(""non-scalar object fields not ""\n                                         ""supported"")\n\n                len_str = _data_type_reverse[len_types.get(t[0], \'u1\')]\n                if t[1][1] == \'O\':\n                    val_type = val_types.get(t[0], \'i4\')\n                    val_str = _lookup_type(val_type)\n                else:\n                    val_str = _lookup_type(t[1][1:])\n\n                prop = PlyListProperty(t[0], len_str, val_str)\n            else:\n                val_str = _lookup_type(t[1][1:])\n                prop = PlyProperty(t[0], val_str)\n\n            properties.append(prop)\n\n        elt = PlyElement(name, properties, count, comments)\n        elt.data = data\n\n        return elt\n\n    def _read(self, stream, text, byte_order):\n        \'\'\'\n        Read the actual data from a PLY file.\n\n        \'\'\'\n        dtype = self.dtype(byte_order)\n        if text:\n            self._read_txt(stream)\n        elif _can_mmap(stream) and not self._have_list:\n            # Loading the data is straightforward.  We will memory map\n            # the file in copy-on-write mode.\n            num_bytes = self.count * dtype.itemsize\n            offset = stream.tell()\n            stream.seek(0, 2)\n            max_bytes = stream.tell() - offset\n            if max_bytes < num_bytes:\n                raise PlyElementParseError(""early end-of-file"", self,\n                                           max_bytes // dtype.itemsize)\n            self._data = _np.memmap(stream, dtype,\n                                    \'c\', offset, self.count)\n            # Fix stream position\n            stream.seek(offset + self.count * dtype.itemsize)\n        else:\n            # A simple load is impossible.\n            self._read_bin(stream, byte_order)\n\n        self._check_sanity()\n\n    def _write(self, stream, text, byte_order):\n        \'\'\'\n        Write the data to a PLY file.\n\n        \'\'\'\n        if text:\n            self._write_txt(stream)\n        else:\n            if self._have_list:\n                # There are list properties, so serialization is\n                # slightly complicated.\n                self._write_bin(stream, byte_order)\n            else:\n                # no list properties, so serialization is\n                # straightforward.\n                stream.write(self.data.astype(self.dtype(byte_order),\n                                              copy=False).data)\n\n    def _read_txt(self, stream):\n        \'\'\'\n        Load a PLY element from an ASCII-format PLY file.  The element\n        may contain list properties.\n\n        \'\'\'\n        self._data = _np.empty(self.count, dtype=self.dtype())\n\n        k = 0\n        for line in _islice(iter(stream.readline, b\'\'), self.count):\n            fields = iter(line.strip().split())\n            for prop in self.properties:\n                try:\n                    self._data[prop.name][k] = prop._from_fields(fields)\n                except StopIteration:\n                    raise PlyElementParseError(""early end-of-line"",\n                                               self, k, prop)\n                except ValueError:\n                    raise PlyElementParseError(""malformed input"",\n                                               self, k, prop)\n            try:\n                next(fields)\n            except StopIteration:\n                pass\n            else:\n                raise PlyElementParseError(""expected end-of-line"",\n                                           self, k)\n            k += 1\n\n        if k < self.count:\n            del self._data\n            raise PlyElementParseError(""early end-of-file"", self, k)\n\n    def _write_txt(self, stream):\n        \'\'\'\n        Save a PLY element to an ASCII-format PLY file.  The element may\n        contain list properties.\n\n        \'\'\'\n        for rec in self.data:\n            fields = []\n            for prop in self.properties:\n                fields.extend(prop._to_fields(rec[prop.name]))\n\n            _np.savetxt(stream, [fields], \'%.18g\', newline=\'\\n\')\n\n    def _read_bin(self, stream, byte_order):\n        \'\'\'\n        Load a PLY element from a binary PLY file.  The element may\n        contain list properties.\n\n        \'\'\'\n        self._data = _np.empty(self.count, dtype=self.dtype(byte_order))\n\n        for k in _range(self.count):\n            for prop in self.properties:\n                try:\n                    self._data[prop.name][k] = \\\n                        prop._read_bin(stream, byte_order)\n                except StopIteration:\n                    raise PlyElementParseError(""early end-of-file"",\n                                               self, k, prop)\n\n    def _write_bin(self, stream, byte_order):\n        \'\'\'\n        Save a PLY element to a binary PLY file.  The element may\n        contain list properties.\n\n        \'\'\'\n        for rec in self.data:\n            for prop in self.properties:\n                prop._write_bin(rec[prop.name], stream, byte_order)\n\n    @property\n    def header(self):\n        \'\'\'\n        Format this element\'s metadata as it would appear in a PLY\n        header.\n\n        \'\'\'\n        lines = [\'element %s %d\' % (self.name, self.count)]\n\n        # Some information is lost here, since all comments are placed\n        # between the \'element\' line and the first property definition.\n        for c in self.comments:\n            lines.append(\'comment \' + c)\n\n        lines.extend(list(map(str, self.properties)))\n\n        return \'\\n\'.join(lines)\n\n    def __getitem__(self, key):\n        return self.data[key]\n\n    def __setitem__(self, key, value):\n        self.data[key] = value\n\n    def __str__(self):\n        return self.header\n\n    def __repr__(self):\n        return (\'PlyElement(%r, %r, count=%d, comments=%r)\' %\n                (self.name, self.properties, self.count,\n                 self.comments))\n\n\ndef _check_comments(comments):\n    for comment in comments:\n        for char in comment:\n            if not 0 <= ord(char) < 128:\n                raise ValueError(""non-ASCII character in comment"")\n            if char == \'\\n\':\n                raise ValueError(""embedded newline in comment"")\n\n\nclass PlyProperty(object):\n\n    \'\'\'\n    PLY property description.  This class is pure metadata; the data\n    itself is contained in PlyElement instances.\n\n    \'\'\'\n\n    def __init__(self, name, val_dtype):\n        _check_name(name)\n        self._name = str(name)\n        self.val_dtype = val_dtype\n\n    def _get_val_dtype(self):\n        return self._val_dtype\n\n    def _set_val_dtype(self, val_dtype):\n        self._val_dtype = _data_types[_lookup_type(val_dtype)]\n\n    val_dtype = property(_get_val_dtype, _set_val_dtype)\n\n    @property\n    def name(self):\n        return self._name\n\n    def dtype(self, byte_order=\'=\'):\n        \'\'\'\n        Return the numpy dtype description for this property (as a tuple\n        of strings).\n\n        \'\'\'\n        return byte_order + self.val_dtype\n\n    def _from_fields(self, fields):\n        \'\'\'\n        Parse from generator.  Raise StopIteration if the property could\n        not be read.\n\n        \'\'\'\n        return _np.dtype(self.dtype()).type(next(fields))\n\n    def _to_fields(self, data):\n        \'\'\'\n        Return generator over one item.\n\n        \'\'\'\n        yield _np.dtype(self.dtype()).type(data)\n\n    def _read_bin(self, stream, byte_order):\n        \'\'\'\n        Read data from a binary stream.  Raise StopIteration if the\n        property could not be read.\n\n        \'\'\'\n        try:\n            return _read_array(stream, self.dtype(byte_order), 1)[0]\n        except IndexError:\n            raise StopIteration\n\n    def _write_bin(self, data, stream, byte_order):\n        \'\'\'\n        Write data to a binary stream.\n\n        \'\'\'\n        _write_array(stream, _np.dtype(self.dtype(byte_order)).type(data))\n\n    def __str__(self):\n        val_str = _data_type_reverse[self.val_dtype]\n        return \'property %s %s\' % (val_str, self.name)\n\n    def __repr__(self):\n        return \'PlyProperty(%r, %r)\' % (self.name,\n                                        _lookup_type(self.val_dtype))\n\n\nclass PlyListProperty(PlyProperty):\n\n    \'\'\'\n    PLY list property description.\n\n    \'\'\'\n\n    def __init__(self, name, len_dtype, val_dtype):\n        PlyProperty.__init__(self, name, val_dtype)\n\n        self.len_dtype = len_dtype\n\n    def _get_len_dtype(self):\n        return self._len_dtype\n\n    def _set_len_dtype(self, len_dtype):\n        self._len_dtype = _data_types[_lookup_type(len_dtype)]\n\n    len_dtype = property(_get_len_dtype, _set_len_dtype)\n\n    def dtype(self, byte_order=\'=\'):\n        \'\'\'\n        List properties always have a numpy dtype of ""object"".\n\n        \'\'\'\n        return \'|O\'\n\n    def list_dtype(self, byte_order=\'=\'):\n        \'\'\'\n        Return the pair (len_dtype, val_dtype) (both numpy-friendly\n        strings).\n\n        \'\'\'\n        return (byte_order + self.len_dtype,\n                byte_order + self.val_dtype)\n\n    def _from_fields(self, fields):\n        (len_t, val_t) = self.list_dtype()\n\n        n = int(_np.dtype(len_t).type(next(fields)))\n\n        data = _np.loadtxt(list(_islice(fields, n)), val_t, ndmin=1)\n        if len(data) < n:\n            raise StopIteration\n\n        return data\n\n    def _to_fields(self, data):\n        \'\'\'\n        Return generator over the (numerical) PLY representation of the\n        list data (length followed by actual data).\n\n        \'\'\'\n        (len_t, val_t) = self.list_dtype()\n\n        data = _np.asarray(data, dtype=val_t).ravel()\n\n        yield _np.dtype(len_t).type(data.size)\n        for x in data:\n            yield x\n\n    def _read_bin(self, stream, byte_order):\n        (len_t, val_t) = self.list_dtype(byte_order)\n\n        try:\n            n = _read_array(stream, _np.dtype(len_t), 1)[0]\n        except IndexError:\n            raise StopIteration\n\n        data = _read_array(stream, _np.dtype(val_t), n)\n        if len(data) < n:\n            raise StopIteration\n\n        return data\n\n    def _write_bin(self, data, stream, byte_order):\n        \'\'\'\n        Write data to a binary stream.\n\n        \'\'\'\n        (len_t, val_t) = self.list_dtype(byte_order)\n\n        data = _np.asarray(data, dtype=val_t).ravel()\n\n        _write_array(stream, _np.array(data.size, dtype=len_t))\n        _write_array(stream, data)\n\n    def __str__(self):\n        len_str = _data_type_reverse[self.len_dtype]\n        val_str = _data_type_reverse[self.val_dtype]\n        return \'property list %s %s %s\' % (len_str, val_str, self.name)\n\n    def __repr__(self):\n        return (\'PlyListProperty(%r, %r, %r)\' %\n                (self.name,\n                 _lookup_type(self.len_dtype),\n                 _lookup_type(self.val_dtype)))\n\n\ndef _check_name(name):\n    for char in name:\n        if not 0 <= ord(char) < 128:\n            raise ValueError(""non-ASCII character in name %r"" % name)\n        if char.isspace():\n            raise ValueError(""space character(s) in name %r"" % name)\n\n\ndef _read_array(stream, dtype, n):\n    try:\n        size = int(_np.dtype(dtype).itemsize * n)\n        return _np.frombuffer(stream.read(size), dtype)\n    except Exception:\n        raise StopIteration\n\n\ndef _write_array(stream, array):\n    stream.write(array.tostring())\n\n\ndef _can_mmap(stream):\n    try:\n        pos = stream.tell()\n        try:\n            _np.memmap(stream, \'u1\', \'c\')\n            stream.seek(pos)\n            return True\n        except Exception as e:\n            stream.seek(pos)\n            return False\n    except Exception as e:\n        return False\n'"
setup.py,0,"b'import os\n\nfrom setuptools import setup\n\nmydir = os.path.dirname(__file__)\nif mydir:\n    os.chdir(mydir)\n\nwith open(""README.md"", ""r"") as f:\n    long_description = f.read()\n\nversion = \'0.7.2\'\nbase_url = \'https://github.com/dranjan/python-plyfile\'\n\nsetup(name=\'plyfile\',\n      author=\'Darsh Ranjan\',\n      author_email=\'dranjan@berkeley.edu\',\n      version=version,\n      install_requires=[\'numpy>=1.8\'],\n      description=\'PLY file reader/writer\',\n      long_description_content_type=""text/markdown"",\n      long_description=long_description,\n      url=base_url,\n      download_url=(\'%s/archive/v%s.tar.gz\' % (base_url, version)),\n      classifiers=[\n          \'Programming Language :: Python :: 2\',\n          \'Programming Language :: Python :: 2.7\',\n          \'Programming Language :: Python :: 3\',\n          \'Programming Language :: Python :: 3.4\',\n          \'Programming Language :: Python :: 3.5\',\n          \'Programming Language :: Python :: 3.6\',\n          \'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)\',\n          \'Operating System :: OS Independent\',\n          \'Development Status :: 4 - Beta\',\n          \'Topic :: Scientific/Engineering\'\n      ],\n      data_files=[(\'\', [\'COPYING\'])],\n      py_modules=[\'plyfile\'],\n      keywords=[\'ply\', \'numpy\'])\n'"
examples/plot.py,0,"b""'''\nExample script illustrating plotting of PLY data using Mayavi.  Mayavi\nis not a dependency of plyfile, but you will need to install it in order\nto run this script.  Failing to do so will immediately result in\nImportError.\n\n'''\n\nfrom argparse import ArgumentParser\n\nimport numpy\nfrom mayavi import mlab\n\nfrom plyfile import PlyData\n\n\ndef main():\n    parser = ArgumentParser()\n    parser.add_argument('ply_filename')\n\n    args = parser.parse_args()\n\n    mlab.figure(bgcolor=(0, 0, 0))\n    plot(PlyData.read(args.ply_filename))\n    mlab.show()\n\n\ndef plot(ply):\n    '''\n    Plot vertices and triangles from a PlyData instance. Assumptions:\n        `ply' has a 'vertex' element with 'x', 'y', and 'z'\n            properties;\n\n        `ply' has a 'face' element with an integral list property\n            'vertex_indices', all of whose elements have length 3.\n\n    '''\n    vertex = ply['vertex']\n\n    (x, y, z) = (vertex[t] for t in ('x', 'y', 'z'))\n\n    mlab.points3d(x, y, z, color=(1, 1, 1), mode='point')\n\n    if 'face' in ply:\n        tri_idx = ply['face']['vertex_indices']\n        triangles = numpy.vstack(tri_idx)\n        mlab.triangular_mesh(x, y, z, triangles,\n                             color=(1, 0, 0.4), opacity=0.5)\n\n\nmain()\n"""
test/test_plyfile.py,0,"b'from __future__ import print_function\n\nimport sys\nfrom io import BytesIO\nimport gzip\n\nimport pytest\n\nimport numpy\n\nfrom plyfile import (PlyData, PlyElement, make2d,\n                     PlyHeaderParseError, PlyElementParseError,\n                     PlyProperty)\n\n\ntry:\n    _range = xrange\nexcept NameError:\n    _range = range\n\n\nclass Raises(object):\n\n    \'\'\'\n    Utility: use as a context manager for code that is expected to raise\n    an exception.\n\n    \'\'\'\n    def __init__(self, *exc_types):\n        self._exc_types = set(exc_types)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        assert exc_type in self._exc_types\n        self.exc_type = exc_type\n        self.exc_val = exc_val\n        self.traceback = traceback\n        return True\n\n    def __str__(self):\n        return str(self.exc_val)\n\n\ndef normalize_property(prop):\n    if prop.ndim == 1:\n        return prop\n\n    n = len(prop)\n\n    arr = numpy.empty(n, dtype=\'O\')\n    for k in _range(n):\n        arr[k] = prop[k]\n\n    return arr\n\n\ndef verify(ply0, ply1):\n    \'\'\'\n    Verify that two PlyData instances describe the same data.\n\n    \'\'\'\n    el0 = ply0.elements\n    el1 = ply1.elements\n\n    num_elements = len(el0)\n    assert len(el1) == num_elements\n\n    for k in _range(num_elements):\n        assert el0[k].name == el1[k].name\n\n        data0 = el0[k].data\n        data1 = el1[k].data\n\n        dtype0 = el0[k].dtype().descr\n        dtype1 = el1[k].dtype().descr\n\n        num_properties = len(dtype0)\n        assert len(dtype1) == num_properties\n\n        for j in _range(num_properties):\n            prop_name = dtype0[j][0]\n            assert dtype1[j][0] == prop_name\n\n            prop0 = normalize_property(data0[prop_name])\n            prop1 = normalize_property(data1[prop_name])\n\n            verify_1d(prop0, prop1)\n\n        verify_comments(el0[k].comments, el1[k].comments)\n\n    verify_comments(ply0.comments, ply1.comments)\n    verify_comments(ply0.obj_info, ply1.obj_info)\n\n\ndef verify_1d(prop0, prop1):\n    \'\'\'\n    Verify that two 1-dimensional arrays (possibly of type object)\n    describe the same data.\n\n    \'\'\'\n    n = len(prop0)\n    assert len(prop1) == n\n\n    s0 = prop0.dtype.descr[0][1][1:]\n    s1 = prop1.dtype.descr[0][1][1:]\n\n    assert s0 == s1\n    s = s0[0]\n\n    if s == \'O\':\n        for k in _range(n):\n            assert len(prop0[k]) == len(prop1[k])\n            assert (prop0[k] == prop1[k]).all()\n    else:\n        assert (prop0 == prop1).all()\n\n\ndef verify_comments(comments0, comments1):\n    \'\'\'\n    Verify that comment lists are identical.\n\n    \'\'\'\n    assert len(comments0) == len(comments1)\n    for (comment0, comment1) in zip(comments0, comments1):\n        assert comment0 == comment1\n\n\ndef write_read(ply, tmpdir, name=\'test.ply\'):\n    \'\'\'\n    Utility: serialize/deserialize a PlyData instance through a\n    temporary file.\n\n     \'\'\'\n    filename = tmpdir.join(name)\n    ply.write(str(filename))\n    return PlyData.read(str(filename))\n\n\ndef read_str(string, tmpdir, name=\'test.ply\'):\n    \'\'\'\n    Utility: create a PlyData instance from a string.\n\n    \'\'\'\n    filename = tmpdir.join(name)\n    with filename.open(\'wb\') as f:\n        f.write(string)\n    return PlyData.read(str(filename))\n\n\ndef tet_ply(text, byte_order):\n    vertex = numpy.array([(0, 0, 0),\n                          (0, 1, 1),\n                          (1, 0, 1),\n                          (1, 1, 0)],\n                         dtype=[(\'x\', \'f4\'), (\'y\', \'f4\'), (\'z\', \'f4\')])\n\n    face = numpy.array([([0, 1, 2], 255, 255, 255),\n                        ([0, 2, 3], 255,   0,   0),\n                        ([0, 1, 3],   0, 255,   0),\n                        ([1, 2, 3],   0,   0, 255)],\n                       dtype=[(\'vertex_indices\', \'i4\', (3,)),\n                              (\'red\', \'u1\'), (\'green\', \'u1\'),\n                              (\'blue\', \'u1\')])\n\n    return PlyData(\n        [\n            PlyElement.describe(\n                vertex, \'vertex\',\n                comments=[\'tetrahedron vertices\']\n            ),\n            PlyElement.describe(face, \'face\')\n        ],\n        text=text, byte_order=byte_order,\n        comments=[\'single tetrahedron with colored faces\']\n    )\n\n\n@pytest.fixture(scope=\'function\')\ndef tet_ply_txt():\n    return tet_ply(True, \'=\')\n\n\ntet_ply_ascii = \'\'\'\\\nply\\n\\\nformat ascii 1.0\\n\\\ncomment single tetrahedron with colored faces\\n\\\nelement vertex 4\\n\\\ncomment tetrahedron vertices\\n\\\nproperty float x\\n\\\nproperty float y\\n\\\nproperty float z\\n\\\nelement face 4\\n\\\nproperty list uchar int vertex_indices\\n\\\nproperty uchar red\\n\\\nproperty uchar green\\n\\\nproperty uchar blue\\n\\\nend_header\\n\\\n0 0 0\\n\\\n0 1 1\\n\\\n1 0 1\\n\\\n1 1 0\\n\\\n3 0 1 2 255 255 255\\n\\\n3 0 2 3 255 0 0\\n\\\n3 0 1 3 0 255 0\\n\\\n3 1 2 3 0 0 255\\n\\\n\'\'\'.encode(\'ascii\')\n\nnp_types = [\'i1\', \'u1\', \'i2\', \'u2\', \'i4\', \'u4\', \'f4\', \'f8\']\n\n\ndef test_str(tet_ply_txt):\n    # Nothing to assert; just make sure the call succeeds\n    str(tet_ply_txt)\n\n\ndef test_repr(tet_ply_txt):\n    # Nothing to assert; just make sure the call succeeds\n    repr(tet_ply_txt)\n\n\n@pytest.mark.parametrize(\'np_type\', np_types)\ndef test_property_type(tmpdir, np_type):\n    dtype = [(\'x\', np_type), (\'y\', np_type), (\'z\', np_type)]\n    a = numpy.array([(1, 2, 3), (4, 5, 6)], dtype=dtype)\n\n    ply0 = PlyData([PlyElement.describe(a, \'test\')])\n\n    assert ply0.elements[0].name == \'test\'\n    assert ply0.elements[0].properties[0].name == \'x\'\n    assert ply0.elements[0].properties[0].val_dtype == np_type\n    assert ply0.elements[0].properties[1].name == \'y\'\n    assert ply0.elements[0].properties[1].val_dtype == np_type\n    assert ply0.elements[0].properties[2].name == \'z\'\n    assert ply0.elements[0].properties[2].val_dtype == np_type\n\n    ply1 = write_read(ply0, tmpdir)\n\n    assert ply1.elements[0].name == \'test\'\n    assert ply1.elements[0].data.dtype == dtype\n    verify(ply0, ply1)\n\n\n@pytest.mark.parametrize(\'np_type\', np_types)\ndef test_list_property_type(tmpdir, np_type):\n    a = numpy.array([([0],), ([1, 2, 3],)], dtype=[(\'x\', object)])\n\n    ply0 = PlyData([PlyElement.describe(a, \'test\',\n                                        val_types={\'x\': np_type})])\n\n    assert ply0.elements[0].name == \'test\'\n    assert ply0.elements[0].properties[0].name == \'x\'\n    assert ply0.elements[0].properties[0].val_dtype == np_type\n\n    ply1 = write_read(ply0, tmpdir)\n\n    assert ply1.elements[0].name == \'test\'\n    assert ply1.elements[0].data[0][\'x\'].dtype == numpy.dtype(np_type)\n    verify(ply0, ply1)\n\n\n@pytest.mark.parametrize(\'len_type\',\n                         [\'i1\', \'u1\', \'i2\', \'u2\', \'i4\', \'u4\'])\ndef test_list_property_len_type(tmpdir, len_type):\n    a = numpy.array([([0],), ([1, 2, 3],)], dtype=[(\'x\', object)])\n\n    ply0 = PlyData([PlyElement.describe(a, \'test\',\n                                        len_types={\'x\': len_type})])\n\n    assert ply0.elements[0].name == \'test\'\n    assert ply0.elements[0].properties[0].name == \'x\'\n    assert ply0.elements[0].properties[0].val_dtype == \'i4\'\n    assert ply0.elements[0].properties[0].len_dtype == len_type\n\n    ply1 = write_read(ply0, tmpdir)\n\n    assert ply1.elements[0].name == \'test\'\n    assert ply1.elements[0].data[0][\'x\'].dtype == numpy.dtype(\'i4\')\n    verify(ply0, ply1)\n\n\ndef test_write_stream(tmpdir, tet_ply_txt):\n    ply0 = tet_ply_txt\n    test_file = tmpdir.join(\'test.ply\')\n\n    with test_file.open(\'wb\') as f:\n        tet_ply_txt.write(f)\n\n    ply1 = PlyData.read(str(test_file))\n    verify(ply0, ply1)\n\n\ndef test_read_stream(tmpdir, tet_ply_txt):\n    ply0 = tet_ply_txt\n    test_file = tmpdir.join(\'test.ply\')\n\n    tet_ply_txt.write(str(test_file))\n\n    with test_file.open(\'rb\') as f:\n        ply1 = PlyData.read(f)\n\n    verify(ply0, ply1)\n\n\ndef test_write_read_str_filename(tmpdir, tet_ply_txt):\n    ply0 = tet_ply_txt\n    test_file = tmpdir.join(\'test.ply\')\n    filename = str(test_file)\n\n    tet_ply_txt.write(filename)\n    ply1 = PlyData.read(filename)\n\n    verify(ply0, ply1)\n\n\ndef test_memmap(tmpdir, tet_ply_txt):\n    vertex = tet_ply_txt[\'vertex\']\n    face0 = PlyElement.describe(tet_ply_txt[\'face\'].data, \'face0\')\n    face1 = PlyElement.describe(tet_ply_txt[\'face\'].data, \'face1\')\n\n    # Since the memory mapping requires some manual offset calculation,\n    # check that it\'s done correctly when there are elements before\n    # and after the one that can be memory-mapped.\n    ply0 = PlyData([face0, vertex, face1])\n    ply1 = write_read(ply0, tmpdir)\n\n    verify(ply0, ply1)\n\n\ndef test_copy_on_write(tmpdir, tet_ply_txt):\n    ply0 = tet_ply_txt\n    filename = str(tmpdir.join(\'test.ply\'))\n    ply0.write(filename)\n    ply1 = PlyData.read(filename)\n    ply1[\'vertex\'][\'x\'] += 1\n    ply2 = PlyData.read(filename)\n\n    verify(ply0, ply2)\n\n\n# In Python 3, `unicode\' is not a separate type from `str\' (and the\n# `unicode\' builtin does not exist).  Thus, this test is unnecessary\n# (and indeed would not pass).\n@pytest.mark.skipif(sys.version_info >= (3,),\n                    reason=""only relevant on Python 2"")\ndef test_write_read_unicode_filename(tmpdir, tet_ply_txt):\n    ply0 = tet_ply_txt\n    test_file = tmpdir.join(\'test.ply\')\n    filename = unicode(str(test_file))\n\n    tet_ply_txt.write(filename)\n    ply1 = PlyData.read(filename)\n\n    verify(ply0, ply1)\n\n\ndef test_write_invalid_filename(tet_ply_txt):\n    with Raises(RuntimeError) as e:\n        tet_ply_txt.write(None)\n\n    assert str(e) == ""expected open file or filename""\n\n\ndef test_ascii(tet_ply_txt, tmpdir):\n    test_file = tmpdir.join(\'test.ply\')\n\n    tet_ply_txt.write(str(test_file))\n    assert test_file.read(\'rb\') == tet_ply_ascii\n\n\n@pytest.mark.parametrize(\'text,byte_order\',\n                         [(True, \'=\'), (False, \'<\'), (False, \'>\')])\ndef test_write_read(tet_ply_txt, tmpdir, text, byte_order):\n    ply0 = PlyData(tet_ply_txt.elements, text, byte_order,\n                   tet_ply_txt.comments)\n    ply1 = write_read(ply0, tmpdir)\n    verify(ply0, ply1)\n\n\ndef test_switch_format(tet_ply_txt, tmpdir):\n    ply0 = tet_ply_txt\n    ply1 = write_read(ply0, tmpdir, \'test0.ply\')\n    verify(ply0, ply1)\n    ply1.text = False\n    ply1.byte_order = \'<\'\n    ply2 = write_read(ply1, tmpdir, \'test1.ply\')\n    assert ply2.byte_order == \'<\'\n    verify(ply0, ply2)\n    ply2.byte_order = \'>\'\n    ply3 = write_read(ply2, tmpdir, \'test2.ply\')\n    assert ply3.byte_order == \'>\'\n    verify(ply0, ply3)\n\n\ndef test_invalid_byte_order(tet_ply_txt):\n    with Raises(ValueError):\n        tet_ply_txt.byte_order = \'xx\'\n\n\ndef test_element_lookup(tet_ply_txt):\n    assert tet_ply_txt[\'vertex\'].name == \'vertex\'\n    assert tet_ply_txt[\'face\'].name == \'face\'\n\n\ndef test_property_lookup(tet_ply_txt):\n    vertex = tet_ply_txt[\'vertex\'].data\n    assert (tet_ply_txt.elements[0][\'x\'] == vertex[\'x\']).all()\n    assert (tet_ply_txt.elements[0][\'y\'] == vertex[\'y\']).all()\n    assert (tet_ply_txt.elements[0][\'z\'] == vertex[\'z\']).all()\n\n    face = tet_ply_txt[\'face\'].data\n    assert (tet_ply_txt.elements[1][\'vertex_indices\'] ==\n            face[\'vertex_indices\']).all()\n    assert (tet_ply_txt.elements[1][\'red\'] == face[\'red\']).all()\n    assert (tet_ply_txt.elements[1][\'green\'] == face[\'green\']).all()\n    assert (tet_ply_txt.elements[1][\'blue\'] == face[\'blue\']).all()\n\n\ndef test_obj_info(tmpdir):\n    ply0 = PlyData([], text=True, obj_info=[\'test obj_info\'])\n    test_file = tmpdir.join(\'test.ply\')\n    ply0.write(str(test_file))\n\n    ply0_str = test_file.read(\'rb\').decode(\'ascii\')\n    assert ply0_str.startswith(\'ply\\nformat ascii 1.0\\n\'\n                               \'obj_info test obj_info\\n\')\n\n    ply1 = PlyData.read(str(test_file))\n    assert len(ply1.obj_info) == 1\n    assert ply1.obj_info[0] == \'test obj_info\'\n\n\ndef test_comment_spaces(tmpdir):\n    ply0 = PlyData([], text=True, comments=[\'  test comment\'])\n    test_file = tmpdir.join(\'test.ply\')\n    ply0.write(str(test_file))\n\n    ply0_str = test_file.read(\'rb\').decode(\'ascii\')\n    assert ply0_str.startswith(\'ply\\nformat ascii 1.0\\n\'\n                               \'comment   test comment\\n\')\n\n    ply1 = PlyData.read(str(test_file))\n    assert len(ply1.comments) == 1\n    assert ply1.comments[0] == \'  test comment\'\n\n\ndef test_assign_comments(tet_ply_txt):\n    ply0 = tet_ply_txt\n\n    ply0.comments = [\'comment1\', \'comment2\']\n    ply0.obj_info = [\'obj_info1\', \'obj_info2\']\n    verify_comments(ply0.comments, [\'comment1\', \'comment2\'])\n    verify_comments(ply0.obj_info, [\'obj_info1\', \'obj_info2\'])\n\n    ply0[\'face\'].comments = [\'comment1\']\n    verify_comments(ply0[\'face\'].comments, [\'comment1\'])\n\n\ndef test_assign_comments_newline(tet_ply_txt):\n    ply0 = tet_ply_txt\n\n    with Raises(ValueError):\n        ply0.comments = [\'comment1\\ncomment2\']\n\n    with Raises(ValueError):\n        ply0.obj_info = [\'comment1\\ncomment2\']\n\n    with Raises(ValueError):\n        ply0[\'face\'].comments = [\'comment1\\ncomment2\']\n\n\ndef test_assign_comments_non_ascii(tet_ply_txt):\n    ply0 = tet_ply_txt\n\n    with Raises(ValueError):\n        ply0.comments = [\'\\xb0\']\n\n    with Raises(ValueError):\n        ply0.obj_info = [\'\\xb0\']\n\n    with Raises(ValueError):\n        ply0[\'face\'].comments = [\'\\xb0\']\n\n\ndef test_make2d():\n    a = numpy.empty(2, dtype=object)\n    a[:] = [numpy.array([0, 1, 2]), numpy.array([3, 4, 5])]\n\n    b = make2d(a)\n    assert b.shape == (2, 3)\n    assert (b == [[0, 1, 2], [3, 4, 5]]).all()\n\n\ndef test_reorder_elements(tet_ply_txt, tmpdir):\n    ply0 = tet_ply_txt\n    (vertex, face) = ply0.elements\n    ply0.elements = [face, vertex]\n\n    ply1 = write_read(ply0, tmpdir)\n\n    assert ply1.elements[0].name == \'face\'\n    assert ply1.elements[1].name == \'vertex\'\n\n\ndef test_assign_elements_duplicate(tet_ply_txt):\n    with Raises(ValueError) as e:\n        tet_ply_txt.elements = [tet_ply_txt[\'vertex\'],\n                                tet_ply_txt[\'vertex\']]\n    assert str(e) == ""two elements with same name""\n\n\ndef test_reorder_properties(tet_ply_txt, tmpdir):\n    ply0 = tet_ply_txt\n    vertex = ply0.elements[0]\n    (x, y, z) = vertex.properties\n    vertex.properties = [y, z, x]\n\n    ply1 = write_read(ply0, tmpdir)\n\n    assert ply1.elements[0].properties[0].name == \'y\'\n    assert ply1.elements[0].properties[1].name == \'z\'\n    assert ply1.elements[0].properties[2].name == \'x\'\n\n    verify_1d(ply0[\'vertex\'][\'x\'], ply1[\'vertex\'][\'x\'])\n    verify_1d(ply0[\'vertex\'][\'y\'], ply1[\'vertex\'][\'y\'])\n    verify_1d(ply0[\'vertex\'][\'z\'], ply1[\'vertex\'][\'z\'])\n\n\n@pytest.mark.parametrize(\'text,byte_order\',\n                         [(True, \'=\'), (False, \'<\'), (False, \'>\')])\ndef test_remove_property(tet_ply_txt, tmpdir, text, byte_order):\n    ply0 = tet_ply_txt\n    face = ply0.elements[1]\n    (vertex_indices, r, g, b) = face.properties\n    face.properties = [vertex_indices]\n\n    ply0.text = text\n    ply0.byte_order = byte_order\n\n    ply1 = write_read(ply0, tmpdir)\n\n    assert ply1.text == text\n    assert ply1.byte_order == byte_order\n\n    assert len(ply1.elements[1].properties) == 1\n    assert ply1.elements[1].properties[0].name == \'vertex_indices\'\n\n    verify_1d(normalize_property(ply1[\'face\'][\'vertex_indices\']),\n              normalize_property(face[\'vertex_indices\']))\n\n\ndef test_assign_properties_error(tet_ply_txt):\n    vertex = tet_ply_txt[\'vertex\']\n    with Raises(ValueError) as e:\n        vertex.properties = (vertex.properties +\n                             (PlyProperty(\'xx\', \'i4\'),))\n    assert str(e) == ""dangling property \'xx\'""\n\n\ndef test_assign_properties_duplicate(tet_ply_txt):\n    vertex = tet_ply_txt[\'vertex\']\n    with Raises(ValueError) as e:\n        vertex.properties = (vertex.ply_property(\'x\'),\n                             vertex.ply_property(\'x\'))\n    assert str(e) == ""two properties with same name""\n\n\n@pytest.mark.parametrize(\'text,byte_order\',\n                         [(True, \'=\'), (False, \'<\'), (False, \'>\')])\ndef test_cast_property(tet_ply_txt, tmpdir, text, byte_order):\n    ply0 = tet_ply_txt\n    (vertex, face) = ply0.elements\n    vertex.properties[0].val_dtype = \'f8\'\n    vertex.properties[2].val_dtype = \'u1\'\n\n    assert face.properties[0].len_dtype == \'u1\'\n    face.properties[0].len_dtype = \'i4\'\n\n    ply0.text = text\n    ply0.byte_order = byte_order\n\n    ply1 = write_read(ply0, tmpdir)\n\n    assert ply1.text == text\n    assert ply1.byte_order == byte_order\n\n    assert ply1[\'vertex\'][\'x\'].dtype.descr[0][1][1:] == \'f8\'\n    assert ply1[\'vertex\'][\'y\'].dtype.descr[0][1][1:] == \'f4\'\n    assert ply1[\'vertex\'][\'z\'].dtype.descr[0][1][1:] == \'u1\'\n\n    assert(ply1[\'vertex\'][\'x\'] == vertex[\'x\']).all()\n    assert(ply1[\'vertex\'][\'y\'] == vertex[\'y\']).all()\n    assert(ply1[\'vertex\'][\'z\'] == vertex[\'z\']).all()\n\n    assert ply1[\'face\'].properties[0].len_dtype == \'i4\'\n\n    verify_1d(normalize_property(ply1[\'face\'][\'vertex_indices\']),\n              normalize_property(face[\'vertex_indices\']))\n\n\ndef test_cast_val_error(tet_ply_txt):\n    with Raises(ValueError) as e:\n        tet_ply_txt[\'vertex\'].properties[0].val_dtype = \'xx\'\n    assert str(e).startswith(""field type \'xx\' not in"")\n\n\ndef test_cast_len_error(tet_ply_txt):\n    with Raises(ValueError) as e:\n        tet_ply_txt[\'face\'].properties[0].len_dtype = \'xx\'\n    assert str(e).startswith(""field type \'xx\' not in"")\n\n\ndef ply_abc(fmt, n, data):\n    string = (b""ply\\nformat "" + fmt.encode() + b"" 1.0\\nelement test "" +\n              str(n).encode() + b""\\n""\n              b""property uchar a\\nproperty uchar b\\n property uchar c\\n""\n              b""end_header\\n"")\n    if fmt == \'ascii\':\n        return string + data + b\'\\n\'\n    else:\n        return string + data\n\n\ndef ply_list_a(fmt, n, data):\n    string = (b""ply\\nformat "" + fmt.encode() + b"" 1.0\\nelement test "" +\n              str(n).encode() + b""\\n""\n              b""property list uchar int a\\n""\n              b""end_header\\n"")\n    if fmt == \'ascii\':\n        return string + data + b\'\\n\'\n    else:\n        return string + data\n\n\ninvalid_cases = [\n    (ply_abc(\'ascii\', 1, b\'1 2 3.3\'),\n     ""row 0: property \'c\': malformed input""),\n\n    (ply_list_a(\'ascii\', 1, b\'\'),\n     ""row 0: property \'a\': early end-of-line""),\n\n    (ply_list_a(\'ascii\', 1, b\'3 2 3\'),\n     ""row 0: property \'a\': early end-of-line""),\n\n    (ply_abc(\'ascii\', 1, b\'1 2 3 4\'),\n     ""row 0: expected end-of-line""),\n\n    (ply_abc(\'ascii\', 1, b\'1\'),\n     ""row 0: property \'b\': early end-of-line""),\n\n    (ply_abc(\'ascii\', 2, b\'1 2 3\'),\n     ""row 1: early end-of-file""),\n\n    (ply_abc(\'binary_little_endian\', 1, b\'\\x01\\x02\'),\n     ""row 0: early end-of-file""),\n\n    (ply_list_a(\'binary_little_endian\', 1, b\'\'),\n     ""row 0: property \'a\': early end-of-file""),\n\n    (ply_list_a(\'binary_little_endian\', 1,\n                b\'\\x03\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\'),\n     ""row 0: property \'a\': early end-of-file""),\n\n    (ply_list_a(\'binary_little_endian\', 1, b\'\\x01\\x02\'),\n     ""row 0: property \'a\': early end-of-file""),\n\n    (ply_abc(\'binary_little_endian\', 2, b\'\\x01\\x02\\x03\'),\n     ""row 1: early end-of-file"")\n]\n\n\n@pytest.mark.parametrize(\'s,error_string\', invalid_cases,\n                         ids=list(map(str, _range(len(invalid_cases)))))\ndef test_invalid(tmpdir, s, error_string):\n    with Raises(PlyElementParseError) as e:\n        read_str(s, tmpdir)\n    assert str(e) == ""element \'test\': "" + error_string\n\n\ndef test_assign_elements(tet_ply_txt):\n    test = PlyElement.describe(numpy.zeros(1, dtype=[(\'a\', \'i4\')]),\n                               \'test\')\n    tet_ply_txt.elements = [test]\n    assert len(tet_ply_txt.elements) == 1\n    assert len(tet_ply_txt) == 1\n    assert \'vertex\' not in tet_ply_txt\n    assert \'face\' not in tet_ply_txt\n    assert \'test\' in tet_ply_txt\n\n    for (k, elt) in enumerate(tet_ply_txt):\n        assert elt.name == \'test\'\n        assert k == 0\n\n\ndef test_assign_data(tet_ply_txt):\n    face = tet_ply_txt[\'face\']\n    face.data = face.data[:1]\n\n    assert face.count == 1\n\n\ndef test_assign_data_error(tet_ply_txt):\n    vertex = tet_ply_txt[\'vertex\']\n\n    with Raises(ValueError) as e:\n        vertex.data = vertex[[\'x\', \'z\']]\n    assert str(e) == ""dangling property \'y\'""\n\n\ndef test_invalid_element_names():\n    with Raises(ValueError):\n        PlyElement.describe(numpy.zeros(1, dtype=[(\'a\', \'i4\')]),\n                            \'\\xb0\')\n\n    with Raises(ValueError):\n        PlyElement.describe(numpy.zeros(1, dtype=[(\'a\', \'i4\')]),\n                            \'test test\')\n\n\ndef test_invalid_property_names():\n    with Raises(ValueError):\n        PlyElement.describe(numpy.zeros(1, dtype=[(\'\\xb0\', \'i4\')]),\n                            \'test\')\n\n    with Raises(ValueError):\n        PlyElement.describe(numpy.zeros(1, dtype=[(\'a b\', \'i4\')]),\n                            \'test\')\n\ninvalid_header_cases = [\n    (b\'plyy\\n\', 1),\n    (b\'ply xxx\\n\', 1),\n    (b\'ply\\n\\n\', 2),\n    (b\'ply\\nformat\\n\', 2),\n    (b\'ply\\nelement vertex 0\\n\', 2),\n    (b\'ply\\nformat asciii 1.0\\n\', 2),\n    (b\'ply\\nformat ascii 2.0\\n\', 2),\n    (b\'ply\\nformat ascii 1.0\\n\', 3),\n    (b\'ply\\nformat ascii 1.0\\nelement vertex\\n\', 3),\n    (b\'ply\\nformat ascii 1.0\\nelement vertex x\\n\', 3),\n    (b\'ply\\nformat ascii 1.0\\nelement vertex 0\\n\'\n     b\'property float\\n\', 4),\n    (b\'ply\\nformat ascii 1.0\\nelement vertex 0\\n\'\n     b\'property list float\\n\', 4),\n    (b\'ply\\nformat ascii 1.0\\nelement vertex 0\\n\'\n     b\'property floatt x\\n\', 4),\n    (b\'ply\\nformat ascii 1.0\\nelement vertex 0\\n\'\n     b\'property float x y\\n\', 4),\n    (b\'ply\\nformat ascii 1.0\\nelement vertex 0\\n\'\n     b\'property list ucharr int extra\\n\', 4),\n    (b\'ply\\nformat ascii 1.0\\nelement vertex 0\\n\'\n     b\'property float x\\nend_header xxx\\n\', 5)\n]\n\n\n@pytest.mark.parametrize(\n    \'s,line\', invalid_header_cases,\n    ids=list(map(str, _range(len(invalid_header_cases))))\n)\ndef test_header_parse_error(s, line):\n    with Raises(PlyHeaderParseError) as e:\n        PlyData.read(BytesIO(s))\n    assert e.exc_val.line == line\n\n\ninvalid_arrays = [\n    numpy.zeros((2,2)),\n    numpy.array([(0, (0, 0))],\n                dtype=[(\'x\', \'f4\'), (\'y\', [(\'y0\', \'f4\'), (\'y1\', \'f4\')])]),\n    numpy.array([(0, (0, 0))],\n                dtype=[(\'x\', \'f4\'), (\'y\', \'O\', (2,))])\n]\n\n\n@pytest.mark.parametrize(\n    \'a\', invalid_arrays,\n    ids=list(map(str, _range(len(invalid_arrays))))\n)\ndef test_invalid_array(a):\n    with Raises(ValueError):\n        PlyElement.describe(a, \'test\')\n\n\ndef test_invalid_array_type():\n    with Raises(TypeError):\n        PlyElement.describe([0, 1, 2], \'test\')\n\n\ndef test_header_parse_error_repr():\n    e = PlyHeaderParseError(\'text\', 11)\n    assert repr(e) == \'PlyHeaderParseError(\\\'text\\\', line=11)\'\n\n\ndef test_element_parse_error_repr():\n    prop = PlyProperty(\'x\', \'f4\')\n    elt = PlyElement(\'test\', [prop], 0)\n    e = PlyElementParseError(\'text\', elt, 0, prop)\n    assert repr(e)\n\n\n@pytest.mark.parametrize(\'text,byte_order\',\n                         [(True, \'=\'), (False, \'<\'), (False, \'>\')])\ndef test_gzip_file(tmpdir, tet_ply_txt, text, byte_order):\n    ply0 = tet_ply_txt\n    ply0.text = text\n    ply0.byte_order = byte_order\n    test_file = tmpdir.join(\'test.ply.gz\')\n\n    with gzip.open(str(test_file), \'wb\') as f:\n        tet_ply_txt.write(f)\n\n    with gzip.open(str(test_file), \'rb\') as f:\n        ply1 = PlyData.read(f)\n\n    verify(ply0, ply1)\n\n\n@pytest.mark.parametrize(\'text,byte_order\',\n                         [(True, \'=\'), (False, \'<\'), (False, \'>\')])\ndef test_bytesio(tet_ply_txt, text, byte_order):\n    ply0 = tet_ply_txt\n    ply0.text = text\n    ply0.byte_order = byte_order\n    fw = BytesIO()\n    ply0.write(fw)\n    fr = BytesIO(fw.getvalue())\n    ply1 = PlyData.read(fr)\n    verify(ply0, ply1)\n'"
