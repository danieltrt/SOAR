file_path,api_count,code
main.py,0,"b'#!/usr/bin/env python\n\nimport sys\n\nfrom PyQt5.QtWidgets import QApplication\n\nfrom qt.MainWindow import MainWindow\n\nif __name__ == ""__main__"":\n    app = QApplication(sys.argv)\n    window = MainWindow()\n    window.show()\n    sys.exit(app.exec_())\n'"
canvas/BottleNeckMode.py,0,"b""from .Mode import Mode\n\n\nclass BottleNeckMode(Mode):\n    priority = 1\n    conflict_modes = ['EditMode', 'ShortestPathMode']\n\n    def onSet(self):\n        if self.canvas.g:\n            self.findBottleNeck()\n\n    def onSetGraph(self):\n        self.findBottleNeck()\n\n    def findBottleNeck(self):\n        canvas = self.canvas\n        g = canvas.g\n        clusterOutgoingEdges = {cl: [] for cl in set(g.vs['cluster'])}\n        for e in g.es:\n            targetCluster = g.vs[e.target]['cluster']\n            sourceCluster = g.vs[e.source]['cluster']\n            if targetCluster != sourceCluster:\n                clusterOutgoingEdges[targetCluster].append(e)\n                clusterOutgoingEdges[sourceCluster].append(e)\n        canvas.selectedEdges = []\n        canvas.selectedVertices = []\n        for cluster, edges in clusterOutgoingEdges.items():\n            if len(edges) == 1:\n                e = edges[0]\n                canvas.selectedEdges.append(e)\n                canvas.selectedVertices.append(g.vs[e.target])\n                canvas.selectedVertices.append(g.vs[e.source])\n"""
canvas/Canvas.py,0,"b""from math import sqrt\nfrom typing import Union\n\nimport igraph\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtWidgets import *\nfrom igraph import Graph\nfrom numpy import *\n\nfrom .Mode import Mode\nfrom .utils import *\n\n\nclass Canvas(QWidget):\n    WIDTH = 1120\n    HEIGHT = 760\n\n    SCREEN_RECT_LINE = [\n        QLineF(0, 0, WIDTH, 0),\n        QLineF(WIDTH, 0, WIDTH, HEIGHT),\n        QLineF(WIDTH, HEIGHT, 0, HEIGHT),\n        QLineF(0, HEIGHT, 0, 0)\n    ]\n\n    SCREEN_RECT = QRectF(0, 0, WIDTH, HEIGHT)\n\n    POINT_RADIUS = 8\n    SELECTED_POINT_RADIUS = 12\n    LINE_DISTANCE = 2\n    CURVE_SELECT_SQUARE_SIZE = 10\n\n    DEFAULT_CLUSTERING_ALGO = 'community_edge_betweenness'\n    DEFAULT_GRAPH_LAYOUT = 'layout_circle'\n\n    def __init__(self, width: int, height: int):\n        super().__init__(None)\n\n        self.WIDTH = width\n        self.HEIGHT = height\n        self.SCREEN_RECT = QRectF(0, 0, width, height)\n        self.SCREEN_RECT_LINE = [\n            QLineF(0, 0, width, 0),\n            QLineF(width, 0, width, height),\n            QLineF(width, height, 0, height),\n            QLineF(0, height, 0, 0)\n        ]\n\n        self.center = self.zoom = None\n        self.backgroundDragging = None\n        self.selectedEdges = self.selectedVertices = []\n        self.viewRect = self.verticesToDraw = self.edgesToDraw = None\n\n        self.modes = []\n        self.g = None\n\n    def toScaledXY(self, x, y):\n        return self.toScaledX(x), self.toScaledY(y)\n\n    def toScaledX(self, x):\n        return float((x - self.viewRect.x()) * self.zoom)\n\n    def toScaledY(self, y):\n        return float((y - self.viewRect.y()) * self.zoom)\n\n    def toAbsoluteXY(self, x, y):\n        return self.toAbsoluteX(x), self.toAbsoluteY(y)\n\n    def toAbsoluteX(self, x):\n        return float(x / self.zoom + self.viewRect.x())\n\n    def toAbsoluteY(self, y):\n        return float(y / self.zoom + self.viewRect.y())\n\n    def setGraph(self, g: Union[str, Graph]):\n        if isinstance(g, str):\n            g = igraph.read(g)\n        self.g = g\n        g.vs['degree'] = [v.degree() for v in g.vs]\n        for mode in self.modes:\n            if mode.onSetGraph():\n                break\n        self.notifyGraphUpdated()\n        self.resetViewRect()\n        self.update()\n\n    def notifyGraphUpdated(self):\n        for mode in self.modes:\n            if mode.onUpdateGraph():\n                break\n\n    def addMode(self, mode: Mode):\n        if mode in self.modes:\n            mode.onUnset()\n            mode.onSet()\n            self.update()\n            return\n\n        def isConflict(m: Mode):\n            if m.__class__.__name__ in mode.conflict_modes:\n                return True\n            return False\n\n        mode.canvas = self\n        mode.onSet()\n        modes = []\n        for m in self.modes:\n            if isConflict(m):\n                m.onUnset()\n            else:\n                modes.append(m)\n        self.modes = sorted(modes + [mode], key=lambda m: m.priority)\n        self.update()\n\n    def removeMode(self, mode: Mode):\n        if mode in self.modes:\n            self.modes.remove(mode)\n            mode.onUnset()\n            return True\n        return False\n\n    def resetViewRect(self):\n        for mode in self.modes:\n            if mode.onResetViewRect():\n                break\n\n        self.center = QPointF(self.WIDTH / 2, self.HEIGHT / 2)\n        self.zoom = 1\n        self.backgroundDragging = None\n        self.selectedEdges = []\n        self.selectedVertices = []\n\n        self.updateViewRect()\n\n    def updateViewRect(self):\n        viewRectWidth = self.WIDTH / self.zoom\n        viewRectHeight = self.HEIGHT / self.zoom\n        viewRectX = self.center.x() - viewRectWidth / 2\n        viewRectY = self.center.y() - viewRectHeight / 2\n        self.viewRect = QRectF(viewRectX, viewRectY, viewRectWidth, viewRectHeight)\n\n        def intersectWithViewRect(line):\n            if isinstance(line, QLineF):\n                return any([line.intersect(vrl, QPointF()) == 1 for vrl in self.SCREEN_RECT_LINE])\n            return line.intersects(self.SCREEN_RECT)\n\n        def inScreen(edge):\n            return self.SCREEN_RECT.contains(self.g.vs[edge.source]['pos']) \\\n                   or self.SCREEN_RECT.contains(self.g.vs[edge.target]['pos'])\n\n        self.g.vs['pos'] = [QPointF(\n            self.toScaledX(v['x']),\n            self.toScaledY(v['y'])\n        ) for v in self.g.vs]\n\n        multipleEdge = {}\n        for e in self.g.es:\n            count = e.count_multiple()\n            key = (e.source, e.target)\n            if count > 1 and key not in multipleEdge:\n                p1 = self.g.vs[e.source]['pos']\n                p2 = self.g.vs[e.target]['pos']\n                midPoint = QPointF((p1.x() + p2.x()) / 2, (p1.y() + p2.y()) / 2)\n                normalVector = QVector2D(p1.y() - p2.y(), p2.x() - p1.x())\n                startVector = QVector2D(midPoint.x() - normalVector.x() / 2, midPoint.y() - normalVector.y() / 2)\n                incVector = normalVector / (count - 1)\n                multipleEdge[key] = [(p1, p2, (startVector + incVector * i).toPointF())\n                                     for i in range(count)]\n\n        def createLine(edge):\n            result = multipleEdge.get((edge.source, edge.target))\n            if result:\n                pos1, pos2, controlPoint = result.pop()\n                path = QPainterPath(pos1)\n                path.quadTo(controlPoint, pos2)\n                path.quadTo(controlPoint, pos1)\n                return path\n            return QLineF(\n                self.g.vs[edge.source]['pos'],\n                self.g.vs[edge.target]['pos'],\n            )\n\n        self.g.es['line'] = [createLine(e) for e in self.g.es]\n\n        self.verticesToDraw = [v for v in self.g.vs if self.viewRect.contains(v['x'], v['y'])]\n\n        linesInScreen = {e for e in self.g.es if inScreen(e)}\n        linesIntersectScreen = {e for e in self.g.es if intersectWithViewRect(e['line'])}\n        self.edgesToDraw = list(linesInScreen.union(linesIntersectScreen))\n\n        for mode in self.modes:\n            if mode.onUpdateViewRect():\n                break\n\n    def paintEvent(self, event):\n        self.updateViewRect()\n        painter = QPainter()\n        painter.begin(self)\n        self.paint(painter)\n        painter.end()\n\n    def paint(self, painter):\n        for mode in self.modes:\n            if mode.onPaintBegin(painter):\n                break\n\n        for mode in self.modes:\n            if mode.beforePaintEdges(painter):\n                break\n        for edge in self.edgesToDraw:\n            painter.setPen(edge['color'])\n            line = edge['line']\n            if isinstance(line, QLineF):\n                painter.drawLine(line)\n            else:\n                painter.drawPath(line)\n\n        for mode in self.modes:\n            if mode.beforePaintVertices(painter):\n                break\n        for vertex in self.verticesToDraw:\n            painter.setBrush(vertex['color'])\n            painter.drawEllipse(\n                int(vertex['pos'].x() - self.POINT_RADIUS / 2.0),\n                int(vertex['pos'].y() - self.POINT_RADIUS / 2.0),\n                self.POINT_RADIUS, self.POINT_RADIUS\n            )\n\n        for mode in self.modes:\n            if mode.beforePaintSelectedEdges(painter):\n                break\n        for edge in self.selectedEdges:\n            line = edge['line']\n            if isinstance(line, QLineF):\n                painter.drawLine(line)\n            else:\n                painter.drawPath(line)\n\n        for mode in self.modes:\n            if mode.beforePaintSelectedVertices(painter):\n                break\n        for vertex in self.selectedVertices:\n            painter.setBrush(vertex['color'])\n            painter.drawEllipse(\n                int(vertex['pos'].x() - self.POINT_RADIUS / 2.0),\n                int(vertex['pos'].y() - self.POINT_RADIUS / 2.0),\n                self.POINT_RADIUS, self.POINT_RADIUS\n            )\n\n    def zoomInEvent(self):\n        self.zoom *= 1.2\n        self.update()\n\n    def zoomOutEvent(self):\n        self.zoom /= 1.2\n        self.update()\n\n    def zoomResetEvent(self):\n        self.zoom = 1\n        self.center = QPointF(self.WIDTH / 2, self.HEIGHT / 2)\n        self.update()\n\n    def wheelEvent(self, event):\n        self.zoom += event.angleDelta().y() / 120 * 0.05\n        self.update()\n\n    def mousePressEvent(self, event):\n        pos = event.pos()\n\n        clickedSquare = QPainterPath(pos)\n        clickedSquare.addRect(QRectF(\n            pos.x() - self.CURVE_SELECT_SQUARE_SIZE / 2,\n            pos.y() - self.CURVE_SELECT_SQUARE_SIZE / 2,\n            self.CURVE_SELECT_SQUARE_SIZE,\n            self.CURVE_SELECT_SQUARE_SIZE\n        ))\n\n        def clickToLine(line):\n            if isinstance(line, QLineF):\n                try:\n                    d = abs((line.x2() - line.x1()) * (line.y1() - pos.y()) - (line.x1() - pos.x()) *\n                            (line.y2() - line.y1())) / sqrt((line.x2() - line.x1()) ** 2 + (line.y2() - line.y1()) ** 2)\n                except ZeroDivisionError:\n                    return False\n                return d < self.LINE_DISTANCE and min(line.x1(), line.x2()) < pos.x() < max(line.x1(), line.x2())\n\n            return line.intersects(clickedSquare)\n\n        def clickedToPoint(point):\n            return self.POINT_RADIUS ** 2 >= (point.x() - pos.x()) ** 2 + (point.y() - pos.y()) ** 2\n\n        for v in self.verticesToDraw:\n            if clickedToPoint(v['pos']):\n                for mode in self.modes:\n                    if mode.onSelectVertex(v):\n                        break\n                self.update()\n                return\n\n        for e in self.edgesToDraw:\n            if clickToLine(e['line']):\n                for mode in self.modes:\n                    if mode.onSelectEdge(e):\n                        break\n                self.update()\n                return\n\n        for mode in self.modes:\n            if mode.onSelectBackground(pos):\n                return\n\n        self.backgroundDragging = pos\n        self.update()\n\n    def mouseMoveEvent(self, event):\n        pos = event.pos()\n        if self.backgroundDragging is not None:\n            self.center = QPointF(\n                self.center.x() + (self.backgroundDragging.x() - pos.x()) / self.zoom,\n                self.center.y() + (self.backgroundDragging.y() - pos.y()) / self.zoom,\n            )\n            self.backgroundDragging = pos\n        else:\n            for mode in self.modes:\n                if mode.onMouseMove(pos):\n                    break\n        self.update()\n\n    def mouseReleaseEvent(self, event):\n        self.backgroundDragging = None\n        for mode in self.modes:\n            if mode.onMouseRelease(event.pos()):\n                return\n"""
canvas/CentralityMode.py,0,"b""from .Mode import Mode\nfrom .utils import arrayToSpectrum\n\nCENTRALITY_OPTIONS = [\n    ['Closeness', 'closeness'],\n    ['Betweenness', 'betweenness'],\n    ['Eigenvector', 'evcent']\n]\n\n\nclass CentralityMode(Mode):\n    priority = 3\n    conflict_modes = ['ClusterVerticesMode', 'VertexAttrColorMode']\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.centrality = None\n        self.weight = None\n\n    def onSet(self):\n        self.gui.spectrum.show()\n        if self.canvas.g:\n            self.applyCentrality()\n\n    def onUnset(self):\n        self.gui.spectrum.hide()\n\n    def onSetGraph(self):\n        self.applyCentrality()\n\n    def onUpdateGraph(self):\n        self.applyCentrality()\n\n    def applyCentrality(self):\n        centrality = getattr(self.canvas.g, self.centrality)(weights=self.weight)\n        self.canvas.g.vs['color'] = arrayToSpectrum(centrality)\n"""
canvas/ClusterVerticesMode.py,0,"b""from igraph import VertexDendrogram\n\nfrom .Mode import Mode\nfrom .utils import randomColor\n\nCLUSTERING_ALGO_OPTIONS = [\n    ['Fast Greedy', 'community_fastgreedy'],\n    ['Info Map', 'community_infomap'],\n    ['Leading eigenvector', 'community_leading_eigenvector'],\n    ['Label Propagation', 'community_label_propagation'],\n    ['Multilevel', 'community_multilevel'],\n    ['Edge Betweenness', 'community_edge_betweenness'],\n    ['Walktrap', 'community_walktrap']\n]\n\n\nclass ClusterVerticesMode(Mode):\n    priority = 3\n    conflict_modes = ['VertexAttrColorMode', 'CentralityMode']\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.weight = None\n        self.clusterAlgo = 'community_fastgreedy'\n\n    def onSet(self):\n        if self.canvas.g:\n            self.applyClusteringAlgo()\n\n    def onSetGraph(self):\n        g = self.canvas.g\n        if 'cluster' not in g.vs.attributes():\n            self.applyClusteringAlgo()\n        else:\n            clusterToColor = {cl: randomColor() for cl in set(g.vs['cluster'])}\n            g.vs['color'] = [clusterToColor[v['cluster']] for v in g.vs]\n\n    def applyClusteringAlgo(self):\n        g = self.canvas.g\n        clusterFunc = getattr(g, self.clusterAlgo)\n        if self.clusterAlgo == 'community_infomap':\n            clusters = clusterFunc(edge_weights=self.weight)\n        else:\n            clusters = clusterFunc(weights=self.weight)\n        if isinstance(clusters, VertexDendrogram):\n            clusters = clusters.as_clustering()\n        clusters = clusters.subgraphs()\n\n        def getClusterId(vertex):\n            for cluster in clusters:\n                if vertex['id'] in cluster.vs['id']:\n                    return str(id(cluster))\n\n        clusterToColor = {str(id(cl)): randomColor() for cl in clusters}\n        g.vs['cluster'] = [getClusterId(v) for v in g.vs]\n        g.vs['color'] = [clusterToColor[v['cluster']] for v in g.vs]\n"""
canvas/EdgeAttrColorMode.py,0,"b""from PyQt5.QtGui import QPen\n\nfrom .Mode import Mode\nfrom .utils import arrayToSpectrum, randomColor\n\n\nclass EdgeAttrColorMode(Mode):\n    priority = 3\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.attr = None\n\n    def onSet(self):\n        self.gui.spectrum.show()\n        if self.canvas.g:\n            self.setEdgesColor()\n\n    def onUnset(self):\n        self.gui.spectrum.hide()\n\n    def onSetGraph(self):\n        self.setEdgesColor()\n\n    def onUpdateGraph(self):\n        self.setEdgesColor()\n\n    def setEdgesColor(self):\n        if self.attr is not None:\n            self.canvas.g.es['color'] = [QPen(c, 2) for c in arrayToSpectrum(self.canvas.g.es[self.attr])]\n        # else:\n        #     self.canvas.g.es['color'] = [randomColor()] * self.canvas.g.ecount()\n"""
canvas/EditMode.py,0,"b""from PyQt5.QtCore import Qt\n\nfrom .Mode import Mode\n\n\nclass EditMode(Mode):\n    conflict_modes = ['ShortestPathMode', 'BottleNeckMode']\n    priority = 1\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.addVertex = self.addEdge = self.deleteVertex = self.deleteEdge = False\n\n    def reset(self):\n        self.addVertex = self.addEdge = self.deleteVertex = self.deleteEdge = False\n\n    def onSet(self):\n        self.canvas.selectedVertices = []\n        self.canvas.selectedEdges = []\n\n    def onUnset(self):\n        self.reset()\n\n    def onSetGraph(self):\n        self.reset()\n\n    def onSelectVertex(self, vertex):\n        if self.deleteVertex:\n            if vertex in self.canvas.selectedVertices:\n                self.canvas.selectedVertices.remove(vertex)\n            self.canvas.g.delete_vertices(vertex)\n            self.deleteVertex = False\n            self.canvas.notifyGraphUpdated()\n            return\n\n        if self.addEdge:\n            sv = self.canvas.selectedVertices\n            if len(sv) == 2:\n                self.canvas.selectedVertices = []\n            sv.append(vertex)\n            if len(sv) == 2:\n                self.canvas.g.add_edge(sv[0], sv[1])\n                self.canvas.selectedVertices = []\n                self.addEdge = False\n            self.canvas.notifyGraphUpdated()\n            return\n\n        self.gui.displayVertex(vertex)\n        self.canvas.selectedVertices = [vertex]\n        self.canvas.selectedEdges = []\n\n    def onSelectEdge(self, edge):\n        if self.deleteEdge:\n            if edge in self.canvas.selectedEdges:\n                self.canvas.selectedEdges.remove(edge)\n            self.canvas.g.delete_edges(edge)\n            self.deleteEdge = False\n            self.canvas.notifyGraphUpdated()\n            return\n\n        self.gui.displayEdge(edge)\n        self.canvas.selectedEdges = [edge]\n        self.canvas.selectedVertices = []\n\n    def onSelectBackground(self, pos):\n        if self.addVertex:\n            self.canvas.g.add_vertex(\n                name=None,\n                x=self.canvas.toAbsoluteX(pos.x()),\n                y=self.canvas.toAbsoluteY(pos.y()),\n                cluster=0,\n                color=Qt.white,\n                pos=pos,\n            )\n            self.canvas.notifyGraphUpdated()\n            self.addVertex = False\n\n        super().onSelectBackground(pos)\n\n    def onMouseMove(self, pos):\n        if len(self.canvas.selectedVertices) > 0:\n            vertex = self.canvas.selectedVertices[0]\n            vertex['x'] = self.canvas.toAbsoluteX(pos.x())\n            vertex['y'] = self.canvas.toAbsoluteY(pos.y())\n\n    def setDeleteEdge(self):\n        self.reset()\n        self.deleteEdge = True\n\n    def setDeleteVertex(self):\n        self.reset()\n        self.deleteVertex = True\n\n    def setAddEdge(self):\n        self.reset()\n        self.addEdge = True\n\n    def setAddVertex(self):\n        self.reset()\n        self.addVertex = True\n"""
canvas/FilterEdgeMode.py,0,"b""from .Mode import Mode\n\n\nclass FilterEdgeMode(Mode):\n    priority = 3\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.attr = None\n        self.left = None\n        self.right = None\n\n    def onUpdateViewRect(self):\n        if self.attr is not None:\n            self.canvas.edgesToDraw = list(filter(\n                lambda e: self.left < e[self.attr] < self.right,\n                self.canvas.edgesToDraw\n            ))\n\n    def setFilters(self, attr=None, left=float('-inf'), right=float('inf')):\n        self.attr = attr\n        self.left = left\n        self.right = right\n"""
canvas/LayoutMode.py,0,"b""from .Mode import Mode\n\nLAYOUT_OPTIONS = [\n    ['Auto', 'auto'],\n    ['Circle', 'layout_circle'],\n    ['Distributed Recursive', 'layout_drl'],\n    ['Fruchterman-Reingold', 'layout_fruchterman_reingold'],\n    ['Graphopt', 'layout_graphopt'],\n    ['Grid', 'layout_grid'],\n    ['Kamada-Kawai', 'layout_kamada_kawai'],\n    ['Large Graph', 'layout_lgl'],\n    ['MDS', 'layout_mds'],\n    ['Random', 'layout_random'],\n    ['Reingold-Tilford', 'layout_reingold_tilford'],\n    ['Reingold-Tilford Circular', 'layout_reingold_tilford_circular'],\n    ['Star', 'layout_star']\n]\n\nLAYOUT_WITH_WEIGHT = ['layout_drl', 'layout_fruchterman_reingold']\n\n\nclass LayoutMode(Mode):\n    priority = 2\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.layoutName = 'auto'\n        self.weights = None\n        self.initXY = None\n\n    def onSetGraph(self):\n        self.backupInitXY()\n        self.applyLayout()\n\n    def onResetViewRect(self):\n        g = self.canvas.g\n        vsAttributes = g.vs.attributes()\n\n        # if xy not in graph data, use default layout\n        if 'x' not in vsAttributes or 'y' not in vsAttributes:\n            layout = g.layout_reingold_tilford_circular()\n            for c, v in zip(layout.coords, g.vs):\n                v['x'] = c[0]\n                v['y'] = c[1]\n\n        # scale coordinates to screen\n        mx = min(g.vs['x']) - 1\n        my = min(g.vs['y']) - 1\n        g.vs['x'] = [x - mx for x in g.vs['x']]\n        g.vs['y'] = [y - my for y in g.vs['y']]\n\n        mx = max(g.vs['x'])\n        my = max(g.vs['y'])\n        if mx / my > self.canvas.WIDTH / self.canvas.HEIGHT:\n            scale = self.canvas.WIDTH / mx\n        else:\n            scale = self.canvas.HEIGHT / my\n\n        g.vs['x'] = [x * scale for x in g.vs['x']]\n        g.vs['y'] = [y * scale for y in g.vs['y']]\n\n    def backupInitXY(self):\n        self.onResetViewRect()\n        self.initXY = {v: (v['x'], v['y']) for v in self.canvas.g.vs}\n\n    def applyLayout(self):\n        if self.layoutName == 'auto':\n            for v in self.canvas.g.vs:\n                coor = self.initXY.get(v)\n                if coor:\n                    v['x'] = coor[0]\n                    v['y'] = coor[1]\n        else:\n            layoutFunc = getattr(self.canvas.g, self.layoutName)\n            if self.layoutName in LAYOUT_WITH_WEIGHT:\n                layout = layoutFunc(weights=self.weights)\n            else:\n                layout = layoutFunc()\n            for c, v in zip(layout.coords, self.canvas.g.vs):\n                v['x'] = c[0]\n                v['y'] = c[1]\n        self.canvas.resetViewRect()\n\n    def setLayout(self, layoutName, weights=None):\n        self.layoutName = layoutName\n        self.weights = weights\n        self.applyLayout()\n        self.canvas.update()\n"""
canvas/Mode.py,0,"b'from abc import ABC\n\n\nclass Mode(ABC):\n    conflict_modes = []\n    priority = None\n\n    def __init__(self, gui):\n        self.gui = gui\n        self.canvas = gui.canvas\n\n    def onSet(self):\n        pass\n\n    def onUnset(self):\n        pass\n\n    def onSetGraph(self):\n        pass\n\n    def onUpdateGraph(self):\n        pass\n\n    def onResetViewRect(self):\n        pass\n\n    def onUpdateViewRect(self):\n        pass\n\n    def onPaintBegin(self, painter):\n        pass\n\n    def beforePaintEdges(self, painter):\n        pass\n\n    def beforePaintVertices(self, painter):\n        pass\n\n    def beforePaintSelectedEdges(self, painter):\n        pass\n\n    def beforePaintSelectedVertices(self, painter):\n        pass\n\n    def onSelectVertex(self, vertex):\n        pass\n\n    def onSelectEdge(self, edge):\n        pass\n\n    def onSelectBackground(self, pos):\n        pass\n\n    def onMouseMove(self, pos):\n        pass\n\n    def onMouseRelease(self, pos):\n        pass\n'"
canvas/RealTimeMode.py,0,"b'from threading import Thread\nfrom time import sleep\n\nfrom numpy import random\n\nfrom .Mode import Mode\n\n\nclass RealTimeMode(Mode):\n    priority = 4\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.vertexAttr = None\n        self.edgeAttr = None\n        self.fps = None\n        self.inRealtimeMode = None\n        self.thread = None\n\n    def onSet(self):\n        self.inRealtimeMode = True\n        self.thread = Thread(target=self.doRealTime, daemon=True)\n        self.thread.start()\n\n    def onUnset(self):\n        self.inRealtimeMode = False\n        self.thread.join()\n\n    def doRealTime(self):\n        g = self.canvas.g\n        print(""Do real time "" ,self.vertexAttr)\n        while self.inRealtimeMode:\n            if len(self.vertexAttr) > 0:\n                for v in self.vertexAttr:\n                    if v[0] == ""Normal Distribution"":\n                        g.vs[v[2]] = [abs(random.normal(i, v[1])) for i in g.vs[v[2]]]\n                    else:\n                        g.vs[v[2]] = [abs(random.uniform(i - v[1], i + v[1])) for i in g.vs[v[2]]]\n\n            if len(self.edgeAttr) > 0:\n                for edge in self.edgeAttr:\n                    if edge[0] == ""Normal Distribution"":\n                        g.es[edge[2]] = [abs(random.normal(i, edge[1])) for i in g.es[edge[2]]]\n                    else:\n                        g.es[edge[2]] = [abs(random.uniform(i - edge[1], i + edge[1])) for i in g.es[edge[2]]]\n\n            self.canvas.notifyGraphUpdated()\n            self.canvas.update()\n            sleep(1.0 / self.fps)\n'"
canvas/ShortestPathMode.py,0,"b""from .Mode import Mode\n\n\nclass ShortestPathMode(Mode):\n    conflict_modes = ['EditMode', 'BottleNeckMode']\n    priority = 1\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.weight = None\n        self.src = self.dst = None\n\n    def onSet(self):\n        self.canvas.selectedVertices = []\n        self.canvas.selectedEdges = []\n\n    def onUpdateGraph(self):\n        self.findShortestPath()\n\n    def onSelectVertex(self, vertex):\n        self.gui.displayVertex(vertex)\n        canvas = self.canvas\n        svl = len(canvas.selectedVertices)\n        if svl != 1:\n            canvas.selectedVertices = [vertex]\n            canvas.selectedEdges = []\n        else:\n            canvas.selectedVertices.append(vertex)\n            self.src, self.dst = canvas.selectedVertices\n            self.findShortestPath()\n\n    def findShortestPath(self):\n        canvas = self.canvas\n        g = canvas.g\n        path = g.get_shortest_paths(\n            self.src,\n            self.dst,\n            self.weight,\n            output='epath'\n        )\n        if path[0]:\n            canvas.selectedEdges = [g.es[i] for i in path[0]]\n            canvas.selectedVertices = [g.vs[e.source] for e in canvas.selectedEdges] + [self.dst]\n"""
canvas/VertexAttrColorMode.py,0,"b""from .Mode import Mode\nfrom .utils import randomColor\nfrom PyQt5.QtGui import QBrush\n\nclass VertexAttrColorMode(Mode):\n    priority = 3\n    conflict_modes = ['ClusterVerticesMode', 'CentralityMode']\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.attr = None\n\n    def onSet(self):\n        if self.canvas.g:\n            self.applyAttrColor()\n\n    def onSetGraph(self):\n        if 'cluster' not in self.canvas.g.vs.attributes():\n            self.applyAttrColor()\n        else:\n            clusterToColor = {cl: randomColor() for cl in set(self.canvas.g.vs['cluster'])}\n            for v in self.canvas.g.vs:\n                v['color'] = clusterToColor[v['cluster']]\n\n    def applyAttrColor(self):\n        g = self.canvas.g\n        if self.attr is None:\n            g.vs['cluster'] = [0] * g.vcount()\n            g.vs['color'] = [randomColor()] * g.vcount()\n        else:\n            g.vs['cluster'] = g.vs[self.attr]\n            clusterToColor = {cl: randomColor() for cl in set(g.vs[self.attr])}\n            for v in g.vs:\n                v['color'] = clusterToColor[v['cluster']]\n"""
canvas/ViewMode.py,0,"b""from abc import ABC\nfrom math import radians, pi, log, tan, isnan\n\nfrom PyQt5.QtCore import Qt, QRectF\nfrom PyQt5.QtGui import QPainter, QBrush, QPen, QImage, QColor\n\nfrom .Mode import Mode\n\n\nclass ViewMode(Mode, ABC):\n    priority = 0\n\n    backgroundBrush = None\n    backgroundPen = None\n    foregroundBrush = None\n    foregroundPen = None\n    selectedPen = QPen(QColor(255, 0, 0), 4)\n\n    def onSet(self):\n        g = self.canvas.g\n        if g:\n            g.es['color'] = [self.foregroundPen] * g.ecount()\n            g.vs['color'] = [self.foregroundBrush] * g.vcount()\n\n    def onSetGraph(self):\n        g = self.canvas.g\n        if 'color' not in g.es.attributes():\n            g.es['color'] = [self.foregroundPen] * g.ecount()\n        override = False\n        if 'color' in g.vs.attributes() and g.vcount() > 0 and isinstance(g.vs[0]['color'], str):\n            g.vs['cluster'] = g.vs['color']\n            g.vs['color'] = [QBrush(QColor(c)) for c in g.vs['color']]\n            override = True\n        if 'color' in g.es.attributes() and g.ecount() > 0 and isinstance(g.es[0]['color'], str):\n            g.es['cluster'] = g.es['color']\n            g.es['color'] = [QPen(QColor(c)) for c in g.es['color']]\n            override = True\n        if override:\n            return True\n        if 'cluster' not in g.vs.attributes():\n            g.vs['color'] = [self.foregroundBrush] * g.vcount()\n\n    def onUpdateGraph(self):\n        for e in self.canvas.g.es:\n            if not e['color']:\n                e['color'] = self.foregroundPen\n        for v in self.canvas.g.vs:\n            if not v['color']:\n                v['color'] = self.foregroundBrush\n\n    def onPaintBegin(self, painter: QPainter):\n        painter.fillRect(self.canvas.SCREEN_RECT, self.backgroundBrush)\n\n    def beforePaintEdges(self, painter):\n        painter.setPen(self.foregroundPen)\n\n    def beforePaintVertices(self, painter):\n        painter.setPen(self.backgroundPen)\n\n    def beforePaintSelectedEdges(self, painter):\n        painter.setPen(self.selectedPen)\n\n    def onSelectEdge(self, edge):\n        return\n\n    def onSelectVertex(self, vertex):\n        return\n\n\nclass DarkViewMode(ViewMode):\n    conflict_modes = ['LightViewMode', 'GeoViewMode']\n    backgroundBrush = QBrush(Qt.black)\n    backgroundPen = QPen(Qt.black)\n    foregroundBrush = QBrush(Qt.white)\n    foregroundPen = QPen(Qt.white)\n\n\nclass LightViewMode(ViewMode):\n    conflict_modes = ['DarkViewMode', 'GeoViewMode']\n    backgroundBrush = QBrush(Qt.white)\n    backgroundPen = QPen(Qt.white)\n    foregroundBrush = QBrush(Qt.darkBlue)\n    foregroundPen = QPen(Qt.black)\n\n\nclass GeoViewMode(ViewMode):\n    conflict_modes = ['LightViewMode', 'DarkViewMode']\n    backgroundPen = QPen(Qt.black)\n    foregroundPen = QPen(Qt.black)\n    foregroundBrush = QBrush(Qt.green)\n\n    def __init__(self, gui):\n        super().__init__(gui)\n        self.backGroundImage = QImage('resource/gui/maptovl.png')\n        self.backgroundRect = None\n\n    def geolocationToXY(self, longitude, latitude):\n        x = (longitude + 180) * (self.canvas.WIDTH / 360)\n        latRad = radians(latitude)\n        mercN = log(tan((pi / 4) + (latRad / 2)))\n        y = (self.canvas.HEIGHT / 2) - (self.canvas.WIDTH * mercN / (2 * pi))\n        return x, y\n\n    def onResetViewRect(self):\n        for v in self.canvas.g.vs:\n            longitude = v['Longitude']\n            latitude = v['Latitude']\n            if isnan(longitude) or isnan(latitude):\n                v['x'] = self.canvas.WIDTH / 2\n                v['y'] = self.canvas.HEIGHT / 2 + 150\n            else:\n                x, y = self.geolocationToXY(longitude, latitude)\n                v['x'] = x\n                v['y'] = y + 150\n        return True\n\n    def onUpdateViewRect(self):\n        scale = self.backGroundImage.width() / self.canvas.WIDTH\n        self.backgroundRect = QRectF(\n            self.canvas.viewRect.x() * scale,\n            self.canvas.viewRect.y() * scale,\n            self.canvas.viewRect.width() * scale,\n            self.canvas.viewRect.height() * scale\n        )\n\n    def onPaintBegin(self, painter: QPainter):\n        painter.drawImage(\n            self.canvas.SCREEN_RECT,\n            self.backGroundImage,\n            self.backgroundRect\n        )\n"""
canvas/__init__.py,0,"b'from .Canvas import Canvas\n\nfrom .ViewMode import DarkViewMode, LightViewMode, GeoViewMode\n\nfrom .EditMode import EditMode\nfrom .ShortestPathMode import ShortestPathMode\nfrom .BottleNeckMode import BottleNeckMode\n\nfrom .LayoutMode import LayoutMode, LAYOUT_OPTIONS, LAYOUT_WITH_WEIGHT\n\nfrom .ClusterVerticesMode import ClusterVerticesMode, CLUSTERING_ALGO_OPTIONS\nfrom .CentralityMode import CentralityMode, CENTRALITY_OPTIONS\nfrom .VertexAttrColorMode import VertexAttrColorMode\nfrom .EdgeAttrColorMode import EdgeAttrColorMode\nfrom .FilterEdgeMode import FilterEdgeMode\n\nfrom .RealTimeMode import RealTimeMode\n'"
canvas/utils.py,0,"b""from math import sin, pi\nfrom random import choice\n\nfrom PyQt5.QtGui import *\n\nDARK_MODE = 'Dark mode'\nLIGHT_MODE = 'Light mode'\nGEO_MODE = 'Geo mode'\n\nLAYOUT_WITH_WEIGHT = ['layout_drl', 'layout_fruchterman_reingold']\n\n\ndef randomColor():\n    return QColor(choice(range(0, 256)), choice(range(0, 256)), choice(range(0, 256)))\n\n\ndef arrayToSpectrum(arr):\n    def g(i):\n        return 255 * (i + 1) / 2.0\n\n    def f(start, stop, N):\n        interval = (stop - start) / N\n        for i in range(N):\n            coefficient = start + interval * i\n            yield int(g(sin(coefficient * pi)))\n\n    uniqueValues = set(arr)\n    n = len(uniqueValues)\n    RED = f(0.5, 1.5, n)\n    GREEN = f(1.5, 3.5, n)\n    BLUE = f(1.5, 2.5, n)\n    RGBs = [('#%02x%02x%02x' % rgb) for rgb in zip(RED, GREEN, BLUE)]\n\n    temp = sorted(uniqueValues, reverse=True)\n    dictColor = {central: color for central, color in zip(temp, RGBs)}\n    return [QColor(dictColor[i]) for i in arr]\n"""
qt/AboutUsDialog.py,0,"b'import os\n\nfrom PyQt5.QtCore import QPropertyAnimation, QPointF, QUrl\nfrom PyQt5.QtGui import QIcon, QPainterPath, QMovie\nfrom PyQt5.QtMultimedia import *\nfrom PyQt5.QtWidgets import QDialog, QLabel\nfrom PyQt5.uic import loadUi\n\n\nclass AboutUsDialog(QDialog):\n    def __init__(self):\n        super().__init__()\n\n        loadUi(\'resource/gui/AboutUsDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""About Us"")\n        self.media = QMediaPlaylist()\n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        url = QUrl.fromLocalFile(os.path.join(dir_path, \'../resource/media/music.mp3\'))\n        self.media.addMedia(QMediaContent(url))\n        self.media.setPlaybackMode(QMediaPlaylist.Loop)\n\n        self.player = QMediaPlayer()\n        self.player.setPlaylist(self.media)\n        self.player.play()\n\n        self.mascot = self.findChild(QLabel, \'mascotLabel\')\n        self.mascotFlip = self.findChild(QLabel, \'mascotLabel2\')\n        self.mascotGif = QMovie(""resource/image/small-mascot.gif"")\n        self.mascotGif2 = QMovie(""resource/image/small-mascot-flip.gif"")\n        self.mascot.setMovie(self.mascotGif)\n        self.mascotFlip.setMovie(self.mascotGif2)\n\n        self.step = 10\n        self.xRange = 500\n        self.duration = 5000\n\n        self.goOn()\n\n    def goOn(self):\n        self.anim = QPropertyAnimation(self.mascot, b""pos"")\n        self.mascotFlip.hide()\n        self.mascotGif.start()\n        self.mascot.show()\n        path = QPainterPath()\n        path.moveTo(-70, 410)\n        for i in range(self.step):\n            path.quadTo(QPointF(self.xRange / self.step * i - 70 + (self.xRange / self.step / 2), 410),\n                        QPointF((self.xRange / self.step) * i - 70 + (self.xRange / self.step), 430))\n        vals = [p / 100 for p in range(0, 101)]\n        self.anim.setDuration(self.duration)\n        for i in vals:\n            self.anim.setKeyValueAt(i, path.pointAtPercent(i))\n        self.anim.start()\n        self.anim.finished.connect(self.goFlip)\n\n    def goFlip(self):\n        self.anim2 = QPropertyAnimation(self.mascotFlip, b""pos"")\n        self.mascot.hide()\n        self.mascotGif2.start()\n        self.mascotFlip.show()\n        path2 = QPainterPath()\n        path2.moveTo(500, 410)\n        for i in range(self.step):\n            path2.quadTo(QPointF(500 - (self.xRange / self.step) * i - (self.xRange / self.step / 2), 410),\n                         QPointF(500 - (self.xRange / self.step) * i - (self.xRange / self.step), 430))\n        vals = [p / 100 for p in range(0, 101)]\n        self.anim2.setDuration(self.duration)\n        for i in vals:\n            self.anim2.setKeyValueAt(i, path2.pointAtPercent(i))\n        self.anim2.start()\n        self.anim2.finished.connect(self.goOn)\n'"
qt/AddAttributesDialog.py,0,"b'from PyQt5.QtGui import QIcon\nfrom PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton\nfrom PyQt5.uic import loadUi\n\nfrom canvas import Canvas\nfrom .utils import BuddyLabel, textEdited\n\n\nclass AddAttributesDialog(QDialog):\n    def __init__(self, canvas: Canvas):\n        super().__init__()\n        self.canvas = canvas\n\n        loadUi(\'resource/gui/AddAttributesDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Add Attributes for Vertices/Edges"")\n\n        # ------------Vertex-----------------\n        self.layout = self.findChild(QVBoxLayout, \'verticalLayout\')\n        self.button = self.findChild(QPushButton, \'acceptButton\')\n\n        self.label = QLabel(\'Attribute name: \')\n        self.label.setStyleSheet(""color: rgb(180,180,180); font-size: 15px; background-color: transparent;"")\n        self.layout.addWidget(self.label)\n        valueLabelStyleSheet = (""QLabel {  font-size: 12px; border: 1px solid rgb(150, 150, 150); ""\n                                ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                ""border-radius: 5px; }""\n                                ""QLabel:hover{background-color: #242424;}""\n                                ""QLineEdit {  font-size: 12px; border: 1px solid rgb(150, 150, 150); ""\n                                ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                ""border-radius: 5px; }""\n                                ""QLineEdit:hover{background-color: #242424;}"")\n\n        self.valueEdit = QLineEdit()\n        self.valueEdit.setStyleSheet(valueLabelStyleSheet)\n        self.valueEdit.setFixedHeight(30)\n        self.value = BuddyLabel(self.valueEdit)\n        self.value.setFixedHeight(30)\n        \n        self.value.setStyleSheet(valueLabelStyleSheet)\n\n        self.layout.addWidget(self.value)\n        self.layout.addWidget(self.valueEdit)\n\n        self.button.clicked.connect(textEdited(self.value, self.valueEdit))\n        self.button.clicked.connect(self.saveVertexInfo)\n\n        # ------------Edge-----------------\n        self.layout2 = self.findChild(QVBoxLayout, \'verticalLayout_2\')\n        self.button2 = self.findChild(QPushButton, \'acceptButton_2\')\n\n        self.label2 = QLabel(\'Attribute name: \')\n        self.label2.setStyleSheet(""color: rgb(180,180,180); font-size: 15px; background-color: transparent;"")\n        self.layout2.addWidget(self.label2)\n\n        self.valueEdit2 = QLineEdit()\n        self.valueEdit2.setStyleSheet(valueLabelStyleSheet)\n        self.valueEdit2.setFixedHeight(30)\n        self.value2 = BuddyLabel(self.valueEdit2)\n        self.value2.setFixedHeight(30)\n\n        self.value2.setStyleSheet(valueLabelStyleSheet)\n\n        self.layout2.addWidget(self.value2)\n        self.layout2.addWidget(self.valueEdit2)\n\n        self.button2.clicked.connect(textEdited(self.value2, self.valueEdit2))\n        self.button2.clicked.connect(self.saveEdgeInfo)\n\n    def saveVertexInfo(self):\n        valueEdited = str(self.valueEdit.text())\n        self.canvas.g.vs[valueEdited] = """"\n        self.label.setText(valueEdited + "" has been successfully added!"")\n\n    def saveEdgeInfo(self):\n        valueEdited = str(self.valueEdit2.text())\n        self.canvas.g.es[valueEdited] = """"\n        self.label2.setText(valueEdited + "" has been successfully added!"")\n'"
qt/ConstraintDialog.py,0,"b'from PyQt5.QtCore import Qt\nfrom PyQt5.QtGui import QIcon\nfrom PyQt5.QtWidgets import QDialog, QLabel, QGridLayout, QPushButton\nfrom PyQt5.uic import loadUi\n\nfrom canvas import Canvas\nfrom .RandomDialog import RandomDialog\nfrom .RenameDialog import RenameDialog\nfrom .utils import clearLayout\n\n\nclass ConstraintDialog(QDialog):\n    attrEdge = {""total delay"", ""link speed raw"", ""bit error rate"", ""packet loss""}\n    attrNode = {""latitude"", ""longitude""}\n\n    def __init__(self, canvas: Canvas):\n        super().__init__()\n        self.labelStyleSheet = ""font-size: 15px; color: rgb(180,180,180); background-color: transparent;""\n        self.buttonStyleSheet = (""QPushButton{""\n                                 ""color: rgb(200, 200, 200);""\n                                 ""border-style: 2px solid rgb(200, 200, 200);""\n                                 ""border-radius: 7px;""\n                                 ""background-color: #383838; padding: 10px""\n                                 ""}""\n                                 ""QPushButton:hover{""\n                                 "" background-color: #303030;""\n                                 ""}""\n                                 )\n        self.canvas = canvas\n        self.g = canvas.g\n        loadUi(\'resource/gui/ConstraintDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Checking constraints"")\n        self.label = self.findChild(QLabel, \'label\')\n        self.grid = self.findChild(QGridLayout, \'gridLayout\')\n        #self.grid.setAlignment(Qt.AlignTop)\n        self.check()\n        self.name = """"\n\n    def checkConstrainEdge(self):\n        attr = self.g.es.attributes()\n        currAttr = [x.lower() for x in attr]\n        missingAttr = []\n        for i in self.attrEdge:\n            if i not in currAttr:\n                missingAttr.append(i)\n        return missingAttr\n\n    def checkConstrainVertex(self):\n        attr = self.g.vs.attributes()\n        currAttr = [x.lower() for x in attr]\n        missingAttr = []\n        for i in self.attrNode:\n            if i not in currAttr:\n                missingAttr.append(i)\n        return missingAttr\n\n    def check(self):\n        edgeMissing = self.checkConstrainEdge()\n        vertexMissing = self.checkConstrainVertex()\n        self.notify(edgeMissing, vertexMissing)\n        return len(edgeMissing) == 0 and len(vertexMissing) == 0\n\n    def link(self, missingAttr, linkAttr, type):\n        if type.upper() == ""EDGE"":\n            for i in self.g.es:\n                i[linkAttr] = i.attributes()[missingAttr]\n                i[missingAttr] = None\n        elif type.upper() == ""VERTEX"":\n            for i in self.g.vs:\n                i[linkAttr] = i.attributes()[missingAttr]\n                i[missingAttr] = None\n\n    def notify(self, edgeMissing, vertexMissing):\n        clearLayout(self.grid)\n        self.label.setText(\n            \'Choose ""Rename"" if the attribute already exists with another name \\n \'\n            \'Choose ""Random"" to generate data for a missing attribute\')\n        self.label.setAlignment(Qt.AlignCenter)\n        count = 1\n        if len(edgeMissing) > 0:\n            missLabel = QLabel(""Missing attribute of edge:"")\n            missLabel.setStyleSheet(self.labelStyleSheet)\n            self.grid.addWidget(missLabel, 0, 0, 1, 3)\n            missLabel.setAlignment(Qt.AlignCenter)\n            for i in edgeMissing:\n                label = QLabel(i + "":"")\n                label.setStyleSheet(self.labelStyleSheet)\n                label.setAlignment(Qt.AlignCenter)\n                self.grid.addWidget(label, count, 0)\n                buttonRename = QPushButton(\'Rename\', self)\n                buttonRename.setStyleSheet(self.buttonStyleSheet)\n                buttonRename.setToolTip(\'This is rename dialog\')\n                buttonRename.setFixedWidth(80)\n                self.grid.addWidget(buttonRename, count, 1)\n                setattr(buttonRename, ""type"", ""EDGE"")\n                buttonRename.clicked.connect(self.openRenameDialog(i))\n                # ========\n                buttonRandom = QPushButton(\'Random\', self)\n                buttonRandom.setToolTip(\'This is random dialog\')\n                buttonRandom.setStyleSheet(self.buttonStyleSheet)\n                buttonRandom.setFixedWidth(80)\n                self.grid.addWidget(buttonRandom, count, 2)\n                buttonRandom.clicked.connect(self.openRandomDialog)\n                buttonRandom.setObjectName(i)\n                setattr(buttonRandom, \'type\', \'EDGE\')\n                count = count + 1\n        count = 1\n        if len(vertexMissing) > 0:\n            missLabel = QLabel(""Missing attribute of vertex:"")\n            missLabel.setStyleSheet(self.labelStyleSheet)\n            missLabel.setAlignment(Qt.AlignCenter)\n            self.grid.addWidget(missLabel, 0, 3, 1, 3)\n            for i in vertexMissing:\n                label = QLabel(i + "":"")\n                label.setStyleSheet(self.labelStyleSheet)\n                label.setAlignment(Qt.AlignCenter)\n                self.grid.addWidget(label, count, 3)\n                buttonRename = QPushButton(\'Rename\', self)\n                buttonRename.setStyleSheet(self.buttonStyleSheet)\n                buttonRename.setFixedWidth(80)\n                buttonRename.setToolTip(\'This is rename dialog\')\n                self.grid.addWidget(buttonRename, count, 4)\n                setattr(buttonRename, ""type"", ""VERTEX"")\n                buttonRename.clicked.connect(self.openRenameDialog(i))\n                # ========\n                buttonRandom = QPushButton(\'Random\', self)\n                buttonRandom.setToolTip(\'This is random dialog\')\n                buttonRandom.setStyleSheet(self.buttonStyleSheet)\n                buttonRandom.setFixedWidth(80)\n                self.grid.addWidget(buttonRandom, count, 5)\n                buttonRandom.clicked.connect(self.openRandomDialog)\n                buttonRandom.setObjectName(i)\n                setattr(buttonRandom, \'type\', \'VERTEX\')\n                count = count + 1\n        if len(vertexMissing) == 0 and len(edgeMissing) == 0:\n            missLabel = QLabel(""None attribute missing"")\n            missLabel.setStyleSheet(self.labelStyleSheet)\n            self.grid.addWidget(missLabel, 0, 0)\n            missLabel.setAlignment(Qt.AlignCenter)\n\n    def openRandomDialog(self):\n        randomDialog = RandomDialog(self.canvas, getattr(self.sender(), ""type""))\n        self.setObjectName(self.sender().objectName())\n        randomDialog.exec()\n        self.check()\n\n    def openRenameDialog(self, label):\n        def func():\n            renameDialog = RenameDialog(self.canvas, label)\n            renameDialog.exec()\n            self.check()\n\n        return func\n'"
qt/FilterDialog.py,0,"b'from PyQt5.QtGui import QIcon\nfrom PyQt5.QtWidgets import QComboBox, QWidget, QPushButton, QLineEdit, QLabel, QTabWidget\nfrom PyQt5.uic import loadUi\n\nfrom canvas import *\n\n\nclass FilterDialog(QWidget):\n    def __init__(self, canvas: Canvas, layoutMode: LayoutMode, clusterMode: ClusterVerticesMode,\n                 centralityMode: CentralityMode, vertexAttrMode: VertexAttrColorMode,\n                 edgeAttrMode: EdgeAttrColorMode, filterEdgeMode: FilterEdgeMode):\n        super().__init__()\n        self.canvas = canvas\n        self.layoutMode = layoutMode\n        self.clusterMode = clusterMode\n        self.centralityMode = centralityMode\n        self.vertexAttrMode = vertexAttrMode\n        self.edgeAttrMode = edgeAttrMode\n        self.filterEdgeMode = filterEdgeMode\n\n        loadUi(\'resource/gui/FilterDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Network Visualization - Team Black - Filter Dialog"")\n        self.tab = self.findChild(QTabWidget, \'tabWidget\')\n        self.tab.setCurrentIndex(0)\n        self.vertexAttr = [opt for opt in self.canvas.g.vs.attributes()]\n\n        self.edgeWeights = [opt for opt in self.canvas.g.es.attributes()]\n        self.edgeWeights.remove(\'line\')\n\n        self.selectLayout = self.findChild(QComboBox, \'selectLayout\')\n        self.selectLayoutEdgeWeight = self.findChild(QComboBox, \'selectLayoutEdgeWeight\')\n        self.labelLayoutEdgeWeight = self.findChild(QLabel, \'labelLayoutEdgeWeight\')\n        self.applyLayoutBtn = self.findChild(QPushButton, \'applyLayoutBtn\')\n\n        self.selectClusteringAlgo = self.findChild(QComboBox, \'selectClusteringAlgo\')\n        self.selectClusteringAlgoEdgeWeight = self.findChild(QComboBox, \'selectClusteringAlgoEdgeWeight\')\n        self.applyClusterBtn = self.findChild(QPushButton, \'applyClusterBtn\')\n\n        self.selectFilterEdge = self.findChild(QComboBox, \'selectFilterEdge\')\n        self.applyFilterBtn = self.findChild(QPushButton, \'applyFilterBtn\')\n        self.cancelFilterBtn = self.findChild(QPushButton, \'cancelFilterBtn\')\n        self.cancelFilterBtn.pressed.connect(self.cancelFilter)\n        self.filterLeft = self.findChild(QLineEdit, \'filterLeft\')\n        self.filterRight = self.findChild(QLineEdit, \'filterRight\')\n\n        self.selectCentrality = self.findChild(QComboBox, \'selectCentrality\')\n        self.selectCentralityEdgeWeight = self.findChild(QComboBox, \'selectCentralityEdgeWeight\')\n        self.applyCentralityBtn = self.findChild(QPushButton, \'applyCentralityBtn\')\n        self.cancelCentralityBtn = self.findChild(QPushButton, \'cancelCentralityBtn\')\n\n        self.selectClusterAttribute = self.findChild(QComboBox, \'selectVertex\')\n        self.applyClusterAttribute = self.findChild(QPushButton, \'applyVertexBtn\')\n\n        self.selectEdgeAttribute = self.findChild(QComboBox, \'selectEdge\')\n        self.applyEdgeAttribute = self.findChild(QPushButton, \'applyEdge\')\n        self.addSelectOptions()\n        self.setShowLayoutWeight(0)\n\n    def addSelectOptions(self):\n        # Graph Layout Opt\n        self.selectLayout.addItems([opt[0] for opt in LAYOUT_OPTIONS])\n        self.selectLayout.currentIndexChanged.connect(self.setShowLayoutWeight)\n        self.selectLayoutEdgeWeight.addItems([\'-- Please choose --\'] + self.edgeWeights)\n        self.applyLayoutBtn.pressed.connect(self.changeGraphLayout)\n\n        # Clustering Algo Opt\n        self.selectClusteringAlgo.addItems([opt[0] for opt in CLUSTERING_ALGO_OPTIONS])\n        self.selectClusteringAlgoEdgeWeight.addItems([\'-- Please choose --\'] + self.edgeWeights)\n        self.applyClusterBtn.pressed.connect(self.changeClusteringAlgo)\n\n        # Filter Edge Opt\n        self.selectFilterEdge.addItems(self.edgeWeights)\n        self.applyFilterBtn.pressed.connect(self.changeEdgeFilter)\n\n        # Centrality\n        self.selectCentrality.addItems([opt[0] for opt in CENTRALITY_OPTIONS])\n        self.selectCentralityEdgeWeight.addItems([\'-- Please choose --\'] + self.edgeWeights)\n        self.applyCentralityBtn.pressed.connect(self.changeCentrality)\n        self.cancelCentralityBtn.pressed.connect(self.cancelCentrality)\n\n        # Cluster Attribute Opt\n        self.selectClusterAttribute.addItems(self.vertexAttr)\n        self.applyClusterAttribute.pressed.connect(self.changeClusterAttribute)\n\n        # Edge Attribute Opt\n        self.selectEdgeAttribute.addItems([\'-- Please choose --\'] + self.canvas.g.es.attributes())\n        self.applyEdgeAttribute.pressed.connect(self.setEdgeAttr)\n\n    def setShowLayoutWeight(self, opt):\n        visible = LAYOUT_OPTIONS[opt][1] in LAYOUT_WITH_WEIGHT\n        self.selectLayoutEdgeWeight.setVisible(visible)\n        self.labelLayoutEdgeWeight.setVisible(visible)\n\n    def setEdgeAttr(self):\n        opt = self.selectEdgeAttribute.currentIndex()\n        attr = self.canvas.g.es.attributes()[opt - 1] if opt > 0 else None\n        self.edgeAttrMode.attr = attr\n        self.canvas.addMode(self.edgeAttrMode)\n\n    def changeGraphLayout(self):\n        layout = LAYOUT_OPTIONS[self.selectLayout.currentIndex()][1]\n        i = self.selectLayoutEdgeWeight.currentIndex()\n        weight = self.edgeWeights[i - 1] if i > 0 else None\n        self.layoutMode.setLayout(layout, weight)\n\n    def changeClusteringAlgo(self):\n        algo = CLUSTERING_ALGO_OPTIONS[self.selectClusteringAlgo.currentIndex()][1]\n        i = self.selectClusteringAlgoEdgeWeight.currentIndex()\n        weight = self.edgeWeights[i - 1] if i > 0 else None\n        self.clusterMode.clusterAlgo = algo\n        self.clusterMode.weight = weight\n        self.canvas.addMode(self.clusterMode)\n\n    def changeEdgeFilter(self):\n        attr = self.edgeWeights[self.selectFilterEdge.currentIndex()]\n        left = float(self.filterLeft.text())\n        right = float(self.filterRight.text())\n        self.filterEdgeMode.setFilters(attr, left, right)\n        self.canvas.update()\n\n    def changeCentrality(self):\n        centrality = CENTRALITY_OPTIONS[self.selectCentrality.currentIndex()][1]\n        i = self.selectCentralityEdgeWeight.currentIndex()\n        weight = self.edgeWeights[i - 1] if i > 0 else None\n        self.centralityMode.centrality = centrality\n        self.centralityMode.weight = weight\n        self.canvas.addMode(self.centralityMode)\n\n    def cancelCentrality(self):\n        self.changeClusteringAlgo()\n\n    def changeClusterAttribute(self):\n        attr = self.vertexAttr[self.selectClusterAttribute.currentIndex()]\n        self.vertexAttrMode.attr = attr\n        self.canvas.addMode(self.vertexAttrMode)\n\n    def cancelFilter(self):\n        self.filterEdgeMode.setFilters(None, -999, 9999)\n        self.canvas.update()\n'"
qt/InfoWidget.py,0,"b'from PyQt5.QtCore import Qt\nfrom PyQt5.QtWidgets import QWidget, QLabel, QGridLayout, QLineEdit, QHBoxLayout\n\nfrom .utils import BuddyLabel, textEdited\n\n\nclass InfoWidget(QWidget):\n    title = \'\'\n    ignoredFields = []\n\n    def __init__(self, value, canvas):\n        super().__init__()\n        self.value = value\n        self.canvas = canvas\n\n        self.dict = value.attributes()\n        for f in self.ignoredFields:\n            if f in self.dict:\n                del self.dict[f]\n\n        # Title layout\n        layout = QGridLayout(self)\n        layout.setAlignment(Qt.AlignTop)\n        topLabelStyleSheet = (\n            ""font-size: 15px; font-weight: Bold; QLabel; ""\n            ""padding: 2px; color: rgb(220,220,220); background-color: #383838; border-radius: 15px"")\n\n        self.topLabel = QLabel(self.title)\n        self.topLabel.setFixedHeight(45)\n        self.topLabel.setAlignment(Qt.AlignCenter)\n        self.topLabel.setStyleSheet(topLabelStyleSheet)\n        layout.addWidget(self.topLabel, 0, 0, 1, 2)\n\n        # Info layout\n        count = 2\n        self.valueLabelItems = []\n        self.valueLabelEditItems = []\n        for label, text in self.dict.items():\n            text = str(text)\n            keyLabel = QLabel(str(label) + "":"")\n            keyLabel.setWordWrap(True)\n            keyLabel.setStyleSheet(""QLabel {  background-color: #414141; font-weight: Bold; font-size: 11px;""\n                                   ""color: rgb(220,220,220); border-radius: 5px; padding-left: 3px; }"")\n            layout.addWidget(keyLabel, count, 0)\n\n            valueLabelStyleSheet = (""QLabel {  font-size: 12px; border: 1px solid rgb(150, 150, 150); ""\n                                    ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                    ""border-radius: 5px; }""\n                                    ""QLabel:hover{background-color: #242424;}""\n                                    ""QLineEdit {  font-size: 12px; border: 1px solid rgb(150, 150, 150); ""\n                                    ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                    ""border-radius: 5px; }""\n                                    ""QLineEdit:hover{background-color: #242424;}""\n                                    )\n\n            valueLabelEdit = QLineEdit()\n\n            valueLabel = BuddyLabel(valueLabelEdit)\n            self.valueLabelItems.append(valueLabel)\n            self.valueLabelEditItems.append(valueLabelEdit)\n\n            valueLabelEdit.setStyleSheet(valueLabelStyleSheet)\n            valueLabelEdit.setFixedHeight(30)\n            valueLabel.setText(text)\n            valueLabel.setFixedHeight(30)\n            valueLabelEdit.setText(text)\n            valueLabel.setWordWrap(True)\n            valueLabel.setStyleSheet(valueLabelStyleSheet)\n            #hLayout = QHBoxLayout()\n            #hLayout.addWidget(valueLabelEdit)\n            #hLayout.addWidget(valueLabel)\n            layout.addWidget(valueLabel, count, 1)\n            layout.addWidget(valueLabelEdit, count, 1)\n            count = count + 1\n        self.setLayout(layout)\n\n        # Update info\n        for i in range(len(self.valueLabelEditItems)):\n            func = textEdited(self.valueLabelItems[i], self.valueLabelEditItems[i])\n            self.valueLabelEditItems[i].editingFinished.connect(func)\n            self.valueLabelEditItems[i].editingFinished.connect(self.saveInfo)\n\n    def saveInfo(self):\n        for attr, i in zip(self.dict.keys(), range(len(self.valueLabelItems))):\n            newValue = self.valueLabelItems[i].text()\n            try:\n                newValue = float(newValue)\n            except ValueError:\n                pass\n            self.value[attr] = newValue\n\n        self.canvas.update()\n\n\nclass VertexInfoWidget(InfoWidget):\n    title = \'VERTEX INFO\'\n    ignoredFields = [\'color\', \'pos\', \'degree\']\n\n\nclass EdgeInfoWidget(InfoWidget):\n    title = \'EDGE INFO\'\n    ignoredFields = [\'color\', \'edge_color\', \'line\']\n'"
qt/MainWindow.py,0,"b'import igraph\nfrom PIL import Image\nfrom PyQt5 import uic\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import QColor\nfrom PyQt5.QtGui import QPainter, QPixmap\nfrom PyQt5.QtWidgets import *\nfrom igraph import Graph\n\nfrom canvas import *\nfrom .AboutUsDialog import AboutUsDialog\nfrom .AddAttributesDialog import AddAttributesDialog\nfrom .ConstraintDialog import ConstraintDialog\nfrom .FilterDialog import FilterDialog\nfrom .InfoWidget import EdgeInfoWidget, VertexInfoWidget\nfrom .RealTimeDialog import *\nfrom .ShortestPathWeightDialog import ShortestPathWeightDialog\nfrom .StatDialog import StatDialog\nfrom .utils import clearLayout\n\nDEFAULT_GRAPH = \'resource/graph/NREN.graphml\'\n\n\nclass MainWindow(QMainWindow):\n    def __init__(self):\n        super().__init__()\n\n        uic.loadUi(\'resource/gui/GUI.ui\', self)\n\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Network Visualization - Team Black"")\n        self.setWindowFlag(QtCore.Qt.WindowMaximizeButtonHint, False)\n\n        self.canvas = Canvas(1129, 760)\n        self.findChild(QVBoxLayout, \'verticalLayout\').addWidget(self.canvas)\n\n        # Modes\n        # 0\n        self.darkMode = DarkViewMode(self)\n        self.lightMode = LightViewMode(self)\n        self.geoMode = GeoViewMode(self)\n        # 1\n        self.editMode = EditMode(self)\n        self.shortestPathMode = ShortestPathMode(self)\n        self.bottleNeckMode = BottleNeckMode(self)\n        # 2\n        self.layoutMode = LayoutMode(self)\n        # 3\n        self.clusterVerticesMode = ClusterVerticesMode(self)\n        self.centralityMode = CentralityMode(self)\n        self.vertexAttrColorMode = VertexAttrColorMode(self)\n        self.edgeAttrColorMode = EdgeAttrColorMode(self)\n        self.filterEdgeMode = FilterEdgeMode(self)\n        # 4\n        self.realTimeMode = RealTimeMode(self)\n\n        defaultModes = [\n            self.darkMode,\n            self.editMode,\n            self.layoutMode,\n            self.clusterVerticesMode,\n            self.edgeAttrColorMode,\n            self.filterEdgeMode\n        ]\n        for m in defaultModes:\n            self.canvas.addMode(m)\n        self.canvas.setGraph(DEFAULT_GRAPH)\n\n        self.realTimeDialog = self.statDialog = self.filterDialog = None\n\n        self.infoArea = self.findChild(QVBoxLayout, \'infoArea\')\n        self.bindMenuActions()\n\n    def bindMenuActions(self):\n        # ------------- Menu ---------------- #\n        # File\n        # Open_button\n        openBtn = self.findChild(QAction, \'action_Open\')\n        openBtn.triggered.connect(self.openFileNameDialog)\n        # Open_Image\n        openImageBtn = self.findChild(QAction, \'actionOpen_Image\')\n        openImageBtn.triggered.connect(self.openImageToGraphDialog)\n        # Save_Image_button\n        saveImageBtn = self.findChild(QAction, \'actionSave_Image\')\n        saveImageBtn.triggered.connect(self.saveImageDialog)\n        # Save_button\n        saveBtn = self.findChild(QAction, \'action_Save\')\n        saveBtn.triggered.connect(self.saveFileDialog)\n        # Close_button\n        closeBtn = self.findChild(QAction, \'action_Close\')\n        closeBtn.triggered.connect(self.close)\n        # New\n        newBtn = self.findChild(QAction, \'actionNew\')\n        newBtn.triggered.connect(self.newGraph)\n        # About Us\n        aboutUsBtn = self.findChild(QAction, \'actionAboutUs\')\n        aboutUsBtn.triggered.connect(self.aboutUsDialog)\n        # View\n        # Zoom in\n        self.findChild(QAction, \'actionZoom_In\').triggered.connect(self.canvas.zoomInEvent)\n        # Zoom out\n        self.findChild(QAction, \'actionZoom_Out\').triggered.connect(self.canvas.zoomOutEvent)\n        # Zoom reset\n        self.findChild(QAction, \'actionReset_Zoom\').triggered.connect(self.canvas.zoomResetEvent)\n        # View mode\n        self.findChild(QAction, \'actionGeographical_Mode\').triggered.connect(self.changeViewModeTo(GeoViewMode))\n        self.findChild(QAction, \'actionDark_Mode\').triggered.connect(self.changeViewModeTo(DarkViewMode))\n        self.findChild(QAction, \'actionLight_Mode\').triggered.connect(self.changeViewModeTo(LightViewMode))\n        # Add a Node\n        self.findChild(QAction, \'action_Add_nodes\').triggered.connect(self.editMode.setAddVertex)\n        # Delete a node\n        self.findChild(QAction, \'actionDelete_a_Node\').triggered.connect(self.editMode.setDeleteVertex)\n        # Add a Line\n        self.findChild(QAction, \'actionAdd_a_Line\').triggered.connect(self.editMode.setAddEdge)\n        # Delete a Line\n        self.findChild(QAction, \'actionDelete_a_Line\').triggered.connect(self.editMode.setDeleteEdge)\n        # Find shortest path\n        self.findChild(QAction, \'actionFind_shortest_path\').triggered.connect(self.activateFindShortestPathMode)\n        # Edit mode\n        self.findChild(QAction, \'actionEdit_graph\').triggered.connect(self.activateEditGraphMode)\n        # Chart mode\n        self.findChild(QAction, \'actionStatistical_Charts\').triggered.connect(self.openStatDialog)\n        # Checking constraints\n        self.findChild(QAction, \'actionCheck_constraints\').triggered.connect(self.openConstraintDialog)\n        # Add new attribute\n        self.findChild(QAction, \'actionAdd_a_new_attribute\').triggered.connect(self.openAddAttributesDialog)\n        # Real time\n        self.findChild(QAction, \'action_Real_Time_Mode\').triggered.connect(self.openRealTimeDialog)\n        # Window\n        # Minimize_button\n        self.findChild(QAction, \'action_Minimize\').triggered.connect(self.minimizeWindow)\n\n        # -------------Toolbar---------------- #\n        # Zoom in\n        zoomInBtn = self.findChild(QToolButton, \'zoom_in_btn\')\n        zoomInBtn.pressed.connect(self.canvas.zoomInEvent)\n        # Zoom out\n        zoomOutBtn = self.findChild(QToolButton, \'zoom_out_btn\')\n        zoomOutBtn.pressed.connect(self.canvas.zoomOutEvent)\n        # Zoom reset\n        zoomResetBtn = self.findChild(QToolButton, \'zoom_reset_btn\')\n        zoomResetBtn.pressed.connect(self.canvas.zoomResetEvent)\n        # Add vertex\n        addVertexBtn = self.findChild(QToolButton, \'add_node_btn\')\n        addVertexBtn.pressed.connect(self.editMode.setAddVertex)\n        # Delete Vertex\n        deleteBtn = self.findChild(QToolButton, \'delete_node_btn\')\n        deleteBtn.pressed.connect(self.editMode.setDeleteVertex)\n        # Add Line\n        addLineBtn = self.findChild(QToolButton, \'add_line_btn\')\n        addLineBtn.pressed.connect(self.editMode.setAddEdge)\n        # Delete Line\n        deleteLineBtn = self.findChild(QToolButton, \'delete_line_btn\')\n        deleteLineBtn.pressed.connect(self.editMode.setDeleteEdge)\n\n        # --- Mode ---\n        # shortest path\n        findShortestPathBtn = self.findChild(QToolButton, \'findShortestPathBtn\')\n        findShortestPathBtn.pressed.connect(self.activateFindShortestPathMode)\n        # bottle neck\n        findBottleNeck = self.findChild(QToolButton, \'findBottleNeckBtn\')\n        findBottleNeck.pressed.connect(self.activateFindBottleNeckMode)\n        # edit\n        editBtn = self.findChild(QToolButton, \'editBtn\')\n        editBtn.pressed.connect(self.activateEditGraphMode)\n        # Generate stat\n        graphBtn = self.findChild(QToolButton, \'graph_btn\')\n        graphBtn.pressed.connect(self.openStatDialog)\n        # open Filter window\n        filterBtn = self.findChild(QToolButton, \'filter_dialog_btn\')\n        filterBtn.pressed.connect(self.openFilterDialog)\n        # Open Constraint Dialog\n        constraintBtn = self.findChild(QToolButton, \'constraint_btn\')\n        constraintBtn.pressed.connect(self.openConstraintDialog)\n        # Add Attributes Dialog\n        addAttributeBtn = self.findChild(QToolButton, \'add_attribute_btn\')\n        addAttributeBtn.pressed.connect(self.openAddAttributesDialog)\n        # Real Time Dialog\n        realTimeBtn = self.findChild(QToolButton, \'real_time_btn\')\n        realTimeBtn.pressed.connect(self.openRealTimeDialog)\n        # Spectrum Box\n        self.spectrum = self.findChild(QLabel, \'spectrum\')\n        self.spectrum.hide()\n\n    def openAddAttributesDialog(self):\n        AddAttributesDialog(self.canvas).exec()\n\n    def openConstraintDialog(self):\n        constraintDialog = ConstraintDialog(self.canvas)\n        constraintDialog.exec()\n        constraintDialog.check()\n\n    def changeViewModeTo(self, viewModeClass):\n        def func():\n            self.canvas.addMode(viewModeClass(self))\n            self.canvas.resetViewRect()\n            self.canvas.update()\n\n        return func\n\n    def newGraph(self):\n        g = igraph.read(\'resource/graph/__empty__.graphml\')\n        self.canvas.setGraph(g)\n        self.canvas.center = QPointF(530, 1130)\n        self.canvas.zoom = 0.25\n        self.canvas.update()\n\n    def saveImageDialog(self):\n        fileName, _ = QFileDialog.getSaveFileName(\n            self, ""Save As Image"", """",\n            ""All Files (*);;JPG Files (*.jpg)""\n        )\n        if fileName != \'\':\n            img = QPixmap(self.canvas.size())\n            painter = QPainter(img)\n            self.canvas.paint(painter)\n            painter.end()\n            img.save(fileName)\n\n    def minimizeWindow(self):\n        if self.windowState() == Qt.WindowNoState or self.windowState() == Qt.WindowMaximized:\n            # Minimize window\n            self.setWindowState(Qt.WindowMinimized)\n\n    def openFileNameDialog(self):\n        options = QFileDialog.Options()\n        options |= QFileDialog.DontUseNativeDialog\n        fileName, _ = QFileDialog.getOpenFileName(\n            self, ""Open"", ""./resource/graph"",\n            ""All Files (*);;Python Files (*.py)"", options=options\n        )\n        if fileName:\n            self.canvas.setGraph(fileName)\n\n    def openImageToGraphDialog(self):\n        options = QFileDialog.Options()\n        options |= QFileDialog.DontUseNativeDialog\n        fileName, _ = QFileDialog.getOpenFileName(\n            self, ""Open Image"", ""./resource/graph"",\n            ""All Files (*);;Python Files (*.py)"", options=options\n        )\n        if fileName:\n            img = Image.open(fileName, ""r"")\n            w, h = img.size\n            MAX_WIDTH = 160\n            if w > MAX_WIDTH:\n                wpercent = (MAX_WIDTH * 1.0 / w)\n                hsize = int(h * wpercent)\n                img = img.resize((MAX_WIDTH, hsize), Image.ANTIALIAS)\n                w, h = img.size\n            data = img.load()\n            graph = Graph()\n            for i in range(h):\n                for j in range(w):\n                    if img.mode == \'RGBA\':\n                        r, g, b, a = data[j, i]\n                        color = QColor(r, g, b).name()\n                        if a > 0:\n                            graph.add_vertex(\n                                x=j,\n                                y=i,\n                                color=color\n                            )\n                    elif img.mode == \'RGB\':\n                        r, g, b = data[j, i]\n                        color = QColor(r, g, b).name()\n                        graph.add_vertex(\n                            x=j,\n                            y=i,\n                            color=color\n                        )\n            self.canvas.setGraph(graph)\n\n    def saveFileDialog(self):\n        options = QFileDialog.Options()\n        fileName, _ = QFileDialog.getSaveFileName(\n            self, ""Save As"", """",\n            ""All Files (*);;GraphML Files (*.graphml);;GML Files (*.gml)"", options=options\n        )\n\n        # process graph before saving\n        g = self.canvas.g.copy()\n        g.vs[\'color\'] = [c.name() if isinstance(c, QColor) else c.color().name() for c in g.vs[\'color\']]\n        g.es[\'color\'] = [c.name() if isinstance(c, QColor) else c.color().name() for c in g.es[\'color\']]\n        del g.es[\'line\']\n        del g.vs[\'pos\']\n\n        if fileName:\n            if "".graphml"" in fileName:\n                g.write_graphml(fileName)\n            elif "".gml"" in fileName:\n                g.write_gml(fileName)\n\n    def activateFindShortestPathMode(self):\n        ShortestPathWeightDialog(self.canvas, self.shortestPathMode).exec()\n        self.canvas.addMode(self.shortestPathMode)\n\n    def activateEditGraphMode(self):\n        self.canvas.addMode(self.editMode)\n\n    def activateFindBottleNeckMode(self):\n        self.canvas.addMode(self.bottleNeckMode)\n\n    def displayVertex(self, vertex):\n        clearLayout(self.infoArea)\n        vertexInfo = VertexInfoWidget(vertex, self.canvas)\n        self.infoArea.addWidget(vertexInfo)\n\n    def displayEdge(self, edge):\n        clearLayout(self.infoArea)\n        edgeInfo = EdgeInfoWidget(edge, self.canvas)\n        self.infoArea.addWidget(edgeInfo)\n\n    def clearInfoArea(self):\n        clearLayout(self.infoArea)\n\n    def openStatDialog(self):\n        self.statDialog = StatDialog(self.canvas)\n        self.statDialog.show()\n\n    def openFilterDialog(self):\n        self.filterDialog = FilterDialog(\n            self.canvas,\n            self.layoutMode,\n            self.clusterVerticesMode,\n            self.centralityMode,\n            self.vertexAttrColorMode,\n            self.edgeAttrColorMode,\n            self.filterEdgeMode\n        )\n        self.filterDialog.show()\n\n    @staticmethod\n    def aboutUsDialog():\n        aboutUsWindow = AboutUsDialog()\n        aboutUsWindow.exec()\n\n    def openRealTimeDialog(self):\n        self.realTimeDialog = RealTimeDialog(self.canvas, self.realTimeMode)\n        self.realTimeDialog.show()\n'"
qt/RandomDialog.py,4,"b'import numpy as np\nfrom PyQt5.QtGui import QIcon\nfrom PyQt5.QtWidgets import QDialog, QComboBox, QVBoxLayout, QLabel, QLineEdit, QPushButton\nfrom PyQt5.uic import loadUi\n\nfrom canvas import Canvas\nfrom .utils import BuddyLabel, clearLayout, textEdited\n\nDIST = [\n    \'Normal distribution\',\n    \'Uniform distribution\'\n]\n\n\nclass RandomDialog(QDialog):\n    def __init__(self, canvas: Canvas, type):\n        super().__init__()\n        self.canvas = canvas\n        self.type = type\n        self.g = canvas.g\n        self.attr = self.sender().objectName()\n        loadUi(\'resource/gui/RandomDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Random data"")\n        self.distLayout = self.findChild(QVBoxLayout, \'distLayout\')\n        self.selectDistribution = self.findChild(QComboBox, \'distBox\')\n        self.randomLayout = self.findChild(QVBoxLayout, \'randomLayout\')\n        self.randomLayout2 = self.findChild(QVBoxLayout, \'randomLayout2\')\n        self.generateBtn = self.findChild(QPushButton, \'generate_btn\')\n        self.notiLabel = self.findChild(QLabel, \'notiLabel\')\n        self.notiLabel.setWordWrap(True)\n        self.addDistSelectOptions()\n        self.labelStyleSheet = (""color: rgb(180,180,180);""\n                                ""font-size: 15px;""\n                                ""background-color: transparent;"")\n        self.buttonStyleSheet = (""QPushButton{""\n                                 ""color: rgb(200, 200, 200);""\n                                 ""border-style: 2px solid rgb(200, 200, 200);""\n                                 ""border-radius: 7px;""\n                                 ""background-color: #383838;""\n                                 ""}""\n                                 ""QPushButton:hover{""\n                                 "" background-color: #303030;""\n                                 ""}""\n                                 )\n\n        self.meanEdit = QLineEdit()\n        self.mean = BuddyLabel(self.meanEdit)\n\n        self.standardDeviationEdit = QLineEdit()\n        self.standardDeviation = BuddyLabel(self.standardDeviationEdit)\n\n        self.minEdit = QLineEdit()\n        self.min = BuddyLabel(self.minEdit)\n\n        self.maxEdit = QLineEdit()\n        self.max = BuddyLabel(self.maxEdit)\n\n        self.valueLabelStyleSheet = (""QLabel {  font-size: 11px; border: 1px solid rgb(150, 150, 150); ""\n                                    ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                    ""border-radius: 5px; }""\n                                    ""QLabel:hover{background-color: #242424;}""\n                                    ""QLineEdit {  font-size: 11px; border: 1px solid rgb(150, 150, 150); ""\n                                    ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                    ""border-radius: 5px; }""\n                                    ""QLineEdit:hover{background-color: #242424;}"")\n        self.attrBack = []\n\n        self.randomArr = []\n        self.update = True\n\n    def changeDist(self, opt):\n        [\n            self.default,\n            self.normalDistribution,\n            self.uniformDistribution,\n        ][opt]()\n\n    def addDistSelectOptions(self):\n        self.selectDistribution.addItems([\'-- None --\'])\n        self.selectDistribution.addItems([opt for opt in DIST])\n        self.selectDistribution.currentIndexChanged.connect(self.changeDist)\n\n    def default(self):\n        clearLayout(self.randomLayout)\n\n    def normalDistribution(self):\n        clearLayout(self.randomLayout)\n        meanLabel = QLabel(\'Mean: \')\n        meanLabel.setStyleSheet(self.labelStyleSheet)\n        self.mean.setStyleSheet(self.valueLabelStyleSheet)\n        self.meanEdit.setStyleSheet(self.valueLabelStyleSheet)\n        self.randomLayout.addWidget(meanLabel)\n        self.randomLayout.addWidget(self.mean)\n        self.randomLayout.addWidget(self.meanEdit)\n\n        stdevLabel = QLabel(\'Standard Deviation: \')\n        stdevLabel.setStyleSheet(self.labelStyleSheet)\n        self.standardDeviationEdit.setStyleSheet(self.valueLabelStyleSheet)\n        self.standardDeviation.setStyleSheet(self.valueLabelStyleSheet)\n        self.randomLayout2.addWidget(stdevLabel)\n        self.randomLayout2.addWidget(self.standardDeviation)\n        self.randomLayout2.addWidget(self.standardDeviationEdit)\n\n        # acceptBtn = QPushButton(\'Generate\', self)\n        # acceptBtn.setStyleSheet(self.buttonStyleSheet)\n        # self.randomLayout.addWidget(acceptBtn)\n        # self.meanEdit.textEdited(self.mean, self.meanEdit))\n        # acceptBtn.clicked.connect(textEdited(self.standardDeviation, self.standardDeviationEdit))\n        # acceptBtn.clicked.connect(self.generateNormalDistribution)\n        self.meanEdit.editingFinished.connect(textEdited(self.mean, self.meanEdit))\n        self.standardDeviationEdit.editingFinished.connect(\n            textEdited(self.standardDeviation, self.standardDeviationEdit))\n        self.generateBtn.pressed.connect(self.generateNormalDistribution)\n\n    def uniformDistribution(self):\n        clearLayout(self.randomLayout)\n        minLabel = QLabel(\'Min: \')\n        minLabel.setStyleSheet(self.labelStyleSheet)\n        self.minEdit.setStyleSheet(self.valueLabelStyleSheet)\n        self.min.setStyleSheet(self.valueLabelStyleSheet)\n        self.randomLayout.addWidget(minLabel)\n        self.randomLayout.addWidget(self.min)\n        self.randomLayout.addWidget(self.minEdit)\n\n        maxLabel = QLabel(\'Max: \')\n        maxLabel.setStyleSheet(self.labelStyleSheet)\n        self.max.setStyleSheet(self.valueLabelStyleSheet)\n        self.maxEdit.setStyleSheet(self.valueLabelStyleSheet)\n        self.randomLayout2.addWidget(maxLabel)\n        self.randomLayout2.addWidget(self.max)\n        self.randomLayout2.addWidget(self.maxEdit)\n\n        # acceptBtn = QPushButton(\'Generate\', self)\n        # acceptBtn.setStyleSheet(self.buttonStyleSheet)\n        # self.randomLayout.addWidget(acceptBtn)\n        self.minEdit.editingFinished.connect(textEdited(self.min, self.minEdit))\n        self.maxEdit.editingFinished.connect(textEdited(self.max, self.maxEdit))\n        self.generateBtn.pressed.connect(self.generateUniformDistribution)\n        # acceptBtn.clicked.connect(self.generateUniformDistribution)\n\n    def generateNormalDistribution(self):\n        mean = float(self.meanEdit.text())\n        stdDeviation = float(self.standardDeviationEdit.text())\n        if self.type == \'EDGE\':\n            if self.update:\n                size = self.g.ecount()\n                self.randomArr = np.random.normal(mean, stdDeviation, size)\n                self.changeEdge(self.attr, self.randomArr)\n        else:\n            if self.update:\n                size = self.g.vcount()\n                self.randomArr = np.random.normal(mean, stdDeviation, size)\n                self.changeVertex(self.attr, self.randomArr)\n\n        self.notiLabel.setText(\n            ""Generated Normal Distribution with \\n Mean = ""+str(mean)+"" Standard Deviation = ""+str(stdDeviation))\n        self.attrBack.append(""Normal Distribution"")\n        self.attrBack.append(mean)\n        self.attrBack.append(stdDeviation)\n\n    def generateUniformDistribution(self):\n        minValue = float(self.minEdit.text())\n        maxValue = float(self.maxEdit.text())\n        if self.type == \'EDGE\':\n            if self.update:\n                size = self.g.ecount()\n                self.randomArr = np.random.uniform(minValue, maxValue, size)\n                self.changeEdge(self.attr, self.randomArr)\n        else:\n            if self.update:\n                size = self.g.vcount()\n                self.randomArr = np.random.uniform(minValue, maxValue, size)\n                self.changeVertex(self.attr, self.randomArr)\n        self.notiLabel.setText(\n            ""Generated Uniform Distribution with \\n Min = ""+str(minValue)+"" Max = ""+str(maxValue))\n        self.attrBack.append(""Uniform Distribution"")\n        self.attrBack.append(minValue)\n        self.attrBack.append(maxValue)\n\n    def changeEdge(self, attributeName, randomArr):\n        count = 0\n        for i in self.g.es:\n            i[attributeName] = randomArr[count]\n            count = count + 1\n\n    def changeVertex(self, attributeName, randomArr):\n        count = 0\n        for i in self.g.vs:\n            i[attributeName] = randomArr[count]\n            count = count + 1\n\n    def getAttr(self):\n        return self.attrBack\n'"
qt/RealTimeDialog.py,0,"b'import re\n\nfrom PyQt5 import QtCore\nfrom PyQt5.QtGui import QIcon\nfrom PyQt5.QtWidgets import QLabel, QGridLayout, QWidget, QCheckBox, QComboBox, QPushButton, QSlider\nfrom PyQt5.uic import loadUi\n\nfrom canvas import Canvas, RealTimeMode\nfrom .RealTimeRandomDialog import RealTimeRandomDialog\n\nDIST = [\n    \'Normal distribution\',\n    \'Uniform distribution\'\n]\n\nVERTEX_IGNORED_KEYS = [\'id\', \'key\']\n\nEDGE_IGNORED_KEYS = [\'id\', \'key\']\n\n\nclass RealTimeDialog(QWidget):\n    def __init__(self, canvas: Canvas, realtimeMode: RealTimeMode):\n        super().__init__()\n        self.canvas = canvas\n        self.realtimeMode = realtimeMode\n        self.count = 0\n        loadUi(\'resource/gui/RealTimeDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Real Time Visualization Tool"")\n        self.labelStyleSheet = ""color: rgb(180,180,180); background-color: transparent;""\n        self.checkBoxList = []\n        self.vertexAttr = []\n        self.edgeAttr = []\n        self.attr = []\n        self.generateBtn = self.findChild(QPushButton, \'generate_btn\')\n        self.generateBtn.setEnabled(False)\n        self.generateBtn.pressed.connect(self.realTimeEvent)\n        self.closeBtn = self.findChild(QPushButton, \'close_btn\')\n        self.closeBtn.pressed.connect(self.close)\n        self.notiLabel = self.findChild(QLabel, \'notiLabel\')\n        # FPS\n        self.fpsSlider = self.findChild(QSlider, \'fpsSlider\')\n        self.fpsSlider.setMinimum(10)\n        self.fpsSlider.setMaximum(50)\n        self.fpsSlider.setValue(30)\n        self.fps = 30\n        self.fpsSlider.setTickPosition(QSlider.TicksBelow)\n        self.fpsSlider.setTickInterval(5)\n        self.fpsValueLabel = self.findChild(QLabel, \'fpsLabel\')\n        self.fpsSlider.valueChanged.connect(self.changeFPSValue)\n        # Vertex tab\n        self.vertexGridLayout = self.findChild(QGridLayout, \'vertexGridLayout\')\n        self.edgeGridLayout = self.findChild(QGridLayout, \'edgeGridLayout\')\n        self.addVertexKey()\n        self.addEdgeKey()\n        self.selectDistribution = QComboBox()\n\n        self.selectDistribution.addItems(DIST)\n\n        for i in range(len(self.checkBoxList)):\n            self.checkBoxList[i].stateChanged.connect(self.checkBoxEdited)\n\n    def closeEvent(self, event):\n        self.canvas.removeMode(self.realtimeMode)\n        super().closeEvent(event)\n\n    def addVertexKey(self):\n        count = 1\n        for key in self.canvas.g.vs.attributes():\n            value = self.canvas.g.vs[0][key]\n            keyLabel = QLabel(key)\n            keyLabel.setStyleSheet(self.labelStyleSheet)\n            if isinstance(value, float) and key not in VERTEX_IGNORED_KEYS:\n                self.vertexGridLayout.addWidget(keyLabel, count, 0)\n                checkBox = QCheckBox(self)\n                checkBox.setStyleSheet(""QCheckBox{   border: none; color: red;}"")\n                checkBox.setObjectName(key)\n                setattr(checkBox, ""type"", ""VERTEX"")\n                self.checkBoxList.append(checkBox)\n                self.vertexGridLayout.addWidget(checkBox, count, 1)\n                distLabel = QLabel(""None"")\n                distLabel.setObjectName(key + \'dist\')\n                distLabel.setStyleSheet(self.labelStyleSheet)\n                self.vertexGridLayout.addWidget(distLabel, count, 2)\n                firstValueLabel = QLabel(""None"")\n                firstValueLabel.setObjectName(key + \'value1\')\n                firstValueLabel.setStyleSheet(self.labelStyleSheet)\n                #self.vertexGridLayout.addWidget(firstValueLabel, count, 3)\n                secondValueLabel = QLabel(""None"")\n                secondValueLabel.setObjectName(key + \'value2\')\n                secondValueLabel.setStyleSheet(self.labelStyleSheet)\n                self.vertexGridLayout.addWidget(secondValueLabel, count, 3)\n\n                count += 1\n\n    def changeFPSValue(self):\n        fpsValue = self.fpsSlider.value()\n        self.fpsValueLabel.setText(\'FPS Value = \' + str(fpsValue))\n        self.fps = fpsValue\n\n    def addEdgeKey(self):\n        count = 1\n        for key in self.canvas.g.es.attributes():\n            value = self.canvas.g.es[0][key]\n            keyLabel = QLabel(key)\n            keyLabel.setStyleSheet(self.labelStyleSheet)\n            if isinstance(value, float) and key not in EDGE_IGNORED_KEYS:\n                self.edgeGridLayout.addWidget(keyLabel, count, 0)\n                checkBox = QCheckBox(self)\n                checkBox.setObjectName(key)\n                setattr(checkBox, ""type"", ""EDGE"")\n                self.checkBoxList.append(checkBox)\n                self.edgeGridLayout.addWidget(checkBox, count, 1)\n                distLabel = QLabel(""None"")\n                distLabel.setObjectName(key + \'dist\')\n                distLabel.setStyleSheet(self.labelStyleSheet)\n                self.edgeGridLayout.addWidget(distLabel, count, 2)\n                firstValueLabel = QLabel(""None"")\n                firstValueLabel.setObjectName(key + \'value1\')\n                firstValueLabel.setStyleSheet(self.labelStyleSheet)\n                #self.edgeGridLayout.addWidget(firstValueLabel, count, 3)\n                secondValueLabel = QLabel(""None"")\n                secondValueLabel.setObjectName(key + \'value2\')\n                secondValueLabel.setStyleSheet(self.labelStyleSheet)\n                self.edgeGridLayout.addWidget(secondValueLabel, count, 3)\n                count += 1\n\n    def checkBoxEdited(self, state):\n        if state == QtCore.Qt.Checked:\n            self.openRandomDialog(self.sender().objectName())\n        else:\n            if getattr(self.sender(), ""type"") == ""VERTEX"":\n                row = self.vertexGridLayout.getItemPosition(self.vertexGridLayout.indexOf(self.sender()))[0]\n                col = self.vertexGridLayout.getItemPosition(self.vertexGridLayout.indexOf(self.sender()))[1]\n                dist = self.vertexGridLayout.itemAtPosition(row, col + 1).widget().text()\n                value = self.vertexGridLayout.itemAtPosition(row, col + 3).widget().text()\n                res = float(re.findall(""\\d+\\.\\d+"", value)[0])\n                vertexToRemove = [dist, res, self.sender().objectName()]\n                self.vertexAttr.remove(vertexToRemove)\n                print(self.vertexAttr)\n                print(vertexToRemove)\n            else:\n                row = self.vertexGridLayout.getItemPosition(self.vertexGridLayout.indexOf(self.sender()))[0]\n                col = self.vertexGridLayout.getItemPosition(self.vertexGridLayout.indexOf(self.sender()))[1]\n                dist = self.vertexGridLayout.itemAtPosition(row, col + 1).widget().text()\n                value = self.vertexGridLayout.itemAtPosition(row, col + 3).widget().text()\n                res = float(re.findall(""\\d+\\.\\d+"", value)[0])\n                vertexToRemove = [dist, res, self.sender().objectName()]\n                self.edgeAttr.remove(vertexToRemove)\n            self.count -= 1\n        if self.count == 0:\n            self.generateBtn.setEnabled(False)\n\n    def openRandomDialog(self, name):\n        randomDialog = RealTimeRandomDialog(self.canvas, getattr(self.sender(), ""type""))\n        self.setObjectName(name)\n        setattr(randomDialog, ""update"", False)\n        randomDialog.exec()\n        randomDialog.attrBack.append(name)\n        if getattr(self.sender(), ""type"").upper() == ""EDGE"":\n            if len(randomDialog.attrBack) == 3:\n                self.edgeAttr.append(randomDialog.attrBack)\n                self.count += 1\n                self.notify(randomDialog.attrBack, getattr(self.sender(), ""type""))\n        else:\n            if len(randomDialog.attrBack) == 3:\n                self.vertexAttr.append(randomDialog.attrBack)\n                self.count += 1\n                self.notify(randomDialog.attrBack, getattr(self.sender(), ""type""))\n        if self.count > 0:\n            self.generateBtn.setEnabled(True)\n\n    def realTimeEvent(self):\n        self.realtimeMode.vertexAttr = self.vertexAttr\n        self.realtimeMode.edgeAttr = self.edgeAttr\n        self.realtimeMode.fps = self.fps\n        self.canvas.addMode(self.realtimeMode)\n        self.notiLabel.setText(""Real Time Mode: ON!"")\n\n    def notify(self, mes, type):\n        dist, value2, name = mes\n        if type is ""VERTEX"":\n            for r in range(1, self.vertexGridLayout.rowCount()):\n                for c in range(2, self.vertexGridLayout.columnCount()):\n                    item = self.vertexGridLayout.itemAtPosition(r, c)\n                    if item is not None:\n                        if dist == ""Normal Distribution"":\n                            if (item.widget()).objectName() == (name + \'dist\'):\n                                (item.widget()).setText(dist)\n                            if (item.widget()).objectName() == (name + \'value2\'):\n                                (item.widget()).setText(""Std = "" + str(value2))\n                        else:\n                            if (item.widget()).objectName() == (name + \'dist\'):\n                                (item.widget()).setText(dist)\n                            if (item.widget()).objectName() == (name + \'value2\'):\n                                (item.widget()).setText(""Interval = "" + str(value2))\n        else:\n            for r in range(1, self.edgeGridLayout.rowCount()):\n                for c in range(2, self.edgeGridLayout.columnCount()):\n                    item = self.edgeGridLayout.itemAtPosition(r, c)\n                    if item is not None:\n                        if dist == ""Normal Distribution"":\n                            if (item.widget()).objectName() == (name + \'dist\'):\n                                (item.widget()).setText(dist)\n                            if (item.widget()).objectName() == (name + \'value2\'):\n                                (item.widget()).setText(""Std = "" + str(value2))\n                        else:\n                            if (item.widget()).objectName() == (name + \'dist\'):\n                                (item.widget()).setText(dist)\n                            if (item.widget()).objectName() == (name + \'value2\'):\n                                (item.widget()).setText(""Interval = "" + str(value2))\n'"
qt/RealTimeRandomDialog.py,0,"b'import numpy as np\nfrom PyQt5.QtGui import QIcon\nfrom PyQt5.QtWidgets import QDialog, QComboBox, QVBoxLayout, QLabel, QLineEdit, QPushButton\nfrom PyQt5.uic import loadUi\n\nfrom canvas import Canvas\nfrom .utils import BuddyLabel, clearLayout, textEdited\n\nDIST = [\n    \'Normal distribution\',\n    \'Uniform distribution\'\n]\n\n\nclass RealTimeRandomDialog(QDialog):\n    def __init__(self, canvas: Canvas, type):\n        super().__init__()\n        self.canvas = canvas\n        self.type = type\n        self.g = canvas.g\n        self.attr = self.sender().objectName()\n        loadUi(\'resource/gui/RandomDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Random data"")\n        self.distLayout = self.findChild(QVBoxLayout, \'distLayout\')\n        self.selectDistribution = self.findChild(QComboBox, \'distBox\')\n        self.randomLayout = self.findChild(QVBoxLayout, \'randomLayout\')\n        self.generateBtn = self.findChild(QPushButton, \'generate_btn\')\n        self.notiLabel = self.findChild(QLabel, \'notiLabel\')\n        self.notiLabel.setWordWrap(True)\n        self.addDistSelectOptions()\n        self.labelStyleSheet = (""color: rgb(180,180,180);""\n                                ""font-size: 15px;""\n                                ""background-color: transparent;"")\n        self.buttonStyleSheet = (""QPushButton{""\n                                 ""color: rgb(200, 200, 200);""\n                                 ""border-style: 2px solid rgb(200, 200, 200);""\n                                 ""border-radius: 7px;""\n                                 ""background-color: #383838;""\n                                 ""}""\n                                 ""QPushButton:hover{""\n                                 "" background-color: #303030;""\n                                 ""}""\n                                 )\n\n        self.valueLabelStyleSheet = (""QLabel { font-size: 11px; border: 1px solid rgb(150, 150, 150); ""\n                                     ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                     ""border-radius: 5px; }""\n                                     ""QLabel:hover {background-color: #242424;}""\n                                     ""QLineEdit {  font-size: 11px; border: 1px solid rgb(150, 150, 150); ""\n                                     ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                     ""border-radius: 5px; }""\n                                     ""QLineEdit:hover{background-color: #242424;}"")\n\n        self.meanEdit = QLineEdit()\n        self.mean = BuddyLabel(self.meanEdit)\n\n        self.standardDeviationEdit = QLineEdit()\n        self.standardDeviation = BuddyLabel(self.standardDeviationEdit)\n\n        self.minEdit = QLineEdit()\n        self.min = BuddyLabel(self.minEdit)\n\n        self.intervalEdit = QLineEdit()\n        self.interval = BuddyLabel(self.intervalEdit)\n\n        self.valueLabelStyleSheet = (""QLabel { font-size: 11px; border: 1px solid rgb(150, 150, 150); ""\n                                     ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                     ""border-radius: 5px; }""\n                                     ""QLabel:hover{background-color: #242424;}""\n                                     ""QLineEdit {  font-size: 11px; border: 1px solid rgb(150, 150, 150); ""\n                                     ""padding: 2px; color: rgb(220,220,220); background-color: #383838;""\n                                     ""border-radius: 5px; }""\n                                     ""QLineEdit:hover{background-color: #242424;}"")\n        self.attrBack = []\n\n        self.randomArr = []\n        self.update = True\n\n    def changeDist(self, opt):\n        [\n            self.default,\n            self.normalDistribution,\n            self.uniformDistribution,\n        ][opt]()\n\n    def addDistSelectOptions(self):\n        self.selectDistribution.addItems([\'-- None --\'])\n        self.selectDistribution.addItems([opt for opt in DIST])\n        self.selectDistribution.currentIndexChanged.connect(self.changeDist)\n\n    def default(self):\n        clearLayout(self.randomLayout)\n\n    def normalDistribution(self):\n        clearLayout(self.randomLayout)\n\n        stdevLabel = QLabel(\'Standard Deviation: \')\n        stdevLabel.setStyleSheet(self.labelStyleSheet)\n        self.randomLayout.addWidget(stdevLabel)\n        self.standardDeviationEdit.setStyleSheet(self.valueLabelStyleSheet)\n        self.standardDeviation.setStyleSheet(self.valueLabelStyleSheet)\n        self.randomLayout.addWidget(self.standardDeviation)\n        self.randomLayout.addWidget(self.standardDeviationEdit)\n\n        self.standardDeviationEdit.editingFinished.connect(\n            textEdited(self.standardDeviation, self.standardDeviationEdit))\n        self.generateBtn.pressed.connect(self.generateNormalDistribution)\n\n    def uniformDistribution(self):\n\n        try:\n            clearLayout(self.randomLayout)\n\n            maxLabel = QLabel(\'Interval: \')\n            maxLabel.setStyleSheet(self.labelStyleSheet)\n            self.interval.setStyleSheet(self.valueLabelStyleSheet)\n            self.intervalEdit.setStyleSheet(self.valueLabelStyleSheet)\n            self.randomLayout.addWidget(maxLabel)\n            self.randomLayout.addWidget(self.interval)\n            self.randomLayout.addWidget(self.intervalEdit)\n\n            self.intervalEdit.editingFinished.connect(textEdited(self.interval, self.intervalEdit))\n            self.generateBtn.pressed.connect(self.generateUniformDistribution)\n        except Exception as e:\n            print(e.__traceback__.tb_lineno, "" "", e)\n\n    def generateNormalDistribution(self):\n        stdDeviation = float(self.standardDeviationEdit.text())\n        print(stdDeviation)\n        self.notiLabel.setText(\n            ""Generated Normal Distribution with \\n Standard Deviation = "" + str(stdDeviation))\n        self.attrBack.append(""Normal Distribution"")\n        self.attrBack.append(stdDeviation)\n        self.generateBtn.hide()\n\n    def generateUniformDistribution(self):\n\n        try:\n            val = float(self.intervalEdit.text())\n            print(""Interval = "", val)\n            self.notiLabel.setText(""Generated Uniform Distribution with \\n interval = "" + str(val))\n            self.attrBack.append(""Uniform Distribution"")\n            self.attrBack.append(val)\n        except Exception as e:\n            print(e.__traceback__.tb_lineno, "" "", e)\n        self.generateBtn.hide()\n\n    def changeEdge(self, attributeName, randomArr):\n        count = 0\n        for i in self.g.es:\n            i[attributeName] = randomArr[count]\n            count = count + 1\n\n    def changeVertex(self, attributeName, randomArr):\n        count = 0\n        for i in self.g.vs:\n            i[attributeName] = randomArr[count]\n            count = count + 1\n\n    def getAttr(self):\n        return self.attrBack\n'"
qt/RenameDialog.py,0,"b'from PyQt5.QtGui import QIcon\nfrom PyQt5.QtWidgets import QDialog, QComboBox, QPushButton, QLabel\nfrom PyQt5.uic import loadUi\n\nfrom canvas import Canvas\n\n\nclass RenameDialog(QDialog):\n    def __init__(self, canvas: Canvas, newAttributeName):\n        super().__init__()\n        self.newAttributeName = newAttributeName\n        self.canvas = canvas\n        loadUi(\'resource/gui/RenameDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Rename an Attribute"")\n        self.attribute = self.findChild(QComboBox, \'comboBox\')\n        self.renameBtn = self.findChild(QPushButton, \'pushButton\')\n        self.label = self.findChild(QLabel, \'label\')\n        self.label.setText(\'Choose an attribute to be renamed as ""\' + self.newAttributeName + \'"" \')\n        self.type = getattr(self.sender(), ""type"")\n        self.addSelectOptions()\n\n    def addSelectOptions(self):\n        if self.type == ""EDGE"":\n            self.attribute.addItems(self.canvas.g.es.attributes())\n            self.renameBtn.clicked.connect(self.rename)\n        else:\n            self.attribute.addItems(self.canvas.g.vs.attributes())\n            self.renameBtn.clicked.connect(self.rename)\n\n    def rename(self):\n        ev = self.canvas.g.es if self.type == \'EDGE\' else self.canvas.g.vs\n        key = ev.attributes()[self.attribute.currentIndex()]\n        ev[self.newAttributeName] = ev[key]\n        del ev[key]\n        self.label.setText(f\'""{key}"" has been renamed to ""{self.newAttributeName}""\')\n        self.renameBtn.setText(""Close"")\n        self.renameBtn.clicked.connect(self.close)\n'"
qt/ShortestPathWeightDialog.py,0,"b'from PyQt5.QtGui import QIcon\nfrom PyQt5.QtWidgets import QDialog, QComboBox, QPushButton, QLabel\nfrom PyQt5.uic import loadUi\n\nfrom canvas import Canvas, ShortestPathMode\n\n\nclass ShortestPathWeightDialog(QDialog):\n    def __init__(self, canvas: Canvas, shortestPathMode: ShortestPathMode):\n        super().__init__()\n        self.canvas = canvas\n        self.shortestPathMode = shortestPathMode\n\n        loadUi(\'resource/gui/ShortestPathWeightDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Network Visualization - Team Black - Input Weight"")\n        self.selectWeight = self.findChild(QComboBox, \'selectWeight\')\n        self.btn = self.findChild(QPushButton, \'pushButton\')\n        self.label = self.findChild(QLabel, \'label\')\n        self.addSelectOptions()\n\n    def addSelectOptions(self):\n        self.selectWeight.addItems([\'-- None --\'] + self.canvas.g.es.attributes())\n        self.btn.pressed.connect(self.changeWeight)\n\n    def changeWeight(self):\n        opt = self.selectWeight.currentIndex()\n        self.shortestPathMode.weight = None if opt == 0 else self.canvas.g.es.attributes()[opt - 1]\n        self.label.setText(""Close the dialog and choose \\n2 nodes to find the shortest path"")\n        self.btn.setText(""Close"")\n        self.btn.pressed.connect(self.close)\n'"
qt/StatDialog.py,3,"b'from math import isnan, isinf\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom PyQt5.QtGui import QIcon\nfrom PyQt5.QtWidgets import QVBoxLayout, QWidget, QComboBox, QSizePolicy, QTabWidget, QLabel\nfrom PyQt5.uic import loadUi\nfrom igraph import VertexSeq\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\nfrom matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar\n\nfrom canvas import Canvas, CENTRALITY_OPTIONS\nfrom .utils import clearLayout\n\n\nclass StatDialog(QWidget):\n    def __init__(self, canvas: Canvas):\n        super().__init__()\n        self.canvas = canvas\n        loadUi(\'resource/gui/StatDialog.ui\', self)\n        self.setWindowIcon(QIcon(\'resource/gui/icon.ico\'))\n        self.setWindowTitle(""Network Visualization - Team Black - Statistics"")\n\n        self.tabWidget = self.findChild(QTabWidget, \'tabWidget\')\n        self.tabWidget.setCurrentIndex(0)\n\n        self.simpleAttrGraph = self.findChild(QVBoxLayout, \'simpleAttrGraph\')\n        self.selectStyleSA = self.findChild(QComboBox, \'selectStyleSA\')\n        self.selectEV = self.findChild(QComboBox, \'selectEV\')\n        self.selectAttr = self.findChild(QComboBox, \'selectAttr\')\n        self.styleSA = \'bmh\'\n        self.ev = canvas.g.vs\n\n        self.computedAttrGraph = self.findChild(QVBoxLayout, \'computedAttrGraph\')\n        self.selectStyleCA = self.findChild(QComboBox, \'selectStyleCA\')\n        self.centralityAttr = self.findChild(QComboBox, \'centralityAttr\')\n        self.centralityWeight = self.findChild(QComboBox, \'centralityWeight\')\n        self.comparableAttr = self.getComparableAttr()\n        self.styleCA = \'bmh\'\n        self.floatCentralityAttr = self.getFloatCentralityAttr()\n\n        self.addSelectOptions()\n\n        self.changeEV(0)\n        self.recalculateCentrality(None)\n        self.calculateSummary()\n\n    def addSelectOptions(self):\n        # Edge / vertex\n        self.selectEV.addItems([\'Vertex\', \'Edge\'])\n        self.selectEV.currentIndexChanged.connect(self.changeEV)\n        # Attr\n        self.selectAttr.currentIndexChanged.connect(self.changeAttr)\n        # Graph Style Opt\n        self.selectStyleSA.addItems(plt.style.available)\n        self.selectStyleSA.currentIndexChanged.connect(self.changeStyleSA)\n\n        # Centrality\n        self.centralityAttr.addItems([opt[0] for opt in CENTRALITY_OPTIONS])\n        self.centralityAttr.currentIndexChanged.connect(self.recalculateCentrality)\n        # Centrality weight\n        self.centralityWeight.addItems(self.floatCentralityAttr)\n        self.centralityWeight.currentIndexChanged.connect(self.recalculateCentrality)\n        # Graph Style Opt\n        self.selectStyleCA.addItems(plt.style.available)\n        self.selectStyleCA.currentIndexChanged.connect(self.changeStyleCA)\n\n    def calculateSummary(self):\n        g = self.canvas.g\n        componentCount = len(g.components().subgraphs())\n        self.findChild(QLabel, \'totalE\').setText(str(g.ecount()))\n        self.findChild(QLabel, \'totalV\').setText(str(g.vcount()))\n        self.findChild(QLabel, \'componentCount\').setText(str(componentCount))\n        self.findChild(QLabel, \'isConnected\').setText(str(componentCount == 1))\n        self.findChild(QLabel, \'isMultigraph\').setText(str(g.has_multiple()))\n        self.findChild(QLabel, \'avgDegree\').setText(str(np.mean(g.degree()))[:6])\n        self.findChild(QLabel, \'density\').setText(str(g.density())[:6])\n        self.findChild(QLabel, \'diameter\').setText(str(g.diameter()))\n        self.findChild(QLabel, \'radius\').setText(str(g.radius()))\n\n    def getComparableAttr(self):\n        if len(self.ev) == 0:\n            return []\n\n        def isStrOrFloat(v):\n            return isinstance(v, str) or isinstance(v, float)\n\n        return [attr for attr in self.ev.attributes() if isStrOrFloat(self.ev[0][attr])]\n\n    def getFloatCentralityAttr(self):\n        es = self.canvas.g.es\n        if len(es) == 0:\n            return []\n        return [attr for attr in es.attributes() if isinstance(es[0][attr], float)]\n\n    def changeEV(self, opt):\n        self.ev = getattr(self.canvas.g, [\'vs\', \'es\'][opt])\n        self.comparableAttr = self.getComparableAttr()\n        self.selectAttr.clear()\n        self.selectAttr.addItems(self.comparableAttr)\n        self.changeAttr(0)\n\n    def changeAttr(self, opt):\n        attr = self.comparableAttr[opt]\n        clearLayout(self.simpleAttrGraph)\n        ev = \'Vertices\' if isinstance(self.ev, VertexSeq) else \'Edges\'\n        w = WidgetPlot(ev, attr, self.ev[attr], self.styleSA)\n        self.simpleAttrGraph.addWidget(w)\n\n    def changeStyleSA(self, opt):\n        self.styleSA = plt.style.available[opt]\n        i = int(self.selectAttr.currentIndex())\n        self.changeAttr(i)\n\n    def recalculateCentrality(self, opt):\n        centrality = CENTRALITY_OPTIONS[self.centralityAttr.currentIndex()]\n        weight = self.floatCentralityAttr[self.centralityWeight.currentIndex()]\n        values = getattr(self.canvas.g, centrality[1])(weights=weight)\n        clearLayout(self.computedAttrGraph)\n        w = WidgetPlot(\'Vertices\', centrality[0], values, self.styleCA)\n        self.computedAttrGraph.addWidget(w)\n\n    def changeStyleCA(self, opt):\n        self.styleCA = plt.style.available[opt]\n        self.recalculateCentrality(None)\n\n\nclass WidgetPlot(QWidget):\n    def __init__(self, ev, attr, values, style):\n        super().__init__()\n        layout = QVBoxLayout()\n        self.setLayout(layout)\n        self.plot = Plot(ev, attr, values, style)\n        self.toolbar = NavigationToolbar(self.plot, self)\n        layout.addWidget(self.toolbar)\n        layout.addWidget(self.plot)\n\n\nclass Plot(FigureCanvas):\n    def __init__(self, ev, attr, values, style):\n        with plt.style.context(style):\n            weightArr = list(filter(lambda x: isinstance(x, str) or not (isnan(x) or isinf(x)), values))\n            fig, ax = plt.subplots()\n            num_bins = 30\n            ax.set_title(attr + \' distribution\')\n            ax.set_ylabel(\'Number of \' + ev)\n            if isinstance(values[0], str):\n                labels = sorted(list(set(values)))\n                ax.set_xticklabels(labels, rotation=90)\n                num_bins = len(labels)\n            if weightArr and isinstance(weightArr[0], float):\n                meanLine = ax.axvline(np.mean(weightArr), color=\'r\', linestyle=\'--\')\n                medianLine = ax.axvline(np.median(weightArr), color=\'b\', linestyle=\'-\')\n                plt.legend([meanLine, medianLine], [\'Mean\', \'Median\'])\n            ax.hist(weightArr, num_bins)\n\n        FigureCanvas.__init__(self, fig)\n        self.setParent(None)\n        FigureCanvas.setSizePolicy(self, QSizePolicy.Expanding, QSizePolicy.Expanding)\n        FigureCanvas.updateGeometry(self)\n'"
qt/__init__.py,0,b''
qt/utils.py,0,"b""from PyQt5.QtWidgets import QLabel\n\n\ndef clearLayout(layout):\n    for i in reversed(range(layout.count())):\n        layout.itemAt(i).widget().deleteLater()\n\n\nclass BuddyLabel(QLabel):\n    def __init__(self, buddy, parent=None):\n        super(BuddyLabel, self).__init__(parent)\n        self.buddy = buddy\n        self.buddy.hide()\n\n    # When it's clicked, hide itself and show its buddy\n    def mousePressEvent(self, event):\n        self.hide()\n        self.buddy.show()\n        self.buddy.setFocus()  # Set focus on buddy so user doesn't have to click again\n\n\ndef textEdited(label, edit):\n    def func():\n        if edit.text():\n            label.setText(str(edit.text()))\n            edit.hide()\n            label.show()\n        else:\n            # If the input is left empty, revert back to the label showing\n            edit.hide()\n            label.show()\n\n    return func\n"""
