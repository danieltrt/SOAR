file_path,api_count,code
demo.py,0,"b'import os\n# We\'ll render HTML templates and access data sent by POST\n# using the request object from flask. Redirect and url_for\n# will be used to redirect the user once the upload is done\n# and send_from_directory will help us to send/show on the\n# browser the file that the user just uploaded\nfrom flask import Flask, render_template, request, redirect, url_for, send_from_directory, jsonify\nfrom werkzeug import secure_filename\nimport detect, face_recognizer\n\n# Initialize the Flask application\napp = Flask(__name__)\n\n# This is the path to the upload directory\napp.config[\'UPLOAD_FOLDER\'] = \'uploads/\'\n# These are the extension that we are accepting to be uploaded\napp.config[\'ALLOWED_EXTENSIONS\'] = set([\'png\', \'jpg\', \'jpeg\'])\n\n# For a given file, return whether it\'s an allowed type or not\ndef allowed_file(filename):\n    return \'.\' in filename and \\\n           filename.rsplit(\'.\', 1)[1] in app.config[\'ALLOWED_EXTENSIONS\']\n\n# This route will show a form to perform an AJAX request\n# jQuery is loaded to execute the request and update the\n# value of the operation\n@app.route(\'/\')\ndef index():\n    return render_template(\'index.html\')\n\nfile =None\n\n# Route that will process the file upload\n@app.route(\'/upload\', methods=[\'GET\',\'POST\'])\ndef upload():\n    # Get the name of the uploaded file\n    file = request.files[\'file\']\n    # Check if the file is one of the allowed types/extensions\n    if file and allowed_file(file.filename):\n        # Make the filename safe, remove unsupported chars\n        filename = secure_filename(file.filename)\n        # Move the file form the temporal folder to\n        # the upload folder we setup\n        file.save(os.path.join(app.config[\'UPLOAD_FOLDER\'], filename))\n        detect.doDetect(file)\n        present_student_list = face_recognizer.doFaceRecognition()\n        return jsonify (\n        \tstudents_present=present_student_list)\n\n\treturn ""something went wrong""\n        # Redirect the user to the uploaded_file route, which\n        # will basicaly show on the browser the uploaded file\n        # return redirect(url_for(\'uploaded_file\',\n        #                         filename=filename))\n@app.route(\'/uploads/<filename>\')\ndef uploaded_file(filename):\n    #return send_from_directory(app.config[\'UPLOAD_FOLDER\'], filename)\n \t#detect.doDetect(file)\n \tif file is None:\n\t\treturn ""File is none""\n #    if file is not None:\n #    \t# present_student = face_recognizer.doFaceRecognition()\n #    \treturn ""file is not none""\n\treturn ""file is not none""\n    \t\nif __name__ == \'__main__\':\n    app.run()\n'"
detect.py,0,"b'import cv2\nimport os\nimport sys\nfrom string import Template\nfrom PIL import Image\n\n\ndef doDetect(filename):\n  dirname = \'/home/dark_knight/hackerrank/demo\'\n\n  # first argument is the haarcascades path\n\n\n  face_cascade_path = ""haarcascade_frontalface_default.xml""\n  face_cascade = cv2.CascadeClassifier(os.path.expanduser(face_cascade_path))\n\n  scale_factor = 1.1\n  min_neighbors = 3\n  min_size = (30, 30)\n  flags = cv2.cv.CV_HAAR_SCALE_IMAGE\n\n  count = 1\n    #for infname in sys.argv[1:]:\n  for infname in filename:\n    image_path = os.path.expanduser(infname)\n    image = cv2.imread(image_path)\n\n    faces = face_cascade.detectMultiScale(image, scaleFactor = scale_factor, minNeighbors = min_neighbors,\n    minSize = min_size, flags = flags)\n\n    for( x, y, w, h ) in faces:\n       cv2.rectangle(image, (x, y), (x + w, y + h), (255, 255, 0), 2)\n       outfname = ""%s.faces.jpg"" % os.path.basename(infname)\n       cv2.imwrite(os.path.join(dirname,outfname), image)\n\n       img = Image.open(image_path)\n       x = img.crop ((x, y, x+w, y+h))\n       x.save (\'crop/subject\' + str (count) + \'.jpg\')\n       #img.close()\n       count += 1\n'"
face_recognizer.py,1,"b'#!/usr/bin/python\n\n# Import the required modules\nimport cv2, os\nimport numpy as np\nfrom PIL import Image\n\ndef doFaceRecognition():\n# For face detection we will use the Haar Cascade provided by OpenCV.\n    cascadePath = ""haarcascade_frontalface_default.xml""\n    faceCascade = cv2.CascadeClassifier(cascadePath)\n\n    # For face recognition we will the the LBPH Face Recognizer \n    recognizer = cv2.createLBPHFaceRecognizer()\n\n    path = \'./crop\'\n\n    present_student = [] #list to hold the sap ids of present students. I guess it is stored in variable\n    recognizer.load(""model.yml"")\n\n    # Append the images with the extension .jpg into image_paths\n    image_paths = [os.path.join(path, f) for f in os.listdir(path) if f.endswith(\'.jpg\')]\n    for image_path in image_paths:\n        predict_image_pil = Image.open(image_path).convert(\'L\')\n        predict_image = np.array(predict_image_pil, \'uint8\')\n        faces = faceCascade.detectMultiScale(predict_image)\n        for (x, y, w, h) in faces:\n            nbr_predicted, conf = recognizer.predict(predict_image[y: y + h, x: x + w])\n            nbr_actual = int(os.path.split(image_path)[1].split(""."")[0].replace(""subject"", """"))\n            if nbr_actual == nbr_predicted:\n                print ""{} is first wala recognized as {}"".format(nbr_actual, conf)\n            else:\n                #print ""{} is second wala recognized as {}"".format(nbr_actual, nbr_predicted)\n                present_student.append(nbr_predicted)\n\n            #cv2.imshow(""Recognizing Face"", predict_image[y: y + h, x: x + w])\n            #cv2.waitKey(1000)\n    for studens in present_student:\n        print studens\n    return present_student'"
facedetectionsolved/detect.py,0,"b'import cv2\nimport os\nimport sys\nfrom string import Template\nfrom PIL import Image\n\n# first argument is the haarcascades path\nface_cascade_path = sys.argv[1]\nface_cascade = cv2.CascadeClassifier(os.path.expanduser(face_cascade_path))\n\nscale_factor = 1.1\nmin_neighbors = 3\nmin_size = (30, 30)\nflags = cv2.cv.CV_HAAR_SCALE_IMAGE\n\ncount = 1\n\nfor infname in sys.argv[2:]:\n   image_path = os.path.expanduser(infname)\n   image = cv2.imread(image_path)\n\n   faces = face_cascade.detectMultiScale(image, scaleFactor = scale_factor, minNeighbors = min_neighbors,\n    minSize = min_size, flags = flags)\n\n   for( x, y, w, h ) in faces:\n     cv2.rectangle(image, (x, y), (x + w, y + h), (255, 255, 0), 2)\n     outfname = ""%s.faces.jpg"" % os.path.basename(infname)\n     cv2.imwrite(os.path.expanduser(outfname), image)\n\n     img = Image.open(image_path)\n     x = img.crop ((x, y, x+w, y+h))\n     x.save (\'subject\' + str (count) + \'.jpg\')\n     #img.close()\n     count += 1'"
