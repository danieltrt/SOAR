file_path,api_count,code
hpatches_extract_numpysift.py,4,"b'import sys\nimport argparse\nimport time\nimport os\nimport sys\nimport cv2\nimport math\nimport numpy as np\nfrom tqdm import tqdm\nfrom numpy_sift import SIFTDescriptor\nfrom copy import deepcopy\nimport random\nimport time\nimport numpy as np\nimport glob\nimport os\n\nassert len(sys.argv)==3, ""Usage python hpatches_extract_numpysift.py hpatches_db_root_folder 64""\nOUT_W = int(sys.argv[2])    \n# all types of patches \ntps = [\'ref\',\'e1\',\'e2\',\'e3\',\'e4\',\'e5\',\'h1\',\'h2\',\'h3\',\'h4\',\'h5\',\\\n       \'t1\',\'t2\',\'t3\',\'t4\',\'t5\']\n\nclass hpatches_sequence:\n    """"""Class for loading an HPatches sequence from a sequence folder""""""\n    itr = tps\n    def __init__(self,base):\n        name = base.split(\'/\')\n        self.name = name[-1]\n        self.base = base\n        for t in self.itr:\n            im_path = os.path.join(base, t+\'.png\')\n            im = cv2.imread(im_path,0)\n            self.N = im.shape[0]/65\n            setattr(self, t, np.split(im, self.N))\n            \n    \nseqs = glob.glob(sys.argv[1]+\'/*\')\nseqs = [os.path.abspath(p) for p in seqs]     \n\ndescr_name = \'numpy-sift-\'+str(OUT_W)\n\nmodel = SIFTDescriptor(patchSize = OUT_W)\n\n\nfor seq_path in seqs:\n    seq = hpatches_sequence(seq_path)\n    path = os.path.join(descr_name,seq.name)\n    if not os.path.exists(path):\n        os.makedirs(path)\n    descr = np.zeros((int(seq.N),128)) # trivial (mi,sigma) descriptor\n    for tp in tps:\n        print(seq.name+\'/\'+tp)\n        if os.path.isfile(os.path.join(path,tp+\'.csv\')):\n            continue\n        n_patches = 0\n        for i,patch in enumerate(getattr(seq, tp)):\n            n_patches+=1\n        t = time.time()\n        descriptors = np.zeros((n_patches, 128))\n        if OUT_W != 65:\n            for i,patch in enumerate(getattr(seq, tp)):\n                descriptors[i,:] = model.describe(cv2.resize(patch,(OUT_W,OUT_W)))\n        else:\n            for i,patch in enumerate(getattr(seq, tp)):\n                descriptors[i,:] = model.describe(patch)\n        np.savetxt(os.path.join(path,tp+\'.csv\'), descriptors.astype(np.uint8), delimiter=\',\', fmt=\'%d\')\n'"
numpy_sift.py,34,"b'import numpy as np\nimport math\nimport time\n\nclass SIFTDescriptor(object):\n    """"""Class for computing SIFT descriptor of the square patch\n\n    Attributes:\n        patchSize: size of the patch in pixels \n        maxBinValue: maximum descriptor element after L2 normalization. All above are clipped to this value\n        numOrientationBins: number of orientation bins for histogram\n        numSpatialBins: number of spatial bins. The final descriptor size is numSpatialBins x numSpatialBins x numOrientationBins\n    """"""\n    def precomputebins(self):\n        halfSize = int(self.patchSize/2)\n        ps = self.patchSize\n        sb = self.spatialBins;\n        step = float(self.spatialBins + 1) / (2 * halfSize)\n        precomp_bins = np.zeros(2*ps, dtype = np.int32)\n        precomp_weights = np.zeros(2*ps, dtype = np.float)\n        precomp_bin_weights_by_bx_py_px_mapping = np.zeros((sb,sb,ps,ps), dtype = np.float)\n        for i in range(ps):\n            i1 = i + ps\n            x = step * i\n            xi = int(x)\n            # bin indices\n            precomp_bins[i] = xi -1;\n            precomp_bins[i1] = xi\n            #bin weights\n            precomp_weights[i1] = x - xi;\n            precomp_weights[i] = 1.0 - precomp_weights[i1];\n            #truncate \n            if  (precomp_bins[i] < 0):\n                precomp_bins[i] = 0;\n                precomp_weights[i] = 0\n            if  (precomp_bins[i] >= self.spatialBins):\n                precomp_bins[i] = self.spatialBins - 1;\n                precomp_weights[i] = 0\n            if  (precomp_bins[i1] < 0):\n                precomp_bins[i1] = 0;\n                precomp_weights[i1] = 0\n            if  (precomp_bins[i1] >= self.spatialBins):\n                precomp_bins[i1] = self.spatialBins - 1;\n                precomp_weights[i1] = 0\n        for y in range(ps):\n            for x in range(ps):\n                precomp_bin_weights_by_bx_py_px_mapping[precomp_bins[y], precomp_bins[x], y, x ] += precomp_weights[y]*precomp_weights[x]\n                precomp_bin_weights_by_bx_py_px_mapping[precomp_bins[y+ps], precomp_bins[x], y, x ] += precomp_weights[y+ps]*precomp_weights[x]\n                precomp_bin_weights_by_bx_py_px_mapping[precomp_bins[y], precomp_bins[x+ps], y, x ] += precomp_weights[y]*precomp_weights[x+ps]\n                precomp_bin_weights_by_bx_py_px_mapping[precomp_bins[y+ps], precomp_bins[x+ps], y, x ] += precomp_weights[y+ps]*precomp_weights[x+ps]\n        if self.mask_type == \'CircularGauss\':\n            mask = self.CircularGaussKernel(kernlen=self.patchSize, circ=True, sigma_type=self.sigma_type).astype(np.float32)\n        elif self.mask_type == \'Gauss\':\n            mask = self.CircularGaussKernel(kernlen=self.patchSize, circ=False, sigma_type=self.sigma_type).astype(np.float32)\n        else:\n            raise ValueError(masktype, \'is unknown mask type\')\n\n        for y in range(sb):\n            for x in range(sb):\n                precomp_bin_weights_by_bx_py_px_mapping[y,x,:,:] *= mask\n                precomp_bin_weights_by_bx_py_px_mapping[y,x,:,:] = np.maximum(0,precomp_bin_weights_by_bx_py_px_mapping[y,x,:,:])\n        return precomp_bins.astype(np.int32),precomp_weights,precomp_bin_weights_by_bx_py_px_mapping,mask\n    def __repr__(self):\n            return self.__class__.__name__ + \'(\' + \'orientationBins=\' + str(self.orientationBins) +\\\n             \', \' + \'spatialBins=\' + str(self.spatialBins) +\\\n             \', \' + \'patchSize=\' + str(self.patchSize) +\\\n             \', \' + \'sigma_type=\' + str(self.sigma_type) +\\\n             \', \' + \'mask_type=\' + str(self.mask_type) +\\\n             \', \' + \'maxBinValue=\' + str(self.maxBinValue) + \')\'\n\n    def __init__(self, patchSize = 41,\n                 maxBinValue = 0.2,\n                 numOrientationBins = 8,\n                 numSpatialBins = 4,\n                 mask_type = \'CircularGauss\',\n                 sigma_type = \'hesamp\'):\n        self.patchSize = patchSize\n        self.maxBinValue = maxBinValue\n        self.orientationBins = numOrientationBins\n        self.spatialBins = numSpatialBins\n        self.mask_type = mask_type\n        self.sigma_type = sigma_type\n        self.precomp_bins,self.precomp_weights,self.mapping,self.mask = self.precomputebins()\n        self.binaryMask = self.mask > 0\n        self.gx = np.zeros((patchSize,patchSize), dtype=np.float)\n        self.gy = np.zeros((patchSize,patchSize), dtype=np.float)\n        self.ori = np.zeros((patchSize,patchSize), dtype=np.float)\n        self.mag = np.zeros((patchSize,patchSize), dtype=np.float)\n        self.norm_patch = np.zeros((patchSize,patchSize), dtype=np.float)\n        ps = self.patchSize\n        sb = self.spatialBins\n        ob = self.orientationBins\n        self.desc = np.zeros((ob, sb , sb ), dtype = np.float)\n        return\n    def CircularGaussKernel(self,kernlen=21, circ = True, sigma_type = \'hesamp\'):\n        halfSize = float(kernlen) / 2.;\n        r2 = float(halfSize**2);\n        if sigma_type == \'hesamp\':\n            sigma_mul_2 = 0.9 * r2;\n        elif sigma_type == \'vlfeat\':\n            sigma_mul_2 = kernlen**2\n        else:\n            raise ValueError(\'Unknown sigma_type\', sigma_type, \'try hesamp or vlfeat\')\n        disq = 0;\n        kernel = np.zeros((kernlen,kernlen))\n        for y in range(kernlen):\n            for x in range(kernlen):\n                disq = (y - halfSize+0.5)**2 +  (x - halfSize+0.5)**2;\n                kernel[y,x] = math.exp(-disq / sigma_mul_2)\n                if circ and (disq >= r2):\n                    kernel[y,x] = 0.\n        return kernel\n    def photonorm(self, patch, binaryMask = None):\n        if binaryMask is not None:\n            std1_coef = 50. /  np.std(patch[binaryMask])\n            mean1 =  np.mean(patch[binaryMask])\n        else:\n            std1_coef = 50. / np.std(patch)\n            mean1 =  np.mean(patch)\n        if std1_coef >= 50. / 0.000001:\n            std1_coef = 50.0\n        self.norm_patch = 128. + std1_coef * (patch - mean1);\n        self.norm_patch = np.clip(self.norm_patch, 0.,255.);\n        return\n    def getDerivatives(self,image):\n        #[-1 1] kernel for borders\n        self.gx[:,0] = image[:,1] - image[:,0]\n        self.gy[0,:] = image[1,:] - image[0,:]\n        self.gx[:,-1] = image[:,-1] - image[:,-2]\n        self.gy[-1,:] = image[-1,:] - image[-2,:]\n        #[-1 0 1] kernel for the rest\n        self.gy[1:-2,:] = image[2:-1,:] - image[0:-3,:]\n        self.gx[:,1:-2] = image[:,2:-1] - image[:,0:-3]\n        self.gx *= 0.5\n        self.gy *= 0.5\n        return\n    def samplePatch(self,grad,ori):\n        ps = self.patchSize\n        sb = self.spatialBins\n        ob = self.orientationBins\n        o_big = float(ob) * (ori + 2.0*math.pi) / (2.0 * math.pi)\n        bo0_big = np.floor(o_big)#.astype(np.int32)\n        wo1_big = o_big - bo0_big;\n        bo0_big = bo0_big % ob;\n        bo1_big = (bo0_big + 1.0) % ob;\n        wo0_big = 1.0 - wo1_big;\n        wo0_big *= grad;\n        wo0_big = np.maximum(0, wo0_big)\n        wo1_big *= grad;\n        wo1_big = np.maximum(0, wo1_big)\n        ori_weight_map = np.zeros((ob,ps,ps))\n        for o in range(ob):\n            relevant0 = np.where(bo0_big == o)\n            ori_weight_map[o, relevant0[0], relevant0[1]] = wo0_big[relevant0[0], relevant0[1]]\n            relevant1 = np.where(bo1_big == o)\n            ori_weight_map[o, relevant1[0], relevant1[1]] += wo1_big[relevant1[0], relevant1[1]]\n        for y in range(sb):\n            for x in range(sb):\n                self.desc[:,y,x] =  np.tensordot( ori_weight_map, self.mapping[y,x,:,:])\n        return\n    def describe(self,patch, userootsift = False, flatten = True, show_timings = False):\n        t = time.time()\n        self.photonorm(patch, binaryMask = self.binaryMask);\n        if show_timings:\n            print( \'photonorm time = \', time.time() - t)\n            t = time.time()\n        self.getDerivatives(self.norm_patch)\n        if show_timings:\n            print( \'gradients time = \', time.time() - t)\n            t = time.time()\n        self.mag = np.sqrt(self.gx * self.gx + self.gy*self.gy)\n        self.ori = np.arctan2(self.gy,self.gx)\n        if show_timings:\n            print( \'mag + ori time = \', time.time() - t)\n            t = time.time()\n        self.samplePatch(self.mag,self.ori)\n        if show_timings:\n            print( \'sample patch time = \', time.time() - t)\n            t = time.time()\n        self.desc /= np.linalg.norm(self.desc.flatten(),2)\n        self.desc = np.clip(self.desc, 0,self.maxBinValue);\n        self.desc /= np.linalg.norm(self.desc.flatten(),2)\n        if userootsift:\n            self.desc = np.sqrt(self.desc / np.linalg.norm(unnorm_desc.flatten(),1))\n        if show_timings:\n            print( \'clip and norm time = \', time.time() - t)\n            t = time.time()\n        if flatten:\n            return np.clip(512. * self.desc.flatten() , 0, 255).astype(np.int32);\n        else:\n            return np.clip(512. * self.desc , 0, 255).astype(np.int32);\n'"
