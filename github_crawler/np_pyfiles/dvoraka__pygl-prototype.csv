file_path,api_count,code
camera.py,0,"b'# -*- coding: utf-8 -*-\n#\n\n""""""Module for cameras.""""""\n\n# import time\n\nfrom math import sin\nfrom math import cos\nfrom math import pi\nfrom numpy import matrix\nfrom numpy import linalg\n\nimport data\nimport script\n\n\nclass FPSCamera(script.Controllable):\n    """"""Class for first person shooter camera.""""""\n\n    def __init__(\n            self,\n            x_pos=0.0,\n            y_pos=0.0,\n            z_pos=0.0,\n            gravity=False):\n\n        # gravity attributes\n        self.gravity = gravity\n        # falling\n        self.falling = False\n        self.falling_start = None\n        self.falling_mp = 0.0004\n        self.falling_max_speed = 2.5\n\n        self.jump_step_height = 0.17\n        self.jump_steps = 16\n\n        self.falling_counter = 0\n        self.jump_counter = 0\n\n        # camera position\n        self.x_pos = x_pos\n        self.y_pos = y_pos\n        self.z_pos = z_pos\n        self.position = data.Point(self.x_pos, self.y_pos, self.z_pos)\n\n        # camera horizontal and vertical angles in radians\n        self.h_angle = 0.0\n        self.v_angle = 0.0\n\n        # camera rotating sensitivity multipliers\n        self.h_multiplier = 0.005\n        self.v_multiplier = 0.01\n\n        self.inverse_horizontal = False\n        self.inverse_vertical = False\n\n        # camera min and max vertical angles\n        self.v_angle_min = - pi / 3\n        self.v_angle_max = pi / 3\n\n        self.step = 0.045\n        self.sprint_mp = 1.8\n        self.side_step = self.step\n        self.back_step = 0.2\n        self.fly_step = 1.0\n\n        self.helper_step = 0.1\n\n    def get_position(self):\n        """"""Return camera position as a Point.\n\n        Return:\n            Point: the camera position\n        """"""\n\n        self.position.set_position(self.x_pos, self.y_pos, self.z_pos)\n\n        return self.position\n\n    def get_position_inverse_z(self):\n        """"""Return camera position as a Point.\n\n        Return:\n            Point: the camera position with inverse z axis\n        """"""\n\n        position = self.get_position()\n        position.z = - position.z\n\n        return position\n\n    def next_fw_x_point(self, offset=0.0):\n        """"""Return next forward x axis Point.""""""\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = self.fw_coll_matrix(offset)\n\n        result = trans_matrix * pos_vec\n\n        pos_list = result.tolist()\n\n        next_x = pos_list[0][0]\n\n        return data.Point(next_x, self.y_pos, self.z_pos)\n\n    def next_fw_z_point(self, offset=0.0):\n        """"""Return next forward z axis Point.""""""\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = self.fw_coll_matrix(offset)\n\n        result = trans_matrix * pos_vec\n\n        pos_list = result.tolist()\n\n        next_z = pos_list[2][0]\n\n        return data.Point(self.x_pos, self.y_pos, next_z)\n\n    def next_bw_x_point(self, offset=0.0):\n        """"""Return next backward x axis Point.""""""\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = linalg.inv(self.fw_coll_matrix(offset))\n\n        result = trans_matrix * pos_vec\n\n        pos_list = result.tolist()\n\n        next_x = pos_list[0][0]\n\n        return data.Point(next_x, self.y_pos, self.z_pos)\n\n    def next_bw_z_point(self, offset=0.0):\n        """"""Return next backward z axis Point.""""""\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = linalg.inv(self.fw_coll_matrix(offset))\n\n        result = trans_matrix * pos_vec\n\n        pos_list = result.tolist()\n\n        next_z = pos_list[2][0]\n\n        return data.Point(self.x_pos, self.y_pos, next_z)\n\n    def next_left_x_point(self, offset=0.0):\n        """"""Return next left x axis Point.""""""\n\n        rot_m = self.rot_y_matrix(- pi / 2)\n        new_vec = rot_m * self.horizontal_view_vec()\n        new_vec = self.scale_matrix(self.side_step + offset) * new_vec\n\n        result = self.get_position_matrix() * new_vec\n\n        pos_list = result.tolist()\n        next_x = pos_list[0][0]\n\n        return data.Point(next_x, self.y_pos, self.z_pos)\n\n    def next_left_z_point(self, offset=0.0):\n        """"""Return next left z axis Point.""""""\n\n        rot_m = self.rot_y_matrix(- pi / 2)\n        new_vec = rot_m * self.horizontal_view_vec()\n        new_vec = self.scale_matrix(self.side_step + offset) * new_vec\n\n        result = self.get_position_matrix() * new_vec\n\n        pos_list = result.tolist()\n        next_z = pos_list[2][0]\n\n        return data.Point(self.x_pos, self.y_pos, next_z)\n\n    def next_right_x_point(self, offset=0.0):\n        """"""Return next right x axis Point.""""""\n\n        rot_m = self.rot_y_matrix(pi / 2)\n        new_vec = rot_m * self.horizontal_view_vec()\n        new_vec = self.scale_matrix(self.side_step + offset) * new_vec\n\n        result = self.get_position_matrix() * new_vec\n\n        pos_list = result.tolist()\n        next_x = pos_list[0][0]\n\n        return data.Point(next_x, self.y_pos, self.z_pos)\n\n    def next_right_z_point(self, offset=0.0):\n        """"""Return next right z axis Point.""""""\n\n        rot_m = self.rot_y_matrix(pi / 2)\n        new_vec = rot_m * self.horizontal_view_vec()\n        new_vec = self.scale_matrix(self.side_step + offset) * new_vec\n\n        result = self.get_position_matrix() * new_vec\n\n        pos_list = result.tolist()\n        next_z = pos_list[2][0]\n\n        return data.Point(self.x_pos, self.y_pos, next_z)\n\n    def jump(self):\n        """"""Simulate camera jumping.""""""\n\n        if self.jump_counter == 0:\n\n            self.jump_counter = 1\n            self.y_pos += self.jump_step_height\n\n    def fall(self):\n        """"""Simulate camera falling.""""""\n\n        # now = time.time()\n\n        if not self.falling:\n\n            # self.falling_start = now\n            self.falling = True\n            self.falling_counter = 0\n\n        else:\n\n            pass\n\n        if 0 < self.jump_counter < self.jump_steps:\n\n            self.y_pos += self.jump_step_height\n            self.jump_counter += 1\n\n        # falling_step = self.falling_mp * 5 * pow(now - self.falling_start, 2)\n        falling_step = self.falling_mp * 5 * pow(self.falling_counter, 2)\n\n        # print(falling_step)\n        if falling_step > self.falling_max_speed:\n\n            falling_step = self.falling_max_speed\n\n        self.y_pos -= falling_step\n        self.falling_counter += 1\n\n    def stop_falling(self):\n        """"""Stop camera falling.""""""\n\n        self.falling = False\n\n    def h_angle_deg(self):\n        """"""Return camera horizontal angle in degrees.""""""\n\n        return (self.h_angle * 180) / pi\n\n    def v_angle_deg(self):\n        """"""Return camera vertical angle in degrees.""""""\n\n        return (self.v_angle * 180) / pi\n\n    def add_h_angle(self, delta):\n        """"""Add delta value to horizontal angle.\n\n        Args:\n            delta (float): delta value\n        """"""\n\n        self.h_angle += self.h_multiplier * delta\n\n    def add_v_angle(self, delta):\n        """"""Add delta value to vertical angle.\n\n        Args:\n            delta (float): delta value\n        """"""\n\n        if self.inverse_horizontal:\n\n            self.v_angle += self.v_multiplier * delta\n\n        else:\n\n            self.v_angle -= self.v_multiplier * delta\n\n        if self.v_angle < self.v_angle_min:\n\n            self.v_angle = self.v_angle_min\n\n        elif self.v_angle > self.v_angle_max:\n\n            self.v_angle = self.v_angle_max\n\n    def get_position_vec(self):\n        """"""Return position vector.\n\n        Return:\n            matrix: position vector\n        """"""\n\n        pos_vec = matrix([\n            [self.x_pos],\n            [self.y_pos],\n            [self.z_pos],\n            [1.0]\n        ])\n\n        return pos_vec\n\n    def get_position_matrix(self):\n        """"""Return position matrix.\n\n        Return:\n            matrix: translation position matrix\n        """"""\n\n        pos_matrix = matrix([\n            [1.0, 0, 0, self.x_pos],\n            [0, 1.0, 0, self.y_pos],\n            [0, 0, 1.0, self.z_pos],\n            [0, 0, 0, 1.0]\n        ])\n\n        return pos_matrix\n\n    def set_position_vec(self, position):\n\n        pos_list = position.tolist()\n\n        self.x_pos = pos_list[0][0]\n        self.y_pos = pos_list[1][0]\n        self.z_pos = pos_list[2][0]\n\n    def set_position(self, point):\n        """"""Set new camera position.\n\n        Args:\n            point (Point): new camera position\n        """"""\n\n        self.x_pos = point.x\n        self.y_pos = point.y\n        self.z_pos = point.z\n\n    def fw_matrix(self, sprint=False):\n\n        if sprint:\n            # use sprint multiplier\n            trans_matrix = matrix([\n                [1.0, 0, 0, (self.step * self.sprint_mp) * sin(self.h_angle)],\n                [0, 1.0, 0, 0],\n                [0, 0, 1.0, (self.step * self.sprint_mp) * cos(self.h_angle)],\n                [0, 0, 0, 1.0]\n            ])\n\n        else:\n\n            trans_matrix = matrix([\n                [1.0, 0, 0, self.step * sin(self.h_angle)],\n                [0, 1.0, 0, 0],\n                [0, 0, 1.0, self.step * cos(self.h_angle)],\n                [0, 0, 0, 1.0]\n            ])\n\n        return trans_matrix\n\n    def fw_coll_matrix(self, offset=0.0):\n\n        trans_matrix = matrix([\n            [1.0, 0, 0, (self.step + offset) * sin(self.h_angle)],\n            [0, 1.0, 0, 0],\n            [0, 0, 1.0, (self.step + offset) * cos(self.h_angle)],\n            [0, 0, 0, 1.0]\n        ])\n\n        return trans_matrix\n\n    def right_matrix(self):\n\n        trans_matrix = matrix([\n            [1.0, 0, 0, self.step * sin(self.h_angle + pi / 2)],\n            [0, 1.0, 0, 0],\n            [0, 0, 1.0, self.step * cos(self.h_angle + pi / 2)],\n            [0, 0, 0, 1.0]\n        ])\n\n        return trans_matrix\n\n    @staticmethod\n    def rot_y_matrix(angle):\n\n        trans_matrix = matrix([\n            [cos(angle), 0, sin(angle), 0],\n            [0, 1, 0, 0],\n            [- sin(angle), 0, cos(angle), 0],\n            [0, 0, 0, 1]\n        ])\n\n        return trans_matrix\n\n    @staticmethod\n    def scale_matrix(ratio):\n\n        trans_matrix = matrix([\n            [ratio, 0, 0, 0],\n            [0, ratio, 0, 0],\n            [0, 0, ratio, 0],\n            [0, 0, 0, 1]\n        ])\n\n        return trans_matrix\n\n    def view_vec(self):\n        """"""Return view vector.""""""\n\n        # TODO: implementation\n        raise NotImplementedError\n\n    def horizontal_view_vec(self):\n        """"""Return horizontal view vector.\n\n        Return:\n            matrix: view vector\n        """"""\n\n        vec = matrix([\n            [sin(self.h_angle)],\n            [0],\n            [cos(self.h_angle)],\n            [1]\n        ])\n\n        return vec\n\n    def forward(self, sprint=False):\n        """"""Move camera forward.""""""\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = self.fw_matrix(sprint)\n\n        result = trans_matrix * pos_vec\n        self.set_position_vec(result)\n\n    def forward_x(self):\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = self.fw_matrix()\n\n        result = trans_matrix * pos_vec\n\n        pos_list = result.tolist()\n\n        x_pos = pos_list[0][0]\n\n        self.set_position(data.Point(x_pos, self.y_pos, self.z_pos))\n\n    def forward_z(self):\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = self.fw_matrix()\n\n        result = trans_matrix * pos_vec\n\n        pos_list = result.tolist()\n\n        z_pos = pos_list[2][0]\n\n        self.set_position(data.Point(self.x_pos, self.y_pos, z_pos))\n\n    def sprint(self):\n\n        self.forward(sprint=True)\n\n    def backward(self):\n        """"""Move camera backward.""""""\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = linalg.inv(self.fw_matrix())\n\n        result = trans_matrix * pos_vec\n        self.set_position_vec(result)\n\n    def backward_x(self):\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = linalg.inv(self.fw_matrix())\n\n        result = trans_matrix * pos_vec\n\n        pos_list = result.tolist()\n\n        x_pos = pos_list[0][0]\n\n        self.set_position(data.Point(x_pos, self.y_pos, self.z_pos))\n\n    def backward_z(self):\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = linalg.inv(self.fw_matrix())\n\n        result = trans_matrix * pos_vec\n\n        pos_list = result.tolist()\n\n        z_pos = pos_list[2][0]\n\n        self.set_position(data.Point(self.x_pos, self.y_pos, z_pos))\n\n    def left(self):\n        """"""Move camera left.""""""\n\n        # pos_vec = self.get_position_vec()\n        # trans_matrix = linalg.inv(self.right_matrix())\n        #\n        # result = trans_matrix * pos_vec\n        # self.set_position_vec(result)\n\n        rot_m = self.rot_y_matrix(- pi / 2)\n        new_vec = rot_m * self.horizontal_view_vec()\n        new_vec = self.scale_matrix(self.side_step) * new_vec\n\n        result = self.get_position_matrix() * new_vec\n        self.set_position_vec(result)\n\n    def left_x(self):\n\n        rot_m = self.rot_y_matrix(- pi / 2)\n        new_vec = rot_m * self.horizontal_view_vec()\n        new_vec = self.scale_matrix(self.side_step) * new_vec\n\n        result = self.get_position_matrix() * new_vec\n\n        pos_list = result.tolist()\n        x_pos = pos_list[0][0]\n\n        self.set_position(data.Point(x_pos, self.y_pos, self.z_pos))\n\n    def left_z(self):\n\n        rot_m = self.rot_y_matrix(- pi / 2)\n        new_vec = rot_m * self.horizontal_view_vec()\n        new_vec = self.scale_matrix(self.side_step) * new_vec\n\n        result = self.get_position_matrix() * new_vec\n\n        pos_list = result.tolist()\n        z_pos = pos_list[2][0]\n\n        self.set_position(data.Point(self.x_pos, self.y_pos, z_pos))\n\n    def right(self):\n        """"""Move camera right.""""""\n\n        pos_vec = self.get_position_vec()\n        trans_matrix = self.right_matrix()\n\n        result = trans_matrix * pos_vec\n        self.set_position_vec(result)\n\n    def right_x(self):\n        """"""Move camera right in x axis.""""""\n\n        rot_m = self.rot_y_matrix(pi / 2)\n        new_vec = rot_m * self.horizontal_view_vec()\n        new_vec = self.scale_matrix(self.side_step) * new_vec\n\n        result = self.get_position_matrix() * new_vec\n\n        pos_list = result.tolist()\n        x_pos = pos_list[0][0]\n\n        self.set_position(data.Point(x_pos, self.y_pos, self.z_pos))\n\n    def right_z(self):\n        """"""Move camera right in z axis.""""""\n\n        rot_m = self.rot_y_matrix(pi / 2)\n        new_vec = rot_m * self.horizontal_view_vec()\n        new_vec = self.scale_matrix(self.side_step) * new_vec\n\n        result = self.get_position_matrix() * new_vec\n\n        pos_list = result.tolist()\n        z_pos = pos_list[2][0]\n\n        self.set_position(data.Point(self.x_pos, self.y_pos, z_pos))\n\n    def up(self):\n        """"""Move camera up.""""""\n\n        self.y_pos += self.fly_step\n\n    def down(self):\n        """"""Move camera down.""""""\n\n        self.y_pos -= self.fly_step\n\n    def collision_helper(self):\n        """"""Help camera with in-block collisions.""""""\n\n        self.y_pos += self.helper_step\n\n    def set_gravity(self, gravity):\n        """"""Set camera gravitation.\n\n        Args:\n            gravity (bool): enable gravity\n        """"""\n\n        self.gravity = gravity\n'"
configuration.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""Module for configuration tools.""""""\n\nfrom __future__ import print_function\n\nimport os\nimport ConfigParser\n\nimport interfaces\n\n\nclass EngineConfiguration(interfaces.Configuration):\n\n    def __init__(self, filename, user_filename):\n\n        self.filename = filename\n        self.user_filename = user_filename\n\n        # default values (when no config file is found)\n        self.values = self.get_default_values()\n\n        self.load_controls(self.filename)\n\n        if os.path.isfile(self.user_filename):\n\n            self.load_controls(self.user_filename)\n\n    @staticmethod\n    def get_default_values():\n        """"""Return default values.\n\n        Return:\n            dict: {""key"": ""value""}\n        """"""\n\n        default_values = {\n\n            ""visibility"": ""22"",\n        }\n\n        return default_values\n\n    def get_values(self):\n\n        return self.values\n\n    def load_controls(self, ini_file):\n        """"""Load configuration from file.\n\n        Args:\n            ini_file (str): ini file with controls\n        """"""\n\n        config = ConfigParser.ConfigParser()\n\n        try:\n\n            config.read(ini_file)\n\n        except ConfigParser.ParsingError as err:\n\n            print(""Bad configuration file: {}"".format(ini_file))\n            print(err)\n\n            return\n\n        section = ""Main""\n        self.set_value(config, section, ""visibility"")\n\n    def set_value(self, config, section, action):\n        """"""Load configuration value and assign it.\n\n        Args:\n            config (ConfigParser): configuration parser\n            section (str): section\n            action (str): action\n        """"""\n\n        new_value = self.config_value(config, section, action)\n\n        if new_value:\n\n            self.values[action] = new_value\n\n    @staticmethod\n    def config_value(config, section, action):\n        """"""Read configuration value.\n\n        Args:\n            config (ConfigParser: configuration parser\n            section (str): section\n            action (str): action\n\n        Return:\n            str or None: found value in configuration file\n        """"""\n\n        if config.has_section(section) and config.has_option(section, action):\n\n            return config.get(section, action)\n\n\nif __name__ == ""__main__"":\n\n    conf = EngineConfiguration(""settings.ini"", ""user.ini"")\n    print(conf.get_values())\n'"
controls.py,0,"b'#! /usr/bin/env python\n\n""""""Module for controls infrastructure.""""""\n\nfrom __future__ import print_function\n\nimport ConfigParser\nimport os.path\n\nfrom pyglet.window import key\n\nfrom configuration import EngineConfiguration\n\n\nclass ControlsMapper(object):\n    """"""Mapper class for controls.\n\n    Args:\n        filename (str): file with control schema\n\n    Attributes:\n        filename (str): file with control schema\n        user_filename (str): user file with control schema (override filename)\n        controls (dict): mapping action to keys\n        pyglet_mapping (dict): pyglet keys mapping\n    """"""\n\n    def __init__(self, filename, user_filename):\n\n        self.filename = filename\n        self.user_filename = user_filename\n\n        # default controls (when no config file is found)\n        self.controls = self.get_default_controls()\n\n        self.load_controls(self.filename)\n\n        if os.path.isfile(self.user_filename):\n\n            self.load_controls(self.user_filename)\n\n        self.pyglet_mapping = self.get_pyglet_mapping()\n\n    @staticmethod\n    def get_default_controls():\n        """"""Return default controls mapping as a dict.\n\n        Return:\n            dict: {""action"": ""key name""}\n        """"""\n\n        default_controls = {\n\n            ""forward"": ""W"",\n            ""backward"": ""S"",\n            ""left"": ""A"",\n            ""right"": ""D"",\n            ""jump"": ""Space"",\n        }\n\n        return default_controls\n\n    def load_controls(self, ini_file):\n        """"""Load controls from file.\n\n        Args:\n            ini_file (str): ini file with controls\n        """"""\n\n        config = ConfigParser.ConfigParser()\n\n        try:\n\n            config.read(ini_file)\n\n        except ConfigParser.ParsingError as err:\n\n            print(""Bad controls config file: {}"".format(ini_file))\n            print(err)\n\n            return\n\n        section = ""Controls""\n\n        self.set_value(config, section, ""forward"")\n        self.set_value(config, section, ""backward"")\n        self.set_value(config, section, ""left"")\n        self.set_value(config, section, ""right"")\n        self.set_value(config, section, ""jump"")\n\n    def set_value(self, config, section, action):\n        """"""Load configuration value and assign it.\n\n        Args:\n            config (ConfigParser): configuration parser\n            section (str): section\n            action (str): action\n        """"""\n\n        new_value = EngineConfiguration.config_value(config, section, action)\n\n        if new_value:\n\n            self.controls[action] = new_value\n\n    def get_pyglet_action(self, pyglet_key):\n        """"""Return mapped action to the pyglet key.""""""\n\n        pass\n\n    def get_pyglet_key(self, action):\n        """"""Return Pyglet key for action.\n\n        Args:\n            action (str): action\n\n        Return:\n            int: key constant\n        """"""\n\n        return self.pyglet_mapping[self.controls[action].upper()]\n\n    @staticmethod\n    def get_pyglet_mapping():\n        """"""Return Pyglet mapping.""""""\n\n        pyglet_mapping = {\n\n            ""A"": key.A,\n            ""B"": key.B,\n            ""C"": key.C,\n            ""D"": key.D,\n            ""E"": key.E,\n            ""F"": key.F,\n            ""G"": key.G,\n            ""H"": key.H,\n            ""I"": key.I,\n            ""J"": key.J,\n            ""K"": key.K,\n            ""L"": key.L,\n            ""M"": key.M,\n            ""O"": key.O,\n            ""P"": key.P,\n            ""Q"": key.Q,\n            ""R"": key.R,\n            ""S"": key.S,\n            ""T"": key.T,\n            ""U"": key.U,\n            ""V"": key.V,\n            ""W"": key.W,\n            ""X"": key.X,\n            ""Y"": key.Y,\n            ""Z"": key.Z,\n\n            ""UP"": key.UP,\n            ""DOWN"": key.DOWN,\n            ""LEFT"": key.LEFT,\n            ""RIGHT"": key.RIGHT,\n            ""SPACE"": key.SPACE,\n        }\n\n        return pyglet_mapping\n\n\nclass Controller(object):\n    """"""Class for objects controlling.\n\n    Args:\n        controllable (interfaces.Controllable): object for controlling\n        controls_file (str): configuration file\n\n    Attributes:\n        controllable_obj (interfaces.Controllable): object for controlling\n        mapper (ControlsMapper): mapper\n        actions (dict): map actions names to methods\n    """"""\n\n    def __init__(self, controllable, controls_file, user_file=""user.ini""):\n\n        self.controllable_obj = controllable\n\n        self.mapper = ControlsMapper(controls_file, user_file)\n\n        self.actions = {\n\n            ""fall"": self.controllable_obj.fall,\n            ""forward"": self.controllable_obj.forward,\n            ""backward"": self.controllable_obj.backward,\n            ""left"": self.controllable_obj.left,\n            ""right"": self.controllable_obj.right,\n            ""jump"": self.controllable_obj.jump,\n        }\n\n    def update(self, key_state):\n        """"""Call actions according to key states.\n\n        Args:\n            key_state (dict): keys states\n        """"""\n\n        # gravity\n        self.actions[""fall""]()\n\n        action = ""forward""\n        if key_state[self.get_pyglet_key(action)]:\n\n            self.actions[action]()\n\n        action = ""backward""\n        if key_state[self.get_pyglet_key(action)]:\n\n            self.actions[action]()\n\n        action = ""left""\n        if key_state[self.get_pyglet_key(action)]:\n\n            self.actions[action]()\n\n        action = ""right""\n        if key_state[self.get_pyglet_key(action)]:\n\n            self.actions[action]()\n\n        action = ""jump""\n        if key_state[self.get_pyglet_key(action)]:\n\n            self.actions[action]()\n\n    def get_pyglet_key(self, action):\n        """"""Return Pyglet key for the action.\n\n        Args:\n            action (str): the action\n\n        Return:\n            int: key constant\n        """"""\n\n        return self.mapper.get_pyglet_key(action)\n\n\nif __name__ == ""__main__"":\n\n    cm = ControlsMapper(""settings.ini"", ""user.ini"")\n    print(cm.controls)\n'"
core.py,0,"b'""""""Core graphics module.""""""\n\nfrom __future__ import print_function\n\nfrom OpenGL.GL import GLfloat\nfrom OpenGL.GL import glBindBuffer\nfrom OpenGL.GL import glBufferData\nfrom OpenGL.GL import glEnableVertexAttribArray\nfrom OpenGL.GL import glDisableVertexAttribArray\nfrom OpenGL.GL import glVertexAttribPointer\nfrom OpenGL.GL import glDrawArrays\nfrom OpenGL.GL import glPolygonMode\nfrom OpenGL.GL import glEnable\nfrom OpenGL.GL import glDisable\n\nfrom OpenGL.GL import GL_ARRAY_BUFFER\nfrom OpenGL.GL import GL_STATIC_DRAW\nfrom OpenGL.GL import GL_FLOAT\nfrom OpenGL.GL import GL_FALSE\nfrom OpenGL.GL import GL_TRIANGLES\nfrom OpenGL.GL import GL_CULL_FACE\nfrom OpenGL.GL import GL_FRONT_AND_BACK\nfrom OpenGL.GL import GL_LINE\nfrom OpenGL.GL import GL_FILL\nfrom OpenGL.GL import GL_POINTS\n\nfrom multiprocessing import Lock\nfrom multiprocessing.sharedctypes import Array\nfrom multiprocessing.sharedctypes import copy\nfrom ctypes import c_float\n\nimport collections\nimport multiprocessing as mp\nimport time\nimport logging\nimport os\n# import pprint\nimport random\n\nimport graphics\n\n# from decorators import print_time\n# from decorators import print_pid\n\n\nlog = logging.getLogger(__name__)\n\n# mpl = mp.log_to_stderr(5)\n\n# multiprocessing infrastructure\n####################################\n\nlock = Lock()\nsize = 250000\nshared_array = Array(c_float, size, lock=lock)\n\n\ndef long_func(chunk_data):\n\n    print(""{}, PID: {} ({})"".format(\n        ""long_func"", os.getpid(), os.getppid()))\n    time.sleep(random.randint(1, 9))\n\n    positions = generate_vbo_blocks(chunk_data)\n\n    return chunk_data, positions\n\n\ndef gl_vertexes_mp(chunk_id, chunk_vertexes):\n    """"""MP wrapper.""""""\n\n    shared_array.get_lock().acquire()\n\n    raw_array = shared_array.get_obj()\n\n    index = 0\n    for value in chunk_vertexes:\n\n        raw_array[index] = value\n\n        index += 1\n\n    return chunk_id\n\n\ndef generate_gl_vertexes(chunk_vertexes):\n    """"""Generate vertex data.\n\n    Args:\n        chunk_vertexes (list): vertexes of chunk\n    """"""\n\n    gl_vertexes = (GLfloat * len(chunk_vertexes))(*chunk_vertexes)\n\n    return gl_vertexes\n\n\ndef vertexes_mp(chunk_id, positions):\n    """"""MP wrapper.""""""\n\n    vertexes = generate_vertexes(positions)\n\n    return chunk_id, vertexes\n\n\ndef generate_vertexes(positions):\n\n    vertexes = []\n    for position in positions:\n\n        vertexes.extend(graphics.GraphicBlock.get_vertexes(position))\n\n    return vertexes\n\n\ndef positions_mp(chunk_data):\n    """"""MP wrapper.""""""\n\n    positions = generate_vbo_blocks(chunk_data)\n\n    return chunk_data, positions\n\n\ndef generate_vbo_blocks(chunk_data):\n    """"""Generate blocks data.\n\n    Args:\n        chunk_data (Chunk): chunk data\n    """"""\n\n    blocks_positions = []\n    for rel_pos, block in chunk_data.blocks.items():\n\n        block_position = (\n            chunk_data.position.x + rel_pos[0],\n            rel_pos[1],\n            chunk_data.position.z + rel_pos[2]\n        )\n\n        if block is not None:\n\n            blocks_positions.append(block_position)\n\n    return blocks_positions\n\n# multiprocessing end\n######################################\n\n\ndef generate_vbo(chunk_data):\n    """"""Generate VBO object.\n\n    Args:\n        chunk_data (Chunk): chunk data\n\n    Return:\n        VboData: VBO data object\n    """"""\n\n    positions = generate_vbo_blocks(chunk_data)\n\n    chunk_vertexes = generate_vertexes(positions)\n\n    gl_vertexes = generate_gl_vertexes(chunk_vertexes)\n\n    chunk_vbo = graphics.VboData(chunk_data.chunk_id)\n    chunk_vbo.vertexes_count = len(gl_vertexes)\n\n    glBindBuffer(GL_ARRAY_BUFFER, chunk_vbo.name)\n    glBufferData(\n        GL_ARRAY_BUFFER,\n        len(gl_vertexes) * 4,\n        gl_vertexes,\n        GL_STATIC_DRAW)\n    glBindBuffer(GL_ARRAY_BUFFER, 0)\n\n    return chunk_vbo\n\n\nclass VboCreator(object):\n    """"""Create VBO data object.""""""\n\n    def __init__(self, vbo_list, workers=2):\n\n        self.orig_list = vbo_list\n\n        self.active_tasks = []\n        self.active_subtasks = {}\n\n        self.prepared_vbos = {}\n\n        self.ready_vbos = collections.deque()\n\n        self.vbo_parts = {\n            # ""vbo_id"": {\n            #     ""parts1"": (1, 2,),\n            #     ""parts2"": (""a"", ""b"", ""d""),\n            #     ""parts3"": None,\n            # },\n        }\n\n        self.pool = mp.Pool(workers)\n\n    def add_task(self, chunk_id):\n\n        log.debug(""New VboCreator task: {}"".format(chunk_id))\n\n        self.active_tasks.append(chunk_id)\n\n    def task_exists(self, chunk_id):\n\n        if chunk_id in self.active_tasks:\n\n            return True\n\n        else:\n\n            return False\n\n    def create_subtasks(self, vbo_id):\n\n        self.active_subtasks[vbo_id] = {\n            ""positions"": None,\n            ""vertexes"": None,\n            ""gl_vertexes"": None,\n        }\n\n    def set_subtask_state(self, vbo_id, subtask, state):\n\n        self.active_subtasks[vbo_id][subtask] = state\n\n    def create_parts(self, vbo_id):\n\n        self.vbo_parts[vbo_id] = {\n            ""positions"": None,\n            ""vertexes"": None,\n            ""gl_vertexes"": None,\n        }\n\n    def delete_parts(self, vbo_id):\n\n        del self.vbo_parts[vbo_id]\n\n    def add_parts(self, vbo_id, section, data):\n\n        self.vbo_parts[vbo_id][section] = data\n\n    def add_ready_vbo(self, uid):\n\n        self.ready_vbos.append(uid)\n\n    def check_parts(self):\n\n        # TODO: refactoring\n\n        log.debug(""Active VboCreator tasks: {}"".format(len(self.active_tasks)))\n\n        for vbo_id, value in self.vbo_parts.items():\n\n            all_parts = []\n            for part_name, data in value.items():\n\n                if data:\n\n                    if (part_name == ""positions""\n                            and not self.active_subtasks[vbo_id][""vertexes""]):\n\n                        positions = data\n                        self.pool.apply_async(\n                            vertexes_mp,\n                            args=(vbo_id, positions),\n                            callback=self.vertexes_done\n                        )\n                        self.set_subtask_state(vbo_id, ""vertexes"", ""running"")\n\n                        all_parts.append(False)\n\n                    elif (part_name == ""vertexes""\n                            and not self.active_subtasks[vbo_id][""gl_vertexes""]):  # NOQA\n\n                        vertexes = data\n                        self.pool.apply_async(\n                            gl_vertexes_mp,\n                            args=(vbo_id, vertexes),\n                            callback=self.gl_vertexes_done\n                        )\n                        self.set_subtask_state(vbo_id, ""gl_vertexes"", ""running"")  # NOQA\n\n                        all_parts.append(False)\n\n                    else:\n\n                        all_parts.append(True)\n\n                else:\n\n                    all_parts.append(False)\n\n            # print(all_parts)\n            if all(all_parts):\n\n                if vbo_id not in self.ready_vbos:\n\n                    self.add_ready_vbo(vbo_id)\n\n    def create(self, chunk_data):\n\n        chunk_id = chunk_data.chunk_id\n        if self.task_exists(chunk_id):\n\n            return\n\n        self.add_task(chunk_id)\n        self.create_subtasks(chunk_id)\n        self.create_parts(chunk_id)\n\n        self.pool.apply_async(\n            positions_mp,\n            args=(chunk_data,),\n            callback=self.positions_done\n        )\n        self.set_subtask_state(chunk_id, ""positions"", ""running"")\n\n    def build_ready_vbos(self):\n\n        if len(self.ready_vbos) > 0:\n\n            new_vbo = self.ready_vbos.popleft()\n\n            self.build_vbo(\n                new_vbo,\n                self.vbo_parts[new_vbo][""vertexes""],\n                self.vbo_parts[new_vbo][""gl_vertexes""],\n            )\n\n            self.delete_parts(new_vbo)\n\n            log.debug(""VboCreator task {} done."".format(new_vbo))\n\n    def build_vbo(self, uid, vertexes, gl_vertexes):\n\n        chunk_vertexes = vertexes\n        gl_vertexes = gl_vertexes\n\n        vertexes_count = len(chunk_vertexes)\n\n        chunk_vbo = graphics.VboData(uid)\n        chunk_vbo.vertexes_count = vertexes_count\n\n        glBindBuffer(GL_ARRAY_BUFFER, chunk_vbo.name)\n        glBufferData(\n            GL_ARRAY_BUFFER,\n            vertexes_count * 4,\n            gl_vertexes,\n            GL_STATIC_DRAW)\n        glBindBuffer(GL_ARRAY_BUFFER, 0)\n\n        self.active_tasks.remove(uid)\n        self.orig_list.append(chunk_vbo)\n\n    def wait_for_procs(self):\n\n        self.pool.close()\n        self.pool.join()\n\n    def positions_done(self, arg):\n\n        log.debug(""positions done"")\n\n        chunk_data = arg[0]\n        positions = arg[1]\n\n        self.add_parts(chunk_data.chunk_id, ""positions"", positions)\n        self.set_subtask_state(chunk_data.chunk_id, ""positions"", ""done"")\n\n    def vertexes_done(self, arg):\n\n        log.debug(""vertexes done"")\n\n        uid = arg[0]\n        vertexes = arg[1]\n\n        self.add_parts(uid, ""vertexes"", vertexes)\n        self.set_subtask_state(uid, ""vertexes"", ""done"")\n\n    def gl_vertexes_done(self, arg):\n\n        log.debug(""gl_vertexes done"")\n\n        uid = arg\n        c_array = copy(shared_array.get_obj())\n\n        shared_array.get_lock().release()\n\n        self.add_parts(uid, ""gl_vertexes"", c_array)\n        self.set_subtask_state(uid, ""gl_vertexes"", ""done"")\n\n    def update(self):\n\n        self.check_parts()\n\n        self.build_ready_vbos()\n\n\nclass Renderer(object):\n    """"""Render world.""""""\n\n    def __init__(self, world, configuration=None):\n\n        log.debug(""Renderer initializing..."")\n\n        self.world = world\n        self.visibility = 22\n        self.chunk_gen_distance = self.visibility * 1.2\n\n        # VboData list for vertex buffer objects\n        self.vbos = []\n\n        self.vbo_creator = VboCreator(self.vbos, workers=2)\n\n        # external configuration\n        self.configuration = configuration.get_values()\n        self.update_configuration()\n\n        log.debug(""Renderer initialized."")\n\n    # def print_info(self, point):\n    #     """"""Development info method.""""""\n    #\n    #     # print(self.world.find_necessary_chunks(point, 10))\n    #     pass\n\n    def update_configuration(self):\n        """"""Update configuration of renderer.""""""\n\n        if not self.configuration:\n            return\n\n        self.visibility = int(self.configuration[""visibility""])\n\n    def ground_collision(self, point):\n        """"""Return ground collision value as boolean.\n\n        Args:\n            point (Point): Point for collision check.\n\n        Return:\n            boolean\n        """"""\n\n        return self.world.collision(point)\n\n    def prepare_new_chunks(self, position):\n        """"""Generate new chunks around the position.\n\n        Args:\n            position (Point): Centre.\n        """"""\n\n        self.world.generate_chunks(position, self.chunk_gen_distance)\n\n    def print_visibility(self):\n        """"""Print visibility for all chunks in world.""""""\n\n        for position, chunk in self.world.chunks.items():\n\n            print(position, chunk.visible)\n\n    def check_visibility(self, point):\n        """"""Check and set visibility for chunks.\n\n        Args:\n            point (Point): Centre.\n        """"""\n\n        self.world.set_visibility(point, self.visibility)\n\n    def set_visibility(self):\n        """"""Set visibility for VBOs according to world data.""""""\n\n        for position, chunk in self.world.chunks.items():\n\n            for vbo in self.vbos:\n\n                if vbo.chunk_id == chunk.chunk_id:\n\n                    vbo.render = chunk.visible\n\n    def data_update(self):\n\n        self.vbo_creator.update()\n        self.world.update_chunks()\n\n    def create_vbos(self):\n        """"""Create necessary VBOs.""""""\n\n        for position, chunk in self.world.chunks.items():\n\n            if self.vbo_exists(chunk.chunk_id):\n\n                pass\n\n            else:\n\n                self.vbo_creator.create(chunk)\n\n    def vbo_exists(self, chunk_id):\n        """"""Check VBO existence for the chunk ID.\n\n        Args:\n            chunk_id (str): Chunk ID.\n\n        Return:\n            boolean: True if VBO data exists.\n        """"""\n\n        for vbo in self.vbos:\n\n            if vbo.chunk_id == chunk_id:\n\n                return True\n\n        return False\n\n    def prepare_world(self):\n        """"""Fill buffer objects with data.""""""\n\n        block_counter = 0\n        for pos, chunk in self.world.chunks.items():\n\n            chunk_vbo = generate_vbo(chunk)\n\n            self.vbos.append(chunk_vbo)\n\n        print(""="" * 40)\n        print(""World info"")\n        print(""Chunks: {}"".format(len(self.vbos)))\n        print(""Blocks: {}"".format(\n            len(self.vbos) *\n            self.world.chunk_type.size *\n            self.world.chunk_type.size *\n            self.world.chunk_type.height))\n        print(""Rendered blocks: {}"".format(block_counter))\n        print(""+"" * 40)\n        print("""")\n\n    def render(self):\n        """"""Render game world.""""""\n\n        for vbo in self.vbos:\n\n            if vbo.render:\n\n                glBindBuffer(GL_ARRAY_BUFFER, vbo.name)\n                glEnableVertexAttribArray(0)\n                glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)\n\n                glDrawArrays(\n                    GL_TRIANGLES,\n                    0,\n                    vbo.vertexes_count)\n                glDisableVertexAttribArray(0)\n                glBindBuffer(GL_ARRAY_BUFFER, 0)\n\n    @staticmethod\n    def set_lines():\n        """"""Set OpenGL lines rendering.""""""\n\n        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)\n        glDisable(GL_CULL_FACE)\n\n    @staticmethod\n    def set_fill():\n        """"""Set OpenGL fill rendering.""""""\n\n        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)\n        glEnable(GL_CULL_FACE)\n\n    @staticmethod\n    def set_points():\n        """"""Set OpenGL points rendering.""""""\n\n        glPolygonMode(GL_FRONT_AND_BACK, GL_POINTS)\n'"
data.py,0,"b'# -*- coding: utf-8 -*-\n#\n\n""""""Module for data representation.""""""\n\nimport uuid\nimport collections\nimport logging\nimport multiprocessing as mp\n\nfrom math import sqrt\n\n# from decorators import print_time\nfrom functions import generate_chunk\nfrom functions import generate_chunk_mp\n\n\nlog = logging.getLogger(__name__)\n\n\nclass ChunkCreator(object):\n\n    def __init__(self, chunk_dict, workers=2):\n\n        self.orig_dict = chunk_dict\n\n        self.active_tasks = []\n        self.prepared_chunks = {}\n        self.ready_chunks = collections.deque()\n\n        self.pool = mp.Pool(workers)\n\n    def add_task(self, chunk_position):\n\n        log.debug(""New ChunkCreator task: {}"".format(chunk_position))\n\n        self.active_tasks.append(chunk_position)\n\n    def task_exists(self, position):\n\n        if position in self.active_tasks:\n\n            return True\n\n        else:\n\n            return False\n\n    def add_ready_chunk(self, position):\n\n        self.ready_chunks.append(position)\n\n    def add_blocks(self, chunk_type, position, blocks):\n\n        self.prepared_chunks[position] = chunk_type, blocks\n\n    def create(self, chunk_type, chunk_position):\n        """"""\n\n        Args:\n            chunk_position (int, int): X and Z coordinates\n        """"""\n\n        width = chunk_type.size\n        height = chunk_type.height\n\n        if self.task_exists(chunk_position):\n\n            return\n\n        self.add_task(chunk_position)\n\n        self.pool.apply_async(\n            generate_chunk_mp,\n            args=(chunk_type, chunk_position, width, height),\n            callback=self.chunk_done\n        )\n\n    def build_ready_chunks(self):\n\n        if len(self.ready_chunks) > 0:\n\n            chunk_position = self.ready_chunks.popleft()\n            chunk_type = self.prepared_chunks[chunk_position][0]\n            blocks = self.prepared_chunks[chunk_position][1]\n\n            self.build_chunk(chunk_type, chunk_position, blocks)\n\n            log.debug(""ChunkCreator task {} done."".format(chunk_position))\n\n    def build_chunk(self, chunk_type, chunk_position, blocks):\n\n        position_point = Point(chunk_position[0], 0, chunk_position[1])\n\n        new_chunk = chunk_type(position_point, blocks=blocks)\n\n        self.active_tasks.remove(chunk_position)\n        self.orig_dict[chunk_position] = new_chunk\n\n    def chunk_done(self, data):\n\n        chunk_type = data[0]\n        chunk_position = data[1]\n        chunk_blocks = data[2]\n\n        self.add_blocks(chunk_type, chunk_position, chunk_blocks)\n        self.add_ready_chunk(chunk_position)\n\n        log.debug(""chunk done"")\n\n    def update(self):\n\n        log.debug(""Active ChunkCreator tasks: {}"".format(\n            len(self.active_tasks)))\n\n        self.build_ready_chunks()\n\n    def wait_for_procs(self):\n\n        self.pool.close()\n        self.pool.join()\n\n\nclass Point(object):\n    """"""Store data for point in 3D space.\n\n    Args:\n        x (float): x position\n        y (float): y position\n        z (float): z position\n    """"""\n\n    def __init__(self, x, y, z):\n\n        self.x = 0\n        self.y = 0\n        self.z = 0\n\n        self.set_position(x, y, z)\n\n    def __str__(self):\n        """"""Return string representation.""""""\n\n        return ""Position: x={}, y={}, z={}"".format(self.x, self.y, self.z)\n\n    def __eq__(self, other):\n\n        if not isinstance(other, Point):\n\n            return False\n\n        if self.x == other.x and self.y == other.y and self.z == other.z:\n\n            return True\n\n    def __ne__(self, other):\n\n        return not self == other\n\n    def set_position(self, x, y, z):\n        """"""Set point position.""""""\n\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def chunk_distance(self, chunk_pos):\n        """"""Return distance of chunk from self instance.\n\n        Args:\n            chunk_pos (Point): position of chunk\n        """"""\n\n        x_dist = chunk_pos.x - self.x\n        z_dist = chunk_pos.z - self.z\n\n        distance = sqrt(pow(x_dist, 2) + pow(z_dist, 2))\n\n        return distance\n\n\nclass Block(object):\n    """"""Data representation for block.\n\n    Attributes:\n        structure: block structure\n        parents (list): block\'s parents\n        children (list): block\'s children\n    """"""\n\n    def __init__(self):\n\n        # real structure\n        self.structure = None\n\n        # lists of parents and children\n        self.parents = None\n        self.children = None\n\n    def __str__(self):\n        """"""Return string representation.""""""\n\n        return \'Block\'\n\n    def __repr__(self):\n\n        return self.__str__()\n\n\nclass BlockInfo(object):\n    """"""Auxiliary mapping class.\n\n    Args:\n        chunk (Chunk): chunk object\n        position ((x, y, z)): position of block\n\n    Attributes:\n        position ((x, y, z)): position of block\n        chunk_id (str): ID of chunk\n        chunk_position (Point): position of chunk\n    """"""\n\n    def __init__(self, chunk, position):\n\n        self.position = position\n        self.chunk_id = chunk.chunk_id\n        self.chunk_position = chunk.position\n\n\nclass Chunk(object):\n    """"""Base class for chunks.\n\n    Args:\n        position (Point): position of chunk\n\n    Attributes:\n        position (Position): position of chunk\n        centre (Point): centre point of chunk\n        chunk_id (str): ID of chunk\n        dirty (bool): indicates changes in chunk\n        visible (bool): stores visibility for chunk\n        blocks (dict): dictionary of Block objects, key is (x, y, z) of int\n    """"""\n\n    size = None\n    height = None\n\n    def __init__(self, position, blocks=None):\n\n        self.position = position\n        self.centre = Point(\n            position.x + self.size / 2,\n            0,\n            position.z + self.size / 2\n        )\n\n        self.chunk_id = str(uuid.uuid4())\n\n        self.dirty = False\n        self.visible = False\n\n        if blocks:\n\n            self.blocks = blocks\n\n        else:\n\n            self.blocks = self.generate_chunk()\n\n    def get_centre(self):\n        """"""Return centre of chunk as a Point object.""""""\n\n        return self.centre\n\n    def generate_chunk(self):\n        """"""Generate chunk data.\n\n        Return:\n            dict: {(x, y, z) of int: Block}\n        """"""\n\n        blocks = generate_chunk(self.size, self.height)\n\n        return blocks\n\n    def block_collision(self, point):\n        """"""Return collision block info.\n\n        Args:\n            point (Point): the collision point\n\n        Return:\n            BlockInfo or None: info about block\n        """"""\n\n        selected_blocks = []  # (x, y, z)\n        for x in range(int(point.x - 2 - self.position.x),\n                       int(point.x + 2 - self.position.x)):\n            for y in range(int(point.y - 2 - self.position.y),\n                           int(point.y + 2 - self.position.y)):\n                for z in range(int(point.z - 2 - self.position.z),\n                               int(point.z + 2 - self.position.z)):\n\n                    if x < 0 or x >= self.size:\n\n                        pass\n\n                    elif y < 0 or y >= self.height:\n\n                        pass\n\n                    elif z < 0 or z >= self.size:\n\n                        pass\n\n                    else:\n\n                        selected_blocks.append((x, y, z))\n\n        for block in selected_blocks:\n\n            if abs(block[0] + self.position.x - point.x) < 0.5:\n                if abs(block[1] + self.position.y - point.y) < 0.5:\n                    if abs(block[2] + self.position.z - point.z) < 0.5:\n\n                        if self.blocks[block] is not None:\n\n                            return BlockInfo(self, block)\n\n        return None\n\n    def collision(self, point):\n        """"""Return boolean value of collision for the point.\n\n        Args:\n            point (Point): check collision for this point\n        """"""\n\n        # debug info\n        # counter = 0\n\n        # list of (x, y, z) of int\n        selected_blocks = []\n        for x in range(int(point.x - 2 - self.position.x),\n                       int(point.x + 2 - self.position.x)):\n            for y in range(int(point.y - 2 - self.position.y),\n                           int(point.y + 2 - self.position.y)):\n                for z in range(int(point.z - 2 - self.position.z),\n                               int(point.z + 2 - self.position.z)):\n\n                    if x < 0 or x >= self.size:\n\n                        pass\n\n                    elif y < 0 or y >= self.height:\n\n                        pass\n\n                    elif z < 0 or z >= self.size:\n\n                        pass\n\n                    else:\n\n                        selected_blocks.append((x, y, z))\n\n        for block in selected_blocks:\n\n            if abs(block[0] + self.position.x - point.x) < 0.5:\n                if abs(block[1] + self.position.y - point.y) < 0.5:\n                    if abs(block[2] + self.position.z - point.z) < 0.5:\n\n                        if self.blocks[block] is not None:\n\n                            # print(""Collision: {}"".format(block))\n                            # print(counter)\n\n                            return True\n\n            # counter += 1\n\n        return False\n\n        # if self.block_collision(point) != None:\n        #\n        #     return True\n        #\n        # else:\n        #\n        #     return False\n\n    def __str__(self):\n        """"""String representation of chunk.""""""\n\n        return \'Chunk: \' + str(self.blocks)\n\n    def __repr__(self):\n\n        return self.__str__()\n\n\nclass SmallChunk(Chunk):\n    """"""Small chunk - 2 x 2 x 128 blocks.""""""\n\n    # size of chunk side\n    size = 2\n    # height of chunk\n    height = 128\n\n    def __str__(self):\n        """"""String representation of chunk.""""""\n\n        return \'SmallChunk: \' + str(self.blocks)\n\n\nclass NormalChunk(Chunk):\n    """"""Normal chunk - 8 x 8 x 128 blocks.""""""\n\n    # size of chunk side\n    size = 8\n    # height of chunk\n    height = 128\n\n    def __str__(self):\n        """"""String representation of chunk.""""""\n\n        return ""NormalChunk: {} blocks"".format(len(self.blocks))\n\n\nclass BlockWorld(object):\n    """"""World encapsulates blocks in chunks.""""""\n\n    def __init__(self, chunk_type, width, depth):\n\n        self.chunk_type = chunk_type\n        self.chunk_size = self.chunk_type.size\n        self.chunk_offset = 0.5\n\n        self.width = width\n        self.depth = depth\n\n        self.chunks = {}\n\n        self.chunk_creator = ChunkCreator(self.chunks)\n\n        self.generate_world()\n\n    def in_chunk(self, point):\n        """"""Return chunk key according the point.\n\n        Args:\n            point (Point): find chunk including this point\n        """"""\n\n        for position, chunk in self.chunks.items():\n\n            x_dist = point.x - position[0] + self.chunk_offset\n            z_dist = point.z - position[1] + self.chunk_offset\n            if (0 < x_dist < chunk.size) and (0 < z_dist < chunk.size):\n\n                return position\n\n    def collision(self, point):\n        """"""Return collision with a world as a boolean.\n\n        Args:\n            point (Point): check collision for the point\n\n        Return:\n            bool: point collision with the world\n        """"""\n\n        # temporary solution\n        # TODO: change\n        point.z = -point.z\n\n        offset = 0.5\n\n        # counter = 0\n        for chunk in self.chunks:\n\n            if (chunk[0] < point.x + offset and\n                    point.x - offset < chunk[0] + self.chunk_size):\n                if (chunk[1] < point.z + offset and\n                        point.z - offset < chunk[1] + self.chunk_size):\n\n                    if self.chunks[chunk].collision(point):\n\n                        # print(counter)\n                        return True\n\n            # counter += 1\n\n        return False\n\n    def __str__(self):\n        """"""String representation for world.""""""\n\n        return ""BlockWorld: {} chunks"".format(len(self.chunks))\n\n    def generate_chunk(self, position, async=True):\n        """"""Generate chunk.\n\n        Args:\n            position ((int, int)): position of chunk in a world\n        """"""\n\n        if not self.chunk_exists(position):\n\n            # print(""Creating new chunk: {}"".format(position))\n\n            # create chunk with creator\n\n            if async:\n\n                self.chunk_creator.create(self.chunk_type, position)\n\n            else:\n\n                self.chunks[position] = self.chunk_type(\n                    Point(position[0], 0, position[1]))\n\n    def update_chunks(self):\n\n        self.chunk_creator.update()\n\n    def chunk_exists(self, position):\n        """"""Return chunk existence on the position.\n\n        Args:\n            position ((int, int)): chunk position/key (x, z)\n        """"""\n\n        return position in self.chunks\n\n    def find_necessary_chunks(self, point, distance):\n        """"""Find necessary chunks in the distance.\n\n        Args:\n            point (Point): centre point\n            distance (int): distance\n\n        Return:\n            list: list of necessary chunks positions\n        """"""\n\n        offset = self.chunk_size / 2\n\n        min_x = int(point.x - distance) - offset\n        min_z = int(point.z - distance) - offset\n        max_x = int(point.x + distance) - offset\n        max_z = int(point.z + distance) - offset\n\n        positions = []\n        for x_pos in range(min_x, max_x):\n            for z_pos in range(min_z, max_z):\n\n                if (x_pos % self.chunk_size == 0 and\n                        z_pos % self.chunk_size == 0):\n\n                    if sqrt(pow((x_pos + offset) - point.x, 2)\n                            + pow((z_pos + offset) - point.z, 2)) > distance:\n\n                        pass\n\n                    else:\n\n                        positions.append((x_pos, z_pos))\n\n        return positions\n\n    def find_nearest_chunks(self, point):\n\n        return self.find_necessary_chunks(point, 7)\n\n    def block_collision(self, point, chunks):\n\n        for chunk in chunks:\n\n            print(self.chunks[chunk].block_collision(point))\n\n    def generate_chunks(self, point, distance):\n\n        necessary_chunks = self.find_necessary_chunks(point, distance)\n\n        for position in necessary_chunks:\n\n            self.generate_chunk(position)\n\n    def set_visibility(self, point, distance):\n        """"""Set chunks visibility.\n\n        Args:\n            point (Point): observer position\n            distance (int): max distance\n        """"""\n\n        for position, chunk in self.chunks.items():\n\n            if point.chunk_distance(chunk.get_centre()) > distance:\n\n                chunk.visible = False\n\n            else:\n\n                chunk.visible = True\n\n    def generate_world(self):\n        """"""Generate world from chunks.""""""\n\n        for x in range(0, self.width, self.chunk_size):\n            for z in range(0, self.depth, self.chunk_size):\n\n                # self.chunks[(x, z)] = self.chunk_type(Point(x, 0, z))\n                self.generate_chunk((x, z), async=False)\n'"
decorators.py,0,"b'""""""Module for decorators.""""""\n\nimport time\nimport os\n\n\ndef print_time(func):\n    """"""Print function call time.""""""\n\n    def wrapper(*args, **kwargs):\n\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n\n        print(""{}: {} s"".format(func.__name__, end - start))\n\n        return result\n\n    return wrapper\n\n\ndef print_pid(func):\n    """"""Print process ID.""""""\n\n    def wrapper(*args, **kwargs):\n\n        print(""{}, PID: {} ({})"".format(\n            func.__name__, os.getpid(), os.getppid()))\n\n        return func(*args, **kwargs)\n\n    return wrapper\n'"
functions.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""Module for functions.""""""\n\nfrom __future__ import print_function\n\nimport random\n\nimport data\n\n# from decorators import print_time\n\n\ndef generate_chunk_mp(chunk_type, position, width, height):\n\n    blocks = generate_chunk(width, height)\n\n    return chunk_type, position, blocks\n\n\n# @print_time\ndef generate_chunk(width, height):\n    """"""Generate chunk data.\n\n    Args:\n        width (int): width\n        height (int): height\n\n    Return:\n        dict: {(x, y, z) of int: Block}\n    """"""\n\n    blocks = {}\n\n    last = False\n    for x in range(width):\n        for y in range(height):\n            for z in range(width):\n\n                if y < 50:\n\n                    if last:\n                        if random.randint(0, 2) in (0, 1):\n\n                            blocks[(x, y, z)] = data.Block()\n                            last = True\n\n                        else:\n\n                            blocks[(x, y, z)] = None\n                            last = False\n\n                    else:\n\n                        if random.randint(0, 3) in (0,):\n\n                            blocks[(x, y, z)] = data.Block()\n                            last = True\n\n                        else:\n\n                            blocks[(x, y, z)] = None\n                            last = False\n\n                else:\n\n                    blocks[(x, y, z)] = None\n\n    return blocks\n'"
graphics.py,0,"b'""""""Module for graphic representation.""""""\n\nfrom __future__ import print_function\n\nimport pyglet\nimport sys\nimport logging\n\nfrom pyglet.window import key\n\n# PyOpenGL imports\nfrom OpenGL.GL import GL_ARRAY_BUFFER\nfrom OpenGL.GL import GL_COLOR_BUFFER_BIT\nfrom OpenGL.GL import GL_CULL_FACE\nfrom OpenGL.GL import GL_DEPTH_BUFFER_BIT\nfrom OpenGL.GL import GL_DEPTH_TEST\nfrom OpenGL.GL import GL_FALSE\nfrom OpenGL.GL import GL_FLOAT\nfrom OpenGL.GL import GL_MODELVIEW\nfrom OpenGL.GL import GL_PROJECTION\nfrom OpenGL.GL import GL_STATIC_DRAW\nfrom OpenGL.GL import GL_TRIANGLES\n\nfrom OpenGL.GL import GLfloat\nfrom OpenGL.GL import GLuint\n\nfrom OpenGL.GL import glBindBuffer\nfrom OpenGL.GL import glBufferData\nfrom OpenGL.GL import glClear\nfrom OpenGL.GL import glClearColor\nfrom OpenGL.GL import glDisable\nfrom OpenGL.GL import glDisableVertexAttribArray\nfrom OpenGL.GL import glDrawArrays\nfrom OpenGL.GL import glEnable\nfrom OpenGL.GL import glEnableVertexAttribArray\nfrom OpenGL.GL import glGenBuffers\nfrom OpenGL.GL import glIsEnabled\nfrom OpenGL.GL import glLoadIdentity\nfrom OpenGL.GL import glMatrixMode\nfrom OpenGL.GL import glOrtho\nfrom OpenGL.GL import glRotatef\nfrom OpenGL.GL import glTranslatef\nfrom OpenGL.GL import glUseProgram\nfrom OpenGL.GL import glVertexAttribPointer\nfrom OpenGL.GL import glViewport\n\nfrom OpenGL.GLU import gluPerspective\n\n# project imports\nimport camera\nimport controls\nimport player\nimport script\nimport shaders\n\nlog = logging.getLogger(__name__)\n\n\nclass TestObject(object):\n    """"""Test rendering object.""""""\n\n    def __init__(self):\n\n        self.vbo = GLuint()\n\n        self.vertexes = (\n            0, 0, 0,\n            1.0, 0, 0,\n            1.0, 1.0, 0,\n            0, 0, 0,\n            1.0, 1.0, 0,\n            0, 1.0, 0,\n        )\n\n        self.vertexes_GL = (GLfloat * len(\n            self.vertexes))(*self.vertexes)\n\n        glGenBuffers(1, self.vbo)\n        glBindBuffer(GL_ARRAY_BUFFER, self.vbo)\n        glBufferData(\n            GL_ARRAY_BUFFER,\n            len(self.vertexes_GL) * 4,\n            self.vertexes_GL,\n            GL_STATIC_DRAW)\n        glBindBuffer(GL_ARRAY_BUFFER, 0)\n\n    def draw(self):\n        """"""Draw test object.""""""\n\n        glBindBuffer(GL_ARRAY_BUFFER, self.vbo)\n        glEnableVertexAttribArray(0)\n        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)\n        glDrawArrays(GL_TRIANGLES, 0, 6)\n        glDisableVertexAttribArray(0)\n        glBindBuffer(GL_ARRAY_BUFFER, 0)\n\n\nclass GraphicBlock(object):\n    """"""Graphic data representation for block.""""""\n\n    def __init__(self):\n\n        pass\n\n    @staticmethod\n    def get_vertexes(position):\n        """"""Return vertex list from position.""""""\n\n        vertexes = []\n        x_pos = float(position[0])\n        y_pos = float(position[1])\n        z_pos = float(position[2])\n\n        points = 36 * [None]\n\n        # front\n        points[0] = (x_pos - 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[1] = (x_pos + 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[2] = (x_pos + 0.5, y_pos + 0.5, z_pos + 0.5)\n        points[3] = (x_pos - 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[4] = (x_pos + 0.5, y_pos + 0.5, z_pos + 0.5)\n        points[5] = (x_pos - 0.5, y_pos + 0.5, z_pos + 0.5)\n\n        # top\n        points[6] = (x_pos - 0.5, y_pos + 0.5, z_pos + 0.5)\n        points[7] = (x_pos + 0.5, y_pos + 0.5, z_pos + 0.5)\n        points[8] = (x_pos + 0.5, y_pos + 0.5, z_pos - 0.5)\n        points[9] = (x_pos - 0.5, y_pos + 0.5, z_pos + 0.5)\n        points[10] = (x_pos + 0.5, y_pos + 0.5, z_pos - 0.5)\n        points[11] = (x_pos - 0.5, y_pos + 0.5, z_pos - 0.5)\n\n        # right\n        points[12] = (x_pos + 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[13] = (x_pos + 0.5, y_pos - 0.5, z_pos - 0.5)\n        points[14] = (x_pos + 0.5, y_pos + 0.5, z_pos - 0.5)\n        points[15] = (x_pos + 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[16] = (x_pos + 0.5, y_pos + 0.5, z_pos - 0.5)\n        points[17] = (x_pos + 0.5, y_pos + 0.5, z_pos + 0.5)\n\n        # left\n        points[18] = (x_pos - 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[19] = (x_pos - 0.5, y_pos + 0.5, z_pos - 0.5)\n        points[20] = (x_pos - 0.5, y_pos - 0.5, z_pos - 0.5)\n        points[21] = (x_pos - 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[22] = (x_pos - 0.5, y_pos + 0.5, z_pos + 0.5)\n        points[23] = (x_pos - 0.5, y_pos + 0.5, z_pos - 0.5)\n\n        # back\n        points[24] = (x_pos - 0.5, y_pos - 0.5, z_pos - 0.5)\n        points[25] = (x_pos - 0.5, y_pos + 0.5, z_pos - 0.5)\n        points[26] = (x_pos + 0.5, y_pos + 0.5, z_pos - 0.5)\n        points[27] = (x_pos - 0.5, y_pos - 0.5, z_pos - 0.5)\n        points[28] = (x_pos + 0.5, y_pos + 0.5, z_pos - 0.5)\n        points[29] = (x_pos + 0.5, y_pos - 0.5, z_pos - 0.5)\n\n        # bottom\n        points[30] = (x_pos - 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[31] = (x_pos + 0.5, y_pos - 0.5, z_pos - 0.5)\n        points[32] = (x_pos + 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[33] = (x_pos - 0.5, y_pos - 0.5, z_pos + 0.5)\n        points[34] = (x_pos - 0.5, y_pos - 0.5, z_pos - 0.5)\n        points[35] = (x_pos + 0.5, y_pos - 0.5, z_pos - 0.5)\n\n        for point in points:\n\n            vertexes.extend(point)\n\n        return vertexes\n\n\nclass VboData(object):\n    """"""VBO data structure.""""""\n\n    def __init__(self, chunk_id):\n\n        self.name = GLuint()\n        glGenBuffers(1, self.name)\n\n        self.chunk_id = chunk_id\n        self.vertexes_count = 0\n\n        # render flag\n        self.render = False\n\n\nclass GameWindow(pyglet.window.Window):\n    """"""Show game window.""""""\n\n    def __init__(self, renderer):\n\n        super(GameWindow, self).__init__()\n        self.set_caption(\'GL prototype\')\n\n        self.renderer = renderer\n\n        self.set_exclusive_mouse(True)\n\n        # detect OpenGL capabilities\n        self.capabilities = None\n        self.detect_capabilities()\n\n        if self.capabilities == ""unsupported"":\n\n            print(""Unsupported OpenGL version."")\n            sys.exit()\n\n        # schedule tasks\n        pyglet.clock.schedule_interval(self.print_info, 5.0 / 1.0)\n        pyglet.clock.schedule_interval(self.data_update, 1.0)\n        pyglet.clock.schedule_interval(self.less_frequent_tasks, 1.0 / 2.0)\n        pyglet.clock.schedule_interval(self.update, 1.0 / 30.0)\n\n        self.keyboard = pyglet.window.key.KeyStateHandler()\n        self.push_handlers(self.keyboard)\n\n        # camera settings\n        self.camera = camera.FPSCamera(x_pos=10, y_pos=53, z_pos=-20)\n        self.camera.set_gravity(True)\n        self.camera_fall_collision = True\n\n        self.devel_keys_enabled = True\n\n        # script mode settings\n        self.scripter = script.Script(""script.txt"", self.camera)\n        if self.scripter:\n\n            # self.camera.set_gravity(False)\n            self.camera.set_gravity(True)\n\n        # player\'s body\n        self.player = player.PlayerBody(self.camera, self.renderer, 0.1, 1.9)\n\n        # controller for player\'s input\n        self.controller = controls.Controller(self.player, ""settings.ini"")\n\n        # self.collision_offset = 0.1\n\n        self.update_counter = 0\n\n        self.test_label = pyglet.text.Label(\n            \'TEST Label\',\n            font_size=36,\n            x=self.width / 2,\n            y=self.height,\n            anchor_x=\'center\',\n            anchor_y=\'top\'\n        )\n\n        # init shaders\n        shader_pool = shaders.ShaderPool(self.capabilities)\n        self.shader_programs = shader_pool.get_shaders()\n\n        # initial rendering - fill, lines, points\n        self.rendering_type = ""fill""\n\n        # variables for scheduling\n        self.long_tasks = 3\n        self.long_tasks_counter = 0\n\n        self.setup()\n\n    @staticmethod\n    def print_fps(dt):\n        """"""Print FPS.""""""\n\n        print(pyglet.clock.get_fps())\n\n    def print_info(self, dt):\n        """"""Print useful info.""""""\n\n        log.info(""FPS: {}"".format(pyglet.clock.get_fps()))\n        log.info(""Camera: {}"".format(self.camera.get_position()))\n\n    def print_gl_info(self):\n        """"""Print OpenGL info.""""""\n\n        print(""="" * 40)\n        print(""OpenGL info"")\n        print(""renderer: {}"".format(pyglet.gl.gl_info.get_renderer()))\n        print(""version: {}"".format(pyglet.gl.gl_info.get_version()))\n        print(""capabilities: {}"".format(self.capabilities))\n        # print(self.config)\n        print(""+"" * 40)\n        print("""")\n\n    def print_gl_settings(self):\n        """"""Print OpenGL settings.""""""\n\n        print(""="" * 40)\n        print(""OpenGL settings"")\n        print(""Depth test: {}"".format(glIsEnabled(GL_DEPTH_TEST)))\n        print(""Culling: {}"".format(glIsEnabled(GL_CULL_FACE)))\n        print(""+"" * 40)\n        print("""")\n\n    def detect_capabilities(self):\n        """"""Detect OpenGL capabilities.""""""\n\n        if pyglet.gl.gl_info.have_version(3, 3):\n\n            self.capabilities = ""normal""\n\n        elif pyglet.gl.gl_info.have_version(3, 1):\n\n            self.capabilities = ""old""\n\n        elif pyglet.gl.gl_info.have_version(2, 1):\n\n            self.capabilities = ""legacy""\n\n        else:\n\n            self.capabilities = ""unsupported""\n\n    def setup(self):\n        """"""Setup OpenGL.""""""\n\n        self.print_gl_info()\n\n        glClearColor(1.0, 1.0, 1.0, 0.0)\n\n        glEnable(GL_DEPTH_TEST)\n        glEnable(GL_CULL_FACE)\n\n        self.print_gl_settings()\n\n    def on_resize(self, width, height):\n        """"""Prepare perspective for window size.""""""\n\n        print(\'on resize\')\n\n        if height == 0:\n\n            height = 1\n\n        glViewport(0, 0, width, height)\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        gluPerspective(75, 1.0 * width / height, 0.001, 1000.0)\n\n    def show(self):\n        """"""Show window and start app.""""""\n\n        pyglet.app.run()\n\n    def set_2d(self):\n        """"""Set 2D render mode.""""""\n\n        glDisable(GL_DEPTH_TEST)\n\n        glViewport(0, 0, self.width, self.height)\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(0, self.width, 0, self.height, -1, 1)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n\n    def set_3d(self):\n        """"""Set 3D render mode.""""""\n\n        glEnable(GL_DEPTH_TEST)\n\n        glViewport(0, 0, self.width, self.height)\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        gluPerspective(75.0, 1.0 * self.width / self.height, 0.001, 1000.0)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n\n    def use_shader(self, shader_name):\n        """"""Use cached shader.\n\n        Args:\n            shader_name (str): shader name in cache dict\n        """"""\n\n        if shader_name in self.shader_programs:\n\n            glUseProgram(self.shader_programs[shader_name])\n\n        else:\n\n            glUseProgram(0)\n\n    def on_draw(self):\n        """"""Redraw window.""""""\n\n        self.set_3d()\n\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n\n        # rotate camera\n        glRotatef(self.camera.v_angle_deg(), 1.0, 0, 0)\n        glRotatef(self.camera.h_angle_deg(), 0.0, 1.0, 0)\n\n        glTranslatef(\n            -self.camera.x_pos,\n            -self.camera.y_pos,\n            self.camera.z_pos)\n\n        if self.rendering_type == ""fill"":\n\n            self.use_shader(""test"")\n\n        elif self.rendering_type == ""lines"":\n\n            self.use_shader(""lines"")\n\n        self.renderer.render()\n\n        # draw HUD\n        self.set_2d()\n        self.draw_hud()\n\n    def draw_hud(self):\n        """"""Render HUD.""""""\n\n        # TODO: add resize changes\n        # glUseProgram(self.hud_shader)\n        # temporary solution\n        glUseProgram(0)\n        self.test_label.draw()\n\n    def on_mouse_motion(self, x, y, dx, dy):\n\n        self.camera.add_v_angle(float(dy))\n        self.camera.add_h_angle(float(dx))\n\n    def fill_rendering(self):\n        """"""Set fill rendering option.""""""\n\n        self.rendering_type = ""fill""\n        self.renderer.set_fill()\n\n    def lines_rendering(self):\n        """"""Set lines rendering option.""""""\n\n        self.rendering_type = ""lines""\n        self.renderer.set_lines()\n\n    def toggle_fullscreen(self):\n\n        if self.fullscreen:\n\n            self.set_fullscreen(False)\n            self.set_exclusive_mouse(True)\n            self.set_mouse_visible(False)\n\n        else:\n\n            self.set_fullscreen(True)\n            self.set_exclusive_mouse(True)\n            self.set_mouse_visible(False)\n\n    def data_update(self, dt):\n\n        self.renderer.data_update()\n\n    def less_frequent_tasks(self, dt):\n\n        if self.long_tasks_counter % self.long_tasks == 0:\n\n            self.renderer.check_visibility(\n                self.camera.get_position_inverse_z())\n            self.renderer.set_visibility()\n\n        elif self.long_tasks_counter % self.long_tasks == 1:\n\n            self.renderer.prepare_new_chunks(\n                self.camera.get_position_inverse_z())\n\n        elif self.long_tasks_counter % self.long_tasks == 2:\n\n            self.renderer.create_vbos()\n\n        self.long_tasks_counter += 1\n\n    def testing_zone(self):\n\n        if self.update_counter % 120 == 0:\n\n            # print(self.renderer.world.in_chunk(\n            #     self.camera.get_position_inverse_z()))\n\n            # cposition = self.camera.get_position_inverse_z()\n            # nchunks = self.renderer.world.find_nearest_chunks(cposition)\n            # print(self.renderer.world.block_collision(cposition, nchunks))\n\n            pass\n\n        if self.scripter:\n\n            self.scripter.next_action()\n\n    def devel_keys(self):\n\n        # toggle gravity\n        if self.keyboard[key._7]:\n\n            self.keyboard[key._7] = False\n            if self.camera.gravity:\n\n                self.camera.set_gravity(False)\n                self.camera.stop_falling()\n\n            else:\n\n                self.camera.set_gravity(True)\n\n        # move up\n        if self.keyboard[key._8]:\n\n            self.camera.up()\n\n        # move down\n        elif self.keyboard[key._9]:\n\n            self.camera.down()\n\n        # lines rendering\n        if self.keyboard[key._2]:\n\n            self.lines_rendering()\n\n        # fill rendering\n        elif self.keyboard[key._1]:\n\n            self.fill_rendering()\n\n        # points rendering in future\n\n        # toggle fullscreen\n        elif self.keyboard[key._6]:\n\n            self.keyboard[key._6] = False\n\n            self.toggle_fullscreen()\n\n        # disable exclusive mouse\n        elif self.keyboard[key.INSERT]:\n\n            self.set_exclusive_mouse(False)\n\n    def testing_keys(self):\n        """"""Keys for testing and temporary purposes.""""""\n\n        if self.keyboard[key.NUM_1]:\n\n            self.camera.sprint()\n\n        elif self.keyboard[key.NUM_2]:\n\n            self.keyboard[key.NUM_2] = False\n            self.scripter.stop()\n\n        elif self.keyboard[key.NUM_3]:\n\n            self.keyboard[key.NUM_3] = False\n            self.scripter.start()\n\n        elif self.keyboard[key.R]:\n\n            self.keyboard[key.R] = False\n            self.scripter.reload(""script.txt"")\n\n    def update(self, dt):\n\n        self.testing_zone()\n\n        # send keys status to controller\n        self.controller.update(self.keyboard)\n\n        # development keys\n        if self.devel_keys_enabled:\n\n            self.devel_keys()\n\n        # testing keys\n        self.testing_keys()\n\n        self.update_counter += 1\n'"
interfaces.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""Module for interfaces.""""""\n\nfrom __future__ import print_function\n\n\nclass Creator(object):\n\n    def create(self):\n\n        raise NotImplementedError()\n\n    def update(self):\n\n        raise NotImplementedError()\n\n\nclass Configuration(object):\n\n    def get_values(self):\n        """"""Return configuration values.\n\n        Return:\n            dict: configuration values\n        """"""\n\n        raise NotImplementedError()\n'"
player.py,0,"b'""""""Module for player\'s structures.""""""\n\nfrom __future__ import print_function\n\nimport copy\n\nimport data\nimport script\n\n\nclass Body(script.Controllable):\n    """"""Represents body in world.""""""\n\n    def __init__(self, camera, renderer, collision_offset, height):\n\n        self.camera = camera\n        self.camera_fall_collision = False\n\n        self.renderer = renderer\n        self.collision_offset = collision_offset\n\n        self.height = height\n        self.camera_height = self.height * 0.9\n\n        # static for now\n        self.vertical_offsets = [0.2, 1.2]\n\n    def fall(self):\n\n        position = data.Point(\n            self.camera.x_pos,\n            self.camera.y_pos - self.camera_height,\n            self.camera.z_pos)\n        position2 = data.Point(\n            self.camera.x_pos,\n            self.camera.y_pos - (self.height * 0.8),\n            self.camera.z_pos)\n\n        if self.renderer.ground_collision(position2):\n\n            # print(""helper"")\n            self.camera.collision_helper()\n            self.camera.stop_falling()\n            self.camera_fall_collision = True\n\n        elif self.renderer.ground_collision(position):\n\n            self.camera.stop_falling()\n            self.camera_fall_collision = True\n\n        else:\n\n            self.camera_fall_collision = False\n\n        if self.camera.gravity and not self.camera_fall_collision:\n\n            self.camera.fall()\n\n        else:\n\n            self.camera.jump_counter = 0\n\n    def is_collide(self, point):\n        """"""Check collision for point and all its vertical offsets.\n\n        Args:\n            point (data.Point): point\n\n        Return:\n            bool: collision\n        """"""\n\n        for offset in self.vertical_offsets:\n\n            temp = copy.copy(point)\n            temp.y += offset - self.camera_height\n\n            if self.renderer.ground_collision(temp):\n\n                return True\n\n        return False\n\n    def forward(self):\n\n        next_x = self.camera.next_fw_x_point(self.collision_offset)\n        next_z = self.camera.next_fw_z_point(self.collision_offset)\n\n        if not self.is_collide(next_x):\n\n            self.camera.forward_x()\n\n        if not self.is_collide(next_z):\n\n            self.camera.forward_z()\n\n    def backward(self):\n\n        next_x = self.camera.next_bw_x_point(self.collision_offset)\n        next_z = self.camera.next_bw_z_point(self.collision_offset)\n\n        if not self.is_collide(next_x):\n\n            self.camera.backward_x()\n\n        if not self.is_collide(next_z):\n\n            self.camera.backward_z()\n\n    def left(self):\n\n        next_x = self.camera.next_left_x_point(self.collision_offset)\n        next_z = self.camera.next_left_z_point(self.collision_offset)\n\n        if not self.is_collide(next_x):\n\n            self.camera.left_x()\n\n        if not self.is_collide(next_z):\n\n            self.camera.left_z()\n\n    def right(self):\n\n        next_x = self.camera.next_right_x_point(self.collision_offset)\n        next_z = self.camera.next_right_z_point(self.collision_offset)\n\n        if not self.is_collide(next_x):\n\n            self.camera.right_x()\n\n        if not self.is_collide(next_z):\n\n            self.camera.right_z()\n\n    def jump(self):\n\n        # camera_position = self.camera.get_position_inverse_z()\n        camera_position = self.camera.get_position()\n        camera_position.y += 0.6\n        new_position = camera_position\n\n        if not self.renderer.ground_collision(new_position):\n\n            self.camera.jump()\n\n\nclass PlayerBody(Body):\n    """"""Represents player\'s body in world.""""""\n\n    pass\n'"
run.py,0,"b'#! /usr/bin/env python\n\nimport logging\n\nimport core\nimport graphics\nimport data\nimport configuration\n\n\nlog = logging.getLogger(__name__)\n\n\ndef set_logger():\n\n    logging.basicConfig(level=logging.DEBUG)\n\n\ndef main():\n\n    log.info(""Program start."")\n\n    cw = data.BlockWorld(data.NormalChunk, 20, 20)\n    conf = configuration.EngineConfiguration(""settings.ini"", ""user.ini"")\n    renderer = core.Renderer(cw, conf)\n    renderer.prepare_world()\n\n    window = graphics.GameWindow(renderer)\n    window.show()\n\n    log.info(""Program exit."")\n\n\nif __name__ == ""__main__"":\n\n    set_logger()\n    main()\n'"
script.py,0,"b'#! /usr/bin/env python\n#\n\n""""""Scripting module.""""""\n\nfrom __future__ import print_function\n\nimport re\n\n\nclass Controllable(object):\n    """"""Abstract class for controllable objects.""""""\n\n    def fall(self):\n        """"""Fall.""""""\n\n        raise NotImplementedError()\n\n    def forward(self):\n        """"""Move forward.""""""\n\n        raise NotImplementedError()\n\n    def backward(self):\n        """"""Move backward.""""""\n\n        raise NotImplementedError()\n\n    def left(self):\n        """"""Move left.""""""\n\n        raise NotImplementedError()\n\n    def right(self):\n        """"""Move right.""""""\n\n        raise NotImplementedError()\n\n    def up(self):\n        """"""Move up.""""""\n\n        raise NotImplementedError()\n\n    def down(self):\n        """"""Move down.""""""\n\n        raise NotImplementedError()\n\n    def jump(self):\n        """"""Jump.""""""\n\n        raise NotImplementedError()\n\n\nclass DummyObject(Controllable):\n    """"""Simple testing class.""""""\n\n    def forward(self):\n\n        print(""Moving forward..."")\n\n    def backward(self):\n\n        print(""Moving backward..."")\n\n    def left(self):\n\n        print(""Moving left..."")\n\n    def right(self):\n\n        print(""Moving right..."")\n\n    def up(self):\n\n        print(""Moving up..."")\n\n    def down(self):\n\n        print(""Moving down..."")\n\n\nclass ScriptException(Exception):\n\n    pass\n\n\nclass Script(object):\n    """"""Class for scripts running.\n\n    Args:\n        script_file (str): script filename\n        controllable_obj (Controllable): object for controlling\n    """"""\n\n    def __init__(self, script_file, controllable_obj):\n\n        self.state = CommandState()\n\n        self.controllable_obj = controllable_obj\n\n        self.token_pattern = r""""""\n            (?P<command>[a-zA-Z]+)\n            |(?P<float>[+-]?[0-9]+[.][0-9]+)\n            |(?P<integer>[0-9]+)\n            |(?P<hash>[#]+)\n            |(?P<newline>\\n)\n            |(?P<whitespace>[ \\t])\n        """"""\n\n        self.tokenizer = Tokenizer(self.token_pattern)\n\n        self.script_str = self.load_script(script_file)\n        self.script_tokens = self.analyze_script(self.script_str)\n        self.token_index = 0\n\n        self.stopped = False\n        self.action_completed = False\n\n    @staticmethod\n    def load_script(filename):\n        """"""Load script string from file.\n\n        Args:\n            filename (str): filename\n\n        Return:\n            str: script string\n        """"""\n\n        with open(filename) as fo:\n\n            script_str = fo.read()\n\n        return script_str\n\n    def analyze_script(self, text):\n        """"""Analyze script string.\n\n        Args:\n            text (str): script string\n\n        Return:\n            list of (token name, token value): script tokens\n        """"""\n\n        tokens = []\n        for name, value in self.tokenizer.tokenize(text):\n\n            tokens.append((name, value))\n\n        return tokens\n\n    def next_token(self):\n        """"""Return token.\n\n        Return:\n            (token name, token value): token\n        """"""\n\n        act_index = self.token_index\n        self.token_index += 1\n\n        if act_index >= len(self.script_tokens):\n\n            return None\n\n        return self.script_tokens[act_index]\n\n    def action_done(self):\n        """"""Set action completed status.""""""\n\n        self.action_completed = True\n\n    def next_action(self):\n        """"""Run next action.\n\n        Return:\n            True if next action exists\n        """"""\n\n        if not self.stopped:\n\n            self.action_completed = False\n            while not self.action_completed:\n\n                new_state = self.next()\n\n                if not new_state:\n\n                    return False\n\n        else:\n\n            pass\n\n        return True\n\n    def next(self):\n        """"""Transition to state.\n\n        Return:\n            ScriptState or None: next state\n        """"""\n\n        if self.state:\n\n            self.state.process(self)\n\n            # return new state\n            return self.state\n\n        else:\n\n            return None\n\n    def set_next_state(self, state):\n        """"""Set next state.\n\n        Args:\n            state (ScriptState): new script state\n        """"""\n\n        self.state = state\n\n    def start(self):\n        """"""Start script.""""""\n\n        self.stopped = False\n\n    def stop(self):\n        """"""Stop/pause script.""""""\n\n        self.stopped = True\n\n    def restart(self):\n        """"""Restart script.""""""\n\n        self.state = CommandState()\n\n        self.token_index = 0\n        self.action_completed = False\n\n    def reload(self, script_file):\n\n        # print(""Reloading script file..."")\n        self.script_str = self.load_script(script_file)\n        self.script_tokens = self.analyze_script(self.script_str)\n\n        self.restart()\n\n\nclass CameraScript(Script):\n\n    pass\n\n\nclass ScriptState(object):\n    """"""Base class for script states.""""""\n\n    def __init__(self):\n\n        pass\n\n    def process(self, context):\n\n        pass\n\n\nclass CommandState(ScriptState):\n\n    def process(self, context):\n\n        while True:\n\n            token = context.next_token()\n            # print(""Token: {}"".format(token))\n\n            if token:\n\n                if token[0] == ""whitespace"":\n\n                    continue\n\n                elif token[0] == ""newline"":\n\n                    continue\n\n                elif token[0] == ""command"":\n\n                    # print(""Command: {}"".format(token[1]))\n                    context.set_next_state(MultiplierState(token[1]))\n\n                    break\n\n                elif token[0] == ""hash"":\n\n                    context.set_next_state(CommentState())\n\n                    break\n\n            else:\n\n                context.set_next_state(None)\n\n                break\n\n\nclass MultiplierState(ScriptState):\n\n    def __init__(self, command):\n\n        super(MultiplierState, self).__init__()\n\n        self.command = command\n\n    def process(self, context):\n\n        while True:\n\n            token = context.next_token()\n\n            # print(""Token: {}"".format(token))\n\n            if token:\n\n                if token[0] == ""whitespace"":\n\n                    continue\n\n                elif token[0] == ""newline"":\n\n                    context.set_next_state(CommandState())\n\n                    break\n\n                elif token[0] == ""integer"":\n\n                    # print(""{} x {}"".format(self.command, token[1]))\n                    context.set_next_state(\n                        ProcessCommandState(self.command, int(token[1])))\n\n                    break\n\n            else:\n\n                context.set_next_state(None)\n\n                break\n\n\nclass CommentState(ScriptState):\n\n    def process(self, context):\n\n        while True:\n\n            token = context.next_token()\n\n            # print(""Token: {}"".format(token))\n\n            if token:\n\n                if token[0] == ""newline"":\n\n                    context.set_next_state(CommandState())\n\n                    break\n\n            else:\n\n                context.set_next_state(None)\n\n                break\n\n\nclass ProcessCommandState(ScriptState):\n\n    def __init__(self, command, multiplier):\n\n        super(ProcessCommandState, self).__init__()\n\n        self.command = command\n        self.multiplier = multiplier\n\n    def process(self, context):\n\n        if self.multiplier > 0:\n\n            # print(""Processing {} ({})"".format(self.command, self.multiplier))\n\n            # action\n            if self.command == ""forward"":\n\n                context.controllable_obj.forward()\n\n            elif self.command == ""backward"":\n\n                context.controllable_obj.backward()\n\n            elif self.command == ""left"":\n\n                context.controllable_obj.left()\n\n            elif self.command == ""right"":\n\n                context.controllable_obj.right()\n\n            elif self.command == ""up"":\n\n                context.controllable_obj.up()\n\n            elif self.command == ""down"":\n\n                context.controllable_obj.down()\n\n            context.action_done()\n\n            self.multiplier -= 1\n            context.set_next_state(self)\n\n        else:\n\n            context.set_next_state(CommandState())\n\n\nclass TokenizerException(Exception):\n\n    pass\n\n\nclass Tokenizer(object):\n    """"""Class for token tools.""""""\n\n    def __init__(self, pattern):\n\n        self.token_pattern = pattern\n        self.token_re = re.compile(self.token_pattern, re.VERBOSE)\n\n    def tokenize(self, text):\n\n        position = 0\n        while True:\n\n            match_obj = self.token_re.match(text, position)\n\n            if not match_obj:\n\n                break\n\n            position = match_obj.end()\n\n            token_name = match_obj.lastgroup\n            token_value = match_obj.group(token_name)\n\n            yield token_name, token_value\n\n        if position != len(text):\n\n            raise TokenizerException(\n                ""Tokenizer stopped at pos {} of {}"".format(\n                    position, len(text)))\n\n\nif __name__ == ""__main__"":\n\n    pass\n    # script = Script(""script.txt"", DummyObject())\n    #\n    # for token in script.script_tokens:\n    #\n    #     print(token)\n'"
shaders.py,0,"b'# -*- coding: utf-8 -*-\n#\n\n""""""Module for shaders.""""""\n\n\n# PyOpenGL imports\nfrom OpenGL.GL import GL_VERTEX_SHADER\nfrom OpenGL.GL import GL_FRAGMENT_SHADER\nfrom OpenGL.GL.shaders import compileShader\nfrom OpenGL.GL.shaders import compileProgram\n\n\ndef read_shader(filename):\n    """"""Read shader program from file and return it as a string.""""""\n\n    with open(filename) as fh:\n\n        shader = []\n        for line in fh:\n\n            shader.append(line)\n\n    return """".join(shader)\n\n\ndef load_vshader(filename):\n    """"""Return compiled vertex shader.""""""\n\n    shader = read_shader(filename)\n    vshader = compileShader(shader, GL_VERTEX_SHADER)\n\n    return vshader\n\n\ndef load_fshader(filename):\n    """"""Return compiled fragment shader.""""""\n\n    shader = read_shader(filename)\n    fshader = compileShader(shader, GL_FRAGMENT_SHADER)\n\n    return fshader\n\n\ndef compile_program(*shaders):\n    """"""Return compiled shader program.""""""\n\n    return compileProgram(*shaders)\n\n\nclass ShaderPool(object):\n    """"""Shader programs manager.""""""\n\n    def __init__(self, capabilities):\n\n        self.pool = {}\n        self.capabilities = capabilities\n\n        inits = {\n            ""legacy"": self.init_legacy,\n        }\n\n        if capabilities in inits:\n\n            inits[capabilities]()\n\n        else:\n\n            inits[""legacy""]()\n\n    def get_shaders(self):\n\n        return self.pool\n\n    def capabilities(self):\n\n        return self.capabilities\n\n    def init_legacy(self):\n\n        self.pool[""test""] = self.init_test_shader()\n        self.pool[""hud""] = self.init_hud_shader()\n        self.pool[""lines""] = self.init_line_shader()\n\n    def init_test_shader(self):\n        """"""Return compiled test shader.""""""\n\n        v_shader = load_vshader(\'shaders_data/simple.vs\')\n        f_shader = load_fshader(\'shaders_data/test1.fs\')\n\n        program = compile_program(v_shader, f_shader)\n\n        return program\n\n    def init_hud_shader(self):\n        """"""Return compiled HUD shader.""""""\n\n        v_shader = load_vshader(\'shaders_data/test.vs\')\n        f_shader = load_fshader(\'shaders_data/hud.fs\')\n\n        program = compile_program(v_shader, f_shader)\n\n        return program\n\n    def init_line_shader(self):\n        """"""Return compiled line shader.""""""\n\n        v_shader = load_vshader(\'shaders_data/test.vs\')\n        f_shader = load_fshader(\'shaders_data/black.fs\')\n\n        program = compile_program(v_shader, f_shader)\n\n        return program\n'"
test_mp.py,0,"b'#!/usr/bin/env python\n#\n# Testing client for MP infrastructure\n#\n\nimport time\n\n# import core\nimport data\n\n\ntest_size = 5\n\nchunks = {}\ncreator = data.ChunkCreator(chunks)\n\nz_position = 0\nfor _ in range(test_size):\n\n    print(""create"")\n    chunk_type = data.NormalChunk\n\n    pos = (0, z_position)\n\n    creator.create(chunk_type, pos)\n    creator.create(chunk_type, pos)\n\n    z_position += chunk_type.size\n\nfor _ in range(test_size * 2):\n\n    print(""update"")\n    creator.update()\n    time.sleep(1)\n\ncreator.wait_for_procs()\n\nprint(""Chunks: {}"".format(chunks))\n'"
tests/test_data.py,0,"b'# -*- encoding: utf-8 -*-\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\n\nimport unittest\nimport math\n\nimport data\n\n\nclass TestPoint(unittest.TestCase):\n\n    def setUp(self):\n\n        pass\n\n    def test_test(self):\n\n        self.assertEqual(True, True)\n\n    def test_chunk_distance(self):\n\n        p1 = data.Point(0, 0, 0)\n        p2 = data.Point(0, 0, 0)\n        result = p1.chunk_distance(p2)\n        self.assertAlmostEqual(result, 0)\n\n        p1 = data.Point(0, 0, 0)\n        p2 = data.Point(0, 150, 0)\n        result = p1.chunk_distance(p2)\n        self.assertAlmostEqual(result, 0)\n\n        p1 = data.Point(-10, 0, 0)\n        p2 = data.Point(10, 0, 0)\n        result = p1.chunk_distance(p2)\n        self.assertAlmostEqual(result, 20)\n\n        p1 = data.Point(0, 0, 10)\n        p2 = data.Point(0, 0, -10)\n        result = p1.chunk_distance(p2)\n        self.assertAlmostEqual(result, 20)\n\n        p1 = data.Point(-10, 0, 10)\n        p2 = data.Point(10, 0, -10)\n        result = p1.chunk_distance(p2)\n        self.assertAlmostEqual(result, math.sqrt(pow(20, 2) + pow(-20, 2)))\n'"
