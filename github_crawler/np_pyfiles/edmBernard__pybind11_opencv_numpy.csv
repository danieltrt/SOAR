file_path,api_count,code
setup.py,0,"b'\n#\n# Much of this copied from https://github.com/pybind/python_example.git\n#\n\nimport fnmatch\nimport os\nfrom os.path import dirname, exists, join\nfrom setuptools import find_packages, setup, Extension\nfrom setuptools.command.build_ext import build_ext\nimport subprocess\nimport sys\nimport setuptools\n\n#\n# pybind-specific compilation stuff\n#\n\nclass get_pybind_include(object):\n    """"""Helper class to determine the pybind11 include path\n\n    The purpose of this class is to postpone importing pybind11\n    until it is actually installed, so that the ``get_include()``\n    method can be invoked. """"""\n\n    def __init__(self, user=False):\n        self.user = user\n\n    def __str__(self):\n        import pybind11\n        return pybind11.get_include(self.user)\n\n# As of Python 3.6, CCompiler has a `has_flag` method.\n# cf http://bugs.python.org/issue26689\ndef has_flag(compiler, flagname):\n    """"""Return a boolean indicating whether a flag name is supported on\n    the specified compiler.\n    """"""\n    import tempfile\n    with tempfile.NamedTemporaryFile(\'w\', suffix=\'.cpp\') as f:\n        f.write(\'int main (int argc, char **argv) { return 0; }\')\n        try:\n            compiler.compile([f.name], extra_postargs=[flagname])\n        except setuptools.distutils.errors.CompileError:\n            return False\n    return True\n\n\ndef cpp_flag(compiler):\n    """"""Return the -std=c++[11/14] compiler flag.\n\n    The c++14 is preferred over c++11 (when it is available).\n    """"""\n    if has_flag(compiler, \'-std=c++14\'):\n        return \'-std=c++14\'\n    elif has_flag(compiler, \'-std=c++11\'):\n        return \'-std=c++11\'\n    else:\n        raise RuntimeError(\'Unsupported compiler -- at least C++11 support \'\n                           \'is needed!\')\n\n\nclass BuildExt(build_ext):\n    """"""A custom build extension for adding compiler-specific options.""""""\n    c_opts = {\n        \'msvc\': [\'/EHsc\'],\n        \'unix\': [],\n    }\n\n    if sys.platform == \'darwin\':\n        c_opts[\'unix\'] += [\'-stdlib=libc++\', \'-mmacosx-version-min=10.7\']\n\n    def build_extensions(self):\n        ct = self.compiler.compiler_type\n        opts = self.c_opts.get(ct, [])\n        if ct == \'unix\':\n            opts.append(\'-s\') # strip\n            opts.append(\'-g0\') # remove debug symbols\n            opts.append(cpp_flag(self.compiler))\n            if has_flag(self.compiler, \'-fvisibility=hidden\'):\n                opts.append(\'-fvisibility=hidden\')\n        for ext in self.extensions:\n            ext.extra_compile_args = opts\n        build_ext.build_extensions(self)\n\next_modules = [\n    Extension(\n        \'example/example\',\n        [\n            \'example.cpp\',\n            \'ndarray_converter.cpp\',\n        ],\n        include_dirs=[\n            # Path to pybind11 headers\n            get_pybind_include(),\n            get_pybind_include(user=True),\n        ],\n        libraries=[\'opencv_core\', \'opencv_highgui\'],\n        language=\'c++\',\n    ),\n]\n\nsetup(\n    name=\'pybind11-opencv-numpy-example\',\n    version=\'0.1\',\n    author=\'Dustin Spicuzza\',\n    author_email=\'dustin@virtualroadside.com\',\n    packages=find_packages(),\n    ext_modules=ext_modules,\n    install_requires=None,\n    cmdclass={\'build_ext\': BuildExt},\n    zip_safe=False,\n)\n'"
test.py,1,"b'import numpy as np\nimport example.example as eb\nimport copy\n\n# Read from c++\na = eb.read_image(""test.png"")\nprint(\'init a: 0x%x\' % id(a))\neb.show_image(a)  # work\n\n# Check continuous problem from old version\nb = a[:, :, 0]\neb.show_image(b)  # work no more continous problem\nprint(\'diff b: 0x%x\' % id(b))\n\nc = copy.deepcopy(b)\neb.show_image(c)  # still works\nprint(\'diff c: 0x%x\' % id(c))\n\n\n# Proves that it\'s still the same thing\nd = eb.passthru(a)\nprint(\'same d: 0x%x\' % id(b))\n\n# Make a copy\ne = eb.clone(d)\nprint(\'diff e: 0x%x\' % id(e))\n\n\n# different allocator\nf = np.zeros(shape=(100, 100), dtype=np.uint8)\nprint(\'\\ninit e: 0x%x\' % id(f))\n\ng = eb.passthru(f)\nprint(\'same f: 0x%x\' % id(g))\n\n\n# example of class\nmy_class = eb.AddClass(1)\nh = my_class.add(f)\nprint(f[0, 0])  # expected 0\nprint(h[0, 0])  # expected 1\n'"
example/__init__.py,0,b''
