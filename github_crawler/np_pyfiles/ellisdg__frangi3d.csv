file_path,api_count,code
frangi/__init__.py,0,b''
frangi/frangi.py,11,"b'import numpy as np\n\nfrom .utils import divide_nonzero\nfrom .hessian import absolute_hessian_eigenvalues\n\n\ndef frangi(nd_array, scale_range=(1, 10), scale_step=2, alpha=0.5, beta=0.5, frangi_c=500, black_vessels=True):\n\n    if not nd_array.ndim == 3:\n        raise(ValueError(""Only 3 dimensions is currently supported""))\n\n    # from https://github.com/scikit-image/scikit-image/blob/master/skimage/filters/_frangi.py#L74\n    sigmas = np.arange(scale_range[0], scale_range[1], scale_step)\n    if np.any(np.asarray(sigmas) < 0.0):\n        raise ValueError(""Sigma values less than zero are not valid"")\n\n    filtered_array = np.zeros(sigmas.shape + nd_array.shape)\n\n    for i, sigma in enumerate(sigmas):\n        eigenvalues = absolute_hessian_eigenvalues(nd_array, sigma=sigma, scale=True)\n        filtered_array[i] = compute_vesselness(*eigenvalues, alpha=alpha, beta=beta, c=frangi_c,\n                                               black_white=black_vessels)\n\n    return np.max(filtered_array, axis=0)\n\n\ndef compute_measures(eigen1, eigen2, eigen3):\n    """"""\n    RA - plate-like structures\n    RB - blob-like structures\n    S - background\n    """"""\n    Ra = divide_nonzero(np.abs(eigen2), np.abs(eigen3))\n    Rb = divide_nonzero(np.abs(eigen1), np.sqrt(np.abs(np.multiply(eigen2, eigen3))))\n    S = np.sqrt(np.square(eigen1) + np.square(eigen2) + np.square(eigen3))\n    return Ra, Rb, S\n\n\ndef compute_plate_like_factor(Ra, alpha):\n    return 1 - np.exp(np.negative(np.square(Ra)) / (2 * np.square(alpha)))\n\n\ndef compute_blob_like_factor(Rb, beta):\n    return np.exp(np.negative(np.square(Rb) / (2 * np.square(beta))))\n\n\ndef compute_background_factor(S, c):\n    return 1 - np.exp(np.negative(np.square(S)) / (2 * np.square(c)))\n\n\ndef compute_vesselness(eigen1, eigen2, eigen3, alpha, beta, c, black_white):\n    Ra, Rb, S = compute_measures(eigen1, eigen2, eigen3)\n    plate = compute_plate_like_factor(Ra, alpha)\n    blob = compute_blob_like_factor(Rb, beta)\n    background = compute_background_factor(S, c)\n    return filter_out_background(plate * blob * background, black_white, eigen2, eigen3)\n\n\ndef filter_out_background(voxel_data, black_white, eigen2, eigen3):\n    """"""\n    Set black_white to true if vessels are darker than the background and to false if\n    vessels are brighter than the background.\n    """"""\n    if black_white:\n        voxel_data[eigen2 < 0] = 0\n        voxel_data[eigen3 < 0] = 0\n    else:\n        voxel_data[eigen2 > 0] = 0\n        voxel_data[eigen3 > 0] = 0\n    voxel_data[np.isnan(voxel_data)] = 0\n    return voxel_data\n'"
frangi/hessian.py,4,"b'from itertools import combinations_with_replacement\n\nimport numpy as np\nfrom scipy import ndimage as ndi\n\nfrom .utils import absolute_eigenvaluesh\n\n\ndef compute_hessian_matrix(nd_array, sigma=1, scale=True):\n    """"""\n    Computes the hessian matrix for an nd_array.\n    This can be used to detect vesselness as well as other features.\n\n    In 3D the first derivative will contain three directional gradients at each index:\n    [ gx,  gy,  gz ]\n\n    The Hessian matrix at each index will then be equal to the second derivative:\n    [ gxx, gxy, gxz]\n    [ gyx, gyy, gyz]\n    [ gzx, gzy, gzz]\n\n    The Hessian matrix is symmetrical, so gyx == gxy, gzx == gxz, and gyz == gzy.\n\n    :param nd_array: n-dimensional array from which to compute the hessian matrix.\n    :param sigma: gaussian smoothing to perform on the array.\n    :param scale: if True, the hessian elements will be scaled by sigma squared.\n    :return: hessian array of shape (..., ndim, ndim)\n    """"""\n    ndim = nd_array.ndim\n\n    # smooth the nd_array\n    smoothed = ndi.gaussian_filter(nd_array, sigma=sigma)\n\n    # compute the first order gradients\n    gradient_list = np.gradient(smoothed)\n\n    # compute the hessian elements\n    hessian_elements = [np.gradient(gradient_list[ax0], axis=ax1)\n                        for ax0, ax1 in combinations_with_replacement(range(ndim), 2)]\n\n    if sigma > 0 and scale:\n        # scale the elements of the hessian matrix\n        hessian_elements = [(sigma ** 2) * element for element in hessian_elements]\n\n    # create hessian matrix from hessian elements\n    hessian_full = [[None] * ndim] * ndim\n\n    for index, (ax0, ax1) in enumerate(combinations_with_replacement(range(ndim), 2)):\n        element = hessian_elements[index]\n        hessian_full[ax0][ax1] = element\n        if ax0 != ax1:\n            hessian_full[ax1][ax0] = element\n\n    hessian_rows = list()\n    for row in hessian_full:\n        hessian_rows.append(np.stack(row, axis=-1))\n\n    hessian = np.stack(hessian_rows, axis=-2)\n    return hessian\n\n\ndef absolute_hessian_eigenvalues(nd_array, sigma=1, scale=True):\n    """"""\n    Eigenvalues of the hessian matrix calculated from the input array sorted by absolute value.\n    :param nd_array: input array from which to calculate hessian eigenvalues.\n    :param sigma: gaussian smoothing parameter.\n    :param scale: if True hessian values will be scaled according to sigma squared.\n    :return: list of eigenvalues [eigenvalue1, eigenvalue2, ...]\n    """"""\n    return absolute_eigenvaluesh(compute_hessian_matrix(nd_array, sigma=sigma, scale=scale))\n'"
frangi/utils.py,7,"b'import numpy as np\n\n\ndef divide_nonzero(array1, array2):\n    """"""\n    Divides two arrays. Returns zero when dividing by zero.\n    """"""\n    denominator = np.copy(array2)\n    denominator[denominator == 0] = 1e-10\n    return np.divide(array1, denominator)\n\n\ndef create_image_like(data, image):\n    return image.__class__(data, affine=image.affine, header=image.header)\n\n\ndef absolute_eigenvaluesh(nd_array):\n    """"""\n    Computes the eigenvalues sorted by absolute value from the symmetrical matrix.\n    :param nd_array: array from which the eigenvalues will be calculated.\n    :return: A list with the eigenvalues sorted in absolute ascending order (e.g. [eigenvalue1, eigenvalue2, ...])\n    """"""\n    eigenvalues = np.linalg.eigvalsh(nd_array)\n    sorted_eigenvalues = sortbyabs(eigenvalues, axis=-1)\n    return [np.squeeze(eigenvalue, axis=-1)\n            for eigenvalue in np.split(sorted_eigenvalues, sorted_eigenvalues.shape[-1], axis=-1)]\n\n\ndef sortbyabs(a, axis=0):\n    """"""Sort array along a given axis by the absolute value\n    modified from: http://stackoverflow.com/a/11253931/4067734\n    """"""\n    index = list(np.ix_(*[np.arange(i) for i in a.shape]))\n    index[axis] = np.abs(a).argsort(axis)\n    return a[index]\n'"
