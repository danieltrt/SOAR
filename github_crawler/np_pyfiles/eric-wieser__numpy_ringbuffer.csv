file_path,api_count,code
setup.py,0,"b'from setuptools import setup\n\nwith open(\'numpy_ringbuffer/__about__.py\') as f:\n    exec(f.read())\n\ntry:\n    import pypandoc\n    long_description = pypandoc.convert(\'README.md\', \'rst\')\nexcept (IOError, ImportError):\n    print(""No"")\n    long_description = open(\'README.md\').read()\n\nsetup(\n    name=""numpy_ringbuffer"",\n    version=__version__,\n    packages=[\'numpy_ringbuffer\'],\n\n    install_requires=[""numpy""],\n\n    author=""Eric Wieser"",\n    author_email=""wieser.eric+numpy@gmail.com"",\n    description=""Ring buffer implementation for numpy"",\n    long_description=long_description,\n    license=""MIT"",\n    keywords=[""numpy"", ""buffer"", ""ringbuffer"", ""circular buffer""],\n    url=""https://github.com/eric-wieser/numpy_ringbuffer"",\n    download_url=""https://github.com/eric-wieser/numpy_ringbuffer/tarball/v""+__version__,\n    classifiers=[\n        ""License :: OSI Approved :: MIT License"",\n        ""Intended Audience :: Developers"",\n        ""Programming Language :: Python"",\n        ""Programming Language :: Python :: 2.7"",\n        ""Programming Language :: Python :: 3.4"",\n        ""Programming Language :: Python :: 3.5""\n    ]\n)\n'"
tests.py,36,"b'import unittest\nimport numpy as np\nfrom numpy_ringbuffer import RingBuffer\n\nclass TestAll(unittest.TestCase):\n\tdef test_dtype(self):\n\t\tr = RingBuffer(5)\n\t\tself.assertEqual(r.dtype, np.dtype(np.float64))\n\n\t\tr = RingBuffer(5, dtype=np.bool)\n\t\tself.assertEqual(r.dtype, np.dtype(np.bool))\n\n\tdef test_sizes(self):\n\t\tr = RingBuffer(5, dtype=(int, 2))\n\t\tself.assertEqual(r.maxlen, 5)\n\t\tself.assertEqual(len(r), 0)\n\t\tself.assertEqual(r.shape, (0,2))\n\n\t\tr.append([0, 0])\n\t\tself.assertEqual(r.maxlen, 5)\n\t\tself.assertEqual(len(r), 1)\n\t\tself.assertEqual(r.shape, (1,2))\n\n\tdef test_append(self):\n\t\tr = RingBuffer(5)\n\n\t\tr.append(1)\n\t\tnp.testing.assert_equal(r, np.array([1]))\n\t\tself.assertEqual(len(r), 1)\n\n\t\tr.append(2)\n\t\tnp.testing.assert_equal(r, np.array([1, 2]))\n\t\tself.assertEqual(len(r), 2)\n\n\t\tr.append(3)\n\t\tr.append(4)\n\t\tr.append(5)\n\t\tnp.testing.assert_equal(r, np.array([1, 2, 3, 4, 5]))\n\t\tself.assertEqual(len(r), 5)\n\n\t\tr.append(6)\n\t\tnp.testing.assert_equal(r, np.array([2, 3, 4, 5, 6]))\n\t\tself.assertEqual(len(r), 5)\n\n\t\tself.assertEqual(r[4], 6)\n\t\tself.assertEqual(r[-1], 6)\n\n\tdef test_getitem(self):\n\t\tr = RingBuffer(5)\n\t\tr.extend([1, 2, 3])\n\t\tr.extendleft([4, 5])\n\t\texpected = np.array([4, 5, 1, 2, 3])\n\t\tnp.testing.assert_equal(r, expected)\n\n\t\tfor i in range(r.maxlen):\n\t\t\tself.assertEqual(expected[i], r[i])\n\n\t\tii = [0, 4, 3, 1, 2]\n\t\tnp.testing.assert_equal(r[ii], expected[ii])\n\n\tdef test_appendleft(self):\n\t\tr = RingBuffer(5)\n\n\t\tr.appendleft(1)\n\t\tnp.testing.assert_equal(r, np.array([1]))\n\t\tself.assertEqual(len(r), 1)\n\n\t\tr.appendleft(2)\n\t\tnp.testing.assert_equal(r, np.array([2, 1]))\n\t\tself.assertEqual(len(r), 2)\n\n\t\tr.appendleft(3)\n\t\tr.appendleft(4)\n\t\tr.appendleft(5)\n\t\tnp.testing.assert_equal(r, np.array([5, 4, 3, 2, 1]))\n\t\tself.assertEqual(len(r), 5)\n\n\t\tr.appendleft(6)\n\t\tnp.testing.assert_equal(r, np.array([6, 5, 4, 3, 2]))\n\t\tself.assertEqual(len(r), 5)\n\n\tdef test_extend(self):\n\t\tr = RingBuffer(5)\n\t\tr.extend([1, 2, 3])\n\t\tnp.testing.assert_equal(r, np.array([1, 2, 3]))\n\t\tr.popleft()\n\t\tr.extend([4, 5, 6])\n\t\tnp.testing.assert_equal(r, np.array([2, 3, 4, 5, 6]))\n\t\tr.extendleft([0, 1])\n\t\tnp.testing.assert_equal(r, np.array([0, 1, 2, 3, 4]))\n\n\t\tr.extendleft([1, 2, 3, 4, 5, 6, 7])\n\t\tnp.testing.assert_equal(r, np.array([1, 2, 3, 4, 5]))\n\n\t\tr.extend([1, 2, 3, 4, 5, 6, 7])\n\t\tnp.testing.assert_equal(r, np.array([3, 4, 5, 6, 7]))\n\n\tdef test_pops(self):\n\t\tr = RingBuffer(3)\n\t\tr.append(1)\n\t\tr.appendleft(2)\n\t\tr.append(3)\n\t\tnp.testing.assert_equal(r, np.array([2, 1, 3]))\n\n\t\tself.assertEqual(r.pop(), 3)\n\t\tnp.testing.assert_equal(r, np.array([2, 1]))\n\n\t\tself.assertEqual(r.popleft(), 2)\n\t\tnp.testing.assert_equal(r, np.array([1]))\n\n\t\t# test empty pops\n\t\tempty = RingBuffer(1)\n\t\twith self.assertRaisesRegex(IndexError, ""pop from an empty RingBuffer""):\n\t\t\tempty.pop()\n\t\twith self.assertRaisesRegex(IndexError, ""pop from an empty RingBuffer""):\n\t\t\tempty.popleft()\n\n\tdef test_2d(self):\n\t\tr = RingBuffer(5, dtype=(np.float, 2))\n\n\t\tr.append([1, 2])\n\t\tnp.testing.assert_equal(r, np.array([[1, 2]]))\n\t\tself.assertEqual(len(r), 1)\n\t\tself.assertEqual(np.shape(r), (1, 2))\n\n\t\tr.append([3, 4])\n\t\tnp.testing.assert_equal(r, np.array([[1, 2], [3, 4]]))\n\t\tself.assertEqual(len(r), 2)\n\t\tself.assertEqual(np.shape(r), (2, 2))\n\n\t\tr.appendleft([5, 6])\n\t\tnp.testing.assert_equal(r, np.array([[5, 6], [1, 2], [3, 4]]))\n\t\tself.assertEqual(len(r), 3)\n\t\tself.assertEqual(np.shape(r), (3, 2))\n\n\t\tnp.testing.assert_equal(r[0], [5, 6])\n\t\tnp.testing.assert_equal(r[0,:], [5, 6])\n\t\tnp.testing.assert_equal(r[:,0], [5, 1, 3])\n\n\tdef test_iter(self):\n\t\tr = RingBuffer(5)\n\t\tfor i in range(5):\n\t\t\tr.append(i)\n\t\tfor i, j in zip(r, range(5)):\n\t\t\tself.assertEqual(i, j)\n\n\tdef test_repr(self):\n\t\tr = RingBuffer(5, dtype=np.int)\n\t\tfor i in range(5):\n\t\t\tr.append(i)\n\n\t\tself.assertEqual(repr(r), \'<RingBuffer of array([0, 1, 2, 3, 4])>\')\n\n\tdef test_no_overwrite(self):\n\t\tr = RingBuffer(3, allow_overwrite=False)\n\t\tr.append(1)\n\t\tr.append(2)\n\t\tr.appendleft(3)\n\t\twith self.assertRaisesRegex(IndexError, \'overwrite\'):\n\t\t\tr.appendleft(4)\n\t\twith self.assertRaisesRegex(IndexError, \'overwrite\'):\n\t\t\tr.extendleft([4])\n\t\tr.extendleft([])\n\n\t\tnp.testing.assert_equal(r, np.array([3, 1, 2]))\n\t\twith self.assertRaisesRegex(IndexError, \'overwrite\'):\n\t\t\tr.append(4)\n\t\twith self.assertRaisesRegex(IndexError, \'overwrite\'):\n\t\t\tr.extend([4])\n\t\tr.extend([])\n\n\t\t# works fine if we pop the surplus\n\t\tr.pop()\n\t\tr.append(4)\n\t\tnp.testing.assert_equal(r, np.array([3, 1, 4]))\n\n\tdef test_degenerate(self):\n\t\tr = RingBuffer(0)\n\t\tnp.testing.assert_equal(r, np.array([]))\n\n\t\t# this does not error with deque(maxlen=0), so should not error here\n\t\ttry:\n\t\t\tr.append(0)\n\t\t\tr.appendleft(0)\n\t\texcept IndexError:\n\t\t\tself.fail()\n\nif not hasattr(TestAll, \'assertRaisesRegex\'):\n\tTestAll.assertRaisesRegex = TestAll.assertRaisesRegexp\n\nif __name__ == \'__main__\':\n\tunittest.main()\n'"
numpy_ringbuffer/__about__.py,0,"b'__version__ = ""0.2.1""\n'"
numpy_ringbuffer/__init__.py,10,"b'import numpy as np\nfrom collections import Sequence\n\nfrom .__about__ import *\n\nclass RingBuffer(Sequence):\n\tdef __init__(self, capacity, dtype=float, allow_overwrite=True):\n\t\t""""""\n\t\tCreate a new ring buffer with the given capacity and element type\n\n\t\tParameters\n\t\t----------\n\t\tcapacity: int\n\t\t\tThe maximum capacity of the ring buffer\n\t\tdtype: data-type, optional\n\t\t\tDesired type of buffer elements. Use a type like (float, 2) to\n\t\t\tproduce a buffer with shape (N, 2)\n\t\tallow_overwrite: bool\n\t\t\tIf false, throw an IndexError when trying to append to an already\n\t\t\tfull buffer\n\t\t""""""\n\t\tself._arr = np.empty(capacity, dtype)\n\t\tself._left_index = 0\n\t\tself._right_index = 0\n\t\tself._capacity = capacity\n\t\tself._allow_overwrite = allow_overwrite\n\n\tdef _unwrap(self):\n\t\t"""""" Copy the data from this buffer into unwrapped form """"""\n\t\treturn np.concatenate((\n\t\t\tself._arr[self._left_index:min(self._right_index, self._capacity)],\n\t\t\tself._arr[:max(self._right_index - self._capacity, 0)]\n\t\t))\n\n\tdef _fix_indices(self):\n\t\t""""""\n\t\tEnforce our invariant that 0 <= self._left_index < self._capacity\n\t\t""""""\n\t\tif self._left_index >= self._capacity:\n\t\t\tself._left_index -= self._capacity\n\t\t\tself._right_index -= self._capacity\n\t\telif self._left_index < 0:\n\t\t\tself._left_index += self._capacity\n\t\t\tself._right_index += self._capacity\n\n\t@property\n\tdef is_full(self):\n\t\t"""""" True if there is no more space in the buffer """"""\n\t\treturn len(self) == self._capacity\n\n\t# numpy compatibility\n\tdef __array__(self):\n\t\treturn self._unwrap()\n\n\t@property\n\tdef dtype(self):\n\t\treturn self._arr.dtype\n\n\t@property\n\tdef shape(self):\n\t\treturn (len(self),) + self._arr.shape[1:]\n\n\n\t# these mirror methods from deque\n\t@property\n\tdef maxlen(self):\n\t\treturn self._capacity\n\n\tdef append(self, value):\n\t\tif self.is_full:\n\t\t\tif not self._allow_overwrite:\n\t\t\t\traise IndexError(\'append to a full RingBuffer with overwrite disabled\')\n\t\t\telif not len(self):\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tself._left_index += 1\n\n\t\tself._arr[self._right_index % self._capacity] = value\n\t\tself._right_index += 1\n\t\tself._fix_indices()\n\n\tdef appendleft(self, value):\n\t\tif self.is_full:\n\t\t\tif not self._allow_overwrite:\n\t\t\t\traise IndexError(\'append to a full RingBuffer with overwrite disabled\')\n\t\t\telif not len(self):\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tself._right_index -= 1\n\n\t\tself._left_index -= 1\n\t\tself._fix_indices()\n\t\tself._arr[self._left_index] = value\n\n\tdef pop(self):\n\t\tif len(self) == 0:\n\t\t\traise IndexError(""pop from an empty RingBuffer"")\n\t\tself._right_index -= 1\n\t\tself._fix_indices()\n\t\tres = self._arr[self._right_index % self._capacity]\n\t\treturn res\n\n\tdef popleft(self):\n\t\tif len(self) == 0:\n\t\t\traise IndexError(""pop from an empty RingBuffer"")\n\t\tres = self._arr[self._left_index]\n\t\tself._left_index += 1\n\t\tself._fix_indices()\n\t\treturn res\n\n\tdef extend(self, values):\n\t\tlv = len(values)\n\t\tif len(self) + lv > self._capacity:\n\t\t\tif not self._allow_overwrite:\n\t\t\t\traise IndexError(\'extend a RingBuffer such that it would overflow, with overwrite disabled\')\n\t\t\telif not len(self):\n\t\t\t\treturn\n\t\tif lv >= self._capacity:\n\t\t\t# wipe the entire array! - this may not be threadsafe\n\t\t\tself._arr[...] = values[-self._capacity:]\n\t\t\tself._right_index = self._capacity\n\t\t\tself._left_index = 0\n\t\t\treturn\n\n\t\tri = self._right_index % self._capacity\n\t\tsl1 = np.s_[ri:min(ri + lv, self._capacity)]\n\t\tsl2 = np.s_[:max(ri + lv - self._capacity, 0)]\n\t\tself._arr[sl1] = values[:sl1.stop - sl1.start]\n\t\tself._arr[sl2] = values[sl1.stop - sl1.start:]\n\t\tself._right_index += lv\n\n\t\tself._left_index = max(self._left_index, self._right_index - self._capacity)\n\t\tself._fix_indices()\n\n\tdef extendleft(self, values):\n\t\tlv = len(values)\n\t\tif len(self) + lv > self._capacity:\n\t\t\tif not self._allow_overwrite:\n\t\t\t\traise IndexError(\'extend a RingBuffer such that it would overflow, with overwrite disabled\')\n\t\t\telif not len(self):\n\t\t\t\treturn\n\t\tif lv >= self._capacity:\n\t\t\t# wipe the entire array! - this may not be threadsafe\n\t\t\tself._arr[...] = values[:self._capacity]\n\t\t\tself._right_index = self._capacity\n\t\t\tself._left_index = 0\n\t\t\treturn\n\n\t\tself._left_index -= lv\n\t\tself._fix_indices()\n\t\tli = self._left_index\n\t\tsl1 = np.s_[li:min(li + lv, self._capacity)]\n\t\tsl2 = np.s_[:max(li + lv - self._capacity, 0)]\n\t\tself._arr[sl1] = values[:sl1.stop - sl1.start]\n\t\tself._arr[sl2] = values[sl1.stop - sl1.start:]\n\n\t\tself._right_index = min(self._right_index, self._left_index + self._capacity)\n\n\n\t# implement Sequence methods\n\tdef __len__(self):\n\t\treturn self._right_index - self._left_index\n\n\tdef __getitem__(self, item):\n\t\t# handle simple (b[1]) and basic (b[np.array([1, 2, 3])]) fancy indexing specially\n\t\tif not isinstance(item, tuple):\n\t\t\titem_arr = np.asarray(item)\n\t\t\tif issubclass(item_arr.dtype.type, np.integer):\n\t\t\t\titem_arr = (item_arr + self._left_index) % self._capacity\n\t\t\t\treturn self._arr[item_arr]\n\n\t\t# for everything else, get it right at the expense of efficiency\n\t\treturn self._unwrap()[item]\n\n\tdef __iter__(self):\n\t\t# alarmingly, this is comparable in speed to using itertools.chain\n\t\treturn iter(self._unwrap())\n\n\t# Everything else\n\tdef __repr__(self):\n\t\treturn \'<RingBuffer of {!r}>\'.format(np.asarray(self))\n'"
