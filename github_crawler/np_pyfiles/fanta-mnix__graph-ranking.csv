file_path,api_count,code
rank.py,5,"b'def discrete_uniform(n):\n    import numpy as np\n    return np.repeat([1.0 / n], n)\n\n\ndef as_markov_matrix(adjacency):\n    import numpy as np\n    from scipy import sparse\n\n    m, n = adjacency.shape\n    assert m == n\n    assert not sparse.issparse(adjacency)\n\n    adjacency = adjacency.copy()\n    dangling = ~np.any(adjacency , axis=1)\n    adjacency[dangling, :] = 1.0\n    markov_matrix = adjacency / adjacency.sum(axis=1).reshape(-1, 1)\n    return markov_matrix.T\n\n\ndef solve(markov_matrix, p0, p_follow, eps, max_iter):\n    import numpy as np\n    import logging\n    from scipy import sparse, linalg\n\n    def is_valid_matrix():\n        probabilities = markov_matrix.sum(axis=0)\n        ideal = np.ones(len(probabilities))\n        return np.allclose(ideal, probabilities)\n\n    m, n = markov_matrix.shape\n    assert m == n\n    assert len(p0) == n\n    assert is_valid_matrix()\n\n    if not sparse.isspmatrix_csr(markov_matrix):\n        markov_matrix = sparse.csr_matrix(markov_matrix)\n\n    p = p0\n    base = discrete_uniform(n)\n\n    for i in range(max_iter):\n        p_next = (1 - p_follow) * base + p_follow * markov_matrix.dot(p)\n        delta = (linalg.norm(p_next - p, 1)) / n\n        logging.debug(""Delta: {:.4f}"", delta)\n        p = p_next\n        if delta <= eps:\n            break\n\n    return p\n\n\ndef calculate_rank(graph, damp=0.85, eps=1e-4, max_iter=50):\n    def build_index():\n        return {node: index for index, node in enumerate(graph)}\n\n    index = build_index()\n\n    def build_adjacency_matrix():\n        import numpy as np\n\n        nodes = graph.keys()\n        n = len(nodes)\n        matrix = np.zeros((n, n), dtype=float)\n\n        for source in nodes:\n            i = index[source]\n            possible_transitions = graph[source]\n            for target in possible_transitions:\n                j = index[target]\n                matrix[i, j] = 1.0\n\n        return matrix\n\n    adjacency = build_adjacency_matrix()\n    markov = as_markov_matrix(adjacency)\n    p = discrete_uniform(len(graph))\n    stable = solve(markov, p, damp, eps, max_iter)\n\n    def invert_index():\n        return {value: key for key, value in index.items()}\n\n    return sorted(zip(invert_index().values(), stable), key=lambda x: x[1], reverse=True)\n'"
usage.py,0,"b""from rank import calculate_rank\nfrom pprint import pprint\n\nlinks = {\n    'webpage-1': {'webpage-2', 'webpage-4', 'webpage-5', 'webpage-6', 'webpage-8', 'webpage-9', 'webpage-10'},\n    'webpage-2': {'webpage-5', 'webpage-6'},\n    'webpage-3': {'webpage-10'},\n    'webpage-4': {'webpage-9'},\n    'webpage-5': {'webpage-2', 'webpage-4'},\n    'webpage-6': set(), # dangling page\n    'webpage-7': {'webpage-1', 'webpage-3', 'webpage-4'},\n    'webpage-8': {'webpage-1'},\n    'webpage-9': {'webpage-1', 'webpage-2', 'webpage-3', 'webpage-8', 'webpage-10'},\n    'webpage-10': {'webpage-2', 'webpage-3', 'webpage-8', 'webpage-9'},\n}\n\npprint(calculate_rank(links)[:10])\n"""
