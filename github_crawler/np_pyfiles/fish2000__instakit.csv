file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#    \n#    INSTAKIT -- Instagrammy image-processors and tools, based on Pillow and SciPy\n#    \n#    Copyright \xc2\xa9 2012-2025 Alexander B\xc3\xb6hn\n#    \n#    Permission is hereby granted, free of charge, to any person obtaining a copy \n#    of this software and associated documentation files (the ""Software""), to deal \n#    in the Software without restriction, including without limitation the rights \n#    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n#    copies of the Software, and to permit persons to whom the Software is \n#    furnished to do so, subject to the following conditions:\n#    \n#    The above copyright notice and this permission notice shall be included in all \n#    copies or substantial portions of the Software.\n#    \n#    THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n#    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n#    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n#    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n#    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n#    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n#    SOFTWARE.\n#\n\'\'\' Image processors for django-imagekit - based on Pillow, SciPy, and scikit-image \'\'\'\n\nfrom __future__ import print_function\nimport os, sys, sysconfig\n\ntry:\n    from os import cpu_count\nexcept ImportError:\n    try:\n        from multiprocessing import cpu_count\n    except ImportError:\n        try:\n            from psutil import cpu_count\n        except ImportError:\n            cpu_count = lambda: 1\n\nfrom setuptools import setup, find_packages\nfrom Cython.Build import cythonize\n\n# HOST PYTHON VERSION\nPYTHON_VERSION = float(""%s%s%s"" % (sys.version_info.major, os.extsep,\n                                   sys.version_info.minor))\n\n# CONSTANTS\nPROJECT_NAME = \'instakit\'\nAUTHOR_NAME = \'Alexander B\xc3\xb6hn\'\nAUTHOR_USER = \'fish2000\'\n\nGITHUB = \'github.com\'\nGMAIL = \'gmail.com\'\n\nAUTHOR_EMAIL = \'%s@%s\' % (AUTHOR_USER, GMAIL)\nPROJECT_GH_URL = \'https://%s/%s/%s\' % (GITHUB,\n                                       AUTHOR_USER,\n                                       PROJECT_NAME)\nPROJECT_DL_URL = \'%s/zipball/master\' % PROJECT_GH_URL\n\nKEYWORDS = (\'django\',\n            \'imagekit\', PROJECT_NAME,\n                        AUTHOR_USER,\n            \'image processing\',\n            \'image analysis\',\n            \'image comparison\',\n            \'halftone\', \'dithering\',\n            \'Photoshop\', \'acv\', \'curves\',\n            \'PIL\', \'Pillow\',\n            \'Cython\',\n            \'NumPy\', \'SciPy\', \'scikit-image\')\n\nCPPLANGS = (\'c++\', \'cxx\', \'cpp\', \'cc\', \'mm\')\nCPPVERSION = PYTHON_VERSION < 3 and \'c++14\' or \'c++17\'\n\n# PROJECT DIRECTORY\nCWD = os.path.dirname(__file__)\nBASE_PATH = os.path.join(\n            os.path.abspath(CWD), PROJECT_NAME)\n\ndef project_content(*filenames):\n    import io\n    filepath = os.path.join(CWD, *filenames)\n    if not os.path.isfile(filepath):\n        raise IOError(""""""File %s doesn\'t exist"""""" % filepath)\n    out = \'\'\n    with io.open(filepath, \'r\') as handle:\n        out += handle.read()\n    if not out:\n        raise ValueError(""""""File %s couldn\'t be read"""""" % os.path.sep.join(filenames))\n    return out.strip()\n\n# CYTHON & C-API EXTENSION MODULES\ndef cython_module(*args, **kwargs):\n    from Cython.Distutils import Extension\n    sources = []\n    sources.extend(kwargs.pop(\'sources\', []))\n    include_dirs = []\n    include_dirs.extend(kwargs.pop(\'include_dirs\', []))\n    ext_package = os.path.extsep.join(args)\n    ext_pth = os.path.sep.join(args) + os.extsep + ""pyx""\n    sources.insert(0, ext_pth)\n    language = kwargs.pop(\'language\', \'c\').lower()\n    extra_compile_args = [\'-Wno-unused-function\',\n                          \'-Wno-unneeded-internal-declaration\',\n                          \'-O3\',\n                          \'-fstrict-aliasing\',\n                          \'-funroll-loops\',\n                          \'-mtune=native\']\n    if language in CPPLANGS:\n        extra_compile_args.extend([\'-std=%s\' % CPPVERSION,\n                                   \'-stdlib=libc++\',\n                                   \'-Wno-sign-compare\',\n                                   \'-Wno-unused-private-field\'])\n    return Extension(ext_package, sources,\n        language=language,\n        include_dirs=include_dirs,\n        extra_compile_args=extra_compile_args)\n\ndef cython_comparator(name, **kwargs):\n    return cython_module(PROJECT_NAME, \'comparators\', \'ext\', name, **kwargs)\n\ndef cython_processor(name, **kwargs):\n    return cython_module(PROJECT_NAME, \'processors\', \'ext\', name, **kwargs)\n\ndef cython_utility(name, **kwargs):\n    return cython_module(PROJECT_NAME, \'utils\', \'ext\', name, **kwargs)\n\ndef additional_source(*args):\n    return os.path.join(\n           os.path.relpath(BASE_PATH, start=CWD), *args)\n\n# PROJECT VERSION & METADATA\n__version__ = ""<undefined>""\ntry:\n    exec(compile(\n        open(os.path.join(BASE_PATH,\n            \'__version__.py\')).read(),\n            \'__version__.py\', \'exec\'))\nexcept:\n    print(""ERROR COMPILING __version__.py"")\n    __version__ = \'0.8.10\'\n\n# PROJECT DESCRIPTION\nLONG_DESCRIPTION = project_content(\'ABOUT.md\')\n\n# SOFTWARE LICENSE\nLICENSE = \'MIT\'\n\n# REQUIRED INSTALLATION DEPENDENCIES\nINSTALL_REQUIRES = project_content(\'requirements\', \'install.txt\').splitlines()\n\n# PYPI PROJECT CLASSIFIERS\nCLASSIFIERS = [\n    \'Development Status :: 5 - Production/Stable\',\n    \'License :: OSI Approved :: MIT License\',\n    \'Intended Audience :: Developers\',\n    \'Operating System :: MacOS\',\n    \'Operating System :: Microsoft :: Windows\',\n    \'Operating System :: OS Independent\',\n    \'Operating System :: POSIX\',\n    \'Operating System :: Unix\',\n    \'Programming Language :: Python\',\n    \'Programming Language :: Python :: 3\',\n    \'Programming Language :: Python :: 3.5\',\n    \'Programming Language :: Python :: 3.6\',\n    \'Programming Language :: Python :: 3.7\']\n\n# NUMPY: C-API INCLUDE DIRECTORY\ntry:\n    import numpy\nexcept ImportError:\n    class FakeNumpy(object):\n        def get_include(self):\n            return os.path.curdir\n    numpy = FakeNumpy()\n\n# SOURCES & INCLUDE DIRECTORIES\nhsluv_source = additional_source(\'utils\', \'ext\', \'hsluv.c\')\naugli_source = additional_source(\'comparators\', \'ext\', \'butteraugli.cc\')\ninclude_dirs = [numpy.get_include(),\n                sysconfig.get_path(\'include\')]\n\n# THE CALL TO `setup(\xe2\x80\xa6)`\nsetup(\n    name=PROJECT_NAME,\n    author=AUTHOR_NAME,\n    author_email=AUTHOR_EMAIL,\n    \n    version=__version__,\n    description=__doc__.strip(),\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=""text/markdown"",\n    \n    keywords="" "".join(KEYWORDS),\n    url=PROJECT_GH_URL, download_url=PROJECT_DL_URL,\n    license=LICENSE, platforms=[\'any\'],\n    classifiers=CLASSIFIERS,\n    \n    packages=find_packages(),\n    package_data={ \'\' : [\'*.*\'] },\n    include_package_data=True,\n    zip_safe=False,\n    \n    install_requires=INSTALL_REQUIRES,\n    include_dirs=include_dirs,\n    \n    ext_modules=cythonize([\n        cython_comparator(""buttereye"",  sources=[augli_source],\n                                        language=""c++""),\n        cython_processor(""halftone"",    include_dirs=include_dirs,\n                                        language=""c""),\n        cython_utility(""api"",           sources=[hsluv_source],\n                                        language=""c"")\n        ], nthreads=cpu_count(),\n           compiler_directives=dict(language_level=3,\n                                    infer_types=True,\n                                    embedsignature=True)),\n)\n'"
instakit/__init__.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#    \n#    INSTAKIT -- Instagrammy image-processors and tools, based on Pillow and SciPy\n#    \n#    Copyright \xc2\xa9 2012-2025 Alexander B\xc3\xb6hn\n#    \n#    Permission is hereby granted, free of charge, to any person obtaining a copy \n#    of this software and associated documentation files (the ""Software""), to deal \n#    in the Software without restriction, including without limitation the rights \n#    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n#    copies of the Software, and to permit persons to whom the Software is \n#    furnished to do so, subject to the following conditions:\n#    \n#    The above copyright notice and this permission notice shall be included in all \n#    copies or substantial portions of the Software.\n#    \n#    THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n#    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n#    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n#    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n#    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n#    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n#    SOFTWARE.\n#\nfrom __future__ import print_function\nfrom os.path import dirname\n\nfrom clu.version import read_version_file, VersionInfo\n\n# module exports:\n__all__ = (\'__version__\', \'version_info\',\n           \'__title__\', \'__author__\', \'__maintainer__\',\n           \'__license__\', \'__copyright__\')\n\n__dir__ = lambda: list(__all__)\n\n# Embedded project metadata:\n__version__ = read_version_file(dirname(__file__))\n__title__ = \'instakit\'\n__author__ = \'Alexander B\xc3\xb6hn\'\n__maintainer__ = __author__\n__license__ = \'MIT\'\n__copyright__ = \'\xc2\xa9 2012-2025 %s\' % __author__\n\n# The CLU project version:\nversion_info = VersionInfo(__version__)\n'"
instakit/__version__.py,0,"b""__version__ = '0.8.10'"""
instakit/exporting.py,0,"b'# -*- coding: utf-8 -*-\nfrom __future__ import print_function\n\nimport os\n\nfrom clu.exporting import ExporterBase\n\n# The \xe2\x80\x9cbasepath\xe2\x80\x9d is the directory enclosing the package root:\nbasepath = os.path.dirname(\n           os.path.dirname(__file__))\n\nclass Exporter(ExporterBase, basepath=basepath, appname=""instakit""):\n    pass\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\nexport(Exporter)\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n'"
tests/__init__.py,0,b''
instakit/abc/__init__.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\n                                                                                \n                        d8888 888888b.    .d8888b.                              \n      o                d88888 888  ""88b  d88P  Y88b                    o        \n     d8b              d88P888 888  .88P  888    888                   d8b       \n    d888b            d88P 888 8888888K.  888        .d8888b          d888b      \n""Y888888888P""       d88P  888 888  ""Y88b 888        88K          ""Y888888888P""  \n  ""Y88888P""        d88P   888 888    888 888    888 ""Y8888b.       ""Y88888P""    \n  d88P""Y88b       d8888888888 888   d88P Y88b  d88P      X88       d88P""Y88b    \n dP""     ""Yb     d88P     888 8888888P""   ""Y8888P""   88888P\'      dP""     ""Yb   \n                                                                                \n                                                                                \nInstakit\xe2\x80\x99s Abstract Base Classes \xe2\x80\x93 n\xc3\xa9e ABCs \xe2\x80\x93 for processors and data structures\n\n""""""\nfrom __future__ import print_function\n\nfrom abc import ABC, abstractmethod\nfrom collections import defaultdict as DefaultDict\nfrom enum import Enum as EnumBase, EnumMeta\n\nfrom clu.abstract import Slotted\nfrom clu.predicates import (getpyattr, isslotted,\n                                       isdictish,\n                                       isslotdicty,\n                                       slots_for,\n                                       predicate_and,\n                                       tuplize)\n\nfrom instakit.exporting import Exporter\n\nabstract = abstractmethod\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\n@export\ndef is_in_class(atx, cls):\n    """""" Test whether or not a class has a named attribute,\n        regardless of whether the class uses `__slots__` or\n        an internal `__dict__`.\n    """"""\n    if hasattr(cls, \'__slots__\'):\n        return atx in cls.__slots__\n    elif hasattr(cls, \'__dict__\'):\n        return atx in cls.__dict__\n    return False\n\n@export\ndef subclasshook(cls, subclass):\n    """""" A subclass hook function for both Processor and Enum """"""\n    if any(is_in_class(\'process\', ancestor) for ancestor in subclass.__mro__):\n        return True\n    return NotImplemented\n\ndef compare_via_slots(self, other):\n    """""" Compare two slotted objects by checking each available slot\n        on each instance\n    """"""\n    if not isslotted(self):\n        return False\n    if not isslotted(other):\n        return False\n    for slot in slots_for(type(self)):\n        if getattr(self, slot) != getattr(other, slot):\n            return False\n    return True\n\ndef compare_via_dicts(self, other):\n    """""" Compare two objects by comparing the contents of their\n        internal __dict__ attributes\n    """"""\n    if not isdictish(self):\n        return False\n    if not isdictish(other):\n        return False\n    return getpyattr(self, \'dict\') == getpyattr(other, \'dict\')\n\ndef compare_via_attrs(self, other):\n    """""" Compare two processors:\n        1) Return NotImplemented if the types do not exactly match.\n        2) For processors using __dict__ mappings for attributes,\n           compare them directly.\n        3) For processors using __slots__ for attributes,\n           iterate through all ancestor slot names using \xe2\x80\x9cslots_for(\xe2\x80\xa6)\xe2\x80\x9d\n           and return False if any compare inequal between self and other --\n           ultimately returning True.\n        4) If the slots/dict situation differs between the two instances,\n           raise a TypeError.\n    """"""\n    if type(self) is not type(other):\n        return NotImplemented\n    \n    # If they both have *both* __slots__ and __dicts__,\n    # delegate to the results of *both* \xe2\x80\x9ccompare_via_slots(\xe2\x80\xa6)\xe2\x80\x9d\n    # and \xe2\x80\x9ccompare_via_dicts(\xe2\x80\xa6)\xe2\x80\x9d:\n    if predicate_and(isslotdicty, self, other):\n        return compare_via_slots(self, other) and \\\n               compare_via_dicts(self, other)\n    \n    # If they both have __slots__, delegate\n    # to \xe2\x80\x9ccompare_via_slots(\xe2\x80\xa6)\xe2\x80\x9d:\n    if predicate_and(isslotted, self, other):\n        return compare_via_slots(self, other)\n    \n    # If they both have __dicts__, delegate\n    # to \xe2\x80\x9ccompare_via_dicts(\xe2\x80\xa6)\xe2\x80\x9d:\n    if predicate_and(isdictish, self, other):\n        return compare_via_dicts(self, other)\n    \n    # Couldn\xe2\x80\x99t match __dict__ and __slots__ attributes,\n    # raise a TypeError:\n    raise TypeError(""dict/slots mismatch"")\n\n@export\nclass Processor(ABC, metaclass=Slotted):\n    \n    """""" Base abstract processor class. """"""\n    \n    @abstract\n    def process(self, image):\n        """""" Process an image instance, per the processor instance,\n            returning the processed image data.\n        """"""\n        ...\n    \n    def __call__(self, image):\n        return self.process(image)\n    \n    @classmethod\n    def __subclasshook__(cls, subclass):\n        return subclasshook(cls, subclass)\n    \n    def __eq__(self, other):\n        """""" Delegate to \xe2\x80\x9ccompare_via_attrs(\xe2\x80\xa6)\xe2\x80\x9d """"""\n        return compare_via_attrs(self, other)\n\nclass SlottedEnumMeta(EnumMeta, metaclass=Slotted):\n    pass\n\n@export\nclass Enum(EnumBase, metaclass=SlottedEnumMeta):\n    \n    """""" Base abstract processor enum. """"""\n    \n    @abstract\n    def process(self, image):\n        """""" Process an image instance, per the processor enum instance,\n            returning the processed image data.\n        """"""\n        ...\n    \n    @classmethod\n    def __subclasshook__(cls, subclass):\n        return subclasshook(cls, subclass)\n\n@export\nclass NOOp(Processor):\n    \n    """""" A no-op processor. """"""\n    \n    def process(self, image):\n        """""" Return the image instance, unchanged """"""\n        return image\n    \n    def __eq__(self, other):\n        """""" Simple type-comparison """"""\n        return type(self) is type(other)\n\n@export\nclass Container(Processor):\n    \n    """""" Base abstract processor container. """"""\n    \n    @classmethod\n    @abstract\n    def base_type(cls):\n        """""" Return the internal type upon which this instakit.abc.Container\n            subclass is based.\n        """"""\n        ...\n    \n    @abstract\n    def iterate(self):\n        """""" Return an ordered iterable of sub-processors. """"""\n        ...\n    \n    @abstract\n    def __len__(self): ...\n    \n    @abstract\n    def __contains__(self, value): ...\n    \n    @abstract\n    def __getitem__(self, idx): ...\n    \n    def __bool__(self):\n        """""" A processor container is considered Truthy if it contains values,\n            and Falsey if it is empty.\n        """"""\n        return len(self) > 0\n    \n    def __eq__(self, other):\n        """""" Compare \xe2\x80\x9cbase_type()\xe2\x80\x9d results and item-by-item through \xe2\x80\x9citerate()\xe2\x80\x9d """"""\n        if type(self).base_type() is not type(other).base_type():\n            return NotImplemented\n        for self_item, other_item in zip(self.iterate(),\n                                         other.iterate()):\n            if self_item != other_item:\n                return False\n        return True\n\n@export\nclass Mapping(Container):\n    \n    @abstract\n    def get(self, idx, default_value): ...\n\n@export\nclass Sequence(Container):\n    \n    @abstract\n    def index(self, value): ...\n    \n    @abstract\n    def last(self): ...\n\n@export\nclass MutableContainer(Container):\n    \n    """""" Base abstract processor mutable container. """"""\n    \n    @abstract\n    def __setitem__(self, idx, value): ...\n    \n    @abstract\n    def __delitem__(self, idx, value): ...\n\n@export\nclass MutableMapping(MutableContainer):\n    \n    @abstract\n    def get(self, idx, default_value): ...\n    \n    @abstract\n    def pop(self, idx, default_value): ...\n    \n    @abstract\n    def update(self, iterable=None, **kwargs): ...\n\n@export\nclass MutableSequence(MutableContainer):\n    \n    @abstract\n    def index(self, value): ...\n    \n    @abstract\n    def last(self): ...\n    \n    @abstract\n    def append(self, value): ...\n    \n    @abstract\n    def extend(self, iterable): ...\n    \n    @abstract\n    def pop(self, idx=-1): ...\n\n@export\nclass Fork(MutableMapping):\n    \n    """""" Base abstract forking processor. """"""\n    __slots__ = (\'dict\', \'__weakref__\')\n    \n    @classmethod\n    def base_type(cls):\n        return DefaultDict\n    \n    def __init__(self, default_factory, *args, **kwargs):\n        """""" The `Fork` ABC implements the same `__init__(\xc2\xac)` call signature as\n            its delegate type, `collections.defaultdict`. A \xe2\x80\x9cdefault_factory\xe2\x80\x9d\n            callable argument is required to fill in missing values (although\n            one can pass None, which will cause a `NOOp` processor to be used).\n            \n            From the `collections.defaultdict` docstring:\n            \n           \xe2\x80\x9cdefaultdict(default_factory[, ...]) --> dict with default factory\xe2\x80\x9d\n            \n           \xe2\x80\x9cThe default factory is called without arguments to produce\n            a new value when a key is not present, in __getitem__ only.\n            A defaultdict compares equal to a dict with the same items.\n            All remaining arguments are treated the same as if they were\n            passed to the dict constructor, including keyword arguments.\xe2\x80\x9d\n        \n        """"""\n        if default_factory in (None, NOOp):\n            default_factory = NOOp\n        if not callable(default_factory):\n            raise AttributeError(""Fork() requires a callable default_factory"")\n        \n        self.dict = type(self).base_type()(default_factory, *args, **kwargs)\n        super(Fork, self).__init__()\n    \n    @property\n    def default_factory(self):\n        """""" The default factory for the dictionary. """"""\n        return self.dict.default_factory\n    \n    @default_factory.setter\n    def default_factory(self, value):\n        if not callable(value):\n            raise AttributeError(""Fork.default_factory requires a callable value"")\n        self.dict.default_factory = value\n    \n    def __len__(self):\n        """""" The number of entries in the dictionary.\n            See defaultdict.__len__(\xe2\x80\xa6) for details.\n        """"""\n        return len(self.dict)\n    \n    def __contains__(self, idx):\n        """""" True if the dictionary has the specified `idx`, else False.\n            See defaultdict.__contains__(\xe2\x80\xa6) for details.\n        """"""\n        return idx in self.dict\n    \n    def __getitem__(self, idx):\n        """""" Get a value from the dictionary, or if no value is present,\n            the return value of `default_factory()`.\n            See defaultdict.__getitem__(\xe2\x80\xa6) for details.\n        """"""\n        return self.dict[idx]\n    \n    def __setitem__(self, idx, value):\n        """""" Set the value in the dictionary corresponding to the specified\n           `idx` to the value passed, or if a value of \xe2\x80\x9cNone\xe2\x80\x9d was passed,\n            set the value to `instakit.abc.NOOp()` -- the no-op processor.\n        """"""\n        if value in (None, NOOp):\n            value = NOOp()\n        self.dict[idx] = value\n    \n    def __delitem__(self, idx):\n        """""" Delete a value from the dictionary corresponding to the specified\n           `idx`, if one is present.\n            See defaultdict.__delitem__(\xe2\x80\xa6) for details.\n        """"""\n        del self.dict[idx]\n    \n    def get(self, idx, default_value=None):\n        """""" Get a value from the dictionary, with an optional default\n            value to use should a value not be present for this `idx`.\n            See defaultdict.get(\xe2\x80\xa6) for details.\n        """"""\n        return self.dict.get(idx, default_value)\n    \n    def pop(self, idx, default_value=None):\n        """""" D.pop(idx[,d]) -> v, remove specified `idx` and return the corresponding value.\n            If `idx` is not found, d is returned if given, otherwise `KeyError` is raised.\n            See defaultdict.pop(\xe2\x80\xa6) for details.\n        """"""\n        return self.dict.pop(idx, default_value)\n    \n    def update(self, iterable=None, **kwargs):\n        """""" Update the dictionary with new key-value pairs.\n            See defaultdict.update(\xe2\x80\xa6) for details.\n        """"""\n        self.dict.update(iterable or tuple(), **kwargs)\n    \n    @abstract\n    def split(self, image): ...\n    \n    @abstract\n    def compose(self, *bands): ...\n\nclass ThresholdProcessor(Processor):\n    \n    """""" Abstract base class for a processor using a uint8_t threshold matrix """"""\n    # This is used in instakit.processors.halftone\n    __slots__ = tuplize(\'threshold_matrix\')\n    \n    LO_TUP = tuplize(0)\n    HI_TUP = tuplize(255)\n    \n    def __init__(self, threshold = 128.0):\n        """""" Initialize with a threshold value between 0 and 255 """"""\n        self.threshold_matrix = int(threshold)  * self.LO_TUP + \\\n                           (256-int(threshold)) * self.HI_TUP\n\n@export\nclass NDProcessorBase(Processor):\n    \n    """""" An image processor ancestor class that represents PIL image\n        data in a `numpy.ndarray`. This is the base abstract class,\n        specifying necessary methods for subclasses to override.\n        \n        Note that \xe2\x80\x9cprocess(\xe2\x80\xa6)\xe2\x80\x9d has NOT been implemented yet in the\n        inheritance chain \xe2\x80\x93 a subclass will need to furnish it.\n    """"""\n    \n    @abstract\n    def process_nd(self, ndimage):\n        """""" Override NDProcessor.process_nd(\xe2\x80\xa6) in subclasses\n            to provide functionality that acts on image data stored\n            in a `numpy.ndarray`.\n        """"""\n        ...\n    \n    @staticmethod\n    @abstract\n    def compand(ndimage): ...\n    \n    @staticmethod\n    @abstract\n    def uncompand(ndimage): ...\n\nexport(abstract)\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n\ndef test():\n    """""" Inline tests for instakit.abc module """"""\n    import os\n    if os.environ.get(\'TM_PYTHON\'):\n        import sys\n        def print_red(text):\n            print(text, file=sys.stderr)\n    else:\n        import colorama, termcolor\n        colorama.init()\n        def print_red(text):\n            print(termcolor.colored(text, color=\'red\'))\n    \n    import __main__\n    print_red(__main__.__doc__)\n    \n    class SlowAtkinson(ThresholdProcessor):\n        def process(self, image):\n            from instakit.utils.mode import Mode\n            image = Mode.L.process(image)\n            for y in range(image.size[1]):\n                for x in range(image.size[0]):\n                    old = image.getpixel((x, y))\n                    new = self.threshold_matrix[old]\n                    err = (old - new) >> 3 # divide by 8.\n                    image.putpixel((x, y), new)\n                    for nxy in [(x+1, y),\n                                (x+2, y),\n                                (x-1, y+1),\n                                (x, y+1),\n                                (x+1, y+1),\n                                (x, y+2)]:\n                        try:\n                            image.putpixel(nxy, int(\n                            image.getpixel(nxy) + err))\n                        except IndexError:\n                            pass\n            return image\n    \n    from pprint import pprint\n    slow_atkinson = SlowAtkinson()\n    pprint(slow_atkinson)\n    print(""DICT?"", hasattr(slow_atkinson, \'__dict__\'))\n    print(""SLOTS?"", hasattr(slow_atkinson, \'__slots__\'))\n    pprint(slow_atkinson.__slots__)\n    pprint(slow_atkinson.__class__.__base__.__slots__)\n    pprint(slots_for(SlowAtkinson))\n    print(""THRESHOLD_MATRIX:"", slow_atkinson.threshold_matrix)\n    assert slow_atkinson == SlowAtkinson()\n    assert NOOp() == NOOp()\n\nif __name__ == \'__main__\':\n    test()\n'"
instakit/comparators/__init__.py,0,b''
instakit/meta/__init__.py,0,b''
instakit/meta/parameters.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\nfrom __future__ import print_function\n\nimport argparse\nimport enum\nimport importlib\nimport inspect\nimport types\n\nfrom pprint import pprint\n\nclass Parameter(object):\n    """""" A placeholder object, used for the moment in the inline tests """"""\n    pass\n\nQUALIFIER = \'.\'\n\ndef dotpath_join(base, *addenda):\n    """""" Join dotpath elements together as one, \xc3\xa1 la os.path.join(\xe2\x80\xa6) """"""\n    for addendum in addenda:\n        if not base.endswith(QUALIFIER):\n            base += QUALIFIER\n        if addendum.startswith(QUALIFIER):\n            if len(addendum) == 1:\n                raise ValueError(\'operand too short: %s\' % addendum)\n            addendum = addendum[1:]\n        base += addendum\n    # N.B. this might be overthinking it -- \n    # maybe we *want* to allow dotpaths\n    # that happen to start and/or end with dots?\n    if base.endswith(QUALIFIER):\n        return base[:-1]\n    return base\n\ndef qualified_import(qualified):\n    """""" Import a qualified thing-name.\n        e.g. \'instakit.processors.halftone.FloydSteinberg\'\n    """"""\n    if QUALIFIER not in qualified:\n        raise ValueError(""qualified_import() needs a qualified name ""\n                         ""(got %s)"" % qualified)\n    head = qualified.split(QUALIFIER)[-1]\n    tail = qualified.replace(""%s%s"" % (QUALIFIER, head), \'\')\n    module = importlib.import_module(tail)\n    cls = getattr(module, head)\n    print(""Qualified Import: %s"" % qualified)\n    return cls\n\ndef qualified_name_tuple(cls):\n    """""" Get the module name and the thing-name for a class.\n        e.g. (\'instakit.processors.halftone\', \'FloydSteinberg\')\n    """"""\n    mod_name = getattr(cls, \'__module__\')\n    cls_name = getattr(cls, \'__qualname__\',\n               getattr(cls, \'__name__\'))\n    return mod_name, cls_name\n\ndef qualified_name(cls):\n    """""" Get a qualified thing-name for a class.\n        e.g. \'instakit.processors.halftone.FloydSteinberg\'\n    """"""\n    mod_name, cls_name = qualified_name_tuple(cls)\n    out = ""%s%s%s"" % (mod_name, QUALIFIER, cls_name)\n    print(""Qualified Name: %s"" % out)\n    return out\n\nclass Nothing(object):\n    """""" Placeholder singleton, signifying nothing """"""\n    __slots__ = tuple()\n    def __new__(cls, *a, **k):\n        return Nothing\n\ndef check_parameter_default(param_default):\n    """""" Filter result values coming from inspect.signature(\xe2\x80\xa6) """"""\n    if param_default == inspect._empty:\n        return Nothing\n    return param_default\n\ndef default_arguments(cls):\n    """""" Get a dictionary of the keyword arguments with provided defaults,\n        as furnished by a given classes\xe2\x80\x99 \xe2\x80\x9c__init__\xe2\x80\x9d function.\n    """"""\n    try:\n        signature = inspect.signature(cls)\n    except (ValueError, TypeError) as exc:\n        m, n = qualified_name_tuple(cls)\n        qn = ""%s%sSlow%s"" % (m.replace(\'ext.\', \'\'), QUALIFIER, n) # WTF HAX\n        NonCythonCls = qualified_import(qn)\n        if qualified_name(NonCythonCls) != qualified_name(cls):\n            return default_arguments(NonCythonCls)\n        else:\n            raise exc\n    if len(signature.parameters) < 1:\n        return {}\n    return { parameter.name : check_parameter_default(parameter.default) \\\n                                for parameter \\\n                                in signature.parameters.values() }\n\ndef is_enum(cls):\n    """""" Predicate function to ascertain whether a class is an Enum. """"""\n    return enum.Enum in cls.__mro__\n\ndef enum_choices(cls):\n    """""" Return a list of the names of the given Enum class members. """"""\n    return [choice.name for choice in cls]\n\nFILE_ARGUMENT_NAMES = (\'path\', \'pth\', \'file\')\n\ndef add_argparser(subparsers, cls):\n    """""" Add a subparser -- an instance of \xe2\x80\x9cargparse.ArgumentParser\xe2\x80\x9d --\n        with arguments and defaults matching the keyword arguments and\n        defaults provided by the given class (q.v. \xe2\x80\x9cdefault_arguments(\xe2\x80\xa6)\xe2\x80\x9d\n        definition supra.)\n    """"""\n    qualname = qualified_name(cls)\n    cls_help = getattr(cls, \'__doc__\', None) or ""help for %s"" % qualname\n    parser = subparsers.add_parser(qualname, help=cls_help)\n    if is_enum(cls): # Deal with enums\n        argument_name = cls.__name__.lower()\n        add_argument_args = dict(choices=enum_choices(cls),\n                                 type=str,\n                                 help=\'help for enum %s\' % argument_name)\n        parser.add_argument(argument_name,\n                          **add_argument_args)\n    else: # Deal with __init__ signature\n        for argument_name, argument_value in default_arguments(cls).items():\n            argument_type = type(argument_value)\n            argument_required = False\n            add_argument_args = dict(help=\'help for argument %s\' % argument_name)\n            if argument_value is not Nothing:\n                add_argument_args.update({ \'default\' : argument_value })\n            else:\n                add_argument_args.update({ \'type\' : argument_name in FILE_ARGUMENT_NAMES \\\n                                                and argparse.FileType(\'rb\') \\\n                                                 or str })\n                argument_required = True\n            if argument_type is bool:\n                add_argument_args.update({ \'action\' : \'store_true\' })\n            elif argument_type is type(None):\n                add_argument_args.update({ \'type\' : str })\n            elif is_enum(argument_type):\n                add_argument_args.update({ \'choices\' : enum_choices(argument_type),\n                                              \'type\' : str })\n            argument_template = argument_required and \'%s\' or \'--%s\'\n            parser.add_argument(argument_template % argument_name,\n                              **add_argument_args)\n    return parser\n\nfunctype = types.FunctionType\n\ndef get_processors_from(module_name):\n    """""" Memoized processor-extraction function """"""\n    from instakit.utils.static import asset\n    if not hasattr(get_processors_from, \'cache\'):\n        get_processors_from.cache = {}\n    if module_name not in get_processors_from.cache:\n        processors = []\n        module = importlib.import_module(module_name)\n        print(""Module: %s (%s)"" % (module.__name__,\n                    asset.relative(module.__file__)))\n        for thing in (getattr(module, name) for name in dir(module)):\n            if hasattr(thing, \'process\'):\n                print(""Found thing: %s"" % thing)\n                if module.__name__ in thing.__module__:\n                    if thing not in processors:\n                        if type(getattr(thing, \'process\')) is functype:\n                            processors.append(thing)\n        get_processors_from.cache[module_name] = tuple(processors)\n    return get_processors_from.cache[module_name] \n\n\ndef test():\n    \n    # Test \xe2\x80\x9cqualified_import()\xe2\x80\x9d:\n    print(""Testing \xe2\x80\x9cqualified_import()\xe2\x80\x9d\xe2\x80\xa6"")\n    \n    class_name = \'instakit.processors.halftone.SlowFloydSteinberg\'\n    ImportedFloydSteinberg = qualified_import(class_name)\n    assert ImportedFloydSteinberg.__name__ == \'SlowFloydSteinberg\'\n    assert ImportedFloydSteinberg.__qualname__ == \'SlowFloydSteinberg\'\n    assert ImportedFloydSteinberg.__module__ == \'instakit.processors.halftone\'\n    \n    class_name = \'instakit.processors.halftone.Atkinson\' # TWIST!!\n    ImportedAtkinson = qualified_import(class_name)\n    assert ImportedAtkinson.__name__ == \'Atkinson\'\n    assert ImportedAtkinson.__qualname__ == \'Atkinson\'\n    assert ImportedAtkinson.__module__ == \'instakit.processors.ext.halftone\'\n    \n    print(""Success!"")\n    print()\n    \n    # Test \xe2\x80\x9cqualified_name()\xe2\x80\x9d:\n    print(""Testing \xe2\x80\x9cqualified_name()\xe2\x80\x9d\xe2\x80\xa6"")\n    \n    class_name = qualified_name(Parameter)\n    assert class_name == \'__main__.Parameter\'\n    \n    class_name = qualified_name(ImportedFloydSteinberg)\n    assert class_name == \'instakit.processors.halftone.SlowFloydSteinberg\'\n    \n    class_name = qualified_name(ImportedAtkinson)\n    assert class_name == \'instakit.processors.ext.halftone.Atkinson\'\n    \n    print(""Success!"")\n    print()\n    \n    # Test \xe2\x80\x9cNothing\xe2\x80\x9d:\n    print(""Testing \xe2\x80\x9cNothing\xe2\x80\x9d\xe2\x80\xa6"")\n    \n    assert type(Nothing) == type\n    assert Nothing() == Nothing\n    \n    print(""Success!"")\n    print()\n    \n    # Test \xe2\x80\x9cdefault_arguments()\xe2\x80\x9d:\n    print(""Testing \xe2\x80\x9cdefault_arguments()\xe2\x80\x9d\xe2\x80\xa6"")\n    \n    default_args = default_arguments(ImportedFloydSteinberg)\n    assert default_args == dict(threshold=128.0)\n    \n    slow_atkinson = \'instakit.processors.halftone.SlowAtkinson\'\n    default_args = default_arguments(qualified_import(slow_atkinson))\n    assert default_args == dict(threshold=128.0)\n    \n    noise = \'instakit.processors.noise.GaussianNoise\'\n    default_args = default_arguments(qualified_import(noise))\n    assert default_args == dict()\n    \n    contrast = \'instakit.processors.adjust.Contrast\'\n    default_args = default_arguments(qualified_import(contrast))\n    assert default_args == dict(value=1.0)\n    \n    unsharp_mask = \'instakit.processors.blur.UnsharpMask\'\n    default_args = default_arguments(qualified_import(unsharp_mask))\n    assert default_args == dict(radius=2,\n                                percent=150,\n                                threshold=3)\n    \n    curves = \'instakit.processors.curves\'\n    curveset = dotpath_join(curves, \'CurveSet\')\n    interpolate_mode = dotpath_join(curves, \'InterpolateMode\')\n    ImportedInterpolateMode = qualified_import(interpolate_mode)\n    default_args = default_arguments(qualified_import(curveset))\n    LAGRANGE = ImportedInterpolateMode.LAGRANGE\n    assert default_args == dict(path=Nothing,\n                                interpolation_mode=LAGRANGE)\n    \n    print(""Success!"")\n    print()\n    \n    # Test \xe2\x80\x9cis_enum()\xe2\x80\x9d:\n    print(""Testing \xe2\x80\x9cis_enum()\xe2\x80\x9d\xe2\x80\xa6"")\n    \n    assert is_enum(ImportedInterpolateMode)\n    assert not is_enum(Parameter)\n    assert not is_enum(ImportedFloydSteinberg)\n    assert not is_enum(ImportedAtkinson)\n    \n    mode = \'instakit.utils.mode.Mode\'\n    assert is_enum(qualified_import(mode))\n    \n    interpolate_mode = \'instakit.processors.curves.InterpolateMode\'\n    assert is_enum(qualified_import(interpolate_mode))\n    \n    noise_mode = \'instakit.processors.noise.NoiseMode\'\n    assert is_enum(qualified_import(noise_mode))\n    \n    print(""Success!"")\n    print()\n    \n    # Test \xe2\x80\x9cadd_argparser()\xe2\x80\x9d:\n    print(""Testing \xe2\x80\x9cadd_argparser()\xe2\x80\x9d\xe2\x80\xa6"")\n    \n    parser = argparse.ArgumentParser(prog=\'instaprocess\',\n                                     formatter_class=argparse.RawDescriptionHelpFormatter)\n    \n    parser.add_argument(\'--verbose\', \'-v\',\n                        action=\'store_true\',\n                        help=""print verbose messages to STDOUT"")\n    \n    processor_names = (\'adjust\', \'blur\', \'curves\', \'halftone\', \'noise\', \'squarecrop\')\n    utility_names = (\'colortype\', \'gcr\', \'kernels\', \'lutmap\',\n                     \'misc\', \'mode\', \'ndarrays\', \'pipeline\', \'static\', \'stats\')\n    \n    module_names = []\n    module_names.extend([\'instakit.processors.%s\' % name for name in processor_names])\n    module_names.extend([\'instakit.utils.%s\' % name for name in utility_names])\n    \n    processors = {}\n    \n    for module_name in module_names:\n        processors[module_name] = get_processors_from(module_name)\n    \n    subparsers = parser.add_subparsers(help=""subcommands for instakit processors"")\n    for processor_tuple in processors.values():\n        for processor in processor_tuple:\n            add_argparser(subparsers, processor)\n    \n    pprint(processors, indent=4)\n    \n    print()\n    ns = parser.parse_args([\'-h\'])\n    print(ns)\n    \n    print()\n    ns = parser.parse_args([\'instakit.utils.mode.Mode\', \'--help\'])\n    print(ns)\n    \n    print(""Success!"")\n    print()\n\n\nif __name__ == \'__main__\':\n    test()'"
instakit/processors/__init__.py,0,b''
instakit/processors/adjust.py,0,"b'# encoding: utf-8\nfrom __future__ import print_function\n\nfrom PIL import ImageOps, ImageChops, ImageEnhance as enhancers\nfrom clu.abstract import Slotted\nfrom clu.predicates import tuplize\nfrom instakit.abc import abstract, ABC, Processor\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\n@export\nclass EnhanceNop(ABC, metaclass=Slotted):\n    \n    __slots__ = tuplize(\'image\')\n    \n    def __init__(self, image=None):\n        self.image = image\n    \n    def adjust(self, *args, **kwargs):\n        return self.image\n\n@export\nclass Adjustment(Processor):\n    \n    """""" Base type for image adjustment processors """"""\n    __slots__ = tuplize(\'value\')\n    \n    def __init__(self, value=1.0):\n        """""" Initialize the adjustment with a float value """"""\n        self.value = value\n    \n    @abstract\n    def adjust(self, image):\n        """""" Adjust the image, using the float value with which\n            the adjustment was first initialized\n        """"""\n        ...\n    \n    def process(self, image):\n        return (self.value == 1.0) and image or self.adjust(image)\n\n@export\nclass Color(Adjustment):\n    \n    """""" Globally tweak the image color """"""\n    \n    def adjust(self, image):\n        return enhancers.Color(image).enhance(self.value)\n\n@export\nclass Brightness(Adjustment):\n    \n    """""" Adjust the image brightness """"""\n    \n    def adjust(self, image):\n        return enhancers.Brightness(image).enhance(self.value)\n\n@export\nclass Contrast(Adjustment):\n    \n    """""" Adjust the image contrast """"""\n    \n    def adjust(self, image):\n        return enhancers.Contrast(image).enhance(self.value)\n\n@export\nclass Sharpness(Adjustment):\n    \n    """""" Adjust the sharpness of the image """"""\n    \n    def adjust(self, image):\n        return enhancers.Sharpness(image).enhance(self.value)\n\n@export\nclass BrightnessContrast(Adjustment):\n    \n    """""" Adjust the image brightness and contrast simultaneously """"""\n    \n    def adjust(self, image):\n        for Enhancement in (enhancers.Brightness, enhancers.Contrast):\n            image = Enhancement(image).enhance(self.value)\n        return image\n\n@export\nclass BrightnessSharpness(Adjustment):\n    \n    """""" Adjust the image brightness and sharpness simultaneously """"""\n    \n    def adjust(self, image):\n        for Enhancement in (enhancers.Brightness, enhancers.Sharpness):\n            image = Enhancement(image).enhance(self.value)\n        return image\n\n@export\nclass ContrastSharpness(Adjustment):\n    \n    """""" Adjust the image contrast and sharpness simultaneously """"""\n    \n    def adjust(self, image):\n        for Enhancement in (enhancers.Contrast, enhancers.Sharpness):\n            image = Enhancement(image).enhance(self.value)\n        return image\n\n@export\nclass Invert(Processor):\n    \n    """""" Perform a simple inversion of the image values """"""\n    \n    def process(self, image):\n        return ImageChops.invert(image)\n\n@export\nclass Equalize(Processor):\n    \n    """""" Apply a non-linear mapping to the image, via histogram """"""\n    __slots__ = tuplize(\'mask\')\n    \n    def __init__(self, mask=None):\n        self.mask = hasattr(mask, \'copy\') and mask.copy() or mask\n    \n    def process(self, image):\n        return ImageOps.equalize(image, mask=self.mask)\n\n@export\nclass AutoContrast(Processor):\n    \n    """""" Normalize contrast throughout the image, via histogram """"""\n    __slots__ = tuplize(\'cutoff\', \'ignore\')\n    \n    def __init__(self, cutoff=0, ignore=None):\n        self.cutoff, self.ignore = cutoff, ignore\n    \n    def process(self, image):\n        return ImageOps.autocontrast(image, cutoff=self.cutoff,\n                                            ignore=self.ignore)\n\n@export\nclass Solarize(Processor):\n    \n    """""" Invert all pixel values above an 8-bit threshold """"""\n    __slots__ = tuplize(\'threshold\')\n    \n    def __init__(self, threshold=128):\n        self.threshold = min(max(1, threshold), 255)\n    \n    def process(self, image):\n        return ImageOps.solarize(image, threshold=self.threshold)\n\n@export\nclass Posterize(Processor):\n    \n    """""" Reduce the number of bits (1 to 8) per channel """"""\n    __slots__ = tuplize(\'bits\')\n    \n    def __init__(self, bits=4):\n        self.bits = min(max(1, bits), 8)\n    \n    def process(self, image):\n        return ImageOps.posterize(image, bits=self.bits)\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n\ndef test():\n    # from clu.predicates import haspyattr\n    from clu.predicates import isslotted\n    \n    G = globals()\n    \n    for typename in __all__:\n        if typename != ""Adjustment"":\n            assert G[typename]\n            assert isslotted(G[typename]())\n            # assert not isdictish(G[typename]())\n            # assert not haspyattr(G[typename](), \'dict\')\n\nif __name__ == \'__main__\':\n    test()'"
instakit/processors/blur.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\nblur.py\n\nCreated by FI$H 2000 on 2012-08-23.\nCopyright (c) 2012 Objects In Space And Time, LLC. All rights reserved.\n""""""\nfrom __future__ import print_function\n\nfrom PIL import ImageFilter\nfrom instakit.abc import Processor\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\n@export\nclass ImagingCoreFilterMixin(Processor):\n    """""" A mixin furnishing a `process(\xe2\x80\xa6)` method to PIL.ImageFilter classes """"""\n    \n    def process(self, image):\n        return image.filter(self)\n\n@export\nclass Contour(ImageFilter.CONTOUR, ImagingCoreFilterMixin):\n    """""" Contour-Enhance Filter """"""\n    pass\n\n@export\nclass Detail(ImageFilter.DETAIL, ImagingCoreFilterMixin):\n    """""" Detail-Enhance Filter """"""\n    pass\n\n@export\nclass Emboss(ImageFilter.EMBOSS, ImagingCoreFilterMixin):\n    """""" Emboss-Effect Filter """"""\n    pass\n\n@export\nclass FindEdges(ImageFilter.FIND_EDGES, ImagingCoreFilterMixin):\n    """""" Edge-Finder Filter """"""\n    pass\n\n@export\nclass EdgeEnhance(ImageFilter.EDGE_ENHANCE, ImagingCoreFilterMixin):\n    """""" Edge-Enhance Filter """"""\n    pass\n\n@export\nclass EdgeEnhanceMore(ImageFilter.EDGE_ENHANCE_MORE, ImagingCoreFilterMixin):\n    """""" Edge-Enhance (With Extreme Predjudice) Filter """"""\n    pass\n\n@export\nclass Smooth(ImageFilter.SMOOTH, ImagingCoreFilterMixin):\n    """""" Image-Smoothing Filter """"""\n    pass\n\n@export\nclass SmoothMore(ImageFilter.SMOOTH_MORE, ImagingCoreFilterMixin):\n    """""" Image-Smoothing (With Extreme Prejudice) Filter """"""\n    pass\n\n@export\nclass Sharpen(ImageFilter.SHARPEN, ImagingCoreFilterMixin):\n    """""" Image Sharpener """"""\n    pass\n\n@export\nclass UnsharpMask(ImageFilter.UnsharpMask, ImagingCoreFilterMixin):\n    """""" Unsharp Mask Filter \n        Optionally initialize with params:\n            radius (2), percent (150), threshold (3) """"""\n    pass\n\n@export\nclass SimpleGaussianBlur(ImageFilter.GaussianBlur, ImagingCoreFilterMixin):\n    """""" Simple Gaussian Blur Filter \n        Optionally initialize with radius (2) """"""\n    pass\n\n@export\nclass GaussianBlur(Processor):\n    """""" Gaussian Blur Filter \n        Optionally initialize with params:\n            sigmaX (3)\n            sigmaY (3; same as sigmaX)\n            sigmaZ (0; same as sigmaX)\n    """"""\n    __slots__ = (\'sigmaX\', \'sigmaY\', \'sigmaZ\')\n    \n    def __init__(self, sigmaX=3, sigmaY=None, sigmaZ=None):\n        self.sigmaX = sigmaX\n        self.sigmaY = sigmaY or sigmaX\n        self.sigmaZ = sigmaZ or sigmaX\n    \n    def process(self, image):\n        from PIL import Image\n        from numpy import array\n        from instakit.utils import kernels\n        return Image.fromarray(kernels.gaussian_blur_filter(\n                                input=array(image),\n                               sigmaX=self.sigmaX,\n                               sigmaY=self.sigmaY,\n                               sigmaZ=self.sigmaZ))\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n\ndef test():\n    from instakit.utils.static import asset\n    from instakit.utils.mode import Mode\n    from clu.predicates import isslotted\n    \n    image_paths = list(map(\n        lambda image_file: asset.path(\'img\', image_file),\n            asset.listfiles(\'img\')))\n    image_inputs = list(map(\n        lambda image_path: Mode.RGB.open(image_path),\n            image_paths))\n    \n    processors = (Contour(),\n                  Detail(),\n                  Emboss(),\n                  EdgeEnhance(),\n                  EdgeEnhanceMore(),\n                  FindEdges(),\n                  Smooth(),\n                  SmoothMore(),\n                  Sharpen(),\n                  UnsharpMask(),\n                  GaussianBlur(sigmaX=3),\n                  SimpleGaussianBlur(radius=3))\n    \n    for processor in processors:\n        assert isslotted(processor)\n    \n    for image_input in image_inputs:\n        # image_input.show()\n        # for processor in processors:\n        #     processor.process(image_input).show()\n        \n        # image_input.show()\n        # Contour().process(image_input).show()\n        # Detail().process(image_input).show()\n        # Emboss().process(image_input).show()\n        # EdgeEnhance().process(image_input).show()\n        # EdgeEnhanceMore().process(image_input).show()\n        # FindEdges().process(image_input).show()\n        # Smooth().process(image_input).show()\n        # SmoothMore().process(image_input).show()\n        # Sharpen().process(image_input).show()\n        # UnsharpMask().process(image_input).show()\n        GaussianBlur(sigmaX=3).process(image_input).show()\n        # SimpleGaussianBlur(radius=3).process(image_input).show()\n    \n    print(image_paths)\n    \nif __name__ == \'__main__\':\n    test()'"
instakit/processors/curves.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\ncurves.py\n\nAdapted from this:\n\n    https://gist.github.com/fish2000/5641c3697fa4407fcfd59099575d6938\n\nAnd also this:\n\n    https://github.com/vbalnt/filterizer/blob/master/extractCurvesFromACVFile.py\n\nCreated by FI$H 2000 on 2012-08-23.\nCopyright (c) 2012-2019 Objects In Space And Time, LLC. All rights reserved.\n\n""""""\nfrom __future__ import print_function\n\nimport numpy\nimport os\nimport struct\n\nfrom PIL import Image\nfrom enum import Enum, unique\nfrom scipy import interpolate\n\nfrom clu.predicates import pyname\nfrom instakit.utils.static import asset\nfrom instakit.utils.mode import Mode\nfrom instakit.abc import Processor\n\ninterpolate_mode_strings = (\'linear\',\n                            \'nearest\',\n                            \'zero\',\n                            \'slinear\',\n                            \'quadratic\', \'cubic\',\n                            \'previous\', \'next\',\n                            \'lagrange\')\n\n@unique\nclass InterpolateMode(Enum):\n    \n    # These correspond to the \xe2\x80\x9ckind\xe2\x80\x9d arg\n    # from \xe2\x80\x9cscipy.interpolate.interp1d(\xe2\x80\xa6)\xe2\x80\x9d:\n    LINEAR = 0\n    NEAREST = 1\n    ZERO = 2\n    SLINEAR = 3\n    QUADRATIC = 4\n    CUBIC = 5\n    PREVIOUS = 6\n    NEXT = 7\n    \n    # This specifies LaGrange interpolation,\n    # using \xe2\x80\x9cscipy.interpolate.lagrange(\xe2\x80\xa6)\xe2\x80\x9d:\n    LAGRANGE = 8\n    \n    def to_string(self):\n        return interpolate_mode_strings[self.value]\n    \n    def __str__(self):\n        return self.to_string()\n\nclass SingleCurve(list):\n    \n    """""" A SingleCurve instance is a named list of (x, y) coordinates,\n        that provides programmatic access to interpolated values.\n        \n        It is constructed with `(name, [(x, y), (x, y)...])`; since it\n        directly inherits from `__builtins__.list`, the usual methods\n        e.g. `append(\xe2\x80\xa6)`, `insert(\xe2\x80\xa6)` &c. can be used to modify an\n        instance of SingleCurve.\n        \n        Before accessing interpolated values, one first calls the\n        method `interpolate(\xe2\x80\xa6)` with an optional argument specifying\n        the interpolation mode, `mode=InterpolationMode` (q.v. the\n        `InterpolationMode` enum supra.) and thereafter, instances\n        of SingleCurve are callable with an x-coordinate argument,\n        returning the interpolated y-coordinate.\n    """"""\n    \n    def __init__(self, name, *args):\n        self.name = name\n        list.__init__(self, *args)\n    \n    def asarray(self, dtype=None):\n        return numpy.array(self, dtype=dtype)\n    \n    def interpolate(self, mode=InterpolateMode.LAGRANGE):\n        xy = self.asarray()\n        if mode == InterpolateMode.LAGRANGE or mode is None:\n            delegate = interpolate.lagrange(xy.T[0],\n                                            xy.T[1])\n        else:\n            kind = InterpolateMode(mode).to_string()\n            delegate = interpolate.interp1d(xy.T[0],\n                                            xy.T[1], kind=kind)\n        self.delegate = delegate\n        return self\n    \n    def __call__(self, value):\n        if not hasattr(self, \'delegate\'):\n            self.interpolate()\n        delegate = self.delegate\n        return delegate(value)\n\n\nclass CurveSet(Processor):\n    \n    """""" A CurveSet instance represents an ACV file, as generated by the\n        Adobe\xc2\xae Photoshop\xe2\x84\xa2 application, whose data encodes a set of\n        image-adjustment curves.\n        \n        The simplest use is to read an existing set of curves from an\n        existant ACV file; one instantiates a CurveSet like so:\n        \n            mycurveset = CurveSet(\'path/to/curveset.acv\')\n        \n        \xe2\x80\xa6one can then use `mycurveset.process(\xe2\x80\xa6)` to process PIL images,\n        or one can access underlying curve data via `mycurveset.curves`;\n        subsequently the curveset can be rewritten to a new ACV file\n        with `mycurveset.write_acv(acv_file_path)`.\n    """"""\n    __slots__ = (\'_is_builtin\', \'count\', \'curves\',\n                                \'path\',  \'name\',\n                                \'interpolation_mode\')\n    \n    acv = \'acv\'\n    dotacv = f\'.{acv}\'\n    channels = (\'composite\', \'red\', \'green\', \'blue\')\n    valid_modes = ( Mode.RGB, Mode.MONO, Mode.L )\n    \n    @classmethod\n    def builtin(cls, name):\n        print(f""Reading curves [builtin] {name}{cls.dotacv}"")\n        acv_path = asset.path(cls.acv, f""{name}{cls.dotacv}"")\n        out = cls(acv_path)\n        out._is_builtin = True\n        return out\n    \n    @classmethod\n    def instakit_names(cls):\n        return [curve_file.rstrip(cls.dotacv) \\\n            for curve_file in asset.listfiles(cls.acv) \\\n            if curve_file.lower().endswith(cls.dotacv)]\n    \n    @classmethod\n    def instakit_curve_sets(cls):\n        return [cls.builtin(name) for name in cls.instakit_names()]\n    \n    @classmethod\n    def channel_name(cls, idx):\n        try:\n            return cls.channels[idx]\n        except IndexError:\n            return f""channel{idx}""\n    \n    def __init__(self, path, interpolation_mode=InterpolateMode.LAGRANGE):\n        self.count = 0\n        self.curves = []\n        self._is_builtin = False\n        self.path = os.path.abspath(path)\n        self.name = os.path.basename(path)\n        self.interpolation_mode = interpolation_mode\n        if os.path.isfile(self.path):\n            self.read_acv(self.path,\n                          self.interpolation_mode)\n    \n    @property\n    def is_builtin(self):\n        return self._is_builtin\n    \n    @property\n    def file_exists(self):\n        return os.path.isfile(self.path)\n    \n    @staticmethod\n    def read_one_curve(acv_file, name, interpolation_mode):\n        curve = SingleCurve(name)\n        points_in_curve, = struct.unpack(""!h"", acv_file.read(2))\n        for _ in range(points_in_curve):\n            y, x = struct.unpack(""!hh"", acv_file.read(4))\n            curve.append((x, y))\n        return curve.interpolate(interpolation_mode)\n    \n    @staticmethod\n    def write_one_curve(acv_file, curve):\n        points_in_curve = len(curve)\n        acv_file.write(struct.pack(""!h"", points_in_curve))\n        for idx in range(points_in_curve):\n            x, y = curve[idx]\n            acv_file.write(struct.pack(""!hh"", y, x))\n        return points_in_curve\n    \n    def read_acv(self, acv_path, interpolation_mode):\n        if not self.file_exists:\n            raise IOError(f""Can\'t read nonexistant ACV file: {self.path}"")\n        with open(acv_path, ""rb"") as acv_file:\n            _, self.count = struct.unpack(""!hh"", acv_file.read(4))\n            for idx in range(self.count):\n                self.curves.append(\n                    self.read_one_curve(acv_file,\n                                   type(self).channel_name(idx),\n                                        interpolation_mode))\n    \n    def write_acv(self, acv_path):\n        if self.count < 1:\n            raise ValueError(""Can\'t write empty curveset as ACV data"")\n        with open(acv_path, ""wb"") as acv_file:\n            acv_file.write(struct.pack(""!hh"", 0, self.count))\n            for curve in self.curves:\n                self.write_one_curve(acv_file, curve)\n    \n    def process(self, image):\n        mode = Mode.of(image)\n        if mode not in type(self).valid_modes:\n            image = Mode.RGB.process(image)\n        elif mode is not Mode.RGB:\n            return Image.eval(Mode.L.process(image),\n                              self.curves[0])\n        # The image to be RGB-modes at this point:\n        adjusted_bands = []\n        for idx, band in enumerate(image.split()):\n            adjusted_bands.append(\n                Image.eval(band,\n                           lambda v: self.curves[idx+1](v)))\n        return Mode.RGB.merge(*adjusted_bands)\n    \n    def add(self, curve):\n        self.curves.append(curve)\n        self.count = len(self.curves)\n    \n    def __repr__(self):\n        cls_name = pyname(type(self))\n        address = id(self)\n        label = self.is_builtin and \'[builtin]\' or self.name\n        interp = self.interpolation_mode or InterpolateMode.LAGRANGE\n        parenthetical = f""{label}, {self.count}, {interp}""\n        return f""{cls_name}({parenthetical}) @ <{address}>""\n\ndef test():\n    curve_sets = CurveSet.instakit_curve_sets()\n    \n    image_paths = list(map(\n        lambda image_file: asset.path(\'img\', image_file),\n            asset.listfiles(\'img\')))\n    image_inputs = list(map(\n        lambda image_path: Mode.RGB.open(image_path),\n            image_paths))\n    \n    for image_input in image_inputs[:1]:\n        image_input.show()\n        for curve_set in curve_sets:\n            curve_set.process(image_input).show()\n    \n    print(curve_sets)\n    print(image_paths)\n    \n    import tempfile\n    temppath = tempfile.mktemp(suffix=\'.acv\')\n    assert not CurveSet(path=temppath).file_exists\n    \nif __name__ == \'__main__\':\n    test()'"
instakit/processors/halftone.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\nhalftone.py\n\nCreated by FI$H 2000 on 2012-08-23.\nCopyright (c) 2012 Objects In Space And Time, LLC. All rights reserved.\n""""""\nfrom __future__ import print_function\n\nfrom PIL import ImageDraw\n\nfrom instakit.utils import pipeline, gcr\nfrom instakit.utils.mode import Mode\nfrom instakit.utils.stats import histogram_mean\nfrom instakit.abc import Processor, ThresholdProcessor\n\nclass SlowAtkinson(ThresholdProcessor):\n    \n    """""" It\xe2\x80\x99s not a joke, this processor is slow as fuck;\n        if at all possible, use the cythonized version instead\n        (q.v. instakit.processors.ext.Atkinson) and never ever\n        use this one if at all possible \xe2\x80\x93 unless, like, you\xe2\x80\x99re\n        being paid by the hour or somesuch. Up to you dogg.\n    """"""\n    __slots__ = tuple()\n    \n    def process(self, image):\n        """""" The process call returns a monochrome (\'L\'-mode) image """"""\n        image = Mode.L.process(image)\n        for y in range(image.size[1]):\n            for x in range(image.size[0]):\n                old = image.getpixel((x, y))\n                new = self.threshold_matrix[old]\n                err = (old - new) >> 3 # divide by 8.\n                image.putpixel((x, y), new)\n                for nxy in [(x+1, y),\n                            (x+2, y),\n                            (x-1, y+1),\n                            (x, y+1),\n                            (x+1, y+1),\n                            (x, y+2)]:\n                    try:\n                        image.putpixel(nxy, int(\n                        image.getpixel(nxy) + err))\n                    except IndexError:\n                        pass # it happens, evidently.\n        return image\n\nclass SlowFloydSteinberg(ThresholdProcessor):\n    \n    """""" A similarly super-slow reference implementation of Floyd-Steinberg.\n        Adapted from an RGB version here: https://github.com/trimailov/qwer\n    """"""\n    __slots__ = tuple()\n    \n    # Precalculate fractional error multipliers:\n    SEVEN_FRAC = 7/16\n    THREE_FRAC = 3/16\n    CINCO_FRAC = 5/16\n    ALONE_FRAC = 1/16\n    \n    def process(self, image):\n        """""" The process call returns a monochrome (\'L\'-mode) image """"""\n        # N.B. We store local references to the fractional error multipliers\n        # to avoid the Python internal-dict-stuff member-lookup overhead:\n        image = Mode.L.process(image)\n        SEVEN_FRAC = type(self).SEVEN_FRAC\n        THREE_FRAC = type(self).THREE_FRAC\n        CINCO_FRAC = type(self).CINCO_FRAC\n        ALONE_FRAC = type(self).ALONE_FRAC\n        for y in range(image.size[1]):\n            for x in range(image.size[0]):\n                old = image.getpixel((x, y))\n                new = self.threshold_matrix[old]\n                image.putpixel((x, y), new)\n                err = old - new\n                for nxy in [((x+1, y),      SEVEN_FRAC),\n                            ((x-1, y+1),    THREE_FRAC),\n                            ((x, y+1),      CINCO_FRAC),\n                            ((x+1, y+1),    ALONE_FRAC)]:\n                    try:\n                        image.putpixel(nxy[0], int(\n                        image.getpixel(nxy[0]) + err * nxy[1]))\n                    except IndexError:\n                        pass # it happens, evidently.\n        return image\n\n# Register the stub as a instakit.abc.Processor \xe2\x80\x9cvirtual subclass\xe2\x80\x9d:\n@Processor.register\nclass Problematic(object):\n    def __init__(self):\n        raise TypeError(""Fast-math version couldn\'t be imported"")\n\ntry:\n    # My man, fast Bill Atkinson\n    from instakit.processors.ext.halftone import Atkinson as FastAtkinson\nexcept ImportError:\n    Atkinson = SlowAtkinson\n    FastAtkinson = Problematic\nelse:\n    # Register the Cythonized processor with the ABC:\n    Atkinson = Processor.register(FastAtkinson)\n\ntry:\n    # THE FLOYDSTER\n    from instakit.processors.ext.halftone import FloydSteinberg as FastFloydSteinberg\nexcept ImportError:\n    FloydSteinberg = SlowFloydSteinberg\n    FastFloydSteinberg = Problematic\nelse:\n    # Register the Cythonized processor with the ABC:\n    FloydSteinberg = Processor.register(FastFloydSteinberg)\n\nclass CMYKAtkinson(Processor):\n    \n    """""" Create a full-color CMYK Atkinson-dithered halftone, with gray-component\n        replacement (GCR) at a specified percentage level\n    """"""\n    __slots__ = (\'gcr\', \'overprinter\')\n    \n    def __init__(self, gcr=20):\n        self.gcr = max(min(100, gcr), 0)\n        self.overprinter = pipeline.BandFork(Atkinson, mode=\'CMYK\')\n    \n    def process(self, image):\n        return pipeline.Pipe(gcr.BasicGCR(self.gcr),\n                                          self.overprinter).process(image)\n\nclass CMYKFloydsterBill(Processor):\n    \n    """""" Create a full-color CMYK Atkinson-dithered halftone, with gray-component\n        replacement (GCR) and OH SHIT SON WHAT IS THAT ON THE CYAN CHANNEL DOGG\n    """"""\n    __slots__ = (\'gcr\', \'overprinter\')\n    \n    def __init__(self, gcr=20):\n        self.gcr = max(min(100, gcr), 0)\n        self.overprinter = pipeline.BandFork(Atkinson, mode=\'CMYK\')\n        self.overprinter.update({ \'C\' : SlowFloydSteinberg() })\n    \n    def process(self, image):\n        return pipeline.Pipe(gcr.BasicGCR(self.gcr),\n                                          self.overprinter).process(image)\n\nclass DotScreen(Processor):\n    \n    """""" This processor creates a monochrome dot-screen halftone pattern\n        from an image. While this may be useful on its own, it is far\n        more useful when used across all channels of a CMYK image in\n        a BandFork or OverprintFork processor operation (q.v. sources\n        of `instakit.utils.pipeline.BandFork` et al. supra.) serially,\n        with either a gray-component replacement (GCR) or an under-color\n        replacement (UCR) function.\n        \n        Regarding the latter two operations, instakit only has a basic\n        GCR implementation currently, at the time of writing \xe2\x80\x93 q.v. the\n        `instakit.utils.gcr` module sub.\n        \n        Adapted originally from this sample code:\n            https://stackoverflow.com/a/10575940/298171\n    """"""\n    __slots__ = (\'sample\', \'scale\', \'angle\')\n    \n    def __init__(self, sample=1, scale=2, angle=0):\n        self.sample = sample\n        self.scale = scale\n        self.angle = angle\n    \n    def process(self, image):\n        orig_width, orig_height = image.size\n        image = Mode.L.process(image).rotate(self.angle, expand=1)\n        width, height = image.size\n        halftone = Mode.L.new((width * self.scale,\n                              height * self.scale))\n        dotscreen = ImageDraw.Draw(halftone)\n        \n        SAMPLE = self.sample\n        SCALE = self.scale\n        ANGLE = self.angle\n        \n        for y in range(0, height, SAMPLE):\n            for x in range(0, width, SAMPLE):\n                cropbox = image.crop((x,          y,\n                                      x + SAMPLE, y + SAMPLE))\n                diameter = (histogram_mean(cropbox) / 255) ** 0.5\n                edge = 0.5 * (1 - diameter)\n                xpos, ypos = (x + edge) * SCALE, (y + edge) * SCALE\n                boxedge = SAMPLE * diameter * SCALE\n                dotscreen.ellipse((xpos,           ypos,\n                                   xpos + boxedge, ypos + boxedge),\n                                   fill=255)\n        \n        halftone = halftone.rotate(-ANGLE, expand=1)\n        tone_width, tone_height = halftone.size\n        xx = (tone_width  - orig_width  * SCALE) / 2\n        yy = (tone_height - orig_height * SCALE) / 2\n        return halftone.crop((xx,                      yy,\n                              xx + orig_width * SCALE, yy + orig_height * SCALE))\n\nclass CMYKDotScreen(Processor):\n    \n    """""" Create a full-color CMYK dot-screen halftone, with gray-component\n        replacement (GCR), individual rotation angles for each channel\xe2\x80\x99s\n        dot-screen, and resampling value controls.\n    """"""\n    __slots__ = (\'overprinter\', \'sample\', \'scale\')\n    \n    def __init__(self,      gcr=20,\n                 sample=10, scale=10,\n                  thetaC=0, thetaM=15, thetaY=30, thetaK=45):\n        """""" Initialize an internal instakit.utils.pipeline.OverprintFork() """"""\n        self.sample = sample\n        self.scale = scale\n        self.overprinter = pipeline.OverprintFork(None, gcr=gcr)\n        self.overprinter[\'C\'] = DotScreen(angle=thetaC, sample=sample, scale=scale)\n        self.overprinter[\'M\'] = DotScreen(angle=thetaM, sample=sample, scale=scale)\n        self.overprinter[\'Y\'] = DotScreen(angle=thetaY, sample=sample, scale=scale)\n        self.overprinter[\'K\'] = DotScreen(angle=thetaK, sample=sample, scale=scale)\n        self.overprinter.apply_CMYK_inks()\n    \n    @property\n    def gcr_percentage(self):\n        return self.overprinter.basicgcr.percentage\n    \n    def angle(self, band_label):\n        if band_label not in self.overprinter.band_labels:\n            raise ValueError(\'invalid band label\')\n        return self.overprinter[band_label].angle\n    \n    @property\n    def thetaC(self):\n        """""" Return the C-band halftone screen\xe2\x80\x99s rotation """"""\n        return self.angle(\'C\')\n    \n    @property\n    def thetaM(self):\n        """""" Return the M-band halftone screen\xe2\x80\x99s rotation """"""\n        return self.angle(\'M\')\n    \n    @property\n    def thetaY(self):\n        """""" Return the Y-band halftone screen\xe2\x80\x99s rotation """"""\n        return self.angle(\'Y\')\n    \n    @property\n    def thetaK(self):\n        """""" Return the K-band halftone screen\xe2\x80\x99s rotation """"""\n        return self.angle(\'K\')\n    \n    def process(self, image):\n        return self.overprinter.process(image)\n\ndef test():\n    from instakit.utils.static import asset\n    \n    image_paths = list(map(\n        lambda image_file: asset.path(\'img\', image_file),\n            asset.listfiles(\'img\')))\n    image_inputs = list(map(\n        lambda image_path: Mode.RGB.open(image_path),\n            image_paths))\n    \n    for image_input in image_inputs:\n        image_input.show()\n        \n        # Atkinson(threshold=128.0).process(image_input).show()\n        # FloydSteinberg(threshold=128.0).process(image_input).show()\n        # SlowFloydSteinberg(threshold=128.0).process(image_input).show()\n        \n        # CMYKAtkinson().process(image_input).show()\n        # CMYKFloydsterBill().process(image_input).show()\n        CMYKDotScreen(sample=10, scale=4).process(image_input).show()\n    \n    print(image_paths)\n\nif __name__ == \'__main__\':\n    test()'"
instakit/processors/noise.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\nnoise.py\n\nCreated by FI$H 2000 on 2014-05-23.\nCopyright (c) 2012-2019 Objects In Space And Time, LLC. All rights reserved.\n""""""\nfrom __future__ import print_function\nfrom enum import Enum, unique\n\nfrom instakit.utils.ndarrays import NDProcessor\n\n@unique\nclass NoiseMode(Enum):\n    \n    LOCALVAR        = \'localvar\'\n    GAUSSIAN        = \'gaussian\'\n    POISSON         = \'poisson\'\n    SALT            = \'salt\'\n    PEPPER          = \'pepper\'\n    SALT_N_PEPPER   = \'s&p\'\n    SPECKLE         = \'speckle\'\n    \n    def to_string(self):\n        return str(self.value)\n    \n    def __str__(self):\n        return self.to_string()\n    \n    def process_nd(self, ndimage, **kwargs):\n        from skimage.util import random_noise\n        return random_noise(ndimage,\n                            mode=self.to_string(),\n                          **kwargs)\n\n\nclass Noise(NDProcessor):\n    """""" Base noise processor\n        -- defaults to \xe2\x80\x9clocalvar\xe2\x80\x9d mode; q.v. `GaussianLocalVarianceNoise` sub.\n    """"""\n    mode = NoiseMode.LOCALVAR\n    \n    def process_nd(self, ndimage):\n        noisemaker = type(self).mode\n        return self.compand(noisemaker.process_nd(ndimage))\n\n\nclass GaussianNoise(Noise):\n    """""" Add Gaussian noise """"""\n    mode = NoiseMode.GAUSSIAN\n\nclass PoissonNoise(Noise):\n    """""" Add Poisson-distributed noise """"""\n    mode = NoiseMode.POISSON\n\nclass GaussianLocalVarianceNoise(Noise):\n    """""" Add Gaussian noise, with image-dependant local variance """"""\n    pass\n\nclass SaltNoise(Noise):\n    """""" Add \xe2\x80\x9csalt noise\xe2\x80\x9d\n        -- replace random pixel values with 1.0f (255)\n    """"""\n    mode = NoiseMode.SALT\n\nclass PepperNoise(Noise):\n    """""" Add \xe2\x80\x9cpepper noise\xe2\x80\x9d\n        -- replace random pixel values with zero\n    """"""\n    mode = NoiseMode.PEPPER\n\nclass SaltAndPepperNoise(Noise):\n    """""" Add \xe2\x80\x9csalt and pepper noise\xe2\x80\x9d\n        -- replace random pixel values with either 1.0f (255) or zero\n    """"""\n    mode = NoiseMode.SALT_N_PEPPER\n\nclass SpeckleNoise(Noise):\n    """""" Add \xe2\x80\x9cspeckle noise\xe2\x80\x9d\n        --- multiplicative noise using `out = image + n * image`\n           (where `n` is uniform noise with specified mean + variance)\n    """"""\n    mode = NoiseMode.SPECKLE\n\ndef test():\n    from instakit.utils.static import asset\n    from instakit.utils.mode import Mode\n    \n    image_paths = list(map(\n        lambda image_file: asset.path(\'img\', image_file),\n            asset.listfiles(\'img\')))\n    image_inputs = list(map(\n        lambda image_path: Mode.RGB.open(image_path),\n            image_paths))\n    \n    noises = [GaussianNoise,\n              PoissonNoise,\n              GaussianLocalVarianceNoise,\n              SaltNoise,\n              PepperNoise,\n              SaltAndPepperNoise,\n              SpeckleNoise]\n    \n    for idx, image_input in enumerate(image_inputs + image_inputs[:2]):\n        for NoiseProcessor in noises:\n            NoiseProcessor().process(image_input).show()\n    \n    print(image_paths)\n\nif __name__ == \'__main__\':\n    test()'"
instakit/processors/squarecrop.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\nsquarecrop.py\n\nCreated by FI$H 2000 on 2012-08-23.\nCopyright (c) 2012 Objects In Space And Time, LLC. All rights reserved.\n""""""\nfrom __future__ import print_function\n\nfrom instakit.abc import Processor\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\n@export\nclass SquareCrop(Processor):\n    \n    """""" Crop an image to an Instagrammy square, by whittling away\n        the parts of the image with the least entropy.\n        \n        Based on a smart-crop implementation from easy-thumbnails:\n            https://git.io/fhqxj\n    """"""\n    __slots__ = tuple()\n    \n    @staticmethod\n    def compare_entropy(start_slice, end_slice, slice, difference):\n        """""" Calculate the entropy of two slices (from the start and end\n            of an axis), returning a tuple containing the amount that\n            should be added to the start, and removed from the end\n            of that axis.\n            \n            Based on the eponymous function from easy-thumbnails:\n                https://git.io/fhqpT\n        """"""\n        from instakit.utils.stats import histogram_entropy\n        \n        start_entropy = histogram_entropy(start_slice)\n        end_entropy = histogram_entropy(end_slice)\n        \n        if end_entropy and abs(start_entropy / end_entropy - 1) < 0.01:\n            # Less than 1% difference, remove from both sides.\n            if difference >= slice * 2:\n                return slice, slice\n            half_slice = slice // 2\n            return half_slice, slice - half_slice\n        \n        if start_entropy > end_entropy:\n            return 0, slice\n        else:\n            return slice, 0\n    \n    def process(self, image):\n        source_x, source_y = image.size\n        target_width = target_height = min(image.size)\n        \n        diff_x = int(source_x - min(source_x, target_width))\n        diff_y = int(source_y - min(source_y, target_height))\n        left = top = 0\n        right, bottom = source_x, source_y\n        \n        while diff_x:\n            slice = min(diff_x, max(diff_x // 5, 10))\n            start = image.crop((left, 0, left + slice, source_y))\n            end = image.crop((right - slice, 0, right, source_y))\n            add, remove = self.compare_entropy(start, end, slice, diff_x)\n            left += add\n            right -= remove\n            diff_x = diff_x - add - remove\n        \n        while diff_y:\n            slice = min(diff_y, max(diff_y // 5, 10))\n            start = image.crop((0, top, source_x, top + slice))\n            end = image.crop((0, bottom - slice, source_x, bottom))\n            add, remove = self.compare_entropy(start, end, slice, diff_y)\n            top += add\n            bottom -= remove\n            diff_y = diff_y - add - remove\n        \n        box = (left, top, right, bottom)\n        return image.crop(box)\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir(\'pout\', \'inline\')\n\ndef test():\n    from instakit.utils.static import asset\n    from instakit.utils.mode import Mode\n    \n    image_paths = list(map(\n        lambda image_file: asset.path(\'img\', image_file),\n            asset.listfiles(\'img\')))\n    image_inputs = list(map(\n        lambda image_path: Mode.RGB.open(image_path),\n            image_paths))\n    \n    for image_input in image_inputs:\n        image_input.show()\n        SquareCrop().process(image_input).show()\n    \n    print(image_paths)\n\nif __name__ == \'__main__\':\n    test()'"
instakit/utils/__init__.py,0,b''
instakit/utils/colortype.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\nutils/colortype.py\n\nCreated by FI$H 2000 on 2012-08-23.\nCopyright (c) 2012 Objects In Space And Time, LLC. All rights reserved.\n""""""\nfrom __future__ import print_function\nfrom collections import namedtuple, defaultdict\n\nfrom clu.constants.polyfills import numpy\nfrom clu.naming import split_abbreviations\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\ncolor_types = defaultdict(dict)\n\n# hash_RGB = lambda rgb: (rgb[0]*256)**2 + (rgb[1]*256) + rgb[2]\n\n@export\ndef ColorType(name, *args, **kwargs):\n    global color_types\n    dtype = numpy.dtype(kwargs.pop(\'dtype\', numpy.uint8))\n    if name not in color_types[dtype.name]:\n        channels = split_abbreviations(name)\n        \n        class Color(namedtuple(name, channels)):\n            \n            def __repr__(self):\n                return ""%s(dtype=%s, %s)"" % (\n                    name, self.__class__.dtype.name,\n                    \', \'.join([\'%s=%s\' % (i[0], i[1]) \\\n                        for i in self._asdict().items()]))\n            \n            def __hex__(self):\n                return \'0x\' + ""%x"" * len(self) % self\n            \n            def __int__(self):\n                return int(self.__hex__(), 16)\n            \n            def __long__(self):\n                return numpy.long(self.__hex__(), 16)\n            \n            def __hash__(self):\n                return self.__long__()\n            \n            def __eq__(self, other):\n                if not len(other) == len(self):\n                    return False\n                return all([self[i] == other[i] for i in range(len(self))])\n            \n            def __str__(self):\n                return str(repr(self))\n            \n            def composite(self):\n                return numpy.dtype([\n                    (k, self.__class__.dtype) for k, v in self._asdict().items()])\n            \n        Color.__name__ = ""%s<%s>"" % (name, dtype.name)\n        Color.dtype = dtype\n        color_types[dtype.name][name] = Color\n    return color_types[dtype.name][name]\n\nexport(color_types,     name=\'color_types\')\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n\ndef test():\n    assert split_abbreviations(\'RGB\') == (\'R\', \'G\', \'B\')\n    assert split_abbreviations(\'CMYK\') == (\'C\', \'M\', \'Y\', \'K\')\n    assert split_abbreviations(\'YCbCr\') == (\'Y\', \'Cb\', \'Cr\')\n    assert split_abbreviations(\'sRGB\') == (\'R\', \'G\', \'B\')\n    assert split_abbreviations(\'XYZ\') == (\'X\', \'Y\', \'Z\')\n\nif __name__ == \'__main__\':\n    test()'"
instakit/utils/gcr.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\nfrom __future__ import print_function\nfrom math import fabs, pow as mpow\n\nfrom instakit.utils.mode import Mode\nfrom instakit.abc import Processor\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\nPERCENT_ADMONISHMENT = ""Do you not know how percents work??!""\n\n@export\ndef gcr(image, percentage=20, revert_mode=False):\n    \'\'\' basic \xe2\x80\x9cGray Component Replacement\xe2\x80\x9d function. Returns a CMYK image* with \n        percentage gray component removed from the CMY channels and put in the\n        K channel, e.g. for percentage=100, (41, 100, 255, 0) >> (0, 59, 214, 41).\n        \n    {*} This is the default behavior \xe2\x80\x93 to return an image of the same mode as that\n        of which was originally provided, pass the value for the (optional) keyword\n        argument `revert_mode` as `True`.\n    \'\'\'\n    # from http://stackoverflow.com/questions/10572274/halftone-images-in-python\n    \n    if percentage is None:\n        return revert_mode and image or Mode.CMYK.process(image)\n    \n    if percentage > 100 or percentage < 1:\n        raise ValueError(PERCENT_ADMONISHMENT)\n    \n    percent = percentage / 100\n    \n    original_mode = Mode.of(image)\n    cmyk_channels = Mode.CMYK.process(image).split()\n    width, height = image.size\n    \n    cmyk_image = []\n    for channel in cmyk_channels:\n        cmyk_image.append(channel.load())\n    \n    for x in range(width):\n        for y in range(height):\n            gray = int(min(cmyk_image[0][x, y],\n                           cmyk_image[1][x, y],\n                           cmyk_image[2][x, y]) * percent)\n            cmyk_image[0][x, y] -= gray\n            cmyk_image[1][x, y] -= gray\n            cmyk_image[2][x, y] -= gray\n            cmyk_image[3][x, y] = gray\n    \n    recomposed = Mode.CMYK.merge(*cmyk_channels)\n    \n    if revert_mode:\n        return original_mode.process(recomposed)\n    return recomposed\n\n@export\nclass BasicGCR(Processor):\n    \n    __slots__ = (\'percentage\', \'revert_mode\')\n    __doc__ = gcr.__doc__\n    \n    def __init__(self, percentage=20, revert_mode=False):\n        if percentage is None:\n            raise ValueError(PERCENT_ADMONISHMENT)\n        if percentage > 100 or percentage < 1:\n            raise ValueError(PERCENT_ADMONISHMENT)\n        self.percentage = percentage\n        self.revert_mode = revert_mode\n    \n    def process(self, image):\n        return gcr(image, percentage=self.percentage,\n                          revert_mode=self.revert_mode)\n\n@export\ndef hex2rgb(h):\n    """""" Convert a hex string or number to an RGB triple """"""\n    # q.v. https://git.io/fh9E2\n    if isinstance(h, str):\n        return hex2rgb(int(h[1:] if h.startswith(\'#\') else h, 16))\n    return (h >> 16) & 0xff, (h >> 8) & 0xff, h & 0xff\n\n@export\ndef compand(v):\n    """""" Compand a linearized value to an sRGB byte value """"""\n    # q.v. http://www.brucelindbloom.com/index.html?Math.html\n    V = (v <= 0.0031308) and (v * 12.92) or fabs((1.055 * mpow(v, 1 / 2.4)) - 0.055)\n    return int(V * 255.0)\n\n@export\ndef uncompand(A):\n    """""" Uncompand an sRGB byte value to a linearized value """"""\n    # q.v. http://www.brucelindbloom.com/index.html?Eqn_RGB_to_XYZ.html\n    V = A / 255.0\n    return (V <= 0.04045) and (V / 12.92) or mpow(((V + 0.055) / 1.055), 2.4)\n\n@export\ndef ucr(image, revert_mode=False):\n    \'\'\' basic \xe2\x80\x9cUnder-Color Removal\xe2\x80\x9d function. Returns a CMYK image* in which regions\n        containing overlapping C, M, and Y ink are replaced with K (\xe2\x80\x9cKey\xe2\x80\x9d, n\xc3\xa9e \xe2\x80\x9cBlacK\xe2\x80\x9d)\n        ink. Images are first converted to RGB and linearized in order to perform the UCR\n        operation in linear space. E.g.:\n        \n        0xFFDE17 >  rgb(255, 222, 23)\n                 >  RGB(1.0, 0.7304607400903537, 0.008568125618069307)\n                 >  CMY(0.0, 0.26953925990964633, 0.9914318743819307)\n        \n        rgb() > RGB() > CMY() > CMYK(41, 100, 255, 0) >> cmyk(0, 59, 214, 41).\n        \n    {*} This is the default behavior \xe2\x80\x93 to return an image of the same mode as that\n        of which was originally provided, pass the value for the (optional) keyword\n        argument `revert_mode` as `True`.\n    \'\'\'\n    # Adapted from http://www.easyrgb.com/en/math.php#text13\n    # N.B. this is not, out of the gate, particularly well-optimized\n    \n    original_mode = Mode.of(image)\n    width, height = image.size\n    cmyk_target = Mode.CMYK.new(image.size, color=0)\n    rgb_channels = Mode.RGB.process(image).split()\n    cmyk_channels = cmyk_target.split()\n    \n    rgb_image = []\n    for channel in rgb_channels:\n        rgb_image.append(channel.load())\n    \n    cmyk_image = []\n    for channel in cmyk_channels:\n        cmyk_image.append(channel.load())\n    \n    for x in range(width):\n        for y in range(height):\n            # Get the rgb byte values:\n            rgb = (rgb_image[0][x, y],\n                   rgb_image[1][x, y],\n                   rgb_image[2][x, y])\n            \n            # Uncompand rgb bytes to linearized RGB:\n            RGB = (uncompand(v) for v in rgb)\n            \n            # Convert linear RGB to linear CMY:\n            (C, M, Y) = (1.0 - V for V in RGB)\n            \n            # Perform simple UCR with the most combined\n            # overlapping C/M/Y ink values:\n            K = min(C, M, Y, 1.0)\n            \n            if K == 1:\n                C = M = Y = 0\n            else:\n                denominator = (1 - K)\n                C = (C - K) / denominator\n                M = (M - K) / denominator\n                Y = (Y - K) / denominator\n            \n            # Recompand linear CMYK to cmyk byte values for Pillow:\n            cmyk_image[0][x, y] = compand(C)\n            cmyk_image[1][x, y] = compand(M)\n            cmyk_image[2][x, y] = compand(Y)\n            cmyk_image[3][x, y] = compand(K)\n    \n    recomposed = Mode.CMYK.merge(*cmyk_channels)\n    \n    if revert_mode:\n        return original_mode.process(recomposed)\n    return recomposed\n\n@export\nclass BasicUCR(Processor):\n    \n    __slots__ = (\'revert_mode\',)\n    __doc__ = ucr.__doc__\n    \n    def __init__(self, revert_mode=False):\n        self.revert_mode = revert_mode\n    \n    def process(self, image):\n        return ucr(image, revert_mode=self.revert_mode)\n\n@export\nclass DemoUCR(object):\n    \n    """""" Demonstrate each phase of the UCR color-conversion process """"""\n    \n    def __init__(self, hex_triple):\n        """""" Initialize with a hex-encoded RGB triple, either as a string\n            or as a hexadecimal integer, e.g.:\n                \n                >>> onedemo = DemoUCR(0xD8DCAB)\n                >>> another = DemoUCR(\'#6A9391\')\n        """"""\n        self.hex_triple = hex_triple\n    \n    def calculate(self):\n        self.rgb = self.get_rgb()\n        self.RGB = self.get_RGB()\n        self.CMY = self.get_CMY()\n        self.CMYK = self.get_CMYK()\n        self.cmyk = self.get_cmyk()\n    \n    def get_rgb(self):\n        """""" Return the rgb byte-value (0-255) 3-tuple corresponding to the\n            initial hex value\n        """"""\n        return hex2rgb(self.hex_triple)\n    \n    def get_RGB(self):\n        """""" Return the linearized (uncompanded) RGB 3-tuple version of the\n            rgb 3-byte value tuple\n        """"""\n        return tuple(uncompand(v) for v in self.rgb)\n    \n    def get_CMY(self):\n        """""" Return the linearized (uncompanded) CMY color-model analog of the\n            linear RGB value 3-tuple\n        """"""\n        (C, M, Y) = (1.0 - V for V in self.RGB)\n        return (C, M, Y)\n    \n    def get_CMYK(self):\n        """""" Return the UCR\xe2\x80\x99ed -- the under-color removed -- linearized CMYK analog\n            of the linear CMY color-model value tuple\n        """"""\n        K = min(*self.CMY, 1.0)\n        (C, M, Y) = self.CMY\n        \n        if K == 1:\n            C = M = Y = 0\n        else:\n            denominator = (1 - K)\n            C = (C - K) / denominator\n            M = (M - K) / denominator\n            Y = (Y - K) / denominator\n        return (C, M, Y, K)\n    \n    def get_cmyk(self):\n        """""" Return the companded cmyk byte-value (0-255) 4-tuple Pillow-friendly\n            CMYK analog of the initial value\n        """"""\n        return tuple(compand(V) for V in self.CMYK)\n    \n    def stringify_demo_values(self):\n        """""" Return each of the values, step-by-step in the conversion process,\n            admirably formatted in a handsome manner suitable for printing\n        """"""\n        self.calculate()\n        return """"""\n            \n    %(hex_triple)s > rgb%(rgb)s\n            > RGB%(RGB)s\n            > CMY%(CMY)s\n            > CMYK%(CMYK)s\n            > cmyk%(cmyk)s\n        \n        """""" % self.__dict__\n    \n    def __str__(self):\n        """""" Stringify yo self """"""\n        return self.stringify_demo_values()\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n\ndef test():\n    from instakit.utils.static import asset\n    from itertools import chain\n    from os.path import relpath\n    from pprint import pprint\n    \n    start = ""/usr/local/Cellar/python/3.7.2_2/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages""\n    \n    image_paths = list(map(lambda image_file: asset.path(\'img\', image_file), asset.listfiles(\'img\')))\n    image_inputs = list(map(lambda image_path: Mode.RGB.open(image_path), image_paths))\n    # print(""len:"", len(list(image_paths)), len(list(image_inputs)), len(list(callables)))\n    \n    print(\'\\t<<<<<<<<<<<<<<<------------------------------------------------------>>>>>>>>>>>>>>>\')\n    print()\n    \n    functions = (gcr, ucr)\n    processors = (BasicGCR(), BasicUCR(), Mode.CMYK)\n    callables = chain((processor.process for processor in processors), functions)\n    \n    image_components = zip(image_paths, image_inputs, callables)\n    \n    for path, image, process_functor in image_components:\n        print(""\xc2\xabTESTING: %s\xc2\xbb"" % relpath(path, start=start))\n        print()\n        tup = image.size + (image.mode,)\n        print(""\xc2\xac Input: %sx%s %s"" % tup)\n        print(""\xc2\xac Calling functor on image\xe2\x80\xa6"")\n        result = process_functor(image)\n        tup = result.size + (result.mode,)\n        print(""\xc2\xac Output: %sx%s %s"" % tup)\n        print(""\xc2\xac Displaying\xe2\x80\xa6"")\n        print()\n        result.show()\n    \n    print(""\xc2\xab\xc2\xa1SUCCESS!\xc2\xbb"")\n    print()\n    \n    print(""\xc2\xabTESTING: MANUAL CALLABLES\xc2\xbb"")\n    # print()\n    \n    if len(image_inputs):\n        image = image_inputs.pop()\n        \n        # Test GCR function:\n        gcred = gcr(image)\n        assert gcred.mode == Mode.CMYK.value.mode\n        assert Mode.of(gcred) is Mode.CMYK\n        # gcred.show()\n        \n        # close image:\n        image.close()\n    \n    if len(image_inputs):\n        image = image_inputs.pop()\n        \n        # Test UCR function:\n        ucred = ucr(image)\n        assert ucred.mode == Mode.CMYK.value.mode\n        assert Mode.of(ucred) is Mode.CMYK\n        # ucred.show()\n        \n        # close image:\n        image.close()\n    \n    if len(image_inputs):\n        image = image_inputs.pop()\n        \n        # Test GCR processor:\n        gcr_processor = BasicGCR()\n        gcred = gcr_processor.process(image)\n        assert gcred.mode == Mode.CMYK.value.mode\n        assert Mode.of(gcred) is Mode.CMYK\n        # gcred.show()\n        \n        # close image:\n        image.close()\n    \n    if len(image_inputs):\n        image = image_inputs.pop()\n        \n        # Test UCR processor:\n        ucr_processor = BasicUCR()\n        ucred = ucr_processor.process(image)\n        assert ucred.mode == Mode.CMYK.value.mode\n        assert Mode.of(ucred) is Mode.CMYK\n        # ucred.show()\n        \n        # close image:\n        image.close()\n    \n    print(""\xc2\xab\xc2\xa1SUCCESS!\xc2\xbb"")\n    print()\n    \n    print(\'\\t<<<<<<<<<<<<<<<------------------------------------------------------>>>>>>>>>>>>>>>\')\n    print()\n    \n    pprint(list(relpath(path, start=start) for path in image_paths))\n    print()\n    \n    print(""\xc2\xabTESTING: DemoUCR ALGORITHM-STAGE TRACE PRINTER\xc2\xbb"")\n    print()\n    \n    print(DemoUCR(""#BB2F53""))\n    print()\n    \n    print(DemoUCR(0x6F2039))\n    print()\n\n\nif __name__ == \'__main__\':\n    test()'"
instakit/utils/kernels.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\nfrom __future__ import print_function\n\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\n@export\ndef gaussian(size, sizeY=None):\n    """""" Returns a normalized 2D gauss kernel array for convolutions """"""\n    from scipy import mgrid, exp\n    sizeX = int(size)\n    if not sizeY:\n        sizeY = sizeX\n    else:\n        sizeY = int(sizeY)\n    x, y = mgrid[-sizeX:sizeX+1,\n                 -sizeY:sizeY+1]\n    g = exp(-(x**2/float(sizeX)+y**2/float(sizeY)))\n    return (g / g.sum()).flatten()\n\n@export\ndef gaussian_blur_kernel(ndim, kernel):\n    from scipy.ndimage import convolve\n    return convolve(ndim, kernel, mode=\'reflect\')\n\n@export\ndef gaussian_blur(ndim, sigma=3, sizeY=None):\n    return gaussian_blur_kernel(ndim,\n                                gaussian(sigma,\n                                sizeY=sizeY))\n\n@export\ndef gaussian_blur_filter(input, sigmaX=3,\n                                sigmaY=3,\n                                sigmaZ=0):\n    from scipy.ndimage.filters import gaussian_filter\n    if not sigmaY:\n        sigmaY = sigmaX\n    if not sigmaZ:\n        sigmaZ = sigmaX\n    return gaussian_filter(input, sigma=(sigmaX,\n                                         sigmaY,\n                                         sigmaZ), order=0,\n                                                  mode=\'reflect\')\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n'"
instakit/utils/lutmap.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\nlutmap.py\n\nCreated by FI$H 2000 on 2012-08-23.\nCopyright (c) 2012 Objects In Space And Time, LLC. All rights reserved.\n""""""\nfrom __future__ import print_function\n\nimport numpy\nimport imread\nfrom os.path import join\nfrom collections import defaultdict\n\nfrom PIL import Image\n#from math import floor\n\nfrom instakit.utils.colortype import ColorType\nfrom instakit.utils import static\n\nclass RGBTable(defaultdict):\n    RGB = ColorType(\'RGB\', dtype=numpy.uint8)\n    identity = numpy.zeros(\n        shape=(512, 512),\n        dtype=numpy.uint64)\n    \n    for bx in range(0, 8):\n        for by in range(0, 8):\n            for r in range(0, 64):\n                for g in range(0, 64):\n                    identity[\n                        int(g + float(by) * 64.0 + 0.5),\n                        int(r + float(bx) * 64.0 + 0.5)] = hash(RGB(\n                            int(r * 255.0 / 63.0 + 0.5),\n                            int(g * 255.0 / 63.0 + 0.5),\n                            int((bx + by * 8.0) * 255.0 / 63.0 + 0.5)))\n    \n    def __init__(self):\n        super(RGBTable, self).__init__(default_factory=None)\n        self.data = self.identity\n    \n    def __missing__(self, color):\n        self[color] = value = self.lookup(color)\n        return value\n    \n    def _idx(self, color):\n        print(""_idx COLOR:"")\n        print(color)\n        print(""_idx WAT:"")\n        print(int(\'%02x%02x%02x\' % color, 16))\n        print(""hash COLOR:"")\n        print(hash(color))\n        return int(\'%02x%02x%02x\' % color, 16)\n    \n    def _rgb(self, idx):\n        RGB = self.RGB\n        return RGB(*reversed(\n            [(idx >> (8*i)) & 255 for i in range(3)]))\n    \n    def lookup(self, color):\n        print(""lookup COLOR:"")\n        print(color)\n        return self.color_at(*self._xy(color))\n    \n    def _xy(self, color):\n        where = numpy.where(\n            self.identity[:,:] == hash(color))\n        print(""WHERE:"")\n        print(len(tuple(zip(*where))))\n        try:\n            return tuple(zip(*where))[0]\n        except IndexError:\n            return []\n    \n    def color_at(self, x, y, data=None):\n        print(""X, Y: %s, %s"" % (x, y))\n        print(""data: %s"" % data)\n        if data is None:\n            data = self.data\n        print(""DATA.shape:"")\n        print(self.data.shape)\n        print(data[x, y])\n        return self.RGB(*data[x, y])\n    \n    def float_color_at(self, x, y, data=None):\n        if data is None:\n            data = self.identity\n        return (channel/255.0 for channel in self.color_at(x, y, data=data))\n\nclass LUT(RGBTable):\n    \n    def __init__(self, name=\'identity\'):\n        RGBTable.__init__(self)\n        self.name = name\n        self.data = self._read_png_matrix(self.name)\n    \n    @classmethod\n    def _read_png_matrix(cls, name):\n        print(""Reading LUT image: %s"" % static.path(join(\'lut\', \'%s.png\' % name)))\n        return imread.imread(\n            static.path(join(\'lut\', \'%s.png\' % name)))\n\ndef main():\n\n    RGB = ColorType(\'RGB\')\n    RGB24 = ColorType(\'RGB\', dtype=numpy.uint8)\n    YCrCb = ColorType(\'YCrCb\', dtype=numpy.uint8)\n    \n    print(RGB(2, 3, 4))\n    print(RGB24)\n    print(YCrCb(8, 88, 808))\n    \n    identity = LUT()\n    amatorka = LUT(\'amatorka\')\n    \n    print(identity.identity)\n    print(RGB(22,33,44))\n    print(int(RGB(22,33,44)))\n    print(int(RGB(55,66,77)))\n    print(numpy.any(identity.identity[:,:] == int(RGB(11,44,99))))\n    print(numpy.max(identity.identity))\n    print(RGB(111, 222, 11).composite)\n    \n    print("""")\n    print(identity[RGB(146,146,36)])\n    #print(identity[RGB(22,33,44)])\n    print(identity[RGB(132, 166, 188)])\n    \n    print("""")\n    print(""YO DOGG"")\n    print(amatorka[RGB(146,146,36)])\n    print(identity[RGB(22,33,44)])\n    print(identity[RGB(255, 25, 25)])\n\ndef blurthday():\n    \n    from imread import imread\n    from pprint import pprint\n    imfuckingshowalready = lambda mx: Image.fromarray(mx).show()\n    \n    identity = LUT()\n    amatorka = LUT(\'amatorka\')\n    #miss_etikate = LUT(\'miss_etikate\')\n    #soft_elegance_1 = LUT(\'soft_elegance_1\')\n    #soft_elegance_2 = LUT(\'soft_elegance_2\')\n    \n    im1 = imread(static.path(join(\'img\', \'06-DSCN4771.JPG\')))\n    im2 = imread(static.path(join(\n        \'img\', \'430023_3625646599363_1219964362_3676052_834528487_n.jpg\')))\n    \n    pprint(identity)\n    pprint(amatorka)\n    \n    im9 = amatorka.transform(im1)\n    pprint(im9)\n    imfuckingshowalready(im9)\n    print(im1)\n    print(im2)\n\ndef old_maid():\n    pass\n    #global __multipons__\n    #from pprint import pprint\n    #pprint(__multipons__)\n\ndef old_main():\n    \n    #imfuckingshowalready = lambda mx: Image.fromarray(mx).show()\n\n    old_identity = static.path(join(\'lut\', \'identity.png\'))\n\n    im_old_identity = imread.imread(old_identity)\n    im_identity = numpy.zeros_like(im_old_identity)\n\n    for bx in range(0, 8):\n        for by in range(0, 8):\n            for r in range(0, 64):\n                for g in range(0, 64):\n                    im_identity[\n                        int(g + by * 64),\n                        int(r + bx * 64)] = numpy.array((\n                            int(r * 255.0 / 63.0 + 0.5),\n                            int(g * 255.0 / 63.0 + 0.5),\n                                int((bx + by * 8.0) * 255.0 / 63.0 + 0.5)),\n                                dtype=numpy.uint8)\n    \n    print(""THE OLD: %s, %s, %s"" % (\n        im_old_identity.size, im_old_identity.shape,\n        str(im_old_identity.dtype)))\n    #print(im_old_identity)\n    print("""")\n    \n    print(""THE NEW: %s, %s, %s"" % (\n        im_identity.size, im_identity.shape,\n        str(im_identity.dtype)))\n    #print(im_identity)\n    print("""")\n    \n    print(""THE END: %s"" % bool(im_old_identity.shape == im_identity.shape))\n    #print(im_old_identity == im_identity)\n    \n    #imfuckingshowalready(im_identity)\n    #imfuckingshowalready(im_old_identity)\n    \n    pil_im_old_identity = Image.fromarray(im_old_identity)\n    pil_im_old_identity.save(\'/tmp/im_old_identity.jpg\',\n        format=""JPEG"")\n    \n    pil_im_identity = Image.fromarray(im_identity)\n    pil_im_identity.save(\'/tmp/im_identity.jpg\',\n        format=""JPEG"")\n\nif __name__ == \'__main__\':\n    main()'"
instakit/utils/misc.py,0,"b""#!/usr/bin/env python\n# encoding: utf-8\nfrom __future__ import print_function\n\nfrom clu.fs.misc import suffix_searcher, u8encode, u8bytes, u8str\nfrom clu.predicates import wrap_value, none_function, tuplize, uniquify, listify\nfrom clu.repr import stringify\nfrom clu.typespace.namespace import SimpleNamespace, Namespace\nfrom clu.typology import (string_types, bytes_types as byte_types)\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\ntry:\n    import six\nexcept ImportError:\n    class FakeSix(object):\n        @property\n        def string_types(self):\n            return tuple()\n    six = FakeSix()\n\nexport(wrap_value,              name='wrap_value')\nexport(none_function,           name='none_function')\nexport(tuplize,                 name='tuplize')\nexport(uniquify,                name='uniquify')\nexport(listify,                 name='listify')\n\nexport(SimpleNamespace)\nexport(Namespace)\n\nexport(stringify,               name='stringify')\nexport(string_types)\nexport(byte_types)\n\nexport(suffix_searcher)\nexport(u8encode)\nexport(u8bytes)\nexport(u8str)\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n\n"""
instakit/utils/mode.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\nfrom __future__ import print_function\n\nimport contextlib\nimport numpy\nimport os\n\nfrom PIL import Image, ImageMode\nfrom enum import auto, unique\n\nfrom clu.constants.consts import DEBUG, ENCODING\nfrom clu.enums import alias, AliasingEnum\nfrom clu.naming import split_abbreviations\nfrom clu.predicates import attr, getpyattr, isclasstype, or_none\nfrom clu.typespace.namespace import Namespace\nfrom clu.typology import string_types\n\njunkdrawer = Namespace()\njunkdrawer.imode = lambda image: ImageMode.getmode(image.mode)\n\nImageMode.getmode(\'RGB\') # one call must be made to getmode()\n                         # to properly initialize ImageMode._modes:\n\njunkdrawer.modes = ImageMode._modes\njunkdrawer.types = Image._MODE_CONV\njunkdrawer.ismap = Image._MAPMODES\n\nmode_strings = tuple(junkdrawer.modes.keys())\ndtypes_for_modes = { k : v[0] for k, v in junkdrawer.types.items() }\n\njunkdrawer.idxmode = lambda idx: ImageMode.getmode(mode_strings[idx])\njunkdrawer.is_mapped = lambda mode: mode in junkdrawer.ismap\n\nclass ModeAncestor(AliasingEnum):\n    """"""\n    Valid ImageMode mode strings:\n    (\'1\',    \'L\',     \'I\',     \'F\',     \'P\',\n     \'RGB\',  \'RGBX\',  \'RGBA\',  \'CMYK\',  \'YCbCr\',\n     \'LAB\',  \'HSV\',   \'RGBa\',  \'LA\',    \'La\',\n     \'PA\',   \'I;16\',  \'I;16L\', \'I;16B\')\n    """"""\n    \n    def _generate_next_value_(name,\n                              start,\n                              count,\n                              last_values):\n        return junkdrawer.idxmode(count)\n    \n    @classmethod\n    def _missing_(cls, value):\n        try:\n            return cls(junkdrawer.idxmode(value))\n        except (IndexError, TypeError):\n            pass\n        return super(ModeAncestor, cls)._missing_(value)\n    \n    @classmethod\n    def is_mode(cls, instance):\n        return type(instance) in cls.__mro__\n\nclass ModeContext(contextlib.AbstractContextManager):\n    \n    """""" An ad-hoc mutable named-tuple-ish context-manager class,\n        for keeping track of an image while temporarily converting\n        it to a specified mode within the managed context block.\n        \n        Loosely based on the following Code Review posting:\n        \xe2\x80\xa2 https://codereview.stackexchange.com/q/173045/6293\n    """"""\n    \n    __slots__ = (\'initial_image\',\n                         \'image\',\n                   \'final_image\',\n                 \'original_mode\',\n                          \'mode\',\n                       \'verbose\')\n    \n    def __init__(self, image, mode, **kwargs):\n        assert Image.isImageType(image)\n        assert Mode.is_mode(mode)\n        if DEBUG:\n            label = or_none(image, \'filename\') \\\n                and os.path.basename(getattr(image, \'filename\')) \\\n                or str(image)\n            print(f""ModeContext.__init__: configured with image: {label}"")\n        self.initial_image = image\n        self.image = None\n        self.final_image = None\n        self.original_mode = Mode.of(image)\n        self.mode = mode\n    \n    def __repr__(self):\n        return type(self).__name__ + repr(tuple(self))\n    \n    def __iter__(self):\n        for name in self.__slots__:\n            yield getattr(self, name)\n    \n    def __getitem__(self, idx):\n        return getattr(self, self.__slots__[idx])\n    \n    def __len__(self):\n        return len(self.__slots__)\n    \n    def attr_or_none(self, name):\n        return or_none(self, name)\n    \n    def attr_set(self, name, value):\n        setattr(self, name, value)\n    \n    def __enter__(self):\n        initial_image = self.attr_or_none(\'initial_image\')\n        mode = self.attr_or_none(\'mode\')\n        if initial_image is not None and mode is not None:\n            if DEBUG:\n                initial_mode = Mode.of(initial_image)\n                print(f""ModeContext.__enter__: converting {initial_mode} to {mode}"")\n            image = mode.process(initial_image)\n            self.attr_set(\'image\', image)\n        return self\n    \n    def __exit__(self, exc_type=None, exc_val=None, exc_tb=None):\n        image = self.attr_or_none(\'image\')\n        original_mode = self.attr_or_none(\'original_mode\')\n        if image is not None and original_mode is not None:\n            if DEBUG:\n                mode = Mode.of(image)\n                print(f""ModeContext.__exit__: converting {mode} to {original_mode}"")\n            final_image = original_mode.process(image)\n            self.attr_set(\'final_image\', final_image)\n        return exc_type is None\n\n@unique\nclass Field(AliasingEnum):\n    \n    RO          = auto()\n    WO          = auto()\n    RW          = auto()\n    ReadOnly    = alias(RO)\n    WriteOnly   = alias(WO)\n    ReadWrite   = alias(RW)\n\nclass FieldIOError(IOError):\n    pass\n\nanno_for = lambda cls, name, default=None: getpyattr(cls, \'annotations\', default={}).get(name, default)\n\nclass ModeField(object):\n    \n    """""" Not *that* ModeDescriptor. THIS ModeDescriptor! """"""\n    __slots__ = (\'default\', \'value\', \'name\', \'io\')\n    \n    def __init__(self, default):\n        self.default = default\n    \n    def __set_name__(self, cls, name):\n        if name is not None:\n            self.name = name\n            self.value = None\n            self.io = anno_for(cls, name, Field.RW)\n    \n    def __get__(self, instance=None, cls=None):\n        if instance is not None:\n            if self.io is Field.WO:\n                raise FieldIOError(f""can\xe2\x80\x99t access write-only field {self.name}"")\n        if isclasstype(cls):\n            return self.get()\n    \n    def __set__(self, instance, value):\n        if self.io is Field.RO:\n            if value != self.value:\n                FieldIOError(f""can\xe2\x80\x99t set read-only field {self.name}"")\n        self.set(value)\n    \n    def value_from_instance(self, instance):\n        pass\n    \n    def get(self):\n        return attr(self, \'value\', \'default\')\n    \n    def set(self, value):\n        if value is None:\n            self.value = value\n            return\n        if type(value) in string_types:\n            value = Mode.for_string(value)\n        if Mode.is_mode(value):\n            if value is not self.default:\n                self.value = value\n                return\n        else:\n            raise TypeError(""can\xe2\x80\x99t set invalid mode: %s (%s)"" % (type(value), value))\n\n\n@unique\nclass Mode(ModeAncestor):\n    \n    """""" An enumeration class wrapping ImageMode.ModeDescriptor. """"""\n    \n    # N.B. this\'ll have to be manually updated,\n    # whenever PIL.ImageMode gets a change pushed.\n    \n    MONO    = auto() # formerly \xe2\x80\x981\xe2\x80\x99\n    L       = auto()\n    I       = auto()\n    F       = auto()\n    P       = auto()\n    \n    RGB     = auto()\n    RGBX    = auto()\n    RGBA    = auto()\n    CMYK    = auto()\n    YCbCr   = auto()\n    \n    LAB     = auto()\n    HSV     = auto()\n    RGBa    = auto()\n    LA      = auto()\n    La      = auto()\n    \n    PA      = auto()\n    I16     = auto() # formerly \xe2\x80\x98I;16\xe2\x80\x99\n    I16L    = auto() # formerly \xe2\x80\x98I;16L\xe2\x80\x99\n    I16B    = auto() # formerly \xe2\x80\x98I;16B\xe2\x80\x99\n    \n    @classmethod\n    def of(cls, image):\n        for mode in cls:\n            if mode.check(image):\n                return mode\n        raise ValueError(f""Image has unknown mode {image.mode}"")\n    \n    @classmethod\n    def for_string(cls, string):\n        for mode in cls:\n            if mode.to_string() == string:\n                return mode\n        raise ValueError(f""for_string(): unknown mode {string}"")\n    \n    def to_string(self):\n        return str(self.value)\n    \n    def __str__(self):\n        return self.to_string()\n    \n    def __repr__(self):\n        repr_string = ""%s(%s: [%s/%s] \xe2\x88\x9e {%s \xc2\xbb %s}) @ %s""\n        return repr_string % (type(self).__qualname__,\n                                   self.label,\n                                   self.basemode, self.basetype,\n                                   self.dtype_code(), self.dtype,\n                                id(self))\n    \n    def __bytes__(self):\n        return bytes(self.to_string(), encoding=ENCODING)\n    \n    def ctx(self, image, **kwargs):\n        return ModeContext(image, self, **kwargs)\n    \n    def dtype_code(self):\n        return dtypes_for_modes.get(self.to_string(), None) or \\\n                                    self.basetype.dtype_code()\n    \n    @property\n    def band_count(self):\n        return len(self.value.bands)\n    \n    @property\n    def bands(self):\n        return self.value.bands\n        \n    @property\n    def basemode(self):\n        return type(self).for_string(self.value.basemode)\n    \n    @property\n    def basetype(self):\n        return type(self).for_string(self.value.basetype)\n    \n    @property\n    def dtype(self):\n        return numpy.dtype(self.dtype_code())\n    \n    @property\n    def is_memory_mapped(self):\n        return junkdrawer.is_mapped(self.to_string())\n    \n    @property\n    def label(self):\n        return str(self) == self.name \\\n                        and self.name \\\n                        or f""{self!s} ({self.name})""\n    \n    def check(self, image):\n        return junkdrawer.imode(image) is self.value\n    \n    def merge(self, *channels):\n        return Image.merge(self.to_string(), channels)\n    \n    def render(self, image, *args, **kwargs):\n        if self.check(image):\n            return image\n        return image.convert(self.to_string(),\n                            *args,\n                           **kwargs)\n    \n    def process(self, image):\n        return self.render(image)\n    \n    def new(self, size, color=0):\n        return Image.new(self.to_string(), size, color=color)\n    \n    def open(self, fileish):\n        return self.render(Image.open(fileish))\n    \n    def frombytes(self, size, data, decoder_name=\'raw\', *args):\n        return Image.frombytes(self.to_string(),\n                               size, data, decoder_name,\n                              *args)\n\ndef test():\n    from pprint import pprint\n    \n    print(""\xc2\xabKNOWN IMAGE MODES\xc2\xbb"")\n    print()\n    \n    for m in Mode:\n        print(""\xe2\x80\xa2 %10s\\t \xe2\x88\x9e%5s/%s : %s \xc2\xbb %s"" % (m.label,\n                                              m.basemode,\n                                              m.basetype,\n                                              m.dtype_code(),\n                                              m.dtype))\n    \n    print()\n    \n    """"""\n    \xe2\x80\xa2   1 (MONO)\t \xe2\x88\x9e    L/L : |b1 \xc2\xbb bool\n    \xe2\x80\xa2          L\t \xe2\x88\x9e    L/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2          I\t \xe2\x88\x9e    L/I : <i4 \xc2\xbb int32\n    \xe2\x80\xa2          F\t \xe2\x88\x9e    L/F : <f4 \xc2\xbb float32\n    \xe2\x80\xa2          P\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2        RGB\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2       RGBX\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2       RGBA\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2       CMYK\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2      YCbCr\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2        LAB\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2        HSV\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2       RGBa\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2         LA\t \xe2\x88\x9e    L/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2         La\t \xe2\x88\x9e    L/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2         PA\t \xe2\x88\x9e  RGB/L : |u1 \xc2\xbb uint8\n    \xe2\x80\xa2 I;16 (I16)\t \xe2\x88\x9e    L/L : <u2 \xc2\xbb uint16\n    \xe2\x80\xa2 I;16L (I16L)\t \xe2\x88\x9e    L/L : <u2 \xc2\xbb uint16\n    \xe2\x80\xa2 I;16B (I16B)\t \xe2\x88\x9e    L/L : >u2 \xc2\xbb >u2\n    \n    """"""\n    \n    print(""\xc2\xabTESTING: split_abbreviations()\xc2\xbb"")\n    \n    assert split_abbreviations(\'RGB\') == (\'R\', \'G\', \'B\')\n    assert split_abbreviations(\'CMYK\') == (\'C\', \'M\', \'Y\', \'K\')\n    assert split_abbreviations(\'YCbCr\') == (\'Y\', \'Cb\', \'Cr\')\n    assert split_abbreviations(\'sRGB\') == (\'R\', \'G\', \'B\')\n    assert split_abbreviations(\'XYZZ\') == (\'X\', \'Y\', \'Z\')\n    assert split_abbreviations(\'I;16L\') == (\'I\',)\n    \n    assert split_abbreviations(\'RGB\') == Mode.RGB.bands\n    assert split_abbreviations(\'CMYK\') == Mode.CMYK.bands\n    assert split_abbreviations(\'YCbCr\') == Mode.YCbCr.bands\n    assert split_abbreviations(\'I;16L\') == Mode.I16L.bands\n    assert split_abbreviations(\'sRGB\') == Mode.RGB.bands\n    # assert split_abbreviations(\'XYZ\') == (\'X\', \'Y\', \'Z\')\n    \n    print(""\xc2\xabSUCCESS\xc2\xbb"")\n    print()\n    \n    # print(Mode.I16L.bands)\n    # print(Mode.RGB.bands)\n    \n    pprint(list(Mode))\n    print()\n    \n    assert Mode(10) == Mode.LAB\n    # assert hasattr(Mode.RGB, \'__slots__\')\n    \n    print()\n    \n    print(""\xc2\xabTESTING: CONTEXT-MANAGED IMAGE MODES\xc2\xbb"")\n    print()\n    from instakit.utils.static import asset\n    \n    image_paths = list(map(\n        lambda image_file: asset.path(\'img\', image_file),\n            asset.listfiles(\'img\')))\n    image_inputs = list(map(\n        lambda image_path: Mode.RGB.open(image_path),\n            image_paths))\n    \n    for image in image_inputs:\n        with Mode.L.ctx(image) as grayscale:\n            assert Mode.of(grayscale.image) is Mode.L\n            print(grayscale.image)\n            grayscale.image = Mode.MONO.process(grayscale.image)\n        print()\n    \n    print(""\xc2\xabSUCCESS\xc2\xbb"")\n    print()\n\nif __name__ == \'__main__\':\n    test()\n'"
instakit/utils/ndarrays.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\nndarrays.py\n\nCreated by FI$H 2000 on 2013-08-23.\nCopyright \xc2\xa9 2012-2019 Objects In Space And Time, LLC. All rights reserved.\n\nThe `bytescale`[0], `fromimage`[1], and `toimage`[2] functions have been\nadapted from the versions published in the now-historic `scipy.misc.pilutils`\nmodule; the last official release of which looks to have been in SciPy 1.1.0:\n\n* [0] https://git.io/fhIoX\n* [1] https://git.io/fhIo1\n* [2] https://git.io/fhIoD\n\n""""""\nfrom __future__ import division, print_function\n\nimport numpy\nfrom instakit.utils.mode import Mode\nfrom instakit.abc import NDProcessorBase\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\nuint8_t = numpy.uint8\nuint32_t = numpy.uint32\nfloat32_t = numpy.float32\n\n@export\ndef bytescale(data, cmin=None, cmax=None,\n                    high=255,  low=0):\n    """"""\n    Byte-scales a `numpy.ndarray` of nd-image data.\n    \n    \xe2\x80\x9cByte scaling\xe2\x80\x9d means 1) casting the input image to the ``uint8_t`` dtype, and\n                         2) scaling the range to ``(low, high)`` (default 0-255).\n    \n    If the input image data is already of dtype ``uint8_t``, no scaling is done.\n    \n    Parameters\n    ----------\n    data : `numpy.ndarray`\n        PIL image data array.\n    cmin : scalar, optional\n        Bias scaling of small values. Default is ``data.min()``.\n    cmax : scalar, optional\n        Bias scaling of large values. Default is ``data.max()``.\n    high : scalar, optional\n        Scale max value to `high`.  Default is 255.\n    low : scalar, optional\n        Scale min value to `low`.  Default is 0.\n    \n    Returns\n    -------\n    array : `numpy.ndarray` of dtype ``uint8_t``\n        The byte-scaled array.\n    """"""\n    if data.dtype == uint8_t:\n        return data\n    \n    if high > 255:\n        raise ValueError(""`high` should be less than or equal to 255."")\n    if low < 0:\n        raise ValueError(""`low` should be greater than or equal to 0."")\n    if high < low:\n        raise ValueError(""`high` should be greater than or equal to `low`."")\n    \n    if cmin is None:\n        cmin = data.min()\n    \n    if cmax is None:\n        cmax = data.max()\n    \n    cscale = cmax - cmin\n    \n    if cscale < 0:\n        raise ValueError(""`cmax` should be larger than `cmin`."")\n    elif cscale == 0:\n        cscale = 1\n    \n    scale = float(high - low) / cscale\n    bytedata = (data - cmin) * scale + low\n    return (bytedata.clip(low, high) + 0.5).astype(uint8_t)\n\n@export\ndef fromimage(image, flatten=False,\n                        mode=None,\n                       dtype=None):\n    """"""\n    Return the data from an input PIL image as a `numpy.ndarray`.\n    \n    Parameters\n    ----------\n    im : PIL image\n        Input image.\n    flatten : bool, optional\n        If true, convert the output to greyscale. Default is False.\n    mode : str / Mode, optional\n        Mode to convert image to, e.g. ``\'RGB\'``. See the Notes of the\n        `imread` docstring for more details.\n    dtype : str / ``numpy.dtype``, optional\n        Numpy dtype to which to cast the output image array data,\n        e.g. ``\'float64\'`` or ``\'uint16\'``. \n    \n    Returns\n    -------\n    fromimage : ndarray (rank 2..3)\n        The individual color channels of the input image are stored in the\n        third dimension, such that greyscale (`L`) images are MxN (rank-2),\n        `RGB` images are MxNx3 (rank-3), and `RGBA` images are MxNx4 (rank-3).\n    """"""\n    from PIL import Image\n    \n    if not Image.isImageType(image):\n        raise TypeError(f""Input is not a PIL image (got {image!r})"")\n    \n    if mode is not None:\n        if not Mode.is_mode(mode):\n            mode = Mode.for_string(mode)\n        image = mode.process(image)\n    elif Mode.of(image) is Mode.P:\n        # Mode \'P\' means there is an indexed ""palette"".  If we leave the mode\n        # as \'P\', then when we do `a = numpy.array(im)` below, `a` will be a 2D\n        # containing the indices into the palette, and not a 3D array\n        # containing the RGB or RGBA values.\n        if \'transparency\' in image.info:\n            image = Mode.RGBA.process(image)\n        else:\n            image = Mode.RGB.process(image)\n    \n    if flatten:\n        image = Mode.F.process(image)\n    elif Mode.of(image) is Mode.MONO:\n        # Workaround for crash in PIL. When im is 1-bit, the call numpy.array(im)\n        # can cause a seg. fault, or generate garbage. See\n        # https://github.com/scipy/scipy/issues/2138 and\n        # https://github.com/python-pillow/Pillow/issues/350.\n        # This converts im from a 1-bit image to an 8-bit image.\n        image = Mode.L.process(image)\n    \n    out = numpy.array(image)\n    \n    if dtype is not None:\n        return out.astype(\n              numpy.dtype(dtype))\n    \n    return out\n\n_errstr = ""Mode unknown or incompatible with input array shape""\n\n@export\ndef toimage(array,  high=255,    low=0,\n                    cmin=None,  cmax=None,\n                     pal=None,\n                    mode=None,\n            channel_axis=None):\n    """"""\n    Takes an input `numpy.ndarray` and returns a PIL image.\n            \n    The mode of the image returned depends on 1) the array shape, and \n                                              2) the `pal` and `mode` keywords.\n    \n    For 2D arrays, if `pal` is a valid (N, 3) rank-2, ``uint8_t`` bytearray --\n    populated with an `RGB` LUT of values from 0 to 255, ``mode=\'P\'`` (256-color\n    single-channel palette mode) will be used; otherwise ``mode=\'L\'`` (256-level\n    single-channel grayscale mode) will be employed -- unless a \xe2\x80\x9cmode\xe2\x80\x9d argument\n    is given, as either \'F\' or \'I\'; in which case conversion to either a float\n    or an integer rank-3 array will be made.\n    \n    .. warning::\n    \n        This function calls `bytescale` under the hood, to rescale the image\n        pixel values across the full (0, 255) ``uint8_t`` range if ``mode``\n        is one of either: ``None, \'L\', \'P\', \'l\'``.\n        \n        It will also cast rank-2 image data to ``uint32_t`` when ``mode=None``\n        (which is the default).\n    \n    Notes\n    -----\n    For 3D arrays, the `channel_axis` argument tells which dimension of the\n    array holds the channel data. If one of the dimensions is 3, the mode\n    is \'RGB\' by default, or \'YCbCr\' if selected.\n    \n    The input `numpy.ndarray` must be either rank-2 or rank-3.\n    """"""\n    from pprint import pformat\n    \n    data = numpy.asarray(array)\n    if numpy.iscomplexobj(data):\n        raise ValueError(""Cannot convert arrays of complex values"")\n    \n    shape = list(data.shape)\n    valid = len(shape) == 2 or ((len(shape) == 3) and\n                                ((3 in shape) or (4 in shape)))\n    if not valid:\n        raise ValueError(""input array lacks a suitable shape for any mode"")\n    \n    if mode is not None:\n        if not Mode.is_mode(mode):\n            mode = Mode.for_string(mode)\n    \n    if len(shape) == 2:\n        shape = (shape[1], shape[0])  # columns show up first\n        \n        if mode is Mode.F:\n            return mode.frombytes(shape, data.astype(float32_t).tostring())\n        \n        if mode in [ None, Mode.L, Mode.P ]:\n            bytedata = bytescale(data, high=high,\n                                       low=low,\n                                       cmin=cmin,\n                                       cmax=cmax)\n            image = Mode.L.frombytes(shape, bytedata.tostring())\n            \n            if pal is not None:\n                image.putpalette(numpy.asarray(pal,\n                                 dtype=uint8_t).tostring()) # Becomes mode=\'P\' automatically\n            elif mode is Mode.P:  # default grayscale\n                pal = (numpy.arange(0, 256, 1, dtype=uint8_t)[:, numpy.newaxis] *\n                       numpy.ones((3,),        dtype=uint8_t)[numpy.newaxis, :])\n                image.putpalette(numpy.asarray(pal,\n                                 dtype=uint8_t).tostring())\n            \n            return image\n        \n        if mode is Mode.MONO:  # high input gives threshold for 1\n            bytedata = (data > high)\n            return mode.frombytes(shape, bytedata.tostring())\n        \n        if cmin is None:\n            cmin = numpy.amin(numpy.ravel(data))\n        \n        if cmax is None:\n            cmax = numpy.amax(numpy.ravel(data))\n        \n        data = (data * 1.0 - cmin) * (high - low) / (cmax - cmin) + low\n        \n        if mode is Mode.I:\n            image = mode.frombytes(shape, data.astype(uint32_t).tostring())\n        else:\n            raise ValueError(_errstr)\n        \n        return image\n    \n    # if here then 3D array with a 3 or a 4 in the shape length.\n    # Check for 3 in datacube shape --- \'RGB\' or \'YCbCr\'\n    if channel_axis is None:\n        if (3 in shape):\n            ca = numpy.flatnonzero(numpy.asarray(shape) == 3)[0]\n        else:\n            ca = numpy.flatnonzero(numpy.asarray(shape) == 4)\n            if len(ca):\n                ca = ca[0]\n            else:\n                raise ValueError(\n                    f""Could not find a channel dimension (shape = {pformat(shape)})"")\n    else:\n        ca = channel_axis\n    \n    numch = shape[ca]\n    if numch not in [3, 4]:\n        raise ValueError(f""Channel dimension invalid (#channels = {numch})"")\n    \n    bytedata = bytescale(data, high=high,\n                               low=low,\n                               cmin=cmin,\n                               cmax=cmax)\n    \n    if ca == 2:\n        strdata = bytedata.tostring()\n        shape = (shape[1], shape[0])\n    elif ca == 1:\n        strdata = numpy.transpose(bytedata, (0, 2, 1)).tostring()\n        shape = (shape[2], shape[0])\n    elif ca == 0:\n        strdata = numpy.transpose(bytedata, (1, 2, 0)).tostring()\n        shape = (shape[2], shape[1])\n    \n    if mode is None:\n        if numch == 3:\n            mode = Mode.RGB\n        else:\n            mode = Mode.RGBA\n    \n    if mode not in [ Mode.RGB, Mode.RGBA, Mode.YCbCr, Mode.CMYK ]:\n        raise ValueError(_errstr)\n    \n    if mode in [ Mode.RGB, Mode.YCbCr ]:\n        if numch != 3:\n            raise ValueError(f""Invalid shape for mode \xe2\x80\x9c{mode}\xe2\x80\x9d: {pformat(shape)}"")\n    if mode in [ Mode.RGBA, Mode.CMYK ]:\n        if numch != 4:\n            raise ValueError(f""Invalid shape for mode \xe2\x80\x9c{mode}\xe2\x80\x9d: {pformat(shape)}"")\n    \n    # Here we know both `strdata` and `mode` are correct:\n    image = mode.frombytes(shape, strdata)\n    return image\n\n@export\nclass NDProcessor(NDProcessorBase):\n    \n    """""" An image processor ancestor class that represents PIL image\n        data in a `numpy.ndarray`. Subclasses can override the\n        `process_nd(\xe2\x80\xa6)` method to receive, transform, and return\n        the image data using NumPy, SciPy, and the like.\n    """"""\n    __slots__ = tuple()\n    \n    def process(self, image):\n        """""" NDProcessor.process(\xe2\x80\xa6) converts its PIL image operand\n            to a `numpy.ndarray`, hands it off to the delegate\n            method NDProcessor.process_nd(\xe2\x80\xa6), and converts whatever\n            that method call returns back to a PIL image before\n            finally returning it.\n        """"""\n        return toimage(self.process_nd(fromimage(image)))\n    \n    @staticmethod\n    def compand(ndimage):\n        """""" The NDProcessor.compand(\xe2\x80\xa6) static method scales a\n            `numpy.ndarray` with floating-point values from 0.0\xc2\xbb1.0\n            to unsigned 8-bit integer values from 0\xc2\xbb255.\n        """"""\n        return uint8_t(float32_t(ndimage) * 255.0)\n    \n    @staticmethod\n    def uncompand(ndimage):\n        """""" The NDProcessor.uncompand(\xe2\x80\xa6) static method scales a\n            `numpy.ndarray` with unsigned 8-bit integer values\n            from 0\xc2\xbb255 to floating-point values from 0.0\xc2\xbb1.0.\n        """"""\n        return float32_t(ndimage) / 255.0\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n\ndef test():\n    """""" Tests for bytescale(\xc2\xac) adapted from `scipy.misc.pilutil` doctests,\n        q.v. https://git.io/fhkHI supra.\n    """"""\n    from instakit.utils.static import asset\n    \n    image_paths = list(map(\n        lambda image_file: asset.path(\'img\', image_file),\n            asset.listfiles(\'img\')))\n    image_inputs = list(map(\n        lambda image_path: Mode.RGB.open(image_path),\n            image_paths))\n    \n    # print()\n    print(""\xc2\xabTESTING: BYTESCALE UTILITY FUNCTION\xc2\xbb"")\n    \n    image = numpy.array((91.06794177,   3.39058326,  84.4221549,\n                         73.88003259,  80.91433048,   4.88878881,\n                         51.53875334,  34.45808177,  27.5873488)).reshape((3, 3))\n    assert numpy.all(\n           bytescale(image) == numpy.array((255,   0, 236,\n                                            205, 225,   4,\n                                            140,  90,  70),\n                                           dtype=uint8_t).reshape((3, 3)))\n    assert numpy.all(\n           bytescale(image,\n                     high=200,\n                     low=100) == numpy.array((200, 100, 192,\n                                              180, 188, 102,\n                                              155, 135, 128),\n                                             dtype=uint8_t).reshape((3, 3)))\n    assert numpy.all(\n           bytescale(image,\n                     cmin=0,\n                     cmax=255) == numpy.array((91,  3, 84,\n                                               74, 81,  5,\n                                               52, 34, 28),\n                                              dtype=uint8_t).reshape((3, 3)))\n    print(""\xc2\xabSUCCESS\xc2\xbb"")\n    print()\n    \n    # print()\n    print(""\xc2\xabTESTING: FROMIMAGE\xc2\xbb"")\n    \n    image_arrays = list(map(\n        lambda image_input: fromimage(image_input),\n            image_inputs))\n    \n    for idx, image_array in enumerate(image_arrays):\n        assert image_array.dtype == uint8_t\n        assert image_array.shape[0] == image_inputs[idx].size[1]\n        assert image_array.shape[1] == image_inputs[idx].size[0]\n    \n    print(""\xc2\xabSUCCESS\xc2\xbb"")\n    print()\n\nif __name__ == \'__main__\':\n    test()'"
instakit/utils/pipeline.py,0,"b'# encoding: utf-8\nfrom __future__ import print_function\n\nfrom PIL import ImageOps, ImageChops\nfrom collections import defaultdict, OrderedDict\nfrom copy import copy\nfrom enum import unique\nfrom functools import wraps\n\nfrom clu.enums import AliasingEnum, alias\nfrom clu.mathematics import \xce\xa3\nfrom clu.predicates import tuplize\nfrom clu.typology import string_types\n\nfrom instakit.abc import Fork, NOOp, Sequence, MutableSequence\nfrom instakit.utils.gcr import BasicGCR\nfrom instakit.utils.mode import Mode\nfrom instakit.processors.adjust import AutoContrast\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\nif not hasattr(__builtins__, \'cmp\'):\n    def cmp(a, b):\n        return (a > b) - (a < b)\n\n@export\nclass Pipe(Sequence):\n    \n    """""" A static linear pipeline of processors to be applied en masse.\n        Derived from a `pilkit` class:\n            `pilkit.processors.base.ProcessorPipeline`\n    """"""\n    __slots__ = tuplize(\'tuple\')\n    \n    @classmethod\n    def base_type(cls):\n        return tuple\n    \n    @wraps(tuple.__init__)\n    def __init__(self, *args):\n        self.tuple = tuplize(*args)\n    \n    def iterate(self):\n        yield from self.tuple\n    \n    @wraps(tuple.__len__)\n    def __len__(self):\n        return len(self.tuple)\n    \n    @wraps(tuple.__contains__)\n    def __contains__(self, value):\n        return value in self.tuple\n    \n    @wraps(tuple.__getitem__)\n    def __getitem__(self, idx):\n        return self.tuple[idx]\n    \n    @wraps(tuple.index)\n    def index(self, value):\n        return self.tuple.index(value)\n    \n    def last(self):\n        if not bool(self):\n            raise IndexError(""pipe is empty"")\n        return self.tuple[-1]\n    \n    def process(self, image):\n        for processor in self.iterate():\n            image = processor.process(image)\n        return image\n    \n    def __eq__(self, other):\n        if not isinstance(other, (type(self), type(self).base_type())):\n            return NotImplemented\n        return super(Pipe, self).__eq__(other)\n\n@export\nclass Pipeline(MutableSequence):\n    \n    """""" A mutable linear pipeline of processors to be applied en masse.\n        Derived from a `pilkit` class:\n            `pilkit.processors.base.ProcessorPipeline`\n    """"""\n    __slots__ = tuplize(\'list\')\n    \n    @classmethod\n    def base_type(cls):\n        return list\n    \n    @wraps(list.__init__)\n    def __init__(self, *args):\n        base_type = type(self).base_type()\n        if len(args) == 0:\n            self.list = base_type()\n        if len(args) == 1:\n            target = args[0]\n            if type(target) is type(self):\n                self.list = copy(target.list)\n            elif type(target) is base_type:\n                self.list = copy(target)\n            elif type(target) in (tuple, set, frozenset):\n                self.list = base_type([*target])\n            elif type(target) in (dict, defaultdict, OrderedDict):\n                self.list = base_type([*sorted(target).values()])\n            elif hasattr(target, \'iterate\'):\n                self.list = base_type([*target.iterate()])\n            elif hasattr(target, \'__iter__\'):\n                self.list = base_type([*target])\n            else:\n                self.list = base_type([target])\n        else:\n            self.list = base_type([*args])\n    \n    def iterate(self):\n        yield from self.list\n    \n    @wraps(list.__len__)\n    def __len__(self):\n        return len(self.list)\n    \n    @wraps(list.__contains__)\n    def __contains__(self, value):\n        return value in self.list\n    \n    @wraps(list.__getitem__)\n    def __getitem__(self, idx):\n        return self.list[idx]\n    \n    @wraps(list.__setitem__)\n    def __setitem__(self, idx, value):\n        if value in (None, NOOp):\n            value = NOOp()\n        self.list[idx] = value\n    \n    @wraps(list.__delitem__)\n    def __delitem__(self, idx):\n        del self.list[idx]\n    \n    @wraps(list.index)\n    def index(self, value):\n        return self.list.index(value)\n    \n    @wraps(list.append)\n    def append(self, value):\n        self.list.append(value)\n    \n    @wraps(list.extend)\n    def extend(self, iterable):\n        self.list.extend(iterable)\n    \n    def pop(self, idx=-1):\n        """""" Remove and return item at `idx` (default last).\n            Raises IndexError if list is empty or `idx` is out of range.\n            See list.pop(\xe2\x80\xa6) for details.\n        """"""\n        self.list.pop(idx)\n    \n    def last(self):\n        if not bool(self):\n            raise IndexError(""pipe is empty"")\n        return self.list[-1]\n    \n    def process(self, image):\n        for processor in self.iterate():\n            image = processor.process(image)\n        return image\n    \n    def __eq__(self, other):\n        if not isinstance(other, (type(self), type(self).base_type())):\n            return NotImplemented\n        return super(Pipe, self).__eq__(other)\n\n@export\nclass BandFork(Fork):\n    \n    """""" BandFork is a processor container -- a processor that applies other\n        processors. BandFork acts selectively on the individual bands of\n        input image data, either:\n        - applying a band-specific processor instance, or\n        - applying a default processor factory successively across all bands.\n        \n        BandFork\xe2\x80\x99s interface is closely aligned with Python\xe2\x80\x99s mutable-mapping\n        API\xe2\x80\xa1 -- with which most programmers are no doubt quite familiar:\n        \n        \xe2\x80\xa2 Ex. 1: apply Atkinson dithering to each of an RGB images\xe2\x80\x99 bands:\n        >>> from instakit.utils.pipeline import BandFork\n        >>> from instakit.processors.halftone import Atkinson\n        >>> BandFork(Atkinson).process(my_image)\n        \n        \xe2\x80\xa2 Ex. 2: apply Atkinson dithering to only the green band:\n        >>> from instakit.utils.pipeline import BandFork\n        >>> from instakit.processors.halftone import Atkinson\n        >>> bfork = BandFork(None)\n        >>> bfork[\'G\'] = Atkinson()\n        >>> bfork.process(my_image)\n        \n        BandFork inherits from `instakit.abc.Fork`, which itself is not just\n        an Instakit Processor. The Fork ABC implements the required methods\n        of an Instakit Processor Container\xe2\x80\xa0, through which it furnishes an\n        interface to individual bands -- also generally known as channels,\n        per the language of the relevant Photoshop UI elements -- of image\n        data. \n        \n        \xe2\x80\xa0 q.v. the `instakit.abc` module source code supra.\n        \xe2\x80\xa1 q.v. the `collections.abc` module, and the `MutableMapping`\n                    abstract base class within, supra.\n    """"""\n    __slots__ = tuplize(\'mode_t\')\n    \n    def __init__(self, processor_factory, *args, **kwargs):\n        """""" Initialize a BandFork instance, using the given callable value\n            for `processor_factory` and any band-appropriate keyword-arguments,\n            e.g. `(R=MyProcessor, G=MyOtherProcessor, B=None)`\n        """"""\n        # Call `super(\xe2\x80\xa6)`, passing `processor_factory`:\n        super(BandFork, self).__init__(processor_factory, *args, **kwargs)\n        \n        # Reset `self.mode_t` if a new mode was specified --\n        # N.B. we can\xe2\x80\x99t use the \xe2\x80\x9cself.mode\xe2\x80\x9d property during \xe2\x80\x9c__init__(\xe2\x80\xa6)\xe2\x80\x9d:\n        self.mode_t = kwargs.pop(\'mode\', Mode.RGB)\n    \n    @property\n    def mode(self):\n        return self.mode_t\n    \n    @mode.setter\n    def mode(self, value):\n        if value is None:\n            return\n        if type(value) in string_types:\n            value = Mode.for_string(value)\n        if Mode.is_mode(value):\n            # if value is not self.mode_t:\n            self.set_mode_t(value)\n        else:\n            raise TypeError(""invalid mode type: %s (%s)"" % (type(value), value))\n    \n    def set_mode_t(self, value):\n        self.mode_t = value # DOUBLE SHADOW!!\n    \n    @property\n    def band_labels(self):\n        return self.mode.bands\n    \n    def iterate(self):\n        yield from (self[band_label] for band_label in self.band_labels)\n    \n    def split(self, image):\n        return self.mode.process(image).split()\n    \n    def compose(self, *bands):\n        return self.mode.merge(*bands)\n    \n    def process(self, image):\n        processed = []\n        for processor, band in zip(self.iterate(),\n                                   self.split(image)):\n            processed.append(processor.process(band))\n        return self.compose(*processed)\n\nChannelFork = BandFork\n\nink_values = (\n    (255, 255, 255),    # White\n    (0,   250, 250),    # Cyan\n    (250, 0,   250),    # Magenta\n    (250, 250, 0),      # Yellow\n    (0,   0,   0),      # Key (blacK)\n    (255, 0,   0),      # Red\n    (0,   255, 0),      # Green\n    (0,   0,   255),    # Blue\n)\n\nclass Ink(AliasingEnum):\n    \n    def rgb(self):\n        return ink_values[self.value]\n    \n    def process(self, image):\n        InkType = type(self)\n        return ImageOps.colorize(Mode.L.process(image),\n                                 InkType(0).rgb(),\n                                 InkType(self.value).rgb())\n\n@unique\nclass CMYKInk(Ink):\n    \n    WHITE       = 0\n    CYAN        = 1\n    MAGENTA     = 2\n    YELLOW      = 3\n    KEY         = 4\n    BLACK       = alias(KEY)\n    \n    @classmethod\n    def CMYK(cls):\n        return (cls.CYAN, cls.MAGENTA, cls.YELLOW, cls.BLACK)\n    \n    @classmethod\n    def CMY(cls):\n        return (cls.CYAN, cls.MAGENTA, cls.YELLOW)\n\n@unique\nclass RGBInk(Ink):\n    \n    WHITE       = 0\n    RED         = 5\n    GREEN       = 6\n    BLUE        = 7\n    KEY         = 4\n    BLACK       = alias(KEY)\n    \n    @classmethod\n    def RGB(cls):\n        return (cls.RED, cls.GREEN, cls.BLUE)\n    \n    @classmethod\n    def BGR(cls):\n        return (cls.BLUE, cls.GREEN, cls.RED)\n\n@export\nclass OverprintFork(BandFork):\n    \n    """""" A BandFork subclass that rebuilds its output image using multiply-mode\n        to simulate CMYK overprinting effects.\n        \n        N.B. While this Fork-based processor operates strictly in CMYK mode,\n        the composite image it eventually returns will be in RGB mode. This is\n        because the CMYK channels are each individually converted to colorized\n        representations in order to simulate monotone ink preparations; the\n        final compositing operation, in which these colorized channel separation\n        images are combined with multiply-mode, is also computed using the RGB\n        color model -- q.v. the CMYKInk enum processor supra. and the related\n        PIL/Pillow module function `ImageOps.colorize(\xe2\x80\xa6)` supra.\n    """"""\n    __slots__ = (\'contrast\', \'basicgcr\')\n    \n    inks = CMYKInk.CMYK()\n    \n    def __init__(self, processor_factory, gcr=20, *args, **kwargs):\n        """""" Initialize an OverprintFork instance with the given callable value\n            for `processor_factory` and any band-appropriate keyword-arguments,\n            e.g. `(C=MyProcessor, M=MyOtherProcessor, Y=MyProcessor, K=None)`\n        """"""\n        # Store BasicGCR and AutoContrast processors:\n        self.contrast = AutoContrast()\n        self.basicgcr = BasicGCR(percentage=gcr)\n        \n        # Call `super(\xe2\x80\xa6)`, passing `processor_factory`:\n        super(OverprintFork, self).__init__(processor_factory, *args, mode=Mode.CMYK,\n                                                              **kwargs)\n        \n        # Make each band-processor a Pipeline() ending in\n        # the channel-appropriate CMYKInk enum processor:\n        self.apply_CMYK_inks()\n    \n    def apply_CMYK_inks(self):\n        """""" This method ensures that each bands\xe2\x80\x99 processor is set up\n            as a Pipe() or Pipeline() ending in a CMYKInk corresponding\n            to the band in question. Calling it multiple times *should*\n            be idempotent (but don\xe2\x80\x99t quote me on that)\n        """"""\n        for band_label, ink in zip(self.band_labels,\n                              type(self).inks):\n            processor = self[band_label]\n            if processor is None:\n                self[band_label] = Pipe(ink)\n            elif hasattr(processor, \'append\'):\n                if processor[-1] is not ink:\n                    processor.append(ink)\n                    self[band_label] = processor\n            elif hasattr(processor, \'last\'):\n                if processor.last() is not ink:\n                    self[band_label] = Pipe(*processor.iterate(), ink)\n            else:\n                self[band_label] = Pipe(processor, ink)\n    \n    def set_mode_t(self, value):\n        """""" Raise an exception if an attempt is made to set the mode to anything\n            other than CMYK\n        """"""\n        if value is not Mode.CMYK:\n            raise AttributeError(\n                ""OverprintFork only works in %s mode"" % Mode.CMYK.to_string())\n    \n    def update(self, iterable=None, **kwargs):\n        """""" OverprintFork.update(\xe2\x80\xa6) re-applies CMYK ink processors to the\n            updated processing dataflow\n        """"""\n        super(OverprintFork, self).update(iterable, **kwargs)\n        self.apply_CMYK_inks()\n    \n    def split(self, image):\n        """""" OverprintFork.split(image) uses imagekit.utils.gcr.BasicGCR(\xe2\x80\xa6) to perform\n            gray-component replacement in CMYK-mode images; for more information,\n            see the imagekit.utils.gcr module\n        """"""\n        return self.basicgcr.process(image).split()\n    \n    def compose(self, *bands):\n        """""" OverprintFork.compose(\xe2\x80\xa6) uses PIL.ImageChops.multiply() to create\n            the final composite image output\n        """"""\n        return \xce\xa3(ImageChops.multiply, bands)\n\nclass Grid(Fork):\n    pass\n\nclass Sequence(Fork):\n    pass\n\nChannelOverprinter = OverprintFork\n\nexport(ChannelFork,         name=\'ChannelFork\')\nexport(ChannelOverprinter,  name=\'ChannelOverprinter\')\nexport(CMYKInk,             name=\'CMYKInk\',         doc=""CMYKInk \xe2\x86\x92 Enumeration class furnishing CMYK primitive triple values"")\nexport(RGBInk,              name=\'RGBInk\',          doc=""RGBInk \xe2\x86\x92 Enumeration class furnishing RGB primitive triple values"")\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n\ndef test():\n    from pprint import pprint\n    from instakit.utils.static import asset\n    from instakit.processors.halftone import Atkinson\n    \n    image_paths = list(map(\n        lambda image_file: asset.path(\'img\', image_file),\n            asset.listfiles(\'img\')))\n    image_inputs = list(map(\n        lambda image_path: Mode.RGB.open(image_path),\n            image_paths))\n    \n    for image_input in image_inputs[:2]:\n        OverprintFork(Atkinson).process(image_input).show()\n        \n        print(\'Creating OverprintFork and BandFork with Atkinson ditherer...\')\n        overatkins = OverprintFork(Atkinson)\n        forkatkins = BandFork(Atkinson)\n        \n        print(\'Processing image with BandForked Atkinson in default (RGB) mode...\')\n        forkatkins.process(image_input).show()\n        forkatkins.mode = \'CMYK\'\n        print(\'Processing image with BandForked Atkinson in CMYK mode...\')\n        forkatkins.process(image_input).show()\n        forkatkins.mode = \'RGB\'\n        print(\'Processing image with BandForked Atkinson in RGB mode...\')\n        forkatkins.process(image_input).show()\n        \n        overatkins.mode = \'CMYK\'\n        print(\'Processing image with OverprintFork-ized Atkinson in CMYK mode...\')\n        overatkins.process(image_input).show()\n        \n        print(\'Attempting to reset OverprintFork to RGB mode...\')\n        import traceback, sys\n        try:\n            overatkins.mode = \'RGB\'\n            overatkins.process(image_input).show()\n        except:\n            print("">>>>>>>>>>>>>>>>>>>>> TRACEBACK <<<<<<<<<<<<<<<<<<<<<"")\n            traceback.print_exc(file=sys.stdout)\n            print(""<<<<<<<<<<<<<<<<<<<<< KCABECART >>>>>>>>>>>>>>>>>>>>>"")\n            print(\'\')\n    \n    bandfork = BandFork(None)\n    pprint(bandfork)\n    \n    print(image_paths)\n\nif __name__ == \'__main__\':\n    test()\n'"
instakit/utils/static.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nimport os\n\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\nprojectdir = os.path.join(os.path.dirname(__file__), \'..\', \'..\')\nnamespaces = set()\n\n@export\ndef static_namespace(name):\n    """""" Configure and return a clu.typespace.namespace.Namespace instance,\n        festooning it with shortcuts allowing for accesing static files\n        within subdirectories of the Instakit project package tree.\n    """"""\n    from clu.typespace.namespace import SimpleNamespace as Namespace\n    ns = Namespace()\n    ns.name = str(name)\n    ns.root = os.path.join(projectdir, ns.name)\n    ns.data = os.path.join(ns.root, \'data\')\n    ns.relative = lambda p: os.path.relpath(p, start=ns.root)\n    ns.listfiles = lambda *p: os.listdir(os.path.join(ns.data, *p))\n    ns.path = lambda *p: os.path.abspath(os.path.join(ns.data, *p))\n    namespaces.add(ns)\n    return ns\n\nasset = static_namespace(\'instakit\')\ntests = static_namespace(\'tests\')\n\nexport(projectdir,      name=\'projectdir\')\nexport(namespaces,      name=\'namespaces\')\nexport(asset,           name=\'asset\',       doc=""asset \xe2\x86\x92 static namespace relative to the Instakit package assets"")\nexport(tests,           name=\'tests\',       doc=""tests \xe2\x86\x92 static namespace relative to the Instakit testing assets"")\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()\n\ndef test():\n    assert os.path.isdir(projectdir)\n    assert len(namespaces) == 2\n    \n    assert os.path.isdir(asset.root)\n    assert os.path.isdir(asset.data)\n    assert len(asset.listfiles(\'acv\')) > 0\n    assert len(asset.listfiles(\'icc\')) > 0\n    assert len(asset.listfiles(\'img\')) > 0\n    assert len(asset.listfiles(\'lut\')) > 0\n    \n    assert os.path.isdir(tests.root)\n    assert os.path.isdir(tests.data)\n    assert len(os.listdir(tests.data)) > 0\n\nif __name__ == \'__main__\':\n    test()\n'"
instakit/utils/stats.py,0,"b'#!/usr/bin/env python\n# encoding: utf-8\n""""""\nstats.py\n\nCreated by FI$H 2000 on 2018-12-24.\nCopyright (c) 2018 Objects In Space And Time, LLC. All rights reserved.\n""""""\nfrom __future__ import print_function\nfrom instakit.utils.mode import Mode\nfrom instakit.exporting import Exporter\n\nexporter = Exporter(path=__file__)\nexport = exporter.decorator()\n\n@export\ndef pixel_count(image):\n    """""" Return the number of pixels in the input image. """"""\n    width, height = image.size\n    return width * height\n\n@export\ndef color_count(image):\n    """""" Return the number of color values in the input image --\n        this is the number of pixels times the band count\n        of the image.\n    """"""\n    width, height = image.size\n    return width * height * Mode.of(image).band_count\n\n@export\ndef histogram_sum(image):\n    """""" Return the sum of the input images\xe2\x80\x99 histogram values --\n        Basically this is an optimized way of doing:\n            \n            out = 0.0\n            histogram = Mode.L.process(image).histogram()\n            for value, count in enumerate(histogram):\n                out += value * count\n            return out\n            \n        \xe2\x80\xa6 the one-liner uses the much faster sum(\xe2\x80\xa6) in l\xc3\xa9u\n        of looping over the histogram\xe2\x80\x99s enumerated values.\n    """"""\n    histogram = Mode.L.process(image).histogram()\n    return sum(value * count for value, count in enumerate(histogram))\n\n@export\ndef histogram_mean(image):\n    """""" Return the mean of the input images\xe2\x80\x99 histogram values. """"""\n    return float(histogram_sum(image)) / pixel_count(image)\n\n@export\ndef histogram_entropy_py(image):\n    """""" Calculate the entropy of an images\' histogram. """"""\n    from math import log2, fsum\n    histosum = float(color_count(image))\n    histonorm = (histocol / histosum for histocol in image.histogram())\n    \n    return -fsum(p * log2(p) for p in histonorm if p != 0.0)\n\nfrom PIL import Image\n\nhistogram_entropy = hasattr(Image.Image, \'entropy\') \\\n                        and Image.Image.entropy \\\n                        or histogram_entropy_py\n\nexport(histogram_entropy,   name=\'histogram_entropy\')\n\n# Assign the modules\xe2\x80\x99 `__all__` and `__dir__` using the exporter:\n__all__, __dir__ = exporter.all_and_dir()'"
instakit/comparators/ext/__init__.py,0,"b'from pkgutil import extend_path\n__path__ = extend_path(__path__, __name__)\n'"
instakit/processors/ext/__init__.py,0,"b'from pkgutil import extend_path\n__path__ = extend_path(__path__, __name__)\n'"
instakit/utils/ext/__init__.py,0,b''
