file_path,api_count,code
setup.py,0,"b'import os\nfrom setuptools import setup, find_packages\n\nDISTNAME = \'sparse_dot_mkl\'\nVERSION = \'0.5.1\'\nDESCRIPTION = ""Intel MKL wrapper for sparse matrix multiplication""\nMAINTAINER = \'Chris Jackson\'\nMAINTAINER_EMAIL = \'cj59@nyu.edu\'\nURL = \'https://github.com/flatironinstitute/sparse_dot\'\nLICENSE = \'MIT\'\n\n# Description from README.md\nbase_dir = os.path.dirname(os.path.abspath(__file__))\nlong_description = ""\\n\\n"".join([open(os.path.join(base_dir, ""README.md""), ""r"").read()])\n\nsetup(name=DISTNAME,\n      version=VERSION,\n      description=DESCRIPTION,\n      long_description=long_description,\n      long_description_content_type=""text/markdown"",\n      url=URL,\n      author=MAINTAINER,\n      author_email=MAINTAINER_EMAIL,\n      license=LICENSE,\n      packages=find_packages(include=[\'sparse_dot_mkl\', ""sparse_dot_mkl.*""]),\n      install_requires=[\'numpy\', \'scipy\'],\n      tests_require=[\'nose\', \'coverage\'],\n      test_suite=""nose.collector"",\n      zip_safe=True,\n      classifiers=[\n            ""Programming Language :: Python :: 3"",\n            ""License :: OSI Approved :: MIT License"",\n            ""Operating System :: OS Independent"",\n            ""Development Status :: 4 - Beta""\n      ]\n)\n'"
sparse_dot_mkl/__init__.py,0,"b'from sparse_dot_mkl.sparse_dot import dot_product_mkl, dot_product_transpose_mkl, get_version_string, gram_matrix_mkl, sparse_qr_solve_mkl'"
sparse_dot_mkl/_dense_dense.py,4,"b'from sparse_dot_mkl._mkl_interface import (MKL, _type_check, _sanity_check, _empty_output_check, _get_numpy_layout,\n                                           LAYOUT_CODE_C, LAYOUT_CODE_F)\n\nimport numpy as np\nimport ctypes as _ctypes\n\n\ndef _dense_matmul(matrix_a, matrix_b, double_precision, scalar=1.):\n\n    # Reshape matrix_b to a column instead of a vector if it\'s 1d\n    flatten_output = matrix_b.ndim == 1\n    matrix_b = matrix_b.reshape(-1, 1) if flatten_output else matrix_b\n\n    # Get dimensions\n    m, n, k = matrix_a.shape[0], matrix_b.shape[1], matrix_a.shape[1]\n    output_shape = (m, n)\n\n    # Set the MKL function for precision\n    func = MKL._cblas_dgemm if double_precision else MKL._cblas_sgemm\n\n    # Get the memory order for arrays\n    layout_a, ld_a = _get_numpy_layout(matrix_a)\n    layout_b, ld_b = _get_numpy_layout(matrix_b)\n\n    # If they aren\'t the same, use the order for matrix a and have matrix b transposed\n    op_b = 112 if layout_b != layout_a else 111\n\n    # Set output array; use the memory order from matrix_a\n    out_order, ld_out = (""C"", output_shape[1]) if layout_a == LAYOUT_CODE_C else (""F"", output_shape[0])\n\n    # Allocate an array for outputs and set functions and types for float or doubles\n    output_arr = np.zeros(output_shape, dtype=np.float64 if double_precision else np.float32, order=out_order)\n    output_ctype = _ctypes.c_double if double_precision else _ctypes.c_float\n\n    func(layout_a,\n         111,\n         op_b,\n         m,\n         n,\n         k,\n         scalar,\n         matrix_a,\n         ld_a,\n         matrix_b,\n         ld_b,\n         1.,\n         output_arr.ctypes.data_as(_ctypes.POINTER(output_ctype)),\n         ld_out)\n\n    return output_arr.ravel() if flatten_output else output_arr\n\n\ndef _dense_dot_dense(matrix_a, matrix_b, cast=False, dprint=print, scalar=1.):\n\n    _sanity_check(matrix_a, matrix_b, allow_vector=True)\n\n    # Check for edge condition inputs which result in empty outputs\n    if _empty_output_check(matrix_a, matrix_b):\n        dprint(""Skipping multiplication because A (dot) B must yield an empty matrix"")\n        final_dtype = np.float64 if matrix_a.dtype != matrix_b.dtype or matrix_a.dtype != np.float32 else np.float32\n        return np.zeros((matrix_a.shape[0], matrix_b.shape[1]), dtype=final_dtype)\n\n    matrix_a, matrix_b = _type_check(matrix_a, matrix_b, cast=cast, dprint=dprint)\n\n    a_dbl, b_dbl = matrix_a.dtype == np.float64, matrix_b.dtype == np.float64\n\n    return _dense_matmul(matrix_a, matrix_b, a_dbl or b_dbl, scalar=scalar)\n'"
sparse_dot_mkl/_gram_matrix.py,7,"b'from sparse_dot_mkl._mkl_interface import (MKL, sparse_matrix_t, RETURN_CODES, _create_mkl_sparse,\n                                           _export_mkl, _order_mkl_handle, _destroy_mkl_handle, _type_check,\n                                           _get_numpy_layout, _convert_to_csr, _empty_output_check, LAYOUT_CODE_C)\n\nimport scipy.sparse as _sps\nimport ctypes as _ctypes\nimport numpy as np\n\n\ndef _gram_matrix_sparse(matrix_a, aat=False, reorder_output=False):\n    """"""\n    Calculate the gram matrix aTa for sparse matrix and return a sparse matrix\n\n    :param matrix_a: Sparse matrix\n    :type matrix_a: scipy.sparse.csr_matrix, scipy.sparse.csc_matrix\n    :param aat: Return A (dot) AT instead of AT (dot) A\n    :type aat: bool\n    :param reorder_output:\n    :type reorder_output: bool\n    :return: Sparse matrix\n    :rtype: scipy.sparse.csr_matrix\n    """"""\n\n    sp_ref_a, double_prec = _create_mkl_sparse(matrix_a)\n\n    if _sps.isspmatrix_csc(matrix_a):\n        sp_ref_a = _convert_to_csr(sp_ref_a)\n\n    _order_mkl_handle(sp_ref_a)\n\n    ref_handle = sparse_matrix_t()\n\n    ret_val = MKL._mkl_sparse_syrk(10 if aat else 11,\n                                   sp_ref_a,\n                                   _ctypes.byref(ref_handle))\n\n    # Check return\n    if ret_val != 0:\n        raise ValueError(""mkl_sparse_syrk returned {v} ({e})"".format(v=ret_val, e=RETURN_CODES[ret_val]))\n\n    if reorder_output:\n        _order_mkl_handle(ref_handle)\n\n    output_arr = _export_mkl(ref_handle, double_prec, output_type=""csr"")\n\n    _destroy_mkl_handle(sp_ref_a)\n    _destroy_mkl_handle(ref_handle)\n\n    return output_arr\n\n\ndef _gram_matrix_sparse_to_dense(matrix_a, aat=False, scalar=1.):\n    """"""\n    Calculate the gram matrix aTa for sparse matrix and return a dense matrix\n\n    :param matrix_a: Sparse matrix\n    :type matrix_a: scipy.sparse.csr_matrix, scipy.sparse.csc_matrix\n    :param aat: Return A (dot) AT instead of AT (dot) A\n    :type aat: bool\n    :param scalar: Multiply output by a scalar value\n    :type scalar: float\n    :return: Dense matrix\n    :rtype: numpy.ndarray\n    """"""\n\n    sp_ref_a, double_prec = _create_mkl_sparse(matrix_a)\n\n    if _sps.isspmatrix_csc(matrix_a):\n        sp_ref_a = _convert_to_csr(sp_ref_a, destroy_original=True)\n\n    _order_mkl_handle(sp_ref_a)\n\n    out_dtype = np.float64 if double_prec else np.float32\n    output_ctype = _ctypes.c_double if double_prec else _ctypes.c_float\n    out_dim = matrix_a.shape[0] if aat else matrix_a.shape[1]\n\n    output_arr = np.zeros((out_dim, out_dim), dtype=out_dtype, order=""C"")\n    _, output_ld = _get_numpy_layout(output_arr)\n\n    if _empty_output_check(matrix_a, matrix_a):\n        return output_arr\n\n    func = MKL._mkl_sparse_d_syrkd if double_prec else MKL._mkl_sparse_s_syrkd\n\n    ret_val = func(10 if aat else 11,\n                   sp_ref_a,\n                   scalar,\n                   1.,\n                   output_arr.ctypes.data_as(_ctypes.POINTER(output_ctype)),\n                   LAYOUT_CODE_C,\n                   output_ld)\n\n    # Check return\n    if ret_val != 0:\n        err_msg = ""{fn} returned {v} ({e})"".format(fn=func.__name__, v=ret_val, e=RETURN_CODES[ret_val])\n        raise ValueError(err_msg)\n\n    _destroy_mkl_handle(sp_ref_a)\n\n    # This fixes a specific bug in mkl_sparse_d_syrkd which returns a full matrix\n    # This stupid thing only happens with specific flags\n    # I could probably leave it but it\'s pretty annoying\n    if not aat:\n        output_arr[np.tril_indices(output_arr.shape[0], k=-1)] = 0.\n\n    return output_arr\n\n\ndef _gram_matrix_dense_to_dense(matrix_a, aat=False, scalar=1.):\n    """"""\n    Calculate the gram matrix aTa for dense matrix and return a dense matrix\n\n    :param matrix_a: Dense matrix\n    :type matrix_a: numpy.ndarray\n    :param aat: Return A (dot) AT instead of AT (dot) A\n    :type aat: bool\n    :param scalar: Multiply output by a scalar value\n    :type scalar: float\n    :return: Dense matrix\n    :rtype: numpy.ndarray\n    """"""\n\n    # Get dimensions\n    n, k = matrix_a.shape if aat else matrix_a.shape[::-1]\n\n    # Get the memory order for arrays\n    layout_a, ld_a = _get_numpy_layout(matrix_a)\n    double_precision = matrix_a.dtype == np.float64\n\n    # Set the MKL function for precision\n    func = MKL._cblas_dsyrk if double_precision else MKL._cblas_ssyrk\n    output_ctype = _ctypes.c_double if double_precision else _ctypes.c_float\n\n    # Allocate an array for outputs and set functions and types for float or doubles\n    output_arr = np.zeros((n, n), dtype=matrix_a.dtype, order=""C"" if layout_a == LAYOUT_CODE_C else ""F"")\n\n    func(layout_a,\n         121,\n         111 if aat else 112,\n         n,\n         k,\n         scalar,\n         matrix_a,\n         ld_a,\n         1.,\n         output_arr.ctypes.data_as(_ctypes.POINTER(output_ctype)),\n         n)\n\n    return output_arr\n\n\ndef _gram_matrix(matrix, transpose=False, cast=False, dense=False, reorder_output=False, dprint=print):\n    """"""\n    Calculate a gram matrix (AT (dot) A) from a sparse matrix.\n\n    :param matrix: Sparse matrix (CSR format is required but will convert if cast is True)\n    :type matrix: scipy.sparse.csr_matrix\n    :param transpose: Calculate A (dot) AT instead\n    :type transpose: bool\n    :param cast: Make internal copies to convert matrix to a float matrix or convert to a CSR matrix if necessary\n    :type cast: bool\n    :param dense: Produce a dense matrix output instead of a sparse matrix\n    :type dense: bool\n    :return: Gram matrix\n    :rtype: scipy.sparse.csr_matrix, np.ndarray\n    """"""\n\n    # Check for edge condition inputs which result in empty outputs\n    if _empty_output_check(matrix, matrix):\n        dprint(""Skipping multiplication because AT (dot) A must yield an empty matrix"")\n        output_shape = (matrix.shape[1], matrix.shape[1]) if transpose else (matrix.shape[0], matrix.shape[0])\n        output_func = _sps.csr_matrix if _sps.isspmatrix(matrix) else np.zeros\n        return output_func(output_shape, dtype=matrix.dtype)\n\n    matrix = _type_check(matrix, cast=cast, dprint=dprint)\n\n    if _sps.isspmatrix(matrix) and not (_sps.isspmatrix_csr(matrix) or _sps.isspmatrix_csc(matrix)):\n        raise ValueError(""gram_matrix requires sparse matrix to be CSR or CSC format"")\n    if _sps.isspmatrix_csc(matrix) and not cast:\n        raise ValueError(""gram_matrix cannot use a CSC matrix unless cast=True"")\n    elif not _sps.isspmatrix(matrix):\n        return _gram_matrix_dense_to_dense(matrix, aat=transpose)\n    elif dense:\n        return _gram_matrix_sparse_to_dense(matrix, aat=transpose)\n    else:\n        return _gram_matrix_sparse(matrix, aat=transpose, reorder_output=reorder_output)\n\n\n'"
sparse_dot_mkl/_mkl_interface.py,20,"b'import warnings\nimport ctypes as _ctypes\nimport ctypes.util as _ctypes_util\n\n# Load mkl_spblas through the libmkl_rt common interface\n_libmkl, _libmkl_loading_errors = None, []\ntry:\n    so_file = _ctypes_util.find_library(\'mkl_rt\')\n    _libmkl = _ctypes.cdll.LoadLibrary(so_file)    \nexcept (OSError, ImportError) as err:\n    _libmkl_loading_errors.append(err)\n\nif _libmkl._name is None:\n    ierr_msg = ""Unable to load the MKL libraries through libmkl_rt. Try setting $LD_LIBRARY_PATH.""\n    ierr_msg += ""\\n\\t"" + ""\\n\\t"".join(map(lambda x: str(x), _libmkl_loading_errors))\n    raise ImportError(ierr_msg)\n\n# Use mkl-service to check version if it\'s installed\n# Since it\'s not on PyPi I don\'t want to make this an actual package dependency\n# So without it just create mock functions and don\'t do version checking\ntry:\n    from mkl import get_version, get_version_string\nexcept ImportError:\n    def get_version():\n        return None\n\n    def get_version_string():\n        return None\n\nif get_version() is not None and get_version()[""MajorVersion""] < 2020:\n    msg = ""Loaded version of MKL is out of date: {v}"".format(v=get_version_string())\n    warnings.warn(msg)\n\nimport numpy as np\nimport scipy.sparse as _spsparse\nfrom numpy.ctypeslib import ndpointer, as_array\n\nNUMPY_FLOAT_DTYPES = [np.float32, np.float64]\n\n\nclass MKL:\n    """""" This class holds shared object references to C functions with arg and returntypes that can be adjusted""""""\n\n    MKL_INT = None\n    MKL_INT_NUMPY = None\n\n    # Import function for creating a MKL CSR object\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-create-csr\n    _mkl_sparse_d_create_csr = _libmkl.mkl_sparse_d_create_csr\n\n    # Import function for creating a MKL CSR object\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-create-csr\n    _mkl_sparse_s_create_csr = _libmkl.mkl_sparse_s_create_csr\n\n    # Import function for creating a MKL CSC object\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-create-csc\n    _mkl_sparse_d_create_csc = _libmkl.mkl_sparse_d_create_csc\n\n    # Import function for creating a MKL CSC object\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-create-csc\n    _mkl_sparse_s_create_csc = _libmkl.mkl_sparse_s_create_csc\n\n    # Export function for exporting a MKL CSR object\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-export-csr\n    _mkl_sparse_d_export_csr = _libmkl.mkl_sparse_d_export_csr\n\n    # Export function for exporting a MKL CSR object\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-export-csr\n    _mkl_sparse_s_export_csr = _libmkl.mkl_sparse_s_export_csr\n\n    # Export function for exporting a MKL CSC object\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-export-csc\n    _mkl_sparse_d_export_csc = _libmkl.mkl_sparse_d_export_csc\n\n    # Export function for exporting a MKL CSC object\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-export-csc\n    _mkl_sparse_s_export_csc = _libmkl.mkl_sparse_s_export_csc\n\n    # Import function for matmul\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-spmm\n    _mkl_sparse_spmm = _libmkl.mkl_sparse_spmm\n\n    # Import function for cleaning up MKL objects\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-destroy\n    _mkl_sparse_destroy = _libmkl.mkl_sparse_destroy\n\n    # Import function for ordering MKL objects\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-order\n    _mkl_sparse_order = _libmkl.mkl_sparse_order\n\n    # Import function for coverting to CSR\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-convert-csr\n    _mkl_sparse_convert_csr = _libmkl.mkl_sparse_convert_csr\n\n    # Import function for matmul single dense\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-spmm\n    _mkl_sparse_s_spmmd = _libmkl.mkl_sparse_s_spmmd\n\n    # Import function for matmul double dense\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-spmm\n    _mkl_sparse_d_spmmd = _libmkl.mkl_sparse_d_spmmd\n\n    # Import function for matmul single sparse*dense\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-mm\n    _mkl_sparse_s_mm = _libmkl.mkl_sparse_s_mm\n\n    # Import function for matmul double sparse*dense\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-mm\n    _mkl_sparse_d_mm = _libmkl.mkl_sparse_d_mm\n\n    # Import function for matmul single dense*dense\n    # https://software.intel.com/en-us/mkl-developer-reference-c-cblas-gemm\n    _cblas_sgemm = _libmkl.cblas_sgemm\n\n    # Import function for matmul double dense*dense\n    # https://software.intel.com/en-us/mkl-developer-reference-c-cblas-gemm\n    _cblas_dgemm = _libmkl.cblas_dgemm\n\n    # Import function for matrix * vector\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-mv\n    _mkl_sparse_s_mv = _libmkl.mkl_sparse_s_mv\n\n    # Import function for matrix * vector\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-mv\n    _mkl_sparse_d_mv = _libmkl.mkl_sparse_d_mv\n\n    # Import function for sparse gram matrix\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-syrk\n    _mkl_sparse_syrk = _libmkl.mkl_sparse_syrk\n\n    # Import function for dense single gram matrix from sparse\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-syrkd\n    _mkl_sparse_s_syrkd = _libmkl.mkl_sparse_s_syrkd\n\n    # Import function for dense double gram matrix from sparse\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-syrkd\n    _mkl_sparse_d_syrkd = _libmkl.mkl_sparse_d_syrkd\n\n    # Import function for dense single gram matrix\n    # https://software.intel.com/en-us/mkl-developer-reference-c-cblas-syrk\n    _cblas_ssyrk = _libmkl.cblas_ssyrk\n\n    # Import function for dense double gram matrix\n    # https://software.intel.com/en-us/mkl-developer-reference-c-cblas-syrk\n    _cblas_dsyrk = _libmkl.cblas_dsyrk\n\n    # Import function for QR solver - reorder\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-qr-reorder\n    _mkl_sparse_qr_reorder = _libmkl.mkl_sparse_qr_reorder\n\n    # Import function for QR solver - factorize\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-qr-factorize\n    _mkl_sparse_d_qr_factorize = _libmkl.mkl_sparse_d_qr_factorize\n\n    # Import function for QR solver - factorize\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-qr-factorize\n    _mkl_sparse_s_qr_factorize = _libmkl.mkl_sparse_s_qr_factorize\n\n    # Import function for QR solver - solve\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-qr-solve\n    _mkl_sparse_d_qr_solve = _libmkl.mkl_sparse_d_qr_solve\n\n    # Import function for QR solver - solve\n    # https://software.intel.com/en-us/mkl-developer-reference-c-mkl-sparse-qr-solve\n    _mkl_sparse_s_qr_solve = _libmkl.mkl_sparse_s_qr_solve\n\n    @classmethod\n    def _set_int_type(cls, c_type, np_type):\n        cls.MKL_INT = c_type\n        cls.MKL_INT_NUMPY = np_type\n\n        cls._mkl_sparse_d_create_csr.argtypes = cls._mkl_sparse_create_argtypes(_ctypes.c_double)\n        cls._mkl_sparse_d_create_csr.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_create_csr.argtypes = cls._mkl_sparse_create_argtypes(_ctypes.c_float)\n        cls._mkl_sparse_s_create_csr.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_d_create_csc.argtypes = cls._mkl_sparse_create_argtypes(_ctypes.c_double)\n        cls._mkl_sparse_d_create_csc.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_create_csc.argtypes = cls._mkl_sparse_create_argtypes(_ctypes.c_float)\n        cls._mkl_sparse_s_create_csc.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_d_export_csr.argtypes = cls._mkl_export_create_argtypes(_ctypes.c_double)\n        cls._mkl_sparse_d_export_csr.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_export_csr.argtypes = cls._mkl_export_create_argtypes(_ctypes.c_float)\n        cls._mkl_sparse_s_export_csr.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_d_export_csc.argtypes = cls._mkl_export_create_argtypes(_ctypes.c_double)\n        cls._mkl_sparse_d_export_csc.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_export_csr.argtypes = cls._mkl_export_create_argtypes(_ctypes.c_float)\n        cls._mkl_sparse_s_export_csr.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_spmm.argtypes = [_ctypes.c_int,\n                                         sparse_matrix_t,\n                                         sparse_matrix_t,\n                                         _ctypes.POINTER(sparse_matrix_t)]\n        cls._mkl_sparse_spmm.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_spmmd.argtypes = cls._mkl_sparse_spmmd_argtypes(_ctypes.c_float)\n        cls._mkl_sparse_s_spmmd.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_d_spmmd.argtypes = cls._mkl_sparse_spmmd_argtypes(_ctypes.c_double)\n        cls._mkl_sparse_d_spmmd.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_mm.argtypes = cls._mkl_sparse_mm_argtypes(_ctypes.c_float)\n        cls._mkl_sparse_s_mm.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_d_mm.argtypes = cls._mkl_sparse_mm_argtypes(_ctypes.c_double)\n        cls._mkl_sparse_d_mm.restypes = _ctypes.c_int\n\n        cls._cblas_sgemm.argtypes = cls._cblas_gemm_argtypes(_ctypes.c_float)\n        cls._cblas_sgemm.restypes = None\n\n        cls._cblas_dgemm.argtypes = cls._cblas_gemm_argtypes(_ctypes.c_double)\n        cls._cblas_dgemm.restypes = None\n\n        cls._mkl_sparse_destroy.argtypes = [sparse_matrix_t]\n        cls._mkl_sparse_destroy.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_order.argtypes = [sparse_matrix_t]\n        cls._mkl_sparse_order.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_mv.argtypes = cls._mkl_sparse_mv_argtypes(_ctypes.c_float)\n        cls._mkl_sparse_s_mv.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_d_mv.argtypes = cls._mkl_sparse_mv_argtypes(_ctypes.c_double)\n        cls._mkl_sparse_d_mv.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_syrk.argtypes = [_ctypes.c_int,\n                                         sparse_matrix_t,\n                                         _ctypes.POINTER(sparse_matrix_t)]\n        cls._mkl_sparse_syrk.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_syrkd.argtypes = cls._mkl_sparse_syrkd_argtypes(_ctypes.c_float)\n        cls._mkl_sparse_s_syrkd.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_d_syrkd.argtypes = cls._mkl_sparse_syrkd_argtypes(_ctypes.c_double)\n        cls._mkl_sparse_d_syrkd.restypes = _ctypes.c_int\n\n        cls._cblas_ssyrk.argtypes = cls._cblas_syrk_argtypes(_ctypes.c_float)\n        cls._cblas_ssyrk.restypes = None\n\n        cls._cblas_dsyrk.argtypes = cls._cblas_syrk_argtypes(_ctypes.c_double)\n        cls._cblas_dsyrk.restypes = None\n\n        cls._mkl_sparse_qr_reorder.argtypes = [sparse_matrix_t, matrix_descr]\n        cls._mkl_sparse_qr_reorder.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_d_qr_factorize.argtypes = [sparse_matrix_t, _ctypes.POINTER(_ctypes.c_double)]\n        cls._mkl_sparse_d_qr_factorize.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_qr_factorize.argtypes = [sparse_matrix_t, _ctypes.POINTER(_ctypes.c_float)]\n        cls._mkl_sparse_s_qr_factorize.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_d_qr_solve.argtypes = cls._mkl_sparse_qr_solve(_ctypes.c_double)\n        cls._mkl_sparse_d_qr_solve.restypes = _ctypes.c_int\n\n        cls._mkl_sparse_s_qr_solve.argtypes = cls._mkl_sparse_qr_solve(_ctypes.c_float)\n        cls._mkl_sparse_s_qr_solve.restypes = _ctypes.c_int\n\n    def __init__(self):\n        raise NotImplementedError(""This class is not intended to be instanced"")\n\n    """""" The following methods return the argtype lists for each MKL function that has s and d variants""""""\n\n    @staticmethod\n    def _mkl_sparse_create_argtypes(prec_type):\n        return [_ctypes.POINTER(sparse_matrix_t),\n                _ctypes.c_int,\n                MKL.MKL_INT,\n                MKL.MKL_INT,\n                ndpointer(dtype=MKL.MKL_INT, ndim=1, flags=\'C_CONTIGUOUS\'),\n                ndpointer(dtype=MKL.MKL_INT, ndim=1, flags=\'C_CONTIGUOUS\'),\n                ndpointer(dtype=MKL.MKL_INT, ndim=1, flags=\'C_CONTIGUOUS\'),\n                ndpointer(dtype=prec_type, ndim=1, flags=\'C_CONTIGUOUS\')]\n\n    @staticmethod\n    def _mkl_export_create_argtypes(prec_type):\n        return [sparse_matrix_t,\n                _ctypes.POINTER(_ctypes.c_int),\n                _ctypes.POINTER(MKL.MKL_INT),\n                _ctypes.POINTER(MKL.MKL_INT),\n                _ctypes.POINTER(_ctypes.POINTER(MKL.MKL_INT)),\n                _ctypes.POINTER(_ctypes.POINTER(MKL.MKL_INT)),\n                _ctypes.POINTER(_ctypes.POINTER(MKL.MKL_INT)),\n                _ctypes.POINTER(_ctypes.POINTER(prec_type))]\n\n\n    @staticmethod\n    def _cblas_gemm_argtypes(prec_type):\n        return [_ctypes.c_int,\n                _ctypes.c_int,\n                _ctypes.c_int,\n                MKL.MKL_INT,\n                MKL.MKL_INT,\n                MKL.MKL_INT,\n                prec_type,\n                ndpointer(dtype=prec_type, ndim=2),\n                MKL.MKL_INT,\n                ndpointer(dtype=prec_type, ndim=2),\n                MKL.MKL_INT,\n                prec_type,\n                _ctypes.POINTER(prec_type),\n                MKL.MKL_INT]\n\n    @staticmethod\n    def _mkl_sparse_spmmd_argtypes(prec_type):\n        return [_ctypes.c_int,\n                sparse_matrix_t,\n                sparse_matrix_t,\n                _ctypes.c_int,\n                _ctypes.POINTER(prec_type), MKL.MKL_INT]\n\n    @staticmethod\n    def _mkl_sparse_mm_argtypes(prec_type):\n        return [_ctypes.c_int,\n                prec_type,\n                sparse_matrix_t,\n                matrix_descr,\n                _ctypes.c_int,\n                ndpointer(dtype=prec_type, ndim=2),\n                MKL.MKL_INT,\n                MKL.MKL_INT,\n                prec_type,\n                _ctypes.POINTER(prec_type),\n                MKL.MKL_INT]\n\n    @staticmethod\n    def _mkl_sparse_mv_argtypes(prec_type):\n        return [_ctypes.c_int,\n                prec_type,\n                sparse_matrix_t,\n                matrix_descr,\n                ndpointer(dtype=prec_type, ndim=1),\n                prec_type,\n                _ctypes.POINTER(prec_type)]\n\n    @staticmethod\n    def _mkl_sparse_syrkd_argtypes(prec_type):\n        return [_ctypes.c_int,\n                sparse_matrix_t,\n                prec_type,\n                prec_type,\n                _ctypes.POINTER(prec_type),\n                _ctypes.c_int,\n                MKL.MKL_INT]\n\n    @staticmethod\n    def _cblas_syrk_argtypes(prec_type):\n        return [_ctypes.c_int,\n                _ctypes.c_int,\n                _ctypes.c_int,\n                MKL.MKL_INT,\n                MKL.MKL_INT,\n                prec_type,\n                ndpointer(dtype=prec_type, ndim=2),\n                MKL.MKL_INT,\n                prec_type,\n                _ctypes.POINTER(prec_type),\n                MKL.MKL_INT]\n      \n    @staticmethod\n    def _mkl_sparse_qr_solve(prec_type):\n        return [_ctypes.c_int,\n                sparse_matrix_t,\n                _ctypes.POINTER(prec_type),\n                _ctypes.c_int,\n                MKL.MKL_INT,\n                _ctypes.POINTER(prec_type),\n                MKL.MKL_INT,\n                ndpointer(dtype=prec_type, ndim=2),\n                MKL.MKL_INT]\n\n\n# Construct opaque struct & type\nclass _sparse_matrix(_ctypes.Structure):\n    pass\n\n\nsparse_matrix_t = _ctypes.POINTER(_sparse_matrix)\n\n\n# Matrix description struct\nclass matrix_descr(_ctypes.Structure):\n    _fields_ = [(""sparse_matrix_type_t"", _ctypes.c_int),\n                (""sparse_fill_mode_t"", _ctypes.c_int),\n                (""sparse_diag_type_t"", _ctypes.c_int)]\n\n    def __init__(self, sparse_matrix_type_t=20, sparse_fill_mode_t=0, sparse_diag_type_t=0):\n        super(matrix_descr, self).__init__(sparse_matrix_type_t, sparse_fill_mode_t, sparse_diag_type_t)\n\n\n# Define standard return codes\nRETURN_CODES = {0: ""SPARSE_STATUS_SUCCESS"",\n                1: ""SPARSE_STATUS_NOT_INITIALIZED"",\n                2: ""SPARSE_STATUS_ALLOC_FAILED"",\n                3: ""SPARSE_STATUS_INVALID_VALUE"",\n                4: ""SPARSE_STATUS_EXECUTION_FAILED"",\n                5: ""SPARSE_STATUS_INTERNAL_ERROR"",\n                6: ""SPARSE_STATUS_NOT_SUPPORTED""}\n\n# Define order codes\nLAYOUT_CODE_C = 101\nLAYOUT_CODE_F = 102\n\n# Define transpose codes\nSPARSE_OPERATION_NON_TRANSPOSE = 10\nSPARSE_OPERATION_TRANSPOSE = 11\n\n\ndef _check_scipy_index_typing(sparse_matrix):\n    """"""\n    Ensure that the sparse matrix indicies are in the correct integer type\n\n    :param sparse_matrix: Scipy matrix in CSC or CSR format\n    :type sparse_matrix: scipy.sparse.spmatrix\n    """"""\n\n    int_max = np.iinfo(MKL.MKL_INT_NUMPY).max\n    if (sparse_matrix.nnz > int_max) or (max(sparse_matrix.shape) > int_max):\n        msg = ""MKL interface is {t} and cannot hold matrix {m}"".format(m=repr(sparse_matrix), t=MKL.MKL_INT_NUMPY)\n        raise ValueError(msg)\n\n    # Cast indexes to MKL_INT type\n    if sparse_matrix.indptr.dtype != MKL.MKL_INT_NUMPY:\n        sparse_matrix.indptr = sparse_matrix.indptr.astype(MKL.MKL_INT_NUMPY)\n    if sparse_matrix.indices.dtype != MKL.MKL_INT_NUMPY:\n        sparse_matrix.indices = sparse_matrix.indices.astype(MKL.MKL_INT_NUMPY)\n\n\ndef _get_numpy_layout(numpy_arr):\n    """"""\n    Get the array layout code for a dense array in C or F order.\n    Raises a ValueError if the array is not contiguous.\n\n    :param numpy_arr: Numpy dense array\n    :type numpy_arr: np.ndarray\n    :return: The layout code for MKL and the leading dimension\n    :rtype: int, int\n    """"""\n\n    if numpy_arr.flags.c_contiguous:\n        return LAYOUT_CODE_C, numpy_arr.shape[1]\n    elif numpy_arr.flags.f_contiguous:\n        return LAYOUT_CODE_F, numpy_arr.shape[0]\n    elif not numpy_arr.flags.contiguous:\n        raise ValueError(""Array is not contiguous"")\n    else:\n        raise ValueError(""Array layout check has failed for unknown reason"")\n\n\ndef _create_mkl_sparse(matrix):\n    """"""\n    Create MKL internal representation\n\n    :param matrix: Sparse data in CSR or CSC format\n    :type matrix: scipy.sparse.spmatrix\n\n    :return ref, double_precision: Handle for the MKL internal representation and boolean for double precision\n    :rtype: sparse_matrix_t, float\n    """"""\n\n    # Figure out which dtype for data\n    if matrix.dtype == np.float32:\n        double_precision = False\n    elif matrix.dtype == np.float64:\n        double_precision = True\n    else:\n        raise ValueError(""Only float32 or float64 dtypes are supported"")\n\n    # Figure out which matrix creation function to use\n    if _spsparse.isspmatrix_csr(matrix):\n        assert matrix.indptr.shape[0] == matrix.shape[0] + 1\n        handle_func = MKL._mkl_sparse_d_create_csr if double_precision else MKL._mkl_sparse_s_create_csr\n    elif _spsparse.isspmatrix_csc(matrix):\n        assert matrix.indptr.shape[0] == matrix.shape[1] + 1\n        handle_func = MKL._mkl_sparse_d_create_csc if double_precision else MKL._mkl_sparse_s_create_csc\n    else:\n        raise ValueError(""Matrix is not CSC or CSR"")\n\n    # Make sure indices are of the correct integer type\n    _check_scipy_index_typing(matrix)\n    assert matrix.data.shape[0] == matrix.indices.shape[0]\n\n    return _pass_mkl_handle(matrix, handle_func), double_precision\n\n\ndef _pass_mkl_handle(data, handle_func):\n    """"""\n    Create MKL internal representation\n\n    :param data: Sparse data\n    :type data: scipy.sparse.spmatrix\n    :return ref: Handle for the MKL internal representation\n    :rtype: sparse_matrix_t\n    """"""\n\n    # Create a pointer for the output matrix\n    ref = sparse_matrix_t()\n\n    # Load into a MKL data structure and check return\n    ret_val = handle_func(_ctypes.byref(ref),\n                          _ctypes.c_int(0),\n                          MKL.MKL_INT(data.shape[0]),\n                          MKL.MKL_INT(data.shape[1]),\n                          data.indptr[0:-1],\n                          data.indptr[1:],\n                          data.indices,\n                          data.data)\n\n    # Check return\n    if ret_val != 0:\n        err_msg = ""{fn} returned {v} ({e})"".format(fn=handle_func.__name__, v=ret_val, e=RETURN_CODES[ret_val])\n        raise ValueError(err_msg)\n\n    return ref\n\n\ndef _export_mkl(csr_mkl_handle, double_precision, output_type=""csr""):\n    """"""\n    Export a MKL sparse handle\n\n    :param csr_mkl_handle: Handle for the MKL internal representation\n    :type csr_mkl_handle: sparse_matrix_t\n    :param double_precision: Use float64 if True, float32 if False. This MUST match the underlying float type - this\n        defines a memory view, it does not cast.\n    :type double_precision: bool\n    :param output_type: The structure of the MKL handle (and therefore the type of scipy sparse to create)\n    :type output_type: str\n\n    :return: Sparse matrix in scipy format\n    :rtype: scipy.spmatrix\n    """"""\n\n    # Create the pointers for the output data\n    indptrb = _ctypes.POINTER(MKL.MKL_INT)()\n    indptren = _ctypes.POINTER(MKL.MKL_INT)()\n    indices = _ctypes.POINTER(MKL.MKL_INT)()\n\n    ordering = _ctypes.c_int()\n    nrows = MKL.MKL_INT()\n    ncols = MKL.MKL_INT()\n\n    output_type = output_type.lower()\n\n    if output_type == ""csr"":\n        out_func = MKL._mkl_sparse_d_export_csr if double_precision else MKL._mkl_sparse_s_export_csr\n        sp_matrix_constructor = _spsparse.csr_matrix\n    elif output_type == ""csc"":\n        out_func = MKL._mkl_sparse_d_export_csc if double_precision else MKL._mkl_sparse_s_export_csc\n        sp_matrix_constructor = _spsparse.csc_matrix\n    else:\n        raise ValueError(""Only CSR and CSC output types are supported"")\n\n    if double_precision:\n        data = _ctypes.POINTER(_ctypes.c_double)()\n        final_dtype = np.float64\n    else:\n        data = _ctypes.POINTER(_ctypes.c_float)()\n        final_dtype = np.float32\n\n    ret_val = out_func(csr_mkl_handle,\n                       _ctypes.byref(ordering),\n                       _ctypes.byref(nrows),\n                       _ctypes.byref(ncols),\n                       _ctypes.byref(indptrb),\n                       _ctypes.byref(indptren),\n                       _ctypes.byref(indices),\n                       _ctypes.byref(data))\n\n    # Check return\n    if ret_val != 0:\n        err_msg = ""{fn} returned {v} ({e})"".format(fn=out_func.__name__, v=ret_val, e=RETURN_CODES[ret_val])\n        raise ValueError(err_msg)\n\n    # Check ordering\n    if ordering.value != 0:\n        raise ValueError(""1-indexing (F-style) is not supported"")\n\n    # Get matrix dims\n    ncols = ncols.value\n    nrows = nrows.value\n\n    # If any axis is 0 return an empty matrix\n    if nrows == 0 or ncols == 0:\n        return sp_matrix_constructor((nrows, ncols), dtype=final_dtype)\n\n    # Get the index dimension\n    index_dim = nrows if output_type == ""csr"" else ncols\n\n    # Construct a numpy array and add 0 to first position for scipy.sparse\'s 3-array indexing\n    indptrb = as_array(indptrb, shape=(index_dim,))\n    indptren = as_array(indptren, shape=(index_dim,))\n\n    indptren = np.insert(indptren, 0, indptrb[0])\n    nnz = indptren[-1] - indptrb[0]\n\n    # If there are no non-zeros, return an empty matrix\n    # If the number of non-zeros is insane, raise a ValueError\n    if nnz == 0:\n        return sp_matrix_constructor((nrows, ncols), dtype=final_dtype)\n    elif nnz < 0 or nnz > ncols * nrows:\n        raise ValueError(""Matrix ({m} x {n}) is attempting to index {z} elements"".format(m=nrows, n=ncols, z=nnz))\n\n    # Construct numpy arrays from data pointer and from indicies pointer\n    data = np.array(as_array(data, shape=(nnz,)), copy=True)\n    indices = np.array(as_array(indices, shape=(nnz,)), copy=True)\n\n    # Pack and return the matrix\n    return sp_matrix_constructor((data, indices, indptren), shape=(nrows, ncols))\n\n\ndef _destroy_mkl_handle(ref_handle):\n    """"""\n    Deallocate a MKL sparse handle\n\n    :param ref_handle:\n    :type ref_handle: sparse_matrix_t\n    """"""\n\n    ret_val = MKL._mkl_sparse_destroy(ref_handle)\n\n    if ret_val != 0:\n        raise ValueError(""mkl_sparse_destroy returned {v} ({e})"".format(v=ret_val, e=RETURN_CODES[ret_val]))\n\n\ndef _order_mkl_handle(ref_handle):\n    """"""\n    Reorder indexes in a MKL sparse handle\n\n    :param ref_handle:\n    :type ref_handle: sparse_matrix_t\n    """"""\n\n    ret_val = MKL._mkl_sparse_order(ref_handle)\n\n    if ret_val != 0:\n        raise ValueError(""mkl_sparse_order returned {v} ({e})"".format(v=ret_val, e=RETURN_CODES[ret_val]))\n\n\ndef _convert_to_csr(ref_handle, destroy_original=False):\n    """"""\n    Convert a MKL sparse handle to CSR format\n\n    :param ref_handle:\n    :type ref_handle: sparse_matrix_t\n    :return:\n    """"""\n\n    csr_ref = sparse_matrix_t()\n    ret_val = MKL._mkl_sparse_convert_csr(ref_handle, _ctypes.c_int(10), _ctypes.byref(csr_ref))\n\n    if ret_val != 0:\n        try:\n            _destroy_mkl_handle(csr_ref)\n        except ValueError:\n            pass\n\n        raise ValueError(""mkl_sparse_convert_csr returned {v} ({e})"".format(v=ret_val, e=RETURN_CODES[ret_val]))\n\n    if destroy_original:\n        _destroy_mkl_handle(ref_handle)\n\n    return csr_ref\n\n\ndef _sanity_check(matrix_a, matrix_b, allow_vector=False):\n    """"""\n    Check matrix dimensions\n    :param matrix_a: sp.sparse or numpy array\n    :param matrix_b: sp.sparse or numpy array\n    """"""\n\n    a_2d, b_2d = matrix_a.ndim == 2, matrix_b.ndim == 2\n    a_vec, b_vec = _is_dense_vector(matrix_a), _is_dense_vector(matrix_b)\n\n    # Check to make sure that both matrices are 2-d\n    if not allow_vector and (not a_2d or not b_2d):\n        err_msg = ""Matrices must be 2d: {m1} * {m2} is not valid"".format(m1=matrix_a.shape, m2=matrix_b.shape)\n        raise ValueError(err_msg)\n\n    invalid_ndims = not (a_2d or a_vec) or not (b_2d, b_vec)\n    invalid_align = (matrix_a.shape[1] if not matrix_a.ndim == 1 else matrix_a.shape[0]) != matrix_b.shape[0]\n\n    # Check to make sure that this multiplication can work\n    if invalid_align or invalid_ndims:\n        err_msg = ""Matrix alignment error: {m1} * {m2} is not valid"".format(m1=matrix_a.shape, m2=matrix_b.shape)\n        raise ValueError(err_msg)\n\n\ndef _cast_to_float64(matrix):\n    """""" Make a copy of the array as double precision floats or return the reference if it already is""""""\n    return matrix.astype(np.float64) if matrix.dtype != np.float64 else matrix\n\n\ndef _type_check(matrix_a, matrix_b=None, cast=False, dprint=print):\n    """"""\n    Make sure that both matrices are single precision floats or both are double precision floats\n    If not, convert to double precision floats if cast is True, or raise an error if cast is False\n    """"""\n\n    if matrix_b is None and matrix_a.dtype in NUMPY_FLOAT_DTYPES:\n        return matrix_a\n    elif matrix_b is None and cast:\n        return _cast_to_float64(matrix_a)\n    elif matrix_b is None:\n        err_msg = ""Matrix data type must be float32 or float64; {a} provided"".format(a=matrix_a.dtype)\n        raise ValueError(err_msg)\n\n    # Check dtypes\n    if matrix_a.dtype == np.float32 and matrix_b.dtype == np.float32:\n        return matrix_a, matrix_b\n\n    elif matrix_a.dtype == np.float64 and matrix_b.dtype == np.float64:\n        return matrix_a, matrix_b\n\n    elif (matrix_a.dtype != np.float64 or matrix_b.dtype != np.float64) and cast:\n        dprint(""Recasting matrix data types {a} and {b} to np.float64"".format(a=matrix_a.dtype,\n                                                                              b=matrix_b.dtype))\n        return _cast_to_float64(matrix_a), _cast_to_float64(matrix_b)\n\n    elif matrix_a.dtype != np.float64 or matrix_b.dtype != np.float64:\n        err_msg = ""Matrix data types must be in concordance; {a} and {b} provided"".format(a=matrix_a.dtype,\n                                                                                          b=matrix_b.dtype)\n        raise ValueError(err_msg)\n\n\ndef _is_dense_vector(m_or_v):\n    return not _spsparse.issparse(m_or_v) and ((m_or_v.ndim == 1) or ((m_or_v.ndim == 2) and min(m_or_v.shape) == 1))\n\n\ndef _empty_output_check(matrix_a, matrix_b):\n    """"""Check for trivial cases where an empty array should be produced""""""\n\n    # One dimension is zero\n    if min([*matrix_a.shape, *matrix_b.shape]) == 0:\n        return True\n\n    # The sparse array is empty\n    elif _spsparse.issparse(matrix_a) and min(matrix_a.data.shape[0], matrix_a.indices.shape[0]) == 0:\n        return True\n    elif _spsparse.issparse(matrix_b) and min(matrix_b.data.shape[0], matrix_b.indices.shape[0]) == 0:\n        return True\n\n    # Neither trivial condition\n    else:\n        return False\n\n\ndef _validate_dtype():\n    """"""\n    Test to make sure that this library works by creating a random sparse array in CSC format,\n    then converting it to CSR format and making sure is has not raised an exception.\n\n    """"""\n\n    test_array = _spsparse.random(5, 5, density=0.5, format=""csc"", dtype=np.float32, random_state=50)\n    test_comparison = test_array.A\n\n    csc_ref, precision_flag = _create_mkl_sparse(test_array)\n\n    try:\n        csr_ref = _convert_to_csr(csc_ref)\n        final_array = _export_mkl(csr_ref, precision_flag)\n        if not np.allclose(test_comparison, final_array.A):\n            raise ValueError(""Match failed after matrix conversion"")\n        _destroy_mkl_handle(csr_ref)\n    finally:\n        _destroy_mkl_handle(csc_ref)\n\n\n# Define dtypes empirically\n# Basically just try with int64s and if that doesn\'t work try with int32s\n# There\'s a way to do this with intel\'s mkl helper package but I don\'t want to add the dependency\nif MKL.MKL_INT is None:\n\n    MKL._set_int_type(_ctypes.c_longlong, np.int64)\n\n    try:\n        _validate_dtype()\n    except ValueError as err:\n\n        MKL._set_int_type(_ctypes.c_int, np.int32)\n\n        try:\n            _validate_dtype()\n        except ValueError:\n            raise ImportError(""Unable to set MKL numeric type"")\n'"
sparse_dot_mkl/_sparse_dense.py,11,"b'from sparse_dot_mkl._mkl_interface import (MKL, _sanity_check, _empty_output_check, _type_check, _create_mkl_sparse,\n                                           _destroy_mkl_handle, matrix_descr, RETURN_CODES, _convert_to_csr,\n                                           _get_numpy_layout, LAYOUT_CODE_C, LAYOUT_CODE_F)\nimport numpy as np\nimport ctypes as _ctypes\nimport scipy.sparse as _spsparse\n\n\ndef _dense_sparse_matmul(matrix_a, matrix_b, scalar=1.):\n    """"""\n    Calculate BT (dot) AT and then transpose this product. It will be equal to A (dot) B\n\n    :param matrix_a: Left (A) matrix\n    :type matrix_a: np.ndarray\n    :param matrix_b: Right (B) matrix\n    :type matrix_b: sp.spmatrix.csr, sp.spmatrix.csc\n    :param scalar: float\n    :return: A (dot) B as a dense array in either column-major or row-major format\n    :rtype: np.ndarray\n    """"""\n\n    return _sparse_dense_matmul(matrix_b, matrix_a.T, scalar=scalar, transpose=True).T\n\n\ndef _sparse_dense_matmul(matrix_a, matrix_b, scalar=1., transpose=False):\n    """"""\n    Multiply together a sparse and a dense matrix\n    mkl_sparse_?_mm requires the left (A) matrix to be sparse and the right (B) matrix to be dense\n    This requires conversion of the sparse matrix to CSR format for some dense arrays.\n    A must be CSR if B is column-major. Otherwise CSR or CSC are acceptable.\n\n    :param matrix_a: Left (A) matrix\n    :type matrix_a: sp.spmatrix.csr, sp.spmatrix.csc\n    :param matrix_b: Right (B) matrix\n    :type matrix_b: np.ndarray\n    :param scalar: A value to multiply the result matrix by. Defaults to 1.\n    :type scalar: float\n    :param transpose: Return AT (dot) B instead of A (dot) B.\n    :type transpose: bool\n    :return: A (dot) B as a dense array in either column-major or row-major format\n    :rtype: np.ndarray\n    """"""\n\n    output_shape = (matrix_a.shape[1] if transpose else matrix_a.shape[0], matrix_b.shape[1])\n    layout_b, ld_b = _get_numpy_layout(matrix_b)\n\n    # Prep MKL handles and check that matrixes are compatible types\n    # MKL requires CSR format if the dense array is column-major\n    if layout_b == LAYOUT_CODE_F and not _spsparse.isspmatrix_csr(matrix_a):\n        mkl_non_csr, dbl = _create_mkl_sparse(matrix_a)\n        mkl_a = _convert_to_csr(mkl_non_csr)\n    else:\n        mkl_a, dbl = _create_mkl_sparse(matrix_a)\n\n    # Set functions and types for float or doubles\n    output_ctype = _ctypes.c_double if dbl else _ctypes.c_float\n    output_dtype = np.float64 if dbl else np.float32\n    func = MKL._mkl_sparse_d_mm if dbl else MKL._mkl_sparse_s_mm\n\n    # Allocate an output array\n    output_arr = np.zeros(output_shape, dtype=output_dtype, order=""C"" if layout_b == LAYOUT_CODE_C else ""F"")\n    _, output_ld = _get_numpy_layout(output_arr)\n\n    ret_val = func(11 if transpose else 10,\n                   scalar,\n                   mkl_a,\n                   matrix_descr(),\n                   layout_b,\n                   matrix_b,\n                   output_shape[1],\n                   ld_b,\n                   1.,\n                   output_arr.ctypes.data_as(_ctypes.POINTER(output_ctype)),\n                   output_ld)\n\n    # Check return\n    if ret_val != 0:\n        err_msg = ""{fn} returned {v} ({e})"".format(fn=func.__name__, v=ret_val, e=RETURN_CODES[ret_val])\n        raise ValueError(err_msg)\n\n    _destroy_mkl_handle(mkl_a)\n\n    return output_arr\n\n\ndef _sparse_dot_dense(matrix_a, matrix_b, cast=False, dprint=print, scalar=1.):\n    """"""\n    Multiply together a dense and a sparse matrix.\n    If the sparse matrix is not CSR, it may need to be reordered, depending on the order of the dense array.\n\n    :param matrix_a: Left (A) matrix\n    :type matrix_a: np.ndarray, sp.spmatrix.csr, sp.spmatrix.csc\n    :param matrix_b: Right (B) matrix\n    :type matrix_b: np.ndarray, sp.spmatrix.csr, sp.spmatrix.csc\n    :param scalar: A value to multiply the result matrix by. Defaults to 1.\n    :type scalar: float\n    :param cast: Convert values to compatible floats if True. Raise an error if they are not compatible if False.\n    Defaults to False.\n    :type cast: bool\n    :param dprint: A function that will handle debug strings. Defaults to print.\n    :type dprint: function\n\n    :return: A (dot) B as a dense matrix\n    :rtype: np.ndarray\n    """"""\n    _sanity_check(matrix_a, matrix_b)\n\n    # Check for edge condition inputs which result in empty outputs\n    if _empty_output_check(matrix_a, matrix_b):\n        dprint(""Skipping multiplication because A (dot) B must yield an empty matrix"")\n        final_dtype = np.float64 if matrix_a.dtype != matrix_b.dtype or matrix_a.dtype != np.float32 else np.float32\n        return np.zeros((matrix_a.shape[0], matrix_b.shape[1]), dtype=final_dtype)\n\n    matrix_a, matrix_b = _type_check(matrix_a, matrix_b, cast=cast, dprint=dprint)\n\n    if sum([_spsparse.isspmatrix(matrix_a), _spsparse.isspmatrix(matrix_b)]) != 1:\n        raise ValueError(""_sparse_dot_dense takes one sparse and one dense array"")\n    elif _spsparse.isspmatrix(matrix_a):\n        return _sparse_dense_matmul(matrix_a, matrix_b, scalar=scalar)\n    elif _spsparse.isspmatrix(matrix_b):\n        return _dense_sparse_matmul(matrix_a, matrix_b, scalar=scalar)\n'"
sparse_dot_mkl/_sparse_qr_solver.py,2,"b'from sparse_dot_mkl._mkl_interface import (MKL, _sanity_check, _get_numpy_layout, _type_check, _create_mkl_sparse,\n                                           _destroy_mkl_handle, matrix_descr, RETURN_CODES, _convert_to_csr,\n                                           LAYOUT_CODE_C)\n\nimport numpy as np\nimport ctypes as _ctypes\nimport scipy.sparse as _spsparse\n\n\ndef _sparse_qr(matrix_a, matrix_b):\n    """"""\n    Solve AX = B for X\n\n    :param matrix_a: Sparse matrix A\n    :type matrix_a: scipy.sparse.csr_matrix\n    :param matrix_b: Dense matrix B\n    :type matrix_b: numpy.ndarray\n    :return: Dense matrix X\n    :rtype: numpy.ndarray\n    """"""\n\n    mkl_a, dbl = _create_mkl_sparse(matrix_a)\n    layout_b, ld_b = _get_numpy_layout(matrix_b)\n\n    output_shape = matrix_a.shape[1], matrix_b.shape[1]\n\n    if _spsparse.isspmatrix_csc(matrix_a):\n        mkl_a = _convert_to_csr(mkl_a)\n\n    # QR Reorder ##\n    ret_val_r = MKL._mkl_sparse_qr_reorder(mkl_a, matrix_descr())\n\n    # Check return\n    if ret_val_r != 0:\n        err_msg = ""mkl_sparse_qr_reorder returned {v} ({e})"".format(v=ret_val_r, e=RETURN_CODES[ret_val_r])\n        raise ValueError(err_msg)\n\n    # QR Factorize ##\n    factorize_func = MKL._mkl_sparse_d_qr_factorize if dbl else MKL._mkl_sparse_s_qr_factorize\n\n    ret_val_f = factorize_func(mkl_a, None)\n\n    # Check return\n    if ret_val_f != 0:\n        err_msg = ""{fn} returned {v} ({e})"".format(fn=factorize_func.__name__, v=ret_val_f, e=RETURN_CODES[ret_val_f])\n        raise ValueError(err_msg)\n\n    # QR Solve ##\n    output_dtype = np.float64 if dbl else np.float32\n    output_ctype = _ctypes.c_double if dbl else _ctypes.c_float\n\n    output_arr = np.zeros(output_shape, dtype=output_dtype, order=""C"" if layout_b == LAYOUT_CODE_C else ""F"")\n    layout_out, ld_out = _get_numpy_layout(output_arr)\n\n    solve_func = MKL._mkl_sparse_d_qr_solve if dbl else MKL._mkl_sparse_s_qr_solve\n\n    ret_val_s = solve_func(10,\n                           mkl_a,\n                           None,\n                           layout_b,\n                           output_shape[1],\n                           output_arr.ctypes.data_as(_ctypes.POINTER(output_ctype)),\n                           ld_out,\n                           matrix_b,\n                           ld_b)\n\n    # Check return\n    if ret_val_s != 0:\n        err_msg = ""{fn} returned {v} ({e})"".format(fn=solve_func.__name__, v=ret_val_s, e=RETURN_CODES[ret_val_s])\n        raise ValueError(err_msg)\n\n    _destroy_mkl_handle(mkl_a)\n\n    return output_arr\n\n\ndef sparse_qr_solver(matrix_a, matrix_b, cast=False, dprint=print):\n    """"""\n\n    :param matrix_a:\n    :param matrix_b:\n    :param cast:\n    :param dprint:\n    :return:\n    """"""\n\n    if _spsparse.isspmatrix_csc(matrix_a) and not cast:\n        raise ValueError(""sparse_qr_solver only accepts CSR matrices if cast=False"")\n    elif not _spsparse.isspmatrix_csr(matrix_a) and not _spsparse.isspmatrix_csc(matrix_a):\n        raise ValueError(""sparse_qr_solver requires matrix A to be CSR or CSC sparse matrix"")\n    elif matrix_a.shape[0] != matrix_b.shape[0]:\n        err_msg = ""Bad matrix shapes for AX=B solver: A {sha} & B {shb}"".format(sha=matrix_a.shape, shb=matrix_b.shape)\n        raise ValueError(err_msg)\n    else:\n        matrix_a, matrix_b = _type_check(matrix_a, matrix_b, cast=cast, dprint=dprint)\n        x_arr = _sparse_qr(matrix_a, matrix_b if matrix_b.ndim == 2 else matrix_b.reshape(-1, 1))\n        return x_arr if matrix_b.ndim == 2 else x_arr.ravel()\n'"
sparse_dot_mkl/_sparse_sparse.py,4,"b'from sparse_dot_mkl._mkl_interface import (MKL, sparse_matrix_t, RETURN_CODES, _create_mkl_sparse,\n                                           _export_mkl, _order_mkl_handle, _destroy_mkl_handle, _type_check,\n                                           _empty_output_check, _sanity_check)\nimport ctypes as _ctypes\nimport numpy as np\nimport time\nimport scipy.sparse as _spsparse\nfrom scipy.sparse import isspmatrix_csr as is_csr, isspmatrix_csc as is_csc\n\n\ndef _matmul_mkl(sp_ref_a, sp_ref_b):\n    """"""\n    Dot product two MKL objects together and return a handle to the result\n\n    :param sp_ref_a: Sparse matrix A handle\n    :type sp_ref_a: sparse_matrix_t\n    :param sp_ref_b: Sparse matrix B handle\n    :param sp_ref_b: sparse_matrix_t\n    :return: Sparse matrix handle that is the dot product A * B\n    :rtype: sparse_matrix_t\n    """"""\n\n    ref_handle = sparse_matrix_t()\n\n    ret_val = MKL._mkl_sparse_spmm(_ctypes.c_int(10),\n                                   sp_ref_a,\n                                   sp_ref_b,\n                                   _ctypes.byref(ref_handle))\n\n    # Check return\n    if ret_val != 0:\n        raise ValueError(""mkl_sparse_spmm returned {v} ({e})"".format(v=ret_val, e=RETURN_CODES[ret_val]))\n\n    return ref_handle\n\n\ndef _syrk_mkl(sp_ref_a):\n    """"""\n    Dot product an MKL object with its transpose and return a handle to the result\n\n    :param sp_ref_a: Sparse matrix A handle\n    :type sp_ref_a: sparse_matrix_t\n    :return: Sparse matrix handle that is the dot product A * A.T\n    :rtype: sparse_matrix_t\n    """"""\n\n    ref_handle = sparse_matrix_t()\n\n    ret_val = MKL._mkl_sparse_syrk(_ctypes.c_int(10),\n                                   sp_ref_a,\n                                   _ctypes.byref(ref_handle))\n\n    # Check return\n    if ret_val != 0:\n        raise ValueError(""mkl_sparse_spmm returned {v} ({e})"".format(v=ret_val, e=RETURN_CODES[ret_val]))\n\n    return ref_handle\n\n\ndef _matmul_mkl_dense(sp_ref_a, sp_ref_b, output_shape, double_precision):\n    """"""\n    Dot product two MKL objects together into a dense numpy array and return the result\n\n    :param sp_ref_a: Sparse matrix A handle\n    :type sp_ref_a: sparse_matrix_t\n    :param sp_ref_b: Sparse matrix B handle\n    :type sp_ref_b: sparse_matrix_t\n    :param output_shape: The shape of the output array\n    This must be correct or the preallocated numpy array won\'t be correct and this will probably segfault\n    :type output_shape: tuple(int, int)\n    :param double_precision: The resulting array will be float64\n    :type double_precision: bool\n\n    :return: Dense numpy array that\'s the output of A dot B\n    :rtype: np.array\n    """"""\n\n    # Allocate an array for outputs and set functions and types for float or doubles\n    output_arr = np.zeros(output_shape, dtype=np.float64 if double_precision else np.float32)\n    output_ctype = _ctypes.c_double if double_precision else _ctypes.c_float\n    func = MKL._mkl_sparse_d_spmmd if double_precision else MKL._mkl_sparse_s_spmmd\n\n    ret_val = func(10,\n                   sp_ref_a,\n                   sp_ref_b,\n                   101,\n                   output_arr.ctypes.data_as(_ctypes.POINTER(output_ctype)),\n                   output_shape[1])\n\n    # Check return\n    if ret_val != 0:\n        err_msg = ""{fn} returned {v} ({e})"".format(fn=func.__name__, v=ret_val, e=RETURN_CODES[ret_val])\n        raise ValueError(err_msg)\n\n    return output_arr\n\n\ndef _sparse_dot_sparse(matrix_a, matrix_b, cast=False, reorder_output=False, dense=False, dprint=print):\n    """"""\n    Multiply together two scipy sparse matrixes using the intel Math Kernel Library.\n    This currently only supports float32 and float64 data\n\n    :param matrix_a: Sparse matrix A in CSC/CSR format\n    :type matrix_a: scipy.sparse.spmatrix\n    :param matrix_b: Sparse matrix B in CSC/CSR format\n    :type matrix_b: scipy.sparse.spmatrix\n    :param cast: Should the data be coerced into float64 if it isn\'t float32 or float64\n    If set to True and any other dtype is passed, the matrix data will be modified in-place\n    If set to False and any dtype that isn\'t float32 or float64 is passed, a ValueError will be raised\n    Defaults to False\n    :param reorder_output: Should the array indices be reordered using MKL\n    If set to True, the object in C will be ordered and then exported into python\n    If set to False, the array column indices will not be ordered.\n    The scipy sparse dot product does not yield ordered column indices so this defaults to False\n    :type reorder_output: bool\n    :param dense: Should the matrix multiplication yield a dense numpy array\n    This does not require any copy and is memory efficient if the output array density is > 50%\n    :type dense: bool\n    :param dprint: Should debug and timing messages be printed. Defaults to false.\n    :type dprint: function\n    :return: Sparse matrix that is the result of A * B in CSR format\n    :rtype: scipy.sparse.csr_matrix\n    """"""\n\n    # Check for allowed sparse matrix types\n\n    if is_csr(matrix_a) and (is_csc(matrix_b) or is_csr(matrix_b)):\n        default_output = _spsparse.csr_matrix\n        output_type = ""csr""\n    elif is_csc(matrix_a) and (is_csc(matrix_b) or is_csr(matrix_b)):\n        default_output = _spsparse.csc_matrix\n        output_type = ""csc""\n    else:\n        raise ValueError(""Both input matrices to dot_product_mkl must be CSR or CSC; COO and BSR are not supported"")\n\n    # Override output if dense flag is set\n    default_output = default_output if not dense else np.zeros\n\n    # Check to make sure that this multiplication can work and check dtypes\n    _sanity_check(matrix_a, matrix_b)\n\n    # Check for edge condition inputs which result in empty outputs\n    if _empty_output_check(matrix_a, matrix_b):\n        dprint(""Skipping multiplication because A (dot) B must yield an empty matrix"")\n        final_dtype = np.float64 if matrix_a.dtype != matrix_b.dtype or matrix_a.dtype != np.float32 else np.float32\n        return default_output((matrix_a.shape[0], matrix_b.shape[1]), dtype=final_dtype)\n\n    # Check dtypes\n    matrix_a, matrix_b = _type_check(matrix_a, matrix_b, cast=cast, dprint=dprint)\n\n    t0 = time.time()\n\n    # Create intel MKL objects\n    mkl_a, a_dbl = _create_mkl_sparse(matrix_a)\n    mkl_b, b_dbl = _create_mkl_sparse(matrix_b)\n\n    t1 = time.time()\n    dprint(""Created MKL sparse handles: {0:.6f} seconds"".format(t1 - t0))\n\n    # Call spmmd for dense output directly if the dense flag is set\n    if dense:\n        dense_arr = _matmul_mkl_dense(mkl_a, mkl_b, (matrix_a.shape[0], matrix_b.shape[1]), a_dbl or b_dbl)\n\n        t2 = time.time()\n        dprint(""Multiplied matrices: {0:.6f} seconds"".format(t2 - t1))\n\n        _destroy_mkl_handle(mkl_a)\n        _destroy_mkl_handle(mkl_b)\n\n        return dense_arr\n\n    # Call spmm for sparse output if the dense flag is not set and then export the sparse matrix to python\n    else:\n        # Dot product\n        mkl_c = _matmul_mkl(mkl_a, mkl_b)\n\n        _destroy_mkl_handle(mkl_a)\n        _destroy_mkl_handle(mkl_b)\n\n        t2 = time.time()\n        dprint(""Multiplied matrices: {0:.6f} seconds"".format(t2 - t1))\n\n        # Reorder\n        if reorder_output:\n            _order_mkl_handle(mkl_c)\n\n            dprint(""Reordered indicies: {0:.6f} seconds"".format(time.time() - t2))\n            t2 = time.time()\n\n        # Extract\n        python_c = _export_mkl(mkl_c, a_dbl or b_dbl, output_type=output_type)\n        _destroy_mkl_handle(mkl_c)\n\n        dprint(""Created python handle: {0:.6f} seconds"".format(time.time() - t2))\n\n        return python_c\n'"
sparse_dot_mkl/_sparse_vector.py,9,"b'from sparse_dot_mkl._mkl_interface import (MKL, _sanity_check, _empty_output_check, _type_check, _create_mkl_sparse,\n                                           _destroy_mkl_handle, matrix_descr, RETURN_CODES, _is_dense_vector)\n\nimport numpy as np\nimport ctypes as _ctypes\n\n\ndef _sparse_dense_vector_mult(matrix_a, vector_b, scalar=1., transpose=False):\n    """"""\n    Multiply together a sparse matrix and a dense vector\n\n    :param matrix_a: Left (A) matrix\n    :type matrix_a: sp.spmatrix.csr, sp.spmatrix.csc\n    :param vector_b: Right (B) vector with shape (N, ) or (N, 1)\n    :type vector_b: np.ndarray\n    :param scalar: A value to multiply the result matrix by. Defaults to 1.\n    :type scalar: float\n    :param transpose: Return AT (dot) B instead of A (dot) B.\n    :type transpose: bool\n    :return: A (dot) B as a dense array\n    :rtype: np.ndarray\n    """"""\n\n    output_shape = matrix_a.shape[1] if transpose else matrix_a.shape[0]\n    output_shape = (output_shape, ) if vector_b.ndim == 1 else (output_shape, 1)\n\n    if _empty_output_check(matrix_a, vector_b):\n        final_dtype = np.float64 if matrix_a.dtype != vector_b.dtype or matrix_a.dtype != np.float32 else np.float32\n        return np.zeros(output_shape, dtype=final_dtype)\n\n    mkl_a, dbl = _create_mkl_sparse(matrix_a)\n    vector_b = vector_b.ravel()\n\n    # Set functions and types for float or doubles\n    output_ctype = _ctypes.c_double if dbl else _ctypes.c_float\n    output_dtype = np.float64 if dbl else np.float32\n    func = MKL._mkl_sparse_d_mv if dbl else MKL._mkl_sparse_s_mv\n\n    output_arr = np.zeros(output_shape, dtype=output_dtype)\n\n    ret_val = func(11 if transpose else 10,\n                   scalar,\n                   mkl_a,\n                   matrix_descr(),\n                   vector_b,\n                   1.,\n                   output_arr.ctypes.data_as(_ctypes.POINTER(output_ctype)))\n\n    # Check return\n    if ret_val != 0:\n        err_msg = ""{fn} returned {v} ({e})"".format(fn=func.__name__, v=ret_val, e=RETURN_CODES[ret_val])\n        raise ValueError(err_msg)\n\n    _destroy_mkl_handle(mkl_a)\n\n    return output_arr\n\n\ndef _sparse_dot_vector(mv_a, mv_b, cast=False, dprint=print, scalar=1.):\n    """"""\n    Multiply a sparse matrix by a dense vector.\n    The matrix must be CSR or CSC format.\n    The vector must be (N,) or (N, 1) shape.\n    Returns a dense vector of (N,) or (N, 1) shape (depending on vector)\n\n    :param mv_a: Left (A) matrix or vector\n    :type mv_a: np.ndarray, sp.spmatrix.csr, sp.spmatrix.csc\n    :param mv_b: Right (B) matrix or vector\n    :type mv_b: np.ndarray, sp.spmatrix.csr, sp.spmatrix.csc\n    :param scalar: A value to multiply the result matrix by. Defaults to 1.\n    :type scalar: float\n    :param cast: Convert values to compatible floats if True. Raise an error if they are not compatible if False.\n    Defaults to False.\n    :type cast: bool\n    :param dprint: A function that will handle debug strings. Defaults to print.\n    :type dprint: function\n\n    :return: A (dot) B as a dense matrix\n    :rtype: np.ndarray\n    """"""\n\n    _sanity_check(mv_a, mv_b, allow_vector=True)\n    mv_a, mv_b = _type_check(mv_a, mv_b, cast=cast, dprint=dprint)\n\n    if _is_dense_vector(mv_b):\n        return _sparse_dense_vector_mult(mv_a, mv_b, scalar=scalar)\n    elif _is_dense_vector(mv_a):\n        return _sparse_dense_vector_mult(mv_b, mv_a.T, scalar=scalar, transpose=True).T\n'"
sparse_dot_mkl/sparse_dot.py,8,"b'from sparse_dot_mkl._sparse_sparse import _sparse_dot_sparse as _sds\nfrom sparse_dot_mkl._sparse_dense import _sparse_dot_dense as _sdd\nfrom sparse_dot_mkl._dense_dense import _dense_dot_dense as _ddd\nfrom sparse_dot_mkl._sparse_vector import _sparse_dot_vector as _sdv\nfrom sparse_dot_mkl._gram_matrix import _gram_matrix as _gm\nfrom sparse_dot_mkl._sparse_qr_solver import sparse_qr_solver as _qrs\nfrom sparse_dot_mkl._mkl_interface import get_version_string, _is_dense_vector\nimport scipy.sparse as _spsparse\nimport numpy as _np\n\n\ndef dot_product_mkl(matrix_a, matrix_b, cast=False, copy=True, reorder_output=False, dense=False, debug=False):\n    """"""\n    Multiply together matrixes using the intel Math Kernel Library.\n    This currently only supports float32 and float64 data\n\n    :param matrix_a: Sparse matrix A in CSC/CSR format or dense matrix in numpy format\n    :type matrix_a: scipy.sparse.spmatrix, np.ndarray\n    :param matrix_b: Sparse matrix B in CSC/CSR format or dense matrix in numpy format\n    :type matrix_b: scipy.sparse.spmatrix, np.ndarray\n    :param cast: Should the data be coerced into float64 if it isn\'t float32 or float64\n    If set to True and any other dtype is passed, the matrix data will copied internally before multiplication\n    If set to False and any dtype that isn\'t float32 or float64 is passed, a ValueError will be raised\n    Defaults to False\n    :param copy: Deprecated flag to force copy. Removed because the behavior was inconsistent.\n    :type copy: bool\n    :param reorder_output: Should the array indices be reordered using MKL\n    If set to True, the object in C will be ordered and then exported into python\n    If set to False, the array column indices will not be ordered.\n    The scipy sparse dot product does not yield ordered column indices so this defaults to False\n    :type reorder_output: bool\n    :param dense: Should the matrix multiplication be put into a dense numpy array\n    This does not require any copy and is memory efficient if the output array density is > 50%\n    Note that this flag has no effect if one input array is dense; then the output will always be dense\n    :type dense: bool\n    :param debug: Should debug and timing messages be printed. Defaults to false.\n    :type debug: bool\n    :return: Matrix that is the result of A * B in input-dependent format\n    :rtype: scipy.sparse.csr_matrix, scipy.sparse.csc_matrix, np.ndarray\n    """"""\n\n    dprint = print if debug else lambda *x: x\n\n    if get_version_string() is None and debug:\n        dprint(""mkl-service must be installed to get full debug messaging"")\n    elif debug:\n        dprint(get_version_string())\n\n    num_sparse = sum((_spsparse.issparse(matrix_a), _spsparse.issparse(matrix_b)))\n\n    # SPARSE (DOT) SPARSE #\n    if num_sparse == 2:\n        return _sds(matrix_a, matrix_b, cast=cast, reorder_output=reorder_output, dense=dense, dprint=dprint)\n\n    # SPARSE (DOT) VECTOR #\n    elif num_sparse == 1 and _is_dense_vector(matrix_a) and (matrix_a.ndim == 1 or matrix_a.shape[0] == 1):\n        return _sdv(matrix_a, matrix_b, cast=cast, dprint=dprint)\n\n    # SPARSE (DOT) VECTOR #\n    elif num_sparse == 1 and _is_dense_vector(matrix_b) and (matrix_b.ndim == 1 or matrix_b.shape[1] == 1):\n        return _sdv(matrix_a, matrix_b, cast=cast, dprint=dprint)\n\n    # SPARSE (DOT) DENSE & DENSE (DOT) SPARSE #\n    elif num_sparse == 1:\n        return _sdd(matrix_a, matrix_b, cast=cast, dprint=dprint)\n\n    # SPECIAL CASE OF VECTOR (DOT) VECTOR #\n    # THIS IS JUST EASIER THAN GETTING THIS EDGE CONDITION RIGHT IN MKL #\n    elif _is_dense_vector(matrix_a) and _is_dense_vector(matrix_b) and (matrix_a.ndim == 1 or matrix_a.ndim == 1):\n        return _np.dot(matrix_a, matrix_b)\n\n    # DENSE (DOT) DENSE\n    else:\n        return _ddd(matrix_a, matrix_b, cast=cast, dprint=dprint)\n\n\ndef gram_matrix_mkl(matrix, transpose=False, cast=False, dense=False, debug=False, reorder_output=False):\n    """"""\n    Calculate a gram matrix (AT (dot) A) matrix.\n    Note that this should calculate only the upper triangular matrix.\n    However providing a sparse matrix with transpose=False and dense=True will calculate a full matrix\n    (this appears to be a bug in mkl_sparse_?_syrkd)\n\n    :param matrix: Sparse matrix in CSR or CSC format or numpy array\n    :type matrix: scipy.sparse.csr_matrix, scipy.sparse.csc_matrix, numpy.ndarray\n    :param transpose: Calculate A (dot) AT instead\n    :type transpose: bool\n    :param cast: Make internal copies to convert matrix to a float matrix or convert to a CSR matrix if necessary\n    :type cast: bool\n    :param dense: Produce a dense matrix output instead of a sparse matrix\n    :type dense: bool\n    :param debug: Should debug and timing messages be printed. Defaults to false.\n    :type debug: bool\n    :param reorder_output: Should the array indices be reordered using MKL\n    The scipy sparse dot product does not yield ordered column indices so this defaults to False\n    :type reorder_output: bool\n    :return: Gram matrix\n    :rtype: scipy.sparse.csr_matrix, np.ndarray""""""\n    \n    dprint = print if debug else lambda *x: x\n\n    if get_version_string() is None and debug:\n        dprint(""mkl-service must be installed to get full debug messaging"")\n    elif debug:\n        dprint(get_version_string())\n\n    return _gm(matrix, transpose=transpose, cast=cast, dense=dense, reorder_output=reorder_output)\n\n\ndef sparse_qr_solve_mkl(matrix_a, matrix_b, cast=False, debug=False):\n    """"""\n    Solve AX = B for X where A is sparse and B is dense\n\n    :param matrix_a: Sparse matrix (solver requires CSR; will convert if cast=True)\n    :type matrix_a: np.ndarray\n    :param matrix_b: Dense matrix\n    :type matrix_b: np.ndarray\n    :param cast: Should the data be coerced into float64 if it isn\'t float32 or float64,\n    and should a CSR matrix be cast to a CSC matrix.\n    Defaults to False\n    :type cast: bool\n    :param debug: Should debug messages be printed. Defaults to false.\n    :type debug: bool\n    :return: Dense array X\n    :rtype: np.ndarray\n    """"""\n    \n    dprint = print if debug else lambda *x: x\n    \n    if get_version_string() is None and debug:\n        dprint(""mkl-service must be installed to get full debug messaging"")\n    elif debug:\n        dprint(get_version_string())\n        \n    return _qrs(matrix_a, matrix_b, cast=cast, dprint=dprint)\n\n  \n# Alias for backwards compatibility\ndot_product_transpose_mkl = gram_matrix_mkl\n'"
sparse_dot_mkl/tests/__init__.py,0,b''
sparse_dot_mkl/tests/test_mkl.py,117,"b'import os\n\nos.environ[""MKL_NUM_THREADS""] = ""1""\n\nimport unittest\nimport numpy as np\nimport numpy.testing as npt\nimport scipy.sparse as _spsparse\nfrom sparse_dot_mkl import dot_product_mkl, gram_matrix_mkl, sparse_qr_solve_mkl\nfrom sparse_dot_mkl._mkl_interface import (_create_mkl_sparse, _export_mkl, sparse_matrix_t, _destroy_mkl_handle,\n                                           _convert_to_csr, _order_mkl_handle, MKL)\nfrom sparse_dot_mkl._sparse_sparse import _matmul_mkl\n\nSEED = 86\n\n\ndef make_matrixes(a, b, n, density):\n    m1 = _spsparse.random(a, n, density=density, format=""csr"", dtype=np.float64, random_state=SEED)\n    m2 = _spsparse.random(n, b, density=density, format=""csr"", dtype=np.float64, random_state=SEED + 1)\n    return m1, m2\n\n\nMATRIX_1, MATRIX_2 = make_matrixes(200, 100, 300, 0.05)\nVECTOR = np.random.rand(300).astype(np.float64)\nMATRIX_1_EMPTY = _spsparse.csr_matrix((200, 300), dtype=np.float64)\n\n\nclass TestHandles(unittest.TestCase):\n\n    def setUp(self):\n        self.mat1 = MATRIX_1.copy()\n        self.mat2 = MATRIX_2.copy()\n\n    @staticmethod\n    def is_sparse_identical_internal(sparse_1, sparse_2):\n        npt.assert_array_almost_equal(sparse_1.data, sparse_2.data)\n        npt.assert_array_equal(sparse_1.indptr, sparse_2.indptr)\n        npt.assert_array_equal(sparse_1.indices, sparse_2.indices)\n\n    def is_sparse_identical_A(self, sparse_1, sparse_2):\n        self.assertEqual(np.sum((sparse_1 != sparse_2).data), 0)\n\n    def test_create_export(self):\n        mat1 = _spsparse.csc_matrix(self.mat1).copy()\n        mat2 = self.mat2.copy()\n        mat3 = mat1.astype(np.float32).copy()\n        mat4 = self.mat2.astype(np.float32).copy()\n\n        ref_1, precision_1 = _create_mkl_sparse(mat1)\n        ref_2, precision_2 = _create_mkl_sparse(mat2)\n        ref_3, precision_3 = _create_mkl_sparse(mat3)\n        ref_4, precision_4 = _create_mkl_sparse(mat4)\n\n        self.assertTrue(precision_1)\n        self.assertTrue(precision_2)\n        self.assertFalse(precision_3)\n        self.assertFalse(precision_4)\n\n        cycle_1 = _export_mkl(ref_1, precision_1, output_type=""csc"")\n        cycle_2 = _export_mkl(ref_2, precision_2)\n        cycle_3 = _export_mkl(ref_3, precision_3, output_type=""csc"")\n        cycle_4 = _export_mkl(ref_4, precision_4)\n\n        self.is_sparse_identical_A(self.mat1, cycle_1)\n        self.is_sparse_identical_internal(self.mat2, cycle_2)\n        self.is_sparse_identical_A(self.mat1.astype(np.float32), cycle_3)\n        self.is_sparse_identical_internal(self.mat2.astype(np.float32), cycle_4)\n\n\nclass TestMultiplication(unittest.TestCase):\n\n    def setUp(self):\n        self.mat1 = MATRIX_1.copy()\n        self.mat2 = MATRIX_2.copy()\n\n    def test_spmm_success(self):\n        ref_1, precision_1 = _create_mkl_sparse(self.mat1)\n        ref_2, precision_2 = _create_mkl_sparse(self.mat2)\n\n        self.assertTrue(precision_1)\n        self.assertTrue(precision_2)\n\n        ref_3 = _matmul_mkl(ref_1, ref_2)\n        mat3 = _export_mkl(ref_3, precision_1 or precision_2)\n\n        mat3_sp = self.mat1.dot(self.mat2)\n        mat3_np = np.dot(self.mat1.A, self.mat2.A)\n\n        npt.assert_array_almost_equal(mat3.A, mat3_sp.A)\n        npt.assert_array_almost_equal(mat3_np, mat3.A)\n\n    def test_spmm_success_float32(self):\n        self.mat1.data = self.mat1.data.astype(np.float32)\n        self.mat2.data = self.mat2.data.astype(np.float32)\n\n        ref_1, precision_1 = _create_mkl_sparse(self.mat1)\n        ref_2, precision_2 = _create_mkl_sparse(self.mat2)\n\n        self.assertFalse(precision_1)\n        self.assertFalse(precision_2)\n\n        ref_3 = _matmul_mkl(ref_1, ref_2)\n        mat3 = _export_mkl(ref_3, precision_1 or precision_2, output_type=""csr"")\n\n        mat3_sp = self.mat1.dot(self.mat2)\n        mat3_np = np.dot(self.mat1.A, self.mat2.A)\n\n        npt.assert_array_almost_equal(mat3.A, mat3_sp.A)\n        npt.assert_array_almost_equal(mat3_np, mat3.A)\n\n    def test_spmm_error_bad_dims(self):\n        ref_1, prec_1 = _create_mkl_sparse(self.mat1.transpose())\n        ref_2, prec_2 = _create_mkl_sparse(self.mat2)\n\n        with self.assertRaises(ValueError):\n            _matmul_mkl(ref_1, ref_2)\n\n    def test_spmm_error_bad_handle(self):\n        with self.assertRaises(ValueError):\n            _matmul_mkl(sparse_matrix_t(), sparse_matrix_t())\n\n    def test_csr_dot_product_mkl(self):\n        mat3 = dot_product_mkl(self.mat1, self.mat2)\n\n        mat3_sp = self.mat1.dot(self.mat2)\n        mat3_np = np.dot(self.mat1.A, self.mat2.A)\n\n        npt.assert_array_almost_equal(mat3.A, mat3_sp.A)\n        npt.assert_array_almost_equal(mat3_np, mat3.A)\n\n    def test_csr_error_bad_dims(self):\n        with self.assertRaises(ValueError):\n            mat3 = dot_product_mkl(self.mat1.transpose(), self.mat2)\n\n    def test_csr_all_zeros(self):\n        zero_mat_1 = _spsparse.csr_matrix((50, 100))\n        zero_mat_2 = _spsparse.csr_matrix((100, 20))\n\n        zm_sp = zero_mat_1.dot(zero_mat_2)\n        zm_mkl = dot_product_mkl(zero_mat_1, zero_mat_2)\n\n        self.assertTupleEqual(zm_sp.shape, zm_mkl.shape)\n        self.assertEqual(len(zm_mkl.data), 0)\n\n    def test_highly_sparse_CSR(self):\n        hsp1, hsp2 = make_matrixes(2000, 1000, 3000, 0.0005)\n        hsp3_sp = hsp1.dot(hsp2)\n        hsp3 = dot_product_mkl(hsp1, hsp2)\n\n        npt.assert_array_almost_equal(hsp3.A, hsp3_sp.A)\n\n    def test_highly_highly_sparse_CSR(self):\n        hsp1, hsp2 = make_matrixes(2000, 1000, 3000, 0.000005)\n        hsp3_sp = hsp1.dot(hsp2)\n        hsp3 = dot_product_mkl(hsp1, hsp2)\n\n        npt.assert_array_almost_equal(hsp3.A, hsp3_sp.A)\n\n    def test_dense_CSR(self):\n        d1, d2 = make_matrixes(10, 20, 50, 1)\n        hsp3_sp = d1.dot(d2)\n        hsp3 = dot_product_mkl(d1, d2)\n\n        npt.assert_array_almost_equal(hsp3.A, hsp3_sp.A)\n        self.assertTrue(hsp3.dtype == np.float64)\n\n    def test_CSC(self):\n        d1, d2 = _spsparse.csc_matrix(self.mat1), _spsparse.csc_matrix(self.mat2)\n\n        hsp3_sp = d1.dot(d2)\n        hsp3 = dot_product_mkl(d1, d2)\n\n        npt.assert_array_almost_equal(hsp3.A, hsp3_sp.A)\n        self.assertTrue(hsp3.dtype == np.float64)\n\n    def test_CSR_CSC(self):\n        d1, d2 = self.mat1, _spsparse.csc_matrix(self.mat2)\n\n        hsp3_sp = d1.dot(d2)\n        hsp3 = dot_product_mkl(d1, d2)\n\n        npt.assert_array_almost_equal(hsp3.A, hsp3_sp.A)\n        self.assertTrue(hsp3.dtype == np.float64)\n\n    def test_CSC_CSR(self):\n        d1, d2 = _spsparse.csc_matrix(self.mat1), self.mat2\n\n        hsp3_sp = d1.dot(d2)\n        hsp3 = dot_product_mkl(d1, d2)\n\n        npt.assert_array_almost_equal(hsp3.A, hsp3_sp.A)\n        self.assertTrue(hsp3.dtype == np.float64)\n\n    def test_COO(self):\n        d1, d2 = _spsparse.coo_matrix(self.mat1), self.mat2\n\n        with self.assertRaises(ValueError):\n            hsp3 = dot_product_mkl(d1, d2)\n\n    def test_mixed(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2\n\n        hsp3_sp = d1.dot(d2)\n        hsp3 = dot_product_mkl(d1, d2, cast=True)\n\n        npt.assert_array_almost_equal(hsp3.A, hsp3_sp.A)\n        self.assertTrue(hsp3.dtype == np.float64)\n\n    def test_mixed_2(self):\n        d1, d2 = self.mat1, self.mat2.astype(np.float32)\n\n        hsp3_sp = d1.dot(d2)\n        hsp3 = dot_product_mkl(d1, d2, cast=True)\n\n        npt.assert_array_almost_equal(hsp3.A, hsp3_sp.A)\n        self.assertTrue(hsp3.dtype == np.float64)\n\n    def test_mixed_nocast(self):\n        d1, d2 = self.mat1, self.mat2.astype(np.float32)\n\n        with self.assertRaises(ValueError):\n            hsp3 = dot_product_mkl(d1, d2, cast=False)\n\n    def test_float32(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2.astype(np.float32)\n\n        hsp3_sp = d1.dot(d2)\n        hsp3 = dot_product_mkl(d1, d2)\n\n        npt.assert_array_almost_equal(hsp3.A, hsp3_sp.A)\n        self.assertTrue(hsp3.dtype == np.float32)\n\n    def test_csr_dot_product_mkl_copy(self):\n        mat3 = dot_product_mkl(self.mat1, self.mat2, copy=True)\n\n        mat3_sp = self.mat1.dot(self.mat2)\n        mat3_np = np.dot(self.mat1.A, self.mat2.A)\n\n        npt.assert_array_almost_equal(mat3.A, mat3_sp.A)\n        npt.assert_array_almost_equal(mat3_np, mat3.A)\n\n    def test_csr_dot_product_mkl_order(self):\n        mat3 = dot_product_mkl(self.mat1, self.mat2, reorder_output=True)\n\n        mat3_sp = self.mat1.dot(self.mat2)\n        mat3_np = np.dot(self.mat1.A, self.mat2.A)\n\n        npt.assert_array_almost_equal(mat3.A, mat3_sp.A)\n        npt.assert_array_almost_equal(mat3_np, mat3.A)\n\n\nclass TestSparseToDenseMultiplication(unittest.TestCase):\n\n    def setUp(self):\n        self.mat1 = MATRIX_1.copy()\n        self.mat2 = MATRIX_2.copy()\n\n    def test_float32_CSR(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2.astype(np.float32)\n        mat3_np = np.dot(d1.A, d2.A)\n\n        mat3 = dot_product_mkl(d1, d2, copy=True, dense=True)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float32_CSC(self):\n        d1, d2 = self.mat1.astype(np.float32).tocsc(), self.mat2.astype(np.float32).tocsc()\n        mat3_np = np.dot(d1.A, d2.A)\n\n        mat3 = dot_product_mkl(d1, d2, copy=True, dense=True)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float64_CSR(self):\n        d1, d2 = self.mat1, self.mat2\n        mat3_np = np.dot(d1.A, d2.A)\n\n        mat3 = dot_product_mkl(d1, d2, copy=True, dense=True)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float64_CSC(self):\n        d1, d2 = self.mat1.tocsc(), self.mat2.tocsc()\n        mat3_np = np.dot(d1.A, d2.A)\n\n        mat3 = dot_product_mkl(d1, d2, copy=True, dense=True)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n\nclass TestDenseDenseMultiplication(unittest.TestCase):\n\n    def setUp(self):\n        self.mat1 = MATRIX_1.copy().A\n        self.mat2 = MATRIX_2.copy().A\n\n    def test_float32(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2.astype(np.float32)\n        mat3_np = np.dot(d1, d2)\n\n        mat3 = dot_product_mkl(d1, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float64(self):\n        d1, d2 = self.mat1, self.mat2\n        mat3_np = np.dot(d1, d2)\n\n        mat3 = dot_product_mkl(d1, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float64_cast(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2\n        mat3_np = np.dot(d1, d2)\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_outer_product(self):\n        d1, d2 = self.mat1[:, 0].reshape(-1, 1).copy(), self.mat2[0, :].reshape(1, -1).copy()\n\n        mat3 = dot_product_mkl(d1, d2)\n        mat3_np = np.dot(d1, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n\nclass TestDenseDenseFCMultiplication(TestDenseDenseMultiplication):\n\n    def setUp(self):\n        self.mat1 = np.asarray(MATRIX_1.copy().A, order=\'F\')\n        self.mat2 = np.asarray(MATRIX_2.copy().A, order=\'C\')\n\n\nclass TestDenseDenseFFMultiplication(TestDenseDenseMultiplication):\n\n    def setUp(self):\n        self.mat1 = np.asarray(MATRIX_1.copy().A, order=\'F\')\n        self.mat2 = np.asarray(MATRIX_2.copy().A, order=\'F\')\n\n\nclass TestDenseDenseCFMultiplication(TestDenseDenseMultiplication):\n\n    def setUp(self):\n        self.mat1 = np.asarray(MATRIX_1.copy().A, order=\'C\')\n        self.mat2 = np.asarray(MATRIX_2.copy().A, order=\'F\')\n\n\nclass TestSparseDenseMultiplication(unittest.TestCase):\n\n    def setUp(self):\n        self.mat1 = MATRIX_1.copy()\n        self.mat2 = MATRIX_2.copy()\n\n        self.mat1_d = MATRIX_1.A\n        self.mat2_d = MATRIX_2.A\n\n    def test_float32_b_sparse(self):\n        d1, d2 = self.mat1_d.astype(np.float32), self.mat2.astype(np.float32)\n\n        mat3 = dot_product_mkl(d1, d2, debug=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float64_b_sparse(self):\n        d1, d2 = self.mat1_d, self.mat2\n\n        mat3 = dot_product_mkl(d1, d2, debug=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float64_cast_b_sparse(self):\n        d1, d2 = self.mat1_d.astype(np.float32), self.mat2\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float32_csc_sparse(self):\n        d1, d2 = self.mat1_d.astype(np.float32), self.mat2.astype(np.float32).tocsc()\n        mat3_np = np.dot(d1, d2.A)\n\n        mat3 = dot_product_mkl(d1, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n        npt.assert_array_almost_equal(d2.A, self.mat2_d)\n\n    def test_float64_csc_sparse(self):\n        d1, d2 = self.mat1_d, self.mat2.tocsc()\n\n        mat3 = dot_product_mkl(d1, d2)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n        npt.assert_array_almost_equal(d2.A, self.mat2_d)\n\n    def test_float64_cast_csc_sparse(self):\n        d1, d2 = self.mat1_d.astype(np.float32), self.mat2.tocsc()\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n        npt.assert_array_almost_equal(d2.A, self.mat2_d)\n\n    def test_float32_a_sparse(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2_d.astype(np.float32)\n\n        mat3 = dot_product_mkl(d1, d2)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float64_a_sparse(self):\n        d1, d2 = self.mat1, self.mat2_d\n\n        mat3 = dot_product_mkl(d1, d2)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_float64_a_csc_sparse(self):\n        d1, d2 = self.mat1.tocsc(), self.mat2_d\n\n        mat3 = dot_product_mkl(d1, d2)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n        npt.assert_array_almost_equal(d1.A, self.mat1_d)\n\n    def test_float32_a_csc_sparse(self):\n        d1, d2 = self.mat1.astype(np.float32).tocsc(), self.mat2_d.astype(np.float32)\n\n        mat3 = dot_product_mkl(d1, d2)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n        npt.assert_array_almost_equal(d1.A, self.mat1_d)\n\n    def test_float64_cast_a_sparse(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2_d\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n\nclass TestSparseDenseFMultiplication(TestSparseDenseMultiplication):\n\n    def setUp(self):\n        self.mat1 = MATRIX_1.copy()\n        self.mat2 = MATRIX_2.copy()\n\n        self.mat1_d = np.asarray(MATRIX_1.A, order=""F"")\n        self.mat2_d = np.asarray(MATRIX_2.A, order=""F"")\n\n\nclass TestSparseVectorMultiplication(unittest.TestCase):\n\n    def setUp(self):\n        self.mat1 = MATRIX_1.copy()\n        self.mat2 = VECTOR.copy()\n\n    def test_mult_1d(self):\n        d1, d2 = self.mat1.astype(np.float64), self.mat2\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_1d_float32(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_1d_both_float32(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2.astype(np.float32)\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_2d(self):\n        d1, d2 = self.mat1.astype(np.float64), self.mat2.reshape(-1, 1)\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_2d_float32(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2.reshape(-1, 1)\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_2d_both_float32(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2.reshape(-1, 1).astype(np.float32)\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n\nclass TestVectorSparseMultiplication(unittest.TestCase):\n\n    def setUp(self):\n        self.mat1 = VECTOR.copy()\n        self.mat2 = MATRIX_2.copy()\n\n        self.mat2_d = np.asarray(MATRIX_2.A, order=""C"")\n\n    def test_mult_1d(self):\n        d1, d2 = self.mat1.astype(np.float64), self.mat2\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_1d_float32(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_1d_both_float32(self):\n        d1, d2 = self.mat1.astype(np.float32), self.mat2.astype(np.float32)\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_2d(self):\n        d1, d2 = self.mat1.astype(np.float64).reshape(1, -1), self.mat2\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_2d_float32(self):\n        d1, d2 = self.mat1.astype(np.float32).reshape(1, -1), self.mat2\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_2d_both_float32(self):\n        d1, d2 = self.mat1.astype(np.float32).reshape(1, -1), self.mat2.astype(np.float32)\n\n        mat3 = dot_product_mkl(d1, d2, cast=True)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_outer_product_ds(self):\n        d1, d2 = self.mat1.reshape(-1, 1), _spsparse.csr_matrix(self.mat2_d[:, 0].reshape(1, -1))\n\n        mat3 = dot_product_mkl(d1, d2)\n        mat3_np = np.dot(d1, d2.A)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_mult_outer_product_sd(self):\n        d1, d2 = _spsparse.csr_matrix(self.mat1.reshape(-1, 1)), self.mat2_d[:, 0].reshape(1, -1).copy()\n\n        mat3 = dot_product_mkl(d1, d2)\n        mat3_np = np.dot(d1.A, d2)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n\nclass TestVectorVectorMultplication(unittest.TestCase):\n\n    def test_1d_1d(self):\n        mat3 = dot_product_mkl(VECTOR, VECTOR)\n        mat3_np = np.dot(VECTOR, VECTOR)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_1d_2d(self):\n        mat3 = dot_product_mkl(VECTOR, VECTOR.reshape(-1, 1))\n        mat3_np = np.dot(VECTOR, VECTOR.reshape(-1, 1))\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_2d_1d(self):\n        mat3 = dot_product_mkl(VECTOR.reshape(1, -1), VECTOR)\n        mat3_np = np.dot(VECTOR.reshape(1, -1), VECTOR)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_2d_2d(self):\n        mat3 = dot_product_mkl(VECTOR.reshape(1, -1), VECTOR.reshape(-1, 1))\n        mat3_np = np.dot(VECTOR.reshape(1, -1), VECTOR.reshape(-1, 1))\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n\nclass TestEmptyConditions(unittest.TestCase):\n\n    def setUp(self):\n        self.mat1 = MATRIX_1_EMPTY.copy()\n        self.mat2 = MATRIX_2.copy()\n\n        self.mat1_d = np.asarray(MATRIX_1_EMPTY.A, order=""C"")\n        self.mat2_d = np.asarray(MATRIX_2.A, order=""C"")\n\n        self.mat1_zero = np.zeros((0, 300))\n\n    def test_sparse_sparse(self):\n        mat3 = dot_product_mkl(self.mat1, self.mat2)\n        mat3_np = np.dot(self.mat1_d, self.mat2_d)\n\n        npt.assert_array_almost_equal(mat3_np, mat3.A)\n\n    def test_sparse_dense(self):\n        mat3 = dot_product_mkl(self.mat1, self.mat2_d)\n        mat3_np = np.dot(self.mat1_d, self.mat2_d)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_sparse_vector(self):\n        mat3 = dot_product_mkl(self.mat1, self.mat2_d[:, 0])\n        mat3_np = np.dot(self.mat1_d, self.mat2_d[:, 0])\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n    def test_dense_dense(self):\n        mat3 = dot_product_mkl(self.mat1_zero, self.mat2_d)\n        mat3_np = np.dot(self.mat1_zero, self.mat2_d)\n\n        npt.assert_array_almost_equal(mat3_np, mat3)\n\n\nclass TestGramMatrix(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        gram_ut = np.dot(MATRIX_1.A.T, MATRIX_1.A)\n        gram_ut[np.tril_indices(gram_ut.shape[0], k=-1)] = 0.\n        cls.gram_ut = gram_ut\n\n        gram_ut_t = np.dot(MATRIX_1.A, MATRIX_1.A.T)\n        gram_ut_t[np.tril_indices(gram_ut_t.shape[0], k=-1)] = 0.\n        cls.gram_ut_t = gram_ut_t\n\n    def setUp(self):\n        self.mat1 = MATRIX_1.copy()\n        self.mat1_d = MATRIX_1.A\n\n    def test_gram_matrix_sp(self):\n        mat2 = gram_matrix_mkl(self.mat1)\n        npt.assert_array_almost_equal(mat2.A, self.gram_ut)\n\n    def test_gram_matrix_sp_single(self):\n        mat2 = gram_matrix_mkl(self.mat1.astype(np.float32))\n        npt.assert_array_almost_equal(mat2.A, self.gram_ut)\n\n    def test_gram_matrix_d_single(self):\n        mat2 = gram_matrix_mkl(self.mat1.astype(np.float32), dense=True)\n        npt.assert_array_almost_equal(mat2, self.gram_ut)\n\n    def test_gram_matrix_d(self):\n        mat2 = gram_matrix_mkl(self.mat1, dense=True)\n        npt.assert_array_almost_equal(mat2, self.gram_ut)\n\n    def test_gram_matrix_sp_t(self):\n        mat2 = gram_matrix_mkl(self.mat1, transpose=True)\n        npt.assert_array_almost_equal(mat2.A, self.gram_ut_t)\n\n    def test_gram_matrix_d_t(self):\n        mat2 = gram_matrix_mkl(self.mat1, dense=True, transpose=True)\n        npt.assert_array_almost_equal(mat2, self.gram_ut_t)\n\n    def test_gram_matrix_csc_sp(self):\n        mat2 = gram_matrix_mkl(self.mat1.tocsc(), cast=True)\n        npt.assert_array_almost_equal(mat2.A, self.gram_ut)\n\n    def test_gram_matrix_csc_d(self):\n        mat2 = gram_matrix_mkl(self.mat1.tocsc(), dense=True, cast=True)\n        npt.assert_array_almost_equal(mat2, self.gram_ut)\n\n    def test_gram_matrix_dd_double(self):\n        mat2 = gram_matrix_mkl(self.mat1.A, dense=True)\n        npt.assert_array_almost_equal(mat2, self.gram_ut)\n\n    def test_gram_matrix_dd_single(self):\n        mat2 = gram_matrix_mkl(self.mat1.astype(np.float32).A, dense=True)\n        npt.assert_array_almost_equal(mat2, self.gram_ut)\n\n    def test_gram_matrix_dd_double_F(self):\n        mat2 = gram_matrix_mkl(np.asarray(self.mat1.A, order=""F""), dense=True)\n        npt.assert_array_almost_equal(mat2, self.gram_ut)\n\n    def test_gram_matrix_dd_single_F(self):\n        mat2 = gram_matrix_mkl(np.asarray(self.mat1.astype(np.float32).A, order=""F""), dense=True)\n        npt.assert_array_almost_equal(mat2, self.gram_ut)\n\n\nclass TestSparseSolver(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        cls.A = _spsparse.diags((MATRIX_1.data[0:100].copy()), format=""csr"")\n        cls.B = MATRIX_1.data[0:100].copy().reshape(-1, 1)\n        cls.X = np.linalg.lstsq(cls.A.A, cls.B, rcond=None)[0]\n\n    def setUp(self):\n        self.mat1 = self.A.copy()\n        self.mat2 = self.B.copy()\n        self.mat3 = self.X.copy()\n\n    def test_sparse_solver(self):\n        mat3 = sparse_qr_solve_mkl(self.mat1, self.mat2, debug=True)\n        npt.assert_array_almost_equal(self.mat3, mat3)\n\n    def test_sparse_solver_single(self):\n        mat3 = sparse_qr_solve_mkl(self.mat1.astype(np.float32), self.mat2.astype(np.float32))\n        npt.assert_array_almost_equal(self.mat3, mat3)\n\n    def test_sparse_solver_cast_B(self):\n        mat3 = sparse_qr_solve_mkl(self.mat1, self.mat2.astype(np.float32), cast=True)\n        npt.assert_array_almost_equal(self.mat3, mat3)\n\n    def test_sparse_solver_cast_A(self):\n        mat3 = sparse_qr_solve_mkl(self.mat1.astype(np.float32), self.mat2, cast=True)\n        npt.assert_array_almost_equal(self.mat3, mat3)\n\n    def test_sparse_solver_cast_CSC(self):\n        mat3 = sparse_qr_solve_mkl(self.mat1.tocsc(), self.mat2, cast=True)\n        npt.assert_array_almost_equal(self.mat3, mat3)\n\n    def test_sparse_solver_1d_d(self):\n        mat3 = sparse_qr_solve_mkl(self.mat1, self.mat2.ravel())\n        npt.assert_array_almost_equal(self.mat3.ravel(), mat3)\n\n    def test_solver_guard_errors(self):\n        with self.assertRaises(ValueError):\n            mat3 = sparse_qr_solve_mkl(self.mat1, self.mat2.T)\n\n        with self.assertRaises(ValueError):\n            mat3 = sparse_qr_solve_mkl(self.mat1.tocsc(), self.mat2)\n\n        with self.assertRaises(ValueError):\n            mat3 = sparse_qr_solve_mkl(self.mat1.tocoo(), self.mat2, cast=True)\n\n\nclass TestFailureConditions(unittest.TestCase):\n\n    def setUp(self):\n        self.mat1 = MATRIX_1.copy()\n        self.mat2 = MATRIX_2.copy()\n        self.vec = VECTOR.copy()\n\n    def test_make_mkl_bad_type(self):\n        with self.assertRaises(ValueError):\n            _create_mkl_sparse(self.mat1.tocoo())\n\n        with self.assertRaises(ValueError):\n            _create_mkl_sparse(self.mat1.astype(np.int64))\n\n    def test_export_mkl_bad_type(self):\n        mkl_handle, dbl = _create_mkl_sparse(self.mat1)\n\n        with self.assertRaises(ValueError):\n            _export_mkl(mkl_handle, dbl, output_type=""coo"")\n\n        _destroy_mkl_handle(mkl_handle)\n\n    def test_empty_handle(self):\n        mkl_handle_empty = sparse_matrix_t()\n\n        with self.assertRaises(ValueError):\n            _export_mkl(mkl_handle_empty, True, output_type=""csr"")\n\n        with self.assertRaises(ValueError):\n            _convert_to_csr(mkl_handle_empty)\n\n        with self.assertRaises(ValueError):\n            _order_mkl_handle(mkl_handle_empty)\n\n        with self.assertRaises(ValueError):\n            _destroy_mkl_handle(mkl_handle_empty)\n\n    def test_3d_matrixes(self):\n        d1, d2 = self.mat1.A.reshape(200, 300, 1), self.mat2.A.reshape(300, 100, 1)\n\n        with self.assertRaises(ValueError):\n            dot_product_mkl(d1, d2)\n\n        with self.assertRaises(ValueError):\n            dot_product_mkl(d1, self.mat2)\n\n        with self.assertRaises(ValueError):\n            dot_product_mkl(self.mat1, d2)\n\n    def test_bad_shapes(self):\n        with self.assertRaises(ValueError):\n            dot_product_mkl(self.vec.reshape(-1, 1), self.mat2)\n\n        with self.assertRaises(ValueError):\n            dot_product_mkl(self.mat1, self.vec.reshape(1, -1))\n\n        with self.assertRaises(ValueError):\n            dot_product_mkl(self.vec.reshape(-1, 1), self.vec.reshape(-1, 1))\n\n        with self.assertRaises(ValueError):\n            dot_product_mkl(self.mat1.transpose(), self.mat2)\n\n        with self.assertRaises(ValueError):\n            dot_product_mkl(self.vec[100:], self.vec)\n\n    def test_lets_be_honest_this_is_just_to_make_codecov_bigger(self):\n        with self.assertRaises(NotImplementedError):\n            MKL()\n\n\ndef run():\n    unittest.main(module=\'sparse_dot_mkl.tests.test_mkl\')\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
