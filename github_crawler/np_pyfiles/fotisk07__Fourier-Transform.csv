file_path,api_count,code
run.py,0,"b'import argparse\nimport utils\n\n# Initialize the Parser and add the argument\nap=argparse.ArgumentParser(description=""Arguments for running the visualisation script"")\nap.add_argument(\'-s\',\'--list\',type=float,dest=\'s\', nargs=\'+\',help=""The different sinuses to construct the signal"", required=True)\nap.add_argument(""--n"", type=str, dest=""n"",help=""A boolean value to sepcify whether to use my own implementation of the FFT(True) or the numpy command(False)"", default = ""False"")\n\n# Get the different sinuses\npa = ap.parse_args()\nsinuses = pa.s\nn = pa.n\n\n\ns , t = utils.signal(sinuses) # Create, plot and save the signal\nutils.Fourier(s, t, n) # Decompose it, plot it and save it\n'"
utils.py,9,"b'import numpy as np\nimport matplotlib.pyplot as plt\n\ndef signal(sinuses):\n    \'\'\' This function creates a function f(x) = sin(a*pi*2)+sin(b*p*2)+...\n     plots the graph of f(x) and saves it\n\n    Args:\n        sinuses(Float) : The list of constants a,b,c,...\n\n    Returns:\n        t (numpy array): X axis\n        s (numpy array): Y axis\n    \'\'\'\n    # Create the singal as a sum of different sinuses\n    t = np.linspace(0, 0.5, 800)\n    s=0\n    for i in range(len(sinuses)):\n        s += np.sin(sinuses[i] * 2 * np.pi * t)\n\n    # Plot the signal\n    plt.style.use(\'seaborn\')\n    fig = plt.figure(figsize=(8,4))\n    ax = fig.add_subplot(1,1,1)\n\n    ax.plot(t, s, label = r\'$y=f(x)$\')\n\n    ax.set_title("" Signal "", fontsize = 20)\n    ax.set_ylabel(""Amplitude"")\n    ax.set_xlabel(""Time [s]"")\n\n    ax.legend(loc=\'best\')\n    ax.grid(True)\n    plt.show()\n    fig.savefig(\'signal.png\')\n    return s, t\n\ndef Fourier(s, t, alg = ""False""):\n    \'\'\'This function performs the FFT in the function f(x) defined in signal function, plots and saves the figure\n\n    Args:\n        t (numpy array): X axis\n        s (numpy array): Y axis\n        alg (string): Variable to determine whether to use my FFT or numpy\'s\n    \'\'\'\n\n    #Perform the Fourier Transform\n    if alg == ""True"":\n        fft = FFT(s)\n    else:\n        fft = np.fft.fft(s)\n\n    T = t[1] - t[0]  # sample rate\n    N = s.size\n\n    # 1/T = frequency\n    f = np.linspace(0, 1 / T, N)\n\n    # Plot the signal Decomposition\n    plt.style.use(\'seaborn\')\n    fig = plt.figure(figsize=(8,4))\n    ax = fig.add_subplot(1,1,1)\n\n    ax.set_title("" Decomposed Signal "", fontsize = 20)\n    ax.set_ylabel(""Amplitude"")\n    ax.set_xlabel(""Frequency [Hz]"")\n\n    ax.bar(f[:N // 2], np.abs(fft)[:N // 2] * 1 / N, width=1.5)  # 1 / N is a normalization factor\n    ax.grid(False)\n    plt.show()\n    fig.savefig(""Decomposed_signal.png"")\n\ndef FFT(x):\n    """"""Compute the discrete Fourier Transform of the signal x\n\n    Args:\n        x (numpy array): The function f(x)\n\n    Returns:\n        M (numpy array): The FFT\n    """"""\n\n    x = np.asarray(x, dtype=float)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    M = np.exp(-2j * np.pi * k * n / N)\n    return np.dot(M, x)\n'"
