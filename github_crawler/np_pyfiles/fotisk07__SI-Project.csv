file_path,api_count,code
SLAM/PointsGeneration.py,4,"b'# Main program loop for LiSim simulation\nfrom scipy.special import expit\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cv2\nfrom cv2 import VideoWriter, VideoWriter_fourcc\nimport time\nimport sys\nfrom LeadSim import sim\nfrom LiSim import simResultProcess as prc\nfrom LiSim import path_gen as gen\nfrom LiMap.map_utils import map\nfrom LiMap.user_utils import plot\nimport argparse\n\npoints = [25,25]\n\n\nlidar = sim.Lidar(dim=[40,40], pos=[20,20])\ntrue_carte = lidar.carte\ncarte = lidar.initialCarte\ndata=np.zeros((points[0]*points[1],3))\nfree_start = 5\nocc_start = 5\nstep = 5\n\nfor j in range(0,points[0]):\n    occ = occ_start + j*step\n    if j%2 == 0:\n        print(""Remaining {}/{}"".format(j/2,points[0]/2))\n    for i in range(0,points[1]):\n        free = free_start + step*i\n        for tours_count in range(1,11):\n            #Generate the data points where the measurements must be made\n            measure_points =np.array(gen.measure_turn(lidar.pos, 1))\n            # Simulate measurement\n            simMeasure = lidar.simulate(points=measure_points,show=False,noise=True)\n            #Update carte\n            carte = map.processLidarData(simMeasure, carte, lidar.pos, lidar.dim,occ,free)\n\n        scaled_carte = expit(carte)\n        confusion = prc.genConfusionMatrix(scaled_carte, true_carte,lidar.pos,False)\n        loss = prc.smart_loss(lidar, confusion,False)\n        data[points[0]*j+i][:]=[occ,free,loss]\n\nplot.plotData(true_carte,""Real-Map"",lidar.pos,show=True)\n\nnp.savetxt(\'Analysis/Loss_Points.txt\', data, delimiter=\',\')\nnp.savetxt(\'Analysis/Gradient_Descent/Loss_Points.txt\', data, delimiter=\',\')\n'"
SLAM/Simulateur_carte.py,3,"b'# Main program loop for LiSim simulation\nfrom scipy.special import expit\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cv2\nfrom cv2 import VideoWriter, VideoWriter_fourcc\nimport time\nimport sys\nfrom LeadSim.Lidar import sim\nfrom LeadSim.Lidar import simResultProcess as prc\nfrom LeadSim.Lidar import path_gen as gen\nfrom LeadMap.map_utils import map\nfrom LeadSim.Lidar.Plot import Carte_plot as cplot\nfrom LeadSim.Lidar.Plot import Confidence as conf\nimport argparse\n\nnp.set_printoptions(precision=3)\nnp.set_printoptions(suppress=True)\n\nparser = argparse.ArgumentParser(\n    description=\'\'\' \\\n    A program that simulates LiDAR measurements\n    ---------------------------------------------------\n        The simulated measurements are then processed.\n        The program uses the LiMap utility for mapping\n    and the LiSim (which is dependent on LiMap) for all\n    simulations purposes.\n        \'\'\',\n\n    formatter_class=argparse.RawDescriptionHelpFormatter,\n    epilog=""""""\\\n    ---------------------------------------------------\n        This software is released under the MIT license\n    (more details in LICENSE.md)\n        Initial work:\n        Alexander Flamant\n        Theodore Halley\n        Fotios Kapotos\n        Mateo Rivera\n     """""")\nparser.add_argument(""-d"",""--dimensions"",\n    nargs=2,\n    help=""""""\\\n        This should be the x y size of the map.\n    ex: ""10 10""\n    """""",\n    type=int\n)\nparser.add_argument(""-p"",""--position"",\n    nargs=2,\n    help=""""""\\\n        This should be the starting x y coordinates of\n    the LiDAR separated with a space. ex: ""5 5""\n    """""",\n    type=int\n)\nparser.add_argument(""-n"", ""--noise"",\n    help=""""""\\\n        Add this option if you wish to add noise to the\n    simulated data.\n    """""",\n    action=""store_true""\n)\nparser.add_argument(""-s"", ""--save"",\n    help=""""""\\\n        Add this option if you wish to save your files in a dedicated folder in\n        examples or just the default\n    """""",\n    action=""store_true""\n)\nparser.add_argument(""-ani"", ""--animate"",\n    help=""""""\\\n        Add this option if you wish to display the mapping in an animated mode\n    """""",\n    action=""store_true""\n)\nparser.add_argument(""-g"", ""--graphs"",\n    help=""""""\\\n        Add this option if you want to display the finished graphs and the loss evolution\n    """""",\n    action=""store_true""\n)\nparser.add_argument(""-stats"", ""--stats"",\n    help=""""""\\\n        Add this option if you want to save a txt file with all the parameters\n    """""",\n    action=""store_true""\n)\nparser.add_argument(""-video"", ""--video"",\n    help=""""""\\\n        Add this option if you want to save an avi file with the animation\n    """""",\n    action=""store_true""\n)\nparser.add_argument(""-rl"", ""--relativeLoss"",\n    help=""""""\\\n        Add this option if you want to save an avi file with the animation\n    """""",\n    action=""store_true""\n)\nparser.add_argument(""-tours"", ""--tours_number"",type=int,\n    help=""""""\\\n        Number of tours\n    """""",\n    default=100000\n)\nargs = parser.parse_args()\ntry:\n    dim = tuple(args.dimensions)\n    pos = tuple(args.position)\nexcept:\n    pass\nisNoisy = args.noise\nchangeEx = args.save\nanimate = args.animate\ngraphs = args.graphs\nstats = args.stats\nvideo = args.video\nrelativeLoss = args.relativeLoss\ntours_number = args.tours_number\nnorm_scale = 0.01 #Map Scaling variable\nFPT = 1 #How many times the map will be update before plotted\nlogloss = [] #Logloss list for plotting\n\n\n\n#Initialize and get base info from LiSim\ntry:\n    lidar = sim.Lidar(dim=dim,pos=pos, uDist=3)\n    print(""Hey"")\nexcept:\n    lidar = sim.Lidar()\n\ntrue_carte = lidar.carte\ncarte = lidar.initialCarte\n\n\n# Setup save file paths for the simulation\nif changeEx:\n    path = ""Examples/dim=""+str(dim)+""_pos="" +  str(lidar.pos)\n    cplot.setuprootPath(path)\nelse:\n    path = ""Examples/default""\n    cplot.setuprootPath()\n\n\nstart = time.time() #start the clock\nfor tours_count in range(1,tours_number+1):\n    #Generate the data points where the measurements must be made\n    measure_points =np.array(gen.measure_turn(lidar.pos, 1))\n    # Simulate measurement\n    simMeasure = lidar.simulate(points=measure_points,show=False,noise=isNoisy)\n    #Update carte\n    carte = map.processLidarData(simMeasure, carte, lidar.pos, lidar.dim, logodd_occ = 80 ,logodd_free = 20)\n    if animate:\n        #Convert carte in 0-1 format\n        scaled_carte = expit(carte*norm_scale)\n        #Animate\n        cplot.animate(scaled_carte,lidar.pos,""Produced Carte"")\n        if cv2.waitKey(1) & 0xFF == ord(\'q\'): break\n        #Generate confusion matrix and logloss\n        confusion = prc.genConfusionMatrix(scaled_carte, true_carte, lidar.pos)\n        logloss.append(prc.smart_loss(lidar, confusion,False))\n    else:\n        scaled_carte = expit(carte*norm_scale)\n        break\n\ncv2.destroyAllWindows()\nanimation_time = time.time()-start # Measure running time\nif animate==True: print(""FPS:"", tours_count/animation_time)\nif animate==True: print(""Loss:"",logloss[-1])\nprint(""Nombre de tours:"",tours_count)\nprint(""Confidence Score:"",conf.confidence(scaled_carte))\n\n#Plot the data\nif graphs == True:\n    confusion = prc.genConfusionMatrix(scaled_carte, true_carte,lidar.pos)\n    cplot.plotData(confusion,""Confusion-Matrix"",lidar.pos)\n    cplot.plotData(true_carte,""Real-Map"",lidar.pos)\n    cplot.plotData(scaled_carte,""Produced-Map"",lidar.pos)\n    if animate == True:\n        cplot.plot_loss(logloss,tours_count)\n    else:\n        print(""Loss"",prc.smart_loss(lidar, confusion,False))\n    plt.show()\n\nif stats == True:\n    stats_for_nerds = {\n    ""Dimensions"" : lidar.dim,\n    ""Position"" : lidar.pos,\n    ""Noise"" : isNoisy,\n    ""uPos"": lidar.uPos,\n    ""uDist"": lidar.uDist,\n    ""uTheta"": lidar.uTheta,\n    ""Angle_step"": lidar.angle_step,\n    ""Ray_step"": lidar.ray_step ,\n    ""Norm Scale"": norm_scale,\n    ""FPT"": FPT,\n    ""Last logloss"": logloss[-1],\n    ""Tours Count"": tours_count,\n    ""FPS"" :tours_count/animation_time,\n    ""Animation Runtime(s)"": animation_time\n    }\n\n    f = open(path+""/stats for nerds.txt"",""w"")\n    f.write(str(stats_for_nerds) )\n    f.close()\n\nif video == True and animate==True:\n    plot.create_video(path)\n'"
SLAM/Simulateur_pos.py,8,"b'from LeadLoc import Kf as kalman\nfrom LeadSim.Position.Encoder import Sim as encSim\nfrom LeadSim.Position.Encoder import ticks_utils as tu\nfrom LeadSim.Position.Gyroscope import Sim as gyroSim\nfrom LeadLoc import plot_utils as plot\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndt=1\nt=21\n#Prediction erros\nerror_est_x = 5\nerror_est_xdot = 1\n# Observation Errors\nerror_obs_x = 5\nerror_obs_xdot = 1\n\nfilterpos = kalman.Filter(error_obs_x,error_est_x, error_est_xdot, error_obs_xdot, dt) #Initialize Kf method\n\nerror_est_theta = 5\nerror_est_thetadot = 50\n# Observation Errors\nerror_obs_theta = 5\nerror_obs_thetadot = 1\n\nfilterangle = kalman.Filter(error_obs_theta,error_est_theta, error_est_thetadot, error_obs_thetadot, dt)\n\n\nticksTours = 10\nstartPos = 2\nstartV = 4\na=0\nstartTheta = 0\nstartThetadot = 20\nthetadotdot = 5\n\nM = np.array([0,0,0,0])\nX = np.array([[startPos],\n              [startV]])\nT = np.array([[startTheta],\n               [startThetadot]])\n\nenc = encSim.Encoder(ticksTours,startV,a,startPos)\ngyro = gyroSim.Gyro(startTheta,startThetadot,thetadotdot)\n\n#fp stands for ""for plotting""\nXV_fp = np.zeros((4,t-1)) #True state\nXP_fp = np.zeros((4,t-1)) #Predicted state\nM_fp = np.zeros((4,t-1))  #Measurements\nM_fp[0][-1] = startPos  #Stupid fix DO NOT TOUCH\nX_fp = np.zeros((4,t-1))  #State\n\n\nfor i in range(1,t,dt):\n    ticks = enc.getTicks(i,noise=True)\n    M[0] = tu.ticks_to_dist(ticks,ticksTours,startPos)\n    M[1] = tu.ticks_to_v(M[0]-M_fp[0][i-2],dt)\n    M[2] = gyro.theta(i,noise=True)\n    M[3] = gyro.thetadot(i,noise=True)\n    X  = filterpos.NewState(X, M[0:2], a)\n    T = filterangle.NewState(T, M[2:4], thetadotdot)\n    #Plotting\n    M_fp[0][i-1]=M[0]\n    M_fp[1][i-1]=M[1]\n    M_fp[2][i-1]=M[2]\n    M_fp[3][i-1]=M[3]\n    XP_fp[0][i-1] = filterpos.XP_fp[0][0]\n    XP_fp[1][i-1] = filterpos.XP_fp[1][0]\n    XP_fp[2][i-1] = filterangle.XP_fp[0][0]\n    XP_fp[3][i-1] = filterangle.XP_fp[1][0]\n    XV_fp[0][i-1] = enc.distance(i)\n    XV_fp[1][i-1] = enc.vel(i)\n    XV_fp[2][i-1] = gyro.theta(i)\n    XV_fp[3][i-1] = gyro.thetadot(i)\n    X_fp[0][i-1]=X[0]\n    X_fp[1][i-1]=X[1]\n    X_fp[2][i-1]=T[0]\n    X_fp[3][i-1]=T[1]\n\n\nplot.plotData(XV_fp[0][:],XP_fp[0][:], M_fp[:][0],X_fp[0][:], t, dt,""Position Inference"",""Position"" , start = startPos)\nplot.plotData(XV_fp[1][:],XP_fp[1][:], M_fp[:][1],X_fp[1][:], t, dt,""Velocity Inference"",""Velocity"" , start = startV)\nplot.plotData(np.fmod(XV_fp[2][:],360), np.fmod(XP_fp[2][:],360), np.fmod(M_fp[:][2],360), np.fmod(X_fp[2][:],360), t, dt,""Angle Inference"",""Angle"" , start = startTheta)\nplot.plotData(XV_fp[3][:],XP_fp[3][:], M_fp[:][3],X_fp[3][:], t, dt,""Angular Velocity Inference"",""Angular Velocity"" , start = startThetadot)\nplt.show()\n'"
SLAM/Analysis/graphGen.py,4,"b'import numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n\ndata = np.loadtxt(""Loss_Points.txt"", delimiter="","")\n\nshape = (25,25)\n\n\nx = np.reshape(data[:,0], shape)\ny = np.reshape(data[:,1], shape)\nz = np.reshape(data[:,2], shape)\nz[0][:] = 0.1\nfig = plt.figure()\nax = fig.add_subplot(111, projection=\'3d\')\n\nax = plt.axes(projection=\'3d\')\nax.plot_surface(x, y, z, rstride=5, cstride=1,\n                cmap=\'winter\', edgecolor=\'none\')\nax.set_title(\'Loss as a function of odd and free\');\nax.set_xlabel(\'Free\')\nax.set_ylabel(""Occ"")\nax.set_zlabel(""Loss"")\nplt.savefig(\'Loss_Graph.png\')\n\n\nplt.show()\n'"
SLAM/LeadLoc/Kf.py,8,"b""import numpy as np\nfrom numpy.linalg import inv\nfrom LeadLoc import predictionMatrix as pM\n\nclass Filter:\n    '''\n    A filter object that predicts the current state using a Kalma filter algorithm\n    Notation:\n    State: X := [x,xdot]\n    Measurements: M := [xMes, xdotMes]\n    Covariance Matrix: P := [[sigmaX , 0], [0, simgaXDot]]\n    '''\n    def __init__(self,error_obs_x,error_est_x, error_est_xdot, error_obs_xdot,dt=1):\n        self.P = pM.covariance2d(error_est_x, error_est_xdot) #Process covariance matrix\n        self.dt = dt\n        self.A = np.array([[1, dt],\n                      [0, 1]])\n        self.H = np.identity(2) #formatting matrix\n        self.R = pM.covariance2d(error_obs_x, error_obs_xdot) # Error in measurement\n        self.S = np.zeros((2,2)) #formatting matrix\n        self.K = np.zeros((2,2)) #Kalman gain\n        self.Y = np.zeros((2,1)) # For reshaping new data to measuremnt space\n        self.XP_fp = np.zeros((2,1))\n\n    def NewState(self, X, M, a):\n            n = len(M) #Array size\n            X = pM.prediction2d(X[0][0], X[1][0], self.dt, a) #Predict state\n            self.XP_fp = X\n\n            # To simplify the problem set off-diagonal terms to 0.\n            self.P = np.diag(np.diag(self.A.dot(self.P).dot(self.A.T)))\n\n            # Calculating the Kalman Gain\n            self.S = (self.H).dot(self.P).dot(self.H.T) + self.R\n            self.K = self.P.dot(self.H).dot(inv(self.S)) #Kalman gain\n\n            # Reshape the new data into the measurement space.\n            self.Y = self.H.dot(M).reshape(n, -1)\n\n            # Update the State Matrix\n            # Combination of the predicted state, measured values, covariance matrix and Kalman Gain\n            X = X + self.K.dot(self.Y - self.H.dot(X))\n            # Update Process Covariance Matrix\n            self.P = (np.identity(len(self.K)) - self.K.dot(self.H)).dot(self.P)\n            return X\n"""
SLAM/LeadLoc/__init__.py,0,b''
SLAM/LeadLoc/plot_utils.py,1,"b'import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nplt.style.use(\'seaborn\')\n\ndef plotData(true,predicted,measured,kf, t, dt, name, yAxis,start=0,save=False):\n    graph = plt.figure(name)\n\n    x = np.arange(1,t,dt)\n    plt.xlabel(""Time"")\n    plt.ylabel(yAxis)\n    plt.plot(0,start,\'o\',color = ""black"")\n\n    plt.plot(x, true, color=""blue"", label=""True"")\n    plt.plot(x, predicted, color=""red"", label=""Predicted"")\n    plt.plot(x, measured, color=""magenta"", label=""Measured"")\n    plt.plot(x, kf, color=""green"", label=""KF"")\n    plt.legend()\n    if save:\n        graph.savefig(name+"".png"")\n'"
SLAM/LeadLoc/predictionMatrix.py,5,"b'import numpy as np\n\n\ndef prediction2d(x, xdot, dt, a):\n    A = np.array([[1, dt],\n                  [0, 1]])\n    X = np.array([[x],\n                  [xdot]])\n    B = np.array([[0.5 * dt ** 2],\n                  [dt]])\n    X_prime = A.dot(X) + B.dot(a)\n    return X_prime\n\ndef covariance2d(sigma1, sigma2):\n    cov1_2 = sigma1 * sigma2\n    cov2_1 = sigma2 * sigma1\n    cov_matrix = np.array([[sigma1 ** 2, cov1_2],\n                           [cov2_1, sigma2 ** 2]])\n    return np.diag(np.diag(cov_matrix))\n'"
SLAM/LeadMap/__init__.py,0,b''
SLAM/LeadSim/__init__.py,0,b''
SLAM/Analysis/Gradient_Descent/Gd.py,7,"b'import numpy as np\nimport Gradient as math\nimport random\n\ndata = np.loadtxt(""Loss_Points.txt"", delimiter="","")\nshape = (25,25)\n\nx = np.reshape(data[:,0], shape)\ny = np.reshape(data[:,1], shape)\nz = np.reshape(data[:,2], shape)\nz[0][:] = 0.1\nz[:,0] = 0.1\ndmin_coord = np.zeros(2)\nmin_coord = np.array([random.randint(0,shape[0]-2),random.randint(0,shape[0]-2)])\ngamma = 0.1\nalpha = 0.1\nprint(""Start Cords:"",min_coord)\nfor i in range(200):\n    dmin_coord = alpha*dmin_coord - gamma * math.gradient(min_coord[0],min_coord[1],z)\n    min_coord =  min_coord + dmin_coord\n    min_coord = min_coord.astype(int)\n    \'\'\'\n    if i%10 == 0:\n        print(""Gradient:"",math.gradient(min_coord[0],min_coord[1],z))\n        print(""Coords:"", min_coord)\n    \'\'\'\n\nprint(""Final Coords:"", min_coord)\nprint(""X value"",x[min_coord[0]][0])\nprint(""Y value"",y[min_coord[1]][0])\n\nprint(""Min Loss:"",z[min_coord[0]][min_coord[1]])\nprint(""Real min loss:"", np.unravel_index(np.argmin(z, axis=None), z.shape))\n'"
SLAM/Analysis/Gradient_Descent/Gradient.py,1,"b'import numpy as np\n\ndef gradient(x,y,z):\n    h=1\n    try:\n        dx_value = (z[x+h][y] - z[x][y])/h\n        dy_value = (z[x][y+h] - z[x][y])/h\n    except:\n        dx_value = 0\n        dy_value = 0\n        \n    return np.array([dx_value, dy_value])\n'"
SLAM/LeadMap/map_utils/__init__.py,0,b''
SLAM/LeadMap/map_utils/map.py,1,"b""import numpy as np\nimport math as m\nimport matplotlib.pyplot as plt\nfrom scipy.special import expit\nfrom skimage.draw import line\n\n\nfrom LeadMap.map_utils.vector_math import rotation\n\n# TODO:  pos and dim parameters are temporary, should be extracted from measure and previous_map in future versions\ndef processLidarData(measure, previous_map, position, dim,logodd_occ = 0.9,logodd_free = 0.7):\n\n\n    for i in range(len(measure)):\n\n        occ = (np.matmul( rotation(measure[i][1]), [measure[i][0],0] ) + position).astype(int)\n\n        #Take care of boundaries\n        if occ[0]<0:\n            occ[0] = 0\n        if occ[1]<0:\n            occ[1] = 0\n        if occ[0]>=dim[0]:\n            occ[0] = dim[0]-1\n        if occ[1]>=dim[1]:\n            occ[1] = dim[1]-1\n\n        previous_map[occ[0]][occ[1]] += logodd_occ\n\n        #Draw a line Lidar <-> Point, and register all points on the line as unoccupied (the lidar would have detected if not)\n        rr, cc = line(occ[0],occ[1],position[0],position[1])\n        for i in range(len(rr)):\n            x = rr[i]\n            y = cc[i]\n            if (x!=occ[0] or y!=occ[1]) and (0<x<dim[0]) and (0<y<dim[1]):\n                previous_map[x][y] -= logodd_free\n\n    return previous_map #Is now modified as 'new map'\n"""
SLAM/LeadMap/map_utils/vector_math.py,1,"b""import numpy as np\nimport math as m\n\ndef rotation(theta):\n    '''Rotation Matrix for coordinate transformations'''\n    return np.array([[np.cos(m.radians(theta)),-np.sin(m.radians(theta))],[np.sin(m.radians(theta)),np.cos(m.radians(theta))]])\n"""
SLAM/LeadSim/Lidar/Make_carte.py,3,"b""import matplotlib.pyplot as plt\nimport numpy as np\nimport sys\nfrom bresenham import bresenham\nnp.set_printoptions(threshold=sys.maxsize)\n\ndim = [10,10]\npoints = []\ndata=[]\ncarte = np.zeros((10,10))\n\ndef onclick(event):\n    points.append((int(event.xdata), int(event.ydata)))\n\nfig,ax = plt.subplots()\nax.set(xlim=(0, 10),ylim=(0, 10))\nfig.canvas.mpl_connect('button_press_event', onclick)\n\nplt.show()\n\nfor i in range(0,len(points)-1):\n    data.append(list(bresenham(points[i][0],points[i][1],points[i+1][0],points[i+1][1])))\n    \ndata.append(list(bresenham(points[3][0],points[3][1],points[0][0],points[0][1])))\n\nprint(data)\n\nfor k in range(0,len(data)):\n    for i in range(0,len(data[k])):\n        carte[data[k][i][0]][data[k][i][1]] = 1\n\nnp.savetxt('te.txt', carte, delimiter=',') \n"""
SLAM/LeadSim/Lidar/__init__.py,0,b''
SLAM/LeadSim/Lidar/path_gen.py,5,"b'from enum import Enum\nimport numpy as np\n\ndef rotation(theta):\n    \'\'\'Rotation Matrix for coordinate transformations\'\'\'\n    return np.array([[np.cos(m.radians(theta)),-np.sin(m.radians(theta))],[np.sin(m.radians(theta)),np.cos(m.radians(theta))]])\n\nclass PathShape(Enum):\n    STATIC = 0\n    LINE = 1\n    CIRCLE = 2\n\nclass RotationType(Enum):\n    CONTINUOUS = 0\n    CONTINUOUS_BnF = 1\n\ndef createMeasurementSet(\n                frames=1,\n                shape=PathShape.STATIC,\n                rotation=RotationType.CONTINUOUS,\n                speed=0,\n                rotSpeed=0,\n                initialPos=[1,1],\n                initialLidarAngle=0,\n                counterclockwise=True,\n                center=[0,0],\n                direction=315):\n    """""" Base, general function for measurement sets """"""\n\n\n    #Setup\n    angle = initialLidarAngle\n    points = []\n\n    if not(shape is PathShape.STATIC) and speed==None:\n        raise ValueError(""Please assign a speed"")\n\n# Umbrella strategy: Converting to the center\'s coordinate system, doing\n# efficiently the heavy calculation and going back to origin coordinate system\n\n    #Base change\n    position_cen = np.array(initialPos) - np.array(center)\n\n    #Determine the new_position function\n    if shape is PathShape.CIRCLE:\n        try:\n            angle = speed/(np.linalg.norm(position_cen))\n        except ZeroDivisionError:\n            print(""The initial position and the center cannot be the same"")\n            raise\n        transform = rotation(angle)\n        new_position = transform.dot\n\n    elif shape is PathShape.LINE:\n        dirRotation = rotation(direction)\n        transform = dirRotation.dot(speed)\n        new_position = lambda pos: pos+transform\n    else:\n        #print(""The LiDAR path shape defaults to static"")\n        new_position = lambda pos: pos\n\n    #Create the data\n    for f in range(frames):\n        #New measurement\n        points.append([[position_cen+np.array(center), angle]])\n\n        #Increment\n        position_cen = new_position(position_cen)\n        angle += rotSpeed\n        angle = angle%360\n\n    return points\n\n\ndef measure_turn(pos, n=1, rSpeed=1):\n    \'\'\' The way the simulation behaves in current versions \'\'\'\n\n    f = int((360*n)/rSpeed)\n    return createMeasurementSet(frames=f, rotSpeed= rSpeed, initialPos=pos)\n\nclass Scheduler:\n    def __init__(self, points, maxBatchSize=None):\n        self.points = points\n        self.index = 0\n        self.maxIndex = len(points)-1\n        self.complete = False\n\n        self.maxBatchSize = maxBatchSize\n\n    def getNextBatch(self):\n        if (self.maxBatchSize == None):\n            batchSize = len(points)\n        else:\n            batchSize = np.random.randInt(1, self.maxBatchSize+1)\n\n        batch = []\n\n        if (self.index+batchSize)>=self.maxIndex:\n            # TODO: Raise exception if complete already true\n            self.complete = True\n            batchSize = self.maxIndex-self.index+1\n\n        for k in range(batchSize):\n            batch.append(self.points[k+self.index])\n\n        self.index += batchSize\n\n        return batch\n'"
SLAM/LeadSim/Lidar/sim.py,5,"b""import numpy as np\nimport math as m\nimport matplotlib.pyplot as plt\nimport os, sys\n\nplt.style.use('classic')\n\nclass Lidar:\n    '''Class that defines the Lidar object and comes with the simulation properties needed'''\n\n    def __init__(self,dim=(50,50),angle_step=1, ray_step=1,pos=(25,25),uPos=2,uDist=2,uTheta=1.25):\n        self.dim = dim\n        self.angle_step = angle_step\n        self.ray_step = ray_step\n        self.carte = np.zeros(dim)\n        self.pos = pos\n        self.uPos = uPos\n        self.uDist = uDist\n        self.uTheta = uTheta\n\n        #Map Boundaries and obstacle settings\n        self.carte[0][:] = 1\n        self.carte[:,0] = 1\n        self.carte[dim[1]-1][:] = 1\n        self.carte[:,dim[1]-1] = 1\n\n        for i in range(15,25):\n            self.carte[11][i] = 1\n\n        for i in range(16,20):\n            self.carte[i][i]=1\n\n\n        #Create the reference initial working map for LiMap\n        self.initialCarte = np.zeros(dim)\n\n\n\n    def _noise(self, clean_data, dev, esp=0):\n        '''Function that adds noise from a normal distribution to the data provided to mimic real world'''\n        data = np.array(clean_data)\n        noise = np.random.normal(esp,dev,clean_data.shape)\n        return noise+clean_data\n\n    def simulate(self, points, noise=True, show=False):\n        '''Simulates data from one complete lidar rotation, the points parameter is\n        a list representing a discretized version of the path and the laser orientation\n        of the LiDAR over time '''\n\n        simulated = []\n        for i in range(len(points)-1):\n            current_ray = 1\n            theta = points[i][0][1]\n            pos = points[i][0][0]\n            while True:\n                x_current = int(m.cos(m.radians(i))*current_ray)\n                y_current = int(m.sin(m.radians(i))*current_ray)\n\n                if self.carte[x_current+pos[0]][y_current+pos[1]] == 1:\n                    simulated.append([current_ray, theta])\n                    break\n                current_ray += self.ray_step\n\n        simulated = np.array(simulated)\n        if noise == True:\n            #Add noise to the data\n            simulated[:,0] = self._noise(simulated[:,0], self.uDist)\n            simulated[:,1] = self._noise(simulated[:,1], self.uTheta)\n\n\n        return simulated\n"""
SLAM/LeadSim/Lidar/simResultProcess.py,9,"b""import numpy as np\nfrom sklearn.metrics import log_loss\nimport math\nfrom scipy.special import expit\n\ndef genConfusionMatrix(obs, true, pos, rl=False):\n    conf = np.square(obs-true)\n    if rl==False:\n        return conf\n    else:\n        weights = np.ones(np.shape(obs))\n        for i in np.arange(0,obs.shape[0]):\n            for j in np.arange(0,obs.shape[1]):\n                if (i==pos[0] and j==pos[1]) or (j==pos[0] and i==pos[1]):\n                    weights[i][j] = 1\n                else:\n                    weights[i][j] = 1/math.sqrt((i-pos[0])**2+(j-pos[1])**2)*10\n\n        return np.multiply(weights,conf)\n\ndef loss(conf,dim):\n    return (np.sum(conf)/(dim[0]*dim[1]))\n\ndef weightor(x,rho):\n    return rho + (1-2*rho)*x\n\ndef smart_loss(lidar, conf, real_world = True):\n    '''Scalar value ranging from 0 to 1'''\n    alpha = 1\n    beta = 1\n    kappa = 1\n    rho = np.sum(lidar.carte) / lidar.carte.size\n    if real_world:\n        weights = beta * np.exp(alpha * lidar.carte)\n    else:\n         weights = weightor(rho,lidar.carte)\n\n    return kappa *  np.sum(np.multiply(conf, weights)) / np.sum(weights)\n"""
SLAM/LeadSim/Position/__init__.py,0,b''
SLAM/LeadSim/Position/plot_utils.py,1,"b'import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nplt.style.use(\'seaborn\')\n\ndef plotData(true,predicted,measured,kf, t, dt, name, yAxis,start=0,save=False):\n    graph = plt.figure(name)\n\n    x = np.arange(1,t,dt)\n    plt.xlabel(""Time"")\n    plt.ylabel(yAxis)\n    plt.plot(0,start,\'o\',color = ""black"")\n\n    plt.plot(x, true, color=""blue"", label=""True"")\n    plt.plot(x, predicted, color=""red"", label=""Predicted"")\n    plt.plot(x, measured, color=""magenta"", label=""Measured"")\n    plt.plot(x, kf, color=""green"", label=""KF"")\n    plt.legend()\n    if save:\n        graph.savefig(name+"".png"")\n'"
SLAM/LeadSim/Lidar/Plot/Carte_plot.py,5,"b'import numpy as np\nimport matplotlib.pyplot as plt\nimport os, sys, errno\nimport cv2\nimport seaborn as sns\nimport pandas as pd\nfrom cv2 import VideoWriter, VideoWriter_fourcc\nnp.set_printoptions(precision=3)\nnp.set_printoptions(suppress=True)\n\nframes = []\n\nplt.show(block=True)\n_basePath = ""Examples/default""\n\ndef setuprootPath(path=""Examples/default""):\n    global _basePath\n    _basePath = path\n    try:\n        os.mkdir(_basePath)\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n        pass\n\ndef setupPath(path=""Examples/default""):\n    try:\n        os.mkdir(path)\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n        pass\n\n# TODO: Slugification\ndef plotData(data, name,pos, show=False, printa=False, save=False,path=""""):\n    plt.style.use(\'ggplot\')\n    if path=="""":\n        path = _basePath\n    if printa==True:\n        print(name+"" is:\\n"", data)\n\n    data[pos[0]][pos[1]] = 1\n    graph = plt.figure(name)\n    plt.imshow(data,cmap=\'jet\')\n    plt.colorbar()\n\n    if save==True:\n        graph.savefig(path+""/""+name+"".png"")\n    if show==True:\n        plt.show()\n\n    return graph\n\ndef plot_loss(loss,i, show=False, printa=False, save=False, path=""""):\n    plt.style.use(\'seaborn\')\n    if path=="""":\n        path = _basePath\n    if printa==True:\n        print(name+"" is:\\n"", data)\n\n    graph = plt.figure(""Loss"")\n    x = np.arange(0,i,1)\n    plt.plot(x,loss)\n    plt.xlabel(""Nombre de Tours"")\n    plt.ylabel(""LoggLoss"")\n    if save==True:\n        graph.savefig(path+""/""+""loss""+"".png"")\n    if show==True:\n        plt.show()\n\n    return graph\n\ndef animate(image,center_coordinates,name):\n    global frames\n    radius = 20\n    color = (255, 255, 255)\n    thickness = 1\n    image = (image/np.amax(image))*255\n    image = cv2.applyColorMap(image.astype(np.uint8), cv2.COLORMAP_JET)\n    image = cv2.circle(image, center_coordinates, 1, color, thickness)\n    image = cv2.resize(image,(500,500))\n    cv2.imshow(name, image)\n    frames.append(image)\n    cv2.waitKey(20)\n\ndef create_video(path):\n    global frames\n    if path=="""":\n        path = _basePath\n    width = 500\n    height = 500\n    gifFps = 10\n    fourcc = VideoWriter_fourcc(*\'MP42\')\n    video = VideoWriter(path+\'/Animation.avi\', fourcc, float(gifFps), (width, height))\n    for i in frames:\n        video.write(i)\n    video.release()\n'"
SLAM/LeadSim/Lidar/Plot/Confidence.py,2,b'import numpy as np\n\ndef confidence(carte):\n    uncertainty = np.absolute(carte-0.5)\n    return np.sum(uncertainty)/uncertainty.size\n'
SLAM/LeadSim/Lidar/Plot/__init__.py,0,b''
SLAM/LeadSim/Position/Encoder/Sim.py,1,"b""import numpy as np\nfrom random import gauss\n\nclass Encoder():\n\n    def __init__(self,ticsTours,velocity,acceleration,startPos):\n        self.ticsTours = ticsTours\n        self.startvelocity = velocity\n        self.acceleration = acceleration\n        self.startPos = startPos\n        self.wheelRadius = 0.1\n\n    def _noise(self,data,mu=0,std=5):\n        return int(data + gauss(mu,std))\n\n\n    def getTicks(self,t,noise=True):\n        '''Assuming constant acceleration'''\n        newPos = self.distance(t)\n        tics = (int((newPos-self.startPos) / (2*np.pi*self.wheelRadius))+1) * self.ticsTours\n        if noise == True:\n            tics = self._noise(tics)\n        return tics\n\n    def distance(self,t):\n        return self.startPos + self.startvelocity*t + 1/2*self.acceleration*(t**2)\n\n    def vel(self,t):\n        return self.acceleration*t + self.startvelocity\n"""
SLAM/LeadSim/Position/Encoder/__init__.py,0,b''
SLAM/LeadSim/Position/Encoder/ticks_utils.py,1,"b'import numpy as np\n\ndef ticks_to_dist(ticks,tourTick,startpos, wheel_radius=0.1):\n    return (ticks*2*np.pi*wheel_radius)/tourTick + startpos\n\ndef ticks_to_v(dist, dt):\n    return dist/dt\n'"
SLAM/LeadSim/Position/Gyroscope/Sim.py,0,"b'import numpy as np\nfrom random import gauss\n\nclass Gyro():\n\n    def __init__(self,startTheta, startThetadot, thetadotdot):\n        self.startTheta = startTheta\n        self.startThetadot = startThetadot\n        self.thetadotdot = thetadotdot\n\n    def _noise(self,data,mu=0,std=5):\n        return data + gauss(mu,std)\n\n    def theta(self,t, noise=False):\n        if noise:\n            return self._noise(self.startTheta + self.startThetadot*t + 1/2*self.thetadotdot*(t**2))\n        else:\n            return self.startTheta + self.startThetadot*t + 1/2*self.thetadotdot*(t**2)\n\n    def thetadot(self,t,noise=False):\n        if noise:\n            return self. _noise(self.thetadotdot*t + self.startThetadot)\n        else:\n            return self.thetadotdot*t + self.startThetadot\n'"
SLAM/LeadSim/Position/Gyroscope/__init__.py,0,b''
