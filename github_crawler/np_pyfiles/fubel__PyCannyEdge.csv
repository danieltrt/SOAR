file_path,api_count,code
detector.py,0,"b'from CannyEdge.utils import to_ndarray\nfrom CannyEdge.core import (gs_filter, gradient_intensity, suppression,\n                            threshold, tracking)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom copy import copy\nimport argparse\nfrom scipy import misc\n\n# Argparse\nparser = argparse.ArgumentParser(description=\'Educational Canny Edge Detector\')\nparser.add_argument(\'source\', metavar=\'src\', help=\'image source (jpg, png)\')\nparser.add_argument(\'sigma\', type=float, metavar=\'sigma\', help=\'Gaussian smoothing parameter\')\nparser.add_argument(\'t\', type=int, metavar=\'t\', help=\'lower threshold\')\nparser.add_argument(\'T\', type=int, metavar=\'T\', help=\'upper threshold\')\nparser.add_argument(""--all"", help=""Plot all in-between steps"")\nargs = parser.parse_args()\n\ndef ced(img_file, sigma, t, T, all=False):\n    img = to_ndarray(img_file)\n    if not all:\n        # avoid copies, just do all steps:\n        img = gs_filter(img, sigma)\n        img, D = gradient_intensity(img)\n        img = suppression(img, D)\n        img, weak = threshold(img, t, T)\n        img = tracking(img, weak)\n        return [img]\n    else:\n        # make copies, step by step\n        img1 = gs_filter(img, sigma)\n        img2, D = gradient_intensity(img1)\n        img3 = suppression(copy(img2), D)\n        img4, weak = threshold(copy(img3), t, T)\n        img5 = tracking(copy(img4), weak)\n        return [to_ndarray(img_file), img1, img2, img3, img4, img5]\n\ndef plot(img_list, safe=False):\n    for d, img in enumerate(img_list):\n        plt.subplot(1, len(img_list), d+1), plt.imshow(img, cmap=\'gray\'),\n        plt.xticks([]), plt.yticks([])\n    plt.show()\n\n\nimg_list = ced(args.source, args.sigma, args.t, args.T, all=args.all)\nplot(img_list)\n'"
CannyEdge/core.py,14,"b'"""""" Canny Edge Detection is based on the following five steps:\n\n    1. Gaussian filter\n    2. Gradient Intensity\n    3. Non-maximum suppression\n    4. Double threshold\n    5. Edge tracking\n\n    This module contains these five steps as five separate Python functions.\n""""""\n\n# Module imports\nfrom CannyEdge.utils import round_angle\n\n# Third party imports\nfrom scipy.ndimage.filters import gaussian_filter\nfrom scipy import ndimage\nfrom scipy.ndimage import sobel, generic_gradient_magnitude, generic_filter\nimport numpy as np\n\n\ndef gs_filter(img, sigma):\n    """""" Step 1: Gaussian filter\n\n    Args:\n        img: Numpy ndarray of image\n        sigma: Smoothing parameter\n\n    Returns:\n        Numpy ndarray of smoothed image\n    """"""\n    if type(img) != np.ndarray:\n        raise TypeError(\'Input image must be of type ndarray.\')\n    else:\n        return gaussian_filter(img, sigma)\n\n\ndef gradient_intensity(img):\n    """""" Step 2: Find gradients\n\n    Args:\n        img: Numpy ndarray of image to be processed (denoised image)\n\n    Returns:\n        G: gradient-intensed image\n        D: gradient directions\n    """"""\n\n    # Kernel for Gradient in x-direction\n    Kx = np.array(\n        [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], np.int32\n    )\n    # Kernel for Gradient in y-direction\n    Ky = np.array(\n        [[1, 2, 1], [0, 0, 0], [-1, -2, -1]], np.int32\n    )\n    # Apply kernels to the image\n    Ix = ndimage.filters.convolve(img, Kx)\n    Iy = ndimage.filters.convolve(img, Ky)\n\n    # return the hypothenuse of (Ix, Iy)\n    G = np.hypot(Ix, Iy)\n    D = np.arctan2(Iy, Ix)\n    return (G, D)\n    \n\ndef suppression(img, D):\n    """""" Step 3: Non-maximum suppression\n\n    Args:\n        img: Numpy ndarray of image to be processed (gradient-intensed image)\n        D: Numpy ndarray of gradient directions for each pixel in img\n\n    Returns:\n        ...\n    """"""\n\n    M, N = img.shape\n    Z = np.zeros((M,N), dtype=np.int32)\n\n    for i in range(M):\n        for j in range(N):\n            # find neighbour pixels to visit from the gradient directions\n            where = round_angle(D[i, j])\n            try:\n                if where == 0:\n                    if (img[i, j] >= img[i, j - 1]) and (img[i, j] >= img[i, j + 1]):\n                        Z[i,j] = img[i,j]\n                elif where == 90:\n                    if (img[i, j] >= img[i - 1, j]) and (img[i, j] >= img[i + 1, j]):\n                        Z[i,j] = img[i,j]\n                elif where == 135:\n                    if (img[i, j] >= img[i - 1, j - 1]) and (img[i, j] >= img[i + 1, j + 1]):\n                        Z[i,j] = img[i,j]\n                elif where == 45:\n                    if (img[i, j] >= img[i - 1, j + 1]) and (img[i, j] >= img[i + 1, j - 1]):\n                        Z[i,j] = img[i,j]\n            except IndexError as e:\n                """""" Todo: Deal with pixels at the image boundaries. """"""\n                pass\n    return Z\n\n\ndef threshold(img, t, T):\n    """""" Step 4: Thresholding\n    Iterates through image pixels and marks them as WEAK and STRONG edge\n    pixels based on the threshold values.\n\n    Args:\n        img: Numpy ndarray of image to be processed (suppressed image)\n        t: lower threshold\n        T: upper threshold\n\n    Return:\n        img: Thresholdes image\n\n    """"""\n    # define gray value of a WEAK and a STRONG pixel\n    cf = {\n        \'WEAK\': np.int32(50),\n        \'STRONG\': np.int32(255),\n    }\n\n    # get strong pixel indices\n    strong_i, strong_j = np.where(img > T)\n\n    # get weak pixel indices\n    weak_i, weak_j = np.where((img >= t) & (img <= T))\n\n    # get pixel indices set to be zero\n    zero_i, zero_j = np.where(img < t)\n\n    # set values\n    img[strong_i, strong_j] = cf.get(\'STRONG\')\n    img[weak_i, weak_j] = cf.get(\'WEAK\')\n    img[zero_i, zero_j] = np.int32(0)\n\n    return (img, cf.get(\'WEAK\'))\n\ndef tracking(img, weak, strong=255):\n    """""" Step 5:\n    Checks if edges marked as weak are connected to strong edges.\n\n    Note that there are better methods (blob analysis) to do this,\n    but they are more difficult to understand. This just checks neighbour\n    edges.\n\n    Also note that for perfomance reasons you wouldn\'t do this kind of tracking\n    in a seperate loop, you would do it in the loop of the tresholding process.\n    Since this is an **educational** implementation ment to generate plots\n    to help people understand the major steps of the Canny Edge algorithm,\n    we exceptionally don\'t care about perfomance here.\n\n    Args:\n        img: Numpy ndarray of image to be processed (thresholded image)\n        weak: Value that was used to mark a weak edge in Step 4\n\n    Returns:\n        final Canny Edge image.\n    """"""\n\n    M, N = img.shape\n    for i in range(M):\n        for j in range(N):\n            if img[i, j] == weak:\n                # check if one of the neighbours is strong (=255 by default)\n                try:\n                    if ((img[i + 1, j] == strong) or (img[i - 1, j] == strong)\n                         or (img[i, j + 1] == strong) or (img[i, j - 1] == strong)\n                         or (img[i+1, j + 1] == strong) or (img[i-1, j - 1] == strong)):\n                        img[i, j] = strong\n                    else:\n                        img[i, j] = 0\n                except IndexError as e:\n                    pass\n    return img\n'"
CannyEdge/exceptions.py,0,b''
CannyEdge/utils.py,1,"b'"""""" Canny Edge Detection is based on the following five steps:\n\n    1. Gaussian filter\n    2. Gradient Intensity\n    3. Non-maximum suppression\n    4. Double threshold\n    5. Edge tracking\n\n    This module contains these five steps as five separate Python functions.\n""""""\n\nfrom scipy import misc\nimport numpy as np\n\ndef to_ndarray(img):\n    im = misc.imread(img, flatten=True)\n    im = im.astype(\'int32\')\n    return im\n\n\ndef round_angle(angle):\n    """""" Input angle must be \\in [0,180) """"""\n    angle = np.rad2deg(angle) % 180\n    if (0 <= angle < 22.5) or (157.5 <= angle < 180):\n        angle = 0\n    elif (22.5 <= angle < 67.5):\n        angle = 45\n    elif (67.5 <= angle < 112.5):\n        angle = 90\n    elif (112.5 <= angle < 157.5):\n        angle = 135\n    return angle\n'"
