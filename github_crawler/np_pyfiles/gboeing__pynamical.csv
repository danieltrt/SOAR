file_path,api_count,code
setup.py,0,"b'from setuptools import setup\n\n# provide a long description using reStructuredText\nlong_description = """"""\n**pynamical** is a Python package for modeling, simulating, visualizing, and animating discrete \nnonlinear dynamical systems and chaos. pynamical uses pandas, numpy, and numba for fast simulation, \nand matplotlib for beautiful visualizations and animations to explore system behavior. Compatible \nwith Python 2 and 3. See the examples and demos on `GitHub`_.\n\nYou can read/cite the journal article about pynamical: Boeing, G. 2016. \n""`Visual Analysis of Nonlinear Dynamical Systems: Chaos, Fractals, Self-Similarity and the Limits of Prediction`_."" \n*Systems*, 4 (4), 37. doi:10.3390/systems4040037.\n\n.. _GitHub: https://github.com/gboeing/pynamical\n.. _Visual Analysis of Nonlinear Dynamical Systems\\: Chaos, Fractals, Self-Similarity and the Limits of Prediction: http://geoffboeing.com/publications/nonlinear-chaos-fractals-prediction/\n""""""\n\n# list of classifiers from the PyPI classifiers trove\nclassifiers=[\'Development Status :: 5 - Production/Stable\',\n             \'License :: OSI Approved :: MIT License\',\n             \'Operating System :: OS Independent\',\n             \'Intended Audience :: Science/Research\',\n             \'Intended Audience :: Education\',\n             \'Topic :: Scientific/Engineering :: Mathematics\',\n             \'Topic :: Scientific/Engineering :: Visualization\',\n             \'Topic :: Scientific/Engineering :: Physics\',\n             \'Topic :: Scientific/Engineering :: Information Analysis\',\n             \'Programming Language :: Python\',\n             \'Programming Language :: Python :: 2\',\n             \'Programming Language :: Python :: 3\',\n             \'Programming Language :: Python :: 2.7\',\n             \'Programming Language :: Python :: 3.5\',\n             \'Programming Language :: Python :: 3.6\',\n             \'Programming Language :: Python :: 3.7\']\n\nsetup(name=\'pynamical\',\n      version=\'0.2.1\',\n      description=\'Model, simulate, and visualize discrete nonlinear dynamical systems\',\n      long_description=long_description,\n      classifiers=classifiers,\n      url=\'https://github.com/gboeing/pynamical\',\n      author=\'Geoff Boeing\',\n      author_email=\'boeing@usc.edu\',\n      license=\'MIT\',\n      platforms=\'any\',\n      packages=[\'pynamical\'],\n      install_requires=[\'pandas>=0.24\',\n                        \'numpy>=1.15\',\n                        \'matplotlib>=2.2\',\n                        \'numba>=0.39\'])\n                        '"
pynamical/__init__.py,0,"b""from .pynamical import *\n__version__ = '0.2.1'"""
pynamical/pynamical.py,7,"b'#################################################################################################################\n# pynamical\n# Description: Model, simulate, and visualize discrete nonlinear dynamical systems and chaos\n# Author: Geoff Boeing\n# Web: https://geoffboeing.com/\n# Code repo: https://github.com/gboeing/pynamical\n# Documentation: https://pynamical.readthedocs.io/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2019 Geoff Boeing https://geoffboeing.com/\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#################################################################################################################\n\nimport os, pandas as pd, numpy as np\nimport matplotlib.pyplot as plt, matplotlib.cm as cm, matplotlib.font_manager as fm\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom numba import jit\n\n\n\n\ndef get_title_font(family=\'Helvetica\', style=\'normal\', size=20, weight=\'normal\', stretch=\'normal\'):\n    """"""\n    Define fonts to use for image titles.\n    \n    Arguments\n    ---------\n    family : string\n    style : string\n    size : numeric\n    weight : string\n    stretch : string\n    \n    Returns\n    -------\n    matplotlib.font_manager.FontProperties\n    """"""\n    \n    if family==\'Helvetica\':\n        family = [\'Helvetica\', \'Arial\', \'sans-serif\']\n    fp = fm.FontProperties(family=family, style=style, size=size, weight=weight, stretch=stretch)\n    return fp\n\ndef get_label_font(family=\'Helvetica\', style=\'normal\', size=16, weight=\'normal\', stretch=\'normal\'):\n    """"""\n    Define fonts to use for image axis labels.\n    \n    Arguments\n    ---------\n    family : string\n    style : string\n    size : numeric\n    weight : string\n    stretch : string\n    \n    Returns\n    -------\n    matplotlib.font_manager.FontProperties\n    """"""\n    \n    if family==\'Helvetica\':\n        family = [\'Helvetica\', \'Arial\', \'sans-serif\']\n    fp = fm.FontProperties(family=family, style=style, size=size, weight=weight, stretch=stretch)\n    return fp\n\n\ndef save_fig(filename=\'image\', folder=\'images\', dpi=300, bbox_inches=\'tight\', pad=0.1):\n    """"""\n    Save the current figure as a file to disk.\n    \n    Arguments\n    ---------\n    filename: string\n        filename of image file to be saved\n    folder: string\n        folder in which to save the image file\n    dpi: int\n        resolution at which to save the image\n    bbox_inches: string\n        tell matplotlib to figure out the tight bbox of the figure\n    pad: float\n        inches to pad around the figure\n    \n    Returns\n    -------\n    None\n    """"""\n    \n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    plt.savefig(\'{}/{}.png\'.format(folder, filename), dpi=dpi, bbox_inches=bbox_inches, pad_inches=pad)\n\n    \n    \n    \ndef save_and_show(fig, ax, save, show, filename=\'image\', folder=\'images\', dpi=300, bbox_inches=\'tight\', pad=0.1):\n    """"""\n    Consistently handle plot completion by saving then either displaying or returning the figure.\n    \n    Arguments\n    ---------\n    fig: matplotlib figure\n    ax: matplotlib axis\n    save: bool\n        whether to save the image to disk, or not\n    show: bool\n        whether to display the image or instead just return the figure and axis\n    filename: string\n        filename of image file to be saved\n    folder: string\n        folder in which to save the image file\n    dpi: int\n        resolution at which to save the image\n    bbox_inches: string\n        tell matplotlib to figure out the tight bbox of the figure\n    pad: float\n        inches to pad around the figure\n    \n    Returns\n    -------\n    tuple \n        (fig, ax) if show=False, otherwise returns None\n    """"""\n    \n    if save:  \n        save_fig(filename=filename, folder=folder, dpi=dpi, bbox_inches=bbox_inches, pad=pad)\n        \n    if show:\n        plt.show()   \n    else:\n        return fig, ax\n    \n    \n    \n\n@jit(cache=True, nopython=True) # pragma: no cover\ndef logistic_map(pop, rate):\n    """"""\n    Define the equation for the logistic map.\n    \n    Arguments\n    ---------\n    pop: float\n        current population value at time t\n    rate: float\n        growth rate parameter values\n    \n    Returns\n    -------\n    float\n        scalar result of logistic map at time t+1\n    """"""\n    \n    return pop * rate * (1 - pop)\n    \n    \n    \n\n@jit(cache=True, nopython=True) # pragma: no cover \ndef cubic_map(pop, rate):\n    """"""\n    Define the equation for the cubic map.\n    \n    Arguments\n    ---------\n    pop: float\n        current population value at time t\n    rate: float\n        growth rate parameter values\n    \n    Returns\n    -------\n    float\n        scalar result of cubic map at time t+1\n    """"""\n    \n    return rate * pop ** 3 + pop * (1 - rate)\n    \n\n    \n    \n@jit(cache=True, nopython=True) # pragma: no cover\ndef singer_map(pop, rate):\n    """"""\n    Define the equation for the singer map.\n    \n    Arguments\n    ---------\n    pop: float\n        current population value at time t\n    rate: float\n        growth rate parameter values\n    \n    Returns\n    -------\n    float\n        scalar result of singer map at time t+1\n    """"""\n    \n    return rate * (7.86 * pop - 23.31 * pop ** 2 + 28.75 * pop ** 3 - 13.3 * pop ** 4)\n\n    \n    \n    \ndef simulate(model=logistic_map, num_gens=50, rate_min=0.5, rate_max=4, num_rates=8, num_discard=0, initial_pop=0.5, jit=True):\n    """"""\n    Call simulator (either JIT compiled or not) to create a DataFrame with columns for each growth rate, row labels for each time step, and values computed by the model.\n    \n    Arguments\n    ---------\n    model: function\n        the function defining an iterated map to simulate; default is the logistic map\n    num_gens: int\n        number of iterations to run the model\n    rate_min: float\n        the first growth rate for the model, between 0 and 4\n    rate_max: float\n        the last growth rate for the model, between 0 and 4\n    num_rates: int\n        how many growth rates between min and max to run the model on\n    num_discard: int\n        number of generations to discard before keeping population values\n    initial_pop: float\n        starting population when you run the model, between 0 and 1\n    jit: bool\n        if True, use jit compiled simulator function to speed up simulation, if False, use uncompiled simulator function\n    \n    Returns\n    -------\n    DataFrame\n    """"""\n    \n    if jit:\n        return simulate_jit(model=model, num_gens=num_gens, rate_min=rate_min, rate_max=rate_max, num_rates=num_rates, num_discard=num_discard, initial_pop=initial_pop)\n    else:\n        return simulate_no_compile(model=model, num_gens=num_gens, rate_min=rate_min, rate_max=rate_max, num_rates=num_rates, num_discard=num_discard, initial_pop=initial_pop)\n    \n    \n    \n    \ndef simulate_no_compile(model, num_gens, rate_min, rate_max, num_rates, num_discard, initial_pop):\n    """"""\n    Create a DataFrame with columns for each growth rate, row labels for each time step, and values computed by the model (without JIT compilation).\n    \n    Arguments\n    ---------\n    model: function\n        the function defining an iterated map to simulate\n    num_gens: int\n        number of iterations to run the model\n    rate_min: float\n        the first growth rate for the model, between 0 and 4\n    rate_max: float\n        the last growth rate for the model, between 0 and 4\n    num_rates: int\n        how many growth rates between min and max to run the model on\n    num_discard: int\n        number of generations to discard before keeping population values\n    initial_pop: float\n        starting population when you run the model, between 0 and 1\n    \n    Returns\n    -------\n    DataFrame\n    """"""\n    \n    pops = []\n    rates = np.linspace(rate_min, rate_max, num_rates)\n    \n    # for each rate, run the function repeatedly, starting at the initial_pop\n    for rate in rates:\n        pop = initial_pop\n        \n        # first run it num_discard times and ignore the results\n        for _ in range(num_discard):\n            pop = model(pop, rate)\n        \n        # now that those gens are discarded, run it num_gens times and keep the results\n        for _ in range(num_gens):\n            pops.append([rate, pop])\n            pop = model(pop, rate)\n    \n    # return a DataFrame with one column for each growth rate and one row for each timestep (aka generation)\n    df = pd.DataFrame(data=pops, columns=[\'rate\', \'pop\'])\n    df.index = pd.MultiIndex.from_arrays([num_rates * list(range(num_gens)), df[\'rate\'].values])\n    return df.drop(labels=\'rate\', axis=1).unstack()[\'pop\']\n\n    \n    \n    \ndef simulate_jit(model, num_gens, rate_min, rate_max, num_rates, num_discard, initial_pop):\n    """"""\n    Create a DataFrame with columns for each growth rate, row labels for each time step, and values computed by the model (with JIT compilation).\n    \n    You can\'t pass a jitted function to a jitted function unless you turn off \'nopython\' mode (which makes it slow)\n    In other words, you can\'t pass different model functions directly to the simulate function. Instead, use a closure:\n    The make_jit_simulator function returns a jitted simulator function that receives the jitted model function,\n    without it being an argument passed to the simulator function, because of the closure local scope\n    \n    Arguments\n    ---------\n    model: function\n        the function defining an iterated map to simulate\n    num_gens: int\n        number of iterations to run the model\n    rate_min: float\n        the first growth rate for the model, between 0 and 4\n    rate_max: float\n        the last growth rate for the model, between 0 and 4\n    num_rates: int\n        how many growth rates between min and max to run the model on\n    num_discard: int\n        number of generations to discard before keeping population values\n    initial_pop: float\n        starting population when you run the model, between 0 and 1\n    \n    Returns\n    -------\n    DataFrame\n    """"""\n    \n    # make the jitted simulator\n    jit_simulator = make_jit_simulator(model=model, num_gens=num_gens, rate_min=rate_min, rate_max=rate_max, \n                                       num_rates=num_rates, num_discard=num_discard, initial_pop=initial_pop)\n    \n    # run the jit_simulator to create the pops to pass to the DataFrame\n    pops = jit_simulator()\n    \n    # return a DataFrame with one column for each growth rate and one row for each timestep (aka generation)\n    df = pd.DataFrame(data=pops, columns=[\'rate\', \'pop\'])\n    df.index = pd.MultiIndex.from_arrays([num_rates * list(range(num_gens)), df[\'rate\'].values])\n    return df.drop(labels=\'rate\', axis=1).unstack()[\'pop\']\n    \n    \n    \n    \ndef make_jit_simulator(model, num_gens, rate_min, rate_max, num_rates, num_discard, initial_pop):\n    """"""\n    Create a jitted simulator function that receives the jitted model function, without it being an argument passed to the simulator function, because of the closure local scope.\n    \n    Arguments\n    ---------\n    model: function\n        the function defining an iterated map to simulate\n    num_gens: int\n        number of iterations to run the model\n    rate_min: float\n        the first growth rate for the model, between 0 and 4\n    rate_max: float\n        the last growth rate for the model, between 0 and 4\n    num_rates: int\n        how many growth rates between min and max to run the model on\n    num_discard: int\n        number of generations to discard before keeping population values\n    initial_pop: float\n        starting population when you run the model, between 0 and 1\n    \n    Returns\n    -------\n    function\n    """"""\n    \n    @jit(cache=True, nopython=True) # pragma: no cover\n    def jit_simulator(num_gens=num_gens, rate_min=rate_min, rate_max=rate_max, num_rates=num_rates, \n                      num_discard=num_discard, initial_pop=initial_pop):\n        \n        pops = np.empty(shape=(num_gens*num_rates, 2), dtype=np.float64)\n        rates = np.linspace(rate_min, rate_max, num_rates)\n\n        # for each rate, run the function repeatedly, starting at the initial_pop\n        for rate_num, rate in zip(range(len(rates)), rates):\n            pop = initial_pop\n\n            # first run it num_discard times and ignore the results\n            for _ in range(num_discard):\n                pop = model(pop, rate)\n\n            # now that those gens are discarded, run it num_gens times and keep the results\n            for gen_num in range(num_gens):\n                row_num = gen_num + num_gens * rate_num\n                pops[row_num] = [rate, pop]\n                pop = model(pop, rate)\n        \n        return pops\n    \n    return jit_simulator\n    \n    \n    \n    \ndef get_bifurcation_plot_points(pops):\n    """"""\n    Convert a DataFrame of values from the model into a set of xy points that you can plot as a bifurcation diagram.\n    \n    Arguments\n    ---------\n    pops: DataFrame\n        population data output from the model\n    \n    Returns\n    -------\n    DataFrame\n    """"""\n    \n    # create a new DataFrame to contain our xy points\n    xy_points = pd.DataFrame(columns=[\'x\', \'y\'])\n    \n    # for each column in the populations DataFrame\n    for rate in pops.columns:\n        # append the growth rate as the x column and all the population values as the y column\n        xy_points = xy_points.append(pd.DataFrame({\'x\':rate, \'y\':pops[rate]}))\n    \n    # reset the index and drop the old index before returning the xy point data\n    xy_points = xy_points.reset_index().drop(labels=\'index\', axis=1)\n    return xy_points\n\n    \n    \n    \ndef bifurcation_plot(pops, xmin=0, xmax=4, ymin=0, ymax=1, figsize=(10,6),\n                     title=\'Bifurcation Diagram\', xlabel=\'Growth Rate\', ylabel=\'Population\', \n                     color=\'#003399\', filename=\'image\', save=True, show=True, title_font=None, label_font=None,\n                     folder=\'images\', dpi=300, bbox_inches=\'tight\', pad=0.1):\n    """"""\n    Plot the results of the model as a bifurcation diagram.\n    \n    Arguments\n    ---------\n    pops: DataFrame\n        population data output from the model\n    xmin: float\n        minimum value on the x axis\n    xmax: float\n        maximum value on the x axis\n    ymin: float\n        minimum value on the y axis\n    ymax: float\n        maximum value on the y axis\n    figsize: tuple\n        (width, height) of figure\n    title: string\n        title of the plot\n    xlabel: string\n        label of the x axis\n    ylabel: string\n        label of the y axis\n    color: string\n        color of the points in the scatter plot\n    filename: string\n        name of image file to be saved, if applicable\n    save: bool\n        whether to save the image to disk or not\n    show: bool\n        whether to display the image on screen or not\n    title_font: matplotlib.font_manager.FontProperties\n        font properties for figure title\n    label_font: matplotlib.font_manager.FontProperties\n        font properties for axis labels\n    folder: string\n        folder in which to save the image file\n    dpi: int\n        resolution at which to save the image\n    bbox_inches: string\n        tell matplotlib to figure out the tight bbox of the figure\n    pad: float\n        inches to pad around the figure\n    \n    Returns\n    -------\n    tuple \n        (fig, ax) if show=False, otherwise returns None\n    """"""\n    \n    if title_font is None:\n        title_font = get_title_font()\n        \n    if label_font is None:\n        label_font = get_label_font()\n    \n    # create a new matplotlib figure and axis and set its size\n    fig, ax = plt.subplots(figsize=figsize)\n    \n    # plot the xy data\n    points = get_bifurcation_plot_points(pops)\n    bifurcation_scatter = ax.scatter(points[\'x\'], points[\'y\'], c=color, edgecolor=\'None\', alpha=1, s=1)\n    \n    # set x and y limits, title, and x and y labels\n    ax.set_xlim(xmin, xmax)\n    ax.set_ylim(ymin, ymax)\n    ax.set_title(title, fontproperties=get_title_font())\n    ax.set_xlabel(xlabel, fontproperties=get_label_font())\n    ax.set_ylabel(ylabel, fontproperties=get_label_font())\n    \n    return save_and_show(fig=fig, ax=ax, save=save, show=show, filename=filename, folder=folder, dpi=dpi, bbox_inches=bbox_inches, pad=pad)\n\n\n    \n    \ndef get_phase_colors(color_request, length=1, color_reverse=False, default_color=\'#003399\'):\n    """"""\n    Return a list of colors based on a request that could be a list, string color name, or string colormap name.\n    \n    Arguments\n    ---------\n    color_request: string or list\n        what color the caller wants, could be a list, string color name, or string colormap name\n    length: int\n        how many total colors to return in the list\n    color_reverse: bool\n        reverse the returned list of colors if True\n    default_color: string\n        if the list is shorter than the specified length, pad it out with default_color\n    \n    Returns\n    -------\n    list\n    """"""\n    \n    color_list = []\n    if isinstance(color_request, list):\n        # if they passed a list, then just use it\n        color_list = color_request\n        \n    elif isinstance(color_request, str):\n        # if they passed a string, it could be a color name or a colormap name\n        if len(color_request) == 1 or color_request.startswith(\'#\'):\n            # if it\'s only 1 character long or starts with a #, then it\'s a color name or hex code\n            color_list = [color_request]\n            default_color = color_request\n        else:\n            # if it\'s more than 1 character and doesn\'t start with #, then it\'s the name of a colormap\n            color_map = cm.get_cmap(color_request)\n            color_list = color_map([x/float(length) for x in range(length)]).tolist()\n            \n    # make sure list is same length as specified in length argument - if not, pad it out with default_color, that way, each scatterplot gets a color\n    color_list = color_list + [default_color for n in range(length-len(color_list))] if len(color_list) < length else color_list\n    \n    # if the color_reverse=True, reverse the list of colors before returning it\n    if color_reverse:\n        color_list.reverse()\n    \n    return color_list\n\n    \n    \n    \ndef get_phase_diagram_points(pops, discard_gens=1, dimensions=2):\n    """"""\n    Convert a DataFrame of values from the model into a set of xy(z) points to plot.\n    \n    Arguments\n    ---------\n    pops: DataFrame\n        population data output from the model\n    discard_gens: int\n        number of rows to discard before keeping points to plot\n    dimensions: int\n        {2, 3}, number of dimensions specifying if we want points for a 2-D or 3-D plot: (t, t+1) vs (t, t+1, t+2)\n    \n    Returns\n    -------\n    DataFrame\n    """"""\n\n    # drop the first row by default because every run has the same starting value, it leaves a visual artifact\n    # if specified by the argument, drop the initial n rows to show only the eventual attractor the system settles on\n    if discard_gens > 0 and len(pops) > discard_gens:\n        discard_gens = np.arange(0, discard_gens)\n        pops = pops.drop(labels=pops.index[discard_gens])\n        pops = pops.reset_index().drop(labels=\'index\', axis=1)\n\n    # a point is defined by the name of its model run then its spatial coordinates\n    points = []\n    point_columns = [\'name\', \'x\', \'y\', \'z\']\n    \n    # for each column in the populations DataFrame, where the label is the \'name\' of the model run\n    for name in pops.columns:\n        \n        # for each row in the column\n        for label, row in pops.iterrows():\n            \n            # we can only create points up up to row dimensions-1 because we need future time steps to create each point\n            if label < len(pops)-(dimensions-1):\n                \n                point = [name]\n                for n in range(dimensions):\n                    # append the value at the current time (aka row) as x, t+1 as y (and t+2 as z if dimensions=3)\n                    point.append(pops[name][label + n])\n                \n                # append this point to the list of points\n                points.append(point)\n    \n    # convert the list of points to a MultiIndex DataFrame \n    # with a level in the index called \'name\' to represent each model run\n    df = pd.DataFrame(points, columns=point_columns[0:dimensions+1])\n    df.index = pd.MultiIndex.from_tuples(list(zip(df[\'name\'], df.index)), names=[\'name\', \'\'])\n    df = df.drop(labels=\'name\', axis=1)\n    return df\n    \n    \n    \n    \ndef phase_diagram(pops, discard_gens=0, figsize=(6,6), xmin=0, xmax=1, ymin=0, ymax=1,\n                  title=\'\', xlabel=\'Population (t)\', ylabel=\'Population (t + 1)\',\n                  marker=\'.\', size=5, alpha=0.7, color=\'#003399\', color_reverse=False, legend=False, \n                  filename=\'image\', save=True, show=True, title_font=None, label_font=None,\n                  folder=\'images\', dpi=300, bbox_inches=\'tight\', pad=0.1):\n    """"""\n    Draw a 2D phase diagram for one or more time series by plotting the value at time t on the x-axis and the value at t+1 on the y-axis.\n    \n    Arguments\n    ---------\n    pops: DataFrame\n        population data output from the model\n    discard_gens: int\n        number of rows to discard before keeping points to plot\n    figsize: tuple\n        (width, height) of figure\n    xmin: float\n        minimum value on the x axis\n    xmax: float\n        maximum value on the x axis\n    ymin: float\n        minimum value on the y axis\n    ymax: float\n        maximum value on the y axis\n    title: string\n        title of the plot\n    xlabel: string\n        label of the x axis\n    ylabel: string\n        label of the y axis\n    marker: string\n        the type of point to use in the plot\n    size: float\n        the size of the marker\n    alpha: float\n        the opacity of the marker\n    color: string\n        color of the points in the scatter plot\n    color_reverse: bool\n        reverse the returned list of colors if True\n    legend: bool\n        if we should display a legend or not\n    filename: string\n        name of image file to be saved, if applicable\n    save: bool\n        whether to save the image to disk or not\n    show: bool\n        whether to display the image on screen or not\n    title_font: matplotlib.font_manager.FontProperties\n        font properties for figure title\n    label_font: matplotlib.font_manager.FontProperties\n        font properties for axis labels\n    folder: string\n        folder in which to save the image file\n    dpi: int\n        resolution at which to save the image\n    bbox_inches: string\n        tell matplotlib to figure out the tight bbox of the figure\n    pad: float\n        inches to pad around the figure\n    \n    Returns\n    -------\n    tuple \n        (fig, ax) if show=False, otherwise returns None\n    """"""\n    \n    if title_font is None:\n        title_font = get_title_font()\n        \n    if label_font is None:\n        label_font = get_label_font()\n        \n    # first get the xy points to plot\n    points = get_phase_diagram_points(pops, discard_gens, dimensions=2)\n    plots = []\n    \n    # get_phase_diagram_points() returns a MultiIndexed DataFrame, each run of the model has its own \'name\' in the index\n    index = points.index.get_level_values(\'name\')\n    names = np.unique(index)\n    \n    # create a new matplotlib figure and axis and set its size\n    fig, ax = plt.subplots(figsize=figsize)\n    \n    # set the plot title, x- and y-axis limits, and x- and y-axis labels\n    ax.set_title(title, fontproperties=get_title_font())\n    ax.set_xlim(xmin, xmax)\n    ax.set_ylim(ymin, ymax)\n    ax.set_xlabel(xlabel, fontproperties=get_label_font())\n    ax.set_ylabel(ylabel, fontproperties=get_label_font())\n    \n    # make sure we have a list of colors as long as the number of model runs\n    color_list = get_phase_colors(color, len(names), color_reverse)\n        \n    # plot the xy data for each run of the model that appears in the MultiIndex\n    for n in range(len(names)):\n        xy = points.iloc[index == names[n]]\n        plots.append(ax.scatter(xy[\'x\'], xy[\'y\'], marker=marker, c=[color_list[n]], edgecolor=\'none\', s=size, alpha=alpha))\n        \n    # add a legend if argument is True\n    if legend:\n        ax.legend(plots, names.tolist(), loc=1, frameon=True, framealpha=1)\n    \n    if filename == \'\':\n        filename = title.replace(\' \', \'-\').replace(\'=\', \'-\').replace(\',\', \'-\').replace(\'.\', \'\').replace(\'--\', \'-\')\n    \n    return save_and_show(fig=fig, ax=ax, save=save, show=show, filename=filename, folder=folder, dpi=dpi, bbox_inches=bbox_inches, pad=pad)\n    \n    \n    \n    \ndef phase_diagram_3d(pops, discard_gens=0, figsize=(10,8), xmin=0, xmax=1, ymin=0, ymax=1, zmin=0, zmax=1,\n                     remove_ticks=True, title=\'\', elev=25, azim=240, dist=10,\n                     xlabel=\'Population (t)\', ylabel=\'Population (t + 1)\', zlabel=\'Population (t + 2)\',\n                     marker=\'.\', size=5, alpha=0.7, color=\'#003399\', color_reverse=False, legend=False, \n                     legend_bbox_to_anchor=None, filename=\'image\', save=True, show=True, title_font=None, label_font=None,\n                     folder=\'images\', dpi=300, bbox_inches=\'tight\', pad=0.1):\n    """"""\n    Draw a 3D phase diagram for one or more time series by plotting the value at time t on the x-axis, the value at t+1 on the y-axis, and the value of t+2 on the z-axis.\n    \n    Arguments\n    ---------\n    pops: DataFram\n        population data output from the model\n    discard_gens: int\n        number of rows to discard before keeping points to plot\n    figsize: tuple\n        (width, height) of figure\n    xmin: float\n        minimum value on the x axis\n    xmax: float\n        maximum value on the x axis\n    ymin: float\n        minimum value on the y axis\n    ymax: float\n        maximum value on the y axis\n    zmin: float\n        minimum value on the z axis\n    zmax: float\n        maximum value on the z axis \n    remove_ticks: bool\n        remove axis ticks or not\n    title: string\n        title of the plot\n    elev: float\n        the elevation of the viewing perspective\n    azim: float\n        the azimuth of the viewing perspective\n    dist: float\n        the distance of the viewing perspective\n    xlabel: string\n        label of the x axis\n    ylabel: string\n        label of the y axis\n    zlabel: string\n        label of the z axis\n    marker: string\n        the type of point to use in the plot\n    size: float\n        the size of the marker\n    alpha: float\n        the opacity of the marker\n    color: string\n        color of the points in the scatter plot\n    color_reverse: bool\n        reverse the returned list of colors if True\n    legend: bool\n        if we should display a legend or not\n    legend_bbox_to_anchor: float\n        amount to offset the legend from its natural position\n    filename: string\n        name of image file to be saved, if applicable\n    save: bool\n        whether to save the image to disk or not\n    show: bool\n        whether to display the image on screen or not\n    title_font: matplotlib.font_manager.FontProperties\n        font properties for figure title\n    label_font: matplotlib.font_manager.FontProperties\n        font properties for axis labels\n    folder: string\n        folder in which to save the image file\n    dpi: int\n        resolution at which to save the image\n    bbox_inches: string\n        tell matplotlib to figure out the tight bbox of the figure\n    pad: float\n        inches to pad around the figure\n    \n    Returns\n    -------\n    tuple \n    (fig, ax) if show=False, otherwise returns None\n    """"""\n    \n    if title_font is None:\n        title_font = get_title_font()\n        \n    if label_font is None:\n        label_font = get_label_font()\n        \n    # first get the xyz points to plot\n    points = get_phase_diagram_points(pops, discard_gens, dimensions=3)\n    plots = []\n    \n    # get_phase_diagram_points() returns a MultiIndexed DataFrame, each run of the model has its own \'name\' in the index\n    index = points.index.get_level_values(\'name\')\n    names = np.unique(index)\n    \n    # create a new figure, set its size, and create an axis with a 3-D projection\n    fig = plt.figure(figsize=figsize)\n    ax = fig.gca(projection=\'3d\')\n    ax.xaxis.set_pane_color((1,1,1,1))\n    ax.yaxis.set_pane_color((1,1,1,1))\n    ax.zaxis.set_pane_color((1,1,1,1))\n\n    # configure the perspective from which to view the 3D plot\n    ax.elev = elev\n    ax.azim = azim\n    ax.dist = dist\n    \n    # set the plot title, axis limits, and axis labels\n    ax.set_title(title, fontproperties=get_title_font())\n    ax.set_xlim(xmin, xmax)\n    ax.set_ylim(ymin, ymax)\n    ax.set_zlim(zmin, zmax)\n    ax.set_xlabel(xlabel, fontproperties=get_label_font())\n    ax.set_ylabel(ylabel, fontproperties=get_label_font())  \n    ax.set_zlabel(zlabel, fontproperties=get_label_font())\n    \n    #remove all ticks if argument is True\n    if remove_ticks:\n        ax.tick_params(reset=True, axis=\'both\', which=\'both\', pad=0, width=0, length=0,\n                       bottom=False, top=False, left=False, right=False, \n                       labelbottom=False, labeltop=False, labelleft=False, labelright=False)\n    else:\n        ax.tick_params(reset=True)\n        \n    # make sure we have a list of colors as long as the number of model runs\n    color_list = get_phase_colors(color, len(names), color_reverse)\n    \n    # plot the xyz data for each run of the model that appears in the MultiIndex\n    for n in range(len(names)):\n        xyz = points.iloc[index == names[n]]\n        plots.append(ax.scatter(xyz[\'x\'], xyz[\'y\'], xyz[\'z\'], \n                                marker=marker, c=[color_list[n]], edgecolor=[color_list[n]], s=size, alpha=alpha))\n        \n    # add a legend if argument is True\n    if legend:\n        ax.legend(plots, names.tolist(), loc=1, frameon=True, framealpha=1, bbox_to_anchor=legend_bbox_to_anchor)\n    \n    if filename == \'\':\n        filename = title.replace(\' \', \'-\').replace(\'=\', \'-\').replace(\',\', \'-\').replace(\'.\', \'\').replace(\'--\', \'-\')\n    \n    return save_and_show(fig=fig, ax=ax, save=save, show=show, filename=filename, folder=folder, dpi=dpi, bbox_inches=bbox_inches, pad=pad)\n    \n\n    \n    \ndef get_cobweb_points(model, r, x, n):\n    """"""\n    Calculate the vertices of cobweb lines for a cobweb plot. \n        \n    Steps in the calculation:\n    1) Let x = 0.5\n    2) Start on the x-axis at the point (x, 0).\n    3) Draw a vertical line to the red function curve: this point has the coordinates (x, f(x)).\n    4) Draw a horizontal line from this point to the gray diagonal line: this point has the coordinates (f(x), f(x)).\n    5) Draw a vertical line from this point to the red function curve: this point has the coordinates (f(x), f(f(x))).\n    6) Repeat steps 4 and 5 recursively one hundred times.\n    \n    Arguments\n    ---------\n    model: function\n        defining an iterated map to simulate\n    r: float\n        growth rate parameter value to pass to the map\n    x: float\n        starting population value\n    n: int\n        number of iterations to run\n    \n    Returns\n    -------\n    tuple\n        cobweb_x_vals, cobweb_y_vals\n    """"""\n    \n    cobweb_points = [(x, 0)]\n    for _ in range(n):\n        y1 = model(x, r)\n        cobweb_points.append((x, y1))\n        cobweb_points.append((y1, y1))\n        y2 = model(y1, r)\n        cobweb_points.append((y1, y2))\n        x = y1\n    return zip(*cobweb_points)\n    \n    \n    \n    \ndef get_function_points(model, r, n, start, end):\n    """"""\n    Calculate model results for n population values evenly spaced between start and end values.\n    \n    Arguments\n    ---------\n    model: function\n        defining an iterated map to simulate\n    r: float\n        growth rate parameter value to pass to the map\n    n: int\n        number of iterations to run\n    start: float\n        lower limit of the function range\n    end: float\n        upper limit of the function range\n    \n    Returns\n    -------\n    tuple\n        x_vals, y_vals\n    """"""\n    \n    x_vals = np.linspace(start, end, n)\n    y_vals = [model(x, r) for x in x_vals]\n    return x_vals, y_vals\n    \n    \n\n    \ndef cobweb_plot(model=logistic_map, r=0, function_n=1000, cobweb_n=100, cobweb_x=0.5, num_discard=0, title=\'\', filename=\'\', show=True, save=True,\n                start=0, end=1, figsize=(6,6), diagonal_linewidth=1.35, cobweb_linewidth=1, function_linewidth=1.5, title_font=None, label_font=None,\n                folder=\'images\', dpi=300, bbox_inches=\'tight\', pad=0.1):\n    """"""\n    Draw a cobweb plot. \n    \n    Run the map once each for 1000 population values evenly spaced between 0 and 1. \n    This gives us the results of the equation (y values) across the entire range of \n    possible population values (x values). The gray diagonal line is just a plot of y=x.\n    \n    Arguments\n    ---------\n    model: function\n        defining an iterated map to simulate\n    r: float\n        growth rate parameter value to pass to the map\n    function_n: int\n        number of iterations of the function to run\n    cobweb_n: int\n        number of iterations of the cobweb line to run\n    num_discard: int\n        how many initial iterations of the cobweb line to throw away\n    title: string\n        title of the plot\n    filename: string\n        name of image file to be saved, if applicable\n    save: bool\n        whether to save the image to disk or not\n    show: bool\n        whether to display the image on screen or not\n    start: float\n        lower limit of the function range\n    end: float\n        upper limit of the function range\n    figsize: tuple\n        (width, height) of figure\n    diagonal_linewidth: float\n        width of y=x line\n    cobweb_linewidth: float\n        width of cobweb line\n    function_linewidth: float\n        width of function line\n    title_font: matplotlib.font_manager.FontProperties\n        font properties for figure title\n    label_font: matplotlib.font_manager.FontProperties\n        font properties for axis labels\n    folder: string\n        folder in which to save the image file\n    dpi: int\n        resolution at which to save the image\n    bbox_inches: string\n        tell matplotlib to figure out the tight bbox of the figure\n    pad: float\n        inches to pad around the figure\n    \n    Returns\n    -------\n    tuple\n        (fig, ax) if show=False, otherwise returns None\n    """"""\n    \n    if title_font is None:\n        title_font = get_title_font()\n        \n    if label_font is None:\n        label_font = get_label_font()\n        \n    func_x_vals, func_y_vals = get_function_points(model=model, r=r, n=function_n, start=start, end=end)\n    cobweb_x_vals, cobweb_y_vals = get_cobweb_points(model=model, r=r, x=cobweb_x, n=cobweb_n)\n    cobweb_x_vals = cobweb_x_vals[num_discard:]\n    cobweb_y_vals = cobweb_y_vals[num_discard:]\n    \n    fig, ax = plt.subplots(figsize=figsize)\n    diagonal_line = ax.plot((0,1), (0,1), color=\'gray\', linewidth=diagonal_linewidth)\n    function_line = ax.scatter(func_x_vals, func_y_vals, color=\'#cc0000\', edgecolor=\'None\', s=function_linewidth)\n    cobweb_line = ax.plot(cobweb_x_vals, cobweb_y_vals, color=\'#003399\', linewidth=cobweb_linewidth)\n    \n    ax.set_ylim((0, 1))\n    ax.set_xlim((0, 1))\n    if title == \'\':\n        title = \'Cobweb Plot, r={}\'.format(r)\n    ax.set_title(title, fontproperties=get_title_font())\n    \n    if filename == \'\':\n        filename = \'cobweb-plot-r{}-x{}\'.format(r, cobweb_x).replace(\'.\', \'\')\n    \n    return save_and_show(fig=fig, ax=ax, save=save, show=show, filename=filename, folder=folder, dpi=dpi, bbox_inches=bbox_inches, pad=pad)\n    \n    \n    \n    '"
tests/test_pynamical.py,0,"b'""""""\npynamical tests\n-------\n""""""\n\nimport matplotlib as mpl\nmpl.use(\'Agg\') #use agg backend so you don\'t need a display on travis\n\nimport matplotlib.cm as cm\nimport matplotlib.font_manager as fm\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\nimport pandas as pd\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom numba import jit\n\nfrom pynamical import simulate, logistic_map, cubic_map, singer_map\nfrom pynamical import bifurcation_plot, cobweb_plot, phase_diagram, phase_diagram_3d\n\n_img_folder = \'.temp\'\n\n\ndef test_simulate():\n    \n    pops = simulate(model=logistic_map, num_gens=200, rate_min=3.7, rate_max=3.9, num_rates=100, num_discard=100, jit=True)\n    assert type(pops)==pd.DataFrame\n    assert pops.shape==(200, 100)\n\n    pops = simulate(model=logistic_map, num_gens=200, rate_min=3.7, rate_max=3.9, num_rates=100, num_discard=100, jit=False)\n    assert type(pops)==pd.DataFrame\n    assert pops.shape==(200, 100)\n\n\ndef test_bifurcation_plot():\n    \n    pops = simulate(model=logistic_map, num_gens=200, rate_min=0, rate_max=4, num_rates=100, num_discard=100)\n    assert type(pops)==pd.DataFrame\n    assert pops.shape==(200, 100)\n\n    # returns None\n    bifurcation_plot(pops, save=True, folder=_img_folder, filename=\'\')\n\n\ndef test_phase_diagram():\n    \n    pops = simulate(model=singer_map, num_gens=200, rate_min=3.6, rate_max=4.0, num_rates=50, num_discard=100)\n    assert type(pops)==pd.DataFrame\n    assert pops.shape==(200, 50)\n\n    # returns None\n    phase_diagram(pops, xmin=0.25, xmax=0.75, ymin=0.8, ymax=1.01, size=7, discard_gens=10, color=\'b\', color_reverse=True,\n                  legend=True, save=False, folder=_img_folder, filename=\'\')\n    \n    fig_ax = phase_diagram(pops, xmin=0.25, xmax=0.75, ymin=0.8, ymax=1.01, size=7, discard_gens=10, color=[\'b\', \'g\'],\n                           legend=True, save=False, show=False, folder=_img_folder, filename=\'\')\n    assert type(fig_ax)==tuple\n\n\ndef test_phase_diagram_3d():    \n    \n    pops = simulate(model=cubic_map, num_gens=200, rate_min=3.5, num_rates=30, num_discard=100)\n    assert type(pops)==pd.DataFrame\n    assert pops.shape==(200, 30)\n    \n    # returns None\n    phase_diagram_3d(pops, xmin=-1, xmax=1, ymin=-1, ymax=1, zmin=-1, zmax=1, alpha=0.2, color=\'viridis\', azim=330, \n                     legend=True, save=False, folder=_img_folder, filename=\'\')\n    \n    # returns None\n    phase_diagram_3d(pops, xmin=-1, xmax=1, ymin=-1, ymax=1, zmin=-1, zmax=1, alpha=0.2, color=\'inferno\', azim=330, \n                     legend=True, remove_ticks=False, save=False, folder=_img_folder, filename=\'\')\n\n\ndef test_cobweb_plot():\n\n    # returns None\n    cobweb_plot(r=3.9, save=False, folder=_img_folder, filename=\'\')\n\n'"
docs/source/conf.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# pynamical documentation build configuration file, created by\n# sphinx-quickstart on Tue Jan 31 13:34:32 2017.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\n# go up two levels from /docs/source to the package root\nsys.path.insert(0, os.path.abspath(\'../..\'))\n\n# mock import these packages because readthedocs doesn\'t have them installed\nautodoc_mock_imports = [\n    \'pandas\',\n    \'numpy\',\n    \'numba\',\n    \'matplotlib\',\n    \'mpl_toolkits\',\n    \'matplotlib.pyplot\',\n    \'matplotlib.font_manager\',\n    \'matplotlib.cm\',\n    \'mpl_toolkits.mplot3d\'\n]\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\'sphinx.ext.autodoc\',\n              \'sphinx.ext.napoleon\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = \'pynamical\'\ncopyright = \'2020, Geoff Boeing\'\nauthor = \'Geoff Boeing\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \'0.2.1\'\n# The full version, including alpha/beta/rc tags.\nrelease = \'0.2.1\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = []\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'default\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n\n# -- Options for HTMLHelp output ------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'pynamicaldoc\'\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'pynamical.tex\', \'pynamical Documentation\',\n     \'Geoff Boeing\', \'manual\'),\n]\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'pynamical\', \'pynamical Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'pynamical\', \'pynamical Documentation\',\n     author, \'pynamical\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n\n'"
