file_path,api_count,code
setup.py,0,"b'#-----------------------------------------------------------------------------\n# Copyright (C) 2011-2016  Nicolas P. Rougier\n#\n# Distributed under the terms of the BSD License. The full license is in\n# the file COPYING, distributed as part of this software.\n#-----------------------------------------------------------------------------\nimport os\nimport numpy\nfrom Cython.Distutils import build_ext\nfrom setuptools import setup, Extension\n\nif __name__ == ""__main__"":\n\n    if os.path.exists(\'MANIFEST\'):\n        os.remove(\'MANIFEST\')\n\n    setup(name=""glumpy"",\n          version=""1.1.0"",\n          description=""Fast, scalable & beautiful scientific visualisation"",\n          long_description = """"""Glumpy is a python library for scientific\n                                visualization that is both fast, scalable\n                                and beautiful. Glumpy offers an intuitive\n                                interface between numpy and modern OpenGL."""""",\n          url = ""http://glumpy.github.io"",\n          download_url = ""https://github.com/glumpy/glumpy/releases"",\n          keywords = ""OpenGL, GLSL, 2D, 3D, Visualisation, Science, Numpy, Graphics, Shaders"",\n          platform = ""Any"",\n          maintainer= ""Nicolas P. Rougier"",\n          maintainer_email=""Nicolas.Rougier@inria.fr"",\n          install_requires=[\'numpy\', \'triangle\', \'cython\'],\n          classifiers=[\n              ""Development Status :: 4 - Beta"",\n              ""Operating System :: MacOS :: MacOS X"",\n              ""Operating System :: Microsoft :: Windows"",\n              ""Operating System :: POSIX"",\n              ""Programming Language :: Python :: 2.7"",\n              ""License :: OSI Approved :: BSD License"",\n              ""Intended Audience :: Developers"",\n              ""Intended Audience :: Science/Research"",\n              ""Topic :: Scientific/Engineering :: Visualization"",\n              ""Topic :: Multimedia :: Graphics"",\n          ],\n          license = ""BSD License"",\n          packages=[\'glumpy\',\n                    \'glumpy.data\',\n                    \'glumpy.ext\',\n                    \'glumpy.ext.sdf\',\n                    \'glumpy.ext.freetype\',\n                    \'glumpy.ext.freetype.ft_enums\',\n                    \'glumpy.app\',\n                    \'glumpy.app.window\',\n                    \'glumpy.app.window.backends\',\n                    \'glumpy.gloo\',\n                    \'glumpy.api\',\n                    \'glumpy.api.matplotlib\',\n\n                    \'glumpy.library\',\n                    \'glumpy.library.math\',\n                    \'glumpy.library.misc\',\n                    \'glumpy.library.arrows\',\n                    \'glumpy.library.markers\',\n                    \'glumpy.library.colormaps\',\n                    \'glumpy.library.antialias\',\n                    \'glumpy.library.transforms\',\n                    \'glumpy.library.collections\',\n\n                    \'glumpy.geometry\',\n                    \'glumpy.graphics\',\n                    \'glumpy.graphics.svg\',\n                    \'glumpy.graphics.color\',\n                    \'glumpy.transforms\',\n                    \'glumpy.graphics.text\',\n                    \'glumpy.graphics.collections\'],\n\n          package_data={\n              \'glumpy.ext.sdf\':             [\'_sdf.pyx\', \'sdf.h\'],\n              \'glumpy.data\':                [\'6x13-italic.npy\',\n                                             \'6x13-regular.npy\',\n                                             \'6x13-bold.npy\',\n                                             \'spatial-filters.npy\',\n                                             \'SourceSansPro-Regular.otf\' ],\n              \'glumpy.library\':             [\'*.vert\',\'*.frag\', ""*.geom"", ""*.glsl""],\n              \'glumpy.library.math\':        [\'*.vert\',\'*.frag\', ""*.geom"", ""*.glsl""],\n              \'glumpy.library.misc\':        [\'*.vert\',\'*.frag\', ""*.geom"", ""*.glsl""],\n              \'glumpy.library.arrows\':      [\'*.vert\',\'*.frag\', ""*.geom"", ""*.glsl""],\n              \'glumpy.library.markers\':     [\'*.vert\',\'*.frag\', ""*.geom"", ""*.glsl""],\n              \'glumpy.library.colormaps\':   [\'*.vert\',\'*.frag\', ""*.geom"", ""*.glsl""],\n              \'glumpy.library.antialias\':   [\'*.vert\',\'*.frag\', ""*.geom"", ""*.glsl""],\n              \'glumpy.library.transforms\':  [\'*.vert\',\'*.frag\', ""*.geom"", ""*.glsl""],\n              \'glumpy.library.collections\': [\'*.vert\',\'*.frag\', ""*.geom"", ""*.glsl""]\n          },\n\n          cmdclass={\'build_ext\': build_ext},\n          ext_modules=[Extension(""glumpy.ext.sdf.sdf"",\n                                 sources=[""glumpy/ext/sdf/_sdf.pyx"",\n                                          ""glumpy/ext/sdf/sdf.c""],\n                                 include_dirs=[numpy.get_include()])],\n)\n'"
doc/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# glumpy documentation build configuration file, created by\n# sphinx-quickstart on Sat May  4 16:52:02 2013.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(\'..\'))\n#sys.path.insert(0, os.path.abspath(\'.\'))\ncurpath = os.path.dirname(__file__)\nsys.path.append(os.path.abspath(\'ext\'))\n\n# -- General configuration -----------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named \'sphinx.ext.*\') or your custom ones.\nextensions = [\'sphinx.ext.autodoc\', \'sphinx.ext.pngmath\',\n              \'sphinx.ext.autosummary\', \'sphinx.ext.intersphinx\',\n              \'sphinx.ext.napoleon\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'glumpy\'\ncopyright = u\'2011-2016, Nicolas P. Rougier\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n\n# The short X.Y version.\nversion = \'1.x\'\n# The full version, including alpha/beta/rc tags.\nrelease = \'1.x\'\n\n\n# -- General configuration -----------------------------------------------\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of documents that shouldn\'t be included in the build.\n#unused_docs = []\n\n# List of directories, relative to source directory, that shouldn\'t be searched\n# for source files.\nexclude_trees = []\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------\n\n# The theme to use for HTML and HTML Help pages. Major themes that come with\n# Sphinx are currently \'default\' and \'sphinxdoc\'.\n# html_theme = \'scikit-image\'\n# html_theme = \'sphinxdoc\'\n# html_theme = \'default\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further. For a list of options available for each theme, see the\n# documentation.\n# html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = [\'_themes\']\n\n\n# on_rtd is whether we are on readthedocs.org, this line of code grabbed from docs.readthedocs.org\non_rtd = os.environ.get(\'READTHEDOCS\', None) == \'True\'\n# only import and set the theme if we\'re building docs locally\nif not on_rtd:\n   import sphinx_rtd_theme\n   html_theme = \'sphinx_rtd_theme\'\n   html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n\n# The name for this set of Sphinx documents. If None, it defaults to\n# ""<project> v<release> documentation"".\nhtml_title = \'glumpy v%s documentation\' % version\n\n# A shorter title for the navigation bar. Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs. This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n    \'**\': [\'navigation.html\',\n           \'localtoc.html\',\n           \'versions.html\'],\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_use_modindex = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it. The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# If nonempty, this is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = \'\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'glumpydoc\'\n\n\n# -- Options for LaTeX output --------------------------------------------\n\n# The paper size (\'letter\' or \'a4\').\n#latex_paper_size = \'letter\'\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\nlatex_font_size = \'10pt\'\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n    (\'contents\', \'glumpy.tex\', u\'The glumpy Documentation\',\n     u\'Nicolas P. Rougier\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# Additional stuff for the LaTeX preamble.\nlatex_preamble = r\'\'\'\n\\usepackage{enumitem}\n\\setlistdepth{100}\n\n\\usepackage{amsmath}\n\\DeclareUnicodeCharacter{00A0}{\\nobreakspace}\n\n% In the parameters section, place a newline after the Parameters header\n\\usepackage{expdlist}\n\\let\\latexdescription=\\description\n\\def\\description{\\latexdescription{}{} \\breaklabel}\n\n% Make Examples/etc section headers smaller and more compact\n\\makeatletter\n\\titleformat{\\paragraph}{\\normalsize\\py@HeaderFamily}%\n{\\py@TitleColor}{0em}{\\py@TitleColor}{\\py@NormalColor}\n\\titlespacing*{\\paragraph}{0pt}{1ex}{0pt}\n\\makeatother\n\n\'\'\'\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\nlatex_use_modindex = False\n'"
examples/agg-filters.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" This example shows spatial interpolation of images. """"""\nimport numpy as np\nfrom glumpy import app, gl, gloo, data, library\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n        v_texcoord = texcoord;\n    } """"""\n\nfragment = """"""\n#include ""misc/spatial-filters.frag""\n\nuniform sampler2D u_data;\nuniform vec2      u_shape;\nuniform float     u_interpolation;\nvarying vec2      v_texcoord;\nvoid main()\n{\n    if (u_interpolation < 0.5)       gl_FragColor = Nearest(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 1.5)  gl_FragColor = Bilinear(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 2.5)  gl_FragColor = Hanning(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 3.5)  gl_FragColor = Hamming(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 4.5)  gl_FragColor = Hermite(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 5.5)  gl_FragColor = Kaiser(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 6.5)  gl_FragColor = Quadric(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 7.5)  gl_FragColor = Bicubic(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 8.5)  gl_FragColor = CatRom(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 9.5)  gl_FragColor = Mitchell(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 10.5) gl_FragColor = Spline16(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 11.5) gl_FragColor = Spline36(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 12.5) gl_FragColor = Gaussian(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 13.5) gl_FragColor = Bessel(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 14.5) gl_FragColor = Sinc(u_data, u_shape, v_texcoord);\n    else if (u_interpolation < 15.5) gl_FragColor = Lanczos(u_data, u_shape, v_texcoord);\n    else                             gl_FragColor = Blackman(u_data, u_shape, v_texcoord);\n} """"""\n\nwindow = app.Window(width=2*512, height=2*512)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_key_press(key, modifiers):\n    names = [\n        ""Nearest"", ""Bilinear"", ""Hanning"", ""Hamming"",\n        ""Hermite"", ""Kaiser"", ""Quadric"", ""Bicubic"",\n        ""CatRom"", ""Mitchell"", ""Spline16"", ""Spline36"",\n        ""Gaussian"", ""Bessel"", ""Sinc"", ""Lanczos"", ""Blackman""]\n    \n    if key == app.window.key.RIGHT:\n        program[\'u_interpolation\'] = (program[\'u_interpolation\'] + 1) % 17\n    elif key == app.window.key.LEFT:\n        program[\'u_interpolation\'] = (program[\'u_interpolation\'] - 1) % 17\n    print(""Interpolation :"", names[int(program[\'u_interpolation\'])])\n    \nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[""position""] = (-1,-1), (-1,+1), (+1,-1), (+1,+1)\nprogram[\'texcoord\'] = ( 0, 0), ( 0,+1), (+1, 0), (+1,+1)\n\nprogram[\'u_data\'] =np.array( [ [0.0,0.0,0.0,0.0,0.0],\n                               [0.0,0.5,0.5,0.5,0.0],\n                               [0.0,0.5,1.0,0.5,0.0],\n                               [0.0,0.5,0.5,0.5,0.0],\n                               [0.0,0.0,0.0,0.0,0.0] ]).astype(np.float32)\n\nprogram[\'u_data\'].interpolation = gl.GL_NEAREST\nprogram[\'u_data\'].wrapping = gl.GL_CLAMP\nprogram[\'u_shape\'] = program[\'u_data\'].shape[:2]\n\nprogram[\'u_kernel\'] = data.get(""spatial-filters.npy"")\nprogram[\'u_kernel\'].interpolation = gl.GL_NEAREST\nprogram[\'u_kernel\'].wrapping = gl.GL_CLAMP\n\nprogram[\'u_interpolation\'] = 0\n\n\napp.run()\n'"
examples/app-backend.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app\napp.use(""osxglut"")\n\nwindow = app.Window()\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n\napp.run()\n'"
examples/app-config.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" This example show how to choose a configuration. """"""\nfrom glumpy import app\n\nconfig = app.configuration.Configuration()\nconfig.major_version = 3\nconfig.minor_version = 2\nconfig.profile = ""core""\nprint(config)\nprint(""-----"")\nwindow = app.Window(config=config)\nprint(""-----"")\nprint(window.config)\nprint(""-----"")\n'"
examples/app-event-loop.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" This example shows how to run the event loop manually """"""\n\nfrom glumpy import app\n\nwindow = app.Window()\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n\nbackend = app.__backend__\nclock = app.__init__(backend=backend)\ncount = len(backend.windows())\nwhile count:\n    count = backend.process(clock.tick())\n'"
examples/app-events.py,0,"b""# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app\n\nwindow = app.Window()\n\n@window.event\ndef on_init():\n    print('Initialization')\n\n@window.event\ndef on_draw(dt):\n    # print 'Draw after %.1f milliseconds' % (1000*dt)\n    window.clear()\n\n@window.event\ndef on_resize(width,height):\n    print('Window resized (width=%.1f, height=%.1f)'% (width,height))\n\n@window.timer(1.0) # frames per second\ndef timer(elapsed):\n    print('Timed event (%.2f second(s) elapsed)' % elapsed)\n\n# @window.event\n# def on_idle(dt):\n#     print 'Idle event'\n\n@window.event\ndef on_key_press(symbol, modifiers):\n    print('Key pressed (symbol=%s, modifiers=%s)'% (symbol,modifiers))\n\n@window.event\ndef on_character(character):\n    print('Character entered (chracter: %s)'% character)\n\n@window.event\ndef on_key_release(symbol, modifiers):\n    print('Key released (symbol=%s, modifiers=%s)'% (symbol,modifiers))\n\n@window.event\ndef on_mouse_press(x, y, button):\n    print('Mouse button pressed (x=%.1f, y=%.1f, button=%d)' % (x,y,button))\n\n@window.event\ndef on_mouse_release(x, y, button):\n    print('Mouse button released (x=%.1f, y=%.1f, button=%d)' % (x,y,button))\n\n@window.event\ndef on_mouse_motion(x, y, dx, dy):\n    print('Mouse motion (x=%.1f, y=%.1f, dx=%.1f, dy=%.1f)' % (x,y,dx,dy))\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    print('Mouse drag (x=%.1f, y=%.1f, dx=%.1f, dy=%.1f, button=%d)' % (x,y,dx,dy,button))\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    print('Mouse scroll (x=%.1f, y=%.1f, dx=%.1f, dy=%.1f)' % (x,y,dx,dy))\n\napp.run(framerate=10)\n"""
examples/app-interactive.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app\n\nwindow = app.Window()\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n\napp.run(interactive=True)\nprint(""Try to type \'window.color = (1,1,1,1)\' in the console"")\n'"
examples/app-qt5.py,1,"b'# -----------------------------------------------------------------------------\n# Glumpy / Qt5 integration example (c) LeMinaw, 2020\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n\nimport numpy as np\nfrom glumpy import app\nfrom PyQt5.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QPushButton\n\n\napp.use(""qt5"")\nwindow = app.Window()\n\nqwindow = QMainWindow()\nwidget = QWidget()\nbutton = QPushButton(""Press me!"")\nqwindow.setCentralWidget(widget)\nwidget.setLayout(QVBoxLayout())\nwidget.layout().addWidget(window._native_window)\nwidget.layout().addWidget(button)\n\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n\n\n@button.clicked.connect\ndef on_click():\n    window.color = np.random.rand(4)\n\n\nqwindow.show()\napp.run()\n'"
examples/app-screenshot.py,1,"b""# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl\nfrom glumpy.ext import png\n\nwindow = app.Window(color=(1,0,0,1))\nframebuffer = np.zeros((window.height, window.width * 3), dtype=np.uint8)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    gl.glReadPixels(0, 0, window.width, window.height,\n                    gl.GL_RGB, gl.GL_UNSIGNED_BYTE, framebuffer)\n    png.from_array(framebuffer, 'RGB').save('screenshot.png')\n\napp.run(framecount=1)\n"""
examples/app-simple.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app\n\nwindow = app.Window()\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n\napp.run()\n'
examples/app-timed.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app\n\nwindow = app.Window()\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n\napp.run(framerate=60, duration=5.0)\n'"
examples/app-two-programs.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import gl, app, gloo\n\n\nvertex = """"""\nattribute vec2 a_position;\nvoid main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    gl_PointSize = 30.0;\n}\n""""""\n\nfragment1 = """"""\nvoid main() {\n    gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n}\n""""""\n\nfragment2 = """"""\nvoid main() {\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n""""""\n\n\nprogram1 = gloo.Program(vertex, fragment1)  # blue on the right\nprogram1[\'a_position\'] = np.zeros((1,2),dtype=np.float32) + 0.5\nprogram2 = gloo.Program(vertex, fragment2)  # red on the left\nprogram2[\'a_position\'] = np.zeros((1,2),dtype=np.float32) - 0.5\n\n\nwindow = app.Window()\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program1.draw(gl.GL_POINTS)\n    program2.draw(gl.GL_POINTS)\n\napp.run()\n'"
examples/app-two-windows.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app\n\nwindow1 = app.Window(color=(0,0,0,1))\nwindow2 = app.Window(color=(1,1,1,1))\n\n@window1.event\ndef on_draw(dt):\n    window1.clear()\n\n@window2.event\ndef on_draw(dt):\n    window2.clear()\n\napp.run()\n'"
examples/brain.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, data, log\nfrom glumpy.transforms import Trackball, Position\n\n\nvertex = """"""\nuniform mat4 m_model;\nuniform mat4 m_view;\nuniform mat4 m_normal;\nattribute vec3 position;\nattribute vec3 normal;\nvarying vec3 v_normal;\nvarying vec3 v_position;\n\nvoid main()\n{\n    gl_Position = <transform>;\n    vec4 P = m_view * m_model* vec4(position, 1.0);\n    v_position = P.xyz / P.w;\n    v_normal = vec3(m_normal * vec4(normal,0.0));\n}\n""""""\n\nfragment = """"""\nvarying vec3 v_normal;\nvarying vec3 v_position;\n\nconst vec3 light_position = vec3(1.0,1.0,1.0);\nconst vec3 ambient_color = vec3(0.1, 0.0, 0.0);\nconst vec3 diffuse_color = vec3(0.75, 0.125, 0.125);\nconst vec3 specular_color = vec3(1.0, 1.0, 1.0);\nconst float shininess = 128.0;\nconst float gamma = 2.2;\n\nvoid main()\n{\n    vec3 normal= normalize(v_normal);\n    vec3 light_direction = normalize(light_position - v_position);\n    float lambertian = max(dot(light_direction,normal), 0.0);\n    float specular = 0.0;\n    if (lambertian > 0.0)\n    {\n        vec3 view_direction = normalize(-v_position);\n        vec3 half_direction = normalize(light_direction + view_direction);\n        float specular_angle = max(dot(half_direction, normal), 0.0);\n        specular = pow(specular_angle, shininess);\n    }\n    vec3 color_linear = ambient_color +\n                        lambertian * diffuse_color +\n                        specular * specular_color;\n    vec3 color_gamma = pow(color_linear, vec3(1.0/gamma));\n    gl_FragColor = vec4(color_gamma, 1.0);\n}\n""""""\n\nlog.info(""Loading brain mesh"")\nvertices,indices = data.get(""brain.obj"")\nbrain = gloo.Program(vertex, fragment)\nbrain.bind(vertices)\ntrackball = Trackball(Position(""position""))\nbrain[\'transform\'] = trackball\ntrackball.theta, trackball.phi, trackball.zoom = 80, -135, 15\n\nwindow = app.Window(width=1024, height=768)\n\ndef update():\n    model = brain[\'transform\'][\'model\'].reshape(4,4)\n    view  = brain[\'transform\'][\'view\'].reshape(4,4)\n    brain[\'m_view\']  = view\n    brain[\'m_model\'] = model\n    brain[\'m_normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\n    \n@window.event\ndef on_draw(dt):\n    window.clear()\n    brain.draw(gl.GL_TRIANGLES)\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    update()\n    \n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    update()\n\nwindow.attach(brain[\'transform\'])\napp.run()\n'"
examples/cartopy.py,15,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl, data\nfrom glumpy.transforms import Position, LogScale, LinearScale, Viewport\nfrom glumpy.transforms import PolarProjection\nfrom glumpy.transforms import HammerProjection\nfrom glumpy.transforms import AzimuthalEqualAreaProjection\nfrom glumpy.transforms import AzimuthalEquidistantProjection\nfrom glumpy.transforms import TransverseMercatorProjection\n\nvertex = """"""\nattribute vec2 position;\nvarying vec2 v_uv;\nvoid main()\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n    v_uv = (position + 1.0) / 2.0;\n} """"""\n\nfragment = """"""\nvarying vec2 v_uv;\n\nuniform sampler2D texture; // Texture\nuniform float antialias;   // Line antialias\nuniform vec2  major_step;  // Major ticks step\nuniform vec2  minor_step;  // Minor ticks step\nuniform float major_width; // Major line width (1.50 pixel)\nuniform float minor_width; // Minor line width (0.75 pixel)\nuniform vec4  major_color; // Major line color\nuniform vec4  minor_color; // Minor line color\n\n\n// Antialias stroke alpha coeff\nfloat stroke_alpha(float distance, float linewidth, float antialias)\n{\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n    if( border_distance > (linewidth/2.0 + antialias) )\n        return 0.0;\n    else if( border_distance < 0.0 )\n        return 1.0;\n    else\n        return alpha;\n}\n\n\n// Compute the nearest tick from a value\nfloat get_tick(float value, vec2 bounds, float step)\n{\n    float vmin = bounds.x;\n    float vmax = bounds.y;\n\n    float first_tick = floor((vmin + step/2.0)/step) * step;\n    float last_tick  = floor((vmax + step/2.0)/step) * step;\n    float tick = vmin + value*(vmax-vmin);\n    if (tick < (vmin + (first_tick-vmin)/2.0))\n        return vmin;\n    if (tick > (last_tick + (vmax-last_tick)/2.0))\n        return vmax;\n    tick += step/2.0;\n    tick = floor(tick/step)*step;\n    return clamp(tick,vmin,vmax);\n}\n\n// Compute the screen distance (pixels) between P0 and P1\nfloat screen_distance(vec2 P0, vec2 P1)\n{\n    return length((P0-P1) * <viewport.viewport_global>.zw);\n}\n\n\nvoid main()\n{\n    // <scale1>\n    // vec2 T1; // Texture coordinates (domain [0,1]x[0,1])\n    // vec2 P1; // Cartesian coordinates (range is free)\n\n    // <scale2>\n    // vec2 P2; // Projected coordinates (domain is dependent on projection)\n    // vec2 T2; // Projected texture coordinates (range [0,1]x[0,1])\n\n    // Get texture coordinates (-> scale1.domain)\n    vec2 T1 = v_uv;\n\n    // This scales texture coordinates into cartesian coordinates\n    // scale1.domain -> scale1.range\n    vec2 P1 = vec2( <scale1.x.forward(T1.x)>,\n                    <scale1.y.forward(T1.y)> );\n\n    // Actual projection (scale1.range -> scale2.domain)\n    vec2 P2 = <projection.inverse(P1)>;\n\n    // This scales projected coordinates into texture coordinates\n    // scale2.domain -> scale2.range\n    vec2 T2 = vec2( <scale2.x.forward(P2.x)>,\n                    <scale2.y.forward(P2.y)> );\n\n    // Test if we are within limits but we do not discard yet because we want\n    // to draw border. Discarding would mean half of the exterior not drawn.\n    bvec2 outside = bvec2(false);\n    if ( P2.x < <scale2.x.domain>.x ) outside.x = true;\n    if ( P2.x > <scale2.x.domain>.y ) outside.x = true;\n    if ( P2.y < <scale2.y.domain>.x ) outside.y = true;\n    if ( P2.y > <scale2.y.domain>.y ) outside.y = true;\n\n    float tick;\n    vec2 P;\n\n    // Compute major x tick\n    tick = get_tick(T2.x, <scale2.x.domain>, major_step.x);\n    P = <projection.forward(vec2(tick,P2.y))>.xy;\n    P = vec2( <scale1.x.inverse(P.x)>, <scale1.y.inverse(P.y)> );\n    float Mx = screen_distance(T1, P);\n\n    // Compute major y tick\n    tick = get_tick(T2.y, <scale2.y.domain>, major_step.y);\n    P = <projection.forward(vec2(P2.x,tick))>.xy;\n    P = vec2( <scale1.x.inverse(P.x)>, <scale1.y.inverse(P.y)> );\n    float My = screen_distance(T1, P);\n\n    // Compute minor x tick\n    tick = get_tick(T2.x, <scale2.x.domain>, minor_step.x);\n    P = <projection.forward(vec2(tick,P2.y))>.xy;\n    P = vec2( <scale1.x.inverse(P.x)>, <scale1.y.inverse(P.y)> );\n    float mx = screen_distance(T1, P);\n\n    // Compute minor y tick\n    tick = get_tick(T2.y, <scale2.y.domain>, minor_step.y);\n    P = <projection.forward(vec2(P2.x,tick))>.xy;\n    P = vec2( <scale1.x.inverse(P.x)>, <scale1.y.inverse(P.y)> );\n    float my = screen_distance(T1, P);\n\n    float M = min(Mx,My);\n    float m = min(mx,my);\n\n\n    // Here we take care of ""finishing"" the border lines\n    if( outside.x && outside.y ) {\n        if (Mx > 0.5*(major_width + antialias)) {\n            discard;\n        } else if (My > 0.5*(major_width + antialias)) {\n            discard;\n        } else {\n            M = max(Mx,My);\n        }\n    } else if( outside.x ) {\n        if (Mx > 0.5*(major_width + antialias)) {\n            discard;\n        } else {\n            M = m = Mx;\n        }\n    } else if( outside.y ) {\n        if (My > 0.5*(major_width + antialias)) {\n            discard;\n        } else {\n            M = m = My;\n        }\n    }\n\n    // Mix major/minor colors to get dominant color\n    vec4 color = major_color;\n    float alpha1 = stroke_alpha( M, major_width, antialias);\n    float alpha2 = stroke_alpha( m, minor_width, antialias);\n    float alpha  = alpha1;\n    if( alpha2 > alpha1*1.5 )\n    {\n        alpha = alpha2;\n        color = minor_color;\n    }\n\n    // For the same price you could project a texture\n    if( outside.x || outside.y ) {\n        gl_FragColor = vec4(color.rgb, color.a*alpha);\n    } else {\n        vec4 texcolor = texture2D(texture, T2);\n        gl_FragColor = mix(texcolor, color, color.a*alpha);\n    }\n} """"""\n\n\nwindow = app.Window(800,800, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nprogram[\'texture\'] = data.get(""earth.jpg"")\nprogram[\'texture\'].interpolation = gl.GL_LINEAR\nprogram[\'major_width\'] = 2.0\nprogram[\'minor_width\'] = 1.0\nprogram[\'major_color\'] = 0, 0, 0, 1\nprogram[\'minor_color\'] = 0, 0, 0, 1\nprogram[\'antialias\'] = 1.0\nprogram[\'viewport\'] = Viewport()\n\n\n# Polar projection\n# ----------------\n\n# # This scales texture coordinates into cartesian coordinates\n# program[\'scale1\'] = Position(\n#     LinearScale(name = \'x\', domain=(0,1), range=(-5.1,5.1), discard=False, clamp=False),\n#     LinearScale(name = \'y\', domain=(0,1), range=(-5.1,5.1), discard=False, clamp=False))\n\n# # Actual projection\n# program[\'projection\'] = PolarProjection()\n# program[\'major_step\'] = 1.00, np.pi/6\n# program[\'minor_step\'] = 0.25, np.pi/60\n\n# # This scales projected coordinates into texture coordinates\n# program[\'scale2\'] = Position(\n#    LinearScale(name = \'x\', domain=(0.0, 5.0),     range=(0,1), discard=False, clamp=False),\n#    LinearScale(name = \'y\', domain=(0.0, 2*np.pi), range=(0,1), discard=False, clamp=False))\n\n\n# Transverse Mercator projection\n# ------------------------------\n# This scales texture coordinates into cartesian coordinates\nprogram[\'scale1\'] = Position(\n    LinearScale(name = \'x\', domain=(0,1), range=(-1.5,1.5),\n                discard=False, clamp=False),\n    LinearScale(name = \'y\', domain=(1,0), range=(-2.3,2.3),\n                discard=False, clamp=False))\n\n# Actual projection\nprogram[\'projection\'] = TransverseMercatorProjection()\n\nprogram[\'major_step\'] = np.array([ 1.00, 0.50]) * np.pi/ 6.0\nprogram[\'minor_step\'] = np.array([ 1.00, 0.50]) * np.pi/30.0\n\n# This scales projected coordinates into texture coordinates\nprogram[\'scale2\'] = Position(\n    LinearScale(name = \'x\', domain=(-np.pi, np.pi), range=(0,1),\n                discard=False, clamp=False),\n    LinearScale(name = \'y\', domain=(-np.pi/2, np.pi/2), range=(0,1),\n                discard=False, clamp=False))\nwindow.set_size(500,800)\n\n\n\n# Azimuthal equidistant\n# ---------------------\n# This scales texture coordinates into cartesian coordinates\n# program[\'scale1\'] = Position(\n#     LinearScale(name = \'x\', domain=(0,1), range=(-3.,3.),\n#                 discard=False, clamp=False),\n#     LinearScale(name = \'y\', domain=(1,0), range=(-3.,3.),\n#                 discard=False, clamp=False))\n\n# # Actual projection\n# # program[\'projection\'] = AzimuthalEqualAreaProjection()\n# program[\'projection\'] = AzimuthalEquidistantProjection()\n# program[\'major_step\'] = np.array([ 1.0, 1.0]) * np.pi/6.0\n# program[\'minor_step\'] = np.array([ 1.0, 1.0]) * np.pi/18.0\n\n# # This scales projected coordinates into texture coordinates\n# program[\'scale2\'] = Position(\n#     LinearScale(name = \'x\', domain=(-np.pi, np.pi), range=(0,1),\n#                 discard=False, clamp=False),\n#     LinearScale(name = \'y\', domain=(-np.pi/2, np.pi/2), range=(0,1),\n#                 discard=False, clamp=False))\n# window.set_size(800,800)\n\n\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    vmin, vmax = program[\'scale2\'][\'y\'][\'domain\']\n    if dy > 0:\n        if vmin > -np.pi/2:\n            vmin -= 0.05\n        else:\n            vmax -= 0.05\n    elif dy < 0:\n        if vmax < np.pi/2:\n            vmax += 0.05\n        else:\n            vmin += 0.05\n\n    vmin = min(max(vmin,-np.pi/2),0)\n    vmax = max(min(vmax,+np.pi/2),0)\n    program[\'scale2\'][\'y\'][\'domain\'] = vmin, vmax\n\nwindow.attach(program[""viewport""])\napp.run()\n'"
examples/collection-glyph.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.graphics.collections import GlyphCollection\nfrom glumpy.transforms import Position, Viewport, Trackball\n\n\njabberwocky = (\n""`Twas brillig, and the slithy toves\\n""\n""  Did gyre and gimble in the wabe:\\n""\n""All mimsy were the borogoves,\\n""\n""  And the mome raths outgrabe.\\n""\n""\\n""\n""\\""Beware the Jabberwock, my son!\\n""\n""  The jaws that bite, the claws that catch!\\n""\n""Beware the Jubjub bird, and shun\\n""\n""  The frumious Bandersnatch!\\""\\n""\n""He took his vorpal sword in hand:\\n""\n""  Long time the manxome foe he sought --\\n""\n""So rested he by the Tumtum tree,\\n""\n""  And stood awhile in thought.\\n""\n""And, as in uffish thought he stood,\\n""\n""  The Jabberwock, with eyes of flame,\\n""\n""Came whiffling through the tulgey wood,\\n""\n""  And burbled as it came!\\n""\n""One, two! One, two! And through and through\\n""\n""  The vorpal blade went snicker-snack!\\n""\n""He left it dead, and with its head\\n""\n""  He went galumphing back.\\n""\n""\\""And, has thou slain the Jabberwock?\\n""\n""  Come to my arms, my beamish boy!\\n""\n""O frabjous day! Callooh! Callay!\'\\n""\n""  He chortled in his joy.\\n""\n""\\n""\n""`Twas brillig, and the slithy toves\\n""\n""  Did gyre and gimble in the wabe;\\n""\n""All mimsy were the borogoves,\\n""\n""  And the mome raths outgrabe.\\n"" )\n\nwindow = app.Window(width=700, height=700, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    glyphs.draw()\n\nglyphs = GlyphCollection(transform=Trackball(Position()))\nglyphs.append(jabberwocky, FontManager.get(""Roboto-Regular.ttf""))\n\nwindow.attach(glyphs[""transform""])\nwindow.attach(glyphs[""viewport""])\n\napp.run()\n'"
examples/collection-markers.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom  glumpy import app\nfrom glumpy.graphics.collections import MarkerCollection\n\n\nwindow = app.Window(1024,1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    markers.draw()\n    markers[\'orientation\'] += np.random.uniform(0.0,0.1,len(markers))\n    del markers[0]\n    if not len(markers):\n        app.quit()\n\nn = 256\nmarkers = MarkerCollection(orientation=\'local\')\nmarkers.append(np.random.uniform(-1,1,(n,3)),\n               bg_color = np.random.uniform(0,1,(n,4)),\n               size = 64, fg_color=(0,0,0,1))\n\n\nwindow.attach(markers[""transform""])\nwindow.attach(markers[""viewport""])\napp.run()\n'"
examples/collection-path.py,8,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, glm, gl\nfrom glumpy.graphics.collections import PathCollection\nfrom glumpy.transforms import Position, Viewport, OrthographicProjection, PanZoom\n\n\nwindow = app.Window(width=800, height=800, color=(1,1,1,1))\n\ndef star(inner=0.5, outer=1.0, n=5):\n    R = np.array( [inner,outer]*n)\n    T = np.linspace(0,2*np.pi,2*n,endpoint=False)\n    P = np.zeros((2*n,3))\n    P[:,0]= R*np.cos(T)\n    P[:,1]= R*np.sin(T)\n    return P\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    paths.draw()\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.reset()\n\ntransform = PanZoom(OrthographicProjection(Position()), aspect=None)\n\nn = 2500\nS = star(n=5)\nP = np.tile(S.ravel(),n).reshape(n,len(S),3)\nP *= np.random.uniform(5,10,n)[:,np.newaxis,np.newaxis]\nP[:,:,:2] += np.random.uniform(0,800,(n,2))[:,np.newaxis,:]\nP = P.reshape(n*len(S),3)\n\npaths = PathCollection(mode=""agg"", transform=transform)\npaths.append(P, closed=True, itemsize=len(S))\npaths[""linewidth""] = 1.0\n\nwindow.attach(paths[""transform""])\nwindow.attach(paths[""viewport""])\napp.run()\n'"
examples/collection-point.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app\nfrom glumpy.graphics.collections import PointCollection\n\nwindow = app.Window(1024,1024, color=(1,1,1,1))\npoints = PointCollection(""agg"", color=""local"", size=""local"")\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    points.draw()\n    if len(points) < 100000:\n        points.append(np.random.normal(0.0,0.5,(1,3)),\n                      color = np.random.uniform(0,1,4),\n                      size  = np.random.uniform(1,24,1))\n\nwindow.attach(points[""transform""])\nwindow.attach(points[""viewport""])\napp.run()\n'"
examples/collection-segment.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, glm\nfrom glumpy.graphics.collections import SegmentCollection\nfrom glumpy.transforms import Position, OrthographicProjection, PanZoom\n\nwindow = app.Window(width=1200, height=600, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    segments.draw()\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.reset()\n\nn = 100\nP0 = np.dstack((np.linspace(100,1100,n),np.ones(n)* 50,np.zeros(n))).reshape(n,3)\nP1 = np.dstack((np.linspace(110,1110,n),np.ones(n)*550,np.zeros(n))).reshape(n,3)\n\ntransform = PanZoom(OrthographicProjection(Position()))\nsegments = SegmentCollection(mode=""agg"", linewidth=\'local\', transform=transform)\nsegments.append(P0, P1, linewidth = np.linspace(1, 8, n))\nsegments[\'antialias\'] = 1\n\nwindow.attach(segments[""transform""])\nwindow.attach(segments[""viewport""])\napp.run()\n'"
examples/collection-triangles.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport triangle\nimport numpy as np\nfrom glumpy import app, gl\nfrom glumpy.graphics.collections import TriangleCollection, PathCollection\nfrom glumpy.transforms import Position, OrthographicProjection, PanZoom\n\n\ndef star(inner=0.5, outer=1.0, n=5):\n    R = np.array( [inner,outer]*n)\n    T = np.linspace(0,2*np.pi,2*n,endpoint=False)\n    P = np.zeros((2*n,3))\n    P[:,0]= R*np.cos(T)\n    P[:,1]= R*np.sin(T)\n    return P\n\nwindow = app.Window(800, 800, color=(1,1,1,1))\n\ndef triangulate(P):\n    n = len(P)\n    S = np.repeat(np.arange(n+1),2)[1:-1]\n    S[-2:] = n-1,0\n    S = S.reshape((-1, 2))\n    T = triangle.triangulate({\'vertices\': P[:,:2], \'segments\': S}, ""p"")\n    return  T[""triangles""].ravel()\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    triangles.draw()\n    paths.draw()\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.reset()\n\n\ntransform = PanZoom(OrthographicProjection(Position()))\ntriangles = TriangleCollection(""agg"", transform=transform, color=\'shared\')\npaths = PathCollection(""agg"", transform=transform, color=\'shared\')\npaths[""linewidth""] = 10\n\nP = star()\nI = triangulate(P)\n\nn = 64\nfor i in range(n):\n    c = i/float(n)\n    d = i\n    x,y = np.random.uniform(0,800,2)\n    s = 25\n    triangles.append(P*s+(x,y,d), I, color=(0,0,0,.5))\n    paths.append(P*s+(x,y,(d-1)), closed=True, color=(0,0,0,1))\n\nwindow.attach(paths[""transform""])\nwindow.attach(paths[""viewport""])\napp.run()\n'"
examples/collection-update.py,11,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom  glumpy import app, collections\n\n\nvertex = """"""\n// Externs\n// ------------------------------------\n// extern vec3  position;\n// extern float id;\n// extern vec4  color;\n// ... user-defined through collection init dtypes\n// -----------------------------------------------\n\nuniform float rows, cols;\nvarying float v_x;\nvarying vec4 v_color;\nvoid main()\n{\n    // This line is mandatory and is responsible for fetching uniforms\n    // from the underlying uniform texture\n    fetch_uniforms();\n\n    // color can end up being an attribute or a varying\n    // If you want to make sure to pass it to the fragment,\n    // It\'s better to define it here explicitly\n    if (selected > 0.0)\n        v_color = vec4(1,1,1,1*id);\n    else\n        v_color = vec4(color.rgb, color.a*id);\n\n    float index = collection_index;\n\n    // Compute row/col from collection_index\n    float col = mod(index,cols) + 0.5;\n    float row = floor(index/cols) + 0.5;\n    float x = -1.0 + col * (2.0/cols);\n    float y = -1.0 + row * (2.0/rows);\n    float width = 0.95 / (1.0*cols);\n    float height = 0.95 / (1.0*rows) * amplitude;\n\n    v_x = xscale*position.x;\n    gl_Position = vec4(x + width*xscale*position.x, y + height*position.y, 0.0, 1.0);\n}\n""""""\n\nfragment = """"""\n// Collection varyings are not propagated to the fragment shader\n// -------------------------------------------------------------\nvarying float v_x;\nvarying vec4 v_color;\nvoid main(void)\n{\n    if( v_x < -0.95) discard;\n    if( v_x > +0.95) discard;\n    gl_FragColor = v_color;\n}\n""""""\n\n\nrows,cols = 16,20\nn, p = rows*cols, 1000\nlines = collections.RawPathCollection(\n    user_dtype = [(""amplitude"", (np.float32, 1), \'shared\', 1),\n                  (""selected"",  (np.float32, 1), \'shared\', 0),\n                  (""xscale"",    (np.float32, 1), \'shared\', 1)],\n    color=""shared"", vertex=vertex, fragment=fragment )\nlines.append(np.random.uniform(-1,1,(n*p,3)), itemsize=p)\n\n\nlines[""rows""] = rows\nlines[""cols""] = cols\nlines[""amplitude""][:n] = np.random.uniform(0.25,0.75,n)\nlines[""color""][:n] = np.random.uniform(0.5,1.0,(n,4))\nlines[""color""][:n,3] = 1.0\nlines[""selected""] = 0.0\nlines[""xscale""][:n] = np.random.uniform(1,25,n)\n\n# Each segment has two extra points for breaking the line strip\npositions = lines[""position""].reshape(rows*cols,p+2,3)\npositions[:,1:-1,0] = np.tile(np.linspace(-1,+1,p),n).reshape(rows*cols,p)\n\n# Here we ensure:\n#   * first point = second point\n#   * last point = prev last point\npositions[:, 0] = positions[:, 1]\npositions[:,-1] = positions[:,-2]\n\nwindow = app.Window(1400,1000)\n@window.event\ndef on_draw(dt):\n    window.clear()\n    lines.draw()\n\n    positions[:,:-10,1] = positions[:,10:,1]\n    positions[:,-10:,1] = np.random.uniform(-1,1, (n,10))\n    # Here we ensure:\n    #   * first point = second point\n    #   * last point = prev last point\n    positions[:, 0] = positions[:, 1]\n    positions[:,-1] = positions[:,-2]\n\n\ndef get_index(x,y):\n    """""" Find the index of the plot under mouse """"""\n    y = window.height-y\n    col = int(x/float(window.width)*cols) % cols\n    row = int(y/float(window.height)*rows) % rows\n    return row*cols + col\n\n@window.event\ndef on_mouse_motion(x,y,dx,dy):\n    index = get_index(x,y)\n    lines[""selected""] = 0\n    lines[""selected""][index] = 1\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    index = get_index(x,y)\n    dx = -np.sign(dy) * .05\n    lines[""xscale""][index] *= np.exp(2.5*dx)\n    lines[""xscale""][index] = min(max(1.0, lines[""xscale""][index]),100)\n\napp.run()\n'"
examples/colormaps.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" This example shows colormap functions (faster than 1d texture lookup) """"""\n\nimport datetime\nfrom glumpy import app, gl, gloo\n\nvertex = """"""\nattribute vec2 position;\nvoid main (void)\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n""""""\n\nfragment = """"""\n#include ""colormaps/colormaps.glsl""\n\nuniform vec3      iResolution; // Viewport resolution (in pixels)\nuniform float     iGlobalTime; // Shader playback time (in seconds)\nuniform vec4      iMouse;      // Mouse pixel coords. xy: current (if MLB down) + zw: click\nuniform vec4      iDate;       // Date as (year, month, day, time in seconds)\n// uniform float     iChannelTime[4];       // Channel playback time (in seconds)\n// uniform vec3      iChannelResolution[4]; // Channel resolution (in pixels)\n// uniform sampler2D iChannel[4];           // Input channel. (XX = 2D or Cube)\n\n\nvoid main(void)\n{\n    const float n = 18.0;\n\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float t = gl_FragCoord.x / iResolution.x;\n\n    // Discretization level\n    // float levels = 32.0;\n    // t = floor(t*levels)/levels;\n\n    // Break up mach bands\n    float i = n * gl_FragCoord.y / iResolution.y;\n\n    if (mod(gl_FragCoord.y+n/4., iResolution.y / n) < max(iResolution.y / 200.0, 1.0))\n    { gl_FragColor.rgb = vec3(0.0); }\n    else if (i > n- 1.0) { gl_FragColor.rgb = colormap_gray(t);         }\n    else if (i > n- 2.0) { gl_FragColor.rgb = colormap_hot(t);          }\n    else if (i > n- 3.0) { gl_FragColor.rgb = colormap_cool(t);         }\n    else if (i > n- 4.0) { gl_FragColor.rgb = colormap_autumn(t);       }\n    else if (i > n- 5.0) { gl_FragColor.rgb = colormap_winter(t);       }\n    else if (i > n- 6.0) { gl_FragColor.rgb = colormap_spring(t);       }\n    else if (i > n- 7.0) { gl_FragColor.rgb = colormap_summer(t);       }\n    else if (i > n- 8.0) { gl_FragColor.rgb = colormap_ice(t);          }\n    else if (i > n- 9.0) { gl_FragColor.rgb = colormap_fire(t);         }\n    else if (i > n-10.0) { gl_FragColor.rgb = colormap_icefire(t);      }\n    else if (i > n-11.0) { gl_FragColor.rgb = colormap_reds(t);         }\n    else if (i > n-12.0) { gl_FragColor.rgb = colormap_greens(t);       }\n    else if (i > n-13.0) { gl_FragColor.rgb = colormap_blues(t);        }\n    else if (i > n-14.0) { gl_FragColor.rgb = colormap_wheel(t);        }\n    else if (i > n-15.0) { gl_FragColor.rgb = colormap_stripes(t);      }\n    else if (i > n-16.0) { gl_FragColor.rgb = colormap_discrete(t);     }\n    else if (i > n-17.0) { gl_FragColor.rgb = colormap_gray(-.05+1.1*t, vec3(1,0,0), vec3(0,0,1)); }\n    else if (i > n-18.0) { gl_FragColor.rgb = colormap_jet(t);          }\n\n\n    gl_FragColor.a = 1.0;\n    // Translate to gamma 2.2 space\n    gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(1.0/2.2));\n}\n""""""\n\n\nwindow = app.Window(width=1800, height=800)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n    program[""iGlobalTime""] += dt\n    today = datetime.datetime.now()\n    seconds = (today.hour*60*60 + today.minute*60 + today.second)\n    program[""iDate""] = today.year, today.month, today.day, seconds\n\n@window.event\ndef on_resize(width, height):\n    program[""iResolution""] = width, height, 0\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    buttons = {app.window.mouse.NONE   : 0, app.window.mouse.LEFT  : 1,\n               app.window.mouse.MIDDLE : 2, app.window.mouse.RIGHT : 3 }\n    program[""iMouse""] = x, y, buttons[button], 0\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nprogram[""iGlobalTime""] = 0\napp.run(framerate=60)\n'"
examples/dynamic-transform.py,9,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, data, library\nfrom glumpy.transforms import *\nfrom glumpy.graphics.collections import *\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.geometry import primitives\n\nvertex = """"""\n#include ""misc/spatial-filters.frag""\n\nuniform float time;\nuniform float height;\nuniform sampler2D data;\nuniform vec2 data_shape;\nattribute vec3 position;\nattribute vec2 texcoord;\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\n\nvec4 trackball(vec4 position) { return <trackball(position)>; }\n\nvoid main()\n{\n    float z = height*Bicubic(data, data_shape, texcoord).r;\n    vec4 position1 = trackball(<transform1(vec3(position.xy,z-0.5))>);\n    vec4 position2 = trackball(<transform2(vec3(position.xy,z-0.5))>);\n\n    gl_Position = mix(position1,position2, (1.0+cos(time))/2.0);\n\n    v_texcoord = texcoord;\n    v_position = vec3(position.xy, z);\n}\n""""""\n\nfragment = """"""\n#include ""misc/spatial-filters.frag""\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 normal;\nuniform sampler2D texture;\nuniform float height;\nuniform vec4 color;\n\nuniform sampler2D data;\nuniform vec2 data_shape;\nuniform vec3 light_color[3];\nuniform vec3 light_position[3];\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\n\nfloat lighting(vec3 v_normal, vec3 light_position)\n{\n    // Calculate normal in world coordinates\n    vec3 n = normalize(normal * vec4(v_normal,1.0)).xyz;\n\n    // Calculate the location of this fragment (pixel) in world coordinates\n    vec3 position = vec3(view * model * vec4(v_position, 1));\n\n    // Calculate the vector from this pixels surface to the light source\n    vec3 surface_to_light = light_position - position;\n\n    // Calculate the cosine of the angle of incidence (brightness)\n    float brightness = dot(n, surface_to_light) /\n                      (length(surface_to_light) * length(n));\n    brightness = max(min(brightness,1.0),0.0);\n    return brightness;\n}\n\nvoid main()\n{\n    mat4 model = <trackball.trackball_model>;\n\n    // Extract data value\n    float value = Bicubic(data, data_shape, v_texcoord).r;\n\n    // Compute surface normal using neighbour values\n    float hx0 = height*Bicubic(data, data_shape, v_texcoord+vec2(+1,0)/data_shape).r;\n    float hx1 = height*Bicubic(data, data_shape, v_texcoord+vec2(-1,0)/data_shape).r;\n    float hy0 = height*Bicubic(data, data_shape, v_texcoord+vec2(0,+1)/data_shape).r;\n    float hy1 = height*Bicubic(data, data_shape, v_texcoord+vec2(0,-1)/data_shape).r;\n    vec3 dx = vec3(2.0/data_shape.x,0.0,hx0-hx1);\n    vec3 dy = vec3(0.0,2.0/data_shape.y,hy0-hy1);\n    vec3 v_normal = normalize(cross(dx,dy));\n\n    // Map value to rgb color\n    float c = 0.6 + 0.4*texture2D(texture, v_texcoord).r;\n    vec4 l1 = vec4(light_color[0] * lighting(v_normal, light_position[0]), 1);\n    vec4 l2 = vec4(light_color[1] * lighting(v_normal, light_position[1]), 1);\n    vec4 l3 = vec4(light_color[2] * lighting(v_normal, light_position[2]), 1);\n\n    gl_FragColor = color * vec4(c,c,c,1) * (0.5 + 0.5*(l1+l2+l3));\n} """"""\n\n\n\nwindow = app.Window(1200, 1200, color = (1,1,1,1))\n\n\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, time\n\n    time += dt\n    window.clear()\n\n    surface[""time""] = time\n\n    surface[\'data\']\n\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    surface[""color""] = 1,1,1,1\n    surface.draw(gl.GL_TRIANGLES, s_indices)\n\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    surface[""color""] = 0,0,0,1\n    surface.draw(gl.GL_LINE_LOOP, b_indices)\n    gl.glDepthMask(gl.GL_TRUE)\n\n    model = surface[\'trackball\'][\'model\'].reshape(4,4)\n    view  = surface[\'trackball\'][\'view\'].reshape(4,4)\n    surface[\'view\']  = view\n    surface[\'model\'] = model\n    surface[\'normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\n    # surface[""height""] = 0.75*np.cos(time/5.0)\n\n\n@window.event\ndef on_init():\n    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n    gl.glPolygonOffset(1, 1)\n    gl.glEnable(gl.GL_LINE_SMOOTH)\n    gl.glLineWidth(2.5)\n\n\nn = 64\nsurface = gloo.Program(vertex, fragment)\nvertices, s_indices = primitives.plane(2.0, n=n)\nsurface.bind(vertices)\n\nI = []\nfor i in range(n): I.append(i)\nfor i in range(1,n): I.append(n-1+i*n)\nfor i in range(n-1): I.append(n*n-1-i)\nfor i in range(n-1): I.append(n*(n-1) - i*n)\nb_indices = np.array(I, dtype=np.uint32).view(gloo.IndexBuffer)\n\n\ndef func3(x,y):\n    return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)\nx = np.linspace(-2.0, 2.0, 64).astype(np.float32)\ny = np.linspace(-2.0, 2.0, 64).astype(np.float32)\nX,Y = np.meshgrid(x, y)\nZ = func3(X,Y)\n\nsurface[\'data\'] = (Z-Z.min())/(Z.max() - Z.min())\nsurface[\'data\'].interpolation = gl.GL_NEAREST\nsurface[\'data_shape\'] = Z.shape[1], Z.shape[0]\nsurface[\'u_kernel\'] = data.get(""spatial-filters.npy"")\nsurface[\'u_kernel\'].interpolation = gl.GL_LINEAR\nsurface[\'texture\'] = data.checkerboard(32,24)\n\nxscale1 = LinearScale("".x"", name=""xscale1"")\nyscale1 = LinearScale("".y"", name=""yscale1"")\nzscale1 = LinearScale("".z"", name=""zscale1"")\nprojection1 = Position(name=""data_projection"")\n\nxscale2 = LinearScale("".x"", name=""xscale2"", domain=[-2.5,2.5], range=[-np.pi,+np.pi])\nyscale2 = LinearScale("".y"", name=""yscale2"", domain=[-2.5,2.5], range=[-np.pi/2,+np.pi/2])\nzscale2 = LinearScale("".z"", name=""zscale2"", domain=[-1,1], range=[-1,1])\nprojection2 = TransverseMercatorProjection(name=""data_projection"", call=""forward"")\n\ntrackball = Trackball(name=""view_projection"", aspect=1)\ntransform1 = projection1(Position(xscale1,yscale1,zscale1))\ntransform2 = projection2(Position(xscale2,yscale2,zscale2))\n\nsurface[\'trackball\'] = trackball\nsurface[\'transform1\'] = transform1\nsurface[\'transform2\'] = transform2\nwindow.attach(trackball)\n\nT = (Z-Z.min())/(Z.max() - Z.min())\n\nsurface[\'height\'] = 0.75\nsurface[""light_position[0]""] = 3, 0, 0+5\nsurface[""light_position[1]""] = 0, 3, 0+5\nsurface[""light_position[2]""] = -3, -3, +5\nsurface[""light_color[0]""]    = 1, 0, 0\nsurface[""light_color[1]""]    = 0, 1, 0\nsurface[""light_color[2]""]    = 0, 0, 1\nphi, theta = -45, 0\ntime = 0\n\ntrackball[""zoom""] = 20\napp.run()\n'"
examples/earth.py,11,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport csv\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo, data\nfrom glumpy.geometry.primitives import sphere\nfrom glumpy.transforms import Arcball, Viewport, Position\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.graphics.collections import GlyphCollection\nfrom glumpy.graphics.collections import PathCollection, MarkerCollection\n\n\ndef spheric_to_cartesian(phi, theta, rho):\n    """""" Spheric to cartesian coordinates """"""\n    \n    if   hasattr(phi, \'__iter__\'):   n = len(phi)\n    elif hasattr(theta, \'__iter__\'): n = len(theta)\n    elif hasattr(rho, \'__iter__\'):   n = len(rho)\n    P = np.empty((n,3), dtype=np.float32)\n    sin_theta = np.sin(theta)\n    P[:,0] = sin_theta * np.sin(phi) * rho\n    P[:,1] = sin_theta * np.cos(phi) * rho\n    P[:,2] =           np.cos(theta) * rho\n    return P\n\n\n\nvertex = """"""\nuniform mat4 model, view, projection;\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    v_texcoord  = texcoord;\n    gl_Position = <transform(position)>;\n}\n""""""\n\nfragment = """"""\nconst vec4 blue  = vec4(0.80,0.80,1.00,1.00);\nconst vec4 white = vec4(1.00,1.00,1.00,1.00);\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    float v = texture2D(texture, v_texcoord).r;\n    gl_FragColor = mix(white,blue,v);\n}\n""""""\n\ntransform = Arcball(Position(),znear=1,zfar=10)\nviewport  = Viewport()\n\nradius = 1.5\nvertices, indices = sphere(radius, 64, 64)\nearth = gloo.Program(vertex, fragment)\nearth.bind(vertices)\nearth[\'texture\'] = data.get(""earth-black.jpg"")\nearth[\'texture\'].interpolation = gl.GL_LINEAR\nearth[\'transform\'] = transform\n\npaths = PathCollection(mode=""agg+"", color=""global"", linewidth=""global"",\n                       viewport=viewport, transform=transform)\npaths[""color""] = 0,0,0,0.5\npaths[""linewidth""] = 1.0\n\ntheta = np.linspace(0, 2*np.pi, 64, endpoint=True)\nfor phi in np.linspace(0, np.pi, 12, endpoint=False):\n    paths.append(spheric_to_cartesian(phi, theta, radius*1.01), closed=True)\n\nphi = np.linspace(0, 2*np.pi, 64, endpoint=True)\nfor theta in np.linspace(0, np.pi, 19, endpoint=True)[1:-1]:\n    paths.append(spheric_to_cartesian(phi, theta, radius*1.01), closed=True)\n\n\n\nvertex = """"""\n#include ""math/constants.glsl""\n\nvarying float v_size;\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvarying vec2  v_orientation;\nvarying float v_antialias;\nvarying float v_linewidth;\nvoid main (void)\n{\n    fetch_uniforms();\n    v_linewidth   = linewidth;\n    v_antialias   = antialias;\n    v_fg_color    = fg_color;\n    v_bg_color    = bg_color;\n    v_orientation = vec2(cos(orientation), sin(orientation));\n\n    gl_Position = <transform(position)>;\n    float scale = (3.5 - length(gl_Position.xyz)/length(vec3(1.5)));\n    v_fg_color.a = scale;\n    v_bg_color.a = scale;\n    scale=1;\n    v_size       = scale * size;\n    gl_PointSize = M_SQRT2 * size * scale + 2.0 * (linewidth + 1.5*antialias);\n    <viewport.transform>;\n}\n""""""\n\nmarkers = MarkerCollection(marker=""disc"", vertex=vertex,\n                           viewport = viewport, transform=transform)\nC, La, Lo = [], [], []\nwith open(data.get(""capitals.csv""), \'r\') as file:\n    reader = csv.reader(file, delimiter=\',\')\n    next(reader, None) # skip the header\n    for row in reader:\n        capital = row[1]\n        latitude = np.pi/2 + float(row[2])*np.pi/180\n        longitude = np.pi  + float(row[3])*np.pi/180\n        C.append(capital)\n        La.append(latitude)\n        Lo.append(longitude)\nP = spheric_to_cartesian(Lo, La, radius*1.01)\nmarkers.append(P, bg_color = (1,1,1,1), fg_color=(.25,.25,.25,1), size = 10)\n\n\n\n\n\nvertex = """"""\nvarying vec4  v_color;\nvarying float v_offset;\nvarying vec2  v_texcoord;\n\n// Main\n// ------------------------------------\nvoid main()\n{\n    fetch_uniforms();\n\n    gl_Position = <transform(origin)>;\n    v_color = color;\n    v_texcoord = texcoord;\n    <viewport.transform>;\n\n    float scale = (3.5 - length(gl_Position.xyz)/length(vec3(1.5)));\n    v_color.a = scale;\n\n    // We set actual position after transform\n    v_offset = 3.0*(offset + origin.x - int(origin.x));\n    gl_Position /= gl_Position.w;\n    gl_Position = gl_Position + vec4(2.0*position/<viewport.viewport_global>.zw,0,0);\n}\n""""""\n\nlabels = GlyphCollection(\'agg\', vertex=vertex,\n                         transform=transform, viewport=viewport)\nfont = FontManager.get(""OpenSans-Regular.ttf"", size=16, mode=\'agg\')\nfor i in range(len(P)):\n    labels.append(C[i], font, origin = P[i])\nlabels[""position""][:,1] -= 20\n    \nwindow = app.Window(width=1024, height=1024, color=(.2,.2,.35,1))\nwindow.attach(transform)\nwindow.attach(viewport)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    earth.draw(gl.GL_TRIANGLES, indices)\n    paths.draw()\n    gl.glDisable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_BLEND)\n    markers.draw()\n    labels.draw()\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    transform.phi = 125\n    transform.theta = -150\n    transform.zoom = 15\n\napp.run()\n'"
examples/filter-blur.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy.geometry import primitives\nfrom glumpy.graphics.filter import Filter\nfrom glumpy import gl, app, glm, gloo, data\n\n\ncube_vertex = """"""\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(position,1.0);\n    v_texcoord = texcoord;\n}\n""""""\n\ncube_fragment = """"""\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    float r = texture2D(texture, v_texcoord).r;\n    gl_FragColor = vec4(vec3(r),1.0);\n}\n""""""\n\n\n\nwindow = app.Window(1024,1024)\n\n# See http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\nVBlur = gloo.Snippet(""""""\nvec4 filter(sampler2D original, sampler2D filtered, vec2 texcoord, vec2 texsize)\n{\n    return 0.2270270270 *  texture2D( filtered, texcoord)\n         + 0.3162162162 * (texture2D( filtered, texcoord + vec2(0.0, 1.3846153846)/texsize) +\n                           texture2D( filtered, texcoord - vec2(0.0, 1.3846153846)/texsize) )\n         + 0.0702702703 * (texture2D( filtered, texcoord + vec2(0.0, 3.2307692308)/texsize) +\n                           texture2D( filtered, texcoord - vec2(0.0, 3.2307692308)/texsize) );\n}"""""")\n\nHBlur = gloo.Snippet(""""""\nvec4 filter(sampler2D original, sampler2D filtered, vec2 texcoord, vec2 texsize)\n{\n    return 0.2270270270 *  texture2D( filtered, texcoord)\n         + 0.3162162162 * (texture2D( filtered, texcoord + vec2(1.3846153846, 0.0)/texsize) +\n                           texture2D( filtered, texcoord - vec2(1.3846153846, 0.0)/texsize) )\n         + 0.0702702703 * (texture2D( filtered, texcoord + vec2(3.2307692308, 0.0)/texsize) +\n                           texture2D( filtered, texcoord - vec2(3.2307692308, 0.0)/texsize) );\n}"""""")\nGaussianBlur = Filter(512, 512, VBlur, HBlur)\n\n\n\n@window.event\ndef on_draw(dt):\n    global phi, theta\n\n    with GaussianBlur:\n        window.clear()\n        gl.glEnable(gl.GL_DEPTH_TEST)\n        cube.draw(gl.GL_TRIANGLES, faces)\n\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'model\'] = model\n\n\n@window.event\ndef on_resize(width, height):\n    gl.glViewport(0, 0, width, height)\n    cube[\'projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n\nvertices, faces = primitives.cube()\ncube = gloo.Program(cube_vertex, cube_fragment)\ncube.bind(vertices)\nview = np.eye(4, dtype=np.float32)\nglm.translate(view, 0, 0, -3)\ncube[\'view\'] = view\ncube[\'model\'] = np.eye(4, dtype=np.float32)\ncube[\'texture\'] = data.checkerboard()\nphi, theta = 0, 0\n\n# Run\napp.run()\n'"
examples/filter-compose.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy.geometry import primitives\nfrom glumpy.graphics.filter import Filter\nfrom glumpy import gl, app, glm, gloo, data\n\n\nvertex = """"""\nuniform mat4 model, view, projection;\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(position,1.0);\n    v_texcoord = texcoord;\n}\n""""""\n\nfragment = """"""\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    float r = texture2D(texture, v_texcoord).r;\n    gl_FragColor = vec4(vec3(r),1.0);\n}\n""""""\n\n\npixelate = gloo.Snippet(\n""""""\nuniform float level;\nvec4 filter(sampler2D original, sampler2D filtered, vec2 texcoord, vec2 texsize)\n{\n    vec2 uv = (texcoord * level);\n    uv = (uv - fract(uv)) / level;\n    return texture2D(filtered, uv);\n} """""")\nsepia = gloo.Snippet(\n""""""\nvec4 filter(vec4 color)\n{\n    return vec4( dot(color.rgb, vec3(.393, .769, .189)),\n                 dot(color.rgb, vec3(.349, .686, .168)),\n                 dot(color.rgb, vec3(.272, .534, .131)),\n                 color.a );\n}\nvec4 filter(sampler2D original, sampler2D filtered, vec2 texcoord, vec2 texsize)\n{\n    return filter( texture2D(filtered, texcoord) );\n}\n """""")\ncompose = Filter(512,512, sepia(pixelate))\ncompose[""level""] = 128.0\n\n\nwindow = app.Window(1024,1024)\n\n@window.event\ndef on_draw(dt):\n    global phi, theta\n\n    with compose:\n        window.clear()\n        gl.glEnable(gl.GL_DEPTH_TEST)\n        cube.draw(gl.GL_TRIANGLES, faces)\n    theta += 0.5\n    phi += 0.5\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'model\'] = model\n\n\n@window.event\ndef on_resize(width, height):\n    gl.glViewport(0, 0, width, height)\n    cube[\'projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n    pixelate.viewport = 0, 0, width, height\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    p = compose[""level""]\n    compose[""level""] = min(max(8, p + .01 * dy * p), 512)\n\n\n# Build cube data\nvertices, faces = primitives.cube()\ncube = gloo.Program(vertex, fragment)\ncube.bind(vertices)\nview = np.eye(4, dtype=np.float32)\nglm.translate(view, 0, 0, -3)\ncube[\'view\'] = view\ncube[\'model\'] = np.eye(4, dtype=np.float32)\ncube[\'texture\'] = data.checkerboard()\nphi, theta = 0, 0\napp.run()\n'"
examples/filter-pixelate.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy.geometry import primitives\nfrom glumpy.graphics.filter import Filter\nfrom glumpy import gl, app, glm, gloo, data\n\n\ncube_vertex = """"""\nuniform mat4 model, view, projection;\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(position,1.0);\n    v_texcoord = texcoord;\n}\n""""""\n\ncube_fragment = """"""\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    float r = texture2D(texture, v_texcoord).r;\n    gl_FragColor = vec4(vec3(r),1.0);\n}\n""""""\n\n\npixelate = Filter(512, 512, """"""\nuniform float level;\nvec4 filter(sampler2D original, sampler2D filtered, vec2 texcoord, vec2 texsize)\n{\n    vec2 uv = (texcoord * level);\n    uv = (uv - fract(uv)) / level;\n    return texture2D(filtered, uv);\n} """""")\npixelate[""level""] = 256.0\n\n\nwindow = app.Window(1024,1024)\n\n@window.event\ndef on_draw(dt):\n    global phi, theta\n\n    with pixelate:\n        window.clear()\n        gl.glEnable(gl.GL_DEPTH_TEST)\n        cube.draw(gl.GL_TRIANGLES, faces)\n    theta += 0.5\n    phi += 0.5\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'model\'] = model\n\n\n@window.event\ndef on_resize(width, height):\n    cube[\'projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n    pixelate.viewport = 0, 0, width, height\n\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    p = pixelate[""level""]\n    pixelate[""level""] = min(max(8, p + .01 * dy * p), 512)\n\n\n# Build cube data\nvertices, faces = primitives.cube()\ncube = gloo.Program(cube_vertex, cube_fragment)\ncube.bind(vertices)\nview = np.eye(4, dtype=np.float32)\nglm.translate(view, 0, 0, -3)\ncube[\'view\'] = view\ncube[\'model\'] = np.eye(4, dtype=np.float32)\ncube[\'texture\'] = data.checkerboard()\nphi, theta = 0, 0\napp.run()\n'"
examples/fireworks.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nExample demonstrating simulation of fireworks using point sprites.\n(adapted from the ""OpenGL ES 2.0 Programming Guide"")\n""""""\nimport numpy as np\nfrom glumpy import app, gl, gloo\n\nvertex = """"""\n#version 120\nuniform float time;\nuniform vec2 center;\nattribute vec2 start, end;\nattribute float lifetime;\nvarying float v_lifetime;\nvoid main () {\n    gl_Position = vec4(start + (time * end) + center, 0.0, 1.0);\n    gl_Position.y -= 1.0 * time * time;\n    v_lifetime = clamp(1.0 - (time / lifetime), 0.0, 1.0);\n    gl_PointSize = (v_lifetime * v_lifetime) * 30.0;\n}\n""""""\n\nfragment = """"""\n#version 120\nconst float SQRT_2 = 1.4142135623730951;\nuniform vec4 color;\nvarying float v_lifetime;\nvoid main()\n{\n    gl_FragColor = color * (SQRT_2/2.0 - length(gl_PointCoord.xy - 0.5));\n    gl_FragColor.a *= v_lifetime;\n}\n""""""\n\nn = 2500\nwindow = app.Window(512,512)\nprogram = gloo.Program(vertex, fragment, count=n)\n\ndef explosion():\n    program[\'center\'] = np.random.uniform(-0.5,+0.5)\n    program[\'color\'] = np.random.uniform(0.1,0.9,4)\n    program[\'color\'][3] = 1.0 / n ** 0.05\n    program[\'lifetime\'] = np.random.normal(4.0, 0.5, n)\n    program[\'start\'] = np.random.normal(0.0, 0.2, (n,2))\n    program[\'end\'] = np.random.normal(0.0, 1.2, (n,2))\n    program[\'time\'] = 0\n\n@window.event\ndef on_init():\n    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_POINTS)\n    program[\'time\'] += dt\n    if program[\'time\'] > 1.75:\n        explosion()\n\nexplosion()\napp.run(framerate=60)\n'"
examples/float-texture.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# This example is used to check if float texture are working (depending on GPU):\n# Only one color on screen: texture float are not working\n# Several colors on screen: texture float are working\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\n    uniform sampler2D texture;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        float r = 256*texture2D(texture, v_texcoord).r;\n        gl_FragColor = vec4(r,r,r,1);\n    }\n""""""\n\nwindow = app.Window(width=2*512, height=2*512)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nprogram[\'texcoord\'] = [( 0, 1), ( 0, 0), ( 1, 1), ( 1, 0)]\nT = np.linspace(0/256.0, 1/256.0, 32*32)\nprogram[\'texture\'] = T.astype(np.float32).reshape(32,32).view(gloo.TextureFloat2D)\n\napp.run()\n'"
examples/font-agg.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app\nfrom glumpy.log import log\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.graphics.collections import GlyphCollection\nfrom glumpy.transforms import Position, OrthographicProjection, Viewport\n\nwindow = app.Window(width=1200, height=800, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    labels.draw()\n\n\nlabels = GlyphCollection(\'agg\', transform=OrthographicProjection(Position()))\ntext = ""The quick brown fox jumps over the lazy dog""\nx,y,z = 2,window.height,0\n\nlog.info(""Caching texture fonts"")\nfor i in range(6,54,2):\n    font = FontManager.get(""OpenSans-Regular.ttf"", size=i, mode=\'agg\')\n    y -= i*1.1\n    labels.append(text, font, origin = (x,y,z), anchor_x=""left"")\n\nwindow.attach(labels[""transform""])\nwindow.attach(labels[""viewport""])\napp.run()\n'"
examples/font-atlas.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy.log import log\nfrom glumpy import app, gl, gloo\nfrom glumpy.graphics.text import FontManager\n\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\n    uniform sampler2D texture;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_FragColor = texture2D(texture, v_texcoord);\n    }\n""""""\n\nwindow = app.Window(width=1024, height=1024)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nprogram[\'texcoord\'] = [( 0, 1), ( 0, 0), ( 1, 1), ( 1, 0)]\nlog.info(""Caching texture fonts"")\n\nmanager = FontManager()\n\nfor size in range(8,25):\n    font = manager.get(""OpenSans-Regular.ttf"", size=size, mode=\'agg\')\n    font.load("""""" !\\""#$%&\'()*+,-./0123456789:;<=>?""""""\n              """"""@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_""""""\n              """"""`abcdefghijklmnopqrstuvwxyz{|}~"""""")\n\nprogram[\'texture\'] = manager.atlas_agg\napp.run()\n'"
examples/font-sdf.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.graphics.collections import GlyphCollection\nfrom glumpy.transforms import Position, OrthographicProjection, Viewport\n\nwindow = app.Window(width=1200, height=800, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    labels.draw()\n\n\nlabels = GlyphCollection(transform=OrthographicProjection(Position()))\nregular = FontManager.get(""OpenSans-Regular.ttf"")\ntext = ""The quick brown fox jumps over the lazy dog""\nx,y,z = 2,window.height,0\n\nfor i in range(6,54,2):\n    scale = i/48.0\n    y -= i*1.1\n    labels.append(text, regular, origin = (x,y,z), scale=scale, anchor_x=""left"")\n\n\nwindow.attach(labels[""transform""])\nwindow.attach(labels[""viewport""])\napp.run()\n'"
examples/galaxy.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom galaxy_specrend import *\nfrom galaxy_simulation import Galaxy\nfrom glumpy import app, gloo, gl, glm, data\n\n\nvertex = """"""\n#version 120\nuniform mat4  u_model;\nuniform mat4  u_view;\nuniform mat4  u_projection;\nuniform sampler1D u_colormap;\n\nattribute float a_size;\nattribute float a_type;\nattribute vec2  a_position;\nattribute float a_temperature;\nattribute float a_brightness;\n\nvarying vec3 v_color;\nvoid main (void)\n{\n    gl_Position = u_projection * u_view * u_model * vec4(a_position,0.0,1.0);\n    if (a_size > 2.0)\n    {\n        gl_PointSize = a_size;\n    } else {\n        gl_PointSize = 0.0;\n    }\n    v_color = texture1D(u_colormap, a_temperature).rgb * a_brightness;\n    if (a_type == 2)\n        v_color *= vec3(2,1,1);\n    else if (a_type == 3)\n        v_color = vec3(.9);\n}\n""""""\n\nfragment = """"""\n#version 120\nuniform sampler2D u_texture;\nvarying vec3 v_color;\nvoid main()\n{\n    gl_FragColor = vec4(texture2D(u_texture, gl_PointCoord).r*v_color, 1.0);\n}\n""""""\n\nwindow = app.Window(width=800, height=800)\n\n@window.event\ndef on_init():\n    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    galaxy.update(100000) # in years !\n    program[\'a_size\'] = galaxy[\'size\'] * max(window.width/800.0, window.height/800.0)\n    program[\'a_position\'] = galaxy[\'position\'] / 13000.0\n    program.draw(gl.GL_POINTS)\n\n@window.event\ndef on_resize(width,height):\n    gl.glViewport(0, 0, width, height)\n    projection = glm.perspective(45.0, width/float(height), 1.0, 1000.0)\n    program[\'u_projection\'] = projection\n\ngalaxy = Galaxy(35000)\ngalaxy.reset(13000, 4000, 0.0004, 0.90, 0.90, 0.5, 200, 300)\nt0, t1 = 1000.0, 10000.0\nn = 256\ndt =  (t1-t0)/n\ncolors = np.zeros((n,3), dtype=np.float32)\nfor i in range(n):\n    temperature = t0 + i*dt\n    x,y,z = spectrum_to_xyz(bb_spectrum, temperature)\n    r,g,b = xyz_to_rgb(SMPTEsystem, x, y, z)\n    r = min((max(r,0),1))\n    g = min((max(g,0),1))\n    b = min((max(b,0),1))\n    colors[i] = norm_rgb(r, g, b)\n\n\nprogram = gloo.Program(vertex, fragment, count=len(galaxy))\n\nview = np.eye(4, dtype=np.float32)\nmodel = np.eye(4, dtype=np.float32)\nprojection = np.eye(4, dtype=np.float32)\nglm.translate(view, 0, 0, -5)\nprogram[\'u_model\'] = model\nprogram[\'u_view\'] = view\nprogram[\'u_colormap\'] = colors\nprogram[\'u_texture\'] = data.get(""particle.png"")\nprogram[\'u_texture\'].interpolation = gl.GL_LINEAR\n\nprogram[\'a_temperature\'] = (galaxy[\'temperature\'] - t0) / (t1-t0)\nprogram[\'a_brightness\'] = galaxy[\'brightness\']\nprogram[\'a_size\'] = galaxy[\'size\']\nprogram[\'a_type\'] = galaxy[\'type\']\n\ngl.glClearColor(0.0, 0.0, 0.03, 1.0)\ngl.glDisable(gl.GL_DEPTH_TEST)\ngl.glEnable(gl.GL_BLEND)\ngl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)\n\napp.run(framerate=60)\n'"
examples/galaxy_simulation.py,32,"b'# -----------------------------------------------------------------------------\n#  A Galaxy Simulator based on the density wave theory\n#  (c) 2012 Ingo Berg\n#\n#  Simulating a Galaxy with the density wave theory\n#  http://beltoforion.de/galaxy/galaxy_en.html\n#\n#  Python version(c) 2014 Nicolas P.Rougier\n# -----------------------------------------------------------------------------\nimport math\nimport numpy as np\n\nclass Galaxy(object):\n    """""" Galaxy simulation using the density wave theory """"""\n\n    def __init__(self, n=30000):\n        """""" Initialize galaxy """"""\n\n        # Excentricity of the innermost ellipse\n        self._inner_excentricity = 0.8\n\n        # Excentricity of the outermost ellipse\n        self._outer_excentricity = 1.0\n\n        #  Velovity at the innermost core in km/s\n        self._center_velocity = 30\n\n        # Velocity at the core edge in km/s\n        self._inner_velocity = 200\n\n        # Velocity at the edge of the disk in km/s\n        self._outer_velocity = 300\n\n        # Angular offset per parsec\n        self._angular_offset = 0.019\n\n        # Inner core radius\n        self._core_radius = 6000\n\n        # Galaxy radius\n        self._galaxy_radius = 15000\n\n        # The radius after which all density waves must have circular shape\n        self._distant_radius = 0\n\n        # Distribution of stars\n        self._star_distribution = 0.45\n\n        # Angular velocity of the density waves\n        self._angular_velocity = 0.000001\n\n        # Number of stars\n        self._stars_count = n\n\n        # Number of dust particles\n        self._dust_count = int(self._stars_count * 0.75)\n\n        # Number of H-II regions\n        self._h2_count = 200\n\n        # Particles\n        dtype = [ (\'theta\',       np.float32, 1),\n                  (\'velocity\',    np.float32, 1),\n                  (\'angle\',       np.float32, 1),\n                  (\'m_a\',         np.float32, 1),\n                  (\'m_b\',         np.float32, 1),\n                  (\'size\',        np.float32, 1),\n                  (\'type\',        np.float32, 1),\n                  (\'temperature\', np.float32, 1),\n                  (\'brightness\',  np.float32, 1),\n                  (\'position\',    np.float32, 2) ]\n        n = self._stars_count + self._dust_count + 2*self._h2_count\n        self._particles = np.zeros(n, dtype=dtype)\n\n        i0 = 0\n        i1 = i0  + self._stars_count\n        self._stars = self._particles[i0:i1]\n        self._stars[\'size\'] = 3.\n        self._stars[\'type\'] = 0\n\n        i0 = i1\n        i1 = i0  + self._dust_count\n        self._dust = self._particles[i0:i1]\n        self._dust[\'size\'] = 64\n        self._dust[\'type\'] = 1\n\n        i0 = i1\n        i1 = i0 + self._h2_count\n        self._h2a = self._particles[i0:i1]\n        self._h2a[\'size\'] = 0\n        self._h2a[\'type\'] = 2\n\n        i0 = i1\n        i1 = i0 + self._h2_count\n        self._h2b = self._particles[i0:i1]\n        self._h2b[\'size\'] = 0\n        self._h2b[\'type\'] = 3\n\n\n    def __len__(self):\n        """""" Number of particles """"""\n\n        if self._particles is not None:\n            return len(self._particles)\n        return 0\n\n\n    def __getitem__(self, key):\n        """""" x.__getitem__(y) <==> x[y] """"""\n\n        if self._particles is not None:\n            return self._particles[key]\n        return None\n\n\n    def reset(self, rad, radCore, deltaAng,\n                    ex1, ex2, sigma, velInner, velOuter):\n\n        # Initialize parameters\n        # ---------------------\n        self._inner_excentricity = ex1\n        self._outer_excentricity = ex2\n        self._inner_velocity = velInner\n        self._outer_velocity = velOuter\n        self._angular_offset = deltaAng\n        self._core_radius = radCore\n        self._galaxy_radius = rad\n        self._distant_radius = self._galaxy_radius * 2\n        self.m_sigma = sigma\n\n        # Initialize stars\n        # ----------------\n        stars = self._stars\n        R = np.random.normal(0, sigma, len(stars)) * self._galaxy_radius\n        stars[\'m_a\']        = R\n        stars[\'angle\']      = 90 - R * self._angular_offset\n        stars[\'theta\']      = np.random.uniform(0, 360, len(stars))\n        stars[\'temperature\']= np.random.uniform(3000, 9000, len(stars))\n        stars[\'brightness\'] = np.random.uniform(0.05, 0.25, len(stars))\n        stars[\'velocity\']   = 0.000005\n        for i in range(len(stars)):\n            stars[\'m_b\'][i] = R[i]* self.excentricity(R[i])\n\n        # Initialize dust\n        # ---------------\n        dust = self._dust\n        X = np.random.uniform(0, 2*self._galaxy_radius, len(dust))\n        Y = np.random.uniform(-self._galaxy_radius, self._galaxy_radius, len(dust))\n        R = np.sqrt(X*X+Y*Y)\n        dust[\'m_a\']         = R\n        dust[\'angle\']       = R * self._angular_offset\n        dust[\'theta\']       = np.random.uniform(0, 360, len(dust))\n        dust[\'velocity\']    = 0.000005\n        dust[\'temperature\'] = 6000 + R/4\n        dust[\'brightness\']  = np.random.uniform(0.01,0.02)\n        for i in range(len(dust)):\n            dust[\'m_b\'][i] = R[i] * self.excentricity(R[i])\n\n        # Initialise H-II\n        # ---------------\n        h2a, h2b = self._h2a, self._h2b\n        X = np.random.uniform(-self._galaxy_radius, self._galaxy_radius, len(h2a))\n        Y = np.random.uniform(-self._galaxy_radius, self._galaxy_radius, len(h2a))\n        R = np.sqrt(X*X+Y*Y)\n\n        h2a[\'m_a\']        = R\n        h2b[\'m_a\']        = R + 1000\n\n        h2a[\'angle\']      = R * self._angular_offset\n        h2b[\'angle\']      = h2a[\'angle\']\n\n        h2a[\'theta\']      = np.random.uniform(0, 360, len(h2a))\n        h2b[\'theta\']      = h2a[\'theta\']\n\n        h2a[\'velocity\']   = 0.000005\n        h2b[\'velocity\']   = 0.000005\n\n        h2a[\'temperature\'] = np.random.uniform(3000,9000,len(h2a))\n        h2b[\'temperature\'] = h2a[\'temperature\']\n\n        h2a[\'brightness\']  = np.random.uniform(0.005,0.010, len(h2a))\n        h2b[\'brightness\']  = h2a[\'brightness\']\n\n        for i in range(len(h2a)):\n            h2a[\'m_b\'][i] = R[i] * self.excentricity(R[i])\n        h2b[\'m_b\'] = h2a[\'m_b\']\n\n\n    def update(self, timestep=100000):\n        """""" Update simulation """"""\n\n        self._particles[\'theta\'] += self._particles[\'velocity\'] * timestep\n\n        P = self._particles\n        a,b = P[\'m_a\'], P[\'m_b\']\n        theta, beta = P[\'theta\'], -P[\'angle\']\n\n        alpha = theta * math.pi / 180.0\n        cos_alpha = np.cos(alpha)\n        sin_alpha = np.sin(alpha)\n        cos_beta  = np.cos(beta)\n        sin_beta  = np.sin(beta)\n        P[\'position\'][:,0] = a*cos_alpha*cos_beta - b*sin_alpha*sin_beta\n        P[\'position\'][:,1] = a*cos_alpha*sin_beta + b*sin_alpha*cos_beta\n\n        D = np.sqrt(((self._h2a[\'position\'] - self._h2b[\'position\'])**2).sum(axis=1))\n        S = np.maximum(1,((1000-D)/10) - 50)\n        self._h2a[\'size\'] = 2.0*S\n        self._h2b[\'size\'] = S/6.0\n\n\n    def excentricity(self, r):\n\n        # Core region of the galaxy. Innermost part is round\n        # excentricity increasing linear to the border of the core.\n        if  r < self._core_radius:\n            return 1 + (r / self._core_radius) * (self._inner_excentricity-1)\n\n        elif r > self._core_radius and r <= self._galaxy_radius:\n            a = self._galaxy_radius - self._core_radius\n            b = self._outer_excentricity - self._inner_excentricity\n            return self._inner_excentricity + (r - self._core_radius) / a * b\n\n        # Excentricity is slowly reduced to 1.\n        elif r > self._galaxy_radius and r < self._distant_radius:\n            a = self._distant_radius - self._galaxy_radius\n            b = 1 - self._outer_excentricity\n            return self._outer_excentricity + (r - self._galaxy_radius) / a * b\n\n        else:\n            return 1\n'"
examples/galaxy_specrend.py,0,"b'""""""\n                Colour Rendering of Spectra\n\n                       by John Walker\n                  http://www.fourmilab.ch/\n\n         Last updated: March 9, 2003\n\n    Converted to Python by Andrew Hutchins, sometime in early\n    2011.\n\n           This program is in the public domain.\n           The modifications are also public domain. (AH)\n\n    For complete information about the techniques employed in\n    this program, see the World-Wide Web document:\n\n             http://www.fourmilab.ch/documents/specrend/\n\n    The xyz_to_rgb() function, which was wrong in the original\n    version of this program, was corrected by:\n\n        Andrew J. S. Hamilton 21 May 1999\n        Andrew.Hamilton@Colorado.EDU\n        http://casa.colorado.edu/~ajsh/\n\n    who also added the gamma correction facilities and\n    modified constrain_rgb() to work by desaturating the\n    colour by adding white.\n\n    A program which uses these functions to plot CIE\n    ""tongue"" diagrams called ""ppmcie"" is included in\n    the Netpbm graphics toolkit:\n        http://netpbm.sourceforge.net/\n    (The program was called cietoppm in earlier\n    versions of Netpbm.)\n\n""""""\nimport math\n\n""""""\n/* A colour system is defined by the CIE x and y coordinates of\n   its three primary illuminants and the x and y coordinates of\n   the white point. */\n""""""\nGAMMA_REC709 = 0\n\nNTSCsystem  =  {""name"": ""NTSC"",\n    ""xRed"": 0.67, ""yRed"": 0.33,\n    ""xGreen"": 0.21, ""yGreen"": 0.71,\n    ""xBlue"": 0.14, ""yBlue"": 0.08,\n    ""xWhite"": 0.3101, ""yWhite"": 0.3163, ""gamma"": GAMMA_REC709}\nEBUsystem  =  {""name"": ""SUBU (PAL/SECAM)"",\n    ""xRed"": 0.64, ""yRed"": 0.33,\n    ""xGreen"": 0.29, ""yGreen"": 0.60,\n    ""xBlue"": 0.15, ""yBlue"": 0.06,\n    ""xWhite"": 0.3127, ""yWhite"": 0.3291, ""gamma"": GAMMA_REC709 }\nSMPTEsystem  =  {""name"": ""SMPTE"",\n    ""xRed"": 0.63, ""yRed"": 0.34,\n    ""xGreen"": 0.31, ""yGreen"": 0.595,\n    ""xBlue"": 0.155, ""yBlue"": 0.07,\n    ""xWhite"": 0.3127, ""yWhite"": 0.3291, ""gamma"": GAMMA_REC709 }\nHDTVsystem  =  {""name"": ""HDTV"",\n    ""xRed"": 0.67, ""yRed"": 0.33,\n    ""xGreen"": 0.21, ""yGreen"": 0.71,\n    ""xBlue"": 0.15, ""yBlue"": 0.06,\n    ""xWhite"": 0.3127, ""yWhite"": 0.3291, ""gamma"": GAMMA_REC709 }\nCIEsystem  =  {""name"": ""CIE"",\n    ""xRed"": 0.7355, ""yRed"": 0.2645,\n    ""xGreen"": 0.2658, ""yGreen"": 0.7243,\n    ""xBlue"": 0.1669, ""yBlue"": 0.0085,\n    ""xWhite"": 0.3333333333, ""yWhite"": 0.3333333333, ""gamma"": GAMMA_REC709 }\nRec709system  =  {""name"": ""CIE REC709"",\n    ""xRed"": 0.64, ""yRed"": 0.33,\n    ""xGreen"": 0.30, ""yGreen"": 0.60,\n    ""xBlue"": 0.15, ""yBlue"": 0.06,\n    ""xWhite"": 0.3127, ""yWhite"": 0.3291, ""gamma"": GAMMA_REC709 }\n\ndef upvp_to_xy(up, vp):\n    xc = (9 * up) / ((6 * up) - (16 * vp) + 12)\n    yc = (4 * vp) / ((6 * up) - (16 * vp) + 12)\n    return(xc, yc)\n\ndef xy_toupvp(xc, yc):\n    up = (4 * xc) / ((-2 * xc) + (12 * yc) + 3);\n    vp = (9 * yc) / ((-2 * xc) + (12 * yc) + 3);\n    return(up, vp)\n\ndef xyz_to_rgb(cs, xc, yc, zc):\n    """"""\n    Given an additive tricolour system CS, defined by the CIE x\n    and y chromaticities of its three primaries (z is derived\n    trivially as 1-(x+y)), and a desired chromaticity (XC, YC,\n    ZC) in CIE space, determine the contribution of each\n    primary in a linear combination which sums to the desired\n    chromaticity.  If the  requested chromaticity falls outside\n    the Maxwell  triangle (colour gamut) formed by the three\n    primaries, one of the r, g, or b weights will be negative.\n\n    Caller can use constrain_rgb() to desaturate an\n    outside-gamut colour to the closest representation within\n    the available gamut and/or norm_rgb to normalise the RGB\n    components so the largest nonzero component has value 1.\n    """"""\n\n    xr = cs[""xRed""]\n    yr = cs[""yRed""]\n    zr = 1 - (xr + yr)\n    xg = cs[""xGreen""]\n    yg = cs[""yGreen""]\n    zg = 1 - (xg + yg)\n    xb = cs[""xBlue""]\n    yb = cs[""yBlue""]\n    zb = 1 - (xb + yb)\n    xw = cs[""xWhite""]\n    yw = cs[""yWhite""]\n    zw = 1 - (xw + yw)\n\n    rx = (yg * zb) - (yb * zg)\n    ry = (xb * zg) - (xg * zb)\n    rz = (xg * yb) - (xb * yg)\n    gx = (yb * zr) - (yr * zb)\n    gy = (xr * zb) - (xb * zr)\n    gz = (xb * yr) - (xr * yb)\n    bx = (yr * zg) - (yg * zr)\n    by = (xg * zr) - (xr * zg)\n    bz = (xr * yg) - (xg * yr)\n\n    rw = ((rx * xw) + (ry * yw) + (rz * zw)) / yw\n    gw = ((gx * xw) + (gy * yw) + (gz * zw)) / yw\n    bw = ((bx * xw) + (by * yw) + (bz * zw)) / yw\n\n    rx = rx / rw;  ry = ry / rw;  rz = rz / rw\n    gx = gx / gw;  gy = gy / gw;  gz = gz / gw\n    bx = bx / bw;  by = by / bw;  bz = bz / bw\n\n    r = (rx * xc) + (ry * yc) + (rz * zc)\n    g = (gx * xc) + (gy * yc) + (gz * zc)\n    b = (bx * xc) + (by * yc) + (bz * zc)\n    return(r,g,b)\n\n\ndef inside_gamut(r, g, b):\n    """"""\n     Test whether a requested colour is within the gamut\n     achievable with the primaries of the current colour\n     system.  This amounts simply to testing whether all the\n     primary weights are non-negative. */\n    """"""\n    return (r >= 0) and (g >= 0) and (b >= 0)\n\n\ndef constrain_rgb(r, g, b):\n    """"""\n    If the requested RGB shade contains a negative weight for\n    one of the primaries, it lies outside the colour gamut\n    accessible from the given triple of primaries.  Desaturate\n    it by adding white, equal quantities of R, G, and B, enough\n    to make RGB all positive.  The function returns 1 if the\n    components were modified, zero otherwise.\n    """"""\n    # Amount of white needed is w = - min(0, *r, *g, *b)\n    w = -min([0, r, g, b]) # I think?\n\n    # Add just enough white to make r, g, b all positive.\n    if w > 0:\n        r += w\n        g += w\n        b += w\n    return(r,g,b)\n\ndef gamma_correct(cs, c):\n    """"""\n    Transform linear RGB values to nonlinear RGB values. Rec.\n    709 is ITU-R Recommendation BT. 709 (1990) ``Basic\n    Parameter Values for the HDTV Standard for the Studio and\n    for International Programme Exchange\'\', formerly CCIR Rec.\n    709. For details see\n\n       http://www.poynton.com/ColorFAQ.html\n       http://www.poynton.com/GammaFAQ.html\n    """"""\n    gamma = cs.gamma\n\n    if gamma == GAMMA_REC709:\n        cc = 0.018\n        if c < cc:\n            c = ((1.099 * math.pow(cc, 0.45)) - 0.099) / cc\n        else:\n            c = (1.099 * math.pow(c, 0.45)) - 0.099\n    else:\n        c = math.pow(c, 1.0 / gamma)\n    return(c)\n\ndef gamma_correct_rgb(cs, r, g, b):\n    r = gamma_correct(cs, r)\n    g = gamma_correct(cs, g)\n    b = gamma_correct(cs, b)\n    return(r,g,b)\n\ndef norm_rgb(r, g, b):\n    """"""\n    Normalise RGB components so the most intense (unless all\n    are zero) has a value of 1.\n    """"""\n    greatest = max([r, g, b])\n\n    if greatest > 0:\n        r /= greatest\n        g /= greatest\n        b /= greatest\n    return(r, g, b)\n\ndef spectrum_to_xyz(spec_intens, temp): #spec_intens is a function\n    """"""\n    Calculate the CIE X, Y, and Z coordinates corresponding to\n    a light source with spectral distribution given by  the\n    function SPEC_INTENS, which is called with a series of\n    wavelengths between 380 and 780 nm (the argument is\n    expressed in meters), which returns emittance at  that\n    wavelength in arbitrary units.  The chromaticity\n    coordinates of the spectrum are returned in the x, y, and z\n    arguments which respect the identity:\n\n            x + y + z = 1.\n\n    CIE colour matching functions xBar, yBar, and zBar for\n       wavelengths from 380 through 780 nanometers, every 5\n       nanometers.  For a wavelength lambda in this range:\n\n            cie_colour_match[(lambda - 380) / 5][0] = xBar\n            cie_colour_match[(lambda - 380) / 5][1] = yBar\n            cie_colour_match[(lambda - 380) / 5][2] = zBar\n\n    AH Note 2011: This next bit is kind of irrelevant on modern\n    hardware. Unless you are desperate for speed.\n    In which case don\'t use the Python version!\n\n    To save memory, this table can be declared as floats\n    rather than doubles; (IEEE) float has enough\n    significant bits to represent the values. It\'s declared\n    as a double here to avoid warnings about ""conversion\n    between floating-point types"" from certain persnickety\n    compilers. */\n    """"""\n\n    cie_colour_match = [\n        [0.0014,0.0000,0.0065], [0.0022,0.0001,0.0105], [0.0042,0.0001,0.0201],\n        [0.0076,0.0002,0.0362], [0.0143,0.0004,0.0679], [0.0232,0.0006,0.1102],\n        [0.0435,0.0012,0.2074], [0.0776,0.0022,0.3713], [0.1344,0.0040,0.6456],\n        [0.2148,0.0073,1.0391], [0.2839,0.0116,1.3856], [0.3285,0.0168,1.6230],\n        [0.3483,0.0230,1.7471], [0.3481,0.0298,1.7826], [0.3362,0.0380,1.7721],\n        [0.3187,0.0480,1.7441], [0.2908,0.0600,1.6692], [0.2511,0.0739,1.5281],\n        [0.1954,0.0910,1.2876], [0.1421,0.1126,1.0419], [0.0956,0.1390,0.8130],\n        [0.0580,0.1693,0.6162], [0.0320,0.2080,0.4652], [0.0147,0.2586,0.3533],\n        [0.0049,0.3230,0.2720], [0.0024,0.4073,0.2123], [0.0093,0.5030,0.1582],\n        [0.0291,0.6082,0.1117], [0.0633,0.7100,0.0782], [0.1096,0.7932,0.0573],\n        [0.1655,0.8620,0.0422], [0.2257,0.9149,0.0298], [0.2904,0.9540,0.0203],\n        [0.3597,0.9803,0.0134], [0.4334,0.9950,0.0087], [0.5121,1.0000,0.0057],\n        [0.5945,0.9950,0.0039], [0.6784,0.9786,0.0027], [0.7621,0.9520,0.0021],\n        [0.8425,0.9154,0.0018], [0.9163,0.8700,0.0017], [0.9786,0.8163,0.0014],\n        [1.0263,0.7570,0.0011], [1.0567,0.6949,0.0010], [1.0622,0.6310,0.0008],\n        [1.0456,0.5668,0.0006], [1.0026,0.5030,0.0003], [0.9384,0.4412,0.0002],\n        [0.8544,0.3810,0.0002], [0.7514,0.3210,0.0001], [0.6424,0.2650,0.0000],\n        [0.5419,0.2170,0.0000], [0.4479,0.1750,0.0000], [0.3608,0.1382,0.0000],\n        [0.2835,0.1070,0.0000], [0.2187,0.0816,0.0000], [0.1649,0.0610,0.0000],\n        [0.1212,0.0446,0.0000], [0.0874,0.0320,0.0000], [0.0636,0.0232,0.0000],\n        [0.0468,0.0170,0.0000], [0.0329,0.0119,0.0000], [0.0227,0.0082,0.0000],\n        [0.0158,0.0057,0.0000], [0.0114,0.0041,0.0000], [0.0081,0.0029,0.0000],\n        [0.0058,0.0021,0.0000], [0.0041,0.0015,0.0000], [0.0029,0.0010,0.0000],\n        [0.0020,0.0007,0.0000], [0.0014,0.0005,0.0000], [0.0010,0.0004,0.0000],\n        [0.0007,0.0002,0.0000], [0.0005,0.0002,0.0000], [0.0003,0.0001,0.0000],\n        [0.0002,0.0001,0.0000], [0.0002,0.0001,0.0000], [0.0001,0.0000,0.0000],\n        [0.0001,0.0000,0.0000], [0.0001,0.0000,0.0000], [0.0000,0.0000,0.0000]]\n\n    X = 0\n    Y = 0\n    Z = 0\n    for i, lamb in enumerate(range(380, 780, 5)): #lambda = 380; lambda < 780.1; i++, lambda += 5) {\n        Me = spec_intens(lamb, temp);\n        X += Me * cie_colour_match[i][0]\n        Y += Me * cie_colour_match[i][1]\n        Z += Me * cie_colour_match[i][2]\n    XYZ = (X + Y + Z)\n    x = X / XYZ;\n    y = Y / XYZ;\n    z = Z / XYZ;\n    return(x, y, z)\n\ndef bb_spectrum(wavelength, bbTemp=5000):\n    """"""\n    Calculate, by Planck\'s radiation law, the emittance of a black body\n    of temperature bbTemp at the given wavelength (in metres).  */\n    """"""\n    wlm = wavelength * 1e-9 # Convert to metres\n    return (3.74183e-16 * math.pow(wlm, -5.0)) / (math.exp(1.4388e-2 / (wlm * bbTemp)) - 1.0)\n\n    """"""  Built-in test program which displays the x, y, and Z and RGB\n    values for black body spectra from 1000 to 10000 degrees kelvin.\n    When run, this program should produce the following output:\n\n    Temperature       x      y      z       R     G     B\n    -----------    ------ ------ ------   ----- ----- -----\n       1000 K      0.6528 0.3444 0.0028   1.000 0.007 0.000 (Approximation)\n       1500 K      0.5857 0.3931 0.0212   1.000 0.126 0.000 (Approximation)\n       2000 K      0.5267 0.4133 0.0600   1.000 0.234 0.010\n       2500 K      0.4770 0.4137 0.1093   1.000 0.349 0.067\n       3000 K      0.4369 0.4041 0.1590   1.000 0.454 0.151\n       3500 K      0.4053 0.3907 0.2040   1.000 0.549 0.254\n       4000 K      0.3805 0.3768 0.2428   1.000 0.635 0.370\n       4500 K      0.3608 0.3636 0.2756   1.000 0.710 0.493\n       5000 K      0.3451 0.3516 0.3032   1.000 0.778 0.620\n       5500 K      0.3325 0.3411 0.3265   1.000 0.837 0.746\n       6000 K      0.3221 0.3318 0.3461   1.000 0.890 0.869\n       6500 K      0.3135 0.3237 0.3628   1.000 0.937 0.988\n       7000 K      0.3064 0.3166 0.3770   0.907 0.888 1.000\n       7500 K      0.3004 0.3103 0.3893   0.827 0.839 1.000\n       8000 K      0.2952 0.3048 0.4000   0.762 0.800 1.000\n       8500 K      0.2908 0.3000 0.4093   0.711 0.766 1.000\n       9000 K      0.2869 0.2956 0.4174   0.668 0.738 1.000\n       9500 K      0.2836 0.2918 0.4246   0.632 0.714 1.000\n      10000 K      0.2807 0.2884 0.4310   0.602 0.693 1.000\n""""""\n\nif __name__ == ""__main__"":\n    print(""Temperature       x      y      z       R     G     B"")\n    print(""-----------    ------ ------ ------   ----- ----- -----"")\n\n    for t in range(1000, 10000, 500):  # (t = 1000; t <= 10000; t+= 500) {\n        x, y, z = spectrum_to_xyz(bb_spectrum, t)\n\n        r, g, b = xyz_to_rgb(SMPTEsystem, x, y, z)\n\n        r, g, b = constrain_rgb(r, g, b) # I omit the approximation bit here.\n        r, g, b = norm_rgb(r, g, b)\n        print(""  %5.0f K      %.4f %.4f %.4f   %.3f %.3f %.3f"" % (t, x, y, z, r, g, b))\n'"
examples/game-of-life.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# Author:   Nicolas P .Rougier\n# Date:     06/03/2014\n# Abstract: GPU computing using the framebuffer\n# Keywords: framebuffer, GPU computing, cellular automata\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\n\n\nrender_vertex = """"""\nattribute vec2 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n    v_texcoord = texcoord;\n}\n""""""\n\nrender_fragment = """"""\nuniform int pingpong;\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    float v;\n    v = texture2D(texture, v_texcoord)[pingpong];\n    gl_FragColor = vec4(1.0-v, 1.0-v, 1.0-v, 1.0);\n}\n""""""\n\ncompute_vertex = """"""\nattribute vec2 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n    v_texcoord = texcoord;\n}\n""""""\n\ncompute_fragment = """"""\nuniform int pingpong;\nuniform sampler2D texture;\nuniform float dx;          // horizontal distance between texels\nuniform float dy;          // vertical distance between texels\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    vec2  p = v_texcoord;\n    float old_state, new_state, count;\n\n    old_state = texture2D(texture, p)[pingpong];\n    count = texture2D(texture, p + vec2(-dx,-dy))[pingpong]\n            + texture2D(texture, p + vec2( dx,-dy))[pingpong]\n            + texture2D(texture, p + vec2(-dx, dy))[pingpong]\n            + texture2D(texture, p + vec2( dx, dy))[pingpong]\n            + texture2D(texture, p + vec2(-dx, 0.0))[pingpong]\n            + texture2D(texture, p + vec2( dx, 0.0))[pingpong]\n            + texture2D(texture, p + vec2(0.0,-dy))[pingpong]\n            + texture2D(texture, p + vec2(0.0, dy))[pingpong];\n\n    new_state = old_state;\n    if( old_state > 0.5 ) {\n        // Any live cell with fewer than two live neighbours dies\n        // as if caused by under-population.\n        if( count  < 1.5 )\n            new_state = 0.0;\n\n        // Any live cell with two or three live neighbours\n        // lives on to the next generation.\n\n        // Any live cell with more than three live neighbours dies,\n        //  as if by overcrowding.\n        else if( count > 3.5 )\n            new_state = 0.0;\n    } else {\n        // Any dead cell with exactly three live neighbours becomes\n        //  a live cell, as if by reproduction.\n       if( (count > 2.5) && (count < 3.5) )\n           new_state = 1.0;\n    }\n    if( pingpong == 0 ) {\n        gl_FragColor[1] = new_state;\n        gl_FragColor[0] = old_state;\n    } else {\n        gl_FragColor[0] = new_state;\n        gl_FragColor[1] = old_state;\n    }\n}\n""""""\n\n\nwindow = app.Window(width=512, height=512)\n\n@window.event\ndef on_draw(dt):\n    global pingpong\n\n    width,height = 512,512\n\n    pingpong = 1 - pingpong\n    compute[""pingpong""] = pingpong\n    render[""pingpong""] = pingpong\n\n    gl.glDisable(gl.GL_BLEND)\n\n    framebuffer.activate()\n    gl.glViewport(0, 0, width, height)\n    compute.draw(gl.GL_TRIANGLE_STRIP)\n    framebuffer.deactivate()\n\n    gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n    gl.glViewport(0, 0, width, height)\n    render.draw(gl.GL_TRIANGLE_STRIP)\n\n\nw, h = 512,512\nZ = np.zeros((h, w, 4), dtype=np.float32)\nZ[...] = np.random.randint(0, 2, (h, w, 4))\nZ[:256, :256, :] = 0\ngun = """"""\n........................O...........\n......................O.O...........\n............OO......OO............OO\n...........O...O....OO............OO\nOO........O.....O...OO..............\nOO........O...O.OO....O.O...........\n..........O.....O.......O...........\n...........O...O....................\n............OO......................""""""\nx, y = 0, 0\nfor i in range(len(gun)):\n    if gun[i] == \'\\n\':\n        y += 1\n        x = 0\n    elif gun[i] == \'O\':\n        Z[y, x] = 1\n    x += 1\n\npingpong = 1\ncompute = gloo.Program(compute_vertex, compute_fragment, count=4)\ncompute[""texture""] = Z\ncompute[""texture""].interpolation = gl.GL_NEAREST\ncompute[""texture""].wrapping = gl.GL_CLAMP_TO_EDGE\ncompute[""position""] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]\ncompute[""texcoord""] = [(0, 0), (0, 1), (1, 0), (1, 1)]\ncompute[\'dx\'] = 1.0 / w\ncompute[\'dy\'] = 1.0 / h\ncompute[\'pingpong\'] = pingpong\n\n\nrender = gloo.Program(render_vertex, render_fragment, count=4)\nrender[""position""] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]\nrender[""texcoord""] = [(0, 0), (0, 1), (1, 0), (1, 1)]\nrender[""texture""] = compute[""texture""]\nrender[""texture""].interpolation = gl.GL_LINEAR\nrender[""texture""].wrapping = gl.GL_CLAMP_TO_EDGE\nrender[\'pingpong\'] = pingpong\n\nframebuffer = gloo.FrameBuffer(color=compute[""texture""],\n                               depth=gloo.DepthBuffer(w, h))\napp.run(framerate=0)\n'"
examples/geom-path.py,18,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# This implements antialiased lines using a geometry shader with correct joins\n# and caps.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\n\n# stride_tricks = np.lib.stride_tricks\n# Z = np.arange(24,dtype=np.float32).reshape(8,3)\n# stride_tricks.as_strided(Z,(4,4,12),(4,12,4)).reshape(16,4,3)\n\nvertex = """"""\nuniform float antialias;\nuniform float linewidth;\nuniform float miter_limit;\n\nattribute vec2 position;\n\nvarying float v_antialias[1];\nvarying float v_linewidth[1];\nvarying float v_miter_limit[1];\n\nvoid main()\n{\n    v_antialias[0] = antialias;\n    v_linewidth[0] = linewidth;\n    v_miter_limit[0] = miter_limit;\n\n    gl_Position = vec4(position, 0.0, 1.0);\n} """"""\n\nfragment = """"""\nvec4 stroke(float distance, float linewidth, float antialias, vec4 color)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    if( border_distance > (linewidth/2.0 + antialias) )\n        discard;\n    else if( border_distance < 0.0 )\n        frag_color = color;\n    else\n        frag_color = vec4(color.rgb, color.a * alpha);\n\n    return frag_color;\n}\nvec4 cap(int type, float dx, float dy, float linewidth, float antialias, vec4 color)\n{\n    float d = 0.0;\n    dx = abs(dx);\n    dy = abs(dy);\n    float t = linewidth/2.0 - antialias;\n\n    // None\n    if      (type == 0)  discard;\n    // Round\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);\n    // Triangle in\n    else if (type == 3)  d = (dx+abs(dy));\n    // Triangle out\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));\n    // Square\n    else if (type == 4)  d = max(dx,dy);\n    // Butt\n    else if (type == 5)  d = max(dx+t,dy);\n\n    return stroke(d, linewidth, antialias, color);\n}\n\n\nuniform vec4  color;\nuniform float antialias;\nuniform float linewidth;\nuniform float miter_limit;\n\nvarying float v_length;\nvarying vec2  v_caps;\nvarying vec2  v_texcoord;\nvarying vec2  v_bevel_distance;\n\nvoid main()\n{\n    float distance = v_texcoord.y;\n\n    if (v_caps.x < 0.0)\n    {\n        gl_FragColor = cap(1, v_texcoord.x, v_texcoord.y, linewidth, antialias, color);\n        return;\n    }\n    if (v_caps.y > v_length)\n    {\n        gl_FragColor = cap(1, v_texcoord.x-v_length, v_texcoord.y, linewidth, antialias, color);\n        return;\n    }\n\n    // Round join (instead of miter)\n    // if (v_texcoord.x < 0.0)          { distance = length(v_texcoord); }\n    // else if(v_texcoord.x > v_length) { distance = length(v_texcoord - vec2(v_length, 0.0)); }\n\n    // Miter limit\n    float t = (miter_limit-1.0)*(linewidth/2.0) + antialias;\n\n    if( (v_texcoord.x < 0.0) && (v_bevel_distance.x > (abs(distance) + t)) )\n    {\n        distance = v_bevel_distance.x - t;\n    }\n    else if( (v_texcoord.x > v_length) && (v_bevel_distance.y > (abs(distance) + t)) )\n    {\n        distance = v_bevel_distance.y - t;\n    }\n    gl_FragColor = stroke(distance, linewidth, antialias, color);\n} """"""\n\ngeometry = """"""\n#version 120\n#extension GL_EXT_gpu_shader4 : enable\n#extension GL_EXT_geometry_shader4 : enable\n\nuniform mat4 projection;\n// uniform float antialias;\n// uniform float linewidth;\n// uniform float miter_limit;\n\nvarying in float v_antialias[4][1];\nvarying in float v_linewidth[4][1];\nvarying in float v_miter_limit[4][1];\n\nvarying out vec2 v_caps;\nvarying out float v_length;\nvarying out vec2 v_texcoord;\nvarying out vec2 v_bevel_distance;\n\nfloat compute_u(vec2 p0, vec2 p1, vec2 p)\n{\n    // Projection p\' of p such that p\' = p0 + u*(p1-p0)\n    // Then  u *= lenght(p1-p0)\n    vec2 v = p1 - p0;\n    float l = length(v);\n    return ((p.x-p0.x)*v.x + (p.y-p0.y)*v.y) / l;\n}\n\nfloat line_distance(vec2 p0, vec2 p1, vec2 p)\n{\n    // Projection p\' of p such that p\' = p0 + u*(p1-p0)\n    vec2 v = p1 - p0;\n    float l2 = v.x*v.x + v.y*v.y;\n    float u = ((p.x-p0.x)*v.x + (p.y-p0.y)*v.y) / l2;\n\n    // h is the projection of p on (p0,p1)\n    vec2 h = p0 + u*v;\n\n    return length(p-h);\n}\n\nvoid main(void)\n{\n    float antialias = v_antialias[0][0];\n    float linewidth = v_linewidth[0][0];\n    float miter_limit = v_miter_limit[0][0];\n\n\n    // Get the four vertices passed to the shader\n    vec2 p0 = gl_PositionIn[0].xy; // start of previous segment\n    vec2 p1 = gl_PositionIn[1].xy; // end of previous segment, start of current segment\n    vec2 p2 = gl_PositionIn[2].xy; // end of current segment, start of next segment\n    vec2 p3 = gl_PositionIn[3].xy; // end of next segment\n\n    // Determine the direction of each of the 3 segments (previous, current, next)\n    vec2 v0 = normalize(p1 - p0);\n    vec2 v1 = normalize(p2 - p1);\n    vec2 v2 = normalize(p3 - p2);\n\n    // Determine the normal of each of the 3 segments (previous, current, next)\n    vec2 n0 = vec2(-v0.y, v0.x);\n    vec2 n1 = vec2(-v1.y, v1.x);\n    vec2 n2 = vec2(-v2.y, v2.x);\n\n    // Determine miter lines by averaging the normals of the 2 segments\n    vec2 miter_a = normalize(n0 + n1); // miter at start of current segment\n    vec2 miter_b = normalize(n1 + n2); // miter at end of current segment\n\n    // Determine the length of the miter by projecting it onto normal\n    vec2 p,v;\n    float d;\n    float w = linewidth/2.0 + 1.5*antialias;\n    v_length = length(p2-p1);\n\n    float length_a = w / dot(miter_a, n1);\n    float length_b = w / dot(miter_b, n1);\n\n    float m = miter_limit*linewidth/2.0;\n\n    // Angle between prev and current segment (sign only)\n    float d0 = +1.0;\n    if( (v0.x*v1.y - v0.y*v1.x) > 0 ) { d0 = -1.0;}\n\n    // Angle between current and next segment (sign only)\n    float d1 = +1.0;\n    if( (v1.x*v2.y - v1.y*v2.x) > 0 ) { d1 = -1.0; }\n\n\n\n    // Generate the triangle strip\n\n    // Cap at start\n    if( p0 == p1 ) {\n        p = p1 - w*v1 + w*n1;\n        gl_Position = projection*vec4(p, 0.0, 1.0);\n        v_texcoord = vec2(-w, +w);\n        v_caps.x = v_texcoord.x;\n    // Regular join\n    } else {\n        p = p1 + length_a * miter_a;\n        gl_Position = projection*vec4(p, 0.0, 1.0);\n        v_texcoord = vec2(compute_u(p1,p2,p), +w);\n        v_caps.x = 1.0;\n    }\n    if( p2 == p3 ) v_caps.y = v_texcoord.x;\n    else           v_caps.y = 1.0;\n\n    v_bevel_distance.x = +d0*line_distance(p1+d0*n0*w, p1+d0*n1*w, p);\n    v_bevel_distance.y =    -line_distance(p2+d1*n1*w, p2+d1*n2*w, p);\n    EmitVertex();\n\n    // Cap at start\n    if( p0 == p1 ) {\n        p = p1 - w*v1 - w*n1;\n        v_texcoord = vec2(-w, -w);\n        v_caps.x = v_texcoord.x;\n    // Regular join\n    } else {\n        p = p1 - length_a * miter_a;\n        v_texcoord = vec2(compute_u(p1,p2,p), -w);\n        v_caps.x = 1.0;\n    }\n    if( p2 == p3 ) v_caps.y = v_texcoord.x;\n    else           v_caps.y = 1.0;\n    gl_Position = projection*vec4(p, 0.0, 1.0);\n    v_bevel_distance.x = -d0*line_distance(p1+d0*n0*w, p1+d0*n1*w, p);\n    v_bevel_distance.y =    -line_distance(p2+d1*n1*w, p2+d1*n2*w, p);\n    EmitVertex();\n\n    // Cap at end\n    if( p2 == p3 ) {\n        p = p2 + w*v1 + w*n1;\n        v_texcoord = vec2(v_length+w, +w);\n        v_caps.y = v_texcoord.x;\n    // Regular join\n    } else {\n        p = p2 + length_b * miter_b;\n        v_texcoord = vec2(compute_u(p1,p2,p), +w);\n        v_caps.y = 1.0;\n    }\n    if( p0 == p1 ) v_caps.x = v_texcoord.x;\n    else           v_caps.x = 1.0;\n\n    gl_Position = projection*vec4(p, 0.0, 1.0);\n    v_bevel_distance.x =    -line_distance(p1+d0*n0*w, p1+d0*n1*w, p);\n    v_bevel_distance.y = +d1*line_distance(p2+d1*n1*w, p2+d1*n2*w, p);\n    EmitVertex();\n\n    // Cap at end\n    if( p2 == p3 ) {\n        p = p2 + w*v1 - w*n1;\n        v_texcoord = vec2(v_length+w, -w);\n        v_caps.y = v_texcoord.x;\n    // Regular join\n    } else {\n        p = p2 - length_b * miter_b;\n        v_texcoord = vec2(compute_u(p1,p2,p), -w);\n        v_caps.y = 1.0;\n    }\n    if( p0 == p1 ) v_caps.x = v_texcoord.x;\n    else           v_caps.x = 1.0;\n    gl_Position = projection*vec4(p, 0.0, 1.0);\n    v_bevel_distance.x =    -line_distance(p1+d0*n0*w, p1+d0*n1*w, p);\n    v_bevel_distance.y = -d1*line_distance(p2+d1*n1*w, p2+d1*n2*w, p);\n    EmitVertex();\n\n    EndPrimitive();\n}\n""""""\n\n\n\n# Nice spiral\nn = 1024\nT = np.linspace(0, 10*2*np.pi, n)\nR = np.linspace(10, 400, n)\nP = np.zeros((n,2), dtype=np.float32)\nP[:,0] = 400 + np.cos(T)*R\nP[:,1] = 400 + np.sin(T)*R\n\n# Star\ndef star(inner=0.45, outer=1.0, n=5):\n    R = np.array( [inner,outer]*n)\n    T = np.linspace(0,2*np.pi,2*n,endpoint=False)\n    P = np.zeros((2*n,2))\n    P[:,0]= R*np.cos(T)\n    P[:,1]= R*np.sin(T)\n    return P\n\nvertex   = gloo.VertexShader(vertex)\nfragment = gloo.FragmentShader(fragment)\ngeometry = gloo.GeometryShader(geometry, 4, gl.GL_LINES_ADJACENCY_EXT, gl.GL_TRIANGLE_STRIP)\nprogram = gloo.Program(vertex, fragment, geometry)\n\nP = (star(n=5)*350 + (400,400)).astype(np.float32)\n\nclosed = True\nif closed:\n    if np.allclose(P[0],P[1]):\n        I = (np.arange(len(P)+2)-1)\n        I[0], I[-1] = 0, len(P)-1\n    else:\n        I = (np.arange(len(P)+3)-1)\n        I[0], I[-2], I[-1] = len(P)-1, 0, 1\nelse:\n    I = (np.arange(len(P)+2)-1)\n    I[0], I[-1] = 0, len(P)-1\nI = I.astype(np.uint32).view(gloo.IndexBuffer)\n\n\nprogram[""position""] = P\nprogram[""linewidth""] = 13.0\nprogram[""antialias""] = 1.0\nprogram[""miter_limit""] = 4.0\nprogram[""color""] = 0,0,0,1\n\nwindow = app.Window(width=800, height=800, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_LINE_STRIP_ADJACENCY_EXT, I)\n\n@window.event\ndef on_resize(width, height):\n    program[\'projection\'] = glm.ortho(0, width, 0, height, -1, +1)\n\napp.run()\n'"
examples/geometry-parametric.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo, data\nfrom glumpy.geometry import surface\n\n\nvertex = """"""\nuniform mat4 view;\nuniform mat4 model;\nuniform mat4 projection;\nattribute vec3 normal;\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec3 v_normal;\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    v_texcoord = texcoord;\n    v_normal = normal;\n    v_position = position;\n    gl_Position = projection * view * model * vec4(v_position, 1.0);\n}\n""""""\n\nfragment = """"""\nuniform mat4 view;\nuniform mat4 model;\nuniform mat4 normal;\nuniform mat4 projection;\n\nuniform vec3 light1_position;\nuniform vec3 light2_position;\nuniform vec3 light3_position;\nuniform vec3 light1_color;\nuniform vec3 light2_color;\nuniform vec3 light3_color;\n\nuniform sampler2D texture;\n\nvarying vec3 v_normal;\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\n\nfloat lighting(vec3 light_position)\n{\n    // Calculate normal in world coordinates\n    vec3 n = normalize(normal * vec4(v_normal,1.0)).xyz;\n\n    // Calculate the location of this fragment (pixel) in world coordinates\n    vec3 position = vec3(view * model * vec4(v_position, 1));\n\n    // Calculate the vector from this pixels surface to the light source\n    vec3 surface_to_light = light_position - position;\n\n    // Calculate the cosine of the angle of incidence (brightness)\n    float brightness = dot(n, surface_to_light) /\n                      (length(surface_to_light) * length(n));\n    brightness = max(min(brightness,1.0),0.0);\n    return brightness;\n}\n\nvoid main()\n{\n    vec4 l1 = vec4(light1_color * lighting(light1_position), 1);\n    vec4 l2 = vec4(light2_color * lighting(light2_position), 1);\n    vec4 l3 = vec4(light3_color * lighting(light3_position), 1);\n    float r = texture2D(texture, v_texcoord).r;\n    vec4 color = vec4(r,r,r,1);\n\n    // Calculate final color of the pixel, based on:\n    // 1. The angle of incidence: brightness\n    // 2. The color/intensities of the light: light.intensities\n    // 3. The texture and texture coord: texture(tex, fragTexCoord)\n    gl_FragColor = color *( 0.25 + 0.75*(l1+l2+l3));\n}\n""""""\n\n\nwindow = app.Window(width=1024, height=1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, duration\n\n    window.clear()\n    program.draw(gl.GL_TRIANGLES, indices)\n\n    theta += 0.5\n    phi += 0.5\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    program[\'model\'] = model\n    program[\'normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\n\n\n@window.event\ndef on_resize(width, height):\n    program[\'projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n\n\ndef klein(u, v):\n    from math import pi, cos, sin\n    if u < pi:\n        x = 3 * cos(u) * (1 + sin(u)) + (2 * (1 - cos(u) / 2)) * cos(u) * cos(v)\n        z = -8 * sin(u) - 2 * (1 - cos(u) / 2) * sin(u) * cos(v)\n    else:\n        x = 3 * cos(u) * (1 + sin(u)) + (2 * (1 - cos(u) / 2)) * cos(v + pi)\n        z = -8 * sin(u)\n    y = -2 * (1 - cos(u) / 2) * sin(v)\n    return x/5, y/5, z/5\n\nvertices, indices = surface(klein, urepeat=3)\n\n\nprogram = gloo.Program(vertex, fragment)\nprogram.bind(vertices)\nview = np.eye(4, dtype=np.float32)\nmodel = np.eye(4, dtype=np.float32)\nprojection = np.eye(4, dtype=np.float32)\nglm.translate(view, 0, 0, -5)\nprogram[\'model\'] = model\nprogram[\'view\'] = view\nprogram[\'normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\nprogram[\'texture\'] = data.checkerboard()\nprogram[\'texture\'].wrapping = gl.GL_REPEAT\n\nprogram[""light1_position""] = 3, 0, 0+5\nprogram[""light2_position""] = 0, 3, 0+5\nprogram[""light3_position""] = -3, -3, +5\nprogram[""light1_color""]    = 1, 0, 0\nprogram[""light2_color""]    = 0, 1, 0\nprogram[""light3_color""]    = 0, 0, 1\nphi, theta = 0, 0\n\napp.run()\n'"
examples/geometry-primitives.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo, data\nfrom glumpy.geometry import primitives\n\n\nvertex = """"""\nuniform mat4 view;\nuniform mat4 model;\nuniform mat4 projection;\n\nattribute vec3 normal;\nattribute vec3 position;\nattribute vec2 texcoord;\n\nvarying vec3 v_normal;\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    v_texcoord = texcoord;\n    v_normal = normal;\n    v_position = position;\n    gl_Position = projection * view * model * vec4(v_position, 1.0);\n}\n""""""\n\nfragment = """"""\nuniform mat4 view;\nuniform mat4 model;\nuniform mat4 normal;\nuniform mat4 projection;\n\nuniform vec3 light1_position;\nuniform vec3 light2_position;\nuniform vec3 light3_position;\nuniform vec3 light1_color;\nuniform vec3 light2_color;\nuniform vec3 light3_color;\n\nuniform sampler2D texture;\n\nvarying vec3 v_normal;\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\n\nfloat lighting(vec3 light_position)\n{\n    // Calculate normal in world coordinates\n    vec3 n = normalize(normal * vec4(v_normal,1.0)).xyz;\n\n    // Calculate the location of this fragment (pixel) in world coordinates\n    vec3 position = vec3(view * model * vec4(v_position, 1));\n\n    // Calculate the vector from this pixels surface to the light source\n    vec3 surface_to_light = light_position - position;\n\n    // Calculate the cosine of the angle of incidence (brightness)\n    float brightness = dot(n, surface_to_light) /\n                      (length(surface_to_light) * length(n));\n    brightness = max(min(brightness,1.0),0.0);\n    return brightness;\n}\n\nvoid main()\n{\n    vec4 l1 = vec4(light1_color * lighting(light1_position), 1);\n    vec4 l2 = vec4(light2_color * lighting(light2_position), 1);\n    vec4 l3 = vec4(light3_color * lighting(light3_position), 1);\n\n    float r = texture2D(texture, v_texcoord).r;\n    vec4 color = vec4(r,r,r,1);\n\n    // Calculate final color of the pixel, based on:\n    // 1. The angle of incidence: brightness\n    // 2. The color/intensities of the light: light.intensities\n    // 3. The texture and texture coord: texture(tex, fragTexCoord)\n    gl_FragColor = color *( 0.25 + 0.75*(l1+l2+l3));\n}\n""""""\n\n\nwindow = app.Window(width=1024, height=1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, duration\n    window.clear()\n    program.draw(gl.GL_TRIANGLES, indices)\n    theta += 0.5\n    phi += 0.5\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    program[\'model\'] = model\n    program[\'normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\n\n\n@window.event\ndef on_resize(width, height):\n    program[\'projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n@window.event\ndef on_key_press(key, modifiers):\n    global vertices, indices, index\n    if key == ord(\' \'):\n        index = (index+1) % len(shapes)\n        vertices, indices = shapes[index]\n        program.bind(vertices)\n\nindex = 0\nshapes = [ primitives.plane(1.5),\n           primitives.cube(1.5),\n           primitives.sphere(),\n           primitives.cubesphere(),\n           primitives.cylinder(),\n           primitives.torus(),\n           primitives.cone(),\n           primitives.pyramid(),\n           primitives.teapot() ]\nvertices, indices = shapes[index]\n\nprogram = gloo.Program(vertex, fragment)\nprogram.bind(vertices)\nview = np.eye(4, dtype=np.float32)\nmodel = np.eye(4, dtype=np.float32)\nprojection = np.eye(4, dtype=np.float32)\nglm.translate(view, 0, 0, -5)\nprogram[\'model\'] = model\nprogram[\'view\'] = view\nprogram[\'normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\nprogram[\'texture\'] = data.checkerboard()\nprogram[""light1_position""] = 3, 0, 0+5\nprogram[""light2_position""] = 0, 3, 0+5\nprogram[""light3_position""] = -3, -3, +5\nprogram[""light1_color""]    = 1, 0, 0\nprogram[""light2_color""]    = 0, 1, 0\nprogram[""light3_color""]    = 0, 0, 1\nphi, theta = 0, 0\n\napp.run()\n'"
examples/geometry-surface.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, data, library\nfrom glumpy.geometry import primitives\nfrom glumpy.transforms import Trackball\n\nvertex = """"""\n#include ""misc/spatial-filters.frag""\n\nuniform float height;\nuniform sampler2D data;\nuniform vec2 data_shape;\nattribute vec3 position;\nattribute vec2 texcoord;\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    float z = height*Bicubic(data, data_shape, texcoord).r;\n    gl_Position = <transform>;\n    v_texcoord = texcoord;\n    v_position = vec3(position.xy, z);\n}\n""""""\n\nfragment = """"""\n#include ""misc/spatial-filters.frag""\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 normal;\nuniform sampler2D texture;\nuniform float height;\nuniform vec4 color;\n\nuniform sampler2D data;\nuniform vec2 data_shape;\nuniform vec3 light_color[3];\nuniform vec3 light_position[3];\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\n\nfloat lighting(vec3 v_normal, vec3 light_position)\n{\n    // Calculate normal in world coordinates\n    vec3 n = normalize(normal * vec4(v_normal,1.0)).xyz;\n\n    // Calculate the location of this fragment (pixel) in world coordinates\n    vec3 position = vec3(view * model * vec4(v_position, 1));\n\n    // Calculate the vector from this pixels surface to the light source\n    vec3 surface_to_light = light_position - position;\n\n    // Calculate the cosine of the angle of incidence (brightness)\n    float brightness = dot(n, surface_to_light) /\n                      (length(surface_to_light) * length(n));\n    brightness = max(min(brightness,1.0),0.0);\n    return brightness;\n}\n\nvoid main()\n{\n    mat4 model = <transform.trackball_model>;\n\n    // Extract data value\n    float value = Bicubic(data, data_shape, v_texcoord).r;\n\n    // Compute surface normal using neighbour values\n    float hx0 = height*Bicubic(data, data_shape, v_texcoord+vec2(+1,0)/data_shape).r;\n    float hx1 = height*Bicubic(data, data_shape, v_texcoord+vec2(-1,0)/data_shape).r;\n    float hy0 = height*Bicubic(data, data_shape, v_texcoord+vec2(0,+1)/data_shape).r;\n    float hy1 = height*Bicubic(data, data_shape, v_texcoord+vec2(0,-1)/data_shape).r;\n    vec3 dx = vec3(2.0/data_shape.x,0.0,hx0-hx1);\n    vec3 dy = vec3(0.0,2.0/data_shape.y,hy0-hy1);\n    vec3 v_normal = normalize(cross(dx,dy));\n\n    // Map value to rgb color\n    float c = 0.6 + 0.4*texture2D(texture, v_texcoord).r;\n    vec4 l1 = vec4(light_color[0] * lighting(v_normal, light_position[0]), 1);\n    vec4 l2 = vec4(light_color[1] * lighting(v_normal, light_position[1]), 1);\n    vec4 l3 = vec4(light_color[2] * lighting(v_normal, light_position[2]), 1);\n\n    gl_FragColor = color * vec4(c,c,c,1) * (0.5 + 0.5*(l1+l2+l3));\n} """"""\n\n\n\nwindow = app.Window(1200, 800, color = (1,1,1,1))\n\n\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, time\n\n    time += dt\n    window.clear()\n\n    surface[\'data\']\n\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    surface[""color""] = 1,1,1,1\n    surface.draw(gl.GL_TRIANGLES, s_indices)\n\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    surface[""color""] = 0,0,0,1\n    surface.draw(gl.GL_LINE_LOOP, b_indices)\n    gl.glDepthMask(gl.GL_TRUE)\n\n    model = surface[\'transform\'][\'model\'].reshape(4,4)\n    view  = surface[\'transform\'][\'view\'].reshape(4,4)\n    surface[\'view\']  = view\n    surface[\'model\'] = model\n    surface[\'normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\n    # surface[""height""] = 0.75*np.cos(time/5.0)\n\n\n@window.event\ndef on_init():\n    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n    gl.glPolygonOffset(1, 1)\n    gl.glEnable(gl.GL_LINE_SMOOTH)\n    gl.glLineWidth(2.5)\n\n\nn = 64\nsurface = gloo.Program(vertex, fragment)\nvertices, s_indices = primitives.plane(2.0, n=n)\nsurface.bind(vertices)\n\nI = []\nfor i in range(n): I.append(i)\nfor i in range(1,n): I.append(n-1+i*n)\nfor i in range(n-1): I.append(n*n-1-i)\nfor i in range(n-1): I.append(n*(n-1) - i*n)\nb_indices = np.array(I, dtype=np.uint32).view(gloo.IndexBuffer)\n\n\ndef func3(x,y):\n    return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)\nx = np.linspace(-2.0, 2.0, 32).astype(np.float32)\ny = np.linspace(-2.0, 2.0, 32).astype(np.float32)\nX,Y = np.meshgrid(x, y)\nZ = func3(X,Y)\n\nsurface[\'data\'] = (Z-Z.min())/(Z.max() - Z.min())\nsurface[\'data\'].interpolation = gl.GL_NEAREST\nsurface[\'data_shape\'] = Z.shape[1], Z.shape[0]\nsurface[\'u_kernel\'] = data.get(""spatial-filters.npy"")\nsurface[\'u_kernel\'].interpolation = gl.GL_LINEAR\nsurface[\'texture\'] = data.checkerboard(32,24)\n\ntransform = Trackball(""vec4(position.xy, z, 1.0)"")\nsurface[\'transform\'] = transform\nwindow.attach(transform)\n\nT = (Z-Z.min())/(Z.max() - Z.min())\n\nsurface[\'height\'] = 0.75\nsurface[""light_position[0]""] = 3, 0, 0+5\nsurface[""light_position[1]""] = 0, 3, 0+5\nsurface[""light_position[2]""] = -3, -3, +5\nsurface[""light_color[0]""]    = 1, 0, 0\nsurface[""light_color[1]""]    = 0, 1, 0\nsurface[""light_color[2]""]    = 0, 0, 1\nphi, theta = -45, 0\ntime = 0\n\napp.run()\n'"
examples/gloo-antialias.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Position, OrthographicProjection, PanZoom\n\nvertex = """"""\n#include ""math/constants.glsl""\n\nattribute vec2  position;\nattribute float size;\nattribute vec4  fg_color;\nattribute vec4  bg_color;\nattribute float orientation;\nattribute float linewidth;\nattribute float antialias;\n\nvarying float v_size;\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvarying vec2  v_orientation;\nvarying float v_antialias;\nvarying float v_linewidth;\n\nvoid main (void)\n{\n    v_size        = size;\n    v_linewidth   = linewidth;\n    v_antialias   = antialias;\n    v_fg_color    = fg_color;\n    v_bg_color    = bg_color;\n    v_orientation = vec2(cos(orientation), sin(orientation));\n\n    gl_Position = <transform>;\n    gl_PointSize = M_SQRT2 * size + 2.0 * (linewidth + 1.5*antialias);\n}\n""""""\n\n# Create window\nwindow = app.Window(width=2*512+16, height=3*128+16, color=(1,1,1,1))\n\n# What to draw when necessary\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_POINTS)\n\n# Setup some markers\nn = 3*8\ndata = np.zeros(n, dtype=[(\'position\',    np.float32, 3),\n                          (\'fg_color\',    np.float32, 4),\n                          (\'bg_color\',    np.float32, 4),\n                          (\'size\',        np.float32, 1),\n                          (\'orientation\', np.float32, 1),\n                          (\'antialias\',   np.float32, 1),\n                          (\'linewidth\',   np.float32, 1)])\ndata = data.view(gloo.VertexBuffer)\ndata[\'linewidth\'] = 1\ndata[\'fg_color\'] = 0, 0, 0, 1\ndata[\'bg_color\'] = 1, 1, 1, 0\ndata[\'orientation\'] = 0\n\nradius = 128\n\nfor j in range(3):\n    for i in range(8):\n        x = (i+0.5)*radius\n        y = (j+0.5)*radius\n        index = j*8+i\n        data[\'orientation\'][index] = 0\n        data[\'position\'][index]    = x, y, 0\n        data[\'size\'][index]        = .75*radius\n        data[\'linewidth\'][index]   = 1+i*2\n        data[\'antialias\'][index] = 1\n        if j == 2:\n            data[\'antialias\'][index] = 1+i*3\n        elif j == 1:\n            v = 0.35 + 0.5 * (i/8.0)\n            data[\'fg_color\'][index] = 0,0,0,1\n            data[\'bg_color\'][index] = 1,1,.85,1\n        elif j == 0:\n            v = i / 8.0\n            data[\'fg_color\'][index] = 0,0,0,1\n            data[\'bg_color\'][index] = 0,0,0,1\n\nprogram = gloo.Program(vertex, ""markers/marker.frag"")\nprogram.bind(data)\nprogram[\'marker\'] = ""clover""\nprogram[\'paint\']  = ""outline""\ntransform = OrthographicProjection(Position(""position""))\nprogram[\'transform\'] = transform\nwindow.attach(transform)\n\napp.run()\n'"
examples/gloo-arrows.py,13,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Position, OrthographicProjection, PanZoom\n\n# Create window\nwindow = app.Window(width=2*512, height=512, color=(1,1,1,1))\n\n# What to draw when necessary\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_POINTS)\n    program[\'orientation\'][-1] += np.pi/1024.0\n\n# Setup some markers\nn = 500+1\ndata = np.zeros(n, dtype=[(\'position\',    np.float32, 2),\n                          (\'fg_color\',    np.float32, 4),\n                          (\'bg_color\',    np.float32, 4),\n                          (\'size\',        np.float32, 1),\n                          (\'head\',        np.float32, 1),\n                          (\'orientation\', np.float32, 1),\n                          (\'linewidth\',   np.float32, 1)])\ndata = data.view(gloo.VertexBuffer)\ndata[\'linewidth\'] = 1\ndata[\'fg_color\'] = 0, 0, 0, 1\ndata[\'bg_color\'] = 0, 0, 0, 1\ndata[\'orientation\'] = 0\ndata[\'head\'] = 0.25\nradius, theta, dtheta = 245.0, 0.0, 6.5 / 180.0 * np.pi\nfor i in range(500):\n    theta += dtheta\n    x = 256 + radius * np.cos(theta)\n    y = 256 + radius * np.sin(theta)\n    r = 10.1 - i * 0.01\n    radius -= 0.4\n    data[\'orientation\'][i] = theta + np.pi\n    data[\'position\'][i] = x, y\n    data[\'size\'][i] = 2 * r\n    data[\'linewidth\'][i] = 1.5 - 0.5*i/500.\n\ndata[\'position\'][-1]    = 512+256, 256\ndata[\'size\'][-1]        = 512/np.sqrt(2)\ndata[\'linewidth\'][-1]   = 16.0\ndata[\'fg_color\'][-1]    = 0, 0, 0, 1\ndata[\'bg_color\'][-1]    = .95, .95, .95, 1\ndata[\'orientation\'][-1] = 0\n\nprogram = gloo.Program(""arrows/arrow.vert"", ""arrows/arrow.frag"")\nprogram.bind(data)\nprogram[\'antialias\'] = 1.00\nprogram[\'arrow\']     = ""stealth""\nprogram[\'paint\']     = ""filled""\ntransform = OrthographicProjection(Position(""position""))\nprogram[\'transform\'] = transform\nwindow.attach(transform)\n\napp.run()\n'"
examples/gloo-atlas.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl\n\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\n    uniform sampler2D texture;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_FragColor = texture2D(texture, v_texcoord);\n    }\n""""""\n\nwindow = app.Window(width=800, height=800)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nprogram[\'texcoord\'] = [( 0, 0), ( 0, 1), ( 1, 0), ( 1, 1)]\n\n\natlas = np.zeros((512,512,3),np.ubyte).view(gloo.Atlas)\nprogram[\'texture\'] = atlas\n\nfor i in range(400):\n    height,width = np.random.randint(10,40,2)\n    region = atlas.allocate((height,width))\n    if region:\n        x,y,width,height = region\n        atlas[y:y+height,x:x+width] = np.random.randint(64,256,3)\n\napp.run()\n'"
examples/gloo-cartesian-grid.py,18,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl, glm\n\nvertex = """"""\n    attribute vec2 a_texcoord;\n    attribute vec2 a_position;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(a_position, 0.0, 1.0);\n        v_texcoord = a_texcoord;\n    } """"""\n\nfragment = """"""\n    float\n    compute_alpha(float d, float width, float antialias)\n    {\n        d -= width/2.0 - antialias;\n        if( d < 0.0 )\n        {\n            return 1.0;\n        }\n        else\n        {\n            float alpha = d/antialias;\n            return exp(-alpha*alpha);\n        }\n    }\n\n    uniform vec2      u_size;\n    uniform vec2      u_translate;\n    uniform float     u_scale;\n    uniform float     u_antialias;\n\n    uniform float     u_major_grid_width;\n    uniform float     u_minor_grid_width;\n    uniform vec4      u_major_grid_color;\n    uniform vec4      u_minor_grid_color;\n    uniform sampler2D u_grid;\n\n    varying vec2 v_texcoord;\n    void main()\n    {\n        float x = v_texcoord.x * u_size.x; // - u_translate.x;\n        float y = v_texcoord.y * u_size.y; // - u_translate.y;\n\n        vec4 Tx = texture2D(u_grid, vec2(v_texcoord.x,0.5));\n        float Mx = abs(x - Tx.x - 0.315);\n        float mx = abs(x - Tx.z - 0.315);\n\n        vec4 Ty = texture2D(u_grid, vec2(v_texcoord.y,0.5));\n        float My = abs(y - Ty.y - 0.315);\n        float my = abs(y - Ty.w - 0.315);\n\n        // Major grid\n        float M = min(Mx,My);\n\n        // Minor grid\n        float m = min(mx,my);\n\n        vec4 color = u_major_grid_color;\n        float alpha1 = compute_alpha( M, u_major_grid_width, u_antialias);\n        float alpha2 = compute_alpha( m, u_minor_grid_width, u_antialias);\n        float alpha  = alpha1;\n        if( alpha2 > alpha1*1.5 )\n        {\n            alpha = alpha2;\n            color = u_minor_grid_color;\n        }\n\n        gl_FragColor = vec4(color.xyz, alpha*color.a);\n    }\n    """"""\n\n\ndef find_closest(A, target):\n    # A must be sorted\n    idx = A.searchsorted(target)\n    idx = np.clip(idx, 1, len(A) - 1)\n    left = A[idx - 1]\n    right = A[idx]\n    idx -= target - left < right - target\n    return idx\n\n\ndef update_grid(w, h):\n\n    n = Z.shape[1]\n    t1 = major_grid[0] * scale\n    t2 = minor_grid[0] * scale\n    t3 = major_grid[1] * scale\n    t4 = minor_grid[1] * scale\n\n    # Linear grid\n    I1 = np.arange(\n        np.fmod(translate[0], t1), np.fmod(translate[0], t1) + w + t1, t1)\n    I2 = np.arange(\n        np.fmod(translate[0], t2), np.fmod(translate[0], t2) + w + t2, t2)\n    I3 = np.arange(\n        np.fmod(translate[1], t3), np.fmod(translate[1], t3) + h + t3, t3)\n    I4 = np.arange(\n        np.fmod(translate[1], t4), np.fmod(translate[1], t4) + h + t4, t4)\n\n    # We are here in screen space and we want integer coordinates\n    # np.floor(I1, out=I1)\n    # np.floor(I2, out=I2)\n    # np.floor(I3, out=I3)\n    # np.floor(I4, out=I4)\n\n    L = np.linspace(0, w, n)\n    Z[..., 0] = I1[find_closest(I1, L)]\n    Z[..., 2] = I2[find_closest(I2, L)]\n    L = np.linspace(0, h, n)\n    Z[..., 1] = I3[find_closest(I3, L)]\n    Z[..., 3] = I4[find_closest(I4, L)]\n\n    program[\'u_grid\'][...] = Z\n    program[\'u_size\'] = w, h\n\n\n\nwindow = app.Window(width=512, height=512, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_resize(width, height):\n    gl.glViewport(0, 0, width, height)\n    update_grid(width, height)\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    global translate, scale\n    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)\n    translate = [translate[0] + dx, translate[1] - dy]\n    program[\'u_translate\'] = translate\n    update_grid(w, h)\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    global translate, scale\n    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)\n    y = h-y\n\n    s = min(max(0.25, scale + .01 * dy * scale), 200)\n    translate[0] = x - s * (x - translate[0]) / scale\n    translate[1] = y - s * (y - translate[1]) / scale\n    translate = [translate[0], translate[1]]\n    scale = s\n    program[\'u_translate\'] = translate\n    program[\'u_scale\'] = scale\n\n    update_grid(w, h)\n\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'a_position\'] = (-1, -1), (-1, +1), (+1, -1), (+1, +1)\nprogram[\'a_texcoord\'] = (0, 0), (0, +1), (+1, 0), (+1, +1)\nprogram[\'u_major_grid_width\'] = 1.0\nprogram[\'u_minor_grid_width\'] = 1.0\nprogram[\'u_major_grid_color\'] = 0, 0, 0, .75\nprogram[\'u_minor_grid_color\'] = 0, 0, 0, .25\nprogram[\'u_antialias\'] = 1.0\nprogram[\'u_translate\'] = 0, 0\nprogram[\'u_scale\'] = 1.0\nprogram[\'u_size\'] = 512.0, 512.0\nmajor_grid = np.array([64, 64])\nminor_grid = np.array([8, 8])\nZ = np.zeros((1, 2 * 1024, 4), dtype=np.float32)\nprogram[\'u_grid\'] = Z\nprogram[\'u_grid\'].interpolation = gl.GL_NEAREST\ntranslate = [0, 0]\nscale = 1\n\napp.run()\n'"
examples/gloo-cloud.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, glm\n\nvertex = """"""\n#version 120\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\nuniform float linewidth;\nuniform float antialias;\n\nattribute vec4  fg_color;\nattribute vec4  bg_color;\nattribute float radius;\nattribute vec3  position;\n\nvarying float v_pointsize;\nvarying float v_radius;\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvoid main (void)\n{\n    v_radius = radius;\n    v_fg_color = fg_color;\n    v_bg_color = bg_color;\n\n    gl_Position = projection * view * model * vec4(position,1.0);\n    gl_PointSize = 2 * (v_radius + linewidth + 1.5*antialias);\n}\n""""""\n\nfragment = """"""\n#version 120\n\nuniform float linewidth;\nuniform float antialias;\n\nvarying float v_radius;\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\n\nfloat marker(vec2 P, float size)\n{\n   const float SQRT_2 = 1.4142135623730951;\n   float x = SQRT_2/2 * (P.x - P.y);\n   float y = SQRT_2/2 * (P.x + P.y);\n\n   float r1 = max(abs(x)- size/2, abs(y)- size/10);\n   float r2 = max(abs(y)- size/2, abs(x)- size/10);\n   float r3 = max(abs(P.x)- size/2, abs(P.y)- size/10);\n   float r4 = max(abs(P.y)- size/2, abs(P.x)- size/10);\n   return min( min(r1,r2), min(r3,r4));\n}\n\n\nvoid main()\n{\n    float r = (v_radius + linewidth + 1.5*antialias);\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = length(gl_PointCoord.xy - vec2(0.5,0.5)) * 2 * r - v_radius;\n//    float signed_distance = marker((gl_PointCoord.xy - vec2(0.5,0.5))*r*2, 2*v_radius);\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Inside shape\n    if( signed_distance < 0 ) {\n        // Fully within linestroke\n        if( border_distance < 0 ) {\n            gl_FragColor = v_fg_color;\n        } else {\n            gl_FragColor = mix(v_bg_color, v_fg_color, alpha);\n        }\n    // Outside shape\n    } else {\n        // Fully within linestroke\n        if( border_distance < 0 ) {\n            gl_FragColor = v_fg_color;\n        } else if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\n            gl_FragColor = vec4(v_fg_color.rgb, v_fg_color.a * alpha);\n        } else {\n            discard;\n        }\n    }\n}\n""""""\n\ntheta, phi = 0,0\nwindow = app.Window(width=800, height=800, color=(1,1,1,1))\n\n\nn = 1000000\nprogram = gloo.Program(vertex, fragment, count=n)\nview = np.eye(4, dtype=np.float32)\nglm.translate(view, 0, 0, -5)\n\nprogram[\'position\'] = 0.35 * np.random.randn(n,3)\nprogram[\'radius\']   = np.random.uniform(5,10,n)\nprogram[\'fg_color\'] = 0,0,0,1\ncolors = np.random.uniform(0.75, 1.00, (n, 4))\ncolors[:,3] = 1\nprogram[\'bg_color\'] = colors\nprogram[\'linewidth\'] = 1.0\nprogram[\'antialias\'] = 1.0\nprogram[\'model\'] = np.eye(4, dtype=np.float32)\nprogram[\'projection\'] = np.eye(4, dtype=np.float32)\nprogram[\'view\'] = view\n\n@window.event\ndef on_draw(dt):\n    global theta, phi, translate\n    window.clear()\n    program.draw(gl.GL_POINTS)\n    theta += .5\n    phi += .5\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    program[\'model\'] = model\n\n@window.event\ndef on_resize(width,height):\n    program[\'projection\'] = glm.perspective(45.0, width / float(height), 1.0, 1000.0)\n\ngl.glEnable(gl.GL_DEPTH_TEST)\napp.run()\n'"
examples/gloo-console.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, __version__\n\nconsole = app.Console(rows=32,cols=80)\nwindow = app.Window(width = console.cols*console.cwidth*console.scale,\n                    height = console.rows*console.cheight*console.scale,\n                    color = (1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear(), console.draw()\n\n@window.timer(1/30.0)\ndef timer(fps):\n    console.clear()\n    console.write(""-------------------------------------------------------"")\n    console.write("" Glumpy version %s"" % (__version__))\n    console.write("" Window size: %dx%d"" % (window.width, window.height))\n    console.write("" Console size: %dx%d"" % (console._rows, console._cols))\n    console.write("" Backend: %s (%s)"" % (window._backend.__name__,\n                                        window._backend.__version__))\n    console.write("" Actual FPS: %.2f frames/second"" % (window.fps))\n    console.write(""-------------------------------------------------------"")\n    for line in repr(window.config).split(""\\n""):\n        console.write("" ""+line)\n    console.write(""-------------------------------------------------------"")\n\nwindow.attach(console)\napp.run()\n'"
examples/gloo-cube.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\nfrom glumpy.geometry import colorcube\n\nvertex = """"""\nuniform vec4 ucolor;\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\nattribute vec3 position;\nattribute vec4 color;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    v_color = ucolor * color;\n    gl_Position = projection * view * model * vec4(position,1.0);\n}\n""""""\n\nfragment = """"""\nvarying vec4 v_color;\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024, color=(0.30, 0.30, 0.35, 1.00))\n\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, duration\n\n    window.clear()\n\n    # Filled cube\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    cube[\'ucolor\'] = 1, 1, 1, 1\n    cube.draw(gl.GL_TRIANGLES, faces)\n\n    # Outlined cube\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    cube[\'ucolor\'] = 0, 0, 0, 1\n    cube.draw(gl.GL_LINES, outline)\n    gl.glDepthMask(gl.GL_TRUE)\n\n    # Make cube rotate\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'model\'] = model\n\n\n@window.event\ndef on_resize(width, height):\n    cube[\'projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glPolygonOffset(1, 1)\n    gl.glEnable(gl.GL_LINE_SMOOTH)\n    gl.glLineWidth(0.75)\n\nvertices, faces, outline = colorcube()\ncube = gloo.Program(vertex, fragment)\ncube.bind(vertices)\ncube[\'model\'] = np.eye(4, dtype=np.float32)\ncube[\'view\'] = glm.translation(0, 0, -5)\nphi, theta = 0, 0\n\napp.run()\n'"
examples/gloo-frame.py,8,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom  glumpy import app, gl, gloo, data, library\nfrom glumpy.transforms import Trackball, Position, Position\n\nvertex = """"""\nuniform vec2 iResolution;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvarying vec2 v_size;\n\nvarying mat4 v_PVM;\nvoid main (void)\n{\n    v_texcoord = texcoord;\n    gl_Position = <trackball>;\n\n    v_PVM = <trackball.trackball_projection> *\n            <trackball.trackball_view> *\n            <trackball.trackball_model>;\n}\n""""""\n\nwindow = app.Window(width=2*512, height=2*512, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_resize(width, height):\n    program[""iResolution""] = width, height\n\nprogram = gloo.Program(vertex, ""./regular-grid.frag"")\nprogram[""texcoord""] = (-0.5,-0.5), (-0.5, +0.5), (+0.5,-0.5), (+0.5,+0.5)\nprogram[""u_texture""] = data.get(""lena.png"")\nprogram[""u_texture""].interpolation = gl.GL_LINEAR\nprogram[\'u_major_grid_width\'] = 1.5\nprogram[\'u_minor_grid_width\'] = 1.0\nprogram[\'u_major_grid_color\'] = 0, 0, 0, 1.0\nprogram[\'u_minor_grid_color\'] = 0, 0, 0, 1.0\nprogram[\'u_antialias\'] = 1.0\n\n# Polar domains\n# program[\'u_major_grid_step\'] = np.array([ 1.00, np.pi/6])\n# program[\'u_minor_grid_step\'] = np.array([ 0.25, np.pi/60])\n# program[\'u_limits1\'] = -5.1, +5.1, -5.1, +5.1\n# program[\'u_limits2\'] = 1.0, 5.0, 0*np.pi, 2*np.pi\n\n# Cartesian domains\nprogram[\'u_major_grid_step\'] = np.array([ 1.00, 1.00])\nprogram[\'u_minor_grid_step\'] = np.array([ 0.10, 0.10])\nprogram[\'u_limits1\'] = -5.1, +5.1, -5.1, +5.1\nprogram[\'u_limits2\'] = -5.0, +5.0, -5.0, +5.0\n\n# Hammer domains\n# program[\'u_major_grid_step\'] = np.array([ 1.00, 0.50]) * np.pi/ 6.0\n# program[\'u_minor_grid_step\'] = np.array([ 1.00, 0.50]) * np.pi/30.0\n# program[\'u_limits1\'] = -3.0, +3.0, -1.5, +1.5\n# program[\'u_limits2\'] = -np.pi, +np.pi, -np.pi/3, +np.pi/3\n\n# program[\'transform\'] = shaders.get(""transforms/polar.glsl"")\n# program[\'transform\'] = shaders.get(""transforms/hammer.glsl"")\nprogram[\'transform_forward\'] = gloo.Snippet(library.get(""transforms/identity_forward.glsl""))\nprogram[\'transform_inverse\'] = gloo.Snippet(library.get(""transforms/identity_inverse.glsl""))\nprogram[\'trackball\'] = Trackball(Position(""texcoord""))\nprogram[\'trackball\'].theta = 0\nprogram[\'trackball\'].phi = 0\nprogram[\'trackball\'].zoom = 7.5\n\nwindow.attach(program[\'trackball\'])\n\napp.run()\n'"
examples/gloo-framebuffer.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\n\nvertex_1 = """"""\nattribute vec2 position;\nvoid main()\n{\n    gl_Position = vec4(position,0.0,1.0);\n}\n""""""\nfragment_1 = """"""\nvoid main()\n{\n    gl_FragColor = vec4(10,10,10,1);\n}\n""""""\n\nvertex_2 = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = vec4(0.85*position,0.0,1.0);\n    v_texcoord = (position+1.0)/2.0;\n}\n""""""\nfragment_2 = """"""\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    vec4 color = texture2D(texture, v_texcoord);\n    gl_FragColor = color / vec4(20,20,20,1);\n}\n""""""\n\nwindow = app.Window(width=512, height=512)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    framebuffer.activate()\n    quad_1.draw(gl.GL_TRIANGLE_STRIP)\n    # The texture can be read as np.ndarray.\n    out_texture = framebuffer.color[0].get()\n    framebuffer.deactivate()\n    quad_2.draw(gl.GL_TRIANGLE_STRIP)\n\ntexture = np.zeros((window.height,window.width,4),np.float32).view(gloo.TextureFloat2D)\nframebuffer = gloo.FrameBuffer(color=[texture])\nquad_1 = gloo.Program(vertex_1, fragment_1, count=4)\nquad_1[""position""] = (-1,-1), (-1,+1), (+1,-1), (+1,+1)\nquad_2 = gloo.Program(vertex_2, fragment_2, count=4)\nquad_2[""position""] = (-1,-1), (-1,+1), (+1,-1), (+1,+1)\nquad_2[""texture""] = texture\n\napp.run()\n'"
examples/gloo-hexagonal-grid.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, glm, gl\n\nvertex = """"""\n    attribute vec2 a_texcoord;\n    attribute vec2 a_position;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(a_position, 0.0, 1.0);\n        v_texcoord = a_texcoord;\n    } """"""\n\nfragment = """"""\n    uniform vec2  u_size;\n    uniform vec2  u_translate;\n    uniform float u_scale;\n    uniform vec4  u_grid_color;\n    uniform float u_grid_thickness;\n    uniform float u_grid_antialias;\n\n    varying vec2 v_texcoord;\n\n    float\n    distance_to_line(vec2 P1, vec2 P2, vec2 P3)\n    {\n        float u = (P3.x-P1.x)*(P2.x-P1.x) + (P3.y-P1.y)*(P2.y - P1.y);\n        u /= (P2.x-P1.x)*(P2.x-P1.x) + (P2.y-P1.y)*(P2.y-P1.y);\n        vec2 P = P1 + u*(P2-P1);\n        return sqrt( (P.x-P3.x)*(P.x-P3.x) +(P.y-P3.y)*(P.y-P3.y) );\n    }\n\n    void main()\n    {\n        float R = 16.0*u_scale;\n        float S = 1.5*R;\n        float W = 2.0*R;\n        float H = sqrt(3.0)*R;\n\n        float i,j;\n        float x = v_texcoord.x * u_size.x - u_translate.x;\n        float y = v_texcoord.y * u_size.y - u_translate.y;\n\n        i = floor(x/S);\n        j = floor((y - mod(i,2.0)*H/2.0)/H );\n        float cy0 = j*H + H/2. *(1.0 + mod(i,2.0));\n        float cx0 = i*S + W/2.;\n\n        i = floor(x/S) - 1.;\n        j = floor((y - mod(i,2.0)*H/2.0)/H );\n        float cy1 = j*H + H/2. *(1.0 + mod(i,2.0));\n        float cx1 = i*S + W/2.;\n\n        float t = u_grid_thickness/2.0-u_grid_antialias;\n        float radius = R*.85;\n\n        float X = abs(x-cx0);\n        float Y = abs(y-cy0);\n        float d0 = abs(Y-H/2.);\n        float d1 = distance_to_line( vec2(W/4.,H/2.), vec2(W/2., 0.0), vec2(X,Y));\n        if (X > (W-S))\n        {\n            d0=2.*d1;\n        }\n\n\n        float temp=y; y=x; x=temp;\n        x = (x - H/2.) / H;\n        float t1 = y / R;\n        float t2 = floor(x + t1);\n        float r = floor((floor(t1 - x) + t2) / 3.);\n        float q = floor((floor(2. * x + 1.) + t2) / 3.) - r;\n        r = floor(r);\n        q = floor(q);\n        vec4 color = vec4(min(q/10.0,1.0), min(r/10.0,1.0), 0.0, 1.0);\n\n        float d = min(d0,d1)-t;\n        if( d < 0.0 )\n        {\n            gl_FragColor = u_grid_color;\n        }\n        else\n        {\n            float alpha = d/u_grid_antialias;\n            alpha = exp(-alpha*alpha);\n            //gl_FragColor = vec4(u_grid_color.rgb, alpha) + (1.-alpha)*color;\n            gl_FragColor = vec4(u_grid_color.rgb, alpha);\n        }\n\n    }\n""""""\n\n\nwindow = app.Window(width=512, height=512, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_resize(width, height):\n    gl.glViewport(0, 0, width, height)\n    program[\'u_size\'] = width, height\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    global translate, scale\n    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)\n    translate = [translate[0] + dx, translate[1] - dy]\n    program[\'u_translate\'] = translate\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    global translate, scale\n    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)\n    y = h-y\n\n    s = min(max(0.25, scale + .01 * dy * scale), 200)\n    translate[0] = x - s * (x - translate[0]) / scale\n    translate[1] = y - s * (y - translate[1]) / scale\n    translate = [translate[0], translate[1]]\n    scale = s\n    program[\'u_translate\'] = translate\n    program[\'u_scale\'] = scale\n\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'a_position\'] = (-1,-1), (-1,+1), (+1,-1), (+1,+1)\nprogram[\'a_texcoord\'] = ( 0, 0), ( 0,+1), (+1, 0), (+1,+1)\nprogram[\'u_grid_color\'] = 0,0,0,1\nprogram[\'u_grid_thickness\'] = 1\nprogram[\'u_grid_antialias\'] = 1\nprogram[\'u_translate\'] = 0,0\nprogram[\'u_scale\'] = 1.0\nprogram[\'u_size\'] = 512,512\ntranslate = [0, 0]\nscale = 1\n\napp.run()\n'"
examples/gloo-image.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gloo, gl, glm, data\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\n    uniform sampler2D texture;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_FragColor = texture2D(texture, v_texcoord);\n    }\n""""""\n\nwindow = app.Window(width=512, height=512, aspect=1)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\nquad = gloo.Program(vertex, fragment, count=4)\nquad[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nquad[\'texcoord\'] = [( 0, 1), ( 0, 0), ( 1, 1), ( 1, 0)]\nquad[\'texture\'] = data.get(""lena.png"")\napp.run()\n'"
examples/gloo-irregular-grids.py,23,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport sys\nimport math\nimport numpy as np\nfrom  glumpy import app, gl, glm, gloo, library\n\n\nvertex = """"""\nconst float gap = 4.0;\n\nuniform mat4 projection;\nuniform vec4 viewport;\nuniform float rows, cols;\n\nattribute float row, col;\nattribute vec2 texcoord;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_size;\n\nvoid main (void)\n{\n    v_size = viewport.zw / vec2(cols, rows);\n\n    if (v_size.x > v_size.y)\n        v_texcoord = texcoord * vec2(v_size.x/v_size.y,1.0);\n    else\n        v_texcoord = texcoord * vec2(1.0, v_size.y/v_size.x);\n\n    vec2 position = vec2(gap)/2.0\n                  + vec2(col,row)*v_size\n                  + (texcoord + 0.5) * (v_size - vec2(gap));\n    gl_Position = projection * vec4(position, 0.0, 1.0);\n}\n""""""\n\n\ndef find_closest_direct(I, start, end, count):\n    Q = (I-start)/(end-start)*count\n    mid = ((Q[1:]+Q[:-1]+1)/2).astype(np.int)\n    boundary = np.zeros(count, np.int)\n    boundary[mid] = 1\n    return np.add.accumulate(boundary)\n\ndef compute_grid():\n    """""" Grid reference update """"""\n    n = Z.shape[1]\n\n    epsilon = 1e-10\n\n    xmin, xmax = limits2[:2]\n    t1 = major_grid[0]\n\n    start = xmin - math.fmod(xmin, t1)\n    if abs(start-xmin) < epsilon: start += t1\n    stop  = xmax - math.fmod(xmax, t1)\n    if abs(stop-xmax) < epsilon: stop -= t1\n    count = (stop-start)/t1+1\n    I = np.zeros(int(count+2))\n    I[0], I[-1] = xmin, xmax\n    I[1:-1] = np.linspace(start, stop, int(count), endpoint=True)\n    Z[..., 0] = I[find_closest_direct(I, start=xmin, end=xmax, count=n)]\n\n    t2 = minor_grid[0]\n    start = xmin - math.fmod(xmin, t2)\n    if abs(start-xmin) < epsilon: start += t2\n    stop  = xmax - math.fmod(xmax, t2)\n    if abs(stop-xmax) < epsilon: stop -= t2\n    count = (stop-start)/t2+1\n    I = np.zeros(int(count+2))\n    I[0], I[-1] = xmin, xmax\n    I[1:-1] = np.linspace(start, stop, int(count), endpoint=True)\n    Z[..., 1] = I[find_closest_direct(I, start=xmin, end=xmax, count=n)]\n\n    ymin, ymax = limits2[2:]\n\n    t1 = major_grid[1]\n    start = ymin - math.fmod(ymin, t1)\n    if abs(start-ymin) < epsilon: start += t1\n    stop  = ymax - math.fmod(ymax, t1)\n    if abs(stop-ymax) < epsilon: stop -= t1\n    count = (stop-start)/t1+1\n    I = np.zeros(int(count+2))\n    I[0], I[-1] = ymin, ymax\n    I[1:-1] = np.linspace(start, stop, int(count), endpoint=True)\n    Z[..., 2] = I[find_closest_direct(I, start=ymin, end=ymax, count=n)]\n\n    t2 = minor_grid[1]\n    start = ymin - math.fmod(ymin, t2)\n    if abs(start-ymin) < epsilon: start += t2\n    stop  = ymax - math.fmod(ymax, t2)\n    if abs(stop-ymax) < epsilon: stop -= t2\n    count = (stop-start)/t2+1\n    I = np.zeros(int(count+2))\n    I[0], I[-1] = ymin, ymax\n    I[1:-1] = np.linspace(start, stop, int(count), endpoint=True)\n    Z[..., 3] = I[find_closest_direct(I, start=ymin, end=ymax, count=n)]\n\n\n\nrows,cols = 4,4\nwindow = app.Window(width=1024, height=1024, color=(1,1,1,1))\n\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLES, indices)\n\n@window.event\ndef on_resize(width, height):\n    program[\'projection\'] = glm.ortho(0, width, 0, height, -1, +1)\n    program[\'viewport\'] = 0,0,width,height\n    compute_grid()\n    program[\'u_grid\'][...] = Z\n\n\n\nvertices = np.zeros((rows,cols,4), dtype=[(""row"",      np.float32, 1),\n                                          (""col"",      np.float32, 1),\n                                          (""texcoord"", np.float32, 2)])\nvertices = vertices.view(gloo.VertexBuffer)\n\nC,R = np.meshgrid(np.arange(cols),np.arange(rows))\nvertices[:,:][""texcoord""] = (-0.5,-0.5), (-0.5,+0.5), (+0.5,+0.5), (+0.5,-0.5)\nvertices[:,:][""row""]      = R.reshape(rows,cols,1)\nvertices[:,:][""col""]      = C.reshape(rows,cols,1)\n\nindices = np.zeros( (rows,cols, 6), dtype=np.uint32 )\nindices[:,:] = 0,1,2,0,2,3\nindices[:,:] += 4*np.arange(rows*cols,dtype=np.uint32).reshape(rows,cols,1)\nindices = indices.ravel()\nindices = indices.view(gloo.IndexBuffer)\n\n\nprogram = gloo.Program(vertex, library.get(""misc/irregular-grid.frag""))\nprogram.bind(vertices)\n\nprogram[""rows""] = rows\nprogram[""cols""] = cols\nprogram[\'u_major_grid_width\'] = 1.5\nprogram[\'u_minor_grid_width\'] = 1.0\nprogram[\'u_major_grid_color\'] = 0, 0, 0, 1.0\nprogram[\'u_minor_grid_color\'] = 0, 0, 0, 0.5\n\n# Polar projection example\nif 1:\n    limits1 = -5.1, +5.1, -5.1, +5.1\n    limits2 = 1.0, 5.0, 0.0, 2*np.pi\n    major_grid = np.array([ 1.00, np.pi/6])\n    minor_grid = np.array([ 0.25, np.pi/60])\n\n# Cartesian projection limits\nif 0:\n    limits1 = -5.1, +5.1, -5.1, +5.1\n    limits2 = -5, +5, -5, +5\n    major_grid = np.array([ 1.0, 1.0])\n    minor_grid = np.array([ 0.2, 0.2])\n\nprogram[\'u_limits1\'] = limits1\nprogram[\'u_limits2\'] = limits2\nprogram[\'u_antialias\'] = 1.0\nZ = np.zeros((1,2*1024,4), dtype=np.float32)\nprogram[\'u_grid\'] = Z\nprogram[\'u_grid\'].interpolation = gl.GL_NEAREST\n\napp.run()\n'"
examples/gloo-magnify.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\n\nvertex = """"""\n#version 120\n\nuniform vec2 mouse;\nuniform float zoom;\nattribute vec2 position;\nvarying float v_radius;\nvoid main () {\n    vec2 p = position - mouse;\n    float d = length(p);\n    p = normalize(p);\n    v_radius = 2.0;\n\n    if( d < 0.5 ) {\n        float factor;\n        float limit = 0.5;\n\n        // Compute distortion factor\n        if (d*zoom < limit) {\n            factor = d*zoom;\n            // Adapt radius to zoom level and point position\n            v_radius = 2.0 + (0.50-d)*5.0 * min((zoom-1.0)/5.0,2.0);\n        } else {\n            factor = limit +(0.5-limit)*(d*zoom-limit)/(0.5*zoom-limit);\n        }\n\n        // Compute new position\n        gl_Position = vec4(mouse + p*factor, 0.0, 1.0);\n\n    } else {\n        gl_Position = vec4(position, 0.0, 1.0);\n    }\n    gl_PointSize = 2.0*v_radius;\n}\n""""""\n\nfragment = """"""\n#version 120\n\nvec4 outline(float distance, float linewidth, float antialias, vec4 stroke, vec4 fill)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n    if( border_distance < 0.0 )\n        frag_color = stroke;\n    else if( signed_distance < 0.0 )\n        frag_color = mix(fill, stroke, sqrt(alpha));\n    else\n        frag_color = vec4(stroke.rgb, stroke.a * alpha);\n    return frag_color;\n}\n\nvarying float v_radius;\nvoid main()\n{\n    vec4 stroke = vec4(0,0,0,1);\n    vec4 fill = vec4(1,1,1,1);\n\n    float distance = length(2.0*v_radius*gl_PointCoord.xy - vec2(v_radius));;\n    gl_FragColor = outline(distance - (v_radius-1.0), 1, 1, stroke, fill);\n}\n""""""\n\nn = 25000\nwindow = app.Window(1024,1024, color=(1,1,1,1))\nprogram = gloo.Program(vertex, fragment, count=n)\nprogram[\'position\'] = np.random.normal(0.0,0.25,(n,2))\nprogram[\'zoom\'] = 2.0\n\n@window.event\ndef on_mouse_motion(x, y, dx, dy):\n    program[\'mouse\'] = (2.0*float(x)/window.width-1.0,\n                        1.0-2.0*float(y)/window.height)\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    zoom = program[\'zoom\']\n    program[\'zoom\'] = min(max(zoom *(1.0+ dy/100.0), 1.0), 50.0)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_POINTS)\n\napp.run()\n'"
examples/gloo-marker.py,12,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Position, OrthographicProjection, PanZoom\n\n# Create window\nwindow = app.Window(width=2*512, height=512, color=(1,1,1,1))\n\n# What to draw when necessary\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_POINTS)\n    program[\'orientation\'][-1] += np.pi/1024.0\n\n# Setup some markers\nn = 500+1\ndata = np.zeros(n, dtype=[(\'position\',    np.float32, 2),\n                          (\'fg_color\',    np.float32, 4),\n                          (\'bg_color\',    np.float32, 4),\n                          (\'size\',        np.float32, 1),\n                          (\'orientation\', np.float32, 1),\n                          (\'linewidth\',   np.float32, 1)])\ndata = data.view(gloo.VertexBuffer)\ndata[\'linewidth\'] = 1\ndata[\'fg_color\'] = 0, 0, 0, 1\ndata[\'bg_color\'] = 1, 1, 1, 0\ndata[\'orientation\'] = 0\nradius, theta, dtheta = 250.0, 0.0, 5.5 / 180.0 * np.pi\nfor i in range(500):\n    theta += dtheta\n    x = 256 + radius * np.cos(theta)\n    y = 256 + radius * np.sin(theta)\n    r = 10.0 - i * 0.02\n    radius -= 0.45\n    data[\'orientation\'][i] = theta - np.pi/2\n    data[\'position\'][i] = x, y\n    data[\'size\'][i] = 2 * r\n    data[\'linewidth\'][i] = 1\n\ndata[\'position\'][-1]    = 512+256, 256\ndata[\'size\'][-1]        = 512/np.sqrt(2)\ndata[\'linewidth\'][-1]   = 3.0\ndata[\'fg_color\'][-1]    = 0, 0, 0, 1\ndata[\'bg_color\'][-1]    = .95, .95, .95, 1\ndata[\'orientation\'][-1] = 0\n\nprogram = gloo.Program(""markers/marker.vert"", ""markers/marker.frag"")\nprogram.bind(data)\nprogram[\'antialias\'] = 1.00\nprogram[\'marker\']    = ""square""\nprogram[\'paint\']     = ""stroke""\ntransform = OrthographicProjection(Position(""position""))\nprogram[\'transform\'] = transform\nwindow.attach(transform)\n\napp.run()\n'"
examples/gloo-picking.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, glm\nfrom glumpy.transforms import Trackball\n\nvertex = """"""\n#include ""math/constants.glsl""\n\nuniform float linewidth;\nuniform float antialias;\n\nattribute vec4  fg_color;\nattribute vec4  bg_color;\nattribute float size;\nattribute vec3  position;\nattribute float id;\n\nvarying vec4  v_id;\nvarying float v_size;\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvoid main (void)\n{\n    // id to vec3 (alpha must be one or color will be blended\n    v_id = vec4 ( mod(floor(id / (256*256)), 256) / 255.0,\n                  mod(floor(id /     (256)), 256) / 255.0,\n                  mod(floor(id /       (1)), 256) / 255.0,\n                  1.0 );\n    v_size = size;\n    v_fg_color = fg_color;\n    v_bg_color = bg_color;\n    gl_Position = <transform(vec4(position,1.0))>;\n    gl_PointSize = M_SQRT2 * size + 2.0 * (linewidth + 1.5*antialias);\n}\n""""""\n\nfragment = """"""\n#include ""markers/disc.glsl""\n#include ""math/constants.glsl""\n#include ""antialias/antialias.glsl""\n\nuniform float linewidth;\nuniform float antialias;\n\nvarying vec4  v_id;\nvarying float v_size;\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\n\nvoid main()\n{\n    vec2 P = gl_PointCoord.xy - vec2(0.5,0.5);\n    float point_size = M_SQRT2*v_size  + 2 * (linewidth + 1.5*antialias);\n    float distance = marker_disc(P*point_size, v_size);\n    vec4 color = outline(distance, linewidth, antialias, v_fg_color, v_bg_color);\n    gl_FragData[0] = color;\n    gl_FragData[1] = v_id;\n}\n""""""\n\nquad_vertex = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    gl_Position = vec4(position,0,1);\n    v_texcoord = (position+1.0)/2.0;\n}""""""\n\nquad_fragment = """"""\nuniform sampler2D color;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    gl_FragColor = texture2D(color,v_texcoord);\n}\n""""""\n\nwindow = app.Window(width=1000, height=1000, color=(1,1,1,1))\n\nn = 5000\nprogram = gloo.Program(vertex, fragment, count=n)\nprogram[\'position\'] = 0.75 * np.random.randn(n,3)\nprogram[\'size\']     = np.random.uniform(20,30,n)\nprogram[\'fg_color\'] = 0,0,0,1\nprogram[\'bg_color\'] = np.random.uniform(0.75, 1.00, (n, 4))\nprogram[\'bg_color\'][:,3] = 1\nprogram[\'linewidth\'] = 1.0\nprogram[\'antialias\'] = 1.0\nprogram[\'transform\'] = Trackball()\nprogram[""id""] = np.arange(n,dtype=np.float32)\n\nquad = gloo.Program(quad_vertex, quad_fragment, count=4)\nquad[\'position\']= [(-1,-1), (-1,1), (1,-1), (1,1)]\n\ncolor = np.zeros((window.height,window.width,4),np.ubyte).view(gloo.Texture2D)\ncolor.interpolation = gl.GL_LINEAR\npick = np.zeros((window.height,window.width,4),np.ubyte).view(gloo.Texture2D)\npick.interpolation = gl.GL_LINEAR\nframebuffer = gloo.FrameBuffer(color=[color,pick], depth=gloo.DepthBuffer(window.width, window.height))\nquad[""color""] = color\n\nindex = 0\nmouse = 0,0\n\n@window.event\ndef on_draw(dt):\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n    framebuffer.activate()\n    window.clear()\n    program.draw(gl.GL_POINTS)\n    if mouse is not None:\n        gl.glReadBuffer(gl.GL_COLOR_ATTACHMENT1, gl.GL_FRONT)\n        r,g,b,a = gl.glReadPixels(mouse[0],mouse[1],1,1, gl.GL_RGBA, gl.GL_UNSIGNED_BYTE)\n        if type(r) is not int: r = ord(r)\n        if type(g) is not int: g = ord(g)\n        if type(b) is not int: b = ord(b)\n        index = b + 256*g + 256*256*r\n        if index < len(program):\n            program[""bg_color""][index] = 0,0,0,1\n    framebuffer.deactivate()\n    gl.glDisable(gl.GL_DEPTH_TEST)\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_resize(width, height):\n    framebuffer.resize(width,height)\n    quad[""color""] = framebuffer.color[0]\n\n@window.event\ndef on_mouse_motion(x,y, dx, dy):\n    global mouse\n    mouse = int(x), window.height-int(y)\n\n@window.event\ndef on_mouse_drag(x,y, dx, dy):\n    global mouse\n    mouse = int(x), window.height-int(y)\n\nwindow.attach(program[\'transform\'])\napp.run()\n'"
examples/gloo-quad.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gl, gloo\n\nvertex = """"""\nattribute vec2 position;\nvoid main (void)\n{\n    gl_Position = vec4(0.85*position, 0.0, 1.0);\n}\n""""""\n\nfragment = """"""\nvoid main(void)\n{\n    gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n}\n""""""\n\nwindow = app.Window(width=800, height=800)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\nquad = gloo.Program(vertex, fragment, count=4)\nquad[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\napp.run()\n'"
examples/gloo-rain.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl, glm\n\nvertex = """"""\n#version 120\n\nuniform mat4  projection;\nuniform float linewidth;\nuniform float antialias;\n\nattribute vec3  position;\nattribute vec4  color;\nattribute float size;\n\nvarying vec4  v_color;\nvarying float v_size;\n\nvoid main (void)\n{\n    v_size = size;\n    v_color = color;\n    gl_Position = projection * vec4(position,1.0);\n    gl_PointSize = size + linewidth + 2*1.5*antialias;\n}\n""""""\n\nfragment = """"""\n#version 120\n\nuniform float linewidth;\nuniform float antialias;\nvarying vec4 v_color;\nvarying float v_size;\n\nfloat disc(vec2 P, float size)\n{\n    return length((P.xy - vec2(0.5,0.5))*size);\n}\n\nvoid main()\n{\n    if( v_color.a <= 0.0)\n        discard;\n\n    float actual_size = v_size + linewidth + 2*1.5*antialias;\n    float t = linewidth/2.0 - antialias;\n    float r = disc(gl_PointCoord, actual_size);\n    float d = abs(r - v_size/2.0) - t;\n    if( d < 0.0 )\n    {\n         gl_FragColor = v_color;\n    }\n    else if( abs(d) > 2.5*antialias )\n    {\n         discard;\n    }\n    else\n    {\n        d /= antialias;\n        gl_FragColor = vec4(v_color.rgb, exp(-d*d)*v_color.a);\n    }\n}\n""""""\n\nwindow = app.Window(width=800, height=800, color=(.2,.2,.2,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_POINTS)\n\n@window.event\ndef on_resize(width, height):\n    program[\'projection\'] = glm.ortho(0, width, 0, height, -1, +1)\n\n@window.timer(1/60.)\ndef timer(fps):\n    global index\n    data[\'color\'][..., 3] -= 0.01\n    data[\'size\'] += data[\'growth\']\n    _, _, w, h = gl.glGetInteger(gl.GL_VIEWPORT)\n    data[\'position\'][index] = np.random.uniform(0,1,2)*(w,h)\n    data[\'size\'][index] = 5\n    data[\'growth\'][index] = np.random.uniform(.5,1.5)\n    data[\'color\'][index] = 1, 1, 1, 1\n    index = (index + 1) % len(data)\n\ndtype =  [(\'position\', np.float32, 2),\n          (\'color\',    np.float32, 4),\n          (\'size\',     np.float32, 1),\n          (\'growth\',   np.float32, 1)]\ndata = np.zeros(120,dtype).view(gloo.VertexBuffer)\n\nindex = 0\nprogram = gloo.Program(vertex, fragment)\nprogram.bind(data)\nprogram[\'antialias\'] = 1.00\nprogram[\'linewidth\'] = 1.00\napp.run()\n'"
examples/gloo-regular-grids.py,14,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom  glumpy import app, gl, glm, gloo, library\n\n\nvertex = """"""\nconst float gap = 4.0;\n\nuniform mat4 projection;\nuniform vec4 viewport;\nuniform float rows, cols;\n\nattribute float row, col;\nattribute vec2 texcoord;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_size;\n\nvoid main (void)\n{\n    v_size = viewport.zw / vec2(cols, rows);\n\n    if (v_size.x > v_size.y)\n        v_texcoord = texcoord * vec2(v_size.x/v_size.y,1.0);\n    else\n        v_texcoord = texcoord * vec2(1.0, v_size.y/v_size.x);\n\n    vec2 position = vec2(gap)/2.0\n                  + vec2(col,row)*v_size\n                  + (texcoord + 0.5) * (v_size - vec2(gap));\n    gl_Position = projection * vec4(position, 0.0, 1.0);\n}\n""""""\n\n\n\nrows,cols = 2,2\nwindow = app.Window(width=1024, height=1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLES, indices)\n\n@window.event\ndef on_resize(width, height):\n    program[\'projection\'] = glm.ortho(0, width, 0, height, -1, +1)\n    program[\'viewport\'] = 0,0,width,height\n\nvertices = np.zeros((rows,cols,4), dtype=[(""row"",      np.float32, 1),\n                                          (""col"",      np.float32, 1),\n                                          (""texcoord"", np.float32, 2)])\nvertices = vertices.view(gloo.VertexBuffer)\n\nC,R = np.meshgrid(np.arange(cols),np.arange(rows))\nvertices[:,:][""texcoord""] = (-0.5,-0.5), (-0.5,+0.5), (+0.5,+0.5), (+0.5,-0.5)\nvertices[:,:][""row""]      = R.reshape(rows,cols,1)\nvertices[:,:][""col""]      = C.reshape(rows,cols,1)\n\nindices = np.zeros( (rows,cols, 6), dtype=np.uint32 )\nindices[:,:] = 0,1,2,0,2,3\nindices[:,:] += 4*np.arange(rows*cols,dtype=np.uint32).reshape(rows,cols,1)\nindices = indices.ravel()\nindices = indices.view(gloo.IndexBuffer)\n\nprogram = gloo.Program(vertex, library.get(""misc/regular-grid.frag""))\nprogram.bind(vertices)\n\nprogram[""rows""] = rows\nprogram[""cols""] = cols\nprogram[\'u_major_grid_width\'] = 1.5\nprogram[\'u_minor_grid_width\'] = 1.0\nprogram[\'u_major_grid_color\'] = 0, 0, 0, 1.0\nprogram[\'u_minor_grid_color\'] = 0, 0, 0, 0.5\n\n# Polar projection example\nif 0:\n    limits1 = -5.1, +5.1, -5.1, +5.1\n    limits2 = 1.0, 5.0, 0, 2*np.pi\n    major_grid_step = np.array([ 1.00, np.pi/6])\n    minor_grid_step = np.array([ 0.25, np.pi/60])\n\n\n# Cartesian projection limits\nif 0:\n    limits1 = -5.1, +5.1, -5.1, +5.1\n    limits2 = -5, +5, -5, +5\n    major_grid_step = np.array([ 1.0, 1.0])\n    minor_grid_step = np.array([ 0.2, 0.2])\n\n# Lamber projection limits\nif 1:\n    limits1 = -2.0, +2.0, -1.5, +1.5\n    limits2 = -np.pi, +np.pi, -np.pi/2, +np.pi/2\n    major_grid_step = np.array([1.0, 0.5])*np.pi/(6*1)\n    minor_grid_step = np.array([1.0, 0.5])*np.pi/(6*5)\n\nprogram[\'u_major_grid_step\'] = major_grid_step\nprogram[\'u_minor_grid_step\'] = minor_grid_step\nprogram[\'u_limits1\'] = limits1\nprogram[\'u_limits2\'] = limits2\nprogram[\'u_antialias\'] = 1.0\n\napp.run()\n'"
examples/gloo-snippet.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import gloo\n\nA = gloo.Snippet(""uniform float a;\\nvoid function_A(void) {};\\n\\n"", name = ""Snippet_A"")\nB = gloo.Snippet(""uniform float b;\\nvoid function_B(void) {};\\n\\n"", name = ""Snippet_B"")\nC = gloo.Snippet(""uniform float c;\\nvoid function_C(void) {};\\n\\n"", name = ""Snippet_C"")\nD = A(B(""P"")) + C()\n\nprint(""D:             "", D)\nprint(""D[\'Snippet_A\']:"", D[""Snippet_A""])\nprint(""D[\'Snippet_B\']:"", D[""Snippet_B""])\nprint(""D[\'Snippet_C\']:"", D[""Snippet_C""])\n\nprint()\nprint(""D.locals: "", D.locals)\nprint(""D.globals:"", D.globals)\nprint(""D[\'Snippet_A\'].locals:"", D[""Snippet_A""].locals)\nprint(""D[\'Snippet_B\'].locals:"", D[""Snippet_B""].locals)\nprint(""D[\'Snippet_C\'].locals:"", D[""Snippet_C""].locals)\nprint(""D.symbols:"", D.symbols)\nprint()\n\n# print D.objects\n\n#print(D)\n#print([snippet._id for snippet in D.dependencies])\n\nprint(""Call:"")\nprint(D.call)\nprint()\nprint(""Code:"")\nprint(D.code)\nprint()\n'"
examples/gloo-teapot.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.geometry import primitives\nfrom glumpy.transforms import Trackball, Position\n\n\nvertex = """"""\nattribute vec3 position;\nattribute vec3 normal;\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvoid main()\n{\n    v_position = position;\n    v_normal = normal;\n    gl_Position = <transform>;\n}\n""""""\n\nfragment = """"""\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 normal;\nuniform vec3 light_color[3];\nuniform vec3 light_position[3];\nvarying vec3 v_position;\nvarying vec3 v_normal;\n\nfloat lighting(vec3 v_normal, vec3 light_position)\n{\n    // Calculate normal in world coordinates\n    vec3 n = normalize(normal * vec4(v_normal,1.0)).xyz;\n\n    // Calculate the location of this fragment (pixel) in world coordinates\n    vec3 position = vec3(view * model * vec4(v_position, 1));\n\n    // Calculate the vector from this pixels surface to the light source\n    vec3 surface_to_light = light_position - position;\n\n    // Calculate the cosine of the angle of incidence (brightness)\n    float brightness = dot(n, surface_to_light) /\n                      (length(surface_to_light) * length(n));\n    brightness = max(min(brightness,1.0),0.0);\n    return brightness;\n}\n\nvoid main()\n{\n    vec4 color = vec4(1,1,1,1);\n    vec4 l1 = vec4(light_color[0] * lighting(v_normal, light_position[0]), 1);\n    vec4 l2 = vec4(light_color[1] * lighting(v_normal, light_position[1]), 1);\n    vec4 l3 = vec4(light_color[2] * lighting(v_normal, light_position[2]), 1);\n    gl_FragColor = mix(color,(l1+l2+l3), 0.85);\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\ndef update():\n    model = teapot[\'transform\'][\'model\'].reshape(4,4)\n    view  = teapot[\'transform\'][\'view\'].reshape(4,4)\n    teapot[\'view\']  = view\n    teapot[\'model\'] = model\n    teapot[\'normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\n    \n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    teapot.draw(gl.GL_TRIANGLES, indices)\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    update()\n    \n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    update()\n\nvertices, indices = primitives.teapot()\nteapot = gloo.Program(vertex, fragment)\nteapot.bind(vertices)\ntrackball = Trackball(Position(""position""))\nteapot[\'transform\'] = trackball\ntrackball.theta, trackball.phi, trackball.zoom = 40, 135, 25\n\nteapot[""light_position[0]""] = 3, 0, 0+5\nteapot[""light_position[1]""] = 0, 3, 0+5\nteapot[""light_position[2]""] = -3, -3, +5\nteapot[""light_color[0]""]    = 1, 0, 0\nteapot[""light_color[1]""]    = 0, 1, 0\nteapot[""light_color[2]""]    = 0, 0, 1\n\nwindow.attach(teapot[\'transform\'])\napp.run()\n'"
examples/gloo-terminal.py,18,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport glumpy\nimport numpy as np\nfrom glumpy import app, gl, gloo, glm\n\nvertex = """"""\n#version 120\n\n// Uniforms\n// --------\nuniform sampler2D tex_data;\nuniform vec2 tex_size;\nuniform float char_width;\nuniform float char_height;\nuniform float rows;\nuniform float cols;\nuniform float scale;\nuniform vec4 foreground;\nuniform vec4 background;\nuniform vec2 selection;\nuniform mat4 projection;\n\n// Attributes\n// ----------\nattribute float pindex;\nattribute float gindex;\n\n// Varyings\n// --------\nvarying vec2 v_texcoord;\nvarying vec4 v_foreground;\nvarying vec4 v_background;\n\n// Main\n// ----\nvoid main (void)\n{\n    // Compute char position from pindex\n    float x = mod(pindex, cols);\n    float y = floor(pindex/cols);\n    vec2 P = (vec2(x,y) * vec2(char_width, char_height)) * scale;\n    P += vec2(char_height, char_height)*scale/2.0;\n    P += vec2(2.0, 2.0);\n    gl_Position = projection*vec4(P, 0.0, 1.0);\n    gl_PointSize = char_height * scale;\n\n    // Compute color (selection)\n    if( (pindex >= selection.x) && (pindex < selection.y))\n        v_background = vec4(v_foreground.rgb, 0.1);\n    else\n        v_background = background;\n\n    // Compute glyph tex coord from gindex\n    float n = tex_size.x/char_width;\n    x = 0.5 +  mod(gindex, n) * char_width;\n    y = 0.5 + floor(gindex/n) * char_height;\n    v_texcoord = vec2(x/tex_size.x, y/tex_size.y);\n}\n""""""\n\nfragment = """"""\n#version 120\n\n// Uniforms\n// --------\nuniform sampler2D tex_data;\nuniform vec2 tex_size;\nuniform float char_width;\nuniform float char_height;\nuniform float rows;\nuniform float cols;\nuniform float scale;\nuniform vec2 selection;\nuniform vec4 foreground;\n\n\n// Varyings\n// --------\nvarying vec2 v_texcoord;\nvarying vec4 v_background;\n\n\n// Main\n// ----\nvoid main(void)\n{\n    vec2 uv = floor(gl_PointCoord.xy * char_height);\n    if(uv.x > (char_width-1.0)) discard;\n    if(uv.y > (char_height-1.0)) discard;\n\n    float v = texture2D(tex_data, v_texcoord+uv/tex_size).r;\n    gl_FragColor = v * foreground + (1.0-v) * v_background.a;\n}\n""""""\n\n\nclass TextBuffer(object):\n    """"""\n    """"""\n\n    def __init__(self, rows=24, cols=80, x=0, y=0, scale=2):\n\n        # Build program first\n        self._program = gloo.Program(vertex, fragment)\n\n        # Build a font array that holds regular, italic & bold font\n        # Regular:      0 to   65536-1\n        # Italic :  65536 to 2*65536-1\n        # Bold :  2*65536 to 3*65536-1\n        regular = glumpy.data.get(""6x13-regular.npy"")\n        italic  = glumpy.data.get(""6x13-italic.npy"")\n        bold    = glumpy.data.get(""6x13-bold.npy"")\n        n1 = len(regular)\n        n2 = len(italic)\n        n3 = len(bold)\n        n = n1+n2+n3\n        dtype = [ (""code"", np.uint32, 1),\n                  (""data"", np.uint8, 10)]\n        font = np.zeros(n, dtype)\n        font[:n1] = regular\n        font[n1:n1+n2] = italic\n        font[n1:n1+n2][""code""] += 1*65536\n        font[n1+n2:n1+n2+n3] = bold\n        font[n1+n2:n1+n2+n3][""code""] += 2*65536\n\n        # Build a texture out of glyph arrays (need to unpack bits)\n        # This code is specific for a character size of 6x13\n        n = len(font)\n        G = np.unpackbits(font[""data""].ravel())\n        G = G.reshape(n,80)[:,:78].reshape(n,13,6)\n        width, height = 6*128, 13*((n//128)+1)\n        data = np.zeros((height,width), np.ubyte)\n        for i in range(n):\n            r = 13*(i//128)\n            c = 6*(i % 128)\n            data[r:r+13,c:c+6] = G[i]*255\n\n        # Store char codes\n        self._codes = font[""code""]\n\n        # Fill program uniforms\n        self._program[""tex_data""] = data.view(gloo.Texture2D)\n        self._program[""tex_data""].interpolation = gl.GL_NEAREST\n        self._program[""tex_data""].wrapping = gl.GL_CLAMP\n        self._program[""tex_size""] = width, height\n        self._program[""char_width""] = 6.0\n        self._program[""char_height""]= 13.0\n        self._program[""rows""] = rows\n        self._program[""cols""] = cols\n        self._program[""scale""]= int(max(1.0, scale))\n        self._program[""foreground""] = 0, 0, 0, 1\n        self._program[""background""] = 0, 0, 0, 0\n        self._program[\'selection\'] = -1,-1\n\n        # Build vertex buffer\n        self._vbuffer = np.zeros(rows*cols, [(""pindex"", np.float32, 1),\n                                             (""gindex"", np.float32, 1)])\n        self._vbuffer = self._vbuffer.view(gloo.VertexBuffer)\n        self._vbuffer[""pindex""] = np.arange(rows*cols)\n        self._vbuffer[""gindex""] = 1 # index of space in our font\n        self._program.bind(self._vbuffer)\n\n        self._rows = rows\n        self._cols = cols\n        self._scale = int(max(scale,1))\n        self._selection = None\n\n\n    def on_init(self):\n        gl.glEnable(gl.GL_VERTEX_PROGRAM_POINT_SIZE)\n        gl.glEnable(gl.GL_POINT_SPRITE)\n\n    def on_resize(self, width, height):\n        self._program[""projection""] = glm.ortho(0, width, height, 0, -1, +1)\n\n    def draw(self):\n        self._program.draw(gl.GL_POINTS)\n\n    def __contains__(self, xy):\n        (x,y) = xy\n        width = self._cols*self._scale*6\n        height = self._rows*self._scale*13\n        if 0 <= x < width and 0 <= y < height:\n            return True\n        return False\n\n    @property\n    def scale(self):\n        """""" Font scale """"""\n\n        return self._scale\n\n    @property\n    def rows(self):\n        """""" Number of rows """"""\n\n        return self._rows\n\n    @property\n    def cols(self):\n        """""" Number of columns """"""\n\n        return self._cols\n\n    @property\n    def selection_bounds(self):\n        """""" Selection bounds """"""\n\n        start,end = self._selection\n        if end < start:\n            start,end = end,start\n        return max(0, start), min(self.rows*self.cols, end)\n\n\n    def clear(self, start=0, end=-1):\n        """"""\n        Clear the text buffer\n        """"""\n\n        self._vbuffer[""gindex""] = 1 # index of space in our font\n        self.clear_selection()\n\n\n    def clear_selection(self):\n        """"""\n        Clear current selection\n        """"""\n\n        self._selection = None\n        self._program[""selection""] = -1,-1\n\n\n    def put(self, row, col, text, style=0):\n        """""" Put text at (row,col) """"""\n\n        # Make style argument is of the right type\n        style = np.atleast_1d(style)\n        index = row*self.cols + col\n\n        # Decode text\n        if isinstance(text, str):\n            text = str(text)\n            codes = np.array([ord(c) for c in text]).astype(np.uint32)\n        else:\n            codes = text.astype(np.uint32).ravel()\n\n        # Crop if necessary\n        n = len(codes)\n        imax = self.rows*self.cols\n        if index + n > imax:\n            n = imax - index\n            codes = codes[:n]\n            style = style[:n]\n\n        # Tweak code to take style into account\n        codes += np.uint32(style*65536)\n\n        # Replace unknown glyphs with glyph 0\n        codes *= np.in1d(codes, self._codes)\n\n        # Put glyphs data into buffer\n        self._vbuffer[""gindex""][index:index+n] = np.searchsorted(self._codes, codes)\n\n\n\n\n# -----------------------------------------------------------------------------\nclass Console(TextBuffer):\n\n    def __init__(self, rows=24, cols=80, x=3, y=3, scale=2, cache=1000):\n        TextBuffer.__init__(self, rows, cols, x, y, scale)\n\n        # We use a ring buffer to avoid to have to move things around\n        self._buffer_start = 0\n        self._buffer_end = 0\n        cache = max(cache, rows)\n        self._buffer = np.ones((cache+rows,cols),\n                               dtype=[(""code"",       np.uint16,  1),\n                                      (""style"",      np.uint16,  1)])\n        self._buffer[""code""] = 32 # space\n        self._scroll = -self.rows\n        self._default_foreground = 0,0,0,1 # Black\n        self._default_background = 0,0,0,0 # Transparent black\n        self._default_style      = 0       # Regular\n        self._buffer[""style""]      = self._default_style\n\n\n\n    def write(self, text="""", style=None):\n        """""" Write at current position into the buffer and rotate buffer """"""\n\n        if style is None:\n            style = self._default_style\n\n        n = len(self._buffer)\n        empty = 32, 0\n\n        # Clear line\n        self._buffer[self._buffer_end] = empty\n\n        # Write line\n        self._buffer[""code""][self._buffer_end,:len(text)] = [ord(c) for c in text]\n        self._buffer[""style""][self._buffer_end,:len(text)] = style\n\n        # Clear line beyond row lines in case use want to have only the first\n        # line on top (or else we would display buffer start)\n        self._buffer[(self._buffer_end+self.rows) % n] = empty\n\n        self._buffer_end = (self._buffer_end + 1) % n\n        if self._buffer_end == self._buffer_start:\n            self._buffer_start = (self._buffer_start + 1) % n\n\n        # Update text buffer\n        # V = self.view(int(self._scroll))\n        # self.put(0, 0, text=V[""code""])\n\n        # Update selection if any\n        if self._selection is not None:\n            start, end = self._selection\n            start += self._scroll*self.cols\n            end   += self._scroll*self.cols\n            if end < start:\n                self._program[""selection""] = end, start\n            else:\n                self._program[""selection""] = start, end\n\n\n    def on_mouse_press(self, x, y, button):\n        """""" Selection start point (taking scroll into account) """"""\n\n        if (x,y) in self:\n            x = x // ( 6*self._scale)\n            y = y // (13*self._scale)\n            s = (int(self._scroll)+self.rows)*self.cols\n\n            start = y*self.cols + x\n            self._selection = start+s, start+s\n            self._program[""selection""] = start, start\n\n\n    def on_mouse_drag(self, x, y, dx, dy, button):\n        """""" Selection end point (taking scroll into account) """"""\n\n        if self._selection is not None:\n            x = x // ( 6*self._scale)\n            y = y // (13*self._scale)\n            s = (int(self._scroll)+self.rows)*self.cols\n\n            start = self._selection[0]\n            end = (y*self.cols+x) + s\n            self._selection = start, end\n\n            if end < start:\n                self._program[""selection""] = end-s, start-s\n            else:\n                self._program[""selection""] = start-s, end-s\n\n\n    def on_mouse_scroll(self, x, y, dx, dy):\n        # Count how many lines have been writen so far\n        if self._buffer_end > self._buffer_start:\n            n = self._buffer_end\n        else:\n            n = len(self._buffer) - self.rows\n        self._scroll = min(max(self._scroll-dy,-n),-1)\n\n        # Update text buffer\n        #V = self.view(int(self._scroll))\n        #self.put(0, 0, text=V[""code""])\n\n        # Update selection if any\n        if self._selection is not None:\n            start, end = self._selection\n            start -= (int(self._scroll)+self.rows)*self.cols\n            end   -= (int(self._scroll)+self.rows)*self.cols\n            self._program[""selection""] = start, end\n\n    def draw(self):\n        V = self.view(int(self._scroll))\n        self.put(0, 0, text=V[""code""])\n        TextBuffer.draw(self)\n\n\n    def clear(self):\n        TextBuffer.clear(self)\n        self._buffer_start = 0\n        self._buffer_end = 0\n        self._buffer[...] = 32,0\n\n    def view(self, index=-1):\n        """""" Retrieve a view of the buffer starting at index """"""\n\n        # Count how many lines have been writen so far\n        if self._buffer_end > self._buffer_start:\n            n = self._buffer_end\n        else:\n            n = len(self._buffer) - self.rows\n\n        actual_index = min(max(index, -n),-1)\n        start = (self._buffer_end + actual_index) % len(self._buffer)\n        stop = start + self.rows\n        indices = np.mod(np.arange(start, stop), len(self._buffer))\n        return self._buffer[indices].ravel()\n\n\n\n\n# -----------------------------------------------------------------------------\nif __name__ == \'__main__\':\n    console = Console(24,80,scale=2)\n    window = app.Window(width=console.cols*console.scale*6,\n                        height=console.rows*console.scale*13,\n                        color = (1,1,1,1))\n\n    @window.event\n    def on_draw(dt):\n        window.clear(), console.draw()\n\n    import codecs\n    f = codecs.open(""UTF-8-demo.txt"", ""r"", ""utf-8"")\n    # f = codecs.open(""TeX.txt"", ""r"", ""utf-8"")\n    lines = f.readlines()\n    for line in lines:\n        console.write(line[:-1])\n\n    # @window.timer(1/30.0)\n    def timer(fps):\n        console.clear()\n        console.write(""\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80"")\n        console.write(""GLUMPY 2.0 - Copyright (c) 2014 Nicolas P. Rougier"")\n        console.write("""")\n        console.write("" \xe2\x86\x92 Window size: %dx%d"" % (window.width, window.height))\n        console.write("" \xe2\x86\x92 Backend: %s (%s)"" % (window._backend.__name__,\n                                              window._backend.__version__))\n        console.write("" \xe2\x86\x92 Console size: %dx%d"" % (console.rows, console.cols))\n        console.write("" \xe2\x86\x92 Actual FPS: %.2f frames/second  "" % (app.fps()))\n        console.write(""\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80"")\n        #for line in repr(window.config).split(""\\n""):\n        #    console.write(u"" ""+line)\n        #console.write(u""\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80"")\n\n    window.attach(console)\n    app.run()\n'"
examples/gloo-texture-1D.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\n    uniform sampler1D texture;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        float r = texture1D(texture, v_texcoord.x).r;\n        gl_FragColor = vec4(r,r,r,1);\n    }\n""""""\n\nwindow = app.Window(width=512, height=512)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\nquad = gloo.Program(vertex, fragment, count=4)\nquad[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nquad[\'texcoord\'] = [( 0, 1), ( 0, 0), ( 1, 1), ( 1, 0)]\nquad[\'texture\'] = np.linspace(0.0,1.0,256)\n\napp.run()\n'"
examples/gloo-texture-2D.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\n    uniform sampler2D texture;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        float r = texture2D(texture, v_texcoord).r;\n        gl_FragColor = vec4(r,r,r,1);\n    }\n""""""\n\ndef checkerboard(grid_num=8, grid_size=32):\n    row_even = grid_num // 2 * [0, 1]\n    row_odd = grid_num // 2 * [1, 0]\n    Z = np.row_stack(grid_num // 2 * (row_even, row_odd)).astype(np.uint8)\n    return 255 * Z.repeat(grid_size, axis=0).repeat(grid_size, axis=1)\n\nwindow = app.Window(width=512, height=512)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\nquad = gloo.Program(vertex, fragment, count=4)\nquad[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nquad[\'texcoord\'] = [( 0, 1), ( 0, 0), ( 1, 1), ( 1, 0)]\nquad[\'texture\'] = checkerboard()\napp.run()\n'"
examples/gloo-trace.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Position, OrthographicProjection, PanZoom\n\n# Create window\nwindow = app.Window(width=1024, height=512)\n\nquad_vertex = """"""\nattribute vec2 position;\nvoid main (void) { gl_Position = vec4(position,0,1); }\n""""""\nquad_fragment = """"""\nvoid main(void) { gl_FragColor = vec4(1,1,1,1.0/128.0); }\n""""""\nline_vertex = """"""\nattribute vec2 position;\nvoid main (void) { gl_Position = vec4(position,0,1); }\n""""""\nline_fragment = """"""\nvoid main(void) { gl_FragColor = vec4(0,0,0,1); }\n""""""\n\n\n@window.event\ndef on_draw(dt):\n    global time\n\n    time += np.random.uniform(0,dt)\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n    line.draw(gl.GL_LINE_STRIP)\n    window.swap()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n    line.draw(gl.GL_LINE_STRIP)\n\n    X = line[""position""][:,0]\n    scale = np.random.uniform(0.1,0.5)\n    frequency = np.random.uniform(3,5)\n    noise = 0.01*np.random.uniform(-1,+1,n)\n    line[""position""][:,1] = scale*np.cos(frequency*X + time) + noise\n\n@window.event\ndef on_init():\n    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_DST_ALPHA)\n\n@window.event\ndef on_resize(width, height):\n    window.clear()\n    window.swap()\n    window.clear()\n\n\nn = 512\nline = gloo.Program(line_vertex, line_fragment, count=n)\nline[""position""][:,0] = np.linspace(-1,1,n)\nline[""position""][:,1] = np.random.uniform(-0.5,0.5,n)\n\nquad = gloo.Program(quad_vertex, quad_fragment, count=4)\nquad[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\n\ntime = 0\napp.run()\n'"
examples/gloo-trail.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport sys\nimport numpy as np\n\nimport glumpy\nimport glumpy.gl as gl\nimport glumpy.app as app\nimport glumpy.glm as glm\nimport glumpy.gloo as gloo\n\n\nvertex = """"""\n#version 120\n\nuniform mat4  u_projection;\nuniform float u_linewidth;\nuniform float u_antialias;\n\nattribute vec3  a_position;\nattribute vec4  a_fg_color;\nattribute float a_size;\n\nvarying vec4  v_fg_color;\nvarying float v_size;\n\nvoid main (void)\n{\n    v_size = a_size;\n    v_fg_color = a_fg_color;\n    if( a_fg_color.a > 0.0)\n    {\n        gl_Position = u_projection * vec4(a_position,1.0);\n        gl_PointSize = v_size + u_linewidth + 2*1.5*u_antialias;\n    }\n    else\n    {\n        gl_Position = u_projection * vec4(-1,-1,0,1);\n        gl_PointSize = 0.0;\n    }\n}\n""""""\n\nfragment = """"""\n#version 120\n\nuniform float u_linewidth;\nuniform float u_antialias;\nvarying vec4 v_fg_color;\nvarying vec4 v_bg_color;\nvarying float v_size;\nfloat disc(vec2 P, float size)\n{\n    return length((P.xy - vec2(0.5,0.5))*size);\n}\nvoid main()\n{\n    if( v_fg_color.a <= 0.0)\n        discard;\n    float actual_size = v_size + u_linewidth + 2*1.5*u_antialias;\n    float t = u_linewidth/2.0 - u_antialias;\n    float r = disc(gl_PointCoord, actual_size);\n    float d = abs(r - v_size/2.0) - t;\n    if( d < 0.0 )\n    {\n         gl_FragColor = v_fg_color;\n    }\n    else if( abs(d) > 2.5*u_antialias )\n    {\n         discard;\n    }\n    else\n    {\n        d /= u_antialias;\n        gl_FragColor = vec4(v_fg_color.rgb, exp(-d*d)*v_fg_color.a);\n    }\n}\n""""""\n\n\nwindow = app.Window(width=800, height=800,\n                    color=(0.2, 0.2, 0.2, 1.0))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_POINTS)\n\n@window.event\ndef on_resize(width, height):\n    program[\'u_projection\'] = glm.ortho(0, width, 0, height, -1, +1)\n\n@window.timer(1/60.)\ndef timer(fps):\n    data[\'a_fg_color\'][..., 3] -= 0.01\n    data[\'a_size\'] += 1.0\n\n@window.event\ndef on_mouse_motion(x, y, dx, dy):\n    global index\n    _, _, _, h = gl.glGetInteger(gl.GL_VIEWPORT)\n    data[\'a_size\'][index] = 25\n    data[\'a_position\'][index] = x, h - y\n    data[\'a_fg_color\'][index] = 1, 1, 1, 1\n    index = (index + 1) % len(data)\n\ndata = np.zeros(150, [(\'a_position\', np.float32, 2),\n                      (\'a_fg_color\', np.float32, 4),\n                      (\'a_size\',     np.float32, 1)])\ndata = data.view(gloo.VertexBuffer)\n\nindex = 0\nprogram = gloo.Program(vertex, fragment)\nprogram.bind(data)\nprogram[\'u_antialias\'] = 1.00\nprogram[\'u_linewidth\'] = 1.00\n\napp.run(framerate=60)\n'"
examples/gloo-triangular-grid.py,2,"b""# -----------------------------------------------------------------------------\n# Copyright (c) 2015, Dzhelil S. Rufat. All Rights Reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\n\nfrom glumpy import app, gloo, gl\nimport triangle\n\nA = dict(vertices=np.array(((-1, -1), (1, -1), (1, 1), (-1, 1))))\nB = triangle.triangulate(A, 'qa0.01')\nvertices = B['vertices']\nindices = B['triangles']\n\nvertex = '''\n    attribute vec2 a_position;\n    void main()\n    {\n        gl_Position = vec4(a_position, 0.0, 1.0);\n    }\n'''\n\nfragment = '''\n    void main()\n    {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n'''\n\nprogram = gloo.Program(vertex, fragment)\nprogram['a_position'] = vertices\n\nwindow = app.Window(width=512, height=512, color=(1, 1, 1, 1))\n\n\n@window.event\ndef on_draw(_):\n    window.clear()\n    gl.glLineWidth(2)\n    gl.glPolygonMode(gl.GL_FRONT_AND_BACK, gl.GL_LINE)\n    gl.glEnable(gl.GL_LINE_SMOOTH)\n    program.draw(gl.GL_TRIANGLES, indices.reshape(-1).astype(np.uint32).view(gloo.IndexBuffer))\n\n\napp.run()\n"""
examples/gloo-two-vertex-arrays.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n#\n# modified examples/tutorial/quad-simple.py\nfrom glumpy import app, gloo, gl\nimport numpy as np\n\nvertex = """"""\n  uniform float scale;\n  in vec2 position;\n  in vec4 color;\n  out vec4 v_color;\n  void main()\n  {\n    gl_Position = vec4(scale*position, 0.0, 1.0);\n    v_color = color;\n  } """"""\n\nfragment = """"""\n  in vec4 v_color;\n  out vec4 FragColor;\n  void main()\n  {\n      FragColor = v_color;\n  } """"""\n\napp.use(\'glfw\', api=\'GL\', major=3, minor=3, profile=\'core\')\n\n# Create a window with a valid GL context\nwindow = app.Window()\n\n# Build the program and corresponding buffers (with 4 vertices)\nquad = gloo.Program(vertex, fragment, count=4, version=""330"")\ndtype = [(\'color\', np.float32, 4),\n         (\'position\', np.float32, 2)]\nquad_arrays_0 = np.zeros(4, dtype).view(gloo.VertexArray)\n# Four colors\nquad_arrays_0[\'color\'] = [ (1,0,0,1), (0,1,0,1), (0,0,1,1), (1,1,0,1) ]\nquad_arrays_0[\'position\'] = [ (-1,-1),   (-1,+1),   (+1,-1),   (+1,+1)   ]\n\nquad_arrays_1 = np.zeros(4, dtype).view(gloo.VertexArray)\n# All red data\nquad_arrays_1[\'color\'] = [ (1,0,0,1), (1,0,0,1), (1,0,0,1), (1,0,0,1) ]\nquad_arrays_1[\'position\'] = [ (-1,-1),   (-1,+1),   (+1,-1),   (+1,+1)   ]\n\nquad[\'scale\'] = 1.0\n\n\n# Tell glumpy what needs to be done at each redraw\ncount = 0\n@window.event\ndef on_draw(dt):\n    global count\n    window.clear()\n    if count % 2 == 0:\n        quad.bind(quad_arrays_0)\n        quad.draw(gl.GL_TRIANGLE_STRIP)\n    else:\n        quad.bind(quad_arrays_1)\n        quad.draw(gl.GL_TRIANGLE_STRIP)\n    count += 1\n\n# Run the app\napp.run(framerate=1)\n'"
examples/gpuimage.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2015, Vispy Development Team. All Rights Reserved.\n# Copyright (c) 2015, Dzhelil Rufat. All Rights Reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nIllustrate how to plot a 2D function (an image) y=f(x,y) on the GPU.\n""""""\n\nfrom glumpy import app, gl, gloo\n\nvertex = """"""\nattribute vec2 a_position;\nvarying vec2 v_position;\nvoid main()\n{\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_position = a_position;\n}\n""""""\n\nfragment = """"""\n#include ""math/constants.glsl""\n#include ""colormaps/jet.glsl""\nuniform float u_time;\nvarying vec2 v_position;\n\n/**********************************************************\nSpecify the parameters here.\n**********************************************************/\nconst float z_offset = 1.; // (z+z_offset)/z_max should be in [0,1]\nconst float z_max    = 2.;\nconst float x_scale  = 5.; // x is between -x_scale and +x_scale\nconst float y_scale  = 5.; // y is between -y_scale and +y_scale\nconst float t_scale  = 5.; // scale for the time\n/*********************************************************/\n\n// x is in [-x_scale, +x_scale]\n// y is in [-y_scale, +y_scale]\n// t is in [0, +oo)\n\n\nfloat f(float x, float y, float t) {\n\n    float k = .25*cos(t);\n    return (cos(x)+k)*(sin(y)-k);\n\n}\n\nvoid main() {\n\n    vec2 pos = v_position;\n    float z = f(x_scale * pos.x, y_scale * pos.y, t_scale * u_time);\n    vec3 c = colormap_jet((z + z_offset) / (z_max));\n    gl_FragColor = vec4(c, 1.0);\n\n}\n""""""\n\nprogram = gloo.Program(vertex, fragment)\nprogram[\'a_position\'] = [(-1., -1.), (-1., +1.),\n                         (+1., -1.), (+1., +1.)]\nprogram[\'u_time\'] = 0.0\n\nwindow = app.Window(width=800, height=800)\n\n\n@window.event\ndef on_draw(dt):\n    program.draw(gl.GL_TRIANGLE_STRIP)\n    program[\'u_time\'] += dt\n\n\napp.run()\n'"
examples/graph.py,22,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport sys\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\nfrom glumpy import app, collections\nfrom glumpy.transforms import Position, OrthographicProjection, Viewport\n\nwindow = app.Window(width=800, height=800, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    segments.draw()\n    markers.draw()\n\n@window.event\ndef on_mouse_press(x, y, button):\n    global N, selected\n\n    D = N - [x, window.height-y, 0]\n    D = np.sqrt((D**2).sum(axis=1))\n    selected = np.argmin(D)\n    if D[selected] > 10:\n        selected = -1\n\n@window.event\ndef on_mouse_release(x, y, button):\n    global selected\n    selected = -1\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    global N, selected\n    if selected > -1 :\n        N[selected] = x,window.height-y,0\n\n@window.timer(1.0/60.0)\ndef on_timer(dt):\n    global N, A, S, src, tgt\n\n    X,Y, XY = N[:,0], N[:,1], N[:,:2]\n    XY_ = XY.copy()\n\n    # To be adpated depending on the topology of the graph\n    attraction = 0.4\n    repulsion = 25\n    length = 30\n\n    # Global nodes centering\n    # ----------------------\n    x,y = window.width/2, window.height/2\n    XY += 0.01*([x,y] - XY)\n\n    # Linked nodes attraction\n    # -----------------------\n    D = N[src]- N[tgt]\n    L = np.maximum(np.sqrt((D*D).sum(axis=1)),1)\n    L = (L - length)/L\n    D *= attraction*L[:,np.newaxis]\n    X -= .5*np.bincount(src, D[:,0], minlength=len(N))\n    Y -= .5*np.bincount(src, D[:,1], minlength=len(N))\n    X += .5*np.bincount(tgt, D[:,0], minlength=len(N))\n    Y += .5*np.bincount(tgt, D[:,1], minlength=len(N))\n\n    # Global nodes repulsion\n    # ----------------------\n    dist = np.maximum(cdist(XY,XY,\'sqeuclidean\'),1)\n    D = np.empty((len(N),len(N),2))\n    D[...,0] = np.subtract.outer(X,X)/dist\n    D[...,1] = np.subtract.outer(Y,Y)/dist\n    R = D.sum(axis=1)\n    XY += repulsion*R/np.sqrt(((R*R).sum(axis=0)))\n\n    # Cancel move for selected node\n    # -----------------------------\n    if selected > -1:\n        XY[selected] = XY_[selected]\n\n    # Update markers and segments\n    # ---------------------------\n    markers[""position""] = N\n    segments[""P0""] = np.repeat(N[src],4,axis=0)\n    segments[""P1""] = np.repeat(N[tgt],4,axis=0)\n\n\n# Simple graph\n# n = 11\n# N = np.random.uniform(150, 650, (n,3)) * (1,1,0)\n# A = np.zeros((n,n))\n# A[[0,1,2,3,0,1,3,4,5,6,7,8, 9,10, 8,7],\n#   [1,2,3,0,2,3,4,5,6,7,8,9,10, 7,10,9] ] = 1\n\n# # Random graph\n# n = 250\n# N = np.random.uniform(0, 800, (n,3)) * (1,1,0)\n# A = (cdist(N[:,:2],N[:,:2]) < 75)\n# N = np.random.uniform(390, 410, (n,3)) * (1,1,0)\n\n# Balanced graph\ndepth,branch = 4, 3\n# sum of geometric series r!=1\nn = int((1-branch**(depth+1))/(1-branch)) if branch > 1 else 2\nN = np.random.uniform(0, 800, (n,3)) * (1,1,0)\nA = np.zeros((n,n), dtype=bool)\nnodes=iter(range(n))\nparents=[next(nodes)]\nwhile parents:\n    source=parents.pop(0)\n    for i in range(branch):\n        try:\n            target=next(nodes)\n            parents.append(target)\n            A[source,target] = 1\n        except StopIteration:\n            break\n\n# Current selected node\nselected = -1\n\n# Get edges\nsrc,tgt = np.nonzero(A)\n\ntransform = OrthographicProjection(Position(), aspect=None)\nviewport = Viewport()\n\n\nmarkers = collections.MarkerCollection(marker=\'disc\', transform=transform, viewport=viewport)\nmarkers.append(N, size=15, linewidth=2, itemsize=1,\n               fg_color=(1,1,1,1), bg_color=(1,.5,.5,1))\nsegments = collections.SegmentCollection(\'agg\', transform=transform, viewport=viewport)\nsegments.append(N[src], N[tgt], linewidth=1.0, itemsize=1,\n                color=(0.75,0.75,0.75,1.00))\n\nwindow.attach(transform)\nwindow.attach(viewport)\n\napp.run()\n'"
examples/grayscott.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\n\n\nrender_vertex = """"""\nattribute vec2 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n    v_texcoord = texcoord;\n}\n""""""\n\nrender_fragment = """"""\nuniform int pingpong;\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    float v;\n    if( pingpong == 0 )\n        v = texture2D(texture, v_texcoord).r;\n    else\n        v = texture2D(texture, v_texcoord).b;\n    gl_FragColor = vec4(1.0-v, 1.0-v, 1.0-v, 1.0);\n}\n""""""\n\ncompute_vertex = """"""\nattribute vec2 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n    v_texcoord = texcoord;\n}\n""""""\n\ncompute_fragment = """"""\nuniform int pingpong;\nuniform sampler2D texture; // U,V:= r,g, other channels ignored\nuniform sampler2D params;  // rU,rV,f,k := r,g,b,a\nuniform float dx;          // horizontal distance between texels\nuniform float dy;          // vertical distance between texels\nuniform float dd;          // unit of distance\nuniform float dt;          // unit of time\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    float center = -(4.0+4.0/sqrt(2.0));  // -1 * other weights\n    float diag   = 1.0/sqrt(2.0);         // weight for diagonals\n    vec2 p = v_texcoord;                  // center coordinates\n\n    vec2 c,l;\n    if( pingpong == 0 ) {\n        c = texture2D(texture, p).rg;    // central value\n        // Compute Laplacian\n        l = ( texture2D(texture, p + vec2(-dx,-dy)).rg\n            + texture2D(texture, p + vec2( dx,-dy)).rg\n            + texture2D(texture, p + vec2(-dx, dy)).rg\n            + texture2D(texture, p + vec2( dx, dy)).rg) * diag\n            + texture2D(texture, p + vec2(-dx, 0.0)).rg\n            + texture2D(texture, p + vec2( dx, 0.0)).rg\n            + texture2D(texture, p + vec2(0.0,-dy)).rg\n            + texture2D(texture, p + vec2(0.0, dy)).rg\n            + c * center;\n    } else {\n        c = texture2D(texture, p).ba;    // central value\n        // Compute Laplacian\n        l = ( texture2D(texture, p + vec2(-dx,-dy)).ba\n            + texture2D(texture, p + vec2( dx,-dy)).ba\n            + texture2D(texture, p + vec2(-dx, dy)).ba\n            + texture2D(texture, p + vec2( dx, dy)).ba) * diag\n            + texture2D(texture, p + vec2(-dx, 0.0)).ba\n            + texture2D(texture, p + vec2( dx, 0.0)).ba\n            + texture2D(texture, p + vec2(0.0,-dy)).ba\n            + texture2D(texture, p + vec2(0.0, dy)).ba\n            + c * center;\n    }\n\n    float u = c.r;           // compute some temporary\n    float v = c.g;           // values which might save\n    float lu = l.r;          // a few GPU cycles\n    float lv = l.g;\n    float uvv = u * v * v;\n\n    vec4 q = texture2D(params, p).rgba;\n    float ru = q.r;          // rate of diffusion of U\n    float rv = q.g;          // rate of diffusion of V\n    float f  = q.b;          // some coupling parameter\n    float k  = q.a;          // another coupling parameter\n\n    float du = ru * lu / dd - uvv + f * (1.0 - u); // Gray-Scott equation\n    float dv = rv * lv / dd + uvv - (f + k) * v;   // diffusion+-reaction\n\n    u += du * dt;\n    v += dv * dt;\n\n    if( pingpong == 1 ) {\n        gl_FragColor = vec4(clamp(u, 0.0, 1.0), clamp(v, 0.0, 1.0), c);\n    } else {\n        gl_FragColor = vec4(c, clamp(u, 0.0, 1.0), clamp(v, 0.0, 1.0));\n    }\n}\n""""""\n\n\nwindow = app.Window(width=1024, height=1024)\ncwidth,cheight = 256, 256\n\n@window.event\ndef on_draw(dt):\n    global pingpong\n\n    pingpong = 1 - pingpong\n    compute[""pingpong""] = pingpong\n    render[""pingpong""] = pingpong\n\n    gl.glDisable(gl.GL_BLEND)\n\n    framebuffer.activate()\n    gl.glViewport(0, 0, cwidth, cheight)\n    compute.draw(gl.GL_TRIANGLE_STRIP)\n    framebuffer.deactivate()\n\n    gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n    gl.glViewport(0, 0, window.width, window.height)\n    render.draw(gl.GL_TRIANGLE_STRIP)\n\n\ndt = 1.0\ndd = 1.5\nw,h = cwidth, cheight\nspecies = {\n    # name : [r_u, r_v, f, k]\n    \'Bacteria 1\': [0.16, 0.08, 0.035, 0.065],\n    \'Bacteria 2\': [0.14, 0.06, 0.035, 0.065],\n    \'Coral\': [0.16, 0.08, 0.060, 0.062],\n    \'Fingerprint\': [0.19, 0.05, 0.060, 0.062],\n    \'Spirals\': [0.10, 0.10, 0.018, 0.050],\n    \'Spirals Dense\': [0.12, 0.08, 0.020, 0.050],\n    \'Spirals Fast\': [0.10, 0.16, 0.020, 0.050],\n    \'Unstable\': [0.16, 0.08, 0.020, 0.055],\n    \'Worms 1\': [0.16, 0.08, 0.050, 0.065],\n    \'Worms 2\': [0.16, 0.08, 0.054, 0.063],\n    \'Zebrafish\': [0.16, 0.08, 0.035, 0.060] }\nP = np.zeros((h, w, 4), dtype=np.float32)\nP[:, :] = species[\'Unstable\']\n\nP[:, :] = species[\'Coral\']\n\nUV = np.zeros((h, w, 4), dtype=np.float32)\nUV[:, :, 0] = 1.0\nr = 32\nUV[h//2-r:h//2+r,w//2-r:w//2+r,0] = 0.50\nUV[h//2-r:h//2+r,w//2-r:w//2+r,1] = 0.25\nUV += np.random.uniform(0.00, 0.01, (h, w, 4))\nUV[:,:,2] = UV[:,:,0]\nUV[:,:,3] = UV[:,:,1]\n\npingpong = 1\ncompute = gloo.Program(compute_vertex, compute_fragment, count=4)\ncompute[""params""] = P\ncompute[""texture""] = UV\ncompute[""texture""].interpolation = gl.GL_NEAREST\ncompute[""texture""].wrapping = gl.GL_CLAMP_TO_EDGE\ncompute[""position""] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]\ncompute[""texcoord""] = [(0, 0), (0, 1), (1, 0), (1, 1)]\ncompute[\'dt\'] = dt\ncompute[\'dx\'] = 1.0 / w\ncompute[\'dy\'] = 1.0 / h\ncompute[\'dd\'] = dd\ncompute[\'pingpong\'] = pingpong\n\nrender = gloo.Program(render_vertex, render_fragment, count=4)\nrender[""position""] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]\nrender[""texcoord""] = [(0, 0), (0, 1), (1, 0), (1, 1)]\nrender[""texture""] = compute[""texture""]\nrender[""texture""].interpolation = gl.GL_LINEAR\nrender[""texture""].wrapping = gl.GL_CLAMP_TO_EDGE\nrender[\'pingpong\'] = pingpong\n\nframebuffer = gloo.FrameBuffer(color=compute[""texture""],\n                               depth=gloo.DepthBuffer(w, h))\n\n\napp.run(framerate=0)\n'"
examples/heatmap.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, library\nfrom glumpy.transforms import PanZoom, Position\n\nvertex = """"""\n    uniform vec4 viewport;\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    varying vec2 v_pixcoord;\n    varying vec2 v_quadsize;\n    void main()\n    {\n        gl_Position = <transform>;\n        v_texcoord = texcoord;\n        v_quadsize = viewport.zw * <transform.panzoom_scale>;\n        v_pixcoord = texcoord * v_quadsize;\n    }\n""""""\n\nfragment = """"""\n#include ""markers/markers.glsl""\n#include ""antialias/antialias.glsl""\n\nuniform sampler2D data;\nuniform vec2 data_shape;\nvarying vec2 v_texcoord;\nvarying vec2 v_quadsize;\nvarying vec2 v_pixcoord;\n\nvoid main()\n{\n    float rows = data_shape.x;\n    float cols = data_shape.y;\n    float v = texture2D(data, v_texcoord).r;\n\n    vec2 size = v_quadsize / vec2(cols,rows);\n    vec2 center = (floor(v_pixcoord/size) + vec2(0.5,0.5)) * size;\n    float d = marker_square(v_pixcoord - center, .9*size.x);\n    gl_FragColor = filled(d, 1.0, 1.0, vec4(v,v,v,1));\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.reset()\n\n@window.event\ndef on_resize(width, height):\n    program[\'viewport\'] = 0, 0, width, height\n\nprogram = gloo.Program(vertex, fragment, count=4)\n\nn = 64\nprogram[\'position\'] = [(-1,-1), (-1,1), (1,-1), (1,1)]\nprogram[\'texcoord\'] = [( 0, 1), ( 0, 0), ( 1, 1), ( 1, 0)]\nprogram[\'data\'] = np.random.uniform(0,1,(n,n))\nprogram[\'data_shape\'] = program[\'data\'].shape[:2]\ntransform = PanZoom(Position(""position""),aspect=1)\n\nprogram[\'transform\'] = transform\nwindow.attach(transform)\napp.run()\n'"
examples/hello-world.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gl, gloo, glm, data\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.graphics.collections import GlyphCollection\nfrom glumpy.transforms import Position, OrthographicProjection\n\nwindow = app.Window(width=512, height=512)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    label.draw()\n\nx,y,z = 256,256,0\nfont = FontManager.get(""OpenSans-Regular.ttf"", 64, mode=\'agg\')\nlabel = GlyphCollection(\'agg\', transform=OrthographicProjection(Position()))\nlabel.append(""Hello World !"", font,\n                   anchor_x = \'center\', anchor_y = \'center\',\n                   origin=(x,y,z), color=(1,1,1,1))\n\nwindow.attach(label[""transform""])\n\napp.run()\n'"
examples/high-frequency.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# High frequency (below pixel resolution) function plot\n#\n#  -> http://blog.hvidtfeldts.net/index.php/2011/07/plotting-high-frequency-functions-using-a-gpu/\n#  -> https://www.shadertoy.com/view/4sB3zz\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\n\nvertex = """"""\nattribute vec2 position;\nvoid main (void)\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n""""""\n\nfragment = """"""\nuniform vec2 iResolution;\nuniform float iGlobalTime;\n\n// --- Your function here ---\nfloat function( float x )\n{\n    float d = 3.0 - 2.0*(1.0+cos(iGlobalTime/5.0))/2.0;\n    return sin(pow(x,d))*sin(x);\n}\n// --- Your function here ---\n\n\nfloat sample(vec2 uv)\n{\n    const int samples = 128;\n    const float fsamples = float(samples);\n    vec2 maxdist = vec2(0.5,1.0)/40.0;\n    vec2 halfmaxdist = vec2(0.5) * maxdist;\n\n    float stepsize = maxdist.x / fsamples;\n    float initial_offset_x = -0.5 * fsamples * stepsize;\n    uv.x += initial_offset_x;\n    float hit = 0.0;\n    for( int i=0; i<samples; ++i )\n    {\n        float x = uv.x + stepsize * float(i);\n        float y = uv.y;\n        float fx = function(x);\n        float dist = abs(y-fx);\n        hit += step(dist, halfmaxdist.y);\n    }\n    const float arbitraryFactor = 4.5;\n    const float arbitraryExp = 0.95;\n    return arbitraryFactor * pow( hit / fsamples, arbitraryExp );\n}\n\nvoid main(void)\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float ymin = -2.0;\n    float ymax = +2.0;\n    float xmin = 0.0;\n    float xmax = xmin + (ymax-ymin)* iResolution.x / iResolution.y;\n\n    vec2 xy = vec2(xmin,ymin) + uv*vec2(xmax-xmin, ymax-ymin);\n    gl_FragColor = vec4(0,0,0, sample(xy));\n}\n""""""\n\nwindow = app.Window(width=3*512, height=512, color=(1,1,1,1))\npause = False\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n    if not pause:\n        program[""iGlobalTime""] += dt\n\n@window.event\ndef on_key_press(key, modifiers):\n    global pause\n    if key == ord(\' \'):\n        pause = not pause\n\n@window.event\ndef on_resize(width, height):\n    program[""iResolution""] = width, height\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nprogram[""iGlobalTime""] = 0\napp.run()\n'"
examples/interpolations.py,8,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" This example shows spatial interpolation of images. """"""\nimport numpy as np\nfrom glumpy import app, gl, gloo, data, library\n\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    attribute float interpol;\n    varying vec2 v_texcoord;\n    varying float v_interpol;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n        v_texcoord = texcoord;\n        v_interpol = interpol;\n    } """"""\n\nfragment = """"""\n#include ""misc/spatial-filters.frag""\n\nuniform sampler2D u_data;\nuniform vec2 u_shape;\nvarying vec2 v_texcoord;\nvarying float v_interpol;\nvoid main()\n{\n    if (v_interpol < 0.5)\n         // gl_FragColor = Nearest(u_data, u_shape, v_texcoord);\n         gl_FragColor = texture2D(u_data, v_texcoord);\n    else if (v_interpol < 1.5)\n        gl_FragColor = Bilinear(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 2.5)\n        gl_FragColor = Hanning(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 3.5)\n        gl_FragColor = Hamming(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 4.5)\n        gl_FragColor = Hermite(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 5.5)\n        gl_FragColor = Kaiser(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 6.5)\n        gl_FragColor = Quadric(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 7.5)\n        gl_FragColor = Bicubic(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 8.5)\n        gl_FragColor = CatRom(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 9.5)\n        gl_FragColor = Mitchell(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 10.5)\n        gl_FragColor = Spline16(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 11.5)\n        gl_FragColor = Spline36(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 12.5)\n        gl_FragColor = Gaussian(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 13.5)\n        gl_FragColor = Bessel(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 14.5)\n        gl_FragColor = Sinc(u_data, u_shape, v_texcoord);\n    else if (v_interpol < 15.5)\n        gl_FragColor = Lanczos(u_data, u_shape, v_texcoord);\n    else\n        gl_FragColor = Blackman(u_data, u_shape, v_texcoord);\n} """"""\n\nwindow = app.Window(width=4*512, height=2*512)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLES, indices)\n\n@window.event\ndef on_mouse_motion(x, y, dx, dy):\n    global zoom\n    dx, dy = 0.05*zoom, 0.05*zoom\n    x = min(max(x/1024.0, dx), 1.0-dx)\n    y = min(max(y/1024.0, dy), 1.0-dy)\n    vertices[1:][\'texcoord\'] = (x-dx,y-dy), (x-dy,y+dy), (x+dx, y-dy), (x+dx,y+dy)\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    global zoom\n    zoom = np.minimum(np.maximum(zoom*(1+dy/100.0), 0.001), 10.00)\n    on_mouse_motion(x,y,0,0)\n\n\nzoom = 0.25\nprogram = gloo.Program(vertex, fragment)\nvertices = np.zeros((16+1,4),\n                    [(""position"", np.float32, 2),\n                     (""texcoord"", np.float32, 2),\n                     (""interpol"", np.float32, 1)]).view(gloo.VertexBuffer)\nvertices[""position""][0] = (-1,+1), (-1,-1), (0,+1), (0,-1)\ndx, dy = 1/4.0, 1/2.0\nfor j in range(4):\n    for i in range(4):\n        index = 1+j*4+i\n        x, y = i/4.0, -1 + j/2.0\n        vertices[""position""][index] = (x,y+dy), (x,y), (x+dx,y+dy), (x+dx,y)\nvertices[\'texcoord\'] = ( 0, 0), ( 0,+1), (+1, 0), (+1,+1)\nvertices[\'interpol\'] = np.arange(17).reshape(17,1)\nprogram.bind(vertices)\nindices = np.zeros((17,6),np.uint32).view(gloo.IndexBuffer)\nindices[:] = [0,1,2,1,2,3]\nindices += 4*np.arange(17,dtype=np.uint32).reshape(17,1)\n\nlena = data.get(""lena.png"")\nprogram[\'u_data\'] = lena\nprogram[\'u_shape\'] = lena.shape[1], lena.shape[0]\nprogram[\'u_kernel\'] = data.get(""spatial-filters.npy"")\nprogram[\'u_data\'].interpolation = gl.GL_NEAREST\nprogram[\'u_data\'].wrapping = gl.GL_CLAMP\n\nx,y = 512,512\ndx, dy = 0.05, 0.05\nx = min(max(x/1024.0, dx), 1.0-dx)\ny = min(max(y/1024.0, dy), 1.0-dy)\nvertices[\'texcoord\'][1:] = (x-dx,y-dy), (x-dy,y+dy), (x+dx, y-dy), (x+dx,y+dy)\n\napp.run()\n'"
examples/isocurves-lena.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, data\nfrom glumpy.geometry import primitives\nfrom glumpy.transforms import PanZoom\n\n\nvertex = """"""\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\n\nvoid main()\n{\n    gl_Position = <transform(vec4(position.xy,0,1.0))>;\n    v_texcoord = texcoord;\n}\n""""""\n\nfragment = """"""\n#include ""misc/spatial-filters.frag""\n#include ""colormaps/colormaps.glsl""\n\nuniform sampler2D data;\nuniform vec2 data_shape;\nvarying vec2 v_texcoord;\n\nvoid main()\n{\n    // Extract data value\n    float value = Bicubic(data, data_shape, v_texcoord).r;\n\n    // Map value to rgb color\n    vec4 bg_color = vec4(colormap_hot(value),1.0);\n    vec4 fg_color = vec4(0,0,0,1);\n\n    // Trace contour\n    float levels = 32.0;\n\n    float antialias = 1.0;\n    float linewidth = 1.0 + antialias;\n    if(length(value-0.5) < 0.5/levels)\n        linewidth = 3.0 + antialias;\n\n    float v  = levels*value - 0.5;\n    float dv = linewidth/2.0 * fwidth(v);\n    float f = abs(fract(v) - 0.5);\n    float d = smoothstep(-dv,+dv,f);\n\n    float t = linewidth/2.0 - antialias;\n    d = abs(d)*linewidth/2.0 - t;\n    if( d < 0.0 ) {\n         gl_FragColor = bg_color;\n    } else  {\n        d /= antialias;\n        gl_FragColor = mix(fg_color,bg_color,d);\n    }\n} """"""\n\n\nwindow = app.Window(800, 800, color = (1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLES, I)\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.reset()\n\nprogram = gloo.Program(vertex, fragment)\nV,I = primitives.plane(2.0, n=64)\nprogram.bind(V)\n\nlena = data.get(""lena.png"")/256.0\n\nprogram[\'data\'] = lena[::-1,:,0]\nprogram[\'data\'].interpolation = gl.GL_NEAREST\nprogram[\'data_shape\'] = lena.shape[1], lena.shape[0]\nprogram[\'u_kernel\'] = data.get(""spatial-filters.npy"")\nprogram[\'u_kernel\'].interpolation = gl.GL_LINEAR\n\ntransform = PanZoom(aspect=1)\nprogram[\'transform\'] = transform\nwindow.attach(transform)\napp.run()\n'"
examples/isocurves.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, data\nfrom glumpy.geometry import primitives\nfrom glumpy.transforms import PanZoom\n\n\nvertex = """"""\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\n\nvoid main()\n{\n    gl_Position = <transform(vec4(position.xy,0,1.0))>;\n    v_texcoord = texcoord;\n}\n""""""\n\nfragment = """"""\n#include ""misc/spatial-filters.frag""\n#include ""colormaps/colormaps.glsl""\n\nuniform sampler2D data;\nuniform vec2 data_shape;\nvarying vec2 v_texcoord;\n\nvoid main()\n{\n    // Extract data value\n    float value = Bicubic(data, data_shape, v_texcoord).r;\n\n    // Map value to rgb color\n    vec4 bg_color = vec4(colormap_hot(value),1.0);\n    vec4 fg_color = vec4(0,0,0,1);\n\n    // Trace contour\n    float levels = 16.0;\n\n    float antialias = 1.0;\n    float linewidth = 1.0 + antialias;\n    if(length(value-0.5) < 0.5/levels)\n        linewidth = 3.0 + antialias;\n\n    float v  = levels*value - 0.5;\n    float dv = linewidth/2.0 * fwidth(v);\n    float f = abs(fract(v) - 0.5);\n    float d = smoothstep(-dv,+dv,f);\n\n    float t = linewidth/2.0 - antialias;\n    d = abs(d)*linewidth/2.0 - t;\n    if( d < 0.0 ) {\n         gl_FragColor = bg_color;\n    } else  {\n        d /= antialias;\n        gl_FragColor = mix(fg_color,bg_color,d);\n    }\n} """"""\n\n\nwindow = app.Window(800, 800, color = (1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLES, I)\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.reset()\n\ndef func3(x,y):\n    return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)\nx = np.linspace(-2.0, 2.0, 256).astype(np.float32)\ny = np.linspace(-2.0, 2.0, 256).astype(np.float32)\nX,Y = np.meshgrid(x, y)\nZ = func3(X,Y)\n\nprogram = gloo.Program(vertex, fragment)\nV,I = primitives.plane(2.0, n=64)\nprogram.bind(V)\n\nprogram[\'data\'] = (Z-Z.min())/(Z.max() - Z.min())\nprogram[\'data\'].interpolation = gl.GL_NEAREST\nprogram[\'data_shape\'] = Z.shape[1], Z.shape[0]\nprogram[\'u_kernel\'] = data.get(""spatial-filters.npy"")\nprogram[\'u_kernel\'].interpolation = gl.GL_LINEAR\n\ntransform = PanZoom(aspect=1)\nprogram[\'transform\'] = transform\nwindow.attach(transform)\napp.run()\n'"
examples/lasso.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, glm, gl\nfrom glumpy.graphics.collections import PolygonCollection, PathCollection\nfrom glumpy.transforms import Position, Viewport, OrthographicProjection\n\nwindow = app.Window(width=800, height=800, color=(1,1,1,1))\nP = []\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    polys.draw()\n    paths.draw()\n\n@window.event\ndef on_mouse_press(x, y ,button):\n    global P\n    P = []\n    if len(paths) > 0: del paths[0]\n    if len(polys) > 0: del polys[0]\n\n@window.event\ndef on_mouse_release(x, y ,button):\n    global P\n    if len(paths) > 0: del paths[0]\n    if len(polys) > 0: del polys[0]\n    if len(P):\n        paths.append(np.array(P),closed=True)\n        polys.append(np.array(P))\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    global P\n    P.append( (x, window.height-y,0) )\n    if len(paths) > 0: del paths[0]\n    paths.append(np.array(P), closed=False)\n\n\ntransform = OrthographicProjection(Position())\n\npaths = PathCollection(mode=""agg"", transform=transform)\npolys = PolygonCollection(mode=""agg"", transform=transform, color=""global"")\npaths[""linewidth""] = 1.0\npaths[""color""] = 0.0, 0.0, 0.0, 1.00\npolys[""color""] = 0.0, 0.0, 0.0, 0.10\n\nwindow.attach(paths[""transform""])\nwindow.attach(paths[""viewport""])\napp.run()\n'"
examples/lorenz.py,26,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, glm\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.transforms import Position, Trackball, Viewport\nfrom glumpy.graphics.collections import GlyphCollection\nfrom glumpy.graphics.collections import PathCollection\nfrom glumpy.graphics.collections import SegmentCollection\n\n\nwindow = app.Window(width=1000, height=800, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    ticks.draw()\n    labels.draw()\n    paths.draw()\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        reset()\n\ndef reset():\n    transform.theta = 0\n    transform.phi = 0\n    transform.zoom = 16.5\n\n\ntransform = Trackball(Position())\nviewport = Viewport()\nlabels = GlyphCollection(transform=transform, viewport=viewport)\npaths = PathCollection(mode=""agg+"", transform=transform, viewport=viewport)\nticks = SegmentCollection(mode=""agg"", transform=transform, viewport=viewport,\n                          linewidth=\'local\', color=\'local\')\n\n\n\n# xmin,xmax = 0,800\n# ymin,ymax = 0,800\nxmin,xmax = -1,1\nymin,ymax = -1,1\n\n\nz = 0\n\nregular = FontManager.get(""OpenSans-Regular.ttf"")\nbold    = FontManager.get(""OpenSans-Bold.ttf"")\nn = 11\nscale = 0.001\nfor i,y in enumerate(np.linspace(xmin,xmax,n)):\n    text = ""%.2f"" % (i/10.0)\n    labels.append(text, regular,\n                  origin = (1.05,y,z), scale = scale, direction = (1,0,0),\n                  anchor_x = ""left"", anchor_y = ""center"")\n    labels.append(text, regular, origin = (y, -1.05, z),\n                  scale= scale, direction = (1,0,0),\n                  anchor_x = ""center"", anchor_y = ""top"")\n\ntitle = ""Lorenz strange attractor""\nlabels.append(title, bold, origin = (0, 1.1, z),\n              scale= 2*scale, direction = (1,0,0),\n              anchor_x = ""center"", anchor_y = ""center"")\n\n\n\n\n\n# Frame\n# -------------------------------------\nP0 = [(xmin,ymin,z), (xmin,ymax,z), (xmax,ymax,z), (xmax,ymin,z)]\nP1 = [(xmin,ymax,z), (xmax,ymax,z), (xmax,ymin,z), (xmin,ymin,z)]\nticks.append(P0, P1, linewidth=2)\n\n# Grids\n# -------------------------------------\nn = 11\nP0 = np.zeros((n-2,3))\nP1 = np.zeros((n-2,3))\n\nP0[:,0] = np.linspace(xmin,xmax,n)[1:-1]\nP0[:,1] = ymin\nP0[:,2] = z\nP1[:,0] = np.linspace(xmin,xmax,n)[1:-1]\nP1[:,1] = ymax\nP1[:,2] = z\nticks.append(P0, P1, linewidth=1, color=(0,0,0,.25))\n\nP0 = np.zeros((n-2,3))\nP1 = np.zeros((n-2,3))\nP0[:,0] = xmin\nP0[:,1] = np.linspace(ymin,ymax,n)[1:-1]\nP0[:,2] = z\nP1[:,0] = xmax\nP1[:,1] = np.linspace(ymin,ymax,n)[1:-1]\nP1[:,2] = z\nticks.append(P0, P1, linewidth=1, color=(0,0,0,.25))\n\n\n# Majors\n# -------------------------------------\nn = 11\nP0 = np.zeros((n-2,3))\nP1 = np.zeros((n-2,3))\nP0[:,0] = np.linspace(xmin,xmax,n)[1:-1]\nP0[:,1] = ymin - 0.015\nP0[:,2] = z\nP1[:,0] = np.linspace(xmin,xmax,n)[1:-1]\nP1[:,1] = ymin + 0.025 * (ymax-ymin)\nP1[:,2] = z\nticks.append(P0, P1, linewidth=1.5)\nP0[:,1] = ymax + 0.015\nP1[:,1] = ymax - 0.025 * (ymax-ymin)\nticks.append(P0, P1, linewidth=1.5)\n\nP0 = np.zeros((n-2,3))\nP1 = np.zeros((n-2,3))\nP0[:,0] = xmin - 0.015\nP0[:,1] = np.linspace(ymin,ymax,n)[1:-1]\nP0[:,2] = z\nP1[:,0] = xmin + 0.025 * (xmax-xmin)\nP1[:,1] = np.linspace(ymin,ymax,n)[1:-1]\nP1[:,2] = z\nticks.append(P0, P1, linewidth=1.5)\nP0[:,0] = xmax + 0.015\nP1[:,0] = xmax - 0.025 * (xmax-xmin)\nticks.append(P0, P1, linewidth=1.5)\n\n\n# Minors\n# -------------------------------------\nn = 111\nP0 = np.zeros((n-2,3))\nP1 = np.zeros((n-2,3))\nP0[:,0] = np.linspace(xmin,xmax,n)[1:-1]\nP0[:,1] = ymin\nP0[:,2] = z\nP1[:,0] = np.linspace(xmin,xmax,n)[1:-1]\nP1[:,1] = ymin + 0.0125 * (ymax-ymin)\nP1[:,2] = z\nticks.append(P0, P1, linewidth=1)\nP0[:,1] = ymax\nP1[:,1] = ymax - 0.0125 * (ymax-ymin)\nticks.append(P0, P1, linewidth=1)\n\nP0 = np.zeros((n-2,3))\nP1 = np.zeros((n-2,3))\nP0[:,0] = xmin\nP0[:,1] = np.linspace(ymin,ymax,n)[1:-1]\nP0[:,2] = z\nP1[:,0] = xmin + 0.0125 * (xmax-xmin)\nP1[:,1] = np.linspace(ymin,ymax,n)[1:-1]\nP1[:,2] = z\nticks.append(P0, P1, linewidth=1)\nP0[:,0] = xmax\nP1[:,0] = xmax - 0.0125 * (xmax-xmin)\nticks.append(P0, P1, linewidth=1)\n\n\ndef lorenz(n=50000):\n    def iterate(P, s=10, r=28, b=2.667, dt=0.01):\n        x, y, z = P\n        x_dot = s*(y - x)\n        y_dot = r*x - y - x*z\n        z_dot = x*y - b*z\n        return dt*x_dot, dt*y_dot, dt*z_dot\n\n    # Need one more for the initial values\n    P = np.empty((n+1,3))\n\n    # Setting initial values\n    P[0] = 0., 1., 1.05\n\n    # Stepping through ""time""\n    dt = 100.0/n\n    for i in range(n) :\n        # Derivatives of the X, Y, Z state\n        P[i+1] = P[i] + iterate(P[i], dt=dt)\n\n    # Normalize\n    vmin,vmax = P.min(),P.max()\n    P = 2*(P-vmin)/(vmax-vmin) - 1\n\n    # Centering\n    P[:,0] -= (P[:,0].max() + P[:,0].min())/2.0\n    P[:,1] -= (P[:,1].max() + P[:,1].min())/2.0\n    P[:,2] -= (P[:,2].max() + P[:,2].min())/2.0\n\n    return P\n\n\npaths.append(lorenz(), color=(0,0,1,1), closed=False)\npaths[""color""] = 0,0,1,1\nreset()\n\n\nwindow.attach(paths[""transform""])\nwindow.attach(paths[""viewport""])\napp.run()\n'"
examples/mandelbrot.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" Mandelbrot set with pan & zoom """"""\n\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo, __version__\nfrom glumpy.transforms import PanZoom, Position\n\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = <transform>;\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\nvarying vec2 v_texcoord;\n\nvec3 hot(float t)\n{\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\n\nvoid main()\n{\n    const int n = 300;\n    const float log_2 = 0.6931471805599453;\n    vec2 c = 3.0*v_texcoord - vec2(2.0,1.5);\n\n    float x, y, d;\n    int i;\n    vec2 z = c;\n    for(i = 0; i < n; ++i)\n    {\n        x = (z.x*z.x - z.y*z.y) + c.x;\n        y = (z.y*z.x + z.x*z.y) + c.y;\n        d = x*x + y*y;\n        if (d > 4.0) break;\n        z = vec2(x,y);\n    }\n\n    if ( i < n ) {\n        float nu = log(log(sqrt(d))/log_2)/log_2;\n        float index = float(i) + 1.0 - nu;\n        float v = pow(index/float(n),0.5);\n        gl_FragColor = vec4(hot(v),1.0);\n    } else {\n        gl_FragColor = vec4(hot(0.0),1.0);\n    }\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.reset()\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1, 1), ( 1,-1), ( 1, 1)]\nprogram[\'texcoord\'] = [( 0, 1), ( 0, 0), ( 1, 1), ( 1, 0)]\ntransform = PanZoom(Position(""position""),aspect=1)\nprogram[\'transform\'] = transform\nwindow.attach(transform)\napp.run()\n'"
examples/material-colors.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, color, collections\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.transforms import OrthographicProjection, Position, PanZoom, Viewport\n\n\nwindow = app.Window(1400,1050, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quads.draw()\n    labels.draw()\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.pan = 0.0,0.0\n        transform.zoom = 0.165\n\n\ndef add(names, values, xmin, xmax, ymin, ymax, header=None):\n    colors = color.Colors(values)\n    n = len(colors)\n    dy = (ymax-ymin)/n\n    for i,y in enumerate(np.linspace(ymin,ymax,n+1)[:-1]):\n\n        quads.append( [(xmin,y,0), (xmin,y+dy,0), (xmax,y+dy,0), (xmax,y,0)],\n                      [0,1,2,0,2,3], color = colors[i].rgba)\n\n        r,g,b,a = colors[i].rgba\n        gray = 0.2989 * r + 0.5870 * g + 0.1140 * b\n        if gray < 0.5:\n            c = 1,1,1,1\n        else:\n            c = 0,0,0,1\n        x = xmin + 0.05*(xmax-xmin)\n        if header is None:\n            y = y+dy/2\n        else:\n            y = y + 0.15*(ymax-ymin)\n\n        labels.append(names[i].upper(), regular, color=c,\n                      origin = (x,y,0), scale = 0.002, direction = (1,0,0),\n                      anchor_x = ""left"", anchor_y = ""center"")\n        labels.append(names[i].upper(), regular, color=c,\n                      origin = (x,y,0), scale = 0.002, direction = (1,0,0),\n                      anchor_x = ""left"", anchor_y = ""center"")\n        if header is not None:\n            labels.append(header, regular, color=c,\n                          origin = (x,ymax - 0.25*(ymax-ymin),0),\n                          scale = 0.005, direction = (1,0,0),\n                          anchor_x = ""left"", anchor_y = ""center"")\n\n        x = xmax - 0.05*(xmax-xmin)\n        labels.append(values[i].upper(), regular, color=c,\n                      origin = (x,y,0), scale = 0.002, direction = (1,0,0),\n                      anchor_x = ""right"", anchor_y = ""center"")\n\n\n\ntransform = PanZoom(OrthographicProjection(Position(),normalize=True),aspect=1)\ntransform.zoom = 0.165\nviewport = Viewport()\n\nquads  = collections.TriangleCollection(transform = transform, viewport=viewport)\nlabels = collections.GlyphCollection(transform = transform, viewport=viewport)\nregular = FontManager.get(""OpenSans-Regular.ttf"")\n\n\nx,y = -2.5*2.6,+4\nfor i,name in enumerate([""Red"", ""Pink"", ""Purple"",  ""Deep Purple"", ""Indigo"", ""Blue"",\n                         ""Light Blue"", ""Cyan"", ""Teal"", ""Green"", ""Light Green"", ""Lime"",\n                         ""Yellow"", ""Amber"", ""Orange"", ""Deep Orange"", ""Brown"", ""Grey""]):\n    family = ""material:%s"" % name\n    if i > 0 and (i % 6) == 0:\n        y -= 4\n        x = -2.5*2.6\n    if name not in [""Brown"", ""Grey""]:\n        names  = list(color.get(family).keys())[:-1][::-1]\n        values = color.get(family+"":*"")[:-4][::-1]\n    else:\n        names  = list(color.get(family).keys())[::-1]\n        values = color.get(family+"":*"")[::-1]\n    add(names, values, x-1.25, x+1.25, y-1.000, y+1.000)\n    if name not in [""Brown"", ""Grey""]:\n        names  = [""A""+ v for v in list(color.get(family+"":accent"").keys())[::-1]]\n        values = color.get(family+"":accent:*"")[::-1]\n        add(names, values, x-1.25, x+1.25, y-1.850, y-1.050)\n\n    names  = [""500""]\n    values = [color.get(family+"":500"")]\n    add(names, values, x-1.25, x+1.25, y+1.050, y+1.850, header=name)\n    x += 2.6\n\nwindow.attach(transform)\nwindow.attach(viewport)\n\napp.run()\n'"
examples/matplotlib-1.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy.api.matplotlib import *\n\n# Create a new figure\nfigure = Figure((24,12))\n\n# Create a subplot on left, using trackball interface (3d)\nleft = figure.add_axes( [0.010, 0.01, 0.485, 0.98],\n                        interface = Trackball(name=""trackball""),\n                        facecolor=(1,0,0,0.25), aspect=1 )\n\n# Create a subplot on right, using panzoom interface (2d)\nright = figure.add_axes( [0.505, 0.01, 0.485, 0.98],\n                         interface = PanZoom(name=""panzoom"", aspect=1),\n                         facecolor=(0,0,1,0.25), aspect=1 )\n\n# Create a new collection of points\ncollection = PointCollection(""agg"")\n\n# Add a view of the collection on the left subplot\nleft.add_drawable(collection)\n\n# Add a view of the collection on the right subplot\nright.add_drawable(collection)\n\n# Change xscale range on left subplot\nleft.transform[\'zscale\'][\'range\'] = -0.5,+0.5\n\n# Set trackball view\nleft.transform[\'trackball\'][""phi""] = 0\nleft.transform[\'trackball\'][""theta""] = 0\n\n# Add some points\ncollection.append(np.random.normal(0.0,0.5,(10000,3)))\n\n# Show figure\nfigure.show()\n'"
examples/matplotlib-2.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy.api.matplotlib import *\n\n# Create a new figure\nfigure = Figure((24,12))\n\n# Create a subplot on left, using trackball interface (3d)\nleft = figure.add_axes( [0.010, 0.01, 0.485, 0.98],\n                        xscale = LinearScale(clamp=True),\n                        yscale = LinearScale(clamp=True),\n                        zscale = LinearScale(clamp=True),\n                        interface = Trackball(name=""trackball""),\n                        facecolor=(1,0,0,0.25), aspect=1 )\n\n# Create a subplot on right, using panzoom interface (2d)\nright = figure.add_axes( [0.505, 0.01, 0.485, 0.98],\n                         xscale = LinearScale(domain=[-2.0,+2.0], range=[0.25,1.00]),\n                         yscale = LinearScale(domain=[-2.0,+2.0], range=[0,2*np.pi]),\n                         projection = PolarProjection(),\n                         interface = Trackball(name=""trackball""),\n                         facecolor=(0,0,1,0.25), aspect=1 )\n\n# Create a new collection of points\ncollection = PointCollection(""agg"")\n\n# Add a view of the collection on the left subplot\nleft.add_drawable(collection)\n\n# Add a view of the collection on the right subplot\nright.add_drawable(collection)\n\n# Add some points\ncollection.append(np.random.uniform(-2,2,(10000,3)))\n\n# Show figure\nfigure.show()\n'"
examples/matplotlib-3.py,21,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy.api.matplotlib import *\n\n# Create a new figure\nfigure = Figure((12,12))\n\n\n# Create a subplot on right, using panzoom interface (2d)\nplot = figure.add_axes( [0.01, 0.01, 0.98, 0.98],\n                        xscale = LinearScale(domain=[0.0,1.0], range=[0.0,1.0]),\n                        yscale = LinearScale(domain=[0.0,1.0], range=[0,2*np.pi]),\n                        projection = PolarProjection(),\n                        interface = Trackball(name=""trackball""),\n                        facecolor=(0,0,1,0.25), aspect=None )\n\n# Create a new collection of points\ncollection = PathCollection(""agg+"")\n\n# Add a view of the collection on the subplot\nplot.add_drawable(collection)\n\n# Add some points\nn = 1000\nP = np.zeros((n,3))\nP[:,0] = np.linspace(1, 0,n)\nP[:,1] = np.linspace(0,5,n)\nP[:,2] = np.linspace(-1,1,n)\ncollection.append(P)\ncollection[""linewidth""] = 1\n\n# Frame\nn = 100\nxmin,xmax = +0.0, 1.0\nymin,ymax = +0.0, 1.0\nzmin,zmax = -1.0, 1.0\nframe = PathCollection(""agg+"")\nplot.add_drawable(frame)\nframe[""linewidth""] = 2.5\n\nP = np.zeros((n,3))\n\nP[:,0] = xmax\nP[:,1] = np.linspace(ymin,ymax,n)\nP[:,2] = zmin\nframe.append(P)\n\nP[:,0] = np.linspace(xmin,xmax,n)\nP[:,1] = ymin\nP[:,2] = zmin\nframe.append(P)\n\nP[:,0] = xmin\nP[:,1] = ymin\nP[:,2] = np.linspace(zmin,zmax,n)\nframe.append(P)\n\n# Ticks\nticks = SegmentCollection(""agg"", linewidth=""local"")\nplot.add_drawable(ticks)\n\nn = 23\nP0 = np.zeros((n-2,3))\nP1 = np.zeros((n-2,3))\nP0[:,0] = np.linspace(xmin,xmax,n)[1:-1]\nP0[:,1] = ymin - 0.0\nP0[:,2] = zmin\nP1[:,0] = np.linspace(xmin,xmax,n)[1:-1]\nP1[:,1] = ymin + 0.015 * (ymax-ymin)\nP1[:,2] = zmin\nticks.append(P0, P1, linewidth=2.5)\n\nP0 = np.zeros((n-1,3))\nP1 = np.zeros((n-1,3))\nP0[:,0] = xmax + 0.015\nP0[:,1] = np.linspace(ymin,ymax,n)[1:]\nP0[:,2] = zmin\nP1[:,0] = xmax - 0.025 * (xmax-xmin)\nP1[:,1] = np.linspace(ymin,ymax,n)[1:]\nP1[:,2] = zmin\nticks.append(P0, P1, linewidth=2.5)\n\nP0 = np.zeros((n-1,3))\nP1 = np.zeros((n-1,3))\nP0[:,0] = xmin + 0.025\nP0[:,1] = 0\nP0[:,2] = np.linspace(zmin,zmax,n)[1:]\nP1[:,0] = xmin - 0.015 * (xmax-xmin)\nP1[:,1] = 0\nP1[:,2] = np.linspace(zmin,zmax,n)[1:]\nticks.append(P0, P1, linewidth=2.5)\n\n\n# Show figure\nfigure.show()\n'"
examples/movie-reader.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.ext.ffmpeg_reader import FFMPEG_VideoReader\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\n    uniform sampler2D frame;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_FragColor = texture2D(frame, v_texcoord);\n    }\n""""""\n\n# Add an option for choosing movie to be played\napp.parser.get_default().add_argument(\n    \'movie\', metavar=\'movie file\', type=str, nargs=\'+\', help=\'Movie to play\')\noptions = app.parser.get_options()\n\nfilename = options.movie[0]\nreader = FFMPEG_VideoReader(filename)\nwidth,height = reader.infos[""video_size""]\nduration = reader.infos[""duration""]\n\ntime = 0\nwindow = app.Window(2*width, 2*height)\n\n@window.event\ndef on_draw(dt):\n    global time\n    window.clear()\n    time = np.mod(time+dt, duration)\n    program[\'frame\'][...] = reader.get_frame(time)\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nprogram[\'texcoord\'] = [( 0, 1), ( 0, 0), ( 1, 1), ( 1, 0)]\nprogram[\'frame\'] = np.zeros((height,width,3), dtype=np.uint8)\napp.run()\n'"
examples/movie-writer.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo, data\nfrom glumpy.geometry import primitives\nfrom glumpy.app.movie import record\n\n\nvertex = """"""\nuniform mat4 model, view, projection;\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(position,1.0);\n    v_texcoord = texcoord;\n}\n""""""\n\nfragment = """"""\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    float r = texture2D(texture, v_texcoord).r;\n    gl_FragColor = vec4(vec3(r),1.0);\n}\n""""""\n\n\nwidth, height = 512,512\nwindow = app.Window(width, height, color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta\n\n    window.clear()\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    cube.draw(gl.GL_TRIANGLES, faces)\n\n    # Make cube rotate\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'model\'] = model\n\n\n@window.event\ndef on_resize(width, height):\n    cube[\'projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n\nvertices, faces = primitives.cube()\ncube = gloo.Program(vertex, fragment)\ncube.bind(vertices)\nview = np.eye(4, dtype=np.float32)\nglm.translate(view, 0, 0, -3)\ncube[\'view\'] = view\ncube[\'model\'] = np.eye(4, dtype=np.float32)\ncube[\'texture\'] = data.checkerboard()\nphi, theta = 0, 0\n\nduration = 5.0\nframerate = 60\nwith record(window, ""cube.mp4"", fps=framerate):\n    app.run(framerate=framerate, duration=duration)\n'"
examples/oscilloscope.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" This example show a very simple oscilloscope. """"""\n\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\n\n\nvertex = """"""\nattribute float x, y, intensity;\n\nvarying float v_intensity;\nvoid main (void)\n{\n    v_intensity = intensity;\n    gl_Position = vec4(x, y, 0.0, 1.0);\n}\n""""""\n\nfragment = """"""\nvarying float v_intensity;\nvoid main()\n{\n    gl_FragColor = vec4(0,v_intensity,0,1);\n}\n""""""\n\nwindow = app.Window(width=1024, height=512)\n\n@window.event\ndef on_draw(dt):\n    global index\n    window.clear()\n    oscilloscope.draw(gl.GL_LINE_STRIP)\n    index = (index-1) % len(oscilloscope)\n    oscilloscope[\'intensity\'] -= 1.0/len(oscilloscope)\n    oscilloscope[\'y\'][index] = np.random.uniform(-0.25, +0.25)\n    oscilloscope[\'intensity\'][index] = 1.0\n\nindex = 0\noscilloscope = gloo.Program(vertex, fragment, count=150)\noscilloscope[\'x\'] = np.linspace(-1,1,len(oscilloscope))\n\napp.run()\n'"
examples/polar-surface.py,10,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, data, library\nfrom glumpy.transforms import *\nfrom glumpy.graphics.collections import *\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.geometry import primitives\n\nvertex = """"""\n#include ""misc/spatial-filters.frag""\n\nuniform float height;\nuniform sampler2D data;\nuniform vec2 data_shape;\nattribute vec3 position;\nattribute vec2 texcoord;\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    float z = height*Bicubic(data, data_shape, texcoord).r;\n    gl_Position = <transform(vec3(position.xy,z-0.5))>;\n    v_texcoord = texcoord;\n    v_position = vec3(position.xy, z);\n}\n""""""\n\nfragment = """"""\n#include ""misc/spatial-filters.frag""\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 normal;\nuniform sampler2D texture;\nuniform float height;\nuniform vec4 color;\n\nuniform sampler2D data;\nuniform vec2 data_shape;\nuniform vec3 light_color[3];\nuniform vec3 light_position[3];\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord;\n\nfloat lighting(vec3 v_normal, vec3 light_position)\n{\n    // Calculate normal in world coordinates\n    vec3 n = normalize(normal * vec4(v_normal,1.0)).xyz;\n\n    // Calculate the location of this fragment (pixel) in world coordinates\n    vec3 position = vec3(view * model * vec4(v_position, 1));\n\n    // Calculate the vector from this pixels surface to the light source\n    vec3 surface_to_light = light_position - position;\n\n    // Calculate the cosine of the angle of incidence (brightness)\n    float brightness = dot(n, surface_to_light) /\n                      (length(surface_to_light) * length(n));\n    brightness = max(min(brightness,1.0),0.0);\n    return brightness;\n}\n\nvoid main()\n{\n    mat4 model = <transform.trackball_model>;\n\n    // Extract data value\n    float value = Bicubic(data, data_shape, v_texcoord).r;\n\n    // Compute surface normal using neighbour values\n    float hx0 = height*Bicubic(data, data_shape, v_texcoord+vec2(+1,0)/data_shape).r;\n    float hx1 = height*Bicubic(data, data_shape, v_texcoord+vec2(-1,0)/data_shape).r;\n    float hy0 = height*Bicubic(data, data_shape, v_texcoord+vec2(0,+1)/data_shape).r;\n    float hy1 = height*Bicubic(data, data_shape, v_texcoord+vec2(0,-1)/data_shape).r;\n    vec3 dx = vec3(2.0/data_shape.x,0.0,hx0-hx1);\n    vec3 dy = vec3(0.0,2.0/data_shape.y,hy0-hy1);\n    vec3 v_normal = normalize(cross(dx,dy));\n\n    // Map value to rgb color\n    float c = 0.6 + 0.4*texture2D(texture, v_texcoord).r;\n    vec4 l1 = vec4(light_color[0] * lighting(v_normal, light_position[0]), 1);\n    vec4 l2 = vec4(light_color[1] * lighting(v_normal, light_position[1]), 1);\n    vec4 l3 = vec4(light_color[2] * lighting(v_normal, light_position[2]), 1);\n\n    gl_FragColor = color * vec4(c,c,c,1) * (0.5 + 0.5*(l1+l2+l3));\n} """"""\n\n\n\nwindow = app.Window(1200, 1200, color = (1,1,1,1))\n\n\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, time\n\n    time += dt\n    window.clear()\n\n    surface[\'data\']\n\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    surface[""color""] = 1,1,1,1\n    surface.draw(gl.GL_TRIANGLES, s_indices)\n\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    surface[""color""] = 0,0,0,1\n    surface.draw(gl.GL_LINE_LOOP, b_indices)\n    gl.glDepthMask(gl.GL_TRUE)\n\n    model = surface[\'transform\'][\'model\'].reshape(4,4)\n    view  = surface[\'transform\'][\'view\'].reshape(4,4)\n    surface[\'view\']  = view\n    surface[\'model\'] = model\n    surface[\'normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\n    # surface[""height""] = 0.75*np.cos(time/5.0)\n\n\n@window.event\ndef on_init():\n    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n    gl.glPolygonOffset(1, 1)\n    gl.glEnable(gl.GL_LINE_SMOOTH)\n    gl.glLineWidth(2.5)\n\n\nn = 64\nsurface = gloo.Program(vertex, fragment)\nvertices, s_indices = primitives.plane(2.0, n=n)\nsurface.bind(vertices)\n\nI = []\nfor i in range(n): I.append(i)\nfor i in range(1,n): I.append(n-1+i*n)\nfor i in range(n-1): I.append(n*n-1-i)\nfor i in range(n-1): I.append(n*(n-1) - i*n)\nb_indices = np.array(I, dtype=np.uint32).view(gloo.IndexBuffer)\n\n\ndef func3(x,y):\n    return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)\nx = np.linspace(-2.0, 2.0, 64).astype(np.float32)\ny = np.linspace(-2.0, 2.0, 64).astype(np.float32)\nX,Y = np.meshgrid(x, y)\nZ = func3(X,Y)\n\nsurface[\'data\'] = (Z-Z.min())/(Z.max() - Z.min())\nsurface[\'data\'].interpolation = gl.GL_NEAREST\nsurface[\'data_shape\'] = Z.shape[1], Z.shape[0]\nsurface[\'u_kernel\'] = data.get(""spatial-filters.npy"")\nsurface[\'u_kernel\'].interpolation = gl.GL_LINEAR\nsurface[\'texture\'] = data.checkerboard(32,24)\n\n\nxscale = LinearScale("".x"", name=""xscale"", domain=[-1,1], range=[0.0,1.00])\nyscale = LinearScale("".y"", name=""yscale"", domain=[-1,1], range=[0,2*np.pi])\nzscale = LinearScale("".z"", name=""zscale"", domain=[-1,1], range=[-1,1])\nprojection = PolarProjection(name=""data_projection"")\n\n# xscale = LinearScale("".x"", name=""xscale"", domain=[-2,2], range=[-np.pi,+np.pi])\n# yscale = LinearScale("".y"", name=""yscale"", domain=[-2,2], range=[-np.pi/2,+np.pi/2])\n# zscale = LinearScale("".z"", name=""zscale"", domain=[-1,1], range=[-1,1])\n# projection = TransverseMercatorProjection(name=""data_projection"", call=""forward"")\n\ntrackball = Trackball(name=""view_projection"", aspect=1)\ntransform = trackball(projection(Position(xscale,yscale,zscale)))\nsurface[\'transform\'] = transform\nwindow.attach(transform)\n\nT = (Z-Z.min())/(Z.max() - Z.min())\n\nsurface[\'height\'] = 0.75\nsurface[""light_position[0]""] = 3, 0, 0+5\nsurface[""light_position[1]""] = 0, 3, 0+5\nsurface[""light_position[2]""] = -3, -3, +5\nsurface[""light_color[0]""]    = 1, 0, 0\nsurface[""light_color[1]""]    = 0, 1, 0\nsurface[""light_color[2]""]    = 0, 0, 1\nphi, theta = -45, 0\ntime = 0\n\ntrackball[""zoom""] = 20\napp.run()\n'"
examples/protein-ssao.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl, data\nfrom glumpy.graphics.filter import Filter\nfrom glumpy.transforms import Position, Trackball\n\nvertex = """"""\nuniform vec3 light_position;\n\nattribute vec3 position;\nattribute vec3 color;\nattribute float radius;\n\nvarying vec3 v_color;\nvarying float v_radius;\nvarying vec4 v_eye_position;\nvarying vec3 v_light_direction;\n\nvoid main (void)\n{\n    v_color = color;\n    v_radius = radius;\n    v_eye_position = <transform.trackball_view> *\n                     <transform.trackball_model> *\n                     vec4(position,1.0);\n    v_light_direction = normalize(light_position);\n    gl_Position = <transform(position)>;\n    // stackoverflow.com/questions/8608844/...\n    //  ... resizing-point-sprites-based-on-distance-from-the-camera\n    vec4 p = <transform.trackball_projection> *\n             vec4(radius, radius, v_eye_position.z, v_eye_position.w);\n    gl_PointSize = 512.0 * p.x / p.w;\n}\n""""""\n\nfragment = """"""\nuniform int record;\nuniform sampler2D colors;\nuniform sampler2D normals;\n\nvarying vec3 v_color;\nvarying float v_radius;\nvarying vec4 v_eye_position;\nvarying vec3 v_light_direction;\n\nvoid main()\n{\n    vec2 texcoord = gl_PointCoord*2.0 - vec2(1.0);\n    float x = texcoord.x;\n    float y = texcoord.y;\n    float d = 1.0 - x*x - y*y;\n    if (d <= 0.0) discard;\n\n    float z = sqrt(d);\n    vec4 pos = v_eye_position;\n    pos.z += v_radius*z;\n    vec3 pos2 = pos.xyz;\n    pos = <transform.trackball_projection> * pos;\n\n    float depth = 0.5*(pos.z / pos.w)+0.5;\n    vec3 normal = normalize(vec3(x,y,z));\n\n    float diffuse = clamp(dot(normal, v_light_direction), 0.0, 1.0);\n    vec3 color = (0.25 + 0.75*diffuse) * (0.75 + 0.25*v_color);\n\n    gl_FragDepth = depth;\n    // gl_FragColor = vec4(normal,depth);\n    gl_FragData[0] = vec4(color,0.0);\n    gl_FragData[1] = vec4(normal,depth);\n}\n""""""\n\nssao_vertex = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    gl_Position = vec4(2*position-1,0,1);\n    v_texcoord = position;\n}""""""\n\nssao_fragment = """"""\nuniform sampler2D noise;\nuniform sampler2D colors;\nuniform sampler2D normals;\n\nuniform float base;\nuniform float radius;\nuniform float falloff;\nuniform float strength;\n\nvarying vec2 v_texcoord;\n\nvoid main(void)\n{\n  // Samples count\n  const int samples = 16;\n\n  // Random vectors inside a unit sphere\n  const vec3 sample_kernel[samples] = vec3[](\n      vec3( 0.5381, 0.1856,-0.4319), vec3( 0.1379, 0.2486, 0.4430),\n      vec3( 0.3371, 0.5679,-0.0057), vec3(-0.6999,-0.0451,-0.0019),\n      vec3( 0.0689,-0.1598,-0.8547), vec3( 0.0560, 0.0069,-0.1843),\n      vec3(-0.0146, 0.1402, 0.0762), vec3( 0.0100,-0.1924,-0.0344),\n      vec3(-0.3577,-0.5301,-0.4358), vec3(-0.3169, 0.1063, 0.0158),\n      vec3( 0.0103,-0.5869, 0.0046), vec3(-0.0897,-0.4940, 0.3287),\n      vec3( 0.7119,-0.0154,-0.0918), vec3(-0.0533, 0.0596,-0.5411),\n      vec3( 0.0352,-0.0631, 0.5460), vec3(-0.4776, 0.2847,-0.0271) );\n\n\n   // grab a normal for reflecting the sample rays later on\n   vec3 fres = normalize(texture2D(noise,v_texcoord).xyz*2.0 - 1.0);\n\n   vec4 sample = texture2D(normals, v_texcoord);\n   vec3 color  = texture2D(colors, v_texcoord).xyz;\n\n   vec3 normal = sample.xyz;\n   float depth  = sample.a;\n\n   // current fragment coords in screen space\n   vec3 ep = vec3(v_texcoord, depth);\n\n   float bl = 0.0;\n\n   // adjust for the depth ( not shure if this is good..)\n   float radD = radius / depth;\n\n   vec3 ray, se, occNorm;\n   float occluderDepth, depthDifference, normDiff;\n\n   for(int i=0; i<samples; i++)\n   {\n      // Get a random vector inside the unit sphere\n      ray = radD * reflect(sample_kernel[i], fres);\n\n      // If the ray is outside the hemisphere then change direction\n      se = ep + sign(dot(ray,normal) )*ray;\n\n      // Get the depth of the occluder fragment\n      vec4 occluderFragment = texture2D(normals,se.xy);\n\n      // get the normal of the occluder fragment\n      occNorm = occluderFragment.xyz;\n\n      // if depthDifference is negative = occluder is behind current fragment\n      depthDifference = depth - occluderFragment.a;\n\n      // calculate the difference between the normals as a weight\n      normDiff = (1.0-dot(occNorm,normal));\n\n      // the falloff equation, starts at falloff and is kind of 1/x^2 falling\n      bl += step(falloff,depthDifference)*normDiff*(1.0-smoothstep(falloff,strength,depthDifference));\n   }\n\n   // output the result\n   float ao = 1.0 - base*bl/16;\n   gl_FragColor.rgb = color * ao;\n   gl_FragColor.a = 1.0;\n}\n""""""\n\nwindow = app.Window(width=800, height=800, color=(1,1,1,1))\n\nprotein = gloo.Program(vertex, fragment)\nprotein[\'light_position\'] = 0., 0., 2.\nprotein[""transform""] = Trackball(Position(), znear=2.0, zfar=100.0)\nprotein.bind(data.get(""protein.npy"").view(gloo.VertexBuffer))\n\nssao= gloo.Program(ssao_vertex, ssao_fragment, count=4)\nssao[\'position\']= [(0,0), (0,1), (1,0), (1,1)]\nssao[\'base\']    = 1.00\nssao[\'strength\']= 0.20;\nssao[\'falloff\'] = 0.000002;\nssao[\'radius\']  = 0.01;\n\nssao[\'normals\'] = np.zeros((800,800,4),np.float32).view(gloo.Texture2D)\nssao[\'normals\'].interpolation = gl.GL_LINEAR\nssao[\'colors\'] = np.zeros((800,800,4),np.float32).view(gloo.Texture2D)\nssao[\'colors\'].interpolation = gl.GL_LINEAR\nssao[\'noise\'] = np.random.uniform(0,1,(256,256,3))\nssao[\'noise\'].interpolation = gl.GL_LINEAR\n\nframebuffer = gloo.FrameBuffer(color= [ssao[""colors""], ssao[""normals""]],\n                               depth=gloo.DepthBuffer(800, 800))\n\n@window.event\ndef on_draw(dt):\n    # First pass to record colors, normals and depth\n    framebuffer.activate()\n    window.clear()\n    protein.draw(gl.GL_POINTS)\n    framebuffer.deactivate()\n\n    # Actual Screen Space Ambien Occlusion (SSAO)\n    window.clear()\n    ssao.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glDisable(gl.GL_BLEND)\n\nwindow.attach(protein[""transform""])\napp.run()\n'"
examples/protein.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gloo, gl, data\nfrom glumpy.transforms import Position, Trackball\nfrom glumpy.graphics.filter import Filter\n\nvertex = """"""\nuniform vec3 light_position;\n\nattribute vec3 position;\nattribute vec3 color;\nattribute float radius;\n\nvarying float v_size;\nvarying vec3 v_color;\nvarying float v_radius;\nvarying vec4 v_eye_position;\nvarying vec3 v_light_direction;\n\nvoid main (void)\n{\n    v_color = color;\n    v_radius = radius;\n    v_eye_position = <transform.trackball_view> *\n                     <transform.trackball_model> *\n                     vec4(position,1.0);\n    v_light_direction = normalize(light_position);\n    gl_Position = <transform(position)>;\n    // stackoverflow.com/questions/8608844/...\n    //  ... resizing-point-sprites-based-on-distance-from-the-camera\n    vec4 p = <transform.trackball_projection> *\n             vec4(radius, radius, v_eye_position.z, v_eye_position.w);\n    v_size = 512.0 * p.x / p.w;\n    gl_PointSize = v_size + 5.0;\n}\n""""""\n\nfragment = """"""\n#include ""antialias/outline.glsl""\n\n\nvarying float v_size;\nvarying vec3 v_color;\nvarying float v_radius;\nvarying vec4 v_eye_position;\nvarying vec3 v_light_direction;\n\nvoid main()\n{\n    vec2 P = gl_PointCoord.xy - vec2(0.5,0.5);\n    float point_size = v_size  + 5.0;\n    float distance = length(P*point_size) - v_size/2;\n\n    vec2 texcoord = gl_PointCoord* 2.0 - vec2(1.0);\n    float x = texcoord.x;\n    float y = texcoord.y;\n    float d = 1.0 - x*x - y*y;\n\n    if (d <= 0.0) discard;\n\n    float z = sqrt(d);\n    vec4 pos = v_eye_position;\n    pos.z += v_radius*z;\n    vec3 pos2 = pos.xyz;\n\n    pos = <transform.trackball_projection> * pos;\n    gl_FragDepth = 0.5*(pos.z / pos.w)+0.5;\n    vec3 normal = vec3(x,y,z);\n    float diffuse = clamp(dot(normal, v_light_direction), 0.0, 1.0);\n\n    vec4 color = vec4((0.5 + 0.5*diffuse)*v_color, 1.0);\n    gl_FragColor = outline(distance, 1.0, 1.0, vec4(0,0,0,1), color);\n    // gl_FragColor = color;\n}\n""""""\n\nwindow = app.Window(width=800, height=800, color=(1,1,1,1))\n\nprotein = gloo.Program(vertex, fragment)\nprotein[\'light_position\'] = 0., 0., 2.\nprotein[""transform""] = Trackball(Position())\nprotein.bind(data.get(""protein.npy"").view(gloo.VertexBuffer))\nprotein[\'color\'] *= .25\nprotein[\'color\'] += .75\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    protein.draw(gl.GL_POINTS)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\nwindow.attach(protein[""transform""])\napp.run()\n'"
examples/quiver.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\n\nvertex = """"""\n    attribute vec2 position;\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n    }\n""""""\n\nfragment = """"""\n#include ""math/constants.glsl""\n#include ""arrows/arrows.glsl""\n#include ""antialias/antialias.glsl""\n\nuniform vec2 iResolution;\nuniform vec2 iMouse;\nvoid main()\n{\n    const float M_PI = 3.14159265358979323846;\n    const float SQRT_2 = 1.4142135623730951;\n    const float linewidth = 3.0;\n    const float antialias =  1.0;\n\n    const float rows = 32.0;\n    const float cols = 32.0;\n    float body = min(iResolution.x/cols, iResolution.y/rows) / SQRT_2;\n    vec2 texcoord = gl_FragCoord.xy;\n    vec2 size   = iResolution.xy / vec2(cols,rows);\n    vec2 center = (floor(texcoord/size) + vec2(0.5,0.5)) * size;\n\n\n\n    texcoord -= center;\n\n    // float theta = M_PI/3.0 + 0.1*(center.x / cols + center.y / rows);\n    float theta = M_PI-atan(center.y-iMouse.y,  center.x-iMouse.x);\n\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    texcoord = vec2(cos_theta*texcoord.x - sin_theta*texcoord.y,\n                    sin_theta*texcoord.x + cos_theta*texcoord.y);\n\n    // float d = arrow_curved(texcoord, body, 0.25*body, linewidth, antialias);\n    float d = arrow_stealth(texcoord, body, 0.25*body, linewidth, antialias);\n    // float d = arrow_triangle_90(texcoord, body, 0.15*body, linewidth, antialias);\n    // float d = arrow_triangle_60(texcoord, body, 0.20*body, linewidth, antialias);\n    // float d = arrow_triangle_30(texcoord, body, 0.25*body, linewidth, antialias);\n    // float d = arrow_angle_90(texcoord, body, 0.15*body, linewidth, antialias);\n    // float d = arrow_angle_60(texcoord, body, 0.20*body, linewidth, antialias);\n    // float d = arrow_angle_30(texcoord, body, 0.25*body, linewidth, antialias);\n\n    gl_FragColor = filled(d, linewidth, antialias, vec4(0,0,0,1));\n    // gl_FragColor = stroke(d, linewidth, antialias, vec4(0,0,0,1));\n}\n""""""\n\n\nwindow = app.Window(width=2*512, height=2*512, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_resize(width, height):\n    program[""iResolution""] = width, height\n\n@window.event\ndef on_mouse_motion(x, y, dx, dy):\n    program[""iMouse""] = x,window.height-y\n\nprogram = gloo.Program(vertex, fragment, count=4)\ndx,dy = 1,1\nprogram[\'position\'] = (-dx,-dy), (-dx,+dy), (+dx,-dy), (+dx,+dy)\n\napp.run()\n'"
examples/realtime-signals.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# Realtime signals example\n#\n# Implementation uses a ring buffer such that only new values are uploaded in\n# GPU memory. This requires the corresponding numpy array to have a\n# Fortran-like layout.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl\n\nvertex = """"""\nuniform int index, size, count;\nattribute float x_index, y_index, y_value;\nvarying float do_discard;\nvoid main (void)\n{\n    float x = 2*(mod(x_index - index, size) / (size)) - 1.0;\n    if ((x >= +1.0) || (x <= -1.0)) do_discard = 1;\n    else                            do_discard = 0;\n    float y = (2*((y_index+.5)/(count))-1) + y_value;\n    gl_Position = vec4(x, y, 0, 1);\n}\n""""""\n\nfragment = """"""\nvarying float do_discard;\nvoid main(void)\n{\n    if (do_discard > 0) discard;\n    gl_FragColor = vec4(0,0,0,1);\n}\n""""""\n\nwindow = app.Window(width=1500, height=1000, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    global size, count\n    window.clear()\n    program.draw(gl.GL_LINES, I)\n    index = int(program[""index""])\n    y = program[""y_value""].reshape(size,count)\n\n    yscale = 1.0/count\n    y[index] = yscale * np.random.uniform(-1,+1,count)\n    program[""index""] = (index + 1) % size\n\ncount, size = 64, 1000\nprogram = gloo.Program(vertex, fragment, count=size*count)\nprogram[""size""] = size\nprogram[""count""] = count\nprogram[""x_index""] = np.repeat(np.arange(size),count)\nprogram[""y_index""] = np.tile(np.arange(count),size)\nprogram[""y_value""] = 0\n\n# Compute indices\nI = np.arange(count * size, dtype=np.uint32).reshape(size, -1).T\nI = np.roll(np.repeat(I, 2, axis=1), -1, axis=1)\nI = I.view(gloo.IndexBuffer)\n\napp.run()\n'"
examples/shadertoy-ellipse.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" Adaptation of https://www.shadertoy.com/view/4sS3zz """"""\n\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\n\nvertex = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main (void)\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n""""""\n\nfragment = """"""\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Analytical distance to an 2D ellipse, which is more complicated than it seems. It ends up being\n// a quartic equation, which can be resolved through a cubic, then a quadratic. Some steps through the\n// derivation can be found in this article:\n//\n// http://iquilezles.org/www/articles/ellipsedist/ellipsedist.htm\n//\n\nuniform vec2 iResolution;\n\nvec4 stroke(float distance, float linewidth, float antialias, vec4 stroke)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    if( border_distance > (linewidth/2.0 + antialias) )\n        discard;\n    else if( border_distance < 0.0 )\n        frag_color = stroke;\n    else\n        frag_color = vec4(stroke.rgb, stroke.a * alpha);\n\n    return frag_color;\n}\n\nfloat sdEllipse(vec2 p, in vec2 ab )\n{\n    p = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;\n    float n = ab.y*p.y/l;\n    float m2 = m*m;\n    float n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n    float c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if(d < 0.0)\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt(1.0 - co*co);\n    vec2 closestPoint = vec2(ab.x*co, ab.y*si);\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\nvoid main(void)\n{\n    vec2 uv = gl_FragCoord.xy - iResolution.xy/2.;\n    float d = sdEllipse(uv, vec2(.4,.1) * iResolution);\n\n    // Outline\n    gl_FragColor = stroke(abs(d), 50.0, 1.0, vec4(0,0,0,1));\n\n    // Outline of outline\n    // gl_FragColor = stroke(abs(d)-100.0, 5.0, 1.0, vec4(0,0,0,1));\n}\n""""""\n\n\nwindow = app.Window(width=800, height=800,\n                    color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_resize(width, height):\n    program[""iResolution""] = width, height\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\ngl.glEnable(gl.GL_BLEND)\ngl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\napp.run(framerate=60)\n'"
examples/shadertoy-fluid.py,0,"b'# -*- coding: utf-8 -*-\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nFast rendering of vector field (fluid for example).\nCode is based on https://www.shadertoy.com/view/4llGWl#\n""""""\n\nfrom glumpy import app, gl, gloo, data\n\nvertex = \'\'\'\nattribute vec2 a_position;\nvarying vec2 fragCoord;\n\nvoid main()\n{\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    fragCoord = a_position;\n}\n\'\'\'\n\nfragment = \'\'\'\n#include ""math/constants.glsl""\nvarying vec2 fragCoord;\nuniform float iGlobalTime;\nuniform vec2 iMouse;\nuniform sampler2D iChannel0;\n\n#define CUBIC_INTERPOLATION\n#define STEP_COUNT 10\n#define RUNGE_KUTTA\n//#define SHOW_GRID\n#define SHOW_FIELD\n//#define SHOW_SPEED_SURFACE\n\nvec4 rot(vec2 uv, vec2 center) {\n    vec2 d = uv - center;\n    float l = length(d);\n    return vec4(d.y, -d.x, l, l+0.01);\n}\n\nvec4 point(vec2 uv, vec2 center) {\n    vec2 d = uv - center;\n    float l = length(d);\n    return vec4(d.x, d.y,l, l+0.01);\n}\n\nvec2 field(vec2 uv) {\n\tvec2 dir = vec2(1, 0);\n    vec2 mouse = (iMouse.x == 0. && iMouse.y==0.) ? vec2(-0.15,-0.1) : iMouse.xy;\n    vec4 rot1 = rot(uv, mouse);\n    vec4 rot2 = rot(uv, vec2(-mouse.x,mouse.y));\n  \t//vec4 p1 = point(uv, vec2(0.2,-0.2)); // source  point - looks bad\n    //vec4 p2 = point(uv, vec2(-0.2,-0.2));  // sewer\n\n    return\n      // dir // constant part\n        0.5*(\n        + rot1.xy/(rot1.z*rot1.z+0.1)\n        - rot2.xy/(rot2.z*rot2.z+0.1)\n       // + p1.xy/(p1.z*p1.z+0.1)\n       //  -p2.xy/(p2.z*p2.z+0.1)\n       );\n}\n\nfloat getColor(vec2 uv) {\n    #ifdef SHOW_GRID\n    \tvec2 d = step(0.95, fract(uv*10.));\n    \treturn (d.x + d.y);\n\t#elif defined SHOW_FIELD\n\t    vec2 d = step(0.9, fract(uv*10.));\n\t    return d.x*d.y;\n\t#else\n\t    float c= texture2D(iChannel0, .5*(uv+1.)).x;\n\t    return c;\n    #endif\n}\n\nfloat sumColor = 0.;\nvec2 calcNext(vec2 uv, float t) {\n    t /= float(STEP_COUNT);\n    for(int i = 0; i < STEP_COUNT; ++i) {\n        #ifdef RUNGE_KUTTA\n        \tvec2 k1 = -field(uv);\n        \tvec2 k2 = -field(uv + k1*t/2.);\n        \tvec2 k3 = -field(uv + k2*t/2.);\n\t        vec2 k4 = -field(uv + k3*t);\n    \t    uv = uv + t/6.*(k1+2.*k2+2.*k2+k3);\n        #else\n        \tuv += -field(uv)*t;\n        #endif\n\n        #ifdef SHOW_FIELD\n        \tsumColor += getColor(uv);\n        #endif\n    }\n\n    return uv;\n}\n\nfloat cubic(float x, float v0,float v1, float v2,float v3)\n{\n\tfloat p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\n\n\nfloat getColor(vec2 uv, float cf, float per) {\n\n    float k1 = 0.5;\n    float k2 = 0.;\n\n    float t1 = per * cf/4.;\n    float t2 = t1 + per/4.;\n #ifdef SHOW_FIELD\n\t calcNext(uv, t1 * k1 + k2);\n     float  c =sumColor;\n #else\n    vec2 uv1 = calcNext(uv, t1 * k1 + k2);\n    vec2 uv2 = calcNext(uv, t2 * k1 + k2);\n    float c1 = getColor(uv1);\n    float c2 = getColor(uv2);\n\n    #ifdef CUBIC_INTERPOLATION\n        float t3 = t2 + per/4.;\n        float t4 = t3 + per/4.;\n        vec2 uv3 = calcNext(uv, t3 * k1 + k2);\n        vec2 uv4 = calcNext(uv, t4 * k1 + k2);\n        float c3 = getColor(uv3);\n        float c4 = getColor(uv4);\n\n    \tfloat c = cubic(cf, c4,c3,c2,c1);\n\t#else\n    \tfloat c = mix(c2,c1, cf);\n \t#endif\n #endif\n    // SHOW_FIELD\n    return c;\n\n}\n\nvoid main() {\n\n    vec2 uv = fragCoord;\n\n    float per = 2.;\n\n    float cf = fract(iGlobalTime / per);\n    float cl = getColor(uv,cf, per);\n    float l = length(field(uv));\n    cl = (cl-0.8)*2.+0.8;\n    vec4 c = vec4(cl);\n\n#ifdef SHOW_SPEED_SURFACE\n    float del = 0.1;\n    float q = smoothstep(0.8, 1., fract(l/del));\n    vec4 range = mix(vec4(0, 1, 0, 0), vec4(1, 0, 0.5, 0), l*0.4)*2.;\n    c +=range*q;\n#endif\n   c += 0.75*vec4(1.0, 0.6, 0.2, 1.)*exp(-1./abs(l+0.1))*2.;\n   c *= smoothstep(0., 1.,l)+0.2;\n\n\tgl_FragColor = c;\n}\n\n\'\'\'\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'a_position\'] = [(-1., -1.), (-1., +1.),\n                         (+1., -1.), (+1., +1.)]\nprogram[\'iChannel0\'] = data.checkerboard()\nprogram[\'iGlobalTime\'] = 0.0\n\nwindow = app.Window(width=900, height=900)\n\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n    program[\'iGlobalTime\'] += dt\n\n\n@window.event\ndef on_resize(width, height):\n    gl.glViewport(0, 0, width, height)\n\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)\n    program[""iMouse""] = 2 * x / w - 1, 1 - 2 * y / h\n\n\n@window.timer(1 / 5.0)\ndef timer(dt):\n    window.set_title(""time:{:5.1f}\\tfps:{:3.1f}"".format(program[\'iGlobalTime\'][0], window.fps).encode())\n\n\napp.run()\n'"
examples/shadertoy-fluidobstacles.py,0,"b'# -*- coding: utf-8 -*-\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nFluid with obstacles.\nhttps://www.shadertoy.com/view/lllGDl\n""""""\n\nfrom glumpy import app, gl, gloo\n\nvertex = \'\'\'\nattribute vec2 a_position;\nvarying vec2 fragCoord;\n\nvoid main()\n{\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    fragCoord = a_position;\n}\n\'\'\'\n\nfragment = \'\'\'\nvarying vec2 fragCoord;\nuniform float iGlobalTime;\nuniform vec2 iMouse;\n\n#define STEP_COUNT 10\n\n//these are the field movers\nvec2 swirl(vec2 uv, vec2 center, float strength, float eyeWall) {\n    vec2 d = uv - center;\n    return vec2(d.y, -d.x)/(dot(d,d)/strength+eyeWall);\n}\nvec2 spray(vec2 uv, vec2 center, vec2 dir, float strength, float eyeWall){\n    vec2 d = uv - center;\n    return vec2(d.x, d.y)/(dot(d,d)/strength+eyeWall)*dot(d,dir);\n}\nvec2 drain(vec2 uv, vec2 center, float strength, float eyeWall){\n    vec2 d = uv - center;\n    return -vec2(d.x, d.y)/(dot(d,d)/strength+eyeWall);\n}\n//DE is used to define barriors\nfloat Tube(vec2 pa, vec2 ba){\n    return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));\n}\nfloat DE(vec2 p){\n    p+=vec2(0.5);\n    return min(length(p),Tube(p-vec2(1.0),vec2(0.4,0.2)));\n}\nvec2 ReflectOffSurf(vec2 p, vec2 r){\n    float d=max(DE(p),0.001);\n    vec2 v=vec2(d,0.0);\n    vec2 N=normalize(vec2(DE(p+v.xy)-DE(p-v.xy),DE(p+v.yx)-DE(p-v.yx)));\n    d=clamp(sqrt(d)*1.1,0.0,1.0);\n    r=mix(reflect(r,N)*clamp(0.5-0.5*dot(r,N),0.0,1.0),r*d,d);\n    return r;\n}\nvec2 field(vec2 uv) {\n    vec2 mouse = (iMouse.x == 0. && iMouse.y==0.) ? vec2(-0.15,-0.1) : iMouse.xy;\n    mouse*=3.0;\n    vec2 p=\n        swirl(uv, mouse,1.5,0.25)\n        +spray(uv,-mouse,vec2(-1.0,0.5),0.5,0.1)\n        +drain(uv,mouse,0.5,0.75)\n    ;\n    p=ReflectOffSurf(uv,p);\n    return p;\n}\n\n//just basic clouds from perlin noise\nfloat rand(vec2 co){return fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453);}\nfloat noyz(vec2 co){\n    vec2 d=smoothstep(0.0,1.0,fract(co));\n    co=floor(co);\n    const vec2 v=vec2(1.0,0.0);\n    return mix(mix(rand(co),rand(co+v.xy),d.x),\n        mix(rand(co+v.yx),rand(co+v.xx),d.x),d.y);\n}\nfloat clouds( in vec2 q, in float tm )\n{\n    float f=0.0,a=0.6;\n    for(int i=0;i<5;i++){\n            f+= a*noyz( q+tm );\n        q = q*2.03;\n        a = a*0.5;\n    }\n    return f;\n}\n\nfloat getPattern(vec2 uv) {\n    //this can be any pattern but moving patterns work best\n    float w=clouds(uv*5.0, iGlobalTime*0.5);\n    return w;\n}\n\nvec2 calcNext(vec2 uv, float t) {\n    t /= float(STEP_COUNT);\n    for(int i = 0; i < STEP_COUNT; ++i) {\n        uv -= field(uv)*t;\n    }\n    return uv;\n}\n\nvec3 heatmap(float h){\n    return mix(vec3(0.1,0.2,0.4),vec3(2.0,1.5-h,0.5)/(1.0+h),h);\n}\n\nvec3 Fluid(vec2 uv, float t) {\n    float t1 = t*0.5;\n    float t2 = t1 + 0.5;\n    vec2 uv1 = calcNext(uv, t1);\n    vec2 uv2 = calcNext(uv, t2);\n    float c1 = getPattern(uv1);\n    float c2 = getPattern(uv2);\n    float c=mix(c2,c1,t);\n    float f=1.5-0.5*abs(t-0.5);\n    c=pow(c,f)*f;//correcting the contrast/brightness when sliding\n    float h=mix(length(uv-uv2),length(uv-uv1),t);\n    return 2.0*c*heatmap(clamp(h*0.5,0.0,1.0));//blue means slow, red = fast\n}\n\nvoid main()\n{\n    vec2 uv = fragCoord;\n    uv*=3.0;\n    float t = fract(iGlobalTime);\n    vec3 c = Fluid(uv,t);//draws fluid\n    float d=DE(uv);//get distance to objects\n    c=mix(vec3(1.0-10.0*d*d),c,smoothstep(0.2,0.25,d));//mix in objects\n    gl_FragColor = vec4(c,1.0);\n}\n\n\'\'\'\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'a_position\'] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]\nprogram[\'iGlobalTime\'] = 0.0\n\nwindow = app.Window(width=900, height=900)\n\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)\n    program.draw(gl.GL_TRIANGLE_STRIP)\n    program[\'iGlobalTime\'] += dt\n\n\n@window.event\ndef on_mouse_press(x, y, button):\n    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)\n    program[""iMouse""] = 2 * x / w - 1, 1 - 2 * y / h\n\n\n@window.timer(1 / 5.0)\ndef timer(dt):\n    window.set_title(""time:{:5.1f}\\tfps:{:3.1f}"".format(program[\'iGlobalTime\'][0], window.fps).encode())\n\n\napp.run()\n'"
examples/shadertoy-template.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" Shadertoy template to test a shadertoy from www.shadertoy.com """"""\n\nimport datetime\nimport time\nimport numpy as np\nfrom glumpy import app, gl, gloo\n\nvertex = """"""\nattribute vec2 position;\nvoid main (void)\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n""""""\n\nfragment = """"""\nuniform vec3      iResolution; // Viewport resolution (in pixels)\nuniform float     iTime;       // Shader playback time (in seconds)\nuniform vec4      iMouse;      // Mouse pixel coords. xy: current (if MLB down) + zw: click\nuniform vec4      iDate;       // Date as (year, month, day, time in seconds)\n// uniform float     iChannelTime[4];       // Channel playback time (in seconds)\n// uniform vec3      iChannelResolution[4]; // Channel resolution (in pixels)\n// uniform sampler2D iChannel[4];           // Input channel. (XX = 2D or Cube)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n\n// Put your shadertoy code here\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(uv,0.5*sin(1.0+iTime),1.0);\n}\n""""""\n\nstart_time = time.time()\nwindow = app.Window(width=800, height=800)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n    program[""iTime""] = start_time - time.time()\n    today = datetime.datetime.now()\n    seconds = (today.hour*60*60 + today.minute*60 + today.second)\n    program[""iDate""] = today.year, today.month, today.day, seconds\n\n@window.event\ndef on_resize(width, height):\n    program[""iResolution""] = width, height, 0\n\n@window.event\ndef on_mouse_drag(x, y, dx, dy, button):\n    buttons = {app.window.mouse.NONE   : 0, app.window.mouse.LEFT  : 1,\n               app.window.mouse.MIDDLE : 2, app.window.mouse.RIGHT : 3 }\n    program[""iMouse""] = x, y, buttons[button], 0\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\ngl.glEnable(gl.GL_BLEND)\ngl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\napp.run(framerate=60)\n'"
examples/shadertoy-voronoi.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" Voronoi shadertoy example from  www.shadertoy.com/view/ldl3W8 """"""\n\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\n\n\nvertex = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main (void)\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n""""""\n\nfragment = """"""\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// I\'ve not seen anybody out there computing correct cell interior distances for Voronoi\n// patterns yet. That\'s why they cannot shade the cell interior correctly, and why you\'ve\n// never seen cell boundaries rendered correctly.\n\n// However, here\'s how you do mathematically correct distances (note the equidistant and non\n// degenerated grey isolines inside the cells) and hence edges (in yellow):\n\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n#define ANIMATE\n\nuniform vec2 iResolution;\nuniform float iGlobalTime;\nuniform float scale;\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    vec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g);\n    \t#ifdef ANIMATE\n            o = 0.5 + 0.5*sin( iGlobalTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g);\n        #ifdef ANIMATE\n            o = 0.5 + 0.5*sin( iGlobalTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nvec4 stroke(float distance, float linewidth, float antialias, vec4 stroke)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    if( border_distance > (linewidth/2.0 + antialias) )\n        discard;\n    else if( border_distance < 0.0 )\n        frag_color = stroke;\n    else\n        frag_color = vec4(stroke.rgb, stroke.a * alpha);\n\n    return frag_color;\n}\n\nvoid main( void )\n{\n    float s = scale/20.0;\n    vec2 p = gl_FragCoord.xy/iResolution.xx - 0.5;\n    vec3 c = voronoi( scale*p );\n\n    // isolines\n    vec3 color = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n\n    // borders\n    color = mix( vec3(1.0,1.0,1.0), color, smoothstep( 0.03*s, 0.04*s, c.x ) );\n\n    // feature points\n    float dd = length( c.yz );\n    color += vec3(1.0,1.0,0.0)*(1.0-smoothstep( 0.04*s, 0.05*s, dd));\n\n    gl_FragColor = vec4(color,1.0);\n}\n""""""\n\n\nwindow = app.Window(width=800, height=800)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n    program[""iGlobalTime""] += dt\n\n@window.event\ndef on_resize(width, height):\n    program[""iResolution""] = width, height\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    scale = program[""scale""]\n    program[""scale""] = min(max(1, scale + .01 * dy * scale), 100)\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nprogram[""iGlobalTime""] = 0\nprogram[""scale""] = 10\napp.run(framerate=60)\n'"
examples/skybox.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl, data\nfrom glumpy.transforms import Trackball, Position\n\nvertex = """"""\n    attribute vec3 position;\n    attribute vec3 texcoord;\n    varying vec3 v_texcoord;\n    void main()\n    {\n        gl_Position = <transform(position)> * vec4(-1,-1,1,1);\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\n    uniform samplerCube texture;\n    varying vec3 v_texcoord;\n    void main()\n    {\n        gl_FragColor = textureCube(texture, v_texcoord);\n    }\n""""""\n\n\nwindow = app.Window(width=1024, height=1024)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLES, indices)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\nvertices = np.array([[+1,+1,+1], [-1,+1,+1], [-1,-1,+1], [+1,-1,+1],\n                     [+1,-1,-1], [+1,+1,-1], [-1,+1,-1], [-1,-1,-1]])\ntexcoords = np.array([[+1,+1,+1], [-1,+1,+1], [-1,-1,+1], [+1,-1,+1],\n                     [+1,-1,-1], [+1,+1,-1], [-1,+1,-1], [-1,-1,-1]])\nfaces = np.array([vertices[i] for i in [0,1,2,3, 0,3,4,5, 0,5,6,1,\n                                        6,7,2,1, 7,4,3,2, 4,7,6,5]])\nindices = np.resize(np.array([0,1,2,0,2,3], dtype=np.uint32), 36)\nindices += np.repeat(4 * np.arange(6, dtype=np.uint32), 6)\nindices = indices.view(gloo.IndexBuffer)\ntexture = np.zeros((6,1024,1024,3),dtype=np.float32).view(gloo.TextureCube)\ntexture.interpolation = gl.GL_LINEAR\nprogram = gloo.Program(vertex, fragment, count=24)\nprogram[\'position\'] = faces*10\nprogram[\'texcoord\'] = faces\nprogram[\'texture\'] = texture\nprogram[\'transform\'] = Trackball(Position(), distance=0)\n\ntexture[2] = data.get(""sky-left.png"")/255.\ntexture[3] = data.get(""sky-right.png"")/255.\ntexture[0] = data.get(""sky-front.png"")/255.\ntexture[1] = data.get(""sky-back.png"")/255.\ntexture[4] = data.get(""sky-up.png"")/255.\ntexture[5] = data.get(""sky-down.png"")/255.\nwindow.attach(program[""transform""])\napp.run()\n'"
examples/snippet-cubes.py,12,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy.geometry import primitives\nfrom glumpy import app, gl, glm, gloo, data\nfrom glumpy.graphics.collections import BaseCollection\n\nvertex = """"""\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nattribute float index;\nattribute vec3 position;\nattribute vec2 texcoord;\n\nvarying float v_index;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    v_texcoord = texcoord;\n    v_index = index;\n\n    vec4 pos = projection * view * model * vec4(position,1.0);\n    gl_Position = <grid>;\n}\n""""""\n\nfragment = """"""\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvarying float v_index;\nvoid main()\n{\n    <clip>;\n    float r = texture2D(texture, v_texcoord).r;\n    gl_FragColor = vec4(vec3(r),1.0);\n}\n""""""\n\nGrid = gloo.Snippet(""""""\nuniform float rows, cols;\nvec4 cell(vec4 position, float index)\n{\n    float col = mod(index,cols) + 0.5;\n    float row = floor(index/cols) + 0.5;\n    float x = -1.0 + col * (2.0/cols);\n    float y = -1.0 + row * (2.0/rows);\n    float width = 0.95 / (1.0*cols);\n    float height = 0.95 / (1.0*rows);\n    vec4 P = position / position.w;\n    P = vec4(x + width*P.x, y + height*P.y, P.z, P.w);\n    return P*position.w;\n}\n"""""")\n\nClip = gloo.Snippet(""""""\nuniform vec2 iResolution;\nuniform float rows, cols;\nvoid clip(float index)\n{\n    vec2 P = gl_FragCoord.xy;\n\n    // mod doesn\'t play well with 0\n    float i = index+.00001;\n    float col = mod(i,cols);\n    float row = floor(i/cols);\n    float width  = iResolution.x / cols;\n    float height = iResolution.y / rows;\n    float x = col * width;\n    float y = row * height;\n    float gap = 1.5;\n\n    if( P.x < (x+gap))        discard;\n    if( P.x > (x+width-gap))  discard;\n    if( P.y < (y+gap))        discard;\n    if( P.y > (y+height-gap)) discard;\n\n}\n"""""")\n\nrows,cols = 3,3\nwindow = app.Window(width=1024, height=1024, color=(0.30, 0.30, 0.35, 1.00))\n\n# Build collection\ndtype = [(""position"", np.float32, 3),\n         (""normal"",   np.float32, 3),\n         (""texcoord"", np.float32, 2),\n         (""color"",    np.float32, 4),\n         (""index"",    np.float32, 1)]\ncubes = BaseCollection(vtype=dtype, itype=np.uint32)\nV,I = primitives.cube()\nC = np.zeros(len(V),dtype=dtype)\nfor key in V.dtype.names: C[key] = V[key]\nfor i in range(rows*cols):\n    C[""index""] = i\n    cubes.append(vertices=C, indices=I)\ncubes._update() \nV = cubes._vertices_buffer\nI = cubes._indices_buffer\n\n\n@window.event\ndef on_draw(dt):\n    global phi, theta\n    window.clear()\n    program.draw(gl.GL_TRIANGLES, I)\n    theta += 0.5\n    phi += 0.5\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    program[\'model\'] = model\n\n@window.event\ndef on_resize(width, height):\n    program[\'projection\'] = glm.perspective(fovy, width / float(height), 1.0, 100.0)\n    program[\'clip\'][\'iResolution\'] = width, height\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    global fovy\n    fovy = np.minimum(np.maximum(fovy*(1+dy/100), 10.0), 179.0)\n    program[\'projection\'] = glm.perspective(fovy,\n                                            window.width/float(window.height),\n                                            1.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glDisable(gl.GL_BLEND)\n\n\nprogram = gloo.Program(vertex, fragment)\nprogram.bind(V)\nview = np.eye(4, dtype=np.float32)\nmodel = np.eye(4, dtype=np.float32)\nprojection = np.eye(4, dtype=np.float32)\nglm.translate(view, 0, 0, -3)\nprogram[\'texture\'] = data.get(""checkerboard"")\nprogram[\'model\'] = model\nprogram[\'view\'] = view\nprogram[\'grid\'] = Grid(""pos"", ""index"")\nprogram[\'grid\'][""rows""] = rows\nprogram[\'grid\'][""cols""] = cols\nprogram[\'clip\'] = Clip(""v_index"")\nprogram[\'clip\'][""rows""] = rows\nprogram[\'clip\'][""cols""] = cols\n\nfovy = 30\nphi, theta = 30, 20\napp.run()\n'"
examples/snippet-grids.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl, glm\n\n\nPosition = gloo.Snippet(""""""\nvec4 position2D(vec2 position)\n{\n    return vec4(position, 0.0, 1.0);\n}\n"""""")\n\nXScale = gloo.Snippet(""""""\nuniform float xscale;\nvec2 scale(vec2 position)\n{\n    return vec2(xscale,1.0) * position;\n}\n"""""")\n\nGrid = gloo.Snippet(""""""\nuniform float rows, cols;\nvarying float v_x, v_y, v_index;\nvec2 cell(vec2 position, float index)\n{\n    v_index = index;\n    float col = mod(index,cols) + 0.5;\n    float row = floor(index/cols) + 0.5;\n    float x = -1.0 + col * (2.0/cols);\n    float y = -1.0 + row * (2.0/rows);\n    float w = 0.95 / (1.0*cols);\n    float h = 0.95 / (1.0*rows);\n    v_x = position.x;\n    v_y = position.y;\n    return vec2(x + w*v_x, y + h*v_y);\n}\n"""""")\n\nClip = gloo.Snippet(""""""\nvarying float v_x, v_y, v_index;\nvoid clip()\n{\n    if (fract(v_index) > 0.0) discard;\n    if( v_x < -0.95)          discard;\n    if( v_x > +0.95)          discard;\n    // if( v_y < -0.95)       discard;\n    // if( v_y > +0.95)       discard;\n}\n"""""")\n\n\nvertex = """"""\nattribute float index, posx, posy;\nattribute vec3 color;\nvarying vec3 v_color;\nvoid main (void)\n{\n    v_color = color;\n    gl_Position = <grid>;\n}\n""""""\n\nfragment = """"""\nvarying vec3 v_color;\nvoid main(void)\n{\n    <clip>;\n    gl_FragColor = vec4(v_color,1);\n}\n""""""\n\nwindow = app.Window(width=800, height=600)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_LINE_STRIP)\n    Y = program[""posy""].reshape(rows*cols,n)\n    Y[:,:-10] = Y[:,10:]\n    Y[:,-10:] = 0.5 * np.random.uniform(-1,1, (rows*cols,10))\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    dx = np.sign(dy) * .05\n    program[\'xscale\'] *= np.exp(2.5*dx)\n    program[\'xscale\'] = max(1.0, program[\'xscale\'])\n\nrows, cols, n = 16,20, 1000\nprogram = gloo.Program(vertex, fragment)\nprogram[""index""] = np.repeat(np.arange(rows*cols),n)\nprogram[""color""] = np.repeat(np.random.uniform(0.5,0.9,(rows*cols,3)),n,axis=0)\nprogram[""posx""] = np.tile(np.linspace(-1,1,n),rows*cols)\nprogram[""posy""] = 0.5*np.random.uniform(-1,1,rows*cols*n)\nprogram[""grid""] = Position(Grid(XScale(""vec2(posx,posy)""), ""index""))\nprogram[""grid""][""rows""] = rows\nprogram[""grid""][""cols""] = cols\nprogram[""grid""][""xscale""] = 1.0\nprogram[""clip""] = Clip()\n\n\napp.run()\n'"
examples/snippet-usage.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import gloo\n\ntransform_1 = gloo.Snippet(""""""\nuniform float scale;\nfloat forward(float x) { return scale*x; }\nfloat inverse(float x) { return scale*x; }\n"""""")\n\ntransform_2 = gloo.Snippet(""""""\nuniform float scale;\nfloat forward(float x) { return scale*x; }\nfloat inverse(float x) { return scale*x; }\n"""""")\n\ntransform_3 = gloo.Snippet(""""""\nvec2 compose(float x, float y) { return vec2(x,y); }\nvec2 compose(vec2 xy) { return xy; }\n"""""")\n\ncode= """"""\nuniform float scale;\n\nvoid main(void)\n{\n    // ---\n    float scale_t1 = <transform_1.scale>;\n    float scale_t2 = <transform_6.scale>;\n\n    // ---\n    // Argument must be given through snippet\n    <transform_1>;\n\n    // Argument cannot be given through snippet\n    <transform_2>(B);\n\n    // Argument can be overriden throught snippet\n    <transform_3(C)>;\n\n    // ---\n    // Default function (first defined) is used\n    <transform_4>;\n\n    // Forward function is used\n    <transform_5.forward>;\n\n    // Inverse function is used\n    <transform_6.inverse>;\n\n    // ---\n    // Compose snippet with specific field affectation\n    <transform_7>;\n\n    // Compose snippet with generic field affectation\n    // Note yet done\n    <transform_8(H)>;\n\n    <transform_8.x.scale>;\n    <transform_8.y.scale>;\n} """"""\n\nprogram = gloo.Program(code,""void main(){}"")\nprogram[""transform_1""] = transform_1(""A"")\nprogram[""transform_2""] = ""forward""\nprogram[""transform_3""] = transform_1()\nprogram[""transform_4""] = transform_1(""D"")\nprogram[""transform_5""] = transform_1(transform_2(""E""))\nprogram[""transform_6""] = transform_2(""F"", scale=""aliased_scale"")\nprogram[""transform_7""] = transform_3(transform_1(""G.x""), transform_2(""G.y""))\nprogram[""transform_8""] = transform_3(transform_1(\'.x\', name=\'x\'),\n                                     transform_2(\'.y\', name=\'y\'))\nprint(program.vertex.code)\n\n\n# Make sure that if snippet code has been already included in another program\n# it is nonetheless included in the new program\ncode= """"""\nvoid main(void)\n{\n    // Argument must be given through snippet\n    <transform>;\n}\n""""""\nprogram = gloo.Program(code, ""void main(){}"")\nprogram[""transform""] = transform_1(""A"")\n#print program.vertex.code\n'"
examples/snippet-viewport.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo, transforms\n\nvertex = """"""\nattribute vec2 position;\nvoid main()\n{\n    gl_Position = vec4(position,0,1);\n    <viewport.transform>;\n}\n""""""\n\nfragment = """"""\nvoid main()\n{\n    <viewport.clipping>;\n    gl_FragColor = vec4(1,0,0,1);\n}\n""""""\n\nwindow = app.Window(width=800, height=800)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\n\n# -- Child has size of root -10 pixels\nchild = app.Viewport(size=(-10,-10), position=(0.5,0.5), anchor=(0.5,0.5))\n\n# -- Child has 95% of size of root\n# child = app.Viewport(size=(.95,.95), position=(0.5,0.5), anchor=(0.5,0.5), aspect=1)\n\n# -- Child has a (fixed) size of 256x256\n# child = app.Viewport(size=(256,256), position=(0.5,0.5), anchor=(0.5,0.5), aspect=1)\n\n# -- Child is at bottom-left corner\n# child = app.Viewport(size=(256,256), position=(0.0,0.0), anchor=(0.0,0.0), aspect=1)\n\n# -- Child is at top-right corner\n# child = app.Viewport(size=(256,256), position=(-1,-1), anchor=(-1,-1), aspect=1)\n\n# -- Child is at top-right corner\n# child = app.Viewport(size=(0.5,0.5), position=(-1,-1), anchor=(-1,-1), aspect=1)\n\n\n@window.event\ndef on_resize(width,height):\n    root._requested_size = width, height\n    root._compute_viewport()\n    program[""viewport""][""global""] = root.extents\n    program[""viewport""][""local""] = child.extents\n\nroot = app.Viewport()\nroot.add(child)\nprogram[""viewport""] = transforms.Viewport()\napp.run()\n'"
examples/spherical-harmonics.py,12,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom scipy.special import sph_harm\nfrom glumpy import app, gl, gloo, transforms\n\n\ndef sphere(radius=1.0, slices=256, stacks=256):\n    vtype = [(\'theta\', np.float32, 1),\n             (\'phi\', np.float32, 1)]\n    slices += 1\n    stacks += 1\n    n = slices*stacks\n    vertices = np.zeros(n, dtype=vtype)\n    vertices[""theta""] = np.repeat(np.linspace(0, np.pi, stacks, endpoint=True), slices)\n    vertices[""phi""] = np.tile(np.linspace(0, 2 * np.pi, slices, endpoint=True), stacks)\n    indices = []\n    for i in range(stacks-1):\n        for j in range(slices-1):\n            indices.append(i*(slices) + j        )\n            indices.append(i*(slices) + j+1      )\n            indices.append(i*(slices) + j+slices+1)\n            indices.append(i*(slices) + j+slices  )\n            indices.append(i*(slices) + j+slices+1)\n            indices.append(i*(slices) + j        )\n    indices = np.array(indices, dtype=np.uint32)\n    return vertices.view(gloo.VertexBuffer), indices.view(gloo.IndexBuffer)\n\n\nvertex = """"""\nfloat harmonic(float theta, float phi, float m[8])\n{\n    return pow(sin(m[0]*phi),m[1]) + pow(sin(m[4]*theta),m[5]) +\n           pow(cos(m[2]*phi),m[3]) + pow(cos(m[6]*theta),m[7]);\n}\n\nuniform float time;\nuniform float m1[8];\nuniform float m2[8];\n\nattribute float phi;\nattribute float theta;\nvarying float v_theta;\nvarying float v_phi;\nvarying vec3 v_position;\n\nvoid main()\n{\n    float radius, x, y, z;\n\n    v_phi = phi;\n    v_theta = theta;\n\n    radius = 1.0 + 0.15*(harmonic(theta,phi,m1));\n    x = sin(theta) * sin(phi) * radius;\n    y = sin(theta) * cos(phi) * radius;\n    z = cos(theta) * radius;\n    vec3 position1 = vec3(x,y,z);\n\n    radius = 1.0 + 0.15*(harmonic(theta,phi,m2));\n    x = sin(theta) * sin(phi) * radius;\n    y = sin(theta) * cos(phi) * radius;\n    z = cos(theta) * radius;\n    vec3 position2 = vec3(x,y,z);\n\n    float t = (1.0+cos(time))/2.0;\n    vec4 position = vec4(mix(position1, position2,t), 1.0);\n    v_position = position.xyz;\n\n    gl_Position = <transform(position)>;\n}\n""""""\n\nfragment = """"""\nfloat segment(float edge0, float edge1, float x)\n{\n    return step(edge0,x) * (1.0-step(edge1,x));\n}\nvec3 ice(float t)\n{\n    return vec3(t, t, 1.0);\n}\nvec3 fire(float t) {\n    return mix(mix(vec3(1,1,1),vec3(1,1,0),t),mix(vec3(1,1,0),vec3(1,0,0),t*t),t);\n}\nvec3 ice_and_fire(float t)\n{\n    return segment(0.0,0.5,t)*ice(2.0*(t-0.0)) + segment(0.5,1.0,t)*fire(2.0*(t-0.5));\n}\n\nfloat harmonic(float theta, float phi, float m[8])\n{\n    return pow(sin(m[0]*phi),m[1]) + pow(sin(m[4]*theta),m[5]) +\n           pow(cos(m[2]*phi),m[3]) + pow(cos(m[6]*theta),m[7]);\n}\n\nuniform float time;\nuniform float m1[8];\nuniform float m2[8];\n\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying float v_phi;\nvarying float v_theta;\nvoid main()\n{\n    float t1 = (harmonic(v_theta, v_phi, m1)) / 4.0;\n    float t2 = (harmonic(v_theta, v_phi, m2)) / 4.0;\n    float t = (1.0+cos(time))/2.0;\n    t = mix(t1,t2,t);\n\n    vec4 bg_color = vec4(ice_and_fire(clamp(t,0,1)),1.0);\n    vec4 fg_color = vec4(0,0,0,1);\n\n    // Trace contour\n    float value = length(v_position);\n    float levels = 16.0;\n    float antialias = 1.0;\n    float linewidth = 1.0 + antialias;\n    float v  = levels*value - 0.5;\n    float dv = linewidth/2.0 * fwidth(v);\n    float f = abs(fract(v) - 0.5);\n    float d = smoothstep(-dv,+dv,f);\n    t = linewidth/2.0 - antialias;\n\n    d = abs(d)*linewidth/2.0 - t;\n    if( d < 0.0 ) {\n         gl_FragColor = bg_color;\n    } else  {\n        d /= antialias;\n        gl_FragColor = mix(fg_color,bg_color,d);\n    }\n\n\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024, color=(.3,.3,.3,1))\n\n@window.event\ndef on_draw(dt):\n    global time\n    time += dt\n\n    window.clear()\n    program[""time""] = time\n    program.draw(gl.GL_TRIANGLES, faces)\n\n    # trackball.phi = trackball.phi + 0.13\n    # trackball.theta = trackball.theta + 0.11\n\n    if (abs(time - np.pi)) < dt:\n        values = np.random.randint(0,7,8)\n        keys   = [""m2[0]"",""m2[1]"",""m2[2]"",""m2[3]"",""m2[4]"",""m2[5]"",""m2[6]"",""m2[7]""]\n        for key,value in zip(keys, values):\n            program[key] = value\n\n    elif (abs(time - 2*np.pi)) < dt:\n        values = np.random.randint(0,7,8)\n        keys   = [""m1[0]"",""m1[1]"",""m1[2]"",""m1[3]"",""m1[4]"",""m1[5]"",""m1[6]"",""m1[7]""]\n        for key,value in zip(keys, values):\n            program[key] = value\n        time = 0\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\ntime = 0\nvertices, faces = sphere()\nprogram = gloo.Program(vertex, fragment)\ntrackball = transforms.Trackball()\nprogram[""transform""] = trackball()\nprogram.bind(vertices)\n\nvalues = np.random.randint(0,7,8)\nkeys   = [""m1[0]"",""m1[1]"",""m1[2]"",""m1[3]"",""m1[4]"",""m1[5]"",""m1[6]"",""m1[7]""]\nfor key,value in zip(keys, values):\n    program[key] = value\n\nvalues = np.random.randint(0,7,8)\nkeys   = [""m2[0]"",""m2[1]"",""m2[2]"",""m2[3]"",""m2[4]"",""m2[5]"",""m2[6]"",""m2[7]""]\nfor key,value in zip(keys, values):\n    program[key] = value\n\ntrackball.zoom = 30\nwindow.attach(program[""transform""])\napp.run()\n'"
examples/spherical-voronoi.py,25,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport numpy.matlib\nimport scipy.spatial\nimport itertools\nfrom glumpy import app, gl\nfrom glumpy.graphics.collections import TriangleCollection, PathCollection\nfrom glumpy.transforms import Position, Trackball\n\n# -----------------------------------------------------------------------------\n# Copyright (C)  Tyler Reddy, Ross Hemsley, Edd Edmondson,\n#                Nikolai Nowaczyk, Joe Pitt-Francis, 2015.\n#\n# Distributed under the same BSD license as Scipy.\n# -----------------------------------------------------------------------------\n# This will soon appear in scipy.spatial, until then the code has been inserted\n# See: https://github.com/scipy/scipy/pull/5232\n# -----------------------------------------------------------------------------\ndef calc_circumcenters(tetrahedrons):\n    num = tetrahedrons.shape[0]\n    a = np.concatenate((tetrahedrons, np.ones((num, 4, 1))), axis=2)\n    sums = np.sum(tetrahedrons ** 2, axis=2)\n    d = np.concatenate((sums[:, :, np.newaxis], a), axis=2)\n    dx = np.delete(d, 1, axis=2)\n    dy = np.delete(d, 2, axis=2)\n    dz = np.delete(d, 3, axis=2)\n    dx = np.linalg.det(dx)\n    dy = -np.linalg.det(dy)\n    dz = np.linalg.det(dz)\n    a = np.linalg.det(a)\n    nominator = np.vstack((dx, dy, dz))\n    denominator = 2*a\n    return (nominator / denominator).T\n\ndef project_to_sphere(points, center, radius):\n    lengths = scipy.spatial.distance.cdist(points, np.array([center]))\n    return (points - center) / lengths * radius + center\n\nclass SphericalVoronoi:\n    def __init__(self, points, radius=None, center=None):\n        self.points = points\n        if np.any(center):\n            self.center = center\n        else:\n            self.center = np.zeros(3)\n        if radius:\n            self.radius = radius\n        else:\n            self.radius = 1\n        self.vertices = None\n        self.regions = None\n        self._tri = None\n        self._calc_vertices_regions()\n\n    def _calc_vertices_regions(self):\n        self._tri = scipy.spatial.ConvexHull(self.points)\n        tetrahedrons = self._tri.points[self._tri.simplices]\n        tetrahedrons = np.insert(\n            tetrahedrons,\n            3,\n            np.array([self.center]),\n            axis=1\n        )\n        circumcenters = calc_circumcenters(tetrahedrons)\n        self.vertices = project_to_sphere(\n            circumcenters,\n            self.center,\n            self.radius )\n        generator_indices = np.arange(self.points.shape[0])\n        filter_tuple = np.where((np.expand_dims(self._tri.simplices,\n                                -1) == generator_indices).any(axis=1))\n        list_tuples_associations = zip(filter_tuple[1],\n                                       filter_tuple[0])\n        list_tuples_associations = sorted(list_tuples_associations,\n                                          key=lambda t: t[0])\n        groups = []\n        for k, g in itertools.groupby(list_tuples_associations,\n                                      lambda t: t[0]):\n            groups.append([element[1] for element in list(g)])\n        self.regions = groups\n\n    def sort_vertices_of_regions(self):\n        for n in range(0, len(self.regions)):\n            remaining = self.regions[n][:]\n            sorted_vertices = []\n            current_simplex = remaining[0]\n            current_vertex = [k for k in self._tri.simplices[current_simplex]\n                              if k != n][0]\n            remaining.remove(current_simplex)\n            sorted_vertices.append(current_simplex)\n            while remaining:\n                current_simplex = [\n                    s for s in remaining\n                    if current_vertex in self._tri.simplices[s]\n                    ][0]\n                current_vertex = [\n                    s for s in self._tri.simplices[current_simplex]\n                    if s != n and s != current_vertex\n                    ][0]\n                remaining.remove(current_simplex)\n                sorted_vertices.append(current_simplex)\n            self.regions[n] = sorted_vertices\n# -----------------------------------------------------------------------------\n            \nwindow = app.Window(1200, 1200, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n\n    # Cells\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    cells.draw()\n\n    # Cell outlines\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    outlines.draw()\n    gl.glDepthMask(gl.GL_TRUE)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glPolygonOffset(1, 1)\n    gl.glEnable(gl.GL_LINE_SMOOTH)\n    gl.glLineWidth(0.75)\n\ntransform = Trackball(Position())\ncells     = TriangleCollection(""raw"", transform=transform, color=\'shared\')\noutlines  = PathCollection(""raw"", transform=transform, color=\'shared\')\n\n# Random points\nn = 2000\npoints = np.random.normal(size=(n, 3)) \npoints /= np.linalg.norm(points, axis=1)[:, np.newaxis]\n\n# Voronoi cells\nsv = SphericalVoronoi(points, 2, (0,0,0))\nsv.sort_vertices_of_regions()\n\nfor region in sv.regions:\n    z = np.random.uniform(0,1)\n\n    V = (1.0+0.1*z) * sv.vertices[region]\n    color = (.75+.25*z,.25+.75*z,.25+.75*z,1)\n\n    I = np.zeros((len(V)-2,3))\n    I[:,1] = 1 + np.arange(len(I))\n    I[:,2] = 1 + I[:,1]\n    cells.append(V, I.ravel(), color=color)\n    outlines.append(V, color=(0,0,0,1), closed=True)\n\n    V_ = []\n    for v1,v2 in zip(V[:-1],V[1:]):\n        V_.extend(((0,0,0),v1,v2))\n    V_.extend(((0,0,0), V[-1], V[0]))\n    \n    V_ = np.array(V_)\n    I = np.arange(len(V_))\n    cells.append(V_, I, color=color)\n    outlines.append(V_, color=(0,0,0,1), closed=True)\n    \n\nwindow.attach(outlines[""transform""])\nwindow.attach(outlines[""viewport""])\napp.run()\n'"
examples/spiral.py,18,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, glm, gl, library\nfrom glumpy.transforms import *\nfrom glumpy.graphics.collections import *\nfrom glumpy.graphics.text import FontManager\n\n\ndef linepath(P0, P1, n=100):\n    P = np.zeros((n,3))\n    xmin,ymin,zmin = P0\n    xmax,ymax,zmax = P1\n    P[:,0] = np.linspace(xmin, xmax, n, endpoint=True)\n    P[:,1] = np.linspace(ymin, ymax, n, endpoint=True)\n    P[:,2] = np.linspace(zmin, zmax, n, endpoint=True)\n    return P\n\nwindow = app.Window(width=1200, height=1000, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    labels.draw()\n    ticks.draw()\n    paths.draw()\n\nxscale = LinearScale("".x"", name=""xscale"", domain=[0,1], range=[0,1])\nyscale = LinearScale("".y"", name=""yscale"", domain=[0,1], range=[0,2*np.pi])\nzscale = LinearScale("".z"", name=""zscale"")\nprojection = PolarProjection(name=""data_projection"")\ntrackball = Trackball(name=""view_projection"", aspect=1)\ntransform = trackball(projection(Position(xscale,yscale,zscale)))\nviewport = Viewport()\n\nxmin,xmax = 0,1\nymin,ymax = 0,1\nzmin,zmax = 0,1\n\n\n# Outer Frame\n# -------------------------------------\npaths = PathCollection(""agg"", linewidth=""shared"", color=""shared"",\n                       transform=transform, viewport=viewport)\n\npaths.append(linepath((xmin,ymin,zmin),(xmax,ymin,zmin)), linewidth=2.0)\npaths.append(linepath((xmin,ymax,zmin),(xmax,ymax,zmin)), linewidth=2.0)\n\npaths.append(linepath((xmax,ymin,zmin),(xmax,ymax,zmin)), linewidth=2.0)\npaths.append(linepath((xmin,ymin,zmin),(xmin,ymax,zmin)), linewidth=2.0)\n\npaths.append(linepath((xmin,ymin,zmin),(xmin,ymin,zmax)), linewidth=2.0)\n\n# Grids\n# -------------------------------------\nn = 10+1\nX = np.linspace(xmin,xmax,n)[1:-1]\nfor x in X:\n    paths.append(linepath((x,ymin,zmin),(x,ymax,zmin)),\n                 linewidth=1.0, color=(0,0,0,.25))\nY = np.linspace(ymin,ymax,n)[1:-1]\nfor y in Y:\n    paths.append(linepath((xmin,y,zmin),(xmax,y,zmin)),\n                 linewidth=1.0, color=(0,0,0,.25))\n\n# Ticks\n# -------------------------------------\nticks = SegmentCollection(""agg"", transform=transform, viewport=viewport)\n\nn_major = 10+1\nn_minor = 50+1\nlength_major = 0.02\nlength_minor = 0.01\n\nfor x in np.linspace(xmin,xmax,n_major)[0:-1]:\n    paths.append(linepath((x,ymin,zmin),(x,ymin+length_major,zmin)),\n                 linewidth=2.0, color=(0,0,0,1))\nfor x in np.linspace(xmin,xmax,n_minor)[0:-1]:\n    paths.append(linepath((x,ymin,zmin),(x,ymin+length_minor,zmin)),\n                 linewidth=1.0, color=(0,0,0,1))\n\nlength_major = 0.04\nlength_minor = 0.02\nfor y in np.linspace(ymin,ymax,n_major)[0:-1]:\n    paths.append(linepath((xmax,y,zmin),(xmax-length_major,y,zmin)),\n                 linewidth=2.0, color=(0,0,0,1))\nfor y in np.linspace(ymin,ymax,n_minor)[0:-1]:\n    paths.append(linepath((xmax,y,zmin),(xmax-length_minor,y,zmin)),\n                 linewidth=1.0, color=(0,0,0,1))\n\nfor z in np.linspace(zmin,zmax,n_major)[0:-1]:\n    paths.append(linepath((xmin,ymin,z),(xmin+length_major,ymin,z)),\n                 linewidth=2.0, color=(0,0,0,1))\nfor z in np.linspace(zmin,zmax,n_minor)[0:-1]:\n    paths.append(linepath((xmin,ymin,z),(xmin+length_minor,ymin,z)),\n                 linewidth=1.0, color=(0,0,0,1))\n\n# Tick labels\n# -------------------------------------\nlabels = GlyphCollection(transform=transform, viewport=viewport,\n                         vertex = \'collections/tick-labels.vert\')\n\n\nregular = FontManager.get(""OpenSans-Regular.ttf"")\nn = 10+1\nscale = 0.002\nfor i,y in enumerate(np.linspace(xmin,xmax,n)[:-1]):\n    text = ""%.2f"" % (i/10.0)\n    labels.append(text, regular, origin = (xmax+0.1,y,zmin),\n                  scale = 0.65*scale, direction = (1,0,0),\n                  anchor_x = ""left"", anchor_y = ""center"")\n    labels.append(text, regular, origin = (y, -.001, zmin),\n                  scale = 0.65*scale, direction = (0,1,0),\n                  anchor_x = ""right"", anchor_y = ""center"")\n\n# Add some points\nn = 1000\nP = np.zeros((n,3))\nP[:,0] = np.linspace(+1,0,n)\nP[:,1] = np.linspace(0,4,n)\nP[:,2] = np.linspace(-1,1,n)\npaths.append(P, linewidth=3, color=(1,0,0,1))\n\ntrackball[""phi""] = 0\ntrackball[""zoom""] = 15\ntrackball[""theta""] = 40\nwindow.attach(paths[""transform""])\nwindow.attach(paths[""viewport""])\napp.run()\n'"
examples/svg-path.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\nimport numpy as np\nfrom glumpy import app, gl, data, svg, collections\nfrom glumpy.transforms import Position, OrthographicProjection, PanZoom, Viewport\n\n\nwindow = app.Window(800, 800, color=(1,1,1,1))\ntransform = PanZoom(OrthographicProjection(Position()))\n\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    paths[""antialias""] = -0.5\n    collections.Collection.draw(paths)\n    paths[""antialias""] = +1.0\n    collections.Collection.draw(paths)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n\npaths = collections.PathCollection(""agg"", transform=transform)\n# paths[""miter_limit""] = 4.0\npaths[""linewidth""] = 50.0\npaths[""color""] = 0.0,0.0,0.0,0.5\n\npath = svg.Path(""""""M 300,400\n                   c   0,100  200,-100  200,0\n                   c   0,100 -200,-100 -200,0 z"""""")\nvertices, closed = path.vertices[0]\npaths.append(vertices, closed=closed)\n\nwindow.attach(paths[""transform""])\nwindow.attach(paths[""viewport""])\napp.run()\n'"
examples/tiger.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\nimport triangle\nimport numpy as np\n\nfrom glumpy import app, gl, data\nfrom glumpy.graphics.svg import Document\nfrom glumpy.graphics.collections import PathCollection, PolygonCollection\nfrom glumpy.transforms import Position, OrthographicProjection, PanZoom, Viewport\n\n\ntiger = Document(data.get(""tiger.svg""))\nwindow = app.Window(int(tiger.viewport.width),\n                    int(tiger.viewport.height),\n                    color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    polygons.draw()\n    paths.draw()\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.reset()\n\n\ntransform = PanZoom(OrthographicProjection(Position(), yinvert=True), aspect=None)\npaths = PathCollection(""agg+"", transform=transform, linewidth=\'shared\', color=""shared"")\npolygons = PolygonCollection(""agg"", transform=transform)\n\nz = 0\nfor path in tiger.paths:\n    for vertices,closed in path.vertices:\n        if len(vertices) < 3:\n            continue\n        if path.style.stroke is not None:\n            vertices[:,2] = z + 0.5\n            if path.style.stroke_width:\n                stroke_width = path.style.stroke_width.value\n            else:\n                stroke_width = 2.0\n            paths.append(vertices, closed=closed, color=path.style.stroke.rgba,\n                         linewidth=stroke_width)\n        if path.style.fill is not None:\n            if path.style.stroke is None:\n                vertices[:,2] = z + 0.25\n                paths.append(vertices, closed=closed, color=path.style.fill.rgba,\n                             linewidth=1)\n            vertices[:,2] = z\n            polygons.append(vertices, color=path.style.fill.rgba)\n\n    z += 1\n\nwindow.attach(paths[""transform""])\nwindow.attach(paths[""viewport""])\napp.run()\n'"
examples/topojson-picking.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport csv, json\nimport numpy as np\nfrom glumpy import app, gl, gloo, data\nfrom glumpy.transforms import *\nfrom glumpy.graphics.collections import *\n\n\n# Building the transformation\n# ---------------------------\nscale = 2*1285.0\nLower48 = ConicEqualArea(scale = scale,    parallels = (29.5, 45.5),\n                         rotate = (96,0),  center = (0.38, -0.41))\nAlaska = ConicEqualArea(scale=scale/3,     parallels = (55, 65),\n                        rotate = (154, 0), center = (.32, -.8),\n                        clip = [-200, +200, +50, 100] )\nHawai = ConicEqualArea(scale=scale,        parallels = (8, 18),\n                        rotate = (157, 0), center = (.24, -.32),\n                        clip = [-180, -140, -90, +90] )\n\ntransform = PanZoom(OrthographicProjection(\n                   Position(Lower48(Hawai(Alaska(GeoPosition()))))))\n\n\n# Framebuffer vertex & fragment\n# -----------------------------\nquad_vertex = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    gl_Position = vec4(position,0,1);\n    v_texcoord = (position+1.0)/2.0;\n}""""""\n\nquad_fragment = """"""\nuniform sampler2D color;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    gl_FragColor = texture2D(color,v_texcoord);\n}\n""""""\n\n# Building collection using extended dtype and our own vertex/fragment \n# --------------------------------------------------------------------\nvertex = """"""\nvarying vec3 v_id;\nvarying vec4 v_color;\nvoid main()\n{\n    fetch_uniforms();\n    v_color = color;\n\n    int i = int(id);\n    v_id = vec3 ( mod(floor(id / (256*256)), 256) / 255.0,\n                  mod(floor(id /     (256)), 256) / 255.0,\n                  mod(floor(id /       (1)), 256) / 255.0);\n    gl_Position = <transform(position)>;\n} """"""\n\nfragment = """"""\n#include ""colormaps/colormaps.glsl""\nvarying vec4 v_color;\nvarying float rate;\nvarying vec3 v_id;\nvoid main(void)\n{\n    if( rate  > 0)\n        gl_FragData[0] = vec4(colormap_autumn(1-rate),1.0);\n    else\n        gl_FragData[0] = v_color;\n    gl_FragData[1] = vec4(v_id, 1.0);\n}\n""""""\nuser_dtype = [ (\'rate\', (np.float32, 1), \'shared\', 0.0),\n               (\'id\',   (np.float32, 1), \'shared\', 0.0) ]\npaths = PathCollection(""agg+"", transform=transform, linewidth=\'shared\', color=""shared"")\npolys = PolygonCollection(""raw"", transform=transform, color=""shared"",\n                          user_dtype=user_dtype, vertex=vertex, fragment=fragment)\n\n\n# Opening the topojson file\n# -------------------------\nwith open(data.get(""us.json""), \'r\') as file:\n    geomap = json.load(file)\narcs = geomap[""arcs""]\nscale = geomap[\'transform\'][\'scale\']\ntranslate = geomap[\'transform\'][\'translate\']\n\n# Apply scale and transform to all coordinates (= arcs)\n_arcs = []\nfor arc in arcs:\n    _arc = []\n    x, y = translate[0], translate[1]\n    for position in arc:\n        x = x + position[0]*scale[0] \n        y = y + position[1]*scale[1] \n        _arc.append((x,y))\n    _arcs.append(_arc)\narcs = _arcs\n\n# A polygon is made of one or several rings, a ring is made of arcs\n# If there is several rings, the first is the exterior ring while the others are holes\ndef build_paths(obj):\n    paths = []\n    if obj[""type""] == ""Polygon"": polygons = [obj[""arcs""]]\n    else:                        polygons =  obj[""arcs""]\n    for polygon in polygons:\n        for ring in polygon:\n            path = []\n            for i,arc in enumerate(ring):\n                if i == 0:\n                    if arc >= 0: path.extend(arcs[arc])\n                    else:        path.extend((arcs[~arc])[::-1])\n                else:\n                    if arc >= 0: path.extend(arcs[arc][1:])\n                    else:        path.extend((arcs[~arc][:-1])[::-1])\n            if len(path) > 2:\n                V = np.zeros((len(path),3), dtype=np.float32)\n                V[:,:2] = np.array(path)\n                paths.append(V)\n    return paths\n\n\n# Opening the unemployment rate\n# -----------------------------\nunemployment = {}\nwith open(data.get(\'us-unemployment.tsv\'), \'r\') as file:\n    reader = csv.reader(file, delimiter=\'\\t\')\n    next(reader, None) # skip the header\n    for row in reader:\n        unemployment[int(row[0])] = float(row[1]) / 0.16\n\n                     \n# Building the chloropleth\n# ------------------------\n# We could exploit the topojson format to restrict path drawing to\n# non-overlapping paths\n\n# State counties\nfor county in geomap[""objects""][""counties""][""geometries""]:\n    for V in build_paths(county):\n        paths.append(V, closed=True, color=(1,1,1,.5), linewidth=1.0)\n        if len(V) > 3:\n            key = county[""id""]\n            rate = 0.0\n            if key in unemployment.keys():\n                rate = unemployment[county[""id""]]\n            polys.append(V[:-1], color=(1,1,1,1), rate=rate, id=-1)\n\n# Federal states\nfor state in geomap[""objects""][""states""][""geometries""]:\n    for V in build_paths(state):\n        V[:,2] = 1\n        paths.append(V, closed=True, color=(.25,.25,.25,1), linewidth=0.75)\n        if len(V) > 3:\n            index = len(polys)\n            polys.append(V[:-1], color=(1,1,1,0.75), rate=-1, id=index)\n\n# USA land\nfor V in build_paths(geomap[""objects""][""land""]):\n    paths.append(V, closed=True, color=(0,0,0,1), linewidth=1.5)\n\n\n\nwindow = app.Window(2*960, 2*600, color=(1,1,1,1))\n\nquad = gloo.Program(quad_vertex, quad_fragment, count=4)\nquad[\'position\']= [(-1,-1), (-1,1), (1,-1), (1,1)]\ncolor = np.zeros((window.height,window.width,4),np.ubyte).view(gloo.Texture2D)\ncolor.interpolation = gl.GL_LINEAR\npick = np.zeros((window.height,window.width,4),np.ubyte).view(gloo.Texture2D)\npick.interpolation = gl.GL_LINEAR\nframebuffer = gloo.FrameBuffer(color=[color,pick])\nquad[""color""] = color\nindex = -1\nmouse = 0,0\n\n@window.event\ndef on_draw(dt):\n    global index\n    framebuffer.activate()\n    window.clear()\n    polys.draw(), paths.draw()\n    if mouse is not None:\n        gl.glReadBuffer(gl.GL_COLOR_ATTACHMENT1, gl.GL_FRONT)\n        r,g,b,a = gl.glReadPixels(mouse[0],mouse[1], 1, 1, gl.GL_RGBA, gl.GL_UNSIGNED_BYTE)\n        if type(r) is not int: r = ord(r)\n        if type(g) is not int: g = ord(g)\n        if type(b) is not int: b = ord(b)\n        new_index = b + 256*g + 256*256*r\n        if -1 < new_index < len(polys):\n            index = new_index\n            polys[""color""] = 1,1,1,0.75\n            polys[index][""color""] = 1,1,1,0\n    framebuffer.deactivate()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_mouse_motion(x,y, dx, dy):\n    global mouse\n    mouse = int(x), window.height-int(y)\n\n@window.event\ndef on_resize(width, height):\n    framebuffer.resize(width,height)\n    quad[""color""] = framebuffer.color[0]\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_BLEND)\n\nwindow.attach(paths[""transform""])\nwindow.attach(paths[""viewport""])\napp.run()\n'"
examples/topojson.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport csv, json\nimport numpy as np\nfrom glumpy import app, gl, data\nfrom glumpy.transforms import *\nfrom glumpy.graphics.collections import *\n\n\n# Building the transformation\n# ---------------------------\nscale = 2*1285.0\nLower48 = ConicEqualArea(scale = scale,    parallels = (29.5, 45.5),\n                         rotate = (96,0),  center = (0.38, -0.41))\nAlaska = ConicEqualArea(scale=scale/3,     parallels = (55, 65),\n                        rotate = (154, 0), center = (.32, -.8),\n                        clip = [-200, +200, +50, 100] )\nHawai = ConicEqualArea(scale=scale,        parallels = (8, 18),\n                        rotate = (157, 0), center = (.24, -.32),\n                        clip = [-180, -140, -90, +90] )\n\ntransform = Position(Lower48(Hawai(Alaska(GeoPosition()))))\ntransform = PanZoom(OrthographicProjection(transform))\n\n\n# Building collection using extended dtype and our own fragment \n# -------------------------------------------------------------\nfragment = """"""\n#include ""colormaps/colormaps.glsl""\nvarying float rate;\nvoid main(void)\n{\n    gl_FragColor = vec4(colormap_autumn(1-rate),1.0);\n}\n""""""\npaths = PathCollection(""agg+"", transform=transform, linewidth=\'shared\', color=""shared"")\npolys = PolygonCollection(""raw"", transform=transform, color=""shared"", fragment=fragment,\n                          user_dtype=[(\'rate\', (np.float32, 1), \'shared\', 0.0)])\n\n\n# Opening the topojson file\n# -------------------------\nwith open(data.get(""us.json""), \'r\') as file:\n    geomap = json.load(file)\narcs = geomap[""arcs""]\nscale = geomap[\'transform\'][\'scale\']\ntranslate = geomap[\'transform\'][\'translate\']\n\n# Apply scale and transform to all coordinates (= arcs)\n_arcs = []\nfor arc in arcs:\n    _arc = []\n    x, y = translate[0], translate[1]\n    for position in arc:\n        x = x + position[0]*scale[0] \n        y = y + position[1]*scale[1] \n        _arc.append((x,y))\n    _arcs.append(_arc)\narcs = _arcs\n\n# A polygon is made of one or several rings, a ring is made of arcs\n# If there is several rings, the first is the exterior ring while the others are holes\ndef build_paths(obj):\n    paths = []\n    if obj[""type""] == ""Polygon"": polygons = [obj[""arcs""]]\n    else:                        polygons =  obj[""arcs""]\n    for polygon in polygons:\n        for ring in polygon:\n            path = []\n            for i,arc in enumerate(ring):\n                if i == 0:\n                    if arc >= 0: path.extend(arcs[arc])\n                    else:        path.extend((arcs[~arc])[::-1])\n                else:\n                    if arc >= 0: path.extend(arcs[arc][1:])\n                    else:        path.extend((arcs[~arc][:-1])[::-1])\n            if len(path) > 2:\n                V = np.zeros((len(path),3), dtype=np.float32)\n                V[:,:2] = np.array(path)\n                paths.append(V)\n    return paths\n\n\n# Opening the unemployment rate\n# -----------------------------\nunemployment = {}\nwith open(data.get(\'us-unemployment.tsv\'), \'r\') as file:\n    reader = csv.reader(file, delimiter=\'\\t\')\n    next(reader, None) # skip the header\n    for row in reader:\n        unemployment[int(row[0])] = float(row[1]) / 0.16\n\n                     \n# Building the chloropleth\n# ------------------------\n# We could exploit the topojson format to restrict path drawing to\n# non-overlapping paths\n\n# State counties\nfor county in geomap[""objects""][""counties""][""geometries""]:\n    for V in build_paths(county):\n        paths.append(V, closed=True, color=(1,1,1,.5), linewidth=1.0)\n        if len(V) > 3:\n            key = county[""id""]\n            rate = 0.0\n            if key in unemployment.keys():\n                rate = unemployment[county[""id""]]\n            polys.append(V[:-1], color=(1,1,1,1), rate=rate)\n\n# Federal states\nfor state in geomap[""objects""][""states""][""geometries""]:\n    for V in build_paths(state):\n        paths.append(V, closed=True, color=(.25,.25,.25,1), linewidth=0.75)\n\n# USA land\nfor V in build_paths(geomap[""objects""][""land""]):\n    paths.append(V, closed=True, color=(0,0,0,1), linewidth=1.5)\n\n\nwindow = app.Window(2*960, 2*600, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    polys.draw(), paths.draw()\n\nwindow.attach(paths[""transform""])\nwindow.attach(paths[""viewport""])\napp.run()\n'"
examples/transform-image.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl, data\nfrom glumpy.transforms import Position, LogScale, LinearScale\nfrom glumpy.transforms import PolarProjection\nfrom glumpy.transforms import HammerProjection\nfrom glumpy.transforms import TransverseMercatorProjection\n\nvertex = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n    v_texcoord = position;\n} """"""\nfragment = """"""\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n     vec2 uv = <projection.inverse(v_texcoord)>;\n     gl_FragColor = texture2D(texture, <scale(uv)>.xy);\n} """"""\n\n\nwindow = app.Window(800,800, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\nprogram[\'texture\'] = data.get(""earth.jpg"")\nprogram[\'texture\'].interpolation = gl.GL_LINEAR\n\n\n# Polar projection\n# ----------------\n# program[\'projection\'] = PolarProjection(\n#     # This translates texture coordinates to cartesian coordinates\n#     LinearScale(\'.x\', name = \'x\', domain=(-1, 1), range=(-1,1), call=""forward"", clamp=True),\n#     LinearScale(\'.y\', name = \'y\', domain=(-1, 1), range=(-1,1), call=""forward"", clamp=True))\n# program[\'scale\'] = Position(\n#     # This translates cartesian coordinates (polar domains) to texture coordinates\n#     # LogScale(\'.x\', name = \'x\', domain=(-1,0), range=(0,1), clamp=True),\n#     LinearScale(\'.x\', name = \'x\', domain=(0.2, 1.0),     range=(0,1), clamp=True),\n#     LinearScale(\'.y\', name = \'y\', domain=(0.0, 2*np.pi), range=(0,1), clamp=True))\n\n\n# Hammer projection\n# -----------------\n# program[\'projection\'] = HammerProjection(\n#     # This translates texture coordinates to cartesian coordinates\n#     LinearScale(\'.x\', name = \'x\', domain=(-1, 1), range=(-3.0,3.0), call=""forward"", clamp=True),\n#     LinearScale(\'.y\', name = \'y\', domain=(+1,-1), range=(-2.0,2.0), call=""forward"", clamp=True))\n\n# program[\'scale\'] = Position(\n#     # This translates cartesian coordinates (hammer domains) to texture coordinates\n#     LinearScale(\'.x\', name = \'x\', domain=(-np.pi,   np.pi),   range=(0,1), clamp=True),\n#     LinearScale(\'.y\', name = \'y\', domain=(-np.pi/2, np.pi/2), range=(0,1), clamp=True))\n# window.set_size(800,500)\n\n\n# Transverse Mercator projection\n# ------------------------------\nprogram[\'projection\'] = TransverseMercatorProjection(\n    # This translates texture coordinates to cartesian coordinates\n    LinearScale(\'.x\', name=\'x\', domain=(-1,+1), range=(-1.5,1.5), call=""forward"", clamp=True),\n    LinearScale(\'.y\', name=\'y\', domain=(+1,-1), range=(-2.4,2.4), call=""forward"", clamp=True))\n\nprogram[\'scale\'] = Position(\n    # This translates cartesian coordinates (mercator domains) to texture coordinates\n    LinearScale(\'.x\', name = \'x\', domain=(-np.pi,   np.pi),   range=(0,1), clamp=True),\n    LinearScale(\'.y\', name = \'y\', domain=(-np.pi/2, np.pi/2), range=(0,1), clamp=True))\nwindow.set_size(500,800)\n\n\n\n@window.event\ndef on_mouse_scroll(x, y, dx, dy):\n    xdomain = program[\'projection\'][\'x\'][\'domain\']\n    ydomain = program[\'projection\'][\'y\'][\'domain\']\n    if dy < 0:\n        xdomain *= .9\n        ydomain *= .9\n    elif dy > 0:\n        xdomain *= 1.1\n        ydomain *= 1.1\n    program[\'projection\'][\'x\'][\'domain\'] = xdomain\n    program[\'projection\'][\'y\'][\'domain\'] = ydomain\n\n\napp.run()\n'"
examples/transform-linear-log-scale.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app\nfrom glumpy.graphics.collections import PointCollection\nfrom glumpy.transforms import LinearScale, LogScale, Position\n\nwindow = app.Window(1024,1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    points.draw()\n\n\n# lin-lin\ntransform = Position(LinearScale(\'.xy\', domain=(0,10)))\n\n# log-lin\ntransform = Position(LogScale(\'.x\', domain=(-1,1)),\n                     LinearScale(\'.y\', domain=(0,10)))\n\n# lin-log\ntransform = Position(LinearScale(\'.x\', domain=(0,10)),\n                     LogScale(\'.y\', domain=(-1,1)))\n\n# log-log\n# transform = Position(LogScale(\'.xy\', domain=(-1,1)))\n\n\npoints = PointCollection(""agg"", transform = transform, color=\'local\')\nX = np.linspace(0.01,10.0,10000).reshape(10000,1)\nZ = np.zeros((len(X),1))\npoints.append(np.hstack((X,         X, Z)), color=(1,0,0,1))\npoints.append(np.hstack((X, np.log(X), Z)), color=(0,1,0,1))\npoints.append(np.hstack((X,     10**X, Z)), color=(0,0,1,1))\n\nwindow.attach(points[""transform""])\nwindow.attach(points[""viewport""])\napp.run()\n'"
examples/transform-linear-scale.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app\nfrom glumpy.graphics.collections import PointCollection\nfrom glumpy.transforms import LinearScale, Position, Viewport\n\nwindow = app.Window(1024,1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    points.draw()\n\n@window.event\ndef on_mouse_scroll(x,y,dx,dy):\n    if dy < 0:\n        transform[""domain""] = 1.1*transform[""domain""]\n    else:\n        transform[""domain""] = transform[""domain""]/1.1\n\n\ntransform = Position(LinearScale())\npoints = PointCollection(""agg"", transform = transform)\npoints.append( P = np.random.normal(0,.5,(10000,3)) )\n\nwindow.attach(points[""transform""])\nwindow.attach(points[""viewport""])\napp.run()\n'"
examples/transform-log-polar.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app\nfrom glumpy.graphics.collections import PointCollection\nfrom glumpy.transforms import LogScale, LinearScale, PolarProjection, Position, Viewport\n\n\nwindow = app.Window(1024,1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    points.draw()\n\ntransform = Position(PolarProjection(\n    LogScale(\'.x\', domain=(-1,3), range=(0,1)),\n    LinearScale(\'.y\', domain=(0,2*np.pi), range=(0,2*np.pi))))\n\npoints = PointCollection(""agg"", transform = transform)\n\nn = 10000\nR = np.random.uniform(0,1000,n)\nT = np.random.uniform(0,2*np.pi,n)\nZ = np.zeros(n)\n\npoints.append (np.dstack((R,T,Z)).reshape(n,3) )\n\nwindow.attach(points[""transform""])\nwindow.attach(points[""viewport""])\napp.run()\n'"
examples/transform-log-scale.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app\nfrom glumpy.graphics.collections import PointCollection\nfrom glumpy.transforms import LogScale, Position, Viewport\n\nwindow = app.Window(1024,1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    points.draw()\n\n@window.event\ndef on_mouse_scroll(x,y,dx,dy):\n    if dy < 0:\n        transform[""base""] = np.minimum(20., 1.1*transform[""base""])\n    else:\n        transform[""base""] = np.maximum(1., transform[""base""]/1.1)\n\ntransform = Position(LogScale())\ntransform[""domain""] = -1,2 # = [base^-1, base^2]\npoints = PointCollection(""agg"", transform = transform)\nP = np.random.uniform(0,10,(10000,3))\npoints.append(P*P)\n\nwindow.attach(points[""transform""])\nwindow.attach(points[""viewport""])\napp.run()\n'"
examples/transform-ortho.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom  glumpy import app, gl, glm, gloo\nfrom glumpy.transforms import OrthographicProjection, Position\n\n\nvertex = """"""\nattribute vec2 position;\nvoid main()\n{\n    gl_Position = <transform>;\n}\n""""""\n\nfragment = """"""\nvoid main()\n{\n    gl_FragColor = vec4(1,0,0,1);\n}\n""""""\n\nwindow = app.Window(width=800, height=800)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_resize(w, h):\n    quad[\'position\'] = [(w-100,h-100), (w-100,h), (w,h-100), (w,h)]\n\nquad = gloo.Program(vertex, fragment, count=4)\nquad[""transform""] = OrthographicProjection(Position(""position""))\nwindow.attach(quad[""transform""])\napp.run()\n'"
examples/transform-pan-zoom.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom PIL import Image\nfrom glumpy import app, gl, glm, gloo, data\nfrom glumpy.transforms import PanZoom, Position\n\nvertex = """"""\n    attribute vec2 position;\n    attribute vec2 texcoord;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_Position = <transform>;\n        v_texcoord = texcoord;\n    }\n""""""\n\nfragment = """"""\n    uniform sampler2D texture;\n    varying vec2 v_texcoord;\n    void main()\n    {\n        gl_FragColor = texture2D(texture, v_texcoord);\n    }\n""""""\n\nwindow = app.Window(width=800, height=800)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    program.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_key_press(key, modifiers):\n    if key == app.window.key.SPACE:\n        transform.reset()\n\nprogram = gloo.Program(vertex, fragment, count=4)\nprogram[\'position\'] = [(-1,-1), (-1,1), (1,-1), (1,1)]\nprogram[\'texcoord\'] = [( 0, 1), ( 0, 0), ( 1, 1), ( 1, 0)]\nprogram[\'texture\'] = data.get(""lena.png"")\n\ntransform = PanZoom(Position(""position""), aspect=1)\nprogram[\'transform\'] = transform\nwindow.attach(transform)\n\napp.run()\n'"
examples/transform-polar.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app\nfrom glumpy.graphics.collections import PointCollection\nfrom glumpy.transforms import PolarProjection, Position\n\nwindow = app.Window(1024,1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    points.draw()\n\ntransform = Position(PolarProjection())\npoints = PointCollection(""agg"", transform = transform)\n\nn = 10000\nR = np.random.uniform(0.2,0.8,n)\nT = np.random.uniform(0,2*np.pi,n)\nZ = np.zeros(n)\n\npoints.append (np.dstack((R,T,Z)).reshape(n,3) )\nwindow.attach(points[""transform""])\nwindow.attach(points[""viewport""])\napp.run()\n'"
examples/transform-power-scale.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app\nfrom glumpy.graphics.collections import PointCollection\nfrom glumpy.transforms import PowerScale, Position, Viewport\n\nwindow = app.Window(1024,1024, color=(1,1,1,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    points.draw()\n\n@window.event\ndef on_mouse_scroll(x,y,dx,dy):\n    if dy < 0:\n        transform[""exponent""] = np.minimum(10.0, 1.1*transform[""exponent""])\n    else:\n        transform[""exponent""] = np.maximum(0.1, transform[""exponent""]/1.1)\n\ntransform = Position(PowerScale())\ntransform[""exponent""] = 2\ntransform[""domain""] = -10,+10\n\npoints = PointCollection(""agg"", transform = transform)\nP = np.random.uniform(-100,100,(10000,3))\nP = np.copysign(np.sqrt(abs(P)),P)\npoints.append(P)\n\n\nwindow.attach(points[""transform""])\nwindow.attach(points[""viewport""])\napp.run()\n'"
examples/transform-pvm.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\nfrom glumpy.geometry import colorcube\nfrom glumpy.transforms import PVMProjection, Position\n\nvertex = """"""\nuniform vec4 u_color;\nattribute vec3 position;\nattribute vec4 color;\nvarying vec4 v_color;\nvoid main()\n{\n    v_color = u_color * color;\n    gl_Position = <transform>;\n}\n""""""\n\nfragment = """"""\nvarying vec4 v_color;\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta\n\n    window.clear()\n\n    # Filled cube\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    cube[\'u_color\'] = 1, 1, 1, 1\n    cube.draw(gl.GL_TRIANGLES, faces)\n\n    # Outlined cube\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    cube[\'u_color\'] = 0, 0, 0, 1\n    cube.draw(gl.GL_LINES, outline)\n    gl.glDepthMask(gl.GL_TRUE)\n\n    # Make cube rotate\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    transform[\'model\'] = model\n\n\n# Build cube data\nV, I, O = colorcube()\nvertices = V.view(gloo.VertexBuffer)\nfaces    = I.view(gloo.IndexBuffer)\noutline  = O.view(gloo.IndexBuffer)\n\ncube = gloo.Program(vertex, fragment)\ncube.bind(vertices)\ntransform = PVMProjection(Position(""position""))\ncube[\'transform\'] = transform\nwindow.attach(transform)\n\nphi, theta = 0, 0\n\n# OpenGL initalization\ngl.glEnable(gl.GL_DEPTH_TEST)\ngl.glPolygonOffset(1, 1)\ngl.glEnable(gl.GL_LINE_SMOOTH)\ngl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\ngl.glLineWidth(0.75)\n\n# Run\napp.run()\n'"
examples/transform-rotate.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Rotate\n\nvertex = """"""\nattribute vec2 position;\nvoid main (void)\n{\n    gl_Position = vec4( <transform(position)>, 0.0, 1.0);\n}\n""""""\n\nfragment = """"""\nvoid main(void)\n{\n    gl_FragColor = vec4(1,0,0,1);\n}\n""""""\n\nwindow = app.Window(width=800, height=800)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n    quad[""transform""].angle += 1\n\nquad = gloo.Program(vertex, fragment, count=4)\nquad[""position""] = [(-.5,-.5), (-.5,+.5), (+.5,-.5), (+.5,+.5)]\nquad[""transform""] = Rotate(angle=10, origin=(0.5,0.5,0.0))\n\napp.run()\n'"
examples/transform-trackball.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\nfrom glumpy.geometry import colorcube\nfrom glumpy.transforms import Trackball, Position\n\n\nvertex = """"""\nuniform vec4 u_color;\nattribute vec3 position;\nattribute vec4 color;\nvarying vec4 v_color;\nvoid main()\n{\n    v_color = u_color * color;\n    gl_Position = <transform>;\n}\n""""""\n\nfragment = """"""\nvarying vec4 v_color;\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n\n    # Filled cube\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    cube[\'u_color\'] = 1, 1, 1, 1\n    cube.draw(gl.GL_TRIANGLES, faces)\n\n    # Outlined cube\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    cube[\'u_color\'] = 0, 0, 0, 1\n    cube.draw(gl.GL_LINES, outline)\n    gl.glDepthMask(gl.GL_TRUE)\n\n\n# Build cube data\nV, I, O = colorcube()\nvertices = V.view(gloo.VertexBuffer)\nfaces    = I.view(gloo.IndexBuffer)\noutline  = O.view(gloo.IndexBuffer)\n\ncube = gloo.Program(vertex, fragment)\ncube.bind(vertices)\ncube[\'transform\'] = Trackball(Position(""position""))\nwindow.attach(cube[\'transform\'])\n\n# OpenGL initalization\ngl.glEnable(gl.GL_DEPTH_TEST)\ngl.glPolygonOffset(1, 1)\ngl.glEnable(gl.GL_LINE_SMOOTH)\ngl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n\n# Run\napp.run()\n'"
examples/transform-trackballPan.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\nfrom glumpy.geometry import colorcube\nfrom glumpy.transforms import TrackballPan, Position\n\n\nvertex = """"""\n\nuniform vec4 u_color;\nattribute vec3 position;\nattribute vec4 color;\nvarying vec4 v_color;\n\nvoid main()\n{\n    v_color = u_color * color;\n    gl_Position = <transform>;\n}\n""""""\n\nfragment = """"""\nvarying vec4 v_color;\n\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\n# Build cube data\nV, I, O = colorcube()\nvertices = V.view(gloo.VertexBuffer)\nfaces    = I.view(gloo.IndexBuffer)\noutline  = O.view(gloo.IndexBuffer)\n\ncube = gloo.Program(vertex, fragment)\ncube.bind(vertices)\n\n# create an instance of the TrackballPan object.\ntrackball = TrackballPan(Position(""position""), znear=3, zfar=10, distance=5)\ncube[\'transform\'] = trackball\n\ntrackball.aspect = 1\n# rotation around the X axis\ntrackball.phi = 0\n# rotation around the Y axis\ntrackball.theta = 0\ntrackball.zoom = 50\n\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n\n    # Filled cube\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    cube[\'u_color\'] = 1, 1, 1, 1\n    cube.draw(gl.GL_TRIANGLES, faces)\n\n    # Outlined cube\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    cube[\'u_color\'] = 0, 0, 0, 1\n    cube.draw(gl.GL_LINES, outline)\n    gl.glDepthMask(gl.GL_TRUE)\n\n\nwindow.attach(cube[\'transform\'])\n\n# OpenGL\ngl.glEnable(gl.GL_DEPTH_TEST)\ngl.glPolygonOffset(1, 1)\ngl.glEnable(gl.GL_LINE_SMOOTH)\ngl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n\n# Run\napp.run()\n'"
examples/voronoi.py,15,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\nfrom glumpy.graphics.filter import Filter\n\ncone_vertex = """"""\nuniform mat4 projection;\nattribute vec2 translate;\nattribute vec3 position;\nattribute vec3 color;\nvarying vec3 v_color;\nvoid main()\n{\n    v_color = color;\n    gl_Position = projection * vec4(position.xy+translate, position.z ,1.0);\n}\n""""""\n\ncone_fragment = """"""\nvarying vec3 v_color;\nvoid main()\n{\n    gl_FragColor = vec4(v_color.rgb, 1.0);\n}\n""""""\n\nborders = Filter(1024, 1024, """"""\nconst float epsilon = 1e-3;\nvec4 filter(sampler2D original, sampler2D filtered, vec2 texcoord, vec2 texsize)\n{\n    vec4 center = texture2D(filtered, texcoord);\n    vec4 left   = texture2D(filtered, texcoord + vec2(-1.0, 0.0)/texsize);\n    vec4 right  = texture2D(filtered, texcoord + vec2(+1.0, 0.0)/texsize);\n    vec4 down   = texture2D(filtered, texcoord + vec2( 0.0,-1.0)/texsize);\n    vec4 up     = texture2D(filtered, texcoord + vec2( 0.0,+1.0)/texsize);\n    vec4 black  = vec4(0,0,0,1);\n    float level = 0.5;\n\n    if (length(center-left) > epsilon) {\n        return mix(black,right, level);\n    } else if (length(center-right) > epsilon) {\n        return mix(black, left, level);\n    } else if (length(center-down) > epsilon) {\n        return mix(black, up,  level);\n    } else if (length(center-up) > epsilon) {\n        return mix(black, down, level);\n    }\n    return center;\n} """""")\n\n\nwindow = app.Window(width=1024, height=1024)\n\n@window.event\ndef on_draw(dt):\n    with borders:\n        window.clear()\n        gl.glEnable(gl.GL_DEPTH_TEST)\n        cones.draw(gl.GL_TRIANGLES, I)\n\n@window.event\ndef on_resize(width, height):\n    cones[\'projection\'] = glm.ortho(0, width, 0, height, -5, +500)\n    borders.viewport = 0,0,width,height\n\n@window.event\ndef on_mouse_motion(x,y,dx,dy):\n    C[""translate""][0] = x, window.height-y\n\ndef makecone(n=32, radius=1024):\n    height = radius / np.tan(45 * np.pi / 180.0)\n    V = np.zeros((1+n,3))\n    V[0] = 0,0,0\n    T = np.linspace(0,2*np.pi,n, endpoint=False)\n    V[1:,0] = radius*np.cos(T)\n    V[1:,1] = radius*np.sin(T)\n    V[1:,2] = -height\n    I  = np.repeat([[0,1,2]], n, axis=0).astype(np.uint32)\n    I += np.arange(n,dtype=np.uint32).reshape(n,1)\n    I[:,0] = 0\n    I[-1] = 0,n,1\n    return V, I.ravel()\n\n\nn = 512 # number of cones (= number of points)\np = 32  # faces per cones\n\ncones = gloo.Program(cone_vertex, cone_fragment)\nC = np.zeros((n,1+p), [(""translate"", np.float32, 2),\n                       (""position"",  np.float32, 3),\n                       (""color"",     np.float32, 3)]).view(gloo.VertexBuffer)\nI = np.zeros((n,3*p), np.uint32).view(gloo.IndexBuffer)\nI += (1+p)*np.arange(n, dtype=np.uint32).reshape(n,1)\nfor i in range(n):\n    #x,y = np.random.uniform(0,1024,2)\n    x,y = np.random.normal(512,256,2)\n    vertices, indices = makecone(p, radius=512)\n    if i > 0:\n        C[""color""][i] = np.random.uniform(0.25,1.00,3)\n    else:\n        C[""color""][0] = 1,1,0\n    C[""translate""][i] = x,y\n    C[""position""][i] = vertices\n    I[i] += indices.ravel()\ncones.bind(C)\n\napp.run()\n'"
glumpy/__init__.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n__version__ = ""1.0.6""\n\nfrom . import app\nfrom . import api\nfrom . import gloo\nfrom . import data\nfrom . import transforms\n\nfrom . log import log\nfrom . app import run\nfrom . app import Window\nfrom . app.window import key\nfrom . app.window import mouse\n\nfrom . graphics import svg\nfrom . graphics import color\nfrom . graphics import collections\n'"
glumpy/defaults.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAll default parameters and objects.\n""""""\n\n# ------------------------------------------------------------------ Parser ---\ndef get_default_parser():\n    """""" Default command line argument parser """"""\n    from glumpy.app.parser import get_default\n    return get_default()\n\ndef parser():\n    """""" Default command line argument parser """"""\n    return get_default_parser()\n\n\n# ------------------------------------------------------------------- Clock ---\ndef get_default_clock():\n    """""" Default clock """"""\n    from glumpy.app.clock import get_default\n    return get_default()\n\ndef clock():\n    """""" Default clock """"""\n    return get_default_clock()\n\n\n# ----------------------------------------------------------- Configuration ---\ndef get_default_configuration():\n    """""" Default configuration """"""\n    from glumpy.app.configuration import get_default\n    return get_default()\n\ndef configuration():\n    """""" Default command line argument parser """"""\n    return get_default_configuration()\n\n\n# ------------------------------------------------------------ Window width ---\n__width__ = 512\n\ndef get_default_width():\n    """""" Default window width """"""\n    return __width__\n\ndef width():\n    """""" Default window width """"""\n    return get_default_width()\n\n\n# ----------------------------------------------------------- Window height ---\n__height__ = 512\n\ndef get_default_height():\n    """""" Default window height """"""\n    return __height__\n\ndef height():\n    """""" Default window height """"""\n    return get_default_height()\n\n\n# ------------------------------------------------------- Window x position ---\n__x__ = 0\n\ndef get_default_x():\n    """""" Default window x position """"""\n    return __x__\n\ndef x():\n    """""" Default window width """"""\n    return get_default_x()\n\n\n# ------------------------------------------------------- Window y position ---\n__y__ = 0\n\ndef get_default_y():\n    """""" Default window y position """"""\n    return __y__\n\ndef y():\n    """""" Default window width """"""\n    return get_default_y()\n\n\n# --------------------------------------------------------------- Framerate ---\n__framerate__ = 60.0\n\ndef get_default_framerate():\n    """""" Default framerate """"""\n    return __framerate__\n\ndef framerate():\n    """""" Default framerate """"""\n    return get_default_framerate()\n\n\n# ------------------------------------------------------------------- vsync ---\n__vsync__ = False\n\ndef get_default_vsync():\n    """""" Default vsync """"""\n    return __vsync__\n\ndef vsync():\n    """""" Default vsync """"""\n    return get_default_vsync()\n\n\n# -------------------------------------------------------------------- srgb ---\n__srgb__ = False\n\ndef get_default_srgb():\n    """""" Default srgb """"""\n    return __srgb__\n\ndef srgb():\n    """""" Default srgb """"""\n    return get_default_srgb()\n\n\n# ------------------------------------------------------------------ stereo ---\n__stereo__ = False\n\ndef get_default_stereo():\n    """""" Default stereo """"""\n    return __stereo__\n\ndef stereo():\n    """""" Default stereo """"""\n    return get_default_stereo()\n\n\n# ----------------------------------------------------------- double buffer ---\n__double_buffer__ = True\n\ndef get_default_double_buffer():\n    """""" Default double buffer mode """"""\n    return __double_buffer__\n\ndef double_buffer():\n    """""" Default double buffer """"""\n    return get_default_double_buffer()\n\n\n# -------------------------------------------------------------- depth_size ---\n__depth_size__ = 24\n\ndef get_default_depth_size():\n    """""" Default depth size """"""\n    return __depth_size__\n\ndef depth_size():\n    """""" Default depth size """"""\n    return get_default_depth_size()\n\n\n# ------------------------------------------------------------ stencil size ---\n__stencil_size__ = 0\n\ndef get_default_stencil_size():\n    """""" Default stencil size """"""\n    return __stencil_size__\n\ndef stencil_size():\n    """""" Default stencil size """"""\n    return get_default_stencil_size()\n\n\n# -------------------------------------------------------------- GL Version ---\n__gl_major_version__ = 2\n__gl_minor_version__ = 1\n\ndef get_default_gl_version():\n    """""" Default GL version """"""\n    return ""%d.%d"" % (__gl_major_version__,__gl_minor_version__)\n\ndef gl_version():\n    """""" Default GL version """"""\n    return get_default_gl_version()\n\ndef get_default_gl_major_version():\n    """""" Default GL major version """"""\n    return __gl_major_version__\n\ndef gl_major_version():\n    """""" Default GL major version """"""\n    return get_default_gl_major_version()\n\ndef get_default_gl_minor_version():\n    """""" Default GL minor version """"""\n    return __gl_minor_version__\n\ndef gl_minor_version():\n    """""" Default GL minor version """"""\n    return get_default_gl_minor_version()\n\n\n# ------------------------------------------------------------------ GL API ---\n__gl_api__ = ""GL""\n\ndef get_default_gl_api():\n    """""" Default GL API """"""\n    return __gl_api__\n\ndef gl_api():\n    """""" Default GL API """"""\n    return get_default_gl_api()\n\n\n# -------------------------------------------------------------- GL profile ---\n__gl_profile__ = ""none""\n\ndef get_default_gl_profile():\n    """""" Default GL profile """"""\n    return __gl_profile__\n\ndef gl_profile():\n    """""" Default GL profile """"""\n    return get_default_gl_profile()\n\n\n# ----------------------------------------------------------------- Backend ---\n__backend__ = ""glfw""\n\ndef get_default_backend():\n    """""" Default backend """"""\n    return __backend__\n\ndef backend():\n    """""" Default backend """"""\n    return get_default_backend()\n'"
glumpy/gl.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport ctypes\nfrom glumpy.log import log\n\nimport OpenGL\nOpenGL.ERROR_ON_COPY = True\n# -> if set to a True value before importing the numpy/lists support modules,\n#    will cause array operations to raise OpenGL.error.CopyError if the\n#    operation would cause a data-copy in order to make the passed data-type\n#    match the target data-type.\n\nfrom OpenGL.plugins import FormatHandler\nFormatHandler( \'glumpy\',\n               \'OpenGL.arrays.numpymodule.NumpyHandler\',[\n                   \'glumpy.gloo.buffer.VertexBuffer\',\n                   \'glumpy.gloo.buffer.IndexBuffer\',\n                   \'glumpy.gloo.atlas.Atlas\',\n                   \'glumpy.gloo.texture.Texture2D\',\n                   \'glumpy.gloo.texture.Texture1D\',\n                   \'glumpy.gloo.texture.FloatTexture2D\',\n                   \'glumpy.gloo.texture.FloatTexture1D\',\n                   \'glumpy.gloo.texture.TextureCube\',\n               ])\n\n\n\nfrom OpenGL import contextdata\ndef cleanupCallback( context=None ):\n    """"""Create a cleanup callback to clear context-specific storage for the current context""""""\n    def callback( context = contextdata.getContext( context ) ):\n        """"""Clean up the context, assumes that the context will *not* render again!""""""\n        contextdata.cleanupContext( context )\n    return callback\n\nfrom OpenGL.GL import *\nfrom OpenGL.GL.EXT.geometry_shader4 import *\nfrom OpenGL.GL.NV.geometry_program4 import *\nfrom OpenGL.GL.ARB.texture_rg import *\n\n\n# Patch: pythonize the glGetActiveAttrib\n_glGetActiveAttrib = glGetActiveAttrib\ndef glGetActiveAttrib(program, index):\n    # Prepare\n    bufsize = 32\n    length = ctypes.c_int()\n    size = ctypes.c_int()\n    type = ctypes.c_int()\n    name = ctypes.create_string_buffer(bufsize)\n    # Call\n    _glGetActiveAttrib(program, index,\n                       bufsize, ctypes.byref(length), ctypes.byref(size),\n                       ctypes.byref(type), name)\n    # Return Python objects\n    return name.value, size.value, type.value\n\n\n# # --- Wrapper ---\n# import sys\n# def wrap(name):\n#     if callable(globals()[name]):\n#         def wrapper(*args, **kwargs):\n#             # print ""Calling %s%s"" % (name, args)\n#             return globals()[name](*args, **kwargs)\n#         return wrapper\n#     else:\n#         return globals()[name]\n#\n# class Wrapper(object):\n#     def __init__(self, wrapped):\n#         self.wrapped = wrapped\n#     def __getattr__(self, name):\n#         return wrap(name)\n#\n# sys.modules[__name__] = Wrapper(sys.modules[__name__])\n'"
glumpy/glm.py,15,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nVery simple transformation library that is needed for some examples.\n\nNotes\n-----\n\nFunctions that take a matrix as input generally operate on that matrix in\nplace.\n""""""\n\n# Note: we use functions from math module because they\'re faster on scalars\n\nimport math\nimport numpy as np\n\n\ndef translate(M, x, y=None, z=None):\n    """"""Translate by an offset (x, y, z) .\n\n    Parameters\n    ----------\n    M : array\n        Original transformation (4x4).\n    x : float\n        X coordinate of a translation vector.\n    y : float | None\n        Y coordinate of translation vector. If None, `x` will be used.\n    z : float | None\n        Z coordinate of translation vector. If None, `x` will be used.\n\n    Returns\n    -------\n    M : array\n        Updated transformation (4x4). Note that this function operates\n        in-place.\n    """"""\n    y = x if y is None else y\n    z = x if z is None else z\n    T = np.array([[1.0, 0.0, 0.0, x],\n                  [0.0, 1.0, 0.0, y],\n                  [0.0, 0.0, 1.0, z],\n                  [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype).T\n    M[...] = np.dot(M, T)\n    return M\n\n\ndef translation(x, y=None, z=None):\n    """"""Translate by an offset (x, y, z) .\n\n    Parameters\n    ----------\n    x : float\n        X coordinate of a translation vector.\n    y : float | None\n        Y coordinate of translation vector. If None, `x` will be used.\n    z : float | None\n        Z coordinate of translation vector. If None, `x` will be used.\n\n    Returns\n    -------\n    M : array\n        Translation matrix\n    """"""\n\n    M = np.eye(4, dtype=np.float32)\n    return translate(M,x,y,z)\n\n\n\n\ndef scale(M, x, y=None, z=None):\n    """"""Non-uniform scaling along the x, y, and z axes\n\n    Parameters\n    ----------\n    M : array\n        Original transformation (4x4).\n    x : float\n        X coordinate of the translation vector.\n    y : float | None\n        Y coordinate of the translation vector. If None, `x` will be used.\n    z : float | None\n        Z coordinate of the translation vector. If None, `x` will be used.\n\n    Returns\n    -------\n    M : array\n        Updated transformation (4x4). Note that this function operates\n        in-place.\n    """"""\n    y = x if y is None else y\n    z = x if z is None else z\n    S = np.array([[x, 0.0, 0.0, 0.0],\n                  [0.0, y, 0.0, 0.0],\n                  [0.0, 0.0, z, 0.0],\n                  [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype).T\n    M[...] = np.dot(M, S)\n    return M\n\n\ndef xrotate(M, theta):\n    """"""Rotate about the X axis\n\n    Parameters\n    ----------\n    M : array\n        Original transformation (4x4).\n    theta : float\n        Specifies the angle of rotation, in degrees.\n\n    Returns\n    -------\n    M : array\n        Updated transformation (4x4). Note that this function operates\n        in-place.\n    """"""\n    t = math.pi * theta / 180.\n    cosT = math.cos(t)\n    sinT = math.sin(t)\n    R = np.array([[1.0, 0.0, 0.0, 0.0],\n                  [0.0, cosT, -sinT, 0.0],\n                  [0.0, sinT, cosT, 0.0],\n                  [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype)\n    M[...] = np.dot(M, R)\n    return M\n\n\ndef yrotate(M, theta):\n    """"""Rotate about the Y axis\n\n    Parameters\n    ----------\n    M : array\n        Original transformation (4x4).\n    theta : float\n        Specifies the angle of rotation, in degrees.\n\n    Returns\n    -------\n    M : array\n        Updated transformation (4x4). Note that this function operates\n        in-place.\n    """"""\n    t = math.pi * theta / 180\n    cosT = math.cos(t)\n    sinT = math.sin(t)\n    R = np.array(\n        [[cosT, 0.0, sinT, 0.0],\n         [0.0, 1.0, 0.0, 0.0],\n         [-sinT, 0.0, cosT, 0.0],\n         [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype)\n    M[...] = np.dot(M, R)\n    return M\n\n\ndef zrotate(M, theta):\n    """"""Rotate about the Z axis\n\n    Parameters\n    ----------\n    M : array\n        Original transformation (4x4).\n    theta : float\n        Specifies the angle of rotation, in degrees.\n\n    Returns\n    -------\n    M : array\n        Updated transformation (4x4). Note that this function operates\n        in-place.\n    """"""\n    t = math.pi * theta / 180\n    cosT = math.cos(t)\n    sinT = math.sin(t)\n    R = np.array(\n        [[cosT, -sinT, 0.0, 0.0],\n         [sinT, cosT, 0.0, 0.0],\n         [0.0, 0.0, 1.0, 0.0],\n         [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype)\n    M[...] = np.dot(M, R)\n    return M\n\n\ndef rotate(M, angle, x, y, z, point=None):\n    """"""Rotation about a vector\n\n    Parameters\n    ----------\n    M : array\n        Original transformation (4x4).\n    angle : float\n        Specifies the angle of rotation, in degrees.\n    x : float\n        X coordinate of the angle of rotation vector.\n    y : float | None\n        Y coordinate of the angle of rotation vector.\n    z : float | None\n        Z coordinate of the angle of rotation vector.\n\n    Returns\n    -------\n    M : array\n        Updated transformation (4x4). Note that this function operates\n        in-place.\n    """"""\n    angle = math.pi * angle / 180\n    c, s = math.cos(angle), math.sin(angle)\n    n = math.sqrt(x * x + y * y + z * z)\n    x /= n\n    y /= n\n    z /= n\n    cx, cy, cz = (1 - c) * x, (1 - c) * y, (1 - c) * z\n    R = np.array([[cx * x + c, cy * x - z * s, cz * x + y * s, 0],\n                  [cx * y + z * s, cy * y + c, cz * y - x * s, 0],\n                  [cx * z - y * s, cy * z + x * s, cz * z + c, 0],\n                  [0, 0, 0, 1]], dtype=M.dtype).T\n    M[...] = np.dot(M, R)\n    return M\n\n\ndef ortho(left, right, bottom, top, znear, zfar):\n    """"""Create orthographic projection matrix\n\n    Parameters\n    ----------\n    left : float\n        Left coordinate of the field of view.\n    right : float\n        Right coordinate of the field of view.\n    bottom : float\n        Bottom coordinate of the field of view.\n    top : float\n        Top coordinate of the field of view.\n    znear : float\n        Near coordinate of the field of view.\n    zfar : float\n        Far coordinate of the field of view.\n\n    Returns\n    -------\n    M : array\n        Orthographic projection matrix (4x4).\n    """"""\n    assert(right != left)\n    assert(bottom != top)\n    assert(znear != zfar)\n\n    M = np.zeros((4, 4), dtype=np.float32)\n    M[0, 0] = +2.0 / (right - left)\n    M[3, 0] = -(right + left) / float(right - left)\n    M[1, 1] = +2.0 / (top - bottom)\n    M[3, 1] = -(top + bottom) / float(top - bottom)\n    M[2, 2] = -2.0 / (zfar - znear)\n    M[3, 2] = -(zfar + znear) / float(zfar - znear)\n    M[3, 3] = 1.0\n    return M\n\n\ndef frustum(left, right, bottom, top, znear, zfar):\n    """"""Create view frustum\n\n    Parameters\n    ----------\n    left : float\n        Left coordinate of the field of view.\n    right : float\n        Right coordinate of the field of view.\n    bottom : float\n        Bottom coordinate of the field of view.\n    top : float\n        Top coordinate of the field of view.\n    znear : float\n        Near coordinate of the field of view.\n    zfar : float\n        Far coordinate of the field of view.\n\n    Returns\n    -------\n    M : array\n        View frustum matrix (4x4).\n    """"""\n    assert(right != left)\n    assert(bottom != top)\n    assert(znear != zfar)\n\n    M = np.zeros((4, 4), dtype=np.float32)\n    M[0, 0] = +2.0 * znear / (right - left)\n    M[2, 0] = (right + left) / (right - left)\n    M[1, 1] = +2.0 * znear / (top - bottom)\n    M[2, 1] = (top + bottom) / (top - bottom)\n    M[2, 2] = -(zfar + znear) / (zfar - znear)\n    M[3, 2] = -2.0 * znear * zfar / (zfar - znear)\n    M[2, 3] = -1.0\n    return M\n\n\ndef perspective(fovy, aspect, znear, zfar):\n    """"""Create perspective projection matrix\n\n    Parameters\n    ----------\n    fovy : float\n        The field of view along the y axis.\n    aspect : float\n        Aspect ratio of the view.\n    znear : float\n        Near coordinate of the field of view.\n    zfar : float\n        Far coordinate of the field of view.\n\n    Returns\n    -------\n    M : array\n        Perspective projection matrix (4x4).\n    """"""\n    assert(znear != zfar)\n    h = math.tan(fovy / 360.0 * math.pi) * znear\n    w = h * aspect\n    return frustum(-w, w, -h, h, znear, zfar)\n'"
glumpy/log.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport logging\nlog = logging.getLogger(\'glumpy\')\nlog.setLevel(logging.INFO)\n# log.setLevel(logging.DEBUG)\n\n# create console handler and set level to debug\nch = logging.StreamHandler()\n# ch.setLevel(logging.INFO)\n\n# create formatter\n# formatter = logging.Formatter(\'%(levelname)s: %(message)s\')\n# formatter = logging.Formatter(\'%(message)s\')\nclass Formatter(logging.Formatter):\n    def format(self, record):\n        prefix = {logging.INFO    : ""[i]"",\n                  logging.WARNING : ""[w]"",\n                  logging.ERROR   : ""[e]"",\n                  logging.CRITICAL: ""[x]""}\n        if record.levelno in (\n                logging.INFO,\n                logging.WARNING,\n                logging.ERROR,\n                logging.CRITICAL):\n            # record.msg = \'[%s] %s\' % (record.levelname, record.msg)\n            record.msg = \'%s %s\' % (prefix[record.levelno], record.msg)\n        return super(Formatter , self).format(record)\nformatter = Formatter(\'%(message)s\')\n\n\n# add formatter to ch\nch.setFormatter(formatter)\n\n# add ch to logger\nlog.addHandler(ch)\n\n# log.debug(\'debug message\')\n# log.info(\'info message\')\n# log.warn(\'warn message\')\n# log.error(\'error message\')\n# log.critical(\'critical message\')\n'"
examples/smoke/smoke.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# Porting of the Fluid demo by Philip Prideout (c) 2010\n# Originals sources and explanation on http://prideout.net/blog/?p=58\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl, data\n\n# Constants\n# -------------------------------------\nCellSize               = 1.25\nViewportWidth          = 512\nViewportHeight         = 512\nGridWidth              = 512\nGridHeight             = 512\nSplatRadius            = GridWidth / 8.0\nAmbientTemperature     = -1.0\nImpulseTemperature     = 10.0\nImpulseDensity         = 1.0\nNumJacobiIterations    = 40\nTimeStep               = 0.125\nSmokeBuoyancy          = 1.00\nSmokeWeight            = 0.05\nGradientScale          = 1.125 / CellSize\nTemperatureDissipation = 0.99\nVelocityDissipation    = 0.99\nDensityDissipation     = 0.9995\nImpulsePosition        = GridWidth/2, -int(SplatRadius/2)\nPositionSlot           = 0\n\n\nwindow = app.Window(ViewportWidth, ViewportHeight)\n\n\nclass Surface(object):\n    def __init__(self, width, height, depth, interpolation=gl.GL_NEAREST):\n        self.texture = np.zeros((height,width,depth), np.float32).view(gloo.TextureFloat2D)\n        self.texture.interpolation = interpolation\n        self.framebuffer = gloo.FrameBuffer(color=self.texture)\n        self.clear()\n\n    def clear(self):\n        self.activate()\n        gl.glClearColor(0, 0, 0, 0)\n        gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n        self.deactivate()\n\n    def activate(self):\n        self.framebuffer.activate()\n\n    def deactivate(self):\n        self.framebuffer.deactivate()\n\nclass Slab(object):\n    def __init__(self, width, height, depth, interpolation=gl.GL_NEAREST):\n        self.Ping = Surface(width, height, depth, interpolation)\n        self.Pong = Surface(width, height, depth, interpolation)\n\n    def swap(self):\n        self.Ping, self.Pong = self.Pong, self.Ping\n\ndef Program(fragment):\n    program = gloo.Program(""smoke.vert"", fragment, count=4)\n    program[\'Position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\n    return program\n\n\nVelocity = Slab(GridWidth, GridHeight, 2)\nDensity = Slab(GridWidth, GridHeight, 1, gl.GL_LINEAR)\nPressure = Slab(GridWidth, GridHeight, 1)\nTemperature = Slab(GridWidth, GridHeight, 1, gl.GL_LINEAR)\nDivergence = Surface(GridWidth, GridHeight, 3)\nObstacles = Surface(GridWidth, GridHeight, 3, gl.GL_LINEAR)\n\nprog_gradient = Program(""gradient.frag"")\nprog_jacobi = Program(""jacobi.frag"")\nprog_advect = Program(""advect.frag"")\nprog_divergence = Program(""divergence.frag"")\nprog_fill = Program(""fill.frag"")\nprog_splat = Program(""splat.frag"")\nprog_buoyancy = Program(""buoyancy.frag"")\nprog_visualize = Program(""visualize.frag"")\n\n\n\nprog_advect[""InverseSize""] = 1.0 / GridWidth, 1.0 / GridHeight\nprog_divergence[""InverseSize""] = 1.0 / GridWidth, 1.0 / GridHeight\nprog_gradient[""InverseSize""] = 1.0 / GridWidth, 1.0 / GridHeight\nprog_buoyancy[""InverseSize""] = 1.0 / GridWidth, 1.0 / GridHeight\nprog_jacobi[""InverseSize""] = 1.0 / GridWidth, 1.0 / GridHeight\nprog_fill[""InverseSize""] = 1.0 / GridWidth, 1.0 / GridHeight\nprog_advect[""TimeStep""] = TimeStep\nprog_jacobi[""Alpha""] =  -CellSize * CellSize\nprog_jacobi[""InverseBeta""] = 0.25\nprog_gradient[""GradientScale""] = GradientScale\nprog_divergence[""HalfInverseCellSize""] = 0.5 / CellSize\nprog_splat[""Radius""] = SplatRadius\nprog_splat[""Point""] = ImpulsePosition\nprog_buoyancy[""AmbientTemperature""] = AmbientTemperature\nprog_buoyancy[""TimeStep""] = TimeStep\nprog_buoyancy[""Sigma""] = SmokeBuoyancy\nprog_buoyancy[""Kappa""] = SmokeWeight\n\n\ndef Advect(velocity, source, obstacles, dest, dissipation):\n    prog_advect[""Dissipation""] = dissipation\n    prog_advect[""VelocityTexture""] = velocity.texture\n    prog_advect[""SourceTexture""] = source.texture\n    prog_advect[""Obstacles""] = obstacles.texture\n    dest.activate()\n    prog_advect.draw(gl.GL_TRIANGLE_STRIP)\n    dest.deactivate()\n\ndef Jacobi(pressure, divergence, obstacles, dest):\n    prog_jacobi[""Pressure""] = pressure.texture\n    prog_jacobi[""Divergence""] = divergence.texture\n    prog_jacobi[""Obstacles""] = obstacles.texture\n    dest.activate()\n    prog_jacobi.draw(gl.GL_TRIANGLE_STRIP)\n    dest.deactivate()\n\ndef SubtractGradient(velocity, pressure, obstacles, dest):\n    prog_gradient[""Velocity""] = velocity.texture\n    prog_gradient[""Pressure""] = pressure.texture\n    prog_gradient[""Obstacles""] = obstacles.texture\n    dest.activate()\n    prog_gradient.draw(gl.GL_TRIANGLE_STRIP)\n    dest.deactivate()\n\ndef ComputeDivergence(velocity, obstacles, dest):\n    prog_divergence[""Obstacles""] = obstacles.texture\n    prog_divergence[""Velocity""] = velocity.texture\n    dest.activate()\n    prog_divergence.draw(gl.GL_TRIANGLE_STRIP)\n    dest.deactivate()\n\ndef ApplyImpulse(dest, position, value):\n    prog_splat[""FillColor""] = value,value,value\n    dest.activate()\n    gl.glEnable(gl.GL_BLEND)\n    prog_splat.draw(gl.GL_TRIANGLE_STRIP)\n    dest.deactivate()\n    gl.glDisable(gl.GL_BLEND)\n\ndef ApplyBuoyancy(velocity, temperature, density, dest):\n    prog_buoyancy[""Density""] = density.texture\n    prog_buoyancy[""Velocity""] = velocity.texture\n    prog_buoyancy[""Temperature""] = temperature.texture\n    dest.activate()\n    prog_buoyancy.draw(gl.GL_TRIANGLE_STRIP)\n    dest.deactivate()\n\ndef ClearSurface(surface, v):\n    surface.activate()\n    gl.glClearColor(v, v, v, v)\n    gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n    surface.deactivate()\n\ndef disc(shape=(256,256), center=(128,128), radius = 96):\n    def distance(x,y):\n        return np.sqrt((x-center[0])**2+(y-center[1])**2)\n    D = np.fromfunction(distance,shape)\n    return np.where(D<=radius,1.0,0.0).astype(np.float32)\n\ndef CreateObstacles(dest, width, height):\n    dest.activate()\n    gl.glViewport(0, 0, width, height)\n    gl.glClearColor(0, 0, 0, 0)\n    gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n\n    T = np.ones((height,width,3), np.float32).view(gloo.Texture2D)\n\n    T[+1:-1,+1:-1] = 0.0\n    T[...,0] += disc(shape = (GridHeight,GridWidth),\n                     center = (GridHeight/2,GridWidth/2),\n                     radius = 32)\n    T[...,2] += -2*disc(shape = (GridHeight,GridWidth),\n                        center = (GridHeight/2,GridWidth/2),\n                        radius = 32)\n    prog_fill[""Sampler""] = T\n    prog_fill.draw(gl.GL_TRIANGLE_STRIP)\n    dest.deactivate()\n\n@window.event\ndef on_init():\n    gl.glDisable(gl.GL_DEPTH_TEST)\n    gl.glDisable(gl.GL_BLEND)\n    ClearSurface(Temperature.Ping, AmbientTemperature)\n    CreateObstacles(Obstacles, GridWidth, GridHeight)\n\n@window.event\ndef on_draw(dt):\n\n    gl.glViewport(0, 0, GridWidth, GridHeight)\n    gl.glDisable(gl.GL_BLEND)\n\n    Advect(Velocity.Ping, Velocity.Ping, Obstacles, Velocity.Pong, VelocityDissipation)\n    Velocity.swap()\n\n    Advect(Velocity.Ping, Temperature.Ping, Obstacles, Temperature.Pong, TemperatureDissipation)\n    Temperature.swap()\n\n    Advect(Velocity.Ping, Density.Ping, Obstacles, Density.Pong, DensityDissipation)\n    Density.swap()\n\n    ApplyBuoyancy(Velocity.Ping, Temperature.Ping, Density.Ping, Velocity.Pong)\n    Velocity.swap()\n\n    ApplyImpulse(Temperature.Ping, ImpulsePosition, ImpulseTemperature)\n    ApplyImpulse(Density.Ping, ImpulsePosition, ImpulseDensity)\n    ComputeDivergence(Velocity.Ping, Obstacles, Divergence)\n    ClearSurface(Pressure.Ping, 0.0)\n\n    for i in range(NumJacobiIterations):\n        Jacobi(Pressure.Ping, Divergence, Obstacles, Pressure.Pong)\n        Pressure.swap()\n\n    SubtractGradient(Velocity.Ping, Pressure.Ping, Obstacles, Velocity.Pong)\n    Velocity.swap()\n\n    gl.glViewport(0,0,window.width,window.height)\n    gl.glClearColor(0, 0, 0, 1)\n    gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n\n    prog_visualize[\'u_data\']   = Density.Ping.texture\n    prog_visualize[\'u_shape\']  = Density.Ping.texture.shape[1], Density.Ping.texture.shape[0]\n    prog_visualize[\'u_kernel\'] = data.get(""spatial-filters.npy"")\n    prog_visualize[""Sampler""] = Density.Ping.texture\n    prog_visualize[""FillColor""] = 0.95, 0.925, 1.00\n    prog_visualize[""Scale""] =  1.0/window.width, 1.0/window.height\n    prog_visualize.draw(gl.GL_TRIANGLE_STRIP)\n\napp.run()\n'"
examples/transparency/commented-oit.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# This is a python implementation of the ""Weighted Blended Order-Independent\n# Transparency"" technique by Morgan McGuire and Louis Bavoil\n#\n# This implementation use the glumpy python framework available from:\n# glumpy.github.io and https://github.com/glumpy/glumpy\n#\n# Useful resources:\n#  - http://jcgt.org/published/0002/02/09/\n#  - http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html\n#  - http://casual-effects.blogspot.fr/2015/03/implemented-weighted-blended-order.html\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Trackball, Position\n\n# This is the transparent scene vertex shader\n# To be rendered after opaque objects widht depth writing disabled\nscene_vert = """"""\n#version 120\n\nattribute vec4 color;\nattribute vec3 position;\n\nvarying vec4 v_color;\nvarying float v_depth;\nvoid main()\n{\n    // Transform is a simple projection*model*view*vec4(positon,1.0)\n    // You can use your own\n    gl_Position = <transform>;\n\n    // Depth n eye space coordinates (model*view*vec4(positon,1.0))\n    v_depth = -(<transform.trackball_view>*<transform.trackball_model>*vec4(position,1.0)).z;\n\n    v_color = color;\n}\n""""""\n\n# This is the transparent scene fragment shader\n# To be rendered after opaque objects widht depth writing disabled\nscene_frag = """"""\n#version 120\n\nvarying vec4 v_color;\nvarying float v_depth;\nvoid main()\n{\n    float z = v_depth;\n    float alpha = v_color.a;\n\n    // This can be adpated depending on your scene\n    // In this implementation, the 3 quads lies between -40 and -60 z coordinates\n    float weight = pow(alpha + 0.01f, 4.0f) +\n                   max(0.01f, min(3000.0f, 0.3f / (0.00001f + pow(abs(z) / 200.0f, 4.0f))));\n\n    // RGBA32F texture (accumulation)\n    gl_FragData[0] = vec4(v_color.rgb * alpha * weight, alpha);\n\n    // R32F texture (revealage)\n    // Make sure to use the red channel (and GL_RED target in your texture)\n    gl_FragData[1].r = alpha * weight;\n}\n""""""\n\n# Post processing (compositing) vertex shader\ncompose_vert = """"""\n#version 120\n\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    gl_Position = vec4(position,0,1);\n    v_texcoord = (position+1.0)/2.0;\n}""""""\n\n\n# Post processing (compositing) fragment shader\ncompose_frag = """"""\n#version 120\n\nuniform sampler2D tex_accumulation;\nuniform sampler2D tex_revealage;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    vec4 accum = texture2D(tex_accumulation, v_texcoord);\n    float r = accum.a;\n    accum.a = texture2D(tex_revealage, v_texcoord).r;\n    if (r >= 1.0) {\n        discard;\n    }\n    gl_FragColor = vec4(accum.rgb / clamp(accum.a, 1e-4, 5e4), r);\n}\n""""""\n\nC0 = 0.75, 0.75, 0.75, 1.00 # Background color\nC1 = 1.00, 0.00, 0.00, 0.75 # Red quad color\nC2 = 1.00, 1.00, 0.00, 0.75 # Yellow quad color\nC3 = 0.00, 0.00, 1.00, 0.75 # Blue quad color\n\n# New window with a C0 clear color\nwindow = app.Window(width=1024, height=1024)\n\n@window.event\ndef on_draw(dt):\n    # Clear depth and color buffers\n    gl.glClearColor(*C0)\n    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)\n            \n    # Opaque objects rendering\n    gl.glDepthMask(gl.GL_TRUE)\n    gl.glDisable(gl.GL_BLEND)\n    \n    # Transparent objects rendering\n    gl.glDepthMask(gl.GL_FALSE)\n    gl.glEnable(gl.GL_BLEND)\n    framebuffer.activate()\n    gl.glClearColor(0,0,0,1)\n    gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n    \n    window.clear(color=(0,0,0,1))\n    gl.glBlendFuncSeparate(gl.GL_ONE,  gl.GL_ONE,\n                           gl.GL_ZERO, gl.GL_ONE_MINUS_SRC_ALPHA)\n    scene.draw(gl.GL_TRIANGLES, indices)\n    framebuffer.deactivate()\n    \n    # Compositing\n    gl.glBlendFunc(gl.GL_ONE_MINUS_SRC_ALPHA, gl.GL_SRC_ALPHA)\n    compose.draw(gl.GL_TRIANGLE_STRIP)\n\n# RGBA32F float texture\naccumulation = np.zeros((window.height,window.width,4),np.float32).view(gloo.TextureFloat2D)\n\n# R32F float texture\nrevealage = np.zeros((window.height,window.width),np.float32).view(gloo.TextureFloat2D)\n\n# Framebuffer with two color targets\nframebuffer = gloo.FrameBuffer(color=[accumulation,revealage])\n\n\n# Three 10x10 quads at z=-10,0,+10\nscene = gloo.Program(scene_vert, scene_frag, count=12)\nscene[""position""] = [ (-1,-1,-1), (-1,+1,-1), (+1,-1,-1), (+1,+1,-1),\n                      (-1,-1, 0), (-1,+1, 0), (+1,-1, 0), (+1,+1, 0),\n                      (-1,-1,+1), (-1,+1,+1), (+1,-1,+1), (+1,+1,+1) ]\nscene[""position""] *= 10\nscene[""color""] = C1,C1,C1,C1, C2,C2,C2,C2, C3,C3,C3,C3\nindices = np.zeros((3,6),dtype=np.uint32)\nindices[0] = 0 + np.array([0,1,2,1,2,3]) \nindices[1] = 4 + np.array([0,1,2,1,2,3]) \nindices[2] = 8 + np.array([0,1,2,1,2,3]) \nindices = indices.view(gloo.IndexBuffer)\n\n# Post composition\ncompose = gloo.Program(compose_vert, compose_frag)\n# Attach textures from the framebuffer\ncompose[\'tex_accumulation\'] = accumulation\ncompose[\'tex_revealage\']    = revealage\n# Full screen quad\ncompose[\'position\']  = [(-1,-1), (-1,1), (1,-1), (1,1)]\n\n# Glumpy specific code to have a user-controlled trackball Interesting\n# information is the znear/zfar and the distance. This distance is the z\n# translation for the scene, hence quads final z positions are -40,-50,-60\ntrackball = Trackball(Position(""position""), znear=0.1, zfar=100.0, distance=50)\nscene[\'transform\'] = trackball\ntrackball.theta = 40+100\ntrackball.phi = 45\ntrackball.zoom = 40\nwindow.attach(scene[\'transform\'])\n\napp.run()\n'"
examples/transparency/oit-multipass.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# Weighted Blended Order-Independent Transparency.\n#\n# See:\n#  - http://jcgt.org/published/0002/02/09/\n#  - http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html\n#  - http://casual-effects.blogspot.fr/2015/03/implemented-weighted-blended-order.html\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Trackball, Position\n\nvert_quads = """"""\nattribute vec4 color;\nattribute vec3 position;\nvarying vec4 v_color;\nvarying float v_depth;\nvoid main()\n{\n    gl_Position = <transform>;\n    v_depth = -(<transform.trackball_view>*<transform.trackball_model>*vec4(position,1.0)).z;\n    v_color = color;\n}\n""""""\n\nfrag_quads = """"""\nuniform float pass;\nvarying vec4 v_color;\nvarying float v_depth;\nvoid main()\n{\n    float z = v_depth;\n    float alpha = v_color.a;\n    float weight = pow(alpha + 0.01f, 2.0f) +\n                   max(0.01f, min(3000.0f, 0.3f / (0.00001f + pow(abs(z) / 200.0f, 4.0f))));\n    if( pass < 0.5 )\n        gl_FragData[0] = vec4(v_color.rgb * alpha, alpha) * weight;\n    else\n        gl_FragData[0] = vec4(alpha);\n}\n""""""\n\n\nvert_post = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    gl_Position = vec4(position,0,1);\n    v_texcoord = (position+1.0)/2.0;\n}""""""\n\nfrag_post = """"""\nuniform sampler2D tex_accumulation;\nuniform sampler2D tex_revealage;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    vec4 opaque = vec4(0.75,0.75,0.75,1.0);\n    vec4 accum = texture2D(tex_accumulation, v_texcoord);\n    float r = texture2D(tex_revealage, v_texcoord).r;\n    if( r == 1.0)\n        discard;\n    gl_FragColor = vec4(accum.rgb / max(accum.a, 0.00001), 1-r);\n}\n""""""\n\nC0 = (0.75, 0.75, 0.75, 1.00)\nC1 = (1.00, 0.00, 0.00, 0.75)\nC2 = (1.00, 1.00, 0.00, 0.75)\nC3 = (0.00, 0.00, 1.00, 0.75)\n\nwindow = app.Window(width=1024, height=1024, color = C0)\n\n@window.event\ndef on_draw(dt):\n    window.clear(color=C0)\n    \n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glDepthMask(gl.GL_FALSE)\n    gl.glEnable(gl.GL_BLEND)\n\n    # Transparent surfaces\n\n    # Pass 1: accumulation\n    quads[""pass""] = 0\n    framebuffer.color = accumulation\n    framebuffer.activate()\n    gl.glBlendFunc(gl.GL_ONE,  gl.GL_ONE)\n    window.clear(color=(0,0,0,0))\n    quads.draw(gl.GL_TRIANGLES, indices)\n    framebuffer.deactivate()\n\n    # Pass 2: revealage\n    quads[""pass""] = 1\n    framebuffer.color = revealage\n    framebuffer.activate()\n    gl.glBlendFunc(gl.GL_ZERO, gl.GL_ONE_MINUS_SRC_COLOR)\n    window.clear(color=(1,1,1,1))\n    quads.draw(gl.GL_TRIANGLES, indices)\n    framebuffer.deactivate()\n    \n    # Compositing\n    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n    post.draw(gl.GL_TRIANGLE_STRIP)\n    \n    \n\naccumulation = np.zeros((window.height,window.width,4),np.float32).view(gloo.TextureFloat2D)\nrevealage = np.zeros((window.height,window.width),np.ubyte).view(gloo.Texture2D)\nframebuffer = gloo.FrameBuffer(color=[accumulation])\n\nquads = gloo.Program(vert_quads, frag_quads, count=12)\nquads[""position""] = [ (-1,-1,-1), (-1,+1,-1), (+1,-1,-1), (+1,+1,-1),\n                      (-1,-1, 0), (-1,+1, 0), (+1,-1, 0), (+1,+1, 0),\n                      (-1,-1,+1), (-1,+1,+1), (+1,-1,+1), (+1,+1,+1) ]\nquads[""position""] *= 10\n\nquads[""color""] = C1,C1,C1,C1, C2,C2,C2,C2, C3,C3,C3,C3\nindices = np.zeros((3,6),dtype=np.uint32)\nindices[0] = 0 + np.array([0,1,2,1,2,3]) \nindices[1] = 4 + np.array([0,1,2,1,2,3]) \nindices[2] = 8 + np.array([0,1,2,1,2,3]) \nindices = indices.view(gloo.IndexBuffer)\n\n# Post composition\npost = gloo.Program(vert_post, frag_post)\npost[\'tex_accumulation\'] = accumulation\npost[\'tex_revealage\']    = revealage\npost[\'position\']  = [(-1,-1), (-1,1), (1,-1), (1,1)]\n\ntrackball = Trackball(Position(""position""), znear=0.1, zfar=100.0, distance=50)\nquads[\'transform\'] = trackball\ntrackball.theta = 40\ntrackball.phi = 45\ntrackball.zoom = 40\nwindow.attach(quads[\'transform\'])\n\napp.run()\n'"
examples/transparency/oit-teapot.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, data\nfrom glumpy.geometry import primitives\nfrom glumpy.transforms import Trackball, Position\n\n\nteapot_vert = """"""\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvarying float  v_depth;\nvoid main()\n{\n    gl_Position = <transform>;\n    v_depth = -(<transform.trackball_view>*<transform.trackball_model>*vec4(position,1.0)).z;\n    v_texcoord = texcoord;\n}\n""""""\n\nteapot_frag = """"""\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvarying float v_depth;\nvoid main()\n{\n    vec4 color = vec4(vec3(texture2D(texture, v_texcoord).r), .25);\n\n    float z = v_depth;\n    float alpha = color.a;\n    float weight = pow(alpha + 0.01f, 4.0f) +\n                   max(0.01f, min(3000.0f, 0.3f / (0.00001f + pow(abs(z) / 200.0f, 4.0f))));\n    gl_FragData[0] = vec4(color.rgb * alpha * weight, alpha);\n    gl_FragData[1].r = alpha * weight;\n}\n""""""\n\n\npost_process_vert = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    gl_Position = vec4(position,0,1);\n    v_texcoord = (position+1.0)/2.0;\n}""""""\n\npost_process_frag = """"""\nuniform sampler2D tex_accumulation;\nuniform sampler2D tex_revealage;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    vec4 accum = texture2D(tex_accumulation, v_texcoord);\n    float r = accum.a;\n    accum.a = texture2D(tex_revealage, v_texcoord).r;\n    if (r >= 1.0) discard;\n    gl_FragColor = vec4(accum.rgb / clamp(accum.a, 1e-4, 5e4), r);\n}\n""""""\n\n\n\nwindow = app.Window(width=1024, height=1024, color=(.75,.75,.75,1))\n\n@window.event\ndef on_draw(dt):\n\n    window.clear()\n    gl.glDepthMask(gl.GL_FALSE)\n    gl.glEnable(gl.GL_BLEND)\n\n    # Transparent surfaces\n    framebuffer.activate()\n    window.clear(color=(0,0,0,1))\n    gl.glBlendFuncSeparate(gl.GL_ONE,  gl.GL_ONE,\n                           gl.GL_ZERO, gl.GL_ONE_MINUS_SRC_ALPHA)\n    teapot.draw(gl.GL_TRIANGLES, indices)\n    framebuffer.deactivate()\n    \n    # Compositing\n    gl.glBlendFunc(gl.GL_ONE_MINUS_SRC_ALPHA, gl.GL_SRC_ALPHA)\n    gl.glEnable(gl.GL_BLEND)\n    post_process.draw(gl.GL_TRIANGLE_STRIP)\n\n\n\naccumulation = np.zeros((window.height,window.width,4),np.float32).view(gloo.TextureFloat2D)\nrevealage    = np.zeros((window.height,window.width),np.float32).view(gloo.TextureFloat2D)\nframebuffer  = gloo.FrameBuffer(color=[accumulation,revealage])\n\n\nvertices, indices = primitives.teapot()\nvertices[""position""] *= 10\nteapot = gloo.Program(teapot_vert, teapot_frag)\nteapot.bind(vertices)\nteapot[\'texture\'] = data.checkerboard()\n\n# Post composition\npost_process = gloo.Program(post_process_vert, post_process_frag)\npost_process[\'tex_accumulation\'] = accumulation\npost_process[\'tex_revealage\'] = revealage\npost_process[\'position\']  = [(-1,-1), (-1,1), (1,-1), (1,1)]\n\ntrackball = Trackball(Position(""position""), znear=0.1, zfar=100.0, distance=50)\nteapot[\'transform\'] = trackball\ntrackball.theta = 40\ntrackball.phi = 135\ntrackball.zoom = 40\n\nwindow.attach(teapot[\'transform\'])\napp.run()\n'"
examples/transparency/oit.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# Weighted Blended Order-Independent Transparency.\n#\n# See:\n#  - http://jcgt.org/published/0002/02/09/\n#  - http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html\n#  - http://casual-effects.blogspot.fr/2015/03/implemented-weighted-blended-order.html\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Trackball, Position\n\nvert_quads = """"""\nattribute vec4 color;\nattribute vec3 position;\nvarying vec4 v_color;\nvarying float v_depth;\nvoid main()\n{\n    gl_Position = <transform>;\n    v_depth = -(<transform.trackball_view>*<transform.trackball_model>*vec4(position,1.0)).z;\n    v_color = color;\n}\n""""""\nfrag_quads = """"""\nvarying vec4 v_color;\nvarying float v_depth;\nvoid main()\n{\n    float z = v_depth;\n    float alpha = v_color.a;\n    float weight = pow(alpha + 0.01f, 4.0f) +\n                   max(0.01f, min(3000.0f, 0.3f / (0.00001f + pow(abs(z) / 200.0f, 4.0f))));\n    gl_FragData[0] = vec4(v_color.rgb * alpha * weight, alpha);\n    gl_FragData[1].r = alpha * weight;\n}\n""""""\n\n\nvert_post = """"""\nattribute vec2 position;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    gl_Position = vec4(position,0,1);\n    v_texcoord = (position+1.0)/2.0;\n}""""""\n\nfrag_post = """"""\nuniform sampler2D tex_accumulation;\nuniform sampler2D tex_revealage;\nvarying vec2 v_texcoord;\nvoid main(void)\n{\n    vec4 accum = texture2D(tex_accumulation, v_texcoord);\n    float r = accum.a;\n    accum.a = texture2D(tex_revealage, v_texcoord).r;\n    if (r >= 1.0) discard;\n    gl_FragColor = vec4(accum.rgb / clamp(accum.a, 1e-4, 5e4), r);\n}\n""""""\n\nC0 = (0.75, 0.75, 0.75, 1.00)\nC1 = (1.00, 0.00, 0.00, 0.75)\nC2 = (1.00, 1.00, 0.00, 0.75)\nC3 = (0.00, 0.00, 1.00, 0.75)\n\nwindow = app.Window(width=1024, height=1024, color = C0)\n\n@window.event\ndef on_draw(dt):\n    window.clear(color=C0)\n    gl.glDepthMask(gl.GL_FALSE)\n    gl.glEnable(gl.GL_BLEND)\n\n    # Transparent surfaces\n    framebuffer.activate()\n    window.clear(color=(0,0,0,1))\n    gl.glBlendFuncSeparate(gl.GL_ONE,  gl.GL_ONE,\n                           gl.GL_ZERO, gl.GL_ONE_MINUS_SRC_ALPHA)\n    quads.draw(gl.GL_TRIANGLES, indices)\n    framebuffer.deactivate()\n    \n    # Compositing\n    gl.glBlendFunc(gl.GL_ONE_MINUS_SRC_ALPHA, gl.GL_SRC_ALPHA)\n    gl.glEnable(gl.GL_BLEND)\n    post.draw(gl.GL_TRIANGLE_STRIP)\n\n\n# Accumulation buffer\naccumulation = np.zeros((window.height,window.width,4),np.float32).view(gloo.TextureFloat2D)\nrevealage = np.zeros((window.height,window.width),np.float32).view(gloo.TextureFloat2D)\nframebuffer = gloo.FrameBuffer(color=[accumulation,revealage])\n\n# Three quads\nquads = gloo.Program(vert_quads, frag_quads, count=12)\nquads[""position""] = [ (-1,-1,-1), (-1,+1,-1), (+1,-1,-1), (+1,+1,-1),\n                      (-1,-1, 0), (-1,+1, 0), (+1,-1, 0), (+1,+1, 0),\n                      (-1,-1,+1), (-1,+1,+1), (+1,-1,+1), (+1,+1,+1) ]\nquads[""position""] *= 10\n\nquads[""color""] = C1,C1,C1,C1, C2,C2,C2,C2, C3,C3,C3,C3\nindices = np.zeros((3,6),dtype=np.uint32)\nindices[0] = 0 + np.array([0,1,2,1,2,3]) \nindices[1] = 4 + np.array([0,1,2,1,2,3]) \nindices[2] = 8 + np.array([0,1,2,1,2,3]) \nindices = indices.view(gloo.IndexBuffer)\n\n# Post composition\npost = gloo.Program(vert_post, frag_post)\npost[\'tex_accumulation\'] = accumulation\npost[\'tex_revealage\']    = revealage\npost[\'position\']  = [(-1,-1), (-1,1), (1,-1), (1,1)]\n\ntrackball = Trackball(Position(""position""), znear=0.1, zfar=100.0, distance=50)\nquads[\'transform\'] = trackball\ntrackball.theta = 40\ntrackball.phi = 45\ntrackball.zoom = 40\nwindow.attach(quads[\'transform\'])\n\napp.run()\n'"
examples/transparency/reference-depth.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Trackball, Position\n\nvertex = """"""\nattribute vec3 position;\nvarying float depth;\nvoid main()\n{\n    gl_Position = <transform>;\n    vec4 p  = <transform.trackball_view>*<transform.trackball_model>*vec4(position,1.0);\n    depth = -p.z/100;\n}\n""""""\nfragment = """"""\nvarying float depth;\nvoid main()\n{\n    gl_FragColor = vec4(vec3(depth),1);\n} """"""\n\n\ncolor = (0.75,0.75,0.75,1.00)\nwindow = app.Window(1024, 1024, color = color)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quads.draw(gl.GL_TRIANGLES, indices)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n\nquads = gloo.Program(vertex, fragment, count=12)\nquads[""position""] = [ (-1,-1,-1), (-1,+1,-1), (+1,-1,-1), (+1,+1,-1),\n                      (-1,-1, 0), (-1,+1, 0), (+1,-1, 0), (+1,+1, 0),\n                      (-1,-1,+1), (-1,+1,+1), (+1,-1,+1), (+1,+1,+1) ]\nquads[""position""] *= 10\nindices = np.zeros((3,6),dtype=np.uint32)\nindices[0] = 0 + np.array([0,1,2,1,2,3]) \nindices[1] = 4 + np.array([0,1,2,1,2,3]) \nindices[2] = 8 + np.array([0,1,2,1,2,3]) \nindices = indices.view(gloo.IndexBuffer)\n\ntrackball = Trackball(Position(""position""), znear=0.1, zfar=100, distance=50)\n\nquads[\'transform\'] = trackball\ntrackball.theta = 40\ntrackball.phi = 45\ntrackball.zoom = 25\nwindow.attach(quads[\'transform\'])\napp.run()\n'"
examples/transparency/reference-teapot.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo, data\nfrom glumpy.geometry import primitives\nfrom glumpy.transforms import Trackball, Position\n\n\nteapot_vert = """"""\nattribute vec3 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = <transform>;\n    v_texcoord = texcoord;\n}\n""""""\n\nteapot_frag = """"""\nuniform sampler2D texture;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_FragColor = vec4(vec3(texture2D(texture, v_texcoord).r), .25);\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024, color=(.75,.75,.75,1))\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    teapot.draw(gl.GL_TRIANGLES, indices)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\nvertices, indices = primitives.teapot()\nvertices[""position""] *= 10\nteapot = gloo.Program(teapot_vert, teapot_frag)\nteapot.bind(vertices)\nteapot[\'texture\'] = data.checkerboard()\n\ntrackball = Trackball(Position(""position""), znear=0.1, zfar=100.0, distance=50)\nteapot[\'transform\'] = trackball\ntrackball.theta = 40\ntrackball.phi = 135\ntrackball.zoom = 40\n\nwindow.attach(teapot[\'transform\'])\napp.run()\n'"
examples/transparency/reference.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, gloo\nfrom glumpy.transforms import Trackball, Position\n\nvertex = """"""\nattribute vec4 color;\nattribute vec3 position;\nvarying vec4 v_color;\nvoid main()\n{\n    gl_Position = <transform>;\n    v_color = color;\n}\n""""""\nfragment = """"""\nvarying vec4 v_color;\nvoid main()\n{\n    gl_FragColor = v_color;\n} """"""\n\n\nC0 = (0.75,0.75,0.75,1.00)\nC1 = (1.00,0.00,0.00,0.75)\nC2 = (1.00,1.00,0.00,0.75)\nC3 = (0.00,0.00,1.00,0.75)\n\nwindow = app.Window(1024, 1024, color = C0)\n\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quads.draw(gl.GL_TRIANGLES, indices)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_BLEND)\n\nquads = gloo.Program(vertex, fragment, count=12)\nquads[""position""] = [ (-1,-1,-1), (-1,+1,-1), (+1,-1,-1), (+1,+1,-1),\n                      (-1,-1, 0), (-1,+1, 0), (+1,-1, 0), (+1,+1, 0),\n                      (-1,-1,+1), (-1,+1,+1), (+1,-1,+1), (+1,+1,+1) ]\nquads[""position""] *= 10\n\nquads[""color""] = C1,C1,C1,C1, C2,C2,C2,C2, C3,C3,C3,C3\nindices = np.zeros((3,6),dtype=np.uint32)\nindices[0] = 0 + np.array([0,1,2,1,2,3]) \nindices[1] = 4 + np.array([0,1,2,1,2,3]) \nindices[2] = 8 + np.array([0,1,2,1,2,3]) \nindices = indices.view(gloo.IndexBuffer)\n\ntrackball = Trackball(Position(""position""), znear=0.1, zfar=500, distance=50)\nquads[\'transform\'] = trackball\ntrackball.theta = 40\ntrackball.phi = 45\ntrackball.zoom = 40\nwindow.attach(quads[\'transform\'])\napp.run()\n'"
examples/tutorial/color-cube.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\nfrom glumpy.geometry import colorcube\n\nvertex = """"""\nuniform mat4   u_model;         // Model matrix\nuniform mat4   u_view;          // View matrix\nuniform mat4   u_projection;    // Projection matrix\nattribute vec4 a_color;         // Vertex color\nattribute vec3 a_position;      // Vertex position\nvarying vec4   v_color;         // Interpolated fragment color (out)\nvoid main()\n{\n    v_color = a_color;\n    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);\n}\n""""""\n\nfragment = """"""\nvarying vec4   v_color;         // Interpolated fragment color (in)\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n""""""\n\n# window = app.Window(width=1024, height=1024, color=(1,1,1,1))\nwindow = app.Window(width=1024, height=1024,  color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta\n    window.clear()\n\n    # Filled cube\n    cube.draw(gl.GL_TRIANGLES, I)\n    \n    # Rotate cube\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'u_model\'] = model\n\n\n@window.event\ndef on_resize(width, height):\n    cube[\'u_projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n\nV = np.zeros(8, [(""a_position"", np.float32, 3),\n                 (""a_color"",    np.float32, 4)])\nV[""a_position""] = [[ 1, 1, 1], [-1, 1, 1], [-1,-1, 1], [ 1,-1, 1],\n                   [ 1,-1,-1], [ 1, 1,-1], [-1, 1,-1], [-1,-1,-1]]\nV[""a_color""]    = [[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 0, 1],\n                   [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1]]\nV = V.view(gloo.VertexBuffer)\nI = np.array([0,1,2, 0,2,3,  0,3,4, 0,4,5,  0,5,6, 0,6,1,\n              1,6,7, 1,7,2,  7,4,3, 7,3,2,  4,7,6, 4,6,5], dtype=np.uint32)\nI = I.view(gloo.IndexBuffer)\n\ncube = gloo.Program(vertex, fragment)\ncube.bind(V)\n\ncube[\'u_model\'] = np.eye(4, dtype=np.float32)\ncube[\'u_view\'] = glm.translation(0, 0, -5)\nphi, theta = 40, 30\n\napp.run()\n'"
examples/tutorial/glut-cube.py,15,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport sys\nimport math\nimport ctypes\nimport numpy as np\nimport OpenGL.GL as gl\nimport OpenGL.GLUT as glut\n\nvertex_code = """"""\nuniform mat4   u_model;         // Model matrix\nuniform mat4   u_view;          // View matrix\nuniform mat4   u_projection;    // Projection matrix\nuniform vec4   u_color;         // Global color\n\nattribute vec4 a_color;         // Vertex color\nattribute vec3 a_position;      // Vertex position\n\nvarying vec4   v_color;         // Interpolated fragment color (out)\nvoid main()\n{\n    v_color = u_color * a_color;\n    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);\n}\n""""""\n\nfragment_code = """"""\nvarying vec4 v_color;         // Interpolated fragment color (in)\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n""""""\n\n\ndef rotate(M, angle, x, y, z):\n    angle = math.pi * angle / 180\n    c, s = math.cos(angle), math.sin(angle)\n    n = math.sqrt(x * x + y * y + z * z)\n    x, y, z = x/n, y/n, z/n\n    cx, cy, cz = (1 - c) * x, (1 - c) * y, (1 - c) * z\n    R = np.array([[cx * x + c, cy * x - z * s, cz * x + y * s, 0],\n                  [cx * y + z * s, cy * y + c, cz * y - x * s, 0],\n                  [cx * z - y * s, cy * z + x * s, cz * z + c, 0],\n                  [0, 0, 0, 1]], dtype=M.dtype).T\n    M[...] = np.dot(M, R)\n    return M\n\ndef translate(M, x, y=None, z=None):\n    y = x if y is None else y\n    z = x if z is None else z\n    T = np.array([[1.0, 0.0, 0.0, x],\n                  [0.0, 1.0, 0.0, y],\n                  [0.0, 0.0, 1.0, z],\n                  [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype).T\n    M[...] = np.dot(M, T)\n    return M\n\ndef frustum(left, right, bottom, top, znear, zfar):\n    M = np.zeros((4, 4), dtype=np.float32)\n    M[0, 0] = +2.0 * znear / (right - left)\n    M[2, 0] = (right + left) / (right - left)\n    M[1, 1] = +2.0 * znear / (top - bottom)\n    M[3, 1] = (top + bottom) / (top - bottom)\n    M[2, 2] = -(zfar + znear) / (zfar - znear)\n    M[3, 2] = -2.0 * znear * zfar / (zfar - znear)\n    M[2, 3] = -1.0\n    return M\n\ndef perspective(fovy, aspect, znear, zfar):\n    h = math.tan(fovy / 360.0 * math.pi) * znear\n    w = h * aspect\n    return frustum(-w, w, -h, h, znear, zfar)\n\n\n\n\ndef display():\n    global phi, theta\n\n    gl.glDepthMask(gl.GL_TRUE)\n    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)\n\n    # Filled cube\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glUniform4f(gpu[""uniform""][""u_color""], 1, 1, 1, 1)\n    gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, gpu[""buffer""][""filled""])\n    gl.glDrawElements(gl.GL_TRIANGLES, len(f_indices), gl.GL_UNSIGNED_INT, None)\n\n    # Outlined cube\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    gl.glUniform4f(gpu[""uniform""][""u_color""], 0, 0, 0, .5)\n    gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, gpu[""buffer""][""outline""])\n    gl.glDrawElements(gl.GL_LINES, len(o_indices), gl.GL_UNSIGNED_INT, None)\n    gl.glDepthMask(gl.GL_TRUE)\n        \n    # Rotate cube\n    theta += 0.5 # degrees\n    phi   += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    rotate(model, theta, 0, 0, 1)\n    rotate(model, phi, 0, 1, 0)\n    gl.glUniformMatrix4fv(gpu[""uniform""][""u_model""], 1, False, model)\n    glut.glutSwapBuffers()\n\n    \ndef reshape(width,height):\n    gl.glViewport(0, 0, width, height)\n    projection = perspective(45.0, width / float(height), 2.0, 100.0)\n    gl.glUniformMatrix4fv(gpu[""uniform""][""u_projection""], 1, False, projection)\n    \ndef keyboard( key, x, y ):\n    if key == b\'\\033\':  sys.exit( )\n        \ndef timer(fps):\n    glut.glutTimerFunc(1000//fps, timer, fps)\n    glut.glutPostRedisplay()\n\n\n# GLUT init\n# --------------------------------------\nglut.glutInit()\nglut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)\nglut.glutCreateWindow(\'Hello world!\')\nglut.glutReshapeWindow(512,512)\nglut.glutReshapeFunc(reshape)\nglut.glutDisplayFunc(display)\nglut.glutKeyboardFunc(keyboard)\nglut.glutTimerFunc(1000//60, timer, 60)\n\n# Build cube\n# --------------------------------------\nvertices = np.zeros(8, [(""a_position"", np.float32, 3),\n                        (""a_color"", np.float32, 4)])\nvertices[""a_position""] = [[ 1, 1, 1], [-1, 1, 1], [-1,-1, 1], [ 1,-1, 1],\n                          [ 1,-1,-1], [ 1, 1,-1], [-1, 1,-1], [-1,-1,-1]]\nvertices[""a_color""]    = [[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 0, 1],\n                          [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1]]\nf_indices = np.array([0,1,2, 0,2,3,  0,3,4, 0,4,5,  0,5,6, 0,6,1,\n                      1,6,7, 1,7,2,  7,4,3, 7,3,2,  4,7,6, 4,6,5], dtype=np.uint32)\no_indices = np.array([0,1, 1,2, 2,3, 3,0, 4,7, 7,6,\n                      6,5, 5,4, 0,5, 1,6, 2,7, 3,4], dtype=np.uint32)\n\n# Build & activate program\n# --------------------------------------\nprogram  = gl.glCreateProgram()\nvertex = gl.glCreateShader(gl.GL_VERTEX_SHADER)\nfragment = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)\ngl.glShaderSource(vertex, vertex_code)\ngl.glCompileShader(vertex)\ngl.glAttachShader(program, vertex)\ngl.glShaderSource(fragment, fragment_code)\ngl.glCompileShader(fragment)\ngl.glAttachShader(program, fragment)\ngl.glLinkProgram(program)\ngl.glDetachShader(program, vertex)\ngl.glDetachShader(program, fragment)\ngl.glUseProgram(program)\n\n\n# Build GPU objects\n# --------------------------------------\ngpu = { ""buffer"" : {}, ""uniform"" : {} }\n\ngpu[""buffer""][""vertices""] = gl.glGenBuffers(1)\ngl.glBindBuffer(gl.GL_ARRAY_BUFFER, gpu[""buffer""][""vertices""])\ngl.glBufferData(gl.GL_ARRAY_BUFFER, vertices.nbytes, vertices, gl.GL_DYNAMIC_DRAW)\nstride = vertices.strides[0]\n\noffset = ctypes.c_void_p(0)\nloc = gl.glGetAttribLocation(program, ""a_position"")\ngl.glEnableVertexAttribArray(loc)\ngl.glVertexAttribPointer(loc, 3, gl.GL_FLOAT, False, stride, offset)\n\noffset = ctypes.c_void_p(vertices.dtype[""a_position""].itemsize)\nloc = gl.glGetAttribLocation(program, ""a_color"")\ngl.glEnableVertexAttribArray(loc)\ngl.glVertexAttribPointer(loc, 4, gl.GL_FLOAT, False, stride, offset)\n\ngpu[""buffer""][""filled""] = gl.glGenBuffers(1)\ngl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, gpu[""buffer""][""filled""])\ngl.glBufferData(gl.GL_ELEMENT_ARRAY_BUFFER, f_indices.nbytes, f_indices, gl.GL_STATIC_DRAW)\n\ngpu[""buffer""][""outline""] = gl.glGenBuffers(1)\ngl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, gpu[""buffer""][""outline""])\ngl.glBufferData(gl.GL_ELEMENT_ARRAY_BUFFER, o_indices.nbytes, o_indices, gl.GL_STATIC_DRAW)\n\n# Bind uniforms\n# --------------------------------------\ngpu[""uniform""][""u_model""] = gl.glGetUniformLocation(program, ""u_model"")\ngl.glUniformMatrix4fv(gpu[""uniform""][""u_model""], 1, False, np.eye(4))\n\ngpu[""uniform""][""u_view""] = gl.glGetUniformLocation(program, ""u_view"")\nview = translate(np.eye(4), 0, 0, -5)\ngl.glUniformMatrix4fv(gpu[""uniform""][""u_view""], 1, False, view)\n\ngpu[""uniform""][""u_projection""] = gl.glGetUniformLocation(program, ""u_projection"")\ngl.glUniformMatrix4fv(gpu[""uniform""][""u_projection""], 1, False, np.eye(4))\n\ngpu[""uniform""][""u_color""] = gl.glGetUniformLocation(program, ""u_color"")\ngl.glUniform4f(gpu[""uniform""][""u_color""], 1, 1, 1, 1)\n\nphi, theta = 40, 30\n\n# Enter mainloop\n# --------------------------------------\ngl.glClearColor(1,1,1,1)\ngl.glPolygonOffset(1, 1)\ngl.glEnable(gl.GL_LINE_SMOOTH)\ngl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\ngl.glHint(gl.GL_LINE_SMOOTH_HINT, gl.GL_NICEST)\ngl.glLineWidth(1.0)\nglut.glutMainLoop()\n'"
examples/tutorial/light-cube-simple.py,17,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo, data\n\ndef cube():\n    vtype = [(\'a_position\', np.float32, 3),\n             (\'a_texcoord\', np.float32, 2),\n             (\'a_normal\',   np.float32, 3)]\n    itype = np.uint32\n\n    # Vertices positions\n    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],\n                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]], dtype=float)\n    # Face Normals\n    n = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0],\n                  [-1, 0, 1], [0, -1, 0], [0, 0, -1]])\n    # Texture coords\n    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])\n\n    faces_p = [0, 1, 2, 3,  0, 3, 4, 5,   0, 5, 6, 1,\n               1, 6, 7, 2,  7, 4, 3, 2,   4, 7, 6, 5]\n    faces_n = [0, 0, 0, 0,  1, 1, 1, 1,   2, 2, 2, 2,\n               3, 3, 3, 3,  4, 4, 4, 4,   5, 5, 5, 5]\n    faces_t = [0, 1, 2, 3,  0, 1, 2, 3,   0, 1, 2, 3,\n               3, 2, 1, 0,  0, 1, 2, 3,   0, 1, 2, 3]\n\n    vertices = np.zeros(24, vtype)\n    vertices[\'a_position\'] = p[faces_p]\n    vertices[\'a_normal\']   = n[faces_n]\n    vertices[\'a_texcoord\'] = t[faces_t]\n\n    filled = np.resize(\n       np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))\n    filled += np.repeat(4 * np.arange(6, dtype=itype), 6)\n\n    outline = np.resize(\n        np.array([0, 1, 1, 2, 2, 3, 3, 0], dtype=itype), 6 * (2 * 4))\n    outline += np.repeat(4 * np.arange(6, dtype=itype), 8)\n    vertices = vertices.view(gloo.VertexBuffer)\n    filled   = filled.view(gloo.IndexBuffer)\n\n    return vertices, filled\n\n\nvertex = """"""\nuniform mat4   u_model;         // Model matrix\nuniform mat4   u_view;          // View matrix\nuniform mat4   u_projection;    // Projection matrix\nattribute vec3 a_position;      // Vertex position\nattribute vec3 a_normal;        // Vertex normal\nattribute vec2 a_texcoord;      // Vertex texture coordinates\nvarying vec3   v_normal;        // Interpolated normal (out)\nvarying vec3   v_position;      // Interpolated position (out)\nvarying vec2   v_texcoord;      // Interpolated fragment texture coordinates (out)\n\nvoid main()\n{\n    // Assign varying variables\n    v_normal   = a_normal;\n    v_position = a_position;\n    v_texcoord = a_texcoord;\n\n    // Final position\n    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);\n}\n""""""\n\nfragment = """"""\nuniform mat4      u_model;           // Model matrix\nuniform mat4      u_view;            // View matrix\nuniform mat4      u_normal;          // Normal matrix\nuniform mat4      u_projection;      // Projection matrix\nuniform sampler2D u_texture;         // Texture \nuniform vec3      u_light_position;  // Light position\nuniform vec3      u_light_intensity; // Light intensity\n\nvarying vec3      v_normal;          // Interpolated normal (in)\nvarying vec3      v_position;        // Interpolated position (in)\nvarying vec2      v_texcoord;        // Interpolated fragment texture coordinates (in)\nvoid main()\n{\n    // Calculate normal in world coordinates\n    vec3 normal = normalize(u_normal * vec4(v_normal,1.0)).xyz;\n\n    // Calculate the location of this fragment (pixel) in world coordinates\n    vec3 position = vec3(u_view*u_model * vec4(v_position, 1));\n\n    // Calculate the vector from this pixels surface to the light source\n    vec3 surfaceToLight = u_light_position - position;\n\n    // Calculate the cosine of the angle of incidence (brightness)\n    float brightness = dot(normal, surfaceToLight) /\n                      (length(surfaceToLight) * length(normal));\n    brightness = max(min(brightness,1.0),0.0);\n\n    // Calculate final color of the pixel, based on:\n    // 1. The angle of incidence: brightness\n    // 2. The color/intensities of the light: light.intensities\n    // 3. The texture and texture coord: texture(tex, fragTexCoord)\n\n    // Get texture color\n    vec4 t_color = vec4(texture2D(u_texture, v_texcoord).rgb, 1.0);\n\n    // Final color\n    gl_FragColor = t_color * (0.1 + 0.9*brightness * vec4(u_light_intensity, 1));\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, duration\n\n    window.clear()\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    cube.draw(gl.GL_TRIANGLES, indices)\n\n    # Rotate cube\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    view = cube[\'u_view\'].reshape(4,4)\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'u_model\'] = model\n    cube[\'u_normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\n\n@window.event\ndef on_resize(width, height):\n    cube[\'u_projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glDisable(gl.GL_BLEND)\n    \nvertices, indices = cube()\ncube = gloo.Program(vertex, fragment)\ncube.bind(vertices)\n\ncube[""u_light_position""] = -2,-2,2\ncube[""u_light_intensity""] = 1,1,1\ncube[\'u_texture\'] = data.get(""crate.png"")\ncube[\'u_model\'] = np.eye(4, dtype=np.float32)\ncube[\'u_view\'] = glm.translation(0, 0, -5)\nphi, theta = 40, 30\n\napp.run()\n'"
examples/tutorial/light-cube.py,18,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\n\ndef cube():\n    vtype = [(\'a_position\', np.float32, 3), (\'a_texcoord\', np.float32, 2),\n             (\'a_normal\',   np.float32, 3), (\'a_color\',    np.float32, 4)]\n    itype = np.uint32\n\n    # Vertices positions\n    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],\n                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]], dtype=float)\n    # Face Normals\n    n = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0],\n                  [-1, 0, 1], [0, -1, 0], [0, 0, -1]])\n    # Vertice colors\n    c = np.array([[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 0, 1],\n                  [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1]])\n    # Texture coords\n    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])\n\n    faces_p = [0, 1, 2, 3,  0, 3, 4, 5,   0, 5, 6, 1,\n               1, 6, 7, 2,  7, 4, 3, 2,   4, 7, 6, 5]\n    faces_c = [0, 1, 2, 3,  0, 3, 4, 5,   0, 5, 6, 1,\n               1, 6, 7, 2,  7, 4, 3, 2,   4, 7, 6, 5]\n    faces_n = [0, 0, 0, 0,  1, 1, 1, 1,   2, 2, 2, 2,\n               3, 3, 3, 3,  4, 4, 4, 4,   5, 5, 5, 5]\n    faces_t = [0, 1, 2, 3,  0, 1, 2, 3,   0, 1, 2, 3,\n               3, 2, 1, 0,  0, 1, 2, 3,   0, 1, 2, 3]\n\n    vertices = np.zeros(24, vtype)\n    vertices[\'a_position\'] = p[faces_p]\n    vertices[\'a_normal\']   = n[faces_n]\n    vertices[\'a_color\']    = c[faces_c]\n    vertices[\'a_texcoord\'] = t[faces_t]\n\n    filled = np.resize(\n       np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))\n    filled += np.repeat(4 * np.arange(6, dtype=itype), 6)\n\n    outline = np.resize(\n        np.array([0, 1, 1, 2, 2, 3, 3, 0], dtype=itype), 6 * (2 * 4))\n    outline += np.repeat(4 * np.arange(6, dtype=itype), 8)\n\n    vertices = vertices.view(gloo.VertexBuffer)\n    filled   = filled.view(gloo.IndexBuffer)\n    outline  = outline.view(gloo.IndexBuffer)\n\n    return vertices, filled, outline\n\n\ndef checkerboard(grid_num=8, grid_size=32):\n    """""" Checkerboard pattern """"""\n    \n    row_even = grid_num // 2 * [0, 1]\n    row_odd = grid_num // 2 * [1, 0]\n    Z = np.row_stack(grid_num // 2 * (row_even, row_odd)).astype(np.uint8)\n    return 255 * Z.repeat(grid_size, axis=0).repeat(grid_size, axis=1)\n\n\nvertex = """"""\nuniform mat4   u_model;         // Model matrix\nuniform mat4   u_view;          // View matrix\nuniform mat4   u_projection;    // Projection matrix\nattribute vec4 a_color;         // Vertex color\nattribute vec3 a_position;      // Vertex position\nattribute vec3 a_normal;        // Vertex normal\nattribute vec2 a_texcoord;      // Vertex texture coordinates\nvarying vec4   v_color;         // Interpolated fragment color (out)\nvarying vec3   v_normal;        // Interpolated normal (out)\nvarying vec3   v_position;      // Interpolated position (out)\nvarying vec2   v_texcoord;      // Interpolated fragment texture coordinates (out)\n\nvoid main()\n{\n    // Assign varying variables\n    v_color    = a_color;      \n    v_normal   = a_normal;\n    v_position = a_position;\n    v_texcoord = a_texcoord;\n\n    // Final position\n    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);\n}\n""""""\n\nfragment = """"""\nuniform mat4      u_model;           // Model matrix\nuniform mat4      u_view;            // View matrix\nuniform mat4      u_normal;          // Normal matrix\nuniform mat4      u_projection;      // Projection matrix\nuniform vec4      u_color;           // Global color\nuniform sampler2D u_texture;         // Texture \nuniform vec3      u_light_position;  // Light position\nuniform vec3      u_light_intensity; // Light intensity\n\nvarying vec4      v_color;           // Interpolated fragment color (in)\nvarying vec3      v_normal;          // Interpolated normal (in)\nvarying vec3      v_position;        // Interpolated position (in)\nvarying vec2      v_texcoord;        // Interpolated fragment texture coordinates (in)\nvoid main()\n{\n    // Calculate normal in world coordinates\n    vec3 normal = normalize(u_normal * vec4(v_normal,1.0)).xyz;\n\n    // Calculate the location of this fragment (pixel) in world coordinates\n    vec3 position = vec3(u_view*u_model * vec4(v_position, 1));\n\n    // Calculate the vector from this pixels surface to the light source\n    vec3 surfaceToLight = u_light_position - position;\n\n    // Calculate the cosine of the angle of incidence (brightness)\n    float brightness = dot(normal, surfaceToLight) /\n                      (length(surfaceToLight) * length(normal));\n    brightness = max(min(brightness,1.0),0.0);\n\n    // Calculate final color of the pixel, based on:\n    // 1. The angle of incidence: brightness\n    // 2. The color/intensities of the light: light.intensities\n    // 3. The texture and texture coord: texture(tex, fragTexCoord)\n\n    // Get texture color\n    vec4 t_color = vec4(vec3(texture2D(u_texture, v_texcoord).r), 1.0);\n\n    // Final color\n    vec4 color = u_color * t_color * mix(v_color, t_color, 0.25);\n\n    gl_FragColor = color * brightness * vec4(u_light_intensity, 1);\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, duration\n\n    window.clear()\n\n    # Filled cube\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    cube[\'u_color\'] = 1, 1, 1, 1\n    cube.draw(gl.GL_TRIANGLES, I)\n\n    # Outlined cube\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    cube[\'u_color\'] = 0, 0, 0, 1\n    cube.draw(gl.GL_LINES, O)\n    gl.glDepthMask(gl.GL_TRUE)\n\n    # Rotate cube\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    view = cube[\'u_view\'].reshape(4,4)\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'u_model\'] = model\n    cube[\'u_normal\'] = np.array(np.matrix(np.dot(view, model)).I.T)\n\n@window.event\ndef on_resize(width, height):\n    cube[\'u_projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glPolygonOffset(1, 1)\n    gl.glEnable(gl.GL_LINE_SMOOTH)\n\n\nV,I,O = cube()\ncube = gloo.Program(vertex, fragment)\ncube.bind(V)\n\ncube[""u_light_position""] = 2,2,2\ncube[""u_light_intensity""] = 1,1,1\ncube[\'u_texture\'] = checkerboard()\ncube[\'u_model\'] = np.eye(4, dtype=np.float32)\ncube[\'u_view\'] = glm.translation(0, 0, -5)\nphi, theta = 40, 30\n\napp.run()\n'"
examples/tutorial/outline-cube.py,8,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\nfrom glumpy.geometry import colorcube\n\nvertex = """"""\nuniform mat4   u_model;         // Model matrix\nuniform mat4   u_view;          // View matrix\nuniform mat4   u_projection;    // Projection matrix\nuniform vec4   u_color;         // Global color\nattribute vec4 a_color;         // Vertex color\nattribute vec3 a_position;      // Vertex position\nvarying vec4   v_color;         // Interpolated fragment color (out)\nvarying vec2   v_texcoord;      // Interpolated fragment texture coordinates (out)\n\nvoid main()\n{\n    v_color = u_color * a_color;\n    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);\n}\n""""""\n\nfragment = """"""\nvarying vec4   v_color;         // Interpolated fragment color (in)\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, duration\n\n    window.clear()\n\n    # Filled cube\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    cube[\'u_color\'] = 1, 1, 1, 1\n    cube.draw(gl.GL_TRIANGLES, I)\n\n    # Outlined cube\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    cube[\'u_color\'] = 0, 0, 0, 1\n    cube.draw(gl.GL_LINES, O)\n    gl.glDepthMask(gl.GL_TRUE)\n\n    # Rotate cube\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'u_model\'] = model\n\n\n@window.event\ndef on_resize(width, height):\n    cube[\'u_projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glPolygonOffset(1, 1)\n    gl.glEnable(gl.GL_LINE_SMOOTH)\n\n\nV = np.zeros(8, [(""a_position"", np.float32, 3),\n                 (""a_color"",    np.float32, 4)])\nV[""a_position""] = [[ 1, 1, 1], [-1, 1, 1], [-1,-1, 1], [ 1,-1, 1],\n                   [ 1,-1,-1], [ 1, 1,-1], [-1, 1,-1], [-1,-1,-1]]\nV[""a_color""]    = [[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 0, 1],\n                   [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1]]\nV = V.view(gloo.VertexBuffer)\nI = np.array([0,1,2, 0,2,3,  0,3,4, 0,4,5,  0,5,6, 0,6,1,\n              1,6,7, 1,7,2,  7,4,3, 7,3,2,  4,7,6, 4,6,5], dtype=np.uint32)\nI = I.view(gloo.IndexBuffer)\nO = np.array([0,1, 1,2, 2,3, 3,0, 4,7, 7,6,\n              6,5, 5,4, 0,5, 1,6, 2,7, 3,4], dtype=np.uint32)\nO = O.view(gloo.IndexBuffer)\n\ncube = gloo.Program(vertex, fragment)\ncube.bind(V)\n\ncube[\'u_model\'] = np.eye(4, dtype=np.float32)\ncube[\'u_view\'] = glm.translation(0, 0, -5)\nphi, theta = 40, 30\n\napp.run()\n'"
examples/tutorial/quad-aspect.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gloo, gl\n\nvertex = """"""\n  uniform vec2 scale;\n  attribute vec2 position;\n  attribute vec4 color;\n  varying vec4 v_color;\n  void main()\n  {\n    gl_Position = vec4(scale*position, 0.0, 1.0);\n    v_color = color;\n  } """"""\n\nfragment = """"""\n  varying vec4 v_color;\n  void main()\n  {\n      gl_FragColor = v_color;\n  } """"""\n\n# Build the program and corresponding buffers (with 4 vertices)\nquad = gloo.Program(vertex, fragment, count=4)\n\n# Upload data into GPU\nquad[\'color\'] = [ (1,0,0,1), (0,1,0,1), (0,0,1,1), (1,1,0,1) ]\nquad[\'position\'] = [ (-1,-1),   (-1,+1),   (+1,-1),   (+1,+1)   ]\nquad[\'scale\'] = 1.0, 1.0\n\n# Create a window with a valid GL context\nwindow = app.Window()\n\n# Tell glumpy what needs to be done at each redraw\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_resize(width,height):\n    if width > height:\n        quad[\'scale\'] = height/float(width), 1.0\n    else:\n        quad[\'scale\'] = 1.0, width/float(height)\n        \n# Run the app\napp.run()\n'"
examples/tutorial/quad-glut.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport sys\nimport ctypes\nimport numpy as np\nimport OpenGL.GL as gl\nimport OpenGL.GLUT as glut\n\nvertex_code = """"""\n    uniform float scale;\n    attribute vec4 color;\n    attribute vec2 position;\n    varying vec4 v_color;\n    void main()\n    {\n        gl_Position = vec4(scale*position, 0.0, 1.0);\n        v_color = color;\n    } """"""\n\nfragment_code = """"""\n    varying vec4 v_color;\n    void main()\n    {\n        gl_FragColor = v_color;\n    } """"""\n\ndef display():\n    gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n    gl.glDrawArrays(gl.GL_TRIANGLE_STRIP, 0, 4)\n    glut.glutSwapBuffers()\n\ndef reshape(width,height):\n    gl.glViewport(0, 0, width, height)\n\ndef keyboard( key, x, y ):\n    if key == \'\\033\':\n        sys.exit( )\n\n\n# GLUT init\n# --------------------------------------\nglut.glutInit()\nglut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)\nglut.glutCreateWindow(\'Hello world!\')\nglut.glutReshapeWindow(512,512)\nglut.glutReshapeFunc(reshape)\nglut.glutDisplayFunc(display)\nglut.glutKeyboardFunc(keyboard)\n\n# Build data\n# --------------------------------------\ndata = np.zeros(4, [(""position"", np.float32, 2),\n                    (""color"",    np.float32, 4)])\ndata[\'color\']    = [ (1,0,0,1), (0,1,0,1), (0,0,1,1), (1,1,0,1) ]\ndata[\'position\'] = [ (-1,-1),   (-1,+1),   (+1,-1),   (+1,+1)   ]\n\n# Build & activate program\n# --------------------------------------\n\n# Request a program and shader slots from GPU\nprogram  = gl.glCreateProgram()\nvertex   = gl.glCreateShader(gl.GL_VERTEX_SHADER)\nfragment = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)\n\n# Set shaders source\ngl.glShaderSource(vertex, vertex_code)\ngl.glShaderSource(fragment, fragment_code)\n\n# Compile shaders\ngl.glCompileShader(vertex)\ngl.glCompileShader(fragment)\n\n# Attach shader objects to the program\ngl.glAttachShader(program, vertex)\ngl.glAttachShader(program, fragment)\n\n# Build program\ngl.glLinkProgram(program)\n\n# Get rid of shaders (no more needed)\ngl.glDetachShader(program, vertex)\ngl.glDetachShader(program, fragment)\n\n# Make program the default program\ngl.glUseProgram(program)\n\n\n# Build buffer\n# --------------------------------------\n\n# Request a buffer slot from GPU\nbuffer = gl.glGenBuffers(1)\n\n# Make this buffer the default one\ngl.glBindBuffer(gl.GL_ARRAY_BUFFER, buffer)\n\n# Upload data\ngl.glBufferData(gl.GL_ARRAY_BUFFER, data.nbytes, data, gl.GL_DYNAMIC_DRAW)\n\n\n# Bind attributes\n# --------------------------------------\nstride = data.strides[0]\noffset = ctypes.c_void_p(0)\nloc = gl.glGetAttribLocation(program, ""position"")\ngl.glEnableVertexAttribArray(loc)\ngl.glBindBuffer(gl.GL_ARRAY_BUFFER, buffer)\ngl.glVertexAttribPointer(loc, 3, gl.GL_FLOAT, False, stride, offset)\n\noffset = ctypes.c_void_p(data.dtype[""position""].itemsize)\nloc = gl.glGetAttribLocation(program, ""color"")\ngl.glEnableVertexAttribArray(loc)\ngl.glBindBuffer(gl.GL_ARRAY_BUFFER, buffer)\ngl.glVertexAttribPointer(loc, 4, gl.GL_FLOAT, False, stride, offset)\n\n# Bind uniforms\n# --------------------------------------\nloc = gl.glGetUniformLocation(program, ""scale"")\ngl.glUniform1f(loc, 1.0)\n\n# Enter mainloop\n# --------------------------------------\nglut.glutMainLoop()\n'"
examples/tutorial/quad-rotation.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gloo, gl\n\nvertex = """"""\n    uniform float theta;\n    attribute vec4 color;\n    attribute vec2 position;\n    varying vec4 v_color;\n    void main()\n    {\n        float ct = cos(theta);\n        float st = sin(theta);\n        float x = 0.75* (position.x*ct - position.y*st);\n        float y = 0.75* (position.x*st + position.y*ct);\n        gl_Position = vec4(x, y, 0.0, 1.0);\n        v_color = color;\n    } """"""\n\n\nfragment = """"""\n  varying vec4 v_color;\n  void main()\n  {\n      gl_FragColor = v_color;\n  } """"""\n\n# Build the program and corresponding buffers (with 4 vertices)\nquad = gloo.Program(vertex, fragment, count=4)\n\n# Upload data into GPU\nquad[\'color\'] = [ (1,0,0,1), (0,1,0,1), (0,0,1,1), (1,1,0,1) ]\nquad[\'position\'] = [ (-1,-1),   (-1,+1),   (+1,-1),   (+1,+1)   ]\nquad[\'theta\'] = 0\n\n# Create a window with a valid GL context\nwindow = app.Window()\n\ntheta = 0.0\n\n# Tell glumpy what needs to be done at each redraw\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad[\'theta\'] += dt\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\n# Run the app\napp.run()\n'"
examples/tutorial/quad-scale.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport math\nfrom glumpy import app, gloo, gl\n\nvertex = """"""\n  uniform float scale;\n  attribute vec2 position;\n  attribute vec4 color;\n  varying vec4 v_color;\n  void main()\n  {\n    gl_Position = vec4(scale*position, 0.0, 1.0);\n    v_color = color;\n  } """"""\n\nfragment = """"""\n  varying vec4 v_color;\n  void main()\n  {\n      gl_FragColor = v_color;\n  } """"""\n\n# Build the program and corresponding buffers (with 4 vertices)\nquad = gloo.Program(vertex, fragment, count=4)\n\n# Upload data into GPU\nquad[\'color\'] = [ (1,0,0,1), (0,1,0,1), (0,0,1,1), (1,1,0,1) ]\nquad[\'position\'] = [ (-1,-1),   (-1,+1),   (+1,-1),   (+1,+1)   ]\nquad[\'scale\'] = 1.0\n\n# Create a window with a valid GL context\nwindow = app.Window()\n\ntime = 0.0\n\n# Tell glumpy what needs to be done at each redraw\n@window.event\ndef on_draw(dt):\n    global time\n    time += dt\n    window.clear()\n    quad[""scale""] = math.cos(time)\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\n# Run the app\napp.run()\n'"
examples/tutorial/quad-simple.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gloo, gl\n\nvertex = """"""\n  uniform float scale;\n  attribute vec2 position;\n  attribute vec4 color;\n  varying vec4 v_color;\n  void main()\n  {\n    gl_Position = vec4(scale*position, 0.0, 1.0);\n    v_color = color;\n  } """"""\n\nfragment = """"""\n  varying vec4 v_color;\n  void main()\n  {\n      gl_FragColor = v_color;\n  } """"""\n\n# Build the program and corresponding buffers (with 4 vertices)\nquad = gloo.Program(vertex, fragment, count=4)\n\n# Upload data into GPU\nquad[\'color\'] = [ (1,0,0,1), (0,1,0,1), (0,0,1,1), (1,1,0,1) ]\nquad[\'position\'] = [ (-1,-1),   (-1,+1),   (+1,-1),   (+1,+1)   ]\nquad[\'scale\'] = 1.0\n\n# Create a window with a valid GL context\nwindow = app.Window()\n\n# Tell glumpy what needs to be done at each redraw\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\n# Run the app\napp.run()\n'"
examples/tutorial/solid-cube.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\nfrom glumpy.geometry import colorcube\n\nvertex = """"""\nuniform mat4   u_model;         // Model matrix\nuniform mat4   u_view;          // View matrix\nuniform mat4   u_projection;    // Projection matrix\nattribute vec3 a_position;      // Vertex position\nvoid main()\n{\n    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);\n}\n""""""\n\nfragment = """"""\nvoid main()\n{\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta\n    window.clear()\n\n    # Filled cube\n    cube.draw(gl.GL_TRIANGLES, I)\n\n    # Make cube rotate\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'u_model\'] = model\n\n\n@window.event\ndef on_resize(width, height):\n    cube[\'u_projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n\nV = np.zeros(8, [(""a_position"", np.float32, 3)])\nV[""a_position""] = [[ 1, 1, 1], [-1, 1, 1], [-1,-1, 1], [ 1,-1, 1],\n                   [ 1,-1,-1], [ 1, 1,-1], [-1, 1,-1], [-1,-1,-1]]\nV = V.view(gloo.VertexBuffer)\nI = np.array([0,1,2, 0,2,3,  0,3,4, 0,4,5,  0,5,6, 0,6,1,\n              1,6,7, 1,7,2,  7,4,3, 7,3,2,  4,7,6, 4,6,5], dtype=np.uint32)\nI = I.view(gloo.IndexBuffer)\n\ncube = gloo.Program(vertex, fragment)\ncube.bind(V)\ncube[\'u_model\'] = np.eye(4, dtype=np.float32)\ncube[\'u_view\'] = glm.translation(0, 0, -5)\nphi, theta = 40, 30\n\napp.run()\n'"
examples/tutorial/texture-cube-simple.py,13,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo, data\n\ndef cube():\n    vtype = [(\'a_position\', np.float32, 3),\n             (\'a_texcoord\', np.float32, 2),\n             (\'a_normal\',   np.float32, 3)]\n    itype = np.uint32\n\n    # Vertices positions\n    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],\n                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]], dtype=float)\n    # Face Normals\n    n = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0],\n                  [-1, 0, 1], [0, -1, 0], [0, 0, -1]])\n    # Texture coords\n    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])\n\n    faces_p = [0, 1, 2, 3,  0, 3, 4, 5,   0, 5, 6, 1,\n               1, 6, 7, 2,  7, 4, 3, 2,   4, 7, 6, 5]\n    faces_n = [0, 0, 0, 0,  1, 1, 1, 1,   2, 2, 2, 2,\n               3, 3, 3, 3,  4, 4, 4, 4,   5, 5, 5, 5]\n    faces_t = [0, 1, 2, 3,  0, 1, 2, 3,   0, 1, 2, 3,\n               3, 2, 1, 0,  0, 1, 2, 3,   0, 1, 2, 3]\n\n    vertices = np.zeros(24, vtype)\n    vertices[\'a_position\'] = p[faces_p]\n    vertices[\'a_normal\']   = n[faces_n]\n    vertices[\'a_texcoord\'] = t[faces_t]\n\n    filled = np.resize(\n       np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))\n    filled += np.repeat(4 * np.arange(6, dtype=itype), 6)\n    vertices = vertices.view(gloo.VertexBuffer)\n    filled = filled.view(gloo.IndexBuffer)\n\n    return vertices, filled\n\n\n\nvertex = """"""\nuniform mat4   u_model;         // Model matrix\nuniform mat4   u_view;          // View matrix\nuniform mat4   u_projection;    // Projection matrix\nattribute vec3 a_position;      // Vertex position\nattribute vec2 a_texcoord;      // Vertex texture coordinates\nvarying vec2   v_texcoord;      // Interpolated fragment texture coordinates (out)\n\nvoid main()\n{\n    // Assign varying variables\n    v_texcoord  = a_texcoord;\n\n    // Final position\n    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);\n}\n""""""\n\nfragment = """"""\nuniform sampler2D u_texture;  // Texture \nvarying vec2      v_texcoord; // Interpolated fragment texture coordinates (in)\nvoid main()\n{\n    // Get texture color\n    vec4 t_color = texture2D(u_texture, v_texcoord);\n\n    // Final color\n    gl_FragColor = t_color;\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, duration\n\n    window.clear()\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    cube.draw(gl.GL_TRIANGLES, indices)\n\n    # Rotate cube\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'u_model\'] = model\n\n@window.event\ndef on_resize(width, height):\n    cube[\'u_projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n\n\nvertices, indices = cube()\ncube = gloo.Program(vertex, fragment)\ncube.bind(vertices)\ncube[\'u_texture\'] = data.get(""crate.png"")\ncube[\'u_model\'] = np.eye(4, dtype=np.float32)\ncube[\'u_view\'] = glm.translation(0, 0, -5)\nphi, theta = 40, 30\n\napp.run()\n'"
examples/tutorial/texture-cube.py,17,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gl, glm, gloo\n\ndef cube():\n    vtype = [(\'a_position\', np.float32, 3), (\'a_texcoord\', np.float32, 2),\n             (\'a_normal\',   np.float32, 3), (\'a_color\',    np.float32, 4)]\n    itype = np.uint32\n\n    # Vertices positions\n    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],\n                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]], dtype=float)\n    # Face Normals\n    n = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0],\n                  [-1, 0, 1], [0, -1, 0], [0, 0, -1]])\n    # Vertice colors\n    c = np.array([[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 0, 1],\n                  [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1]])\n    # Texture coords\n    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])\n\n    faces_p = [0, 1, 2, 3,  0, 3, 4, 5,   0, 5, 6, 1,\n               1, 6, 7, 2,  7, 4, 3, 2,   4, 7, 6, 5]\n    faces_c = [0, 1, 2, 3,  0, 3, 4, 5,   0, 5, 6, 1,\n               1, 6, 7, 2,  7, 4, 3, 2,   4, 7, 6, 5]\n    faces_n = [0, 0, 0, 0,  1, 1, 1, 1,   2, 2, 2, 2,\n               3, 3, 3, 3,  4, 4, 4, 4,   5, 5, 5, 5]\n    faces_t = [0, 1, 2, 3,  0, 1, 2, 3,   0, 1, 2, 3,\n               3, 2, 1, 0,  0, 1, 2, 3,   0, 1, 2, 3]\n\n    vertices = np.zeros(24, vtype)\n    vertices[\'a_position\'] = p[faces_p]\n    vertices[\'a_normal\']   = n[faces_n]\n    vertices[\'a_color\']    = c[faces_c]\n    vertices[\'a_texcoord\'] = t[faces_t]\n\n    filled = np.resize(\n       np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))\n    filled += np.repeat(4 * np.arange(6, dtype=itype), 6)\n\n    outline = np.resize(\n        np.array([0, 1, 1, 2, 2, 3, 3, 0], dtype=itype), 6 * (2 * 4))\n    outline += np.repeat(4 * np.arange(6, dtype=itype), 8)\n\n    vertices = vertices.view(gloo.VertexBuffer)\n    filled   = filled.view(gloo.IndexBuffer)\n    outline  = outline.view(gloo.IndexBuffer)\n\n    return vertices, filled, outline\n\n\ndef checkerboard(grid_num=8, grid_size=32):\n    """""" Checkerboard pattern """"""\n    \n    row_even = grid_num // 2 * [0, 1]\n    row_odd = grid_num // 2 * [1, 0]\n    Z = np.row_stack(grid_num // 2 * (row_even, row_odd)).astype(np.uint8)\n    return 255 * Z.repeat(grid_size, axis=0).repeat(grid_size, axis=1)\n\n\nvertex = """"""\nuniform mat4   u_model;         // Model matrix\nuniform mat4   u_view;          // View matrix\nuniform mat4   u_projection;    // Projection matrix\nattribute vec4 a_color;         // Vertex color\nattribute vec3 a_position;      // Vertex position\nattribute vec2 a_texcoord;      // Vertex texture coordinates\nvarying vec4   v_color;         // Interpolated fragment color (out)\nvarying vec2   v_texcoord;      // Interpolated fragment texture coordinates (out)\n\nvoid main()\n{\n    // Assign varying variables\n    v_color     = a_color;      \n    v_texcoord  = a_texcoord;\n\n    // Final position\n    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);\n}\n""""""\n\nfragment = """"""\nuniform vec4      u_color;    // Global color\nuniform sampler2D u_texture;  // Texture \nvarying vec4      v_color;    // Interpolated fragment color (in)\nvarying vec2      v_texcoord; // Interpolated fragment texture coordinates (in)\nvoid main()\n{\n    // Get texture color\n    vec4 t_color = vec4(vec3(texture2D(u_texture, v_texcoord).r), 1.0);\n\n    // Final color\n    gl_FragColor = u_color * t_color * mix(v_color, t_color, 0.25);\n}\n""""""\n\nwindow = app.Window(width=1024, height=1024,\n                    color=(0.30, 0.30, 0.35, 1.00))\n\n@window.event\ndef on_draw(dt):\n    global phi, theta, duration\n\n    window.clear()\n\n    # Filled cube\n    gl.glDisable(gl.GL_BLEND)\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    cube[\'u_color\'] = 1, 1, 1, 1\n    cube.draw(gl.GL_TRIANGLES, I)\n\n    # Outlined cube\n    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)\n    gl.glEnable(gl.GL_BLEND)\n    gl.glDepthMask(gl.GL_FALSE)\n    cube[\'u_color\'] = 0, 0, 0, 1\n    cube.draw(gl.GL_LINES, O)\n    gl.glDepthMask(gl.GL_TRUE)\n\n    # Rotate cube\n    theta += 0.5 # degrees\n    phi += 0.5 # degrees\n    model = np.eye(4, dtype=np.float32)\n    glm.rotate(model, theta, 0, 0, 1)\n    glm.rotate(model, phi, 0, 1, 0)\n    cube[\'u_model\'] = model\n\n@window.event\ndef on_resize(width, height):\n    cube[\'u_projection\'] = glm.perspective(45.0, width / float(height), 2.0, 100.0)\n\n@window.event\ndef on_init():\n    gl.glEnable(gl.GL_DEPTH_TEST)\n    gl.glPolygonOffset(1, 1)\n    gl.glEnable(gl.GL_LINE_SMOOTH)\n\n\nV,I,O = cube()\ncube = gloo.Program(vertex, fragment)\ncube.bind(V)\n\ncube[\'u_texture\'] = checkerboard()\ncube[\'u_model\'] = np.eye(4, dtype=np.float32)\ncube[\'u_view\'] = glm.translation(0, 0, -5)\nphi, theta = 40, 30\n\napp.run()\n'"
examples/tutorial/viewport-aspect.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gloo, gl\n\nvertex = """"""\n  uniform float scale;\n  attribute vec2 position;\n  attribute vec4 color;\n  varying vec4 v_color;\n  void main()\n  {\n    gl_Position = vec4(scale*position, 0.0, 1.0);\n    v_color = color;\n  } """"""\n\nfragment = """"""\n  varying vec4 v_color;\n  void main()\n  {\n      gl_FragColor = v_color;\n  } """"""\n\n# Build the program and corresponding buffers (with 4 vertices)\nquad = gloo.Program(vertex, fragment, count=4)\n\n# Upload data into GPU\nquad[\'color\'] = [ (1,0,0,1), (0,1,0,1), (0,0,1,1), (1,1,0,1) ]\nquad[\'position\'] = [ (-1,-1),   (-1,+1),   (+1,-1),   (+1,+1)   ]\nquad[\'scale\'] = 1.0\n\n# Create a window with a valid GL context\nwindow = app.Window()\n\n# Tell glumpy what needs to be done at each redraw\n@window.event\ndef on_draw(dt):\n    window.clear()\n    quad.draw(gl.GL_TRIANGLE_STRIP)\n\n@window.event\ndef on_resize(width,height):\n    if width > height:\n        x = (width-height)/2\n        y = 0\n        w = h = height\n    else:\n        x = 0\n        y = (height-width)/2\n        w = h = width\n    gl.glViewport(int(x), int(y), int(w), int(h))\n    window.dispatch_event(\'on_draw\', 0.0)\n    window.swap()\n    return True\n\n# Run the app\napp.run()\n'"
glumpy/api/__init__.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . import matplotlib\n'
glumpy/app/__init__.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n""""""\nimport os\nimport re\nimport sys\nimport logging\nimport importlib\nimport numpy as np\n\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.ext.inputhook import inputhook_manager, stdin_ready\nfrom glumpy.app.window import backends\n\nfrom . import parser\nfrom . import configuration\nfrom . import clock as _clock\nfrom . clock import Clock\nfrom . console import Console\nfrom . viewport import Viewport\nfrom . window import EventDispatcher\n\n# Default clock\n__clock__ = None\n\n# Active windows\n__windows__ = []\n\n# Current backend\n__backend__ = None\n\n\n__running__ = False\n\n\n# --------------------------------------------------------------------- fps ---\ndef fps():\n    """"""\n    Get FPS from the default clock.\n    """"""\n    return __clock__.get_fps()\n\n\n# --------------------------------------------------------------------- use ---\ndef use(backend, api=None, major=None, minor=None, profile=None):\n    """""" Select a specific backend\n\n    Parameters\n    ----------\n\n    backend : [\'osxglut\', \'freeglut\', \'pyglet\', \'glfw\', \'sdl\', \'sdl2\', \'pyside\']\n        Graphical toolkit to use\n\n    api : [\'GL\'|\'ES\']\n        OpenGL API to use\n\n    major : int\n        OpenGL major version to use\n\n    minor : int\n        OpenGL minor version to use\n\n    profile : [\'compatibility\'|\'core\']\n        OpenGL profile to use\n\n    Note\n    ----\n    A shortened version is available with the following syntax:\n\n    use(""backend (api major.minor profile)"")\n\n    For example, `use(""glfw (GL 3.3 core)"")`\n    """"""\n\n    global __backend__\n    \n    config = configuration.get_default()\n\n    # Parse options (in backend name, see note above)\n    exp = """"""(?P<backend>\\w+)?\n             (.*\\(\n             (.*(?P<api>GL|ES))?\n             (.*(?P<major>[1234])\\.(?P<minor>[012345]))?\n             (.*(?P<profile>compatibility|core))?.*\\))?""""""\n    r = re.search(exp, backend, re.IGNORECASE | re.VERBOSE)\n    _backend = r.group(\'backend\') or ""glfw""\n    _api     = r.group(\'api\') or ""GL""\n    _major   = int(r.group(\'major\') or str(config.major_version))\n    _minor   = int(r.group(\'minor\') or str(config.minor_version))\n    _profile = r.group(\'profile\') or """"\n\n    # Arguments take precedence over shortened options\n    backend = _backend\n    api     = api or _api\n    major   = major or _major\n    minor   = minor or _minor\n    profile = profile or _profile\n\n    config.api = api\n    config.major_version = major\n    config.minor_version = minor\n    config.profile = profile\n\n    if backend not in backends.__backends__:\n        log.critical(""Unknown backend (%s)"" % backend)\n        log.critical(""Available backends are: %s"", str(backends.__backends__))\n        sys.exit(0)\n\n    # BUG: For some reason, the import module changes the working directory\n    #      We save it beforehand and restore it just after\n    workdir = os.getcwd()\n    name = ""glumpy.app.window.backends.backend_"" + backend\n    importlib.import_module(name)\n    backend = sys.modules[name]\n    os.chdir(workdir)\n\n    # Check availability\n    if backend.available():\n        __backend__ = backend\n        return backend\n    else:\n        log.warning(""Backend (%s) not available"" % backend)\n        return None\n\n\n# ----------------------------------------------------------------- Window ---\nclass Window(object):\n    """"""\n    Abstract Window\n\n    This class is responsible for finding a suitable backend and parsing\n    arguments.\n    """"""\n\n    def __new__(cls, *args, **kwargs):\n        global __backend__\n\n        all = list(backends.__backends__)\n        options = parser.get_options()\n\n        # No backend was specified\n        # Check for command line argument then pick a default one if possible\n        if __backend__ is None:\n            if options.backend != all[0]:\n                all = [options.backend,] + all\n            for name in all:\n                backend = use(name)\n                if backend and backend.available():\n                    __backend__ = backend\n                    break\n            # No backend available, there\'s nothing we can do\n            if __backend__ is None:\n                log.critical(""No suitable backend found"")\n                raise NotImplementedError\n\n        config = configuration.get_default()\n        if ""config"" not in kwargs.keys():\n            kwargs[\'config\'] = config\n\n        if \'vsync\' not in kwargs.keys():\n            kwargs[\'vsync\'] = options.vsync\n\n        # Get command line size\n        # if options.size:\n        #     size = options.size.split("","")\n        #     kwargs[\'width\'] = int(size[0])\n        #     kwargs[\'height\'] = int(size[1])\n        # else:\n        #     kwargs[\'width\']  = kwargs.get(\'width\', 512)\n        #     kwargs[\'height\'] = kwargs.get(\'height\', 512)\n\n        # Get command line position\n        # if options.position:\n        #     position = options.position.split("","")\n        #     #kwargs[\'x\'] = kwargs.get(\'x\', int(position[0]))\n        #     #kwargs[\'y\'] = kwargs.get(\'y\', int(position[1]))\n        # else:\n        #     pass\n        #     #kwargs[\'x\'] = kwargs.get(\'x\', 0)\n        #     #kwargs[\'y\'] = kwargs.get(\'y\', 0)\n\n\n        # Create the backend window\n        window = __backend__.Window(*args, **kwargs)\n        window._backend = __backend__\n        window._config = config\n\n        log.info(""Using %s (%s %d.%d)"" %\n                 (__backend__.name(), config.api,\n                  config.major_version, config.minor_version))\n\n        if config.samples > 0:\n            log.info(""Using multisampling with %d samples"" %\n                     (config.samples))\n\n        # Display fps options\n        if options.display_fps:\n            @window.timer(1.0)\n            def timer(elapsed):\n                print(""Estimated FPS: %f""% fps())\n\n        return window\n\n\n\n# --------------------------------------------------------------- __init__ ---\ndef __init__(clock=None, framerate=None, backend=None):\n    """""" Initialize the main loop\n\n    Parameters\n    ----------\n    clock : Clock\n        clock to use to run the app (gives the elementary tick)\n\n    framerate : int\n        frames per second\n\n    backend : python module\n        Backend module\n    """"""\n\n    global __clock__\n\n    options = parser.get_options()\n\n    if options.debug:\n        log.setLevel(logging.DEBUG)\n\n    if framerate is None:\n        framerate = options.framerate\n    if framerate > 0:\n        log.info(""Running at %d frames/second"" % framerate)\n    else:\n        log.info(""Running at full speed"")\n\n\n    if clock is None:\n        __clock__ = _clock.get_default()\n    else:\n        __clock__ = clock\n    __clock__.set_fps_limit(framerate)\n\n    # OpenGL Initialization\n    for window in backend.windows():\n        window.activate()\n        gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 1)\n        gl.glPixelStorei(gl.GL_PACK_ALIGNMENT, 1)\n        gl.glEnable(gl.GL_VERTEX_PROGRAM_POINT_SIZE)\n        try: # This has been removed in 3.2 (it\'s now on by default)\n            gl.glEnable(gl.GL_POINT_SPRITE)\n        except:\n            pass\n        gl.glEnable(gl.GL_BLEND)\n        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n\n\n    # Initialize timers for all windows\n    for window in backend.windows():\n        window._clock = __clock__\n\n        # Start timers\n        for i in range(len(window._timer_stack)):\n            handler, interval = window._timer_stack[i]\n            __clock__.schedule_interval(handler, interval)\n\n        # Activate window\n        window.activate()\n\n        # Dispatch init event\n        window.dispatch_event(\'on_init\')\n\n        # Dispatch an initial resize event\n        window.dispatch_event(\'on_resize\', window._width, window._height)\n\n    return __clock__\n\n\n\n# -------------------------------------------------------------------- quit ---\ndef quit():\n    global __running__\n\n    __running__ = False\n    # count = len(__backend__.windows())\n    # while count:\n    #     dt = clock.tick()\n    #     window = __backend__.windows()[-1]\n    #     window.close()\n    #     count = __backend__.process(dt)\n\n\n# --------------------------------------------------------------------- run ---\ndef run(clock=None, framerate=None, interactive=None,\n        duration = sys.maxsize, framecount = sys.maxsize):\n    """""" Run the main loop\n\n    Parameters\n    ----------\n    clock : Clock\n        clock to use to run the app (gives the elementary tick)\n\n    framerate : int\n        frames per second\n\n    duration : float\n        Duration after which the app will be stopped\n\n    framecount : int\n        Number of frame to display before stopping.\n    """"""\n    global __running__\n\n    clock = __init__(clock=clock, framerate=framerate, backend=__backend__)\n    options = parser.get_options()\n\n    if interactive is None:\n        interactive = options.interactive\n\n    if interactive:\n        # Set interactive python session\n        os.environ[\'PYTHONINSPECT\'] = \'1\'\n        import readline\n        readline.parse_and_bind(""tab: complete"")\n\n        def run():\n            while not stdin_ready():\n                __backend__.process(clock.tick())\n            return 0\n        inputhook_manager.set_inputhook(run)\n\n    else:\n        __running__ = True\n\n        def run(duration, framecount):\n            count = len(__backend__.windows())\n            while count and duration > 0 and framecount > 0 and __running__:\n                dt = clock.tick()\n                duration -= dt\n                framecount -= 1\n                count = __backend__.process(dt)\n\n        if options.record:\n            from .movie import record\n            try:\n                # Check if output file name given\n                name = sys.argv[2]\n            except:\n                # Obtain the name of the script that is being run\n                name = os.path.basename(sys.argv[0])\n            # Replace .py extension with .mp4\n            filename=re.sub(\'.py$\', \'.mp4\', name)\n            log.info(""Recording movie in \'%s\'"" % filename)\n            with record(window=__backend__.windows()[0],\n                        filename=filename,\n                        fps=60):\n                run(duration, framecount)\n        else:\n            run(duration, framecount)\n'"
glumpy/app/clock.py,0,"b'# ----------------------------------------------------------------------------\n# pyglet\n# Copyright (c) 2006-2008 Alex Holkner\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n#  * Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in\n#    the documentation and/or other materials provided with the\n#    distribution.\n#  * Neither the name of pyglet nor the names of its\n#    contributors may be used to endorse or promote products\n#    derived from this software without specific prior written\n#    permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n# ----------------------------------------------------------------------------\n\n\'\'\'Precise framerate calculation, scheduling and framerate limiting.\n\nMeasuring time\n==============\n\nThe `tick` and `get_fps` functions can be used in conjunction to fulfil most\ngames\' basic requirements::\n\n    from glumpy.app import clock\n    while True:\n        dt = clock.tick()\n        # ... update and render ...\n        print \'FPS is %f\' % clock.get_fps()\n\nThe ``dt`` value returned gives the number of seconds (as a float) since the\nlast ""tick"".\n\nThe `get_fps` function averages the framerate over a sliding window of\napproximately 1 second.  (You can calculate the instantaneous framerate by\ntaking the reciprocal of ``dt``).\n\nAlways remember to `tick` the clock!\n\nLimiting frame-rate\n===================\n\nThe framerate can be limited::\n\n    clock.set_fps_limit(60)\n\nThis causes `clock` to sleep during each `tick` in an attempt to keep the\nnumber of ticks (frames) per second below 60.\n\nThe implementation uses platform-dependent high-resolution sleep functions to\nachieve better accuracy with busy-waiting than would not be possible using just\nthe `time` module.\n\nScheduling\n==========\n\nYou can schedule a function to be called every time the clock is ticked::\n\n    def callback(dt):\n        print \'%f seconds since last callback\' % dt\n\n    clock.schedule(callback)\n\nThe `schedule_interval` method causes a function to be called every ""n""\nseconds::\n\n    clock.schedule_interval(callback, .5)   # called twice a second\n\nThe `schedule_once` method causes a function to be called once ""n"" seconds\nin the future::\n\n    clock.schedule_once(callback, 5)        # called in 5 seconds\n\nAll of the `schedule` methods will pass on any additional args or keyword args\nyou specify to the callback function::\n\n    def animate(dt, velocity, sprite):\n       sprite.position += dt * velocity\n\n    clock.schedule(animate, velocity=5.0, sprite=alien)\n\nYou can cancel a function scheduled with any of these methods using\n`unschedule`::\n\n    clock.unschedule(animate)\n\nDisplaying FPS\n==============\n\nThe ClockDisplay class provides a simple FPS counter.  You should create\nan instance of ClockDisplay once during the application\'s start up::\n\n    fps_display = clock.ClockDisplay()\n\nCall draw on the ClockDisplay object for each frame::\n\n    fps_display.draw()\n\nThere are several options to change the font, color and text displayed\nwithin the __init__ method.\n\nUsing multiple clocks\n=====================\n\nThe clock functions are all relayed to an instance of `Clock` which is\ninitialised with the module.  You can get this instance to use directly::\n\n    clk = clock.get_default()\n\nYou can also replace the default clock with your own:\n\n    myclk = clock.Clock()\n    clock.set_default(myclk)\n\nEach clock maintains its own set of scheduled functions and FPS\nlimiting/measurement.  Each clock must be ""ticked"" separately.\n\nMultiple and derived clocks potentially allow you to separate ""game-time"" and\n""wall-time"", or to synchronise your clock to an audio or video stream instead\nof the system clock.\n\n\'\'\'\n\n__docformat__ = \'restructuredtext\'\n__version__ = \'$Id$\'\n\nimport time\nimport sys\nimport ctypes, ctypes.util\n\nif sys.platform in (\'win32\', \'cygwin\'):\n    # Win32 Sleep function is only 10-millisecond resolution, so instead\n    # use a waitable timer object, which has up to 100-nanosecond resolution\n    # (hardware and implementation dependent, of course).\n    _kernel32 = ctypes.windll.kernel32\n    class _ClockBase(object):\n        def __init__(self):\n            self._timer = _kernel32.CreateWaitableTimerA(None, True, None)\n\n        def sleep(self, microseconds):\n            delay = ctypes.c_longlong(int(-microseconds * 10))\n            _kernel32.SetWaitableTimer(self._timer, ctypes.byref(delay),\n                0, ctypes.c_void_p(), ctypes.c_void_p(), False)\n            _kernel32.WaitForSingleObject(self._timer, 0xffffffff)\n\n    if sys.version_info < (3, 8):\n        _default_time_function = time.clock\n    else:\n        _default_time_function = time.perf_counter\n\nelse:\n    _c_file = ctypes.util.find_library(\'c\')\n    _c = ctypes.CDLL(_c_file)\n    _c.usleep.argtypes = [ctypes.c_ulong]\n    class _ClockBase(object):\n        def sleep(self, microseconds):\n            _c.usleep(int(microseconds))\n\n    _default_time_function = time.time\n\nclass _ScheduledItem(object):\n    __slots__ = [\'func\', \'args\', \'kwargs\']\n    def __init__(self, func, args, kwargs):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n\nclass _ScheduledIntervalItem(object):\n    __slots__ = [\'func\', \'interval\', \'last_ts\', \'next_ts\',\n                 \'args\', \'kwargs\']\n    def __init__(self, func, interval, last_ts, next_ts, args, kwargs):\n        self.func = func\n        self.interval = interval\n        self.last_ts = last_ts\n        self.next_ts = next_ts\n        self.args = args\n        self.kwargs = kwargs\n\ndef _dummy_schedule_func(*args, **kwargs):\n    \'\'\'Dummy function that does nothing, placed onto zombie scheduled items\n    to ensure they have no side effect if already queued inside tick() method.\n    \'\'\'\n    pass\n\nclass Clock(_ClockBase):\n    \'\'\'Class for calculating and limiting framerate, and for calling scheduled\n    functions.\n    \'\'\'\n\n    #: The minimum amount of time in seconds this clock will attempt to sleep\n    #: for when framerate limiting.  Higher values will increase the\n    #: accuracy of the limiting but also increase CPU usage while\n    #: busy-waiting.  Lower values mean the process sleeps more often, but is\n    #: prone to over-sleep and run at a potentially lower or uneven framerate\n    #: than desired.\n    MIN_SLEEP = 0.005\n\n    #: The amount of time in seconds this clock subtracts from sleep values\n    #: to compensate for lazy operating systems.\n    SLEEP_UNDERSHOOT = MIN_SLEEP - 0.001\n\n    # List of functions to call every tick.\n    _schedule_items = None\n\n    # List of schedule interval items kept in sort order.\n    _schedule_interval_items = None\n\n    # If True, a sleep(0) is inserted on every tick.\n    _force_sleep = False\n\n    def __init__(self, fps_limit=None, time_function=_default_time_function):\n        \'\'\'Initialise a Clock, with optional framerate limit and custom\n        time function.\n\n        :Parameters:\n            `fps_limit` : float\n                If not None, the maximum allowable framerate.  Defaults\n                to None. \n            `time_function` : function\n                Function to return the elapsed time of the application,\n                in seconds.  Defaults to time.time, but can be replaced\n                to allow for easy time dilation effects or game pausing.\n\n        \'\'\'\n\n        super(Clock, self).__init__()\n        self.time = time_function\n        self.next_ts = self.time()\n        self.last_ts = None\n        self.times = []\n\n        self.set_fps_limit(fps_limit)\n        self.cumulative_time = 0\n\n        self._schedule_items = []\n        self._schedule_interval_items = []\n\n    def update_time(self):\n        \'\'\'Get the elapsed time since the last call to `update_time`.\n\n        This updates the clock\'s internal measure of time and returns\n        the difference since the last update (or since the clock was created).\n\n        :rtype: float\n        :return: The number of seconds since the last `update_time`, or 0\n            if this was the first time it was called.\n        \'\'\'\n        ts = self.time()\n        if self.last_ts is None:\n            delta_t = 0\n        else:\n            delta_t = ts - self.last_ts\n            self.times.insert(0, delta_t)\n            if len(self.times) > self.window_size:\n                self.cumulative_time -= self.times.pop()\n        self.cumulative_time += delta_t\n        self.last_ts = ts\n\n        return delta_t\n\n    def call_scheduled_functions(self, dt):\n        \'\'\'Call scheduled functions that elapsed on the last `update_time`.\n\n        :Parameters:\n            dt : float\n                The elapsed time since the last update to pass to each\n                scheduled function.  This is *not* used to calculate which\n                functions have elapsed.\n\n        :rtype: bool\n        :return: True if any functions were called, otherwise False.\n        \'\'\'\n        ts = self.last_ts\n        result = False\n\n        # Call functions scheduled for every frame\n        # Dupe list just in case one of the items unchedules itself\n        for item in list(self._schedule_items):\n            result = True\n            item.func(dt, *item.args, **item.kwargs)\n\n        # Call all scheduled interval functions and reschedule for future.\n        need_resort = False\n        # Dupe list just in case one of the items unchedules itself\n        for item in list(self._schedule_interval_items):\n            if item.next_ts > ts:\n                break\n            result = True\n            item.func(ts - item.last_ts, *item.args, **item.kwargs)\n            if item.interval:\n                # Try to keep timing regular, even if overslept this time;\n                # but don\'t schedule in the past (which could lead to\n                # infinitely-worsing error).\n                item.next_ts = item.last_ts + item.interval\n                item.last_ts = ts\n                if item.next_ts <= ts:\n                    if ts - item.next_ts < 0.05:\n                        # Only missed by a little bit, keep the same schedule\n                        item.next_ts = ts + item.interval\n                    else:\n                        # Missed by heaps, do a soft reschedule to avoid\n                        # lumping everything together.\n                        item.next_ts = self._get_soft_next_ts(ts, item.interval)\n                        # Fake last_ts to avoid repeatedly over-scheduling in\n                        # future.  Unfortunately means the next reported dt is\n                        # incorrect (looks like interval but actually isn\'t).\n                        item.last_ts = item.next_ts - item.interval\n                need_resort = True\n            else:\n                item.next_ts = None\n\n        # Remove finished one-shots.\n        self._schedule_interval_items = \\\n            [item for item in self._schedule_interval_items \\\n             if item.next_ts is not None]\n\n        if need_resort:\n            # TODO bubble up changed items might be faster\n            self._schedule_interval_items.sort(key=lambda a: a.next_ts)\n\n        return result\n\n    def tick(self, poll=False):\n        \'\'\'Signify that one frame has passed.\n\n        This will call any scheduled functions that have elapsed.\n\n        :Parameters:\n            `poll` : bool\n                If True, the function will call any scheduled functions\n                but will not sleep or busy-wait for any reason.  Recommended\n                for advanced applications managing their own sleep timers\n                only.\n\n        :rtype: float\n        :return: The number of seconds since the last ""tick"", or 0 if this was\n            the first frame.\n        \'\'\'\n        if poll:\n            if self.period_limit:\n                self.next_ts = self.next_ts + self.period_limit\n        else:\n            if self.period_limit:\n                self._limit()\n\n            if self._force_sleep:\n                self.sleep(0)\n\n        delta_t = self.update_time()\n        self.call_scheduled_functions(delta_t)\n        return delta_t\n\n    def _limit(self):\n        \'\'\'Sleep until the next frame is due.  Called automatically by\n        `tick` if a framerate limit has been set.\n\n        This method uses several heuristics to determine whether to\n        sleep or busy-wait (or both).\n        \'\'\'\n        ts = self.time()\n        # Sleep to just before the desired time\n        sleeptime = self.get_sleep_time(False)\n        while sleeptime - self.SLEEP_UNDERSHOOT > self.MIN_SLEEP:\n            self.sleep(1000000 * (sleeptime - self.SLEEP_UNDERSHOOT))\n            sleeptime = self.get_sleep_time(False)\n\n        # Busy-loop CPU to get closest to the mark\n        sleeptime = self.next_ts - self.time()\n        while sleeptime > 0:\n            sleeptime = self.next_ts - self.time()\n\n        if sleeptime < -2 * self.period_limit:\n            # Missed the time by a long shot, let\'s reset the clock\n            # print >> sys.stderr, \'Step %f\' % -sleeptime\n            self.next_ts = ts + 2 * self.period_limit\n        else:\n            # Otherwise keep the clock steady\n            self.next_ts = self.next_ts + self.period_limit\n\n    def get_sleep_time(self, sleep_idle):\n        \'\'\'Get the time until the next item is scheduled.\n\n        This method considers all scheduled items and the current\n        ``fps_limit``, if any.\n\n        Applications can choose to continue receiving updates at the\n        maximum framerate during idle time (when no functions are scheduled),\n        or they can sleep through their idle time and allow the CPU to\n        switch to other processes or run in low-power mode.\n\n        If `sleep_idle` is ``True`` the latter behaviour is selected, and\n        ``None`` will be returned if there are no scheduled items.\n\n        Otherwise, if `sleep_idle` is ``False``, a sleep time allowing\n        the maximum possible framerate (considering ``fps_limit``) will\n        be returned; or an earlier time if a scheduled function is ready.\n\n        :Parameters:\n            `sleep_idle` : bool\n                If True, the application intends to sleep through its idle\n                time; otherwise it will continue ticking at the maximum\n                frame rate allowed.\n\n        :rtype: float\n        :return: Time until the next scheduled event in seconds, or ``None``\n            if there is no event scheduled.\n\n        \'\'\'\n        if self._schedule_items or not sleep_idle:\n            if not self.period_limit:\n                return 0.\n            else:\n                wake_time = self.next_ts\n                if self._schedule_interval_items:\n                    wake_time = min(wake_time,\n                                    self._schedule_interval_items[0].next_ts)\n                return max(wake_time - self.time(), 0.)\n\n        if self._schedule_interval_items:\n            return max(self._schedule_interval_items[0].next_ts - self.time(),\n                       0)\n\n        return None\n\n    def set_fps_limit(self, fps_limit):\n        \'\'\'Set the framerate limit.\n\n        The framerate limit applies only when a function is scheduled\n        for every frame.  That is, the framerate limit can be exceeded by\n        scheduling a function for a very small period of time.\n\n        :Parameters:\n            `fps_limit` : float\n                Maximum frames per second allowed, or None to disable\n                limiting.\n        \'\'\'\n        if not fps_limit:\n            self.period_limit = None\n        else:\n            self.period_limit = 1. / fps_limit\n        self.window_size = fps_limit or 60\n\n    def get_fps_limit(self):\n        \'\'\'Get the framerate limit.\n\n        :rtype: float\n        :return: The framerate limit previously set in the constructor or\n            `set_fps_limit`, or None if no limit was set.\n        \'\'\'\n        if self.period_limit:\n            return 1. / self.period_limit\n        else:\n            return 0\n\n    def get_fps(self):\n        \'\'\'Get the average FPS of recent history.\n\n        The result is the average of a sliding window of the last ""n"" frames,\n        where ""n"" is some number designed to cover approximately 1 second.\n\n        :rtype: float\n        :return: The measured frames per second.\n        \'\'\'\n        if not self.cumulative_time:\n            return 0\n        return len(self.times) / self.cumulative_time\n\n    def schedule(self, func, *args, **kwargs):\n        \'\'\'Schedule a function to be called every frame.\n\n        The function should have a prototype that includes ``dt`` as the\n        first argument, which gives the elapsed time, in seconds, since the\n        last clock tick.  Any additional arguments given to this function\n        are passed on to the callback::\n\n            def callback(dt, *args, **kwargs):\n                pass\n\n        :Parameters:\n            `func` : function\n                The function to call each frame.\n        \'\'\'\n        item = _ScheduledItem(func, args, kwargs)\n        self._schedule_items.append(item)\n\n    def _schedule_item(self, func, last_ts, next_ts, interval, *args, **kwargs):\n        item = _ScheduledIntervalItem(\n            func, interval, last_ts, next_ts, args, kwargs)\n\n        # Insert in sort order\n        for i, other in enumerate(self._schedule_interval_items):\n            if other.next_ts is not None and other.next_ts > next_ts:\n                self._schedule_interval_items.insert(i, item)\n                break\n        else:\n            self._schedule_interval_items.append(item)\n\n    def schedule_interval(self, func, interval, *args, **kwargs):\n        \'\'\'Schedule a function to be called every `interval` seconds.\n\n        Specifying an interval of 0 prevents the function from being\n        called again (see `schedule` to call a function as often as possible).\n\n        The callback function prototype is the same as for `schedule`.\n\n        :Parameters:\n            `func` : function\n                The function to call when the timer lapses.\n            `interval` : float\n                The number of seconds to wait between each call.\n\n        \'\'\'\n        last_ts = self.last_ts or self.next_ts\n\n        # Schedule from now, unless now is sufficiently close to last_ts, in\n        # which case use last_ts.  This clusters together scheduled items that\n        # probably want to be scheduled together.  The old (pre 1.1.1)\n        # behaviour was to always use self.last_ts, and not look at ts.  The\n        # new behaviour is needed because clock ticks can now be quite\n        # irregular, and span several seconds.\n        ts = self.time()\n        if ts - last_ts > 0.2:\n            last_ts = ts\n\n        next_ts = last_ts + interval\n        self._schedule_item(func, last_ts, next_ts, interval, *args, **kwargs)\n\n    def schedule_interval_soft(self, func, interval, *args, **kwargs):\n        \'\'\'\n        Schedule a function to be called every `interval` seconds,\n        beginning at a time that does not coincide with other scheduled\n        events.\n\n        This method is similar to `schedule_interval`, except that the\n        clock will move the interval out of phase with other scheduled\n        functions so as to distribute CPU more load evenly over time.\n\n        This is useful for functions that need to be called regularly, but not\n        relative to the initial start time.  Using the soft interval\n        scheduling, the load is more evenly distributed.\n\n        Soft interval scheduling can also be used as an easy way to schedule\n        graphics animations out of phase; for example, multiple flags\n        waving in the wind.\n\n        :Parameters:\n            `func` : function\n                The function to call when the timer lapses.\n            `interval` : float\n                The number of seconds to wait between each call.\n        \'\'\'\n        last_ts = self.last_ts or self.next_ts\n\n        # See schedule_interval\n        ts = self.time()\n        if ts - last_ts > 0.2:\n            last_ts = ts\n\n        next_ts = self._get_soft_next_ts(last_ts, interval)\n        last_ts = next_ts - interval\n        self._schedule_item(func, last_ts, next_ts, interval, *args, **kwargs)\n\n    def _get_soft_next_ts(self, last_ts, interval):\n        def taken(ts, e):\n            \'\'\'Return True if the given time has already got an item\n            scheduled nearby.\n            \'\'\'\n            for item in self._schedule_interval_items:\n                if item.next_ts is None:\n                    pass\n                elif abs(item.next_ts - ts) <= e:\n                    return True\n                elif item.next_ts > ts + e:\n                    return False\n            return False\n\n        # Binary division over interval:\n        #\n        # 0                          interval\n        # |--------------------------|\n        #   5  3   6   2   7  4  8   1          Order of search\n        #\n        # i.e., first scheduled at interval,\n        #       then at            interval/2\n        #       then at            interval/4\n        #       then at            interval*3/4\n        #       then at            ...\n        #\n        # Schedule is hopefully then evenly distributed for any interval,\n        # and any number of scheduled functions.\n\n        next_ts = last_ts + interval\n        if not taken(next_ts, interval / 4):\n            return next_ts\n\n        dt = interval\n        divs = 1\n        while True:\n            next_ts = last_ts\n            for _ in range(divs - 1):\n                next_ts += dt\n                if not taken(next_ts, dt / 4):\n                    return next_ts\n            dt /= 2\n            divs *= 2\n\n            # Avoid infinite loop in pathological case\n            if divs > 16:\n                return next_ts\n\n    def schedule_once(self, func, delay, *args, **kwargs):\n        \'\'\'Schedule a function to be called once after `delay` seconds.\n\n        The callback function prototype is the same as for `schedule`.\n\n        :Parameters:\n            `func` : function\n                The function to call when the timer lapses.\n            `delay` : float\n                The number of seconds to wait before the timer lapses.\n        \'\'\'\n        last_ts = self.last_ts or self.next_ts\n\n        # See schedule_interval\n        ts = self.time()\n        if ts - last_ts > 0.2:\n            last_ts = ts\n\n        next_ts = last_ts + delay\n        self._schedule_item(func, last_ts, next_ts, 0, *args, **kwargs)\n\n    def unschedule(self, func):\n        \'\'\'Remove a function from the schedule.\n\n        If the function appears in the schedule more than once, all occurrences\n        are removed.  If the function was not scheduled, no error is raised.\n\n        :Parameters:\n            `func` : function\n                The function to remove from the schedule.\n\n        \'\'\'\n        # First replace zombie items\' func with a dummy func that does\n        # nothing, in case the list has already been cloned inside tick().\n        # (Fixes issue 326).\n        for item in self._schedule_items:\n            if item.func == func:\n                item.func = _dummy_schedule_func\n\n        for item in self._schedule_interval_items:\n            if item.func == func:\n                item.func = _dummy_schedule_func\n\n        # Now remove matching items from both schedule lists.\n        self._schedule_items = \\\n            [item for item in self._schedule_items \\\n                  if item.func is not _dummy_schedule_func]\n\n        self._schedule_interval_items = \\\n            [item for item in self._schedule_interval_items \\\n                  if item.func is not _dummy_schedule_func]\n\n# Default clock.\n_default = Clock()\n\ndef set_default(default):\n    \'\'\'Set the default clock to use for all module-level functions.\n\n    By default an instance of `Clock` is used.\n\n    :Parameters:\n        `default` : `Clock`\n            The default clock to use.\n    \'\'\'\n    global _default\n    _default = default\n\ndef get_default():\n    \'\'\'Return the `Clock` instance that is used by all module-level\n    clock functions.\n\n    :rtype: `Clock`\n    :return: The default clock.\n    \'\'\'\n    return _default\n\ndef tick(poll=False):\n    \'\'\'Signify that one frame has passed on the default clock.\n\n    This will call any scheduled functions that have elapsed.\n\n    :Parameters:\n        `poll` : bool\n            If True, the function will call any scheduled functions\n            but will not sleep or busy-wait for any reason.  Recommended\n            for advanced applications managing their own sleep timers\n            only.\n\n    :rtype: float\n    :return: The number of seconds since the last ""tick"", or 0 if this was the\n        first frame.\n    \'\'\'\n\n    return _default.tick(poll)\n\ndef get_sleep_time(sleep_idle):\n    \'\'\'Get the time until the next item is scheduled on the default clock.\n\n    See `Clock.get_sleep_time` for details.\n\n    :Parameters:\n        `sleep_idle` : bool\n            If True, the application intends to sleep through its idle\n            time; otherwise it will continue ticking at the maximum\n            frame rate allowed.\n\n    :rtype: float\n    :return: Time until the next scheduled event in seconds, or ``None``\n        if there is no event scheduled.\n    \'\'\'\n    return _default.get_sleep_time(sleep_idle)\n\ndef get_fps():\n    \'\'\'Return the current measured FPS of the default clock.\n\n    :rtype: float\n    \'\'\'\n    return _default.get_fps()\n\ndef set_fps_limit(fps_limit):\n    \'\'\'Set the framerate limit for the default clock.\n\n    :Parameters:\n        `fps_limit` : float\n            Maximum frames per second allowed, or None to disable\n            limiting.\n    \'\'\'\n    _default.set_fps_limit(fps_limit)\n\ndef get_fps_limit():\n    \'\'\'Get the framerate limit for the default clock.\n\n    :return: The framerate limit previously set by `set_fps_limit`, or None if\n        no limit was set.\n\n    \'\'\'\n    return _default.get_fps_limit()\n\ndef schedule(func, *args, **kwargs):\n    \'\'\'Schedule \'func\' to be called every frame on the default clock.\n\n    The arguments passed to func are ``dt``, followed by any ``*args`` and\n    ``**kwargs`` given here.\n\n    :Parameters:\n        `func` : function\n            The function to call each frame.\n    \'\'\'\n    _default.schedule(func, *args, **kwargs)\n\ndef schedule_interval(func, interval, *args, **kwargs):\n    \'\'\'Schedule \'func\' to be called every \'interval\' seconds on the default\n    clock.\n\n    The arguments passed to \'func\' are \'dt\' (time since last function call),\n    followed by any ``*args`` and ``**kwargs`` given here.\n\n    :Parameters:\n        `func` : function\n            The function to call when the timer lapses.\n        `interval` : float\n            The number of seconds to wait between each call.\n\n    \'\'\'\n    _default.schedule_interval(func, interval, *args, **kwargs)\n\ndef schedule_interval_soft(func, interval, *args, **kwargs):\n    \'\'\'Schedule \'func\' to be called every \'interval\' seconds on the default\n    clock, beginning at a time that does not coincide with other scheduled\n    events.\n\n    The arguments passed to \'func\' are \'dt\' (time since last function call),\n    followed by any ``*args`` and ``**kwargs`` given here.\n\n    :see: `Clock.schedule_interval_soft`\n\n    :Parameters:\n        `func` : function\n            The function to call when the timer lapses.\n        `interval` : float\n            The number of seconds to wait between each call.\n\n    \'\'\'\n    _default.schedule_interval_soft(func, interval, *args, **kwargs)\n\ndef schedule_once(func, delay, *args, **kwargs):\n    \'\'\'Schedule \'func\' to be called once after \'delay\' seconds (can be\n    a float) on the default clock.  The arguments passed to \'func\' are\n    \'dt\' (time since last function call), followed by any ``*args`` and\n    ``**kwargs`` given here.\n\n    If no default clock is set, the func is queued and will be scheduled\n    on the default clock as soon as it is created.\n\n    :Parameters:\n        `func` : function\n            The function to call when the timer lapses.\n        `delay` : float\n            The number of seconds to wait before the timer lapses.\n\n    \'\'\'\n    _default.schedule_once(func, delay, *args, **kwargs)\n\ndef unschedule(func):\n    \'\'\'Remove \'func\' from the default clock\'s schedule.  No error\n    is raised if the func was never scheduled.\n\n    :Parameters:\n        `func` : function\n            The function to remove from the schedule.\n\n    \'\'\'\n    _default.unschedule(func)\n\n'"
glumpy/app/configuration.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nWhen a window is created, it can be given a specific GL configuration in\norder to specify specific GL settings. If no configuration, the default\nconfiguration as provided by the ``get_default`` method is used.\n\n**Usage example**:\n\n  .. code:: python\n\n     from glumpy import app\n\n     config = app.configuration.Configuration()\n     config.major_version = 3\n     config.minor_version = 2\n     config.profile = ""core""\n     window = app.Window(config=config)\n""""""\nfrom glumpy.log import log\nfrom glumpy import defaults\n\n# Default configuration\n__configuration__ = None\n\n\n\ndef get_default():\n    """"""\n    Return the default configuration.\n    """"""\n    global __configuration__\n\n    if __configuration__ is None:\n        __configuration__ = Configuration()\n\n    return __configuration__\n\n\n\nclass Configuration(object):\n    """"""\n    GL Configuration settings\n    """"""\n\n    def __init__(self):\n\n        self._red_size            = 8\n        self._green_size          = 8\n        self._blue_size           = 8\n        self._alpha_size          = 8\n\n        self._double_buffer       = defaults.double_buffer()\n        self._depth_size          = defaults.depth_size()\n        self._stencil_size        = defaults.stencil_size()\n        self._samples             = 0\n\n        self._stereo              = defaults.stereo()\n        self._srgb                = defaults.srgb()\n\n        self._api                 = defaults.gl_api()\n        self._major_version       = defaults.gl_major_version()\n        self._minor_version       = defaults.gl_minor_version()\n        self._profile             = defaults.gl_profile()\n\n\n    # ---------------------------------------------------------------- repr ---\n    def __repr__(self):\n        """"""\n        Configurarion printable description\n        """"""\n\n        s = """"\n        s += ""Color buffer size:     %d bit(s) (R:%d, G:%d, B:%d, A:%d)\\n"" % (\n            self._red_size + self._green_size + self._blue_size + self._alpha_size,\n            self._red_size,\n            self._green_size,\n            self._blue_size,\n            self._alpha_size)\n        s += ""Depth buffer size:     %d bit(s)\\n"" % (self._depth_size)\n        s += ""Stencil buffer size:   %d bit(s)\\n"" % (self._stencil_size)\n        s += ""Double buffered:       %d\\n"" % (self._double_buffer)\n        s += ""Stereo mode:           %d\\n"" % (self._stereo)\n        s += ""sRGB mode:             %d\\n"" % (self._srgb)\n        s += ""Anti-aliasing samples: %d\\n"" % (self._samples)\n        s += ""GL API:                %s\\n"" % (self._api)\n        s += ""GL Version:            %d.%d\\n"" % (self._major_version,\n                                                 self._minor_version)\n        s += ""GL Profile:            %s"" % (self._profile)\n        return s\n\n\n\n    # ------------------------------------------------------------ red size ---\n    @property\n    def red_size(self):\n        """"""\n        Minimum number of bits for the red channel of the color buffer.\n        """"""\n        return self._red_size\n\n    @red_size.setter\n    def red_size(self, value):\n        self._red_size = value\n\n\n    # ---------------------------------------------------------- green size ---\n    @property\n    def green_size(self):\n        """"""\n        Minimum number of bits for the blue channel of the color buffer.\n        """"""\n        return self._green_size\n\n    @green_size.setter\n    def green_size(self, value):\n        self._green_size = value\n\n    # ----------------------------------------------------------- blue size ---\n    @property\n    def blue_size(self):\n        """"""\n        Minimum number of bits for the green channel of the color buffer.\n        """"""\n        return self._blue_size\n\n    @blue_size.setter\n    def blue_size(self, value):\n        self._blue_size = value\n\n    # ---------------------------------------------------------- alpha size ---\n    @property\n    def alpha_size(self):\n        """"""\n        Minimum number of bits for the alpha channel of the color buffer.\n        """"""\n        return self._alpha_size\n\n    @alpha_size.setter\n    def alpha_size(self, value):\n        self._alpha_size = value\n\n    # ------------------------------------------------------- double buffer ---\n    @property\n    def double_buffer(self):\n        """"""\n        Whether to use single or double buffered rendering.\n        """"""\n        return self._double_buffer\n\n    @double_buffer.setter\n    def double_buffer(self, value):\n        self._double_buffer = value\n\n\n    # ---------------------------------------------------------- depth size ---\n    @property\n    def depth_size(self):\n        """"""\n        Minimum number of bits in the depth buffer.\n        """"""\n        return self._depth_size\n\n    @depth_size.setter\n    def depth_size(self, value):\n        self._depth_size = value\n\n    # -------------------------------------------------------- stencil size ---\n    @property\n    def stencil_size(self):\n        """"""\n        Minimum number of bits in the stencil buffer.\n        """"""\n        return self._stencil_size\n\n    @stencil_size.setter\n    def stencil_size(self, value):\n        self._stencil_size = value\n\n    # -------------------------------------------------------------- stereo ---\n    @property\n    def stereo(self):\n        """"""\n        Whether the output is stereo.\n        """"""\n        return self._stereo\n\n    @stereo.setter\n    def stereo(self, value):\n        self._stereo = value\n\n    # ------------------------------------------------------------- samples ---\n    @property\n    def samples(self):\n        """"""\n        Number of samples used around the current pixel for multisample\n        anti-aliasing\n        """"""\n        return self._samples\n\n    @samples.setter\n    def samples(self, value):\n        self._samples = value\n\n    # ----------------------------------------------------------------- api ---\n    @property\n    def api(self):\n        """"""\n        OpenGL API\n        """"""\n        return self._api\n\n    @api.setter\n    def api(self, value):\n        self._api = value\n\n    # ------------------------------------------------------- major version ---\n    @property\n    def major_version(self):\n        """"""\n        OpenGL context major version\n        """"""\n        return self._major_version\n\n    @major_version.setter\n    def major_version(self, value):\n        self._major_version = value\n\n    # ------------------------------------------------------- minor version ---\n    @property\n    def minor_version(self):\n        """"""\n        OpenGL context minor version\n        """"""\n        return self._minor_version\n\n    @minor_version.setter\n    def minor_version(self, value):\n        self._minor_version = value\n\n    # ------------------------------------------------------------- profile ---\n    @property\n    def profile(self):\n        """"""\n        OpenGL profile\n        """"""\n        return self._profile\n\n    @profile.setter\n    def profile(self, value):\n        self._profile = value\n\n    # ---------------------------------------------------------------- srgb ---\n    @property\n    def srgb(self):\n        """"""\n        Whether to user sRGB capable visuals.\n        """"""\n        return self._srgb\n\n    @srgb.setter\n    def srgb(self, value):\n        self._srgb = value\n\n\n# ---------------------------------------------------- gl_get_configuration ---\ndef gl_get_configuration():\n    """"""\n    Read gl configuration independently of backends.\n    """"""\n\n    import ctypes\n    import OpenGL.GL as gl\n\n    configuration =  Configuration()\n    try:\n        gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, 0)\n    except:\n        log.warn(""Cannot bind framebuffer"")\n\n    value = ctypes.c_int()\n\n    try:\n        gl.glGetFramebufferAttachmentParameteriv(\n            gl.GL_FRAMEBUFFER, gl.GL_FRONT_LEFT,\n            gl.GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE, value )\n        configuration._red_size = value.value\n    except:\n        log.warn(""Cannot read RED channel size from the framebuffer"")\n        configuration._red_size = 0\n\n    try:\n        gl.glGetFramebufferAttachmentParameteriv(\n            gl.GL_FRAMEBUFFER, gl.GL_FRONT_LEFT,\n            gl.GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE, value )\n        configuration._green_size = value.value\n    except:\n        log.warn(""Cannot read GREEN channel size from the framebuffer"")\n        configuration._green_size = 0\n\n    try:\n        gl.glGetFramebufferAttachmentParameteriv(\n            gl.GL_FRAMEBUFFER, gl.GL_FRONT_LEFT,\n            gl.GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE, value )\n        configuration._blue_size = value.value\n    except:\n        log.warn(""Cannot read BLUE channel size from the framebuffer"")\n        configuration._blue_size = 0\n\n    try:\n        gl.glGetFramebufferAttachmentParameteriv(\n            gl.GL_FRAMEBUFFER, gl.GL_FRONT_LEFT,\n            gl.GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, value )\n        configuration._alpha_size = value.value\n    except:\n        log.warn(""Cannot read ALPHA channel size from the framebuffer"")\n        configuration._alpha_size = 0\n\n    try:\n        gl.glGetFramebufferAttachmentParameteriv(\n            gl.GL_FRAMEBUFFER, gl.GL_DEPTH,\n            gl.GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE, value )\n        configuration._depth_size = value.value\n    except:\n        log.warn(""Cannot read DEPTH size from the framebuffer"")\n        configuration._depth_size = 0\n\n    try:\n        gl.glGetFramebufferAttachmentParameteriv(\n            gl.GL_FRAMEBUFFER, gl.GL_STENCIL,\n            gl.GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE, value )\n        configuration._stencil_size = value.value\n    except:\n        log.warn(""Cannot read STENCIL size from the framebuffer"")\n        configuration._stencil_size = 0\n\n    try:\n        gl.glGetFramebufferAttachmentParameteriv(\n            gl.GL_FRAMEBUFFER, gl.GL_FRONT_LEFT,\n            gl.GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, value )\n        if value.value == gl.GL_LINEAR:\n            configuration._srgb = False\n        elif value.value == gl.GL_SRGB:\n            configuration._srgb = True\n    except:\n        log.warn(""Cannot read sRGB value from the framebuffer"")\n        configuration._srgb = False\n\n\n    configuration._stereo        = gl.glGetInteger(gl.GL_STEREO)\n    configuration._double_buffer = gl.glGetInteger(gl.GL_DOUBLEBUFFER)\n    configuration._samples       = gl.glGetInteger(gl.GL_SAMPLES)\n\n    # Dumb parsing of the GL_VERSION string\n    version = gl.glGetString(gl.GL_VERSION).decode()\n    version = version.split("" "")[0]\n    major,minor = version.split(\'.\')[:2]\n    configuration._version = version\n    configuration._major_version = int(major)\n    configuration._minor_version = int(minor)\n    configuration._profile = ""unknown""\n\n    return configuration\n'"
glumpy/app/console.py,10,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" Fast and failsafe GL console """"""\nimport numpy as np\nfrom glumpy import gl, glm, gloo\n\n\n# Translated from\n# http://www.piclist.com/tecHREF/datafile/charset/extractor/charset_extractor.htm\n__font_6x8__ = np.array([\n    (0x00,0x00,0x00,0x00,0x00,0x00), (0x10,0xE3,0x84,0x10,0x01,0x00),\n    (0x6D,0xB4,0x80,0x00,0x00,0x00), (0x00,0xA7,0xCA,0x29,0xF2,0x80),\n    (0x20,0xE4,0x0C,0x09,0xC1,0x00), (0x65,0x90,0x84,0x21,0x34,0xC0),\n    (0x21,0x45,0x08,0x55,0x23,0x40), (0x30,0xC2,0x00,0x00,0x00,0x00),\n    (0x10,0x82,0x08,0x20,0x81,0x00), (0x20,0x41,0x04,0x10,0x42,0x00),\n    (0x00,0xA3,0x9F,0x38,0xA0,0x00), (0x00,0x41,0x1F,0x10,0x40,0x00),\n    (0x00,0x00,0x00,0x00,0xC3,0x08), (0x00,0x00,0x1F,0x00,0x00,0x00),\n    (0x00,0x00,0x00,0x00,0xC3,0x00), (0x00,0x10,0x84,0x21,0x00,0x00),\n    (0x39,0x14,0xD5,0x65,0x13,0x80), (0x10,0xC1,0x04,0x10,0x43,0x80),\n    (0x39,0x10,0x46,0x21,0x07,0xC0), (0x39,0x10,0x4E,0x05,0x13,0x80),\n    (0x08,0x62,0x92,0x7C,0x20,0x80), (0x7D,0x04,0x1E,0x05,0x13,0x80),\n    (0x18,0x84,0x1E,0x45,0x13,0x80), (0x7C,0x10,0x84,0x20,0x82,0x00),\n    (0x39,0x14,0x4E,0x45,0x13,0x80), (0x39,0x14,0x4F,0x04,0x23,0x00),\n    (0x00,0x03,0x0C,0x00,0xC3,0x00), (0x00,0x03,0x0C,0x00,0xC3,0x08),\n    (0x08,0x42,0x10,0x20,0x40,0x80), (0x00,0x07,0xC0,0x01,0xF0,0x00),\n    (0x20,0x40,0x81,0x08,0x42,0x00), (0x39,0x10,0x46,0x10,0x01,0x00),\n    (0x39,0x15,0xD5,0x5D,0x03,0x80), (0x39,0x14,0x51,0x7D,0x14,0x40),\n    (0x79,0x14,0x5E,0x45,0x17,0x80), (0x39,0x14,0x10,0x41,0x13,0x80),\n    (0x79,0x14,0x51,0x45,0x17,0x80), (0x7D,0x04,0x1E,0x41,0x07,0xC0),\n    (0x7D,0x04,0x1E,0x41,0x04,0x00), (0x39,0x14,0x17,0x45,0x13,0xC0),\n    (0x45,0x14,0x5F,0x45,0x14,0x40), (0x38,0x41,0x04,0x10,0x43,0x80),\n    (0x04,0x10,0x41,0x45,0x13,0x80), (0x45,0x25,0x18,0x51,0x24,0x40),\n    (0x41,0x04,0x10,0x41,0x07,0xC0), (0x45,0xB5,0x51,0x45,0x14,0x40),\n    (0x45,0x95,0x53,0x45,0x14,0x40), (0x39,0x14,0x51,0x45,0x13,0x80),\n    (0x79,0x14,0x5E,0x41,0x04,0x00), (0x39,0x14,0x51,0x55,0x23,0x40),\n    (0x79,0x14,0x5E,0x49,0x14,0x40), (0x39,0x14,0x0E,0x05,0x13,0x80),\n    (0x7C,0x41,0x04,0x10,0x41,0x00), (0x45,0x14,0x51,0x45,0x13,0x80),\n    (0x45,0x14,0x51,0x44,0xA1,0x00), (0x45,0x15,0x55,0x55,0x52,0x80),\n    (0x45,0x12,0x84,0x29,0x14,0x40), (0x45,0x14,0x4A,0x10,0x41,0x00),\n    (0x78,0x21,0x08,0x41,0x07,0x80), (0x38,0x82,0x08,0x20,0x83,0x80),\n    (0x01,0x02,0x04,0x08,0x10,0x00), (0x38,0x20,0x82,0x08,0x23,0x80),\n    (0x10,0xA4,0x40,0x00,0x00,0x00), (0x00,0x00,0x00,0x00,0x00,0x3F),\n    (0x30,0xC1,0x00,0x00,0x00,0x00), (0x00,0x03,0x81,0x3D,0x13,0xC0),\n    (0x41,0x07,0x91,0x45,0x17,0x80), (0x00,0x03,0x91,0x41,0x13,0x80),\n    (0x04,0x13,0xD1,0x45,0x13,0xC0), (0x00,0x03,0x91,0x79,0x03,0x80),\n    (0x18,0x82,0x1E,0x20,0x82,0x00), (0x00,0x03,0xD1,0x44,0xF0,0x4E),\n    (0x41,0x07,0x12,0x49,0x24,0x80), (0x10,0x01,0x04,0x10,0x41,0x80),\n    (0x08,0x01,0x82,0x08,0x24,0x8C), (0x41,0x04,0x94,0x61,0x44,0x80),\n    (0x10,0x41,0x04,0x10,0x41,0x80), (0x00,0x06,0x95,0x55,0x14,0x40),\n    (0x00,0x07,0x12,0x49,0x24,0x80), (0x00,0x03,0x91,0x45,0x13,0x80),\n    (0x00,0x07,0x91,0x45,0x17,0x90), (0x00,0x03,0xD1,0x45,0x13,0xC1),\n    (0x00,0x05,0x89,0x20,0x87,0x00), (0x00,0x03,0x90,0x38,0x13,0x80),\n    (0x00,0x87,0x88,0x20,0xA1,0x00), (0x00,0x04,0x92,0x49,0x62,0x80),\n    (0x00,0x04,0x51,0x44,0xA1,0x00), (0x00,0x04,0x51,0x55,0xF2,0x80),\n    (0x00,0x04,0x92,0x31,0x24,0x80), (0x00,0x04,0x92,0x48,0xE1,0x18),\n    (0x00,0x07,0x82,0x31,0x07,0x80), (0x18,0x82,0x18,0x20,0x81,0x80),\n    (0x10,0x41,0x00,0x10,0x41,0x00), (0x30,0x20,0x83,0x08,0x23,0x00),\n    (0x29,0x40,0x00,0x00,0x00,0x00), (0x10,0xE6,0xD1,0x45,0xF0,0x00)], dtype=np.float32)\n\n__vertex__ = """"""\n#version 120\nuniform mat4 projection;\nuniform float scale;\nuniform vec4 color;\nattribute vec2 position;\nattribute vec3 bytes_012, bytes_345;\nvarying vec4 v_color;\nvarying vec3 v_bytes_012, v_bytes_345;\nvoid main (void)\n{\n    gl_Position = projection*vec4(position*scale, 0.0, 1.0);\n    gl_PointSize = 8.0 * scale;\n\n    v_color = color;\n    v_bytes_012 = bytes_012;\n    v_bytes_345 = bytes_345;\n}\n""""""\n\n__fragment__ = """"""\n#version 120\nfloat segment(float edge0, float edge1, float x)\n{\n    return step(edge0,x) * (1.0-step(edge1,x));\n}\nvarying vec4 v_color;\nvarying vec3 v_bytes_012, v_bytes_345;\nvoid main(void)\n{\n    vec2 uv = floor(gl_PointCoord.xy * 8.0);\n    if(uv.x > 5.0) discard;\n    if(uv.y > 7.0) discard;\n    float index  = floor( (uv.y*6.0+uv.x)/8.0 );\n    float offset = floor( mod(uv.y*6.0+uv.x,8.0));\n    float byte = segment(0.0,1.0,index) * v_bytes_012.x\n               + segment(1.0,2.0,index) * v_bytes_012.y\n               + segment(2.0,3.0,index) * v_bytes_012.z\n               + segment(3.0,4.0,index) * v_bytes_345.x\n               + segment(4.0,5.0,index) * v_bytes_345.y\n               + segment(5.0,6.0,index) * v_bytes_345.z;\n    if( floor(mod(byte / (128.0/pow(2.0,offset)), 2.0)) > 0.0 )\n        gl_FragColor = v_color;\n    else\n        discard;\n}\n""""""\n\n\nclass Console(object):\n    """""" Fast and failsafe GL console """"""\n\n    def __init__(self, rows, cols, scale=2, color=(0,0,0,1)):\n\n        # Harcoded because of font above and shader program\n        self._cwidth = 6\n        self._cheight = 8\n        self._scale = int(max(scale,1))\n\n        dtype = [(""position"", np.float32, 2),\n                 (""glyph"",    np.float32, 6)]\n        self._program = gloo.Program(__vertex__, __fragment__)\n        self._data = np.zeros((rows,cols), dtype).view(gloo.VertexBuffer)\n        dtype = [(""position"",  np.float32, 2),\n                 (""bytes_012"", np.float32, 3),\n                 (""bytes_345"", np.float32, 3)]\n        self._program.bind(self._data.view(dtype))\n\n        # Initialize glyph position (they won\'t move)\n        C,R = np.meshgrid(np.arange(cols), np.arange(rows))\n        self._data[\'position\'][...,0] = 4.0 + self.cwidth*C\n        self._data[\'position\'][...,1] = 4.0 + self.cheight*R\n\n        self._program[\'scale\'] = self._scale\n        self._program[\'color\'] = color\n        self._rows, self._cols = rows, cols\n        self._row = 0\n\n\n    @property\n    def scale(self):\n        return self._scale\n\n\n    @property\n    def rows(self):\n        return self._rows\n\n\n    @property\n    def cols(self):\n        return self._cols\n\n\n    @property\n    def cwidth(self):\n        return self._cwidth\n\n\n    @property\n    def cheight(self):\n        return self._cheight + 2\n\n\n    def on_resize(self, width, height):\n        """""" Update console projection """"""\n\n        self._program[""projection""] = glm.ortho(0, width, height, 0, -1, +1)\n\n\n    def draw(self):\n        """""" Draw console """"""\n\n        self._program.draw(gl.GL_POINTS)\n\n\n    def clear(self):\n        """""" Clear console """"""\n\n        self._data[""glyph""] = 0\n        self._row = 0\n\n\n    def write(self, text=""""):\n        """""" Write text and scroll """"""\n\n        # Clear line\n        self._data[""glyph""][self._row] = 0\n\n        if len(text):\n            # Crop text if necessary\n            text = text[:self._cols]\n            # Write text\n            I = np.array([ord(c)-32 for c in text])\n            self._data[""glyph""][self._row,:len(text)] = __font_6x8__[I]\n\n        # Update row and scroll if necessary\n        self._row += 1\n        if self._row > self._rows-1:\n            self._data[""glyph""][:-n] = self._data[""glyph""][n:]\n            self._data[""glyph""][-n:] = 0\n            self._row = self._rows-1\n'"
glumpy/app/movie.py,2,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2015, Dzhelil S. Rufat\n# Distributed under the (new) BSD License. See LICENSE.txt for more info.\n# -----------------------------------------------------------------------------\n""""""\nA module for reading and writing movies.\n""""""\nimport contextlib\nimport numpy as np\n\nfrom glumpy import gl\nfrom glumpy.ext.ffmpeg_writer import FFMPEG_VideoWriter\n\n\n@contextlib.contextmanager\ndef record(window, filename, fps):\n    \'\'\'\n    Record an animated window to a movie file.\n\n    :param window: window that is being recorded.\n    :param filename: name of the file to write the movie to.\n    :param fps: framerate at which to record.\n    \'\'\'\n\n    writer = FFMPEG_VideoWriter(filename, (window.width, window.height), fps=fps)\n    fbuffer = np.zeros((window.height, window.width, 3), dtype=np.uint8)\n\n    # Function to write one frame\n    def write_frame(writer):\n        gl.glReadPixels(0, 0, window.width, window.height,\n                        gl.GL_RGB, gl.GL_UNSIGNED_BYTE, fbuffer)\n        writer.write_frame(np.flipud(fbuffer))\n\n    # Modify the on_draw event handler to also write a\n    # movie frame every time it is called\n    old_on_draw = window.get_handler(\'on_draw\')\n    @window.event\n    def on_draw(dt):\n        old_on_draw(dt)\n        write_frame(writer)\n\n    yield\n\n    writer.close()\n'"
glumpy/app/parser.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nDefault argument parser for any glumpy program.\n""""""\nimport argparse\nimport glumpy.defaults\n\n\n# Default parser\n__parser__ = None\n\n\ndef get_default():\n    """""" Get the default parser. """"""\n\n    global __parser__\n\n    if __parser__ is None:\n        __parser__ = argparse.ArgumentParser()\n        set_default_options(__parser__)\n    return __parser__\n\n\n\ndef get_options():\n    """""" Parse and retrun command line options. """"""\n\n    options, unknown = get_default().parse_known_args()\n    return options\n\n\ndef set_default_options(parser):\n    """""" Set parser default options. """"""\n\n    # Backend option\n    parser.add_argument(""--backend"", ""-b"",\n                        default = glumpy.defaults.backend(),\n                        choices = (\'glfw\', \'sdl2\', \'qt5\', \'pyside\',\n                                   \'pyglet\', \'sdl\',  \'freeglut\', \'osxglut\'),\n                        help=""Backend to use, one of "")\n\n    # Record\n    parser.add_argument(""--record"",\n                        action=\'store_true\',\n                        help=\'Record a movie (default is ""movie.mp4"")\')\n\n    # Interactive mode\n    parser.add_argument(""--interactive"", ""-i"",\n                        action=\'store_true\',\n                        help=""Interactive mode"")\n\n    # Framerate option\n    parser.add_argument(""--framerate"", ""-f"",\n                        default=60,\n                        type=int,\n                        help=""Framerate in frames/second"")\n\n    # Display framerate option\n    parser.add_argument(""--display-fps"",\n                        action=\'store_true\',\n                        help=""Display framerate in the console"")\n\n    # Framerate option\n    parser.add_argument(""--debug"", ""-d"",\n                        action=\'store_true\',\n                        help=""Verbose debug mode"")\n\n    # Window size\n    parser.add_argument(""--size"", ""-s"",\n                        default = """",\n                        type=str,\n                        help=""Window size"")\n\n    # Window position\n    parser.add_argument(""--position"", ""-p"",\n                        default = """",\n                        type=str,\n                        help=""Window position"")\n\n    # Single buffer\n    parser.add_argument(""--single-buffer"",\n                        action=\'store_true\',\n                        help=""Single buffer mode"")\n\n    # Stereo mode\n    parser.add_argument(""--stereo"",\n                        action=\'store_true\',\n                        help=""Stereo mode"")\n\n    # vertical synchronization\n    parser.add_argument(""--vsync"",\n                        default=False,\n                        type=bool,\n                        help=""Enable/disable vertical synchronization"")\n\n    # sRGB mode\n    parser.add_argument(""--srgb"",\n                        action=\'store_true\',\n                        help=""sRGB mode (gamma correction)"")\n\n    # Depth buffer size\n    parser.add_argument(""--depth-size"",\n                        default=16,\n                        type=int,\n                        help=""Depth buffer size"")\n\n    # Stencil buffer size\n    parser.add_argument(""--stencil-size"",\n                        default=0,\n                        type=int,\n                        help=""Stencil buffer size"")\n\n    # GL API\n    parser.add_argument(""--gl-api"",\n                        default=""GL"",\n                        choices=[""GL"",""ES""],\n                        help=""GL API"")\n\n    # GL profile\n    parser.add_argument(""--gl-profile"",\n                        default=""none"",\n                        choices=[""none"",""core"", ""compatibility""],\n                        help=""GL context profile (only relevant for GL > 3.0)"")\n\n    # GL version\n    parser.add_argument(""--gl-version"",\n                        default=""2.1"",\n                        help=""GL version"")\n'"
glumpy/app/viewport.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n""""""\nfrom . window import event\nfrom glumpy.log import log\nfrom glumpy import gloo, gl, library\n\nclass ViewportDispatcher(event.EventDispatcher):\n    def __init__(self):\n        pass\n\nViewportDispatcher.register_event_type(\'on_enter\')\nViewportDispatcher.register_event_type(\'on_leave\')\nViewportDispatcher.register_event_type(\'on_resize\')\nViewportDispatcher.register_event_type(\'on_mouse_motion\')\nViewportDispatcher.register_event_type(\'on_mouse_drag\')\nViewportDispatcher.register_event_type(\'on_mouse_press\')\nViewportDispatcher.register_event_type(\'on_mouse_release\')\nViewportDispatcher.register_event_type(\'on_mouse_scroll\')\nViewportDispatcher.register_event_type(\'on_character\')\nViewportDispatcher.register_event_type(\'on_key_press\')\nViewportDispatcher.register_event_type(\'on_key_release\')\nViewportDispatcher.register_event_type(\'on_draw\')\n\n\nclass Viewport(event.EventDispatcher):\n    """"""\n    A Viewport represents a rectangular area on a window.\n\n    :param size: Requested size as (width, height)\n    :param position:  Requested position as (x,y)\n    :param anchor: Anchor point as (x,y)\n    :param float aspect: Aspect (= width/height).\n\n    The size and the position are always relative to the parent viewport.  They\n    may be given in pixels (int) or as a percentage (float) of parent viewport\n    size. Positive or negative values are accepted.\n\n    .. important::\n    \n       The viewport class works in conjunction with the Viewport transform that\n       ensure actual positioning and sizing within a shader program.\n\n    Let\'s consider a root viewport of size 400x400 and a child viewport:\n\n    **Absolute size**\n\n      .. code:: python\n\n         viewport = Viewport(400,400)\n         child = Viewport(100,100)\n         viewport.add(child)\n\n         # Child size is 100x100 (pixels)\n\n      .. code:: python\n\n         viewport = Viewport(400,400)\n         child = Viewport(-100, -100)\n         viewport.add(child)\n\n         # Child size is (400-100) x (400-100) = 300 x 300 (pixels)\n\n\n    **Relative size**\n\n      .. code:: python\n\n         viewport = Viewport(400,400)\n         child = Viewport(0.5, 0.5)\n         viewport.add(child)\n\n         # Child size is 400*0.5 x 400*0.5 = 200 x 200 (pixels)\n\n         # Child size is 200x200 pixels.\n\n      .. code:: python\n\n         viewport = Viewport(400,400)\n         child = Viewport(-0.125, -0.125)\n         viewport.add(child)\n\n         # Child size is (400*(1-0.125)) x (400*(1-0.125)) = 50 x 50 (pixels)\n\n      .. note::\n\n         It is also possible to define an aspect (width/height) that will be\n         enforced anytime.\n\n    Positioning the viewport inside the parent viewport is also made using\n    absolute or relative coordinates.\n\n    **Absolute position**\n\n      .. code:: python\n\n         viewport = Viewport(size=(400,400), position=(0,0))\n         child = Viewport(size=(100,100), position=(10,10))\n         viewport.add(child)\n\n         # Child position is +10+10 (pixels)\n\n      .. code:: python\n\n         viewport = Viewport(size=(400,400), position=(0,0))\n         child = Viewport(size=(100,100), position=(-10,-10))\n         viewport.add(child)\n\n         # Child position is +(400-10)+(400-10) = +390+390 (pixels)\n\n    **Relative position**\n\n      .. code:: python\n\n         viewport = Viewport(size=(400,400), position=(0,0))\n         child = Viewport(size=(100,100), position=(0.25,0.25))\n         viewport.add(child)\n\n         # Child position is +(400*0.25)+(400*0.25) = +100+100 (pixels)\n\n      .. code:: python\n\n         viewport = Viewport(size=(400,400), position=(0,0))\n         child = Viewport(size=(100,100), position=(-0.25,-0.25))\n         viewport.add(child)\n\n         # Child position is +(400*(1-0.25))+(400*(1-0.25)) = +300+300 (pixels)\n\n      .. note::\n\n         The final position of the viewport relates to the anchor point which\n         can be also set in absolute or relative coordinates.\n\n    The order of rendering is done according to the order of the viewport\n    hierarchy, starting from the root viewport.\n    """"""\n\n\n    # Internal id counter to keep track of created objects\n    _idcount = 0\n\n\n    def __init__(self, size=(800,600), position=(0,0), anchor=(0,0), aspect=None):\n        """"""\n        Create a new viewport with requested size and position.\n\n        Parameters\n        ----------\n        """"""\n\n        self._parent = None\n        self._children = []\n        self._active_viewports = []\n        self._dispatcher = ViewportDispatcher()\n\n        # Aspect ratio (width/height)\n        self._aspect = aspect\n        if aspect:\n            log.info(""Enforcing viewport aspect ratio (%g)"" % aspect)\n\n        # Anchor point for placement\n        self._anchor = anchor\n\n        # Requested size & position (may be honored or not, depending on parent)\n        # (relative or absolute coordinates)\n        self._requested_size     = size\n        self._requested_position = position\n\n        # Clipped size & position (used for glScissor)\n        # (absolute coordinates)\n        self._scissor_size     = size\n        self._scissor_position = position\n\n        # Viewport size & position (used for glViewport)\n        # (absolute coordinates)\n        self._viewport_size     = size\n        self._viewport_position = position\n\n        # Wheter viewport is active (cursor is inside)\n        self._active = False\n\n        # Viewport id\n        self._id = Viewport._idcount\n        Viewport._idcount += 1\n\n\n    def event(self, *args):\n        return self._dispatcher.event(*args)\n\n    def attach(self, *args, **kwargs):\n        self.dispatcher.push_handlers(*args, **kwargs)\n\n\n    def add(self, child):\n        """""" Add a new child to the viewport """"""\n\n        child._parent = self\n        self._children.append(child)\n\n\n    def __getitem__(self, index):\n        """"""Get children using index""""""\n\n        return self._children[index]\n\n    @property\n    def dispatcher(self):\n        """""" Event dispatcher """"""\n\n        return self._dispatcher\n\n    @property\n    def name(self):\n        """""" Viewport name """"""\n\n        return ""VP%d"" % (self._id)\n\n\n    @property\n    def active(self):\n        """""" Whether viewport is active """"""\n\n        return self._active\n\n\n    @active.setter\n    def active(self, value):\n        """""" Whether viewport is active """"""\n\n        self._active = value\n        for child in self._children:\n            child.active = value\n\n\n    @property\n    def root(self):\n        """""" Root viewport """"""\n\n        if not self._parent:\n            return self\n        return self._parent.root\n\n    @property\n    def parent(self):\n        """""" Parent viewport """"""\n        return self._parent\n\n\n    @property\n    def extents(self):\n        """""" Actual position and size of the viewport """"""\n\n        x,y = self._viewport_position\n        w,h = self._viewport_size\n        return x, y, w, h\n\n\n    @property\n    def scissor(self):\n        """""" Actual position and size of the scissor """"""\n\n        x,y = self._scissor_position\n        w,h = self._scissor_size\n        return x, y, w, h\n\n\n    @property\n    def size(self):\n        """""" Actual size of the viewport """"""\n\n        return self._viewport_size\n\n    @size.setter\n    def size(self, size):\n        """""" Actual size of the viewport """"""\n\n        self._requested_size = size\n        self.root._compute_viewport()\n\n\n    @property\n    def position(self):\n        """""" Actual position of the viewport """"""\n\n        return self._viewport_position\n\n\n    @position.setter\n    def position(self, position):\n        """""" Actual position of the viewport """"""\n\n        self._requested_position = position\n        self.root._compute_viewport()\n\n\n    def _compute_viewport(self):\n        """""" Compute actual viewport in absolute coordinates """"""\n\n        # Root requests are always honored, modulo the aspect\n        if self.parent is None:\n            w,h = self._requested_size\n            if self._aspect:\n                h = w * self._aspect\n                if h > self._requested_size[1]:\n                    h = self._requested_size[1]\n                    w = h/self._aspect\n            x = (self._requested_size[0] - w)/2\n            y = (self._requested_size[1] - h)/2\n            self._position          = x,y\n            self._size              = w,h\n            self._viewport_position = x,y\n            self._viewport_size     = w,h\n            self._scissor_position  = x,y\n            self._scissor_size      = w,h\n            for child in self._children:\n                child._compute_viewport()\n            return\n\n        # Children viewport request depends on parent viewport\n        pvx, pvy = self.parent._viewport_position\n        pvw, pvh = self.parent._viewport_size\n        psx, psy = self.parent._scissor_position\n        psw, psh = self.parent._scissor_size\n\n        # Relative width (to actual parent viewport)\n        # ------------------------------------------\n        if self._requested_size[0] <= -1.0:\n            vw = max(pvw + self._requested_size[0],0)\n        elif self._requested_size[0] < 0.0:\n            vw = max(pvw + self._requested_size[0]*pvw,0)\n        elif self._requested_size[0] <= 1.0:\n            vw = self._requested_size[0]*pvw\n        # Absolute width\n        else:\n            vw = self._requested_size[0]\n        vw = int(round(vw))\n\n        # Enforce aspect first\n        if self._aspect:\n            vh = self._aspect*vw\n            if vh > pvh and -1 < self._requested_size[0] <= 1:\n                vh = pvh\n                vw = vh/self._aspect\n\n\n\n        # Relative height (to actual parent viewport)\n        # -------------------------------------------\n        else:\n            if self._requested_size[1] <= -1.0:\n                vh = max(pvh + self._requested_size[1],0)\n            elif self._requested_size[1] < 0.0:\n                vh = max(pvh + self._requested_size[1]*pvh,0)\n            elif self._requested_size[1] <= 1.0:\n                vh = self._requested_size[1]*pvh\n            # Absolute height\n            else:\n                vh = self._requested_size[1]\n        vh = int(round(vh))\n\n        # X anchor\n        # ---------------------------------------\n        if self._anchor[0] <= -1.0:\n            ax = vw + self._anchor[0]\n        elif self._anchor[0] < 0.0:\n            ax = vw + self._anchor[0]*vw\n        elif self._anchor[0] < 1.0:\n            ax = self._anchor[0]*vw\n        else:\n            ax = self._anchor[0]\n        ax = int(round(ax))\n\n        # X positioning\n        # ---------------------------------------\n        if self._requested_position[0] <= -1.0:\n            vx = pvw + self._requested_position[0]\n        elif -1.0 < self._requested_position[0] < 0.0:\n            vx = pvw + self._requested_position[0]*pvw\n        elif 0.0 <= self._requested_position[0] < 1.0:\n            vx = self._requested_position[0]*pvw\n        else:\n            vx = self._requested_position[0]\n        vx = int(round(vx)) + pvx - ax\n\n        # Y anchor\n        # ---------------------------------------\n        if self._anchor[1] <= -1.0:\n            ay = vh + self._anchor[1]\n        elif -1.0 < self._anchor[1] < 0.0:\n            ay = vh + self._anchor[1]*vh\n        elif 0.0 <= self._anchor[1] < 1.0:\n            ay = self._anchor[1]*vh\n        else:\n            ay = self._anchor[1]\n        ay = int(round(ay))\n\n        # Y positioning\n        # ---------------------------------------\n        if self._requested_position[1] <= -1.0:\n            vy = pvh + self._requested_position[1] #- vh\n        elif -1.0 < self._requested_position[1] < 0.0:\n            vy = pvh + self._requested_position[1]*pvh\n\n        elif 0.0 <= self._requested_position[1] < 1.0:\n            vy = self._requested_position[1]*pvh\n        else:\n            vy = self._requested_position[1]\n        vy = int(round(vy)) + pvy - ay\n\n\n        # Compute scissor size & position\n        sx = max(pvx,vx)\n        sy = max(pvy,vy)\n        sw = max(min(psw-(sx-pvx)-1,vw), 0)\n        sh = max(min(psh-(sy-pvy)-1,vh), 0)\n\n        # Update internal information\n        self._viewport_size     = vw, vh\n        self._viewport_position = vx, vy\n        self._scissor_size      = sw, sh\n        self._scissor_position  = sx, sy\n\n        # Update children\n        for child in self._children:\n            child._compute_viewport()\n\n\n    def __contains__(self, xy):\n        x,y = xy\n        # WARN: mouse pointer is usually upside down\n        y = self.root.size[1] - y\n        xmin = self._viewport_position[0]\n        xmax = xmin + self._viewport_size[0]\n        ymin = self._viewport_position[1]\n        ymax = ymin + self._viewport_size[1]\n        return  xmin <= x < xmax and  ymin <= y < ymax\n\n    # def lock(self):\n    #     vx, vy = self._viewport_position\n    #     vw, vh = self._viewport_size\n    #     sx, sy = self._scissor_position\n    #     sw, sh = self._scissor_size\n    #     gl.glPushAttrib( gl.GL_VIEWPORT_BIT | gl.GL_SCISSOR_BIT )\n    #     gl.glViewport( vx, vy, vw, vh )\n    #     gl.glEnable( gl.GL_SCISSOR_TEST )\n    #     gl.glScissor( sx, sy, sw+1, sh+1 )\n\n    # def unlock(self):\n    #     gl.glPopAttrib( )\n\n\n    def on_draw(self, dt):\n\n        # Root viewport\n        if self.parent is None:\n            # gl.glEnable(gl.GL_SCISSOR_TEST)\n            # gl.glViewport(*self.viewport)\n            # gl.glScissor(*self.scissor)\n\n            self.dispatcher.dispatch_event(""on_draw"", dt)\n\n        for child in self._children:\n            # x,y = child._viewport_position\n            # w,h = child._viewport_size\n            # gl.glViewport(x,y,w,h)\n            # x,y = child._scissor_position\n            # w,h = child._scissor_size\n            # gl.glScissor(x,y,w+1,h+1)\n\n            # WARNING\n            # Order is important because the direct \'on_draw\' event on child\n            # may result in a viewport/scissor modification.\n            child.dispatcher.dispatch_event(""on_draw"", dt)\n            child.dispatch_event(""on_draw"", dt)\n\n        # if self.parent is None:\n        #     gl.glDisable(gl.GL_SCISSOR_TEST)\n        #     gl.glViewport(*self.viewport)\n\n\n    def on_resize(self, width, height):\n        if self.parent == None:\n            self._requested_size = width, height\n\n        self._compute_viewport()\n        self.dispatcher.dispatch_event(""on_resize"", self.size[0], self.size[1])\n\n        for child in self._children:\n            child.dispatch_event(""on_resize"", width, height)\n\n\n\n    def on_key_press(self, key, modifiers):\n        """""" Default key handler that close window on escape """"""\n        pass\n\n        # if key == window.key.ESCAPE:\n        #     self.close()\n        #     return True\n\n    def on_mouse_press(self, x, y, button):\n        self.dispatcher.dispatch_event(""on_mouse_press"",\n                                       x-self.position[0], y-self.position[1], button)\n        if self.parent == None:\n            self._active_viewports = []\n\n        for child in self._children:\n            if (x,y) in child:\n                self.root._active_viewports.append(child)\n                ox, oy = child.position\n                child.dispatch_event(""on_mouse_press"", x, y, button)\n\n\n    def on_mouse_release(self, x, y, button):\n        self.dispatcher.dispatch_event(\n            ""on_mouse_release"", x-self.position[0], y-self.position[1], button)\n\n        if self.parent == None:\n            for child in self._active_viewports:\n                ox, oy = child.position\n                child.dispatch_event(""on_mouse_release"", x, y, button)\n\n\n    def on_mouse_drag(self, x, y, dx, dy, button):\n        self.dispatcher.dispatch_event(\n            ""on_mouse_drag"", x-self.position[0], y-self.position[1], dx, dy, button)\n\n        if self.parent == None:\n            if len(self.root._active_viewports):\n                #child = self.root._active_viewports[-1]\n                for child in self.root._active_viewports:\n                    ox, oy = child.position\n                    child.dispatch_event(""on_mouse_drag"", x, y, dx, dy, button)\n\n\n    def on_mouse_scroll(self, x, y, dx, dy):\n        self.dispatcher.dispatch_event(\n            ""on_mouse_scroll"", x-self.position[0], y-self.position[1], dx, dy)\n\n        if self.parent == None:\n            if self.root._active_viewports:\n                # child = self.root._active_viewports[-1]\n                for child in self.root._active_viewports:\n                    ox, oy = child.position\n                    child.dispatch_event(""on_mouse_scroll"", x, y, dx, dy)\n\n\n    def on_mouse_motion(self, x, y, dx, dy):\n        self.dispatcher.dispatch_event(\n            ""on_mouse_motion"", x-self.position[0], y-self.position[1], dx, dy)\n\n        for child in self._children:\n            ox, oy = child.position\n            if (x,y) in child:\n                if not child._active:\n                    child.dispatch_event(""on_enter"")\n                    child.dispatcher.dispatch_event(""on_enter"")\n                self.active = False\n                child._active = True\n                child.dispatch_event(""on_mouse_motion"", x, y, dx, dy)\n            else:\n                if child._active:\n                    child.dispatch_event(""on_leave"")\n                child.active = False\n                if (x,y) in self:\n                    self._active = True\n\n\n    def __replines__(self):\n        """""" ASCII display of trees by Andrew Cooke """"""\n        yield ""%s (%dx%d%+d%+d)"" % (self.name,\n                                    self.size[0], self.size[1],\n                                    self.position[0], self.position[1])\n        last = self._children[-1] if self._children else None\n        for child in self._children:\n            prefix = \'\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 \' if child is last else \'\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 \'\n            for line in child.__replines__():\n                yield prefix + line\n                prefix = \'    \' if child is last else \'\xe2\x94\x82   \'\n\n    def __str__(self):\n        return \'\\n\'.join(self.__replines__()) + \'\\n\'\n\n\n# Viewport events\nViewport.register_event_type(\'on_enter\')\nViewport.register_event_type(\'on_leave\')\nViewport.register_event_type(\'on_resize\')\nViewport.register_event_type(\'on_mouse_motion\')\nViewport.register_event_type(\'on_mouse_drag\')\nViewport.register_event_type(\'on_mouse_press\')\nViewport.register_event_type(\'on_mouse_release\')\nViewport.register_event_type(\'on_mouse_scroll\')\nViewport.register_event_type(\'on_character\')\nViewport.register_event_type(\'on_key_press\')\nViewport.register_event_type(\'on_key_release\')\nViewport.register_event_type(\'on_draw\')\n\n# Window events\n#Viewport.register_event_type(\'on_init\')\n#Viewport.register_event_type(\'on_show\')\n#Viewport.register_event_type(\'on_hide\')\n#Viewport.register_event_type(\'on_close\')\n#Viewport.register_event_type(\'on_idle\')\n'"
glumpy/data/__init__.py,15,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport os\nfrom glumpy.ext.six.moves.urllib import request\nimport numpy as np\ntry:\n    from PIL import Image\nexcept:\n    Image = None\ntry:\n    from urllib.parse import urljoin    # Python 3\nexcept ImportError:\n    from urlparse import urljoin        # Python 2\nfrom glumpy import gloo\nfrom glumpy.log import log\n\n\ndef _fetch_file(filename):\n    """"""\n    Fetch a font file from a remote data server\n\n    Available servers:\n\n      * https://github.com/glumpy/glumpy-font/raw/master/Fonts\n      * https://github.com/glumpy/glumpy-data/raw/master/Data\n    """"""\n\n    local_directory = os.path.dirname(__file__) or \'.\'\n    local_file = os.path.join(local_directory, filename)\n\n    if os.path.isfile(local_file):\n        return local_file\n\n    extension = os.path.basename(filename).split(\'.\')[-1]\n\n    # Font server\n    if extension in [\'ttf\', \'otf\']:\n        server = ""https://github.com/glumpy/glumpy-font/raw/master/Fonts/""\n    # Data server\n    else:\n        server = ""https://github.com/glumpy/glumpy-data/raw/master/Data/""\n\n    filename = os.path.basename(filename)\n    remote = urljoin(server, filename)\n\n    # Build url request\n    log.info(\'Requesting ""%s"" from remote server\' % filename)\n    try:\n        response = request.urlopen(remote)\n    except:\n        log.warning(\'Data not available on remote server\')\n        return None\n    # Fetch symlink data (font location)\n    symlink = response.read().decode()\n\n    remote = urljoin(server, symlink)\n    response = request.urlopen(remote)\n\n    # Fetch data\n    size = response.headers[\'Content-Length\'].strip()\n    log.info(\'Fetching data (%s bytes) to ""%s""\' % (size, local_file))\n    with open(local_file, \'wb\') as fp:\n        fp.write(response.read())\n    return local_file\n\n\n\ndef objload(filename, rescale=True):\n    """""" """"""\n    \n    V = [] # vertex\n    T = [] # texcoords\n    N = [] # normals\n    F   = [] # face indices\n    F_V = [] # face indices\n    F_T = [] # face indices\n    F_N = [] # face indices\n    \n    for lineno,line in enumerate(open(filename)):\n        if line[0] == \'#\':\n            continue\n        values = line.strip().split(\' \')\n        code = values[0]\n        values = values[1:]\n        # vertex (v)\n        if code == \'v\':\n            V.append([float(x) for x in values])\n        # tex-coord (vt)\n        elif code == \'vt\' :\n            T.append([float(x) for x in values])\n        # normal (n)\n        elif code == \'vn\' :\n            N.append([float(x) for x in values])\n        # face (f)\n        elif code == \'f\' :\n            if len(values) != 3:\n                raise ValueError(\'not a triangle at line\' % lineno)\n            for v in values:\n                for j,index in enumerate(v.split(\'/\')):\n                    if len(index):\n                        if   j==0: F_V.append(int(index)-1)\n                        elif j==1: F_T.append(int(index)-1)\n                        elif j==2: F_N.append(int(index)-1)\n\n    # Building the vertices\n    V = np.array(V)\n    F_V = np.array(F_V)\n    vtype = [(\'position\', np.float32, 3)]\n    \n    if len(T):\n        T = np.array(T)\n        F_T = np.array(F_T)\n        vtype.append((\'texcoord\', np.float32, 2))\n    if len(N):\n        N = np.array(N)\n        F_N = np.array(F_N)\n        vtype.append((\'normal\', np.float32, 3))\n        \n    vertices = np.empty(len(F_V),vtype)\n    vertices[""position""] = V[F_V,:3]\n    if len(T):\n        vertices[""texcoord""] = T[F_T,:2]\n    if len(N):\n        vertices[""normal""] = N[F_N]\n    vertices = vertices.view(gloo.VertexBuffer)\n\n    if rescale:\n        # Centering and scaling to fit the unit box\n        xmin,xmax = vertices[""position""][:,0].min(), vertices[""position""][:,0].max()\n        ymin,ymax = vertices[""position""][:,1].min(), vertices[""position""][:,1].max()\n        zmin,zmax = vertices[""position""][:,2].min(), vertices[""position""][:,2].max()\n        vertices[""position""][:,0] -= (xmax+xmin)/2.0\n        vertices[""position""][:,1] -= (ymax+ymin)/2.0\n        vertices[""position""][:,2] -= (zmax+zmin)/2.0\n        scale = max(max(xmax-xmin,ymax-ymin), zmax-zmin) / 2.0\n        vertices[""position""] /= scale\n    \n        # xmin,xmax = vertices[""position""][:,0].min(), vertices[""position""][:,0].max()\n        # ymin,ymax = vertices[""position""][:,1].min(), vertices[""position""][:,1].max()\n        # zmin,zmax = vertices[""position""][:,2].min(), vertices[""position""][:,2].max()\n        # print(""xmin: %g, xmax: %g"" % (xmin,xmax))\n        # print(""ymin: %g, xmax: %g"" % (ymin,ymax))\n        # print(""zmin: %g, zmax: %g"" % (zmin,zmax))\n    \n    itype = np.uint32\n    indices = np.arange(len(vertices), dtype=np.uint32)\n    indices = indices.view(gloo.IndexBuffer)\n    return vertices, indices\n\n\ndef checkerboard(grid_num=8, grid_size=32):\n    row_even = grid_num // 2 * [0, 1]\n    row_odd = grid_num // 2 * [1, 0]\n    Z = np.row_stack(grid_num // 2 * (row_even, row_odd)).astype(np.uint8)\n    return 255 * Z.repeat(grid_size, axis=0).repeat(grid_size, axis=1)\n\n\ndef get(name, *args, **kwargs): #, depth=0):\n    """""" Retrieve data content from a name """"""\n\n    if name == ""checkerboard"":\n        return checkerboard(8,16)\n\n    filename = _fetch_file(name)\n    return load(filename, *args, **kwargs)\n\n\ndef load(filename, *args, **kwargs):\n    """""" Load data content from a filename """"""\n    \n    extension = os.path.basename(filename).split(\'.\')[-1]\n\n    if extension == \'npy\':\n        return np.load(filename, *args, **kwargs)\n    elif extension in [\'ttf\', \'otf\']:\n        if filename is not None:\n            return filename\n        if depth == 0:\n            log.warning(""Falling back to default font"")\n            return get(""SourceSansPro-Regular.otf"", 1)\n        else:\n            log.critical(""Default font not available"")\n            raise RuntimeError\n    elif extension == \'obj\':\n        return objload(filename, *args, **kwargs)\n    elif extension in [\'svg\', \'json\', \'csv\', \'tsv\']:\n        return filename\n    elif extension in (\'png\', \'jpg\', \'jpeg\', \'tif\', \'tiff\', \'tga\'):\n        if Image is not None:\n            if filename is not None:\n                return np.array(Image.open(filename))\n            log.warning(""File not found"")\n            return checkerboard(16,32)\n        else:\n            log.warning(""PIL/Pillow not installed, cannot load image"")\n            return checkerboard(16,32)\n\n    log.warning(""Data not found (%s)"" % name)\n    raise RuntimeError\n    return None\n'"
glumpy/data/build-spatial-filters.py,6,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# glumpy is an OpenGL framework for the fast visualization of numpy arrays.\n# Copyright (C) 2009-2011  Nicolas P. Rougier. All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY NICOLAS P. ROUGIER \'\'AS IS\'\' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL NICOLAS P. ROUGIER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Nicolas P. Rougier.\n# -----------------------------------------------------------------------------\n\'\'\'\nA filter is a shader that transform the current displayed texture. Since\nshaders cannot be easily serialized within the GPU, they have to be well\nstructured on the python side such that we can possibly merge them into a\nsingle source code for both vertex and fragment. Consequently, there is a\ndefault code for both vertex and fragment with specific entry points such that\nfilter knows where to insert their specific code (declarations, functions and\ncall (or code) to be inserted in the main function).\n\nSpatial interpolation filter classes for OpenGL textures.\n\nEach filter generates a one-dimensional lookup table (weights value from 0 to\nceil(radius)) that is uploaded to video memory (as a 1d texture) and is then\nread by the shader when necessary. It avoids computing weight values for each\npixel. Furthemore, each 2D-convolution filter is separable and can be computed\nusing 2 1D-convolution with same 1d-kernel (= the lookup table values).\n\nAvailable filters:\n\n  - Nearest  (radius 0.5)\n  - Bilinear (radius 1.0)\n  - Hanning (radius 1.0)\n  - Hamming (radius 1.0)\n  - Hermite (radius 1.0)\n  - Kaiser (radius 1.0)\n  - Quadric (radius 1.5)\n  - Bicubic (radius 2.0)\n  - CatRom (radius 2.0)\n  - Mitchell (radius 2.0)\n  - Spline16 (radius 2.0)\n  - Spline36 (radius 4.0)\n  - Gaussian (radius 2.0)\n  - Bessel (radius 3.2383)\n  - Sinc (radius 4.0)\n  - Lanczos (radius 4.0)\n  - Blackman (radius 4.0)\n\n\nNote::\n\n  Weights code has been translated from the antigrain geometry library available\n  at http://www.antigrain.com/\n\'\'\'\n\nimport os\nimport math\nimport numpy as np\nimport OpenGL.GL as gl\nimport OpenGL.GLUT as glut\n\n\n\nclass SpatialFilter(object):\n    \'\'\' \'\'\'\n\n    def __init__(self, radius=1.0):\n        self.radius = radius\n\n\n    def weight(self, x):\n        \'\'\'\n        Return filter weight for a distance x.\n\n        :Parameters:\n            ``x`` : 0 < float < ceil(self.radius)\n                Distance to be used to compute weight.\n        \'\'\'\n        raise NotImplemented\n\n\n    def kernel(self, size=4*512):\n        radius = self.radius\n        r = int(max(1.0,math.ceil(radius)))\n        samples = size / r\n        n = size # r*samples\n        kernel = np.zeros(n)\n        X = np.linspace(0,r,n)\n        for i in range(n):\n            kernel[i] = self.weight(X[i])\n        N = np.zeros(samples)\n        for i in range(r):\n            N += kernel[::+1][i*samples:(i+1)*samples]\n            N += kernel[::-1][i*samples:(i+1)*samples]\n        for i in range(r):\n            kernel[i*samples:(i+1)*samples:+1] /= N\n        return kernel\n\n\n    def filter_code(self):\n\n        n = int(math.ceil(self.radius))\n        filter_1 = \'filter1D_radius%d\' % n\n        filter_2 = \'filter2D_radius%d\' % n\n\n        code = \'\'\n        code += \'vec4\\n\'\n        code += \'%s( sampler2D kernel, float index, float x, \' % filter_1\n        for i in range(2*n):\n            if i == 2*n-1:\n                code += \'vec4 c%d )\\n\' % i\n            else:\n                code += \'vec4 c%d, \' % i\n        code += \'{\\n\'\n        code += \'    float w, w_sum = 0.0;\\n\'\n        code += \'    vec4 r = vec4(0.0,0.0,0.0,0.0);\\n\'\n        for i in range(n):\n            code += \'    w = texture2D(kernel, vec2(%f+(x/%.1f),index) ).r;\\n\' % (1.0-(i+1)/float(n),n)\n            code += \'    w = w*kernel_scale + kernel_bias;\\n\';\n            # code += \'   w_sum += w;\'\n            code += \'    r += c%d * w;\\n\' % i\n            code += \'    w = texture2D(kernel, vec2(%f-(x/%.1f),index) ).r;\\n\' % ((i+1)/float(n),n)\n            code += \'    w = w*kernel_scale + kernel_bias;\\n\';\n            # code += \'   w_sum += w;\'\n            code += \'    r += c%d * w;\\n\' % (i+n)\n        # code += \'    return r/w_sum;\\n\'\n        code += \'    return r;\\n\'\n        code += \'}\\n\'\n        code += \'vec4\\n\'\n        code += \'%s\' % filter_2\n        code += \'(sampler2D texture, sampler2D kernel, float index, vec2 uv, vec2 pixel )\\n\'\n        code += \'{\\n\'\n        code += \'    vec2 texel = uv/pixel - vec2(0.0,0.0) ;\\n\'\n        code += \'    vec2 f = fract(texel);\\n\'\n        code += \'    texel = (texel-fract(texel)+vec2(0.001,0.001))*pixel;\\n\'\n        for i in range(2*n):\n            code += \'    vec4 t%d = %s(kernel, index, f.x,\\n\' % (i,filter_1)\n            for j in range(2*n):\n                x,y = (-n+1+j,-n+1+i)\n                code += \'        texture2D( texture, texel + vec2(%d,%d)*pixel),\\n\' % (x,y)\n\n            # Remove last trailing\',\' and close function call\n            code = code[:-2] + \');\\n\'\n\n        code += \'    return %s(kernel, index, f.y, \' % filter_1\n        for i in range(2*n):\n            code += \'t%d, \' % i\n\n        # Remove last trailing\',\' and close function call\n        code = code[:-2] + \');\\n\'\n        code += \'}\\n\'\n\n        return code\n\n\n    def call_code(self, index):\n        code = """"\n        n = int(math.ceil(self.radius))\n        filter_1 = \'filter1D_radius%d\' % n\n        filter_2 = \'filter2D_radius%d\' % n\n\n        code += \'vec4 %s(sampler2D texture, vec2 shape, vec2 uv)\\n\' % self.__class__.__name__\n        code += \'{\'\n        code += \' return %s(texture, u_kernel, %f, uv, 1.0/shape); \' % (filter_2,index)\n        code += \'}\\n\'\n        return code\n\n\n\nclass Nearest(SpatialFilter):\n    \'\'\'\n    Nearest (=None) filter (radius = 0.5).\n\n    Weight function::\n\n      w(x) = 1\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=.5)\n\n    def weight(self, x):\n        return 1.0\n\n    def _get_code(self):\n        self.build_LUT()\n        code += \'vec4\\n\'\n        code += \'interpolate( sampler2D texture, sampler1D kernel, vec2 uv, vec2 pixel )\\n\'\n        code += \'{\\n   return texture2D( texture, uv );\\n}\\n\'\n        return code\n    code = property(_get_code, doc=\'\'\'filter functions code\'\'\')\n\n\n\n\nclass Bilinear(SpatialFilter):\n    \'\'\'\n    Bilinear filter (radius = 1.0).\n\n    Weight function::\n\n      w(x) = 1 - x\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def weight(self, x):\n        return 1.0 - x\n\n\nclass Hanning(SpatialFilter):\n    \'\'\'\n    Hanning filter (radius = 1.0).\n\n    Weight function::\n\n      w(x) = 0.5 + 0.5 * cos(pi * x)\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def weight(self, x):\n        return 0.5 + 0.5 * math.cos(math.pi * x)\n\n\n\nclass Hamming(SpatialFilter):\n    \'\'\'\n    Hamming filter (radius = 1.0).\n\n    Weight function::\n\n      w(x) = 0.54 + 0.46 * cos(pi * x)\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def weight(self, x):\n        return 0.54 + 0.46 * math.cos(math.pi * x)\n\n\n\nclass Hermite(SpatialFilter):\n    \'\'\' Hermite filter (radius = 1.0).\n\n    Weight function::\n\n      w(x) = (2*x-3)*x^2 + 1\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def weight(self, x):\n        return (2.0 * x - 3.0) * x * x + 1.0\n\n\n\nclass Quadric(SpatialFilter):\n    \'\'\'\n    Quadric filter (radius = 1.5).\n\n    Weight function::\n\n             |  0.0 \xe2\x89\xa4 x < 0.5: 0.75 - x*x\n      w(x) = |  0.5 \xe2\x89\xa4 x < 1.5: 0.5 - (x-1.5)^2\n             |  1.5 \xe2\x89\xa4 x      : 0\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.5)\n\n    def weight(self, x):\n        if x <  0.75:\n            return 0.75 - x * x\n        elif x <  1.5:\n            t = x - 1.5\n            return 0.5 * t * t\n        else:\n            return 0.0\n\n\n\nclass Bicubic(SpatialFilter):\n    \'\'\'\n    Bicubic filter (radius = 2.0).\n\n    Weight function::\n\n      w(x) = 1/6((x+2)^3 - 4*(x+1)^3 + 6*x^3 -4*(x-1)^3)\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def pow3(self, x):\n        if x <= 0:\n            return 0\n        else:\n            return x * x * x\n\n    def weight(self, x):\n        return (1.0/6.0) * (      self.pow3(x + 2)\n                            - 4 * self.pow3(x + 1)\n                            + 6 * self.pow3(x    )\n                            - 4 * self.pow3(x - 1))\n\n\n\nclass Kaiser(SpatialFilter):\n    \'\'\'\n    Kaiser filter (radius = 1.0).\n\n\n    Weight function::\n\n      w(x) = bessel_i0(a sqrt(1-x^2)* 1/bessel_i0(b)\n\n    \'\'\'\n\n    def __init__(self, b=6.33):\n        self.a = b\n        self.epsilon = 1e-12\n        self.i0a = 1.0 / self.bessel_i0(b)\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def bessel_i0(self, x):\n        s = 1.0\n        y = x * x / 4.0\n        t = y\n        i=2\n        while t > self.epsilon:\n            s += t\n            t *= float(y) / (i * i)\n            i += 1\n        return s\n\n    def weight(self, x):\n        if x > 1: return 0\n        return self.bessel_i0(self.a * math.sqrt(1.0 - x * x)) * self.i0a\n\n\n\n\nclass CatRom(SpatialFilter):\n    \'\'\'\n    Catmull-Rom filter (radius = 2.0).\n\n    Weight function::\n\n             |  0 \xe2\x89\xa4 x < 1: 0.5*(2 + x^2*(-5+x*3))\n      w(x) = |  1 \xe2\x89\xa4 x < 2: 0.5*(4 + x*(-8+x*(5-x)))\n             |  2 \xe2\x89\xa4 x    : 0\n\n    \'\'\'\n\n    def __init__(self, size=256*8):\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def weight(self, x):\n        if x < 1.0:\n            return 0.5 * (2.0 + x * x * (-5.0 + x * 3.0))\n        elif x <  2.0:\n            return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)))\n        else:\n            return 0.0\n\n\n\nclass Mitchell(SpatialFilter):\n    \'\'\'\n    Mitchell-Netravali filter (radius = 2.0).\n\n    Weight function::\n\n             |  0 \xe2\x89\xa4 x < 1: p0 + x^2*(p2 + x*p3)\n      w(x) = |  1 \xe2\x89\xa4 x < 2: q0 + x*(q1 + x*(q2 + x*q3))\n             |  2 \xe2\x89\xa4 x    : 0\n\n    \'\'\'\n\n    def __init__(self, b=1.0/3.0, c = 1.0/3.0):\n        self.p0 = (6.0 - 2.0 * b) / 6.0\n        self.p2 = (-18.0 + 12.0 * b + 6.0 * c) / 6.0\n        self.p3 = (12.0 - 9.0 * b - 6.0 * c) / 6.0\n        self.q0 = (8.0 * b + 24.0 * c) / 6.0\n        self.q1 = (-12.0 * b - 48.0 * c) / 6.0\n        self.q2 = (6.0 * b + 30.0 * c) / 6.0\n        self.q3 = (-b - 6.0 * c) / 6.0\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def weight(self, x):\n        if x < 1.0:\n            return self.p0 + x * x * (self.p2 + x * self.p3)\n        elif x < 2.0:\n            return self.q0 + x * (self.q1 + x * (self.q2 + x * self.q3))\n        else:\n            return 0.0\n\n\n\nclass Spline16(SpatialFilter):\n    \'\'\'\n    Spline16 filter (radius = 2.0).\n\n    Weight function::\n\n             |  0 \xe2\x89\xa4 x < 1: ((x-9/5)*x - 1/5)*x + 1\n      w(x) = |\n             |  1 \xe2\x89\xa4 x < 2: ((-1/3*(x-1) + 4/5)*(x-1) - 7/15 )*(x-1)\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def weight(self, x):\n        if x < 1.0:\n            return ((x - 9.0/5.0 ) * x - 1.0/5.0 ) * x + 1.0\n        else:\n            return ((-1.0/3.0 * (x-1) + 4.0/5.0) * (x-1) - 7.0/15.0 ) * (x-1)\n\n\n\nclass Spline36(SpatialFilter):\n    \'\'\'\n    Spline36 filter (radius = 3.0).\n\n    Weight function::\n\n             |  0 \xe2\x89\xa4 x < 1: ((13/11*x - 453/209)*x -3/209)*x +1\n      w(x) = |  1 \xe2\x89\xa4 x < 2: ((-6/11*(x-1) - 270/209)*(x-1) -156/209)*(x-1)\n             |  2 \xe2\x89\xa4 x < 3: (( 1/11*(x-2) - 45/209)*(x-2) + 26/209)*(x-2)\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=3.0)\n\n    def weight(self, x):\n        if x < 1.0:\n            return ((13.0/11.0 * x - 453.0/209.0) * x - 3.0/209.0) * x + 1.0\n        elif x < 2.0:\n            return ((-6.0/11.0 * (x-1) + 270.0/209.0) * (x-1) - 156.0/ 209.0) * (x-1)\n        else:\n           return ((1.0/11.0 * (x-2) - 45.0/209.0) * (x-2) +  26.0/209.0) * (x-2)\n\n\n\nclass Gaussian(SpatialFilter):\n    \'\'\'\n    Gaussian filter (radius = 2.0).\n\n    Weight function::\n\n      w(x) = exp(-2x^2) * sqrt(2/pi)\n\n    Note::\n\n      This filter does not seem to be correct since:\n\n        x = np.linspace(0, 1.0, 100 )\n        f = weight\n        z = f(x+1)+f(x)+f(1-x)+f(2-x)\n\n        z should be 1 everywhere but it is not the case and it produces ""grid\n        effects"".\n    \'\'\'\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def weight(self, x):\n        return math.exp(-2.0 * x * x) * math.sqrt(2.0 / math.pi)\n\n\n\nclass Bessel(SpatialFilter):\n    \'\'\'\n    Bessel filter (radius = 3.2383).\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=3.2383)\n\n\n    def besj(self, x, n):\n        \'\'\'\n        Function BESJ calculates Bessel function of first kind of order n\n        Arguments:\n            n - an integer (>=0), the order\n            x - value at which the Bessel function is required\n        --------------------\n        C++ Mathematical Library\n        Converted from equivalent FORTRAN library\n        Converted by Gareth Walker for use by course 392 computational project\n        All functions tested and yield the same results as the corresponding\n        FORTRAN versions.\n\n        If you have any problems using these functions please report them to\n        M.Muldoon@UMIST.ac.uk\n\n        Documentation available on the web\n        http://www.ma.umist.ac.uk/mrm/Teaching/392/libs/392.html\n        Version 1.0   8/98\n        29 October, 1999\n        --------------------\n        Adapted for use in AGG library by\n                    Andy Wilk (castor.vulgaris@gmail.com)\n        Adapted for use in vispy library by\n                    Nicolas P. Rougier (Nicolas.Rougier@inria.fr)\n        -----------------------------------------------------------------------\n        \'\'\'\n        if n < 0:\n            return 0.0\n\n        d = 1e-6\n        b = 0\n        if math.fabs(x) <= d:\n            if n != 0:\n                return 0\n            return 1\n\n        b1 = 0 # b1 is the value from the previous iteration\n        # Set up a starting order for recurrence\n        m1 = int(math.fabs(x)) + 6\n        if math.fabs(x) > 5:\n            m1 = int(math.fabs(1.4 * x + 60 / x))\n\n        m2 = int(n + 2 + math.fabs(x) / 4)\n        if m1 > m2:\n            m2 = m1\n\n        # Apply recurrence down from curent max order\n        while True:\n            c3 = 0\n            c2 = 1e-30\n            c4 = 0\n            m8 = 1\n            if m2 / 2 * 2 == m2:\n                m8 = -1\n\n            imax = m2 - 2\n            for i in range(1,imax+1):\n                c6 = 2 * (m2 - i) * c2 / x - c3\n                c3 = c2\n                c2 = c6\n                if m2 - i - 1 == n:\n                    b = c6\n                m8 = -1 * m8\n                if m8 > 0:\n                    c4 = c4 + 2 * c6\n\n            c6 = 2 * c2 / x - c3\n            if n == 0:\n                b = c6\n            c4 += c6\n            b /= c4\n            if math.fabs(b - b1) < d:\n                return b\n            b1 = b\n            m2 += 3\n\n\n    def weight(self, x):\n        if x == 0.0:\n            return math.pi/4.0\n        else:\n            return self.besj(math.pi * x, 1) / (2.0 * x)\n\n\n\nclass Sinc(SpatialFilter):\n    \'\'\'\n    Sinc filter (radius = 4.0).\n\n    Weight function::\n\n\n    \'\'\'\n\n    def __init__(self, size=256, radius=4.0):\n        SpatialFilter.__init__(self, radius=max(radius,2.0))\n\n    def weight(self, x):\n        if x == 0.0:\n            return 1.0\n        x *= math.pi\n        return (math.sin(x) / x)\n\n\n\nclass Lanczos(SpatialFilter):\n    \'\'\'\n    Lanczos filter (radius = 4.0).\n\n    Weight function::\n\n\n    \'\'\'\n\n    def __init__(self, size=256, radius=4.0):\n        SpatialFilter.__init__(self, radius=max(radius,2.0))\n\n    def weight(self, x):\n        if x == 0.0:\n            return 1.0\n        elif x > self.radius:\n            return 0.0\n        x *= math.pi\n        xr = x / self.radius\n        return (math.sin(x) / x) * (math.sin(xr)/xr)\n\n\n\nclass Blackman(SpatialFilter):\n    \'\'\'\n    Blackman filter (radius = 4.0).\n    \'\'\'\n\n    def __init__(self, size=256, radius=4.0):\n        SpatialFilter.__init__(self, radius=max(radius,2.0))\n\n    def weight(self, x):\n        if x == 0.0:\n            return 1.0\n        elif x > self.radius:\n            return 0.0\n        x *= math.pi\n        xr = x / self.radius\n        return (math.sin(x) / x) * (0.42 + 0.5*math.cos(xr) + 0.08*math.cos(2*xr))\n\n\n\n# Generate kernels texture (16 x 1024)\nfilters = [Bilinear(), Hanning(),  Hamming(),  Hermite(),\n           Kaiser(),   Quadric(),  Bicubic(),  CatRom(),\n           Mitchell(), Spline16(), Spline36(), Gaussian(),\n           Bessel(),   Sinc(),     Lanczos(),  Blackman()]\n\nn = 1024\nK = np.zeros((16,n))\nfor i,f in enumerate(filters):\n    K[i] = f.kernel(n)\n#    print f.call_code(i/15.0)\n\nbias = K.min()\nscale = K.max()-K.min()\nK = (K-bias)/scale\nnp.save(""spatial-filters.npy"", K.astype(np.float32))\n\nprint(""// ------------------------------------"")\nprint(""// Automatically generated, do not edit"")\nprint(""// ------------------------------------"")\nprint("""")\nprint(""const float kernel_bias  = %f;"" % bias)\nprint(""const float kernel_scale = %f;"" % scale)\nprint(""uniform sampler2D u_kernel;"")\nprint("""")\n\nF = SpatialFilter(1.0)\nprint(F.filter_code())\nF = SpatialFilter(2.0)\nprint(F.filter_code())\nF = SpatialFilter(3.0)\nprint(F.filter_code())\nF = SpatialFilter(4.0)\nprint(F.filter_code())\n\n# Generate filter functions\n# Special case for nearest\nprint(""""""vec4 Nearest(sampler2D texture, vec2 shape, vec2 uv)"""""")\nprint(""""""{ return texture2D(texture,uv); }\\n"""""")\n\nfor i,f in enumerate(filters):\n    print(f.call_code((i+0.5)/16.0))\n'"
glumpy/ext/__init__.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n# from . import glfw\nfrom . import freetype\n\ntry:\n    from . import sdf\nexcept:\n    sdf = None\n\ntry:\n    from . import ffmpeg_reader\n    from . import ffmpeg_writer\nexcept:\n    ffmpeg_reader = None\n    ffmpeg_writer = None\n'
glumpy/ext/ffmpeg_config.py,0,"b'# The MIT License (MIT)\n#\n# Copyright (c) 2014 Zulko\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n#\n# File from the MoviePy project - released under licence MIT\n# See https://github.com/Zulko/moviepy\n\nimport os\nimport subprocess as sp\ntry:\n    from subprocess import DEVNULL  # py3k\nexcept ImportError:\n    DEVNULL = open(os.devnull, \'wb\')\n    \nif os.name == \'nt\':\n    try:    \n        import winreg as wr # py3k\n    except:\n        import _winreg as wr # py2k\n\nfrom .ffmpeg_config_defaults import (FFMPEG_BINARY, IMAGEMAGICK_BINARY)\n\ndef try_cmd(cmd):\n        try:\n            popen_params = { ""stdout"": sp.PIPE,\n                             ""stderr"": sp.PIPE,\n                              ""stdin"": DEVNULL\n                            }\n\n            \n            # This was added so that no extra unwanted window opens on windows\n            # when the child process is created\n            if os.name == ""nt"":\n                popen_params[""creationflags""] = 0x08000000\n\n            proc = sp.Popen(cmd, **popen_params)\n            proc.communicate()\n        except Exception as err:\n            return False, err\n        else:\n            return True, None\n\nif FFMPEG_BINARY==\'ffmpeg-imageio\':\n    from imageio.plugins.ffmpeg import get_exe\n    FFMPEG_BINARY = get_exe()\n\nelif FFMPEG_BINARY==\'auto-detect\':\n\n    if try_cmd([\'ffmpeg\'])[0]:\n        FFMPEG_BINARY = \'ffmpeg\'\n    elif try_cmd([\'ffmpeg.exe\'])[0]:\n        FFMPEG_BINARY = \'ffmpeg.exe\'\n    else:\n        FFMPEG_BINARY = \'unset\'\nelse:\n    success, err = try_cmd([FFMPEG_BINARY])\n    if not success:\n        raise IOError(err.message +\n                 ""The path specified for the ffmpeg binary might be wrong"")\n\n\n\nif IMAGEMAGICK_BINARY==\'auto-detect\':\n    if os.name == \'nt\':    \n        try:\n            key = wr.OpenKey(wr.HKEY_LOCAL_MACHINE, \'SOFTWARE\\\\ImageMagick\\\\Current\')\n            IMAGEMAGICK_BINARY = wr.QueryValueEx(key, \'BinPath\')[0] + r""\\convert.exe""\n            key.Close()\n        except:\n            IMAGEMAGICK_BINARY = \'unset\'\n    elif try_cmd([\'convert\'])[0]:\n        IMAGEMAGICK_BINARY = \'convert\'\n    else:\n        IMAGEMAGICK_BINARY = \'unset\'\nelse:\n    success, err = try_cmd([IMAGEMAGICK_BINARY])\n    if not success:\n        raise IOError(err.message +\n                 ""The path specified for the ImageMagick binary might be wrong"")\n\n\n\ndef get_setting(varname):\n    """""" Returns the value of a configuration variable. """""" \n    gl = globals()\n    if varname not in gl.keys():\n        raise ValueError(""Unknown setting %s""%varname)\n    # Here, possibly add some code to raise exceptions if some\n    # parameter isn\'t set set properly, explaining on how to set it.\n    return gl[varname]\n\n\ndef change_settings(new_settings={}, file=None):\n    """""" Changes the value of configuration variables.""""""\n    gl = globals()\n    if file is not None:\n        execfile(file)\n        gl.update(locals())\n    gl.update(new_settings)\n    # Here you can add some code  to check that the new configuration\n    # values are valid.\n\nif __name__ == ""__main__"":\n    if try_cmd([FFMPEG_BINARY])[0]:\n        print( ""MoviePy : ffmpeg successfully found."" )\n    else:\n        print( ""MoviePy : can\'t find or access ffmpeg."" )\n\n    if try_cmd([IMAGEMAGICK_BINARY])[0]:\n        print( ""MoviePy : ImageMagick successfully found."" )\n    else:\n        print( ""MoviePy : can\'t find or access ImageMagick."" )\n\n\n'"
glumpy/ext/ffmpeg_config_defaults.py,0,"b'# The MIT License (MIT)\n#\n# Copyright (c) 2014 Zulko\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n#\n# File from the MoviePy project - released under licence MIT\n# See https://github.com/Zulko/moviepy\n\n""""""\nConfiguration of MoviePy\n\n\nThis file enables you to specify a configuration for MoviePy. In\nparticular you can enter the path to the FFMPEG and ImageMagick\nbinaries.\n\nThese changes must be done BEFORE installing MoviePy: first make the changes,\nthen install MoviePy with\n\n    [sudo] python setup.py install\n\nNote that you can also change the path to the binaries AFTER installation, but\nonly for one script at a time, as follows:\n\n>>> import moviepy.config as cf\n>>> cf.change_settings({""FFMPEG_BINARY"": ""some/new/path/to/ffmpeg""})\n>>> print( cf.get_setting(""FFMPEG_BINARY"") )  # prints the current setting\n\n\nInstructions\n--------------\n\nFFMPEG_BINARY\n    Normally you can leave this one to its default (\'ffmpeg-imageio\') at which\n    case image-io will download the right ffmpeg binary (at first use) and then\n    always use that binary.\n    The second option is \'auto-detect\', in this case ffmpeg will be whatever\n    binary is found on the computer generally \'ffmpeg\' (on linux) or \'ffmpeg.exe\'\n    (on windows).\n    Third option: If you want to use a binary at a special location on you disk,\n    enter it like that:\n\n    FFMPEG_BINARY = r""path/to/ffmpeg"" # on linux\n    FFMPEG_BINARY = r""path\\to\\ffmpeg.exe"" # on windows\n\n    Warning: the \'r\' before the path is important, especially on Windows.\n\n\nIMAGEMAGICK_BINARY\n    For linux users, \'convert\' should be fine.\n    For Windows users, you must specify the path to the ImageMagick\n    \'convert\' binary. For instance:\n\n    IMAGEMAGICK_BINARY = r""C:\\Program Files\\ImageMagick-6.8.8-Q16\\convert.exe""\n\n""""""\n\nFFMPEG_BINARY = \'ffmpeg\'\nIMAGEMAGICK_BINARY = \'auto-detect\'\n'"
glumpy/ext/ffmpeg_reader.py,1,"b'# The MIT License (MIT)\n#\n# Copyright (c) 2014 Zulko\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n#\n# File from the MoviePy project - released under licence MIT\n# See https://github.com/Zulko/moviepy\n\n""""""\nThis module implements all the functions to read a video or a picture\nusing ffmpeg. It is quite ugly, as there are many pitfalls to avoid\n""""""\n\nfrom __future__ import division\n\nimport subprocess as sp\nimport re\nimport warnings\n\n# #113\n#import logging\n#logging.captureWarnings(True)\n\n\nimport numpy as np\nfrom . ffmpeg_config import get_setting  # ffmpeg, ffmpeg.exe, etc...\nfrom . ffmpeg_tools import cvsecs\n\nimport os\ntry:\n    from subprocess import DEVNULL  # py3k\nexcept ImportError:\n    DEVNULL = open(os.devnull, \'wb\')\n\n\nclass FFMPEG_VideoReader:\n\n    def __init__(self, filename, print_infos=False, bufsize = None,\n                 pix_fmt=""rgb24"", check_duration=True):\n\n        self.filename = filename\n        infos = ffmpeg_parse_infos(filename, print_infos, check_duration)\n        self.fps = infos[\'video_fps\']\n        self.size = infos[\'video_size\']\n        self.duration = infos[\'video_duration\']\n        self.ffmpeg_duration = infos[\'duration\']\n        self.nframes = infos[\'video_nframes\']\n\n        self.infos = infos\n\n        self.pix_fmt = pix_fmt\n        if pix_fmt == \'rgba\':\n            self.depth = 4\n        else:\n            self.depth = 3\n\n        if bufsize is None:\n            w, h = self.size\n            bufsize = self.depth * w * h + 100\n\n        self.bufsize= bufsize\n        self.initialize()\n\n\n        self.pos = 1\n        self.lastread = self.read_frame()\n\n\n    def initialize(self, starttime=0):\n        """"""Opens the file, creates the pipe. """"""\n\n        self.close() # if any\n\n        if starttime != 0 :\n            offset = min(1, starttime)\n            i_arg = [\'-ss\', ""%.06f"" % (starttime - offset),\n                     \'-i\', self.filename,\n                     \'-ss\', ""%.06f"" % offset]\n        else:\n            i_arg = [ \'-i\', self.filename]\n\n\n        cmd = ([get_setting(""FFMPEG_BINARY"")]+ i_arg +\n                [\'-loglevel\', \'error\',\n                \'-f\', \'image2pipe\',\n                ""-pix_fmt"", self.pix_fmt,\n                \'-vcodec\', \'rawvideo\', \'-\'])\n\n        popen_params = {""bufsize"": self.bufsize,\n                        ""stdout"": sp.PIPE,\n                        ""stderr"": sp.PIPE,\n                        ""stdin"": DEVNULL}\n\n        if os.name == ""nt"":\n            popen_params[""creationflags""] = 0x08000000\n\n        self.proc = sp.Popen(cmd, **popen_params)\n\n\n\n\n\n    def skip_frames(self, n=1):\n        """"""Reads and throws away n frames """"""\n        w, h = self.size\n        for i in range(n):\n            self.proc.stdout.read(self.depth*w*h)\n            #self.proc.stdout.flush()\n        self.pos += n\n\n\n    def read_frame(self):\n        w, h = self.size\n        nbytes= self.depth*w*h\n\n        s = self.proc.stdout.read(nbytes)\n        if len(s) != nbytes:\n\n            warnings.warn(""Warning: in file %s, ""%(self.filename)+\n                   ""%d bytes wanted but %d bytes read,""%(nbytes, len(s))+\n                   ""at frame %d/%d, at time %.02f/%.02f sec. ""%(\n                    self.pos,self.nframes,\n                    1.0*self.pos/self.fps,\n                    self.duration)+\n                   ""Using the last valid frame instead."",\n                   UserWarning)\n\n            if not hasattr(self, \'lastread\'):\n                raise IOError((""MoviePy error: failed to read the first frame of ""\n                               ""video file %s. That might mean that the file is ""\n                               ""corrupted. That may also mean that you are using ""\n                               ""a deprecated version of FFMPEG. On Ubuntu/Debian ""\n                               ""for instance the version in the repos is deprecated. ""\n                               ""Please update to a recent version from the website."")%(\n                                self.filename))\n\n            result = self.lastread\n\n        else:\n\n            result = np.fromstring(s, dtype=\'uint8\')\n            result.shape =(h, w, len(s)//(w*h)) # reshape((h, w, len(s)//(w*h)))\n            self.lastread = result\n\n        return result\n\n    def get_frame(self, t):\n        """""" Read a file video frame at time t.\n\n        Note for coders: getting an arbitrary frame in the video with\n        ffmpeg can be painfully slow if some decoding has to be done.\n        This function tries to avoid fectching arbitrary frames\n        whenever possible, by moving between adjacent frames.\n        """"""\n\n        # these definitely need to be rechecked sometime. Seems to work.\n        \n        # I use that horrible \'+0.00001\' hack because sometimes due to numerical\n        # imprecisions a 3.0 can become a 2.99999999... which makes the int()\n        # go to the previous integer. This makes the fetching more robust in the\n        # case where you get the nth frame by writing get_frame(n/fps).\n        \n        pos = int(self.fps*t + 0.00001)+1\n\n        if pos == self.pos:\n            return self.lastread\n        else:\n            if(pos < self.pos) or (pos > self.pos+100):\n                self.initialize(t)\n                self.pos = pos\n            else:\n                self.skip_frames(pos-self.pos-1)\n            result = self.read_frame()\n            self.pos = pos\n            return result\n\n    def close(self):\n        if hasattr(self,\'proc\'):\n            self.proc.terminate()\n            self.proc.stdout.close()\n            self.proc.stderr.close()\n            del self.proc\n\n    def __del__(self):\n        self.close()\n        if hasattr(self,\'lastread\'):\n            del self.lastread\n\n\n\ndef ffmpeg_read_image(filename, with_mask=True):\n    """""" Read an image file (PNG, BMP, JPEG...).\n\n    Wraps FFMPEG_Videoreader to read just one image.\n    Returns an ImageClip.\n\n    This function is not meant to be used directly in MoviePy,\n    use ImageClip instead to make clips out of image files.\n\n    Parameters\n    -----------\n\n    filename\n      Name of the image file. Can be of any format supported by ffmpeg.\n\n    with_mask\n      If the image has a transparency layer, ``with_mask=true`` will save\n      this layer as the mask of the returned ImageClip\n\n    """"""\n    if with_mask:\n        pix_fmt = \'rgba\'\n    else:\n        pix_fmt = ""rgb24""\n    reader = FFMPEG_VideoReader(filename, pix_fmt=pix_fmt, check_duration=False)\n    im = reader.lastread\n    del reader\n    return im\n\ndef ffmpeg_parse_infos(filename, print_infos=False, check_duration=True):\n    """"""Get file infos using ffmpeg.\n\n    Returns a dictionnary with the fields:\n    ""video_found"", ""video_fps"", ""duration"", ""video_nframes"",\n    ""video_duration"", ""audio_found"", ""audio_fps""\n\n    ""video_duration"" is slightly smaller than ""duration"" to avoid\n    fetching the uncomplete frames at the end, which raises an error.\n\n    """"""\n\n\n    # open the file in a pipe, provoke an error, read output\n    is_GIF = filename.endswith(\'.gif\')\n    cmd = [get_setting(""FFMPEG_BINARY""), ""-i"", filename]\n    if is_GIF:\n        cmd += [""-f"", ""null"", ""/dev/null""]\n\n    popen_params = {""bufsize"": 10**5,\n                    ""stdout"": sp.PIPE,\n                    ""stderr"": sp.PIPE,\n                    ""stdin"": DEVNULL}\n\n    if os.name == ""nt"":\n        popen_params[""creationflags""] = 0x08000000\n\n    proc = sp.Popen(cmd, **popen_params)\n\n    proc.stdout.readline()\n    proc.terminate()\n    infos = proc.stderr.read().decode(\'utf8\')\n    del proc\n\n    if print_infos:\n        # print the whole info text returned by FFMPEG\n        print( infos )\n\n\n    lines = infos.splitlines()\n    if ""No such file or directory"" in lines[-1]:\n        raise IOError((""MoviePy error: the file %s could not be found !\\n""\n                      ""Please check that you entered the correct ""\n                      ""path."")%filename)\n\n    result = dict()\n\n\n    # get duration (in seconds)\n    result[\'duration\'] = None\n\n    if check_duration:\n        try:\n            keyword = (\'frame=\' if is_GIF else \'Duration: \')\n            line = [l for l in lines if keyword in l][0]\n            match = re.findall(""([0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9][0-9])"", line)[0]\n            result[\'duration\'] = cvsecs(match)\n        except:\n            raise IOError((""MoviePy error: failed to read the duration of file %s.\\n""\n                           ""Here are the file infos returned by ffmpeg:\\n\\n%s"")%(\n                              filename, infos))\n\n    # get the output line that speaks about video\n    lines_video = [l for l in lines if \' Video: \' in l and re.search(\'\\d+x\\d+\', l)]\n\n    result[\'video_found\'] = ( lines_video != [] )\n\n    if result[\'video_found\']:\n\n\n        try:\n            line = lines_video[0]\n\n            # get the size, of the form 460x320 (w x h)\n            match = re.search("" [0-9]*x[0-9]*(,| )"", line)\n            s = list(map(int, line[match.start():match.end()-1].split(\'x\')))\n            result[\'video_size\'] = s\n        except:\n            raise IOError((""MoviePy error: failed to read video dimensions in file %s.\\n""\n                           ""Here are the file infos returned by ffmpeg:\\n\\n%s"")%(\n                              filename, infos))\n\n\n        # get the frame rate. Sometimes it\'s \'tbr\', sometimes \'fps\', sometimes\n        # tbc, and sometimes tbc/2...\n        # Current policy: Trust tbr first, then fps. If result is near from x*1000/1001\n        # where x is 23,24,25,50, replace by x*1000/1001 (very common case for the fps).\n\n        try:\n            match = re.search(""( [0-9]*.| )[0-9]* tbr"", line)\n            tbr = float(line[match.start():match.end()].split(\' \')[1])\n            result[\'video_fps\'] = tbr\n\n        except:\n            match = re.search(""( [0-9]*.| )[0-9]* fps"", line)\n            result[\'video_fps\'] = float(line[match.start():match.end()].split(\' \')[1])\n\n\n        # It is known that a fps of 24 is often written as 24000/1001\n        # but then ffmpeg nicely rounds it to 23.98, which we hate.\n        coef = 1000.0/1001.0\n        fps = result[\'video_fps\']\n        for x in [23,24,25,30,50]:\n            if (fps!=x) and abs(fps - x*coef) < .01:\n                result[\'video_fps\'] = x*coef\n\n        if check_duration:\n            result[\'video_nframes\'] = int(result[\'duration\']*result[\'video_fps\'])+1\n            result[\'video_duration\'] = result[\'duration\']\n        else:\n            result[\'video_nframes\'] = 1\n            result[\'video_duration\'] = None\n        # We could have also recomputed the duration from the number\n        # of frames, as follows:\n        # >>> result[\'video_duration\'] = result[\'video_nframes\'] / result[\'video_fps\']\n\n\n    lines_audio = [l for l in lines if \' Audio: \' in l]\n\n    result[\'audio_found\'] = lines_audio != []\n\n    if result[\'audio_found\']:\n        line = lines_audio[0]\n        try:\n            match = re.search("" [0-9]* Hz"", line)\n            result[\'audio_fps\'] = int(line[match.start()+1:match.end()])\n        except:\n            result[\'audio_fps\'] = \'unknown\'\n\n    return result\n'"
glumpy/ext/ffmpeg_tools.py,0,"b'# The MIT License (MIT)\n#\n# Copyright (c) 2014 Zulko\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n#\n# File from the MoviePy project - released under licence MIT\n# See https://github.com/Zulko/moviepy\n\n""""""\nMisc. useful functions that can be used at many places in the program.\n""""""\n\nimport subprocess as sp\nimport sys\nimport warnings\nimport re\n\nimport os\ntry:\n    from subprocess import DEVNULL  # py3k\nexcept ImportError:\n    DEVNULL = open(os.devnull, \'wb\')\n\n\ndef sys_write_flush(s):\n    """""" Writes and flushes without delay a text in the console """"""\n    sys.stdout.write(s)\n    sys.stdout.flush()\n\n\ndef verbose_print(verbose, s):\n    """""" Only prints s (with sys_write_flush) if verbose is True.""""""\n    if verbose:\n        sys_write_flush(s)\n\n\ndef subprocess_call(cmd, verbose=True, errorprint=True):\n    """""" Executes the given subprocess command.""""""\n\n    verbose_print(verbose, ""\\n[MoviePy] Running:\\n>>> ""+ "" "".join(cmd))\n\n    popen_params = {""stdout"": DEVNULL,\n                    ""stderr"": sp.PIPE,\n                    ""stdin"": DEVNULL}\n\n    if os.name == ""nt"":\n        popen_params[""creationflags""] = 0x08000000\n\n    proc = sp.Popen(cmd, **popen_params)\n\n    out, err = proc.communicate() # proc.wait()\n    proc.stderr.close()\n\n    if proc.returncode:\n        verbose_print(errorprint, ""\\n[MoviePy] This command returned an error !"")\n        raise IOError(err.decode(\'utf8\'))\n    else:\n        verbose_print(verbose, ""\\n... command successful.\\n"")\n\n    del proc\n\ndef is_string(obj):\n    """""" Returns true if s is string or string-like object,\n    compatible with Python 2 and Python 3.""""""\n    try:\n        return isinstance(obj, basestring)\n    except NameError:\n        return isinstance(obj, str)\n\ndef cvsecs(time):\n    """""" Will convert any time into seconds.\n    Here are the accepted formats:\n\n    >>> cvsecs(15.4) -> 15.4 # seconds\n    >>> cvsecs( (1,21.5) ) -> 81.5 # (min,sec)\n    >>> cvsecs( (1,1,2) ) -> 3662 # (hr, min, sec)\n    >>> cvsecs(\'01:01:33.5\') -> 3693.5  #(hr,min,sec)\n    >>> cvsecs(\'01:01:33.045\') -> 3693.045\n    >>> cvsecs(\'01:01:33,5\') #coma works too\n    """"""\n\n    if is_string(time):\n        if (\',\' not in time) and (\'.\' not in time):\n            time = time + \'.0\'\n        expr = r""(\\d+):(\\d+):(\\d+)[,|.](\\d+)""\n        finds = re.findall(expr, time)[0]\n        nums = list( map(float, finds) )\n        return ( 3600*int(finds[0])\n                + 60*int(finds[1])\n                + int(finds[2])\n                + nums[3]/(10**len(finds[3])))\n\n    elif isinstance(time, tuple):\n        if len(time)== 3:\n            hr, mn, sec = time\n        elif len(time)== 2:\n            hr, mn, sec = 0, time[0], time[1]\n        return 3600*hr + 60*mn + sec\n\n    else:\n        return time\n\ndef deprecated_version_of(f, oldname, newname=None):\n    """""" Indicates that a function is deprecated and has a new name.\n\n    `f` is the new function, `oldname` the name of the deprecated\n    function, `newname` the name of `f`, which can be automatically\n    found.\n\n    Returns\n    ========\n\n    f_deprecated\n      A function that does the same thing as f, but with a docstring\n      and a printed message on call which say that the function is\n      deprecated and that you should use f instead.\n\n    Examples\n    =========\n\n    >>> # The badly named method \'to_file\' is replaced by \'write_file\'\n    >>> class Clip:\n    >>>    def write_file(self, some args):\n    >>>        # blablabla\n    >>>\n    >>> Clip.to_file = deprecated_version_of(Clip.write_file, \'to_file\')\n    """"""\n\n    if newname is None: newname = f.__name__\n\n    warning= (""The function ``%s`` is deprecated and is kept temporarily ""\n              ""for backwards compatibility.\\nPlease use the new name, ""\n              ""``%s``, instead."")%(oldname, newname)\n\n    def fdepr(*a, **kw):\n        warnings.warn(""MoviePy: "" + warning, PendingDeprecationWarning)\n        return f(*a, **kw)\n    fdepr.__doc__ = warning\n\n    return fdepr\n\n\n# non-exhaustive dictionnary to store default informations.\n# any addition is most welcome.\n# Note that \'gif\' is complicated to place. From a VideoFileClip point of view,\n# it is a video, but from a HTML5 point of view, it is an image.\n\nextensions_dict = { ""mp4"":  {\'type\':\'video\', \'codec\':[\'libx264\',\'libmpeg4\']},\n                    \'ogv\':  {\'type\':\'video\', \'codec\':[\'libtheora\']},\n                    \'webm\': {\'type\':\'video\', \'codec\':[\'libvpx\']},\n                    \'avi\':  {\'type\':\'video\'},\n                    \'mov\':  {\'type\':\'video\'},\n\n                    \'ogg\':  {\'type\':\'audio\', \'codec\':[\'libvorbis\']},\n                    \'mp3\':  {\'type\':\'audio\', \'codec\':[\'libmp3lame\']},\n                    \'wav\':  {\'type\':\'audio\', \'codec\':[\'pcm_s16le\', \'pcm_s32le\']},\n                    \'m4a\':  {\'type\':\'audio\', \'codec\':[\'libfdk_aac\']}\n                  }\n\nfor ext in [""jpg"", ""jpeg"", ""png"", ""bmp"", ""tiff""]:\n    extensions_dict[ext] = {\'type\':\'image\'}\n\ndef find_extension(codec):\n    for ext,infos in extensions_dict.items():\n        if (\'codec\' in infos) and codec in infos[\'codec\']:\n            return ext\n    raise ValueError'"
glumpy/ext/ffmpeg_writer.py,1,"b'# The MIT License (MIT)\n#\n# Copyright (c) 2014 Zulko\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n#\n# File from the MoviePy project - released under licence MIT\n# See https://github.com/Zulko/moviepy\n\n""""""\nOn the long term this will implement several methods to make videos\nout of VideoClips\n""""""\n\nimport subprocess as sp\nimport os\nimport numpy as np\n\ntry:\n    from subprocess import DEVNULL  # py3k\nexcept ImportError:\n    DEVNULL = open(os.devnull, \'wb\')\n\nfrom . ffmpeg_config import get_setting\nfrom . ffmpeg_tools import verbose_print\n\nclass FFMPEG_VideoWriter:\n    """""" A class for FFMPEG-based video writing.\n\n    A class to write videos using ffmpeg. ffmpeg will write in a large\n    choice of formats.\n\n    Parameters\n    -----------\n\n    filename\n      Any filename like \'video.mp4\' etc. but if you want to avoid\n      complications it is recommended to use the generic extension\n      \'.avi\' for all your videos.\n\n    size\n      Size (width,height) of the output video in pixels.\n\n    fps\n      Frames per second in the output video file.\n\n    codec\n      FFMPEG codec. It seems that in terms of quality the hierarchy is\n      \'rawvideo\' = \'png\' > \'mpeg4\' > \'libx264\'\n      \'png\' manages the same lossless quality as \'rawvideo\' but yields\n      smaller files. Type ``ffmpeg -codecs`` in a terminal to get a list\n      of accepted codecs.\n\n      Note for default \'libx264\': by default the pixel format yuv420p\n      is used. If the video dimensions are not both even (e.g. 720x405)\n      another pixel format is used, and this can cause problem in some\n      video readers.\n\n    audiofile\n      Optional: The name of an audio file that will be incorporated\n      to the video.\n\n    preset\n      Sets the time that FFMPEG will take to compress the video. The slower,\n      the better the compression rate. Possibilities are: ultrafast,superfast,\n      veryfast, faster, fast, medium (default), slow, slower, veryslow,\n      placebo.\n\n    bitrate\n      Only relevant for codecs which accept a bitrate. ""5000k"" offers\n      nice results in general.\n\n    withmask\n      Boolean. Set to ``True`` if there is a mask in the video to be\n      encoded.\n\n    """"""\n\n    def __init__(self, filename, size, fps, codec=""libx264"", audiofile=None,\n                 preset=""medium"", bitrate=None, withmask=False,\n                 logfile=None, threads=None, ffmpeg_params=None):\n\n        if logfile is None:\n            logfile = sp.PIPE\n\n        self.filename = filename\n        self.codec = codec\n        self.ext = self.filename.split(""."")[-1]\n\n        # order is important\n        cmd = [\n            get_setting(""FFMPEG_BINARY""),\n            \'-y\',\n            \'-loglevel\', \'error\' if logfile == sp.PIPE else \'info\',\n            \'-f\', \'rawvideo\',\n            \'-vcodec\', \'rawvideo\',\n            \'-s\', \'%dx%d\' % (size[0], size[1]),\n            \'-pix_fmt\', \'rgba\' if withmask else \'rgb24\',\n            \'-r\', \'%.02f\' % fps,\n            \'-i\', \'-\', \'-an\',\n        ]\n        if audiofile is not None:\n            cmd.extend([\n                \'-i\', audiofile,\n                \'-acodec\', \'copy\'\n            ])\n        cmd.extend([\n            \'-vcodec\', codec,\n            \'-preset\', preset,\n        ])\n        if ffmpeg_params is not None:\n            cmd.extend(ffmpeg_params)\n        if bitrate is not None:\n            cmd.extend([\n                \'-b\', bitrate\n            ])\n\n        if threads is not None:\n            cmd.extend([""-threads"", str(threads)])\n\n        if ((codec == \'libx264\') and\n                (size[0] % 2 == 0) and\n                (size[1] % 2 == 0)):\n            cmd.extend([\n                \'-pix_fmt\', \'yuv420p\'\n            ])\n        cmd.extend([\n            filename\n        ])\n\n        popen_params = {""stdout"": DEVNULL,\n                        ""stderr"": logfile,\n                        ""stdin"": sp.PIPE}\n\n        # This was added so that no extra unwanted window opens on windows\n        # when the child process is created\n        if os.name == ""nt"":\n            popen_params[""creationflags""] = 0x08000000\n        \n        self.proc = sp.Popen(cmd, **popen_params)\n\n\n    def write_frame(self, img_array):\n        """""" Writes one frame in the file.""""""\n        try:\n            self.proc.stdin.write(img_array.tostring())\n        except IOError as err:\n            ffmpeg_error = self.proc.stderr.read().decode()\n            error = (str(err) + (""\\n\\nMoviePy error: FFMPEG encountered ""\n                                 ""the following error while writing file %s:""\n                                 ""\\n\\n %s"" % (self.filename, ffmpeg_error)))\n\n            if ""Unknown encoder"" in ffmpeg_error:\n\n                error = error+(""\\n\\nThe video export ""\n                  ""failed because FFMPEG didn\'t find the specified ""\n                  ""codec for video encoding (%s). Please install ""\n                  ""this codec or change the codec when calling ""\n                  ""write_videofile. For instance:\\n""\n                  ""  >>> clip.write_videofile(\'myvid.webm\', codec=\'libvpx\')"")%(self.codec)\n\n            elif ""incorrect codec parameters ?"" in ffmpeg_error:\n\n                 error = error+(""\\n\\nThe video export ""\n                  ""failed, possibly because the codec specified for ""\n                  ""the video (%s) is not compatible with the given ""\n                  ""extension (%s). Please specify a valid \'codec\' ""\n                  ""argument in write_videofile. This would be \'libx264\' ""\n                  ""or \'mpeg4\' for mp4, \'libtheora\' for ogv, \'libvpx for webm. ""\n                  ""Another possible reason is that the audio codec was not ""\n                  ""compatible with the video codec. For instance the video ""\n                  ""extensions \'ogv\' and \'webm\' only allow \'libvorbis\' (default) as a""\n                  ""video codec.""\n                  )%(self.codec, self.ext)\n\n            elif  ""encoder setup failed"" in ffmpeg_error:\n\n                error = error+(""\\n\\nThe video export ""\n                  ""failed, possibly because the bitrate you specified ""\n                  ""was too high or too low for the video codec."")\n\n            elif ""Invalid encoder type"" in ffmpeg_error:\n\n                error = error + (""\\n\\nThe video export failed because the codec ""\n                  ""or file extension you provided is not a video"")\n\n\n            raise IOError(error)\n\n    def close(self):\n        self.proc.stdin.close()\n        if self.proc.stderr is not None:\n            self.proc.stderr.close()\n        self.proc.wait()\n\n        del self.proc\n\ndef ffmpeg_write_video(clip, filename, fps, codec=""libx264"", bitrate=None,\n                       preset=""medium"", withmask=False, write_logfile=False,\n                       audiofile=None, verbose=True, threads=None, ffmpeg_params=None):\n    """""" Write the clip to a videofile. See VideoClip.write_videofile for details\n    on the parameters.\n    """"""\n    if write_logfile:\n        logfile = open(filename + "".log"", \'w+\')\n    else:\n        logfile = None\n\n    verbose_print(verbose, ""[MoviePy] Writing video %s\\n""%filename)\n    writer = FFMPEG_VideoWriter(filename, clip.size, fps, codec = codec,\n                                preset=preset, bitrate=bitrate, logfile=logfile,\n                                audiofile=audiofile, threads=threads,\n                                ffmpeg_params=ffmpeg_params)\n\n    nframes = int(clip.duration*fps)\n\n    for t,frame in clip.iter_frames(progress_bar=True, with_times=True,\n                                    fps=fps, dtype=""uint8""):\n        if withmask:\n            mask = (255*clip.mask.get_frame(t))\n            if mask.dtype != ""uint8"":\n                mask = mask.astype(""uint8"")\n            frame = np.dstack([frame,mask])\n        \n        writer.write_frame(frame)\n\n    writer.close()\n\n    if write_logfile:\n        logfile.close()\n\n    verbose_print(verbose, ""[MoviePy] Done.\\n"")\n\n\ndef ffmpeg_write_image(filename, image, logfile=False):\n    """""" Writes an image (HxWx3 or HxWx4 numpy array) to a file, using\n        ffmpeg. """"""\n    \n    if image.dtype != \'uint8\':\n          image = image.astype(""uint8"")\n\n    cmd = [ get_setting(""FFMPEG_BINARY""), \'-y\',\n           \'-s\', ""%dx%d""%(image.shape[:2][::-1]),\n           ""-f"", \'rawvideo\',\n           \'-pix_fmt\', ""rgba"" if (image.shape[2] == 4) else ""rgb24"",\n           \'-i\',\'-\', filename]\n\n    if logfile:\n        log_file = open(filename + "".log"", \'w+\')\n    else:\n        log_file = sp.PIPE\n\n    popen_params = {""stdout"": DEVNULL,\n                    ""stderr"": log_file,\n                    ""stdin"": sp.PIPE}\n\n    if os.name == ""nt"":\n        popen_params[""creationflags""] = 0x08000000\n\n    proc = sp.Popen(cmd, **popen_params)\n    out, err = proc.communicate(image.tostring())\n\n    if proc.returncode:\n        err = ""\\n"".join([""[MoviePy] Running : %s\\n"" % cmd,\n                         ""WARNING: this command returned an error:"",\n                         err.decode(\'utf8\')])\n        raise IOError(err)\n\n    del proc\n'"
glumpy/ext/glfw.py,0,"b'# -*- coding: utf-8 -*-\n\n# -----------------------------------------------------------------------------\n#  GLFW - An OpenGL framework\n#  API version: 3.0.1\n#  WWW:         http://www.glfw.org/\n#  ----------------------------------------------------------------------------\n#  Copyright (c) 2002-2006 Marcus Geelnard\n#  Copyright (c) 2006-2010 Camilla Berglund\n#\n#  Python bindings - Copyright (c) 2013 Nicolas P. Rougier\n#\n#  This software is provided \'as-is\', without any express or implied\n#  warranty. In no event will the authors be held liable for any damages\n#  arising from the use of this software.\n#\n#  Permission is granted to anyone to use this software for any purpose,\n#  including commercial applications, and to alter it and redistribute it\n#  freely, subject to the following restrictions:\n#\n#  1. The origin of this software must not be misrepresented; you must not\n#     claim that you wrote the original software. If you use this software\n#     in a product, an acknowledgment in the product documentation would\n#     be appreciated but is not required.\n#\n#  2. Altered source versions must be plainly marked as such, and must not\n#     be misrepresented as being the original software.\n#\n#  3. This notice may not be removed or altered from any source\n#     distribution.\n#\n# -----------------------------------------------------------------------------\n\n# NOTE:\n# This source has been modified from its original form by the vispy dev team\n\nimport glob\nimport os\nimport subprocess\nimport sys\nimport textwrap\nimport ctypes.util\nfrom ctypes import (Structure, POINTER, CFUNCTYPE, byref, c_char_p, c_int,\n                    c_uint, c_double, c_float, c_ushort)\n\n\ndef _find_library_candidates(library_names,\n                             library_file_extensions,\n                             library_search_paths):\n    """"""\n    Finds and returns filenames which might be the library you are looking for.\n    """"""\n    candidates = set()\n    for library_name in library_names:\n        for search_path in library_search_paths:\n            glob_query = os.path.join(search_path, \'*\'+library_name+\'*\')\n            for filename in glob.iglob(glob_query):\n                filename = os.path.realpath(filename)\n                if filename in candidates:\n                    continue\n                basename = os.path.basename(filename)\n                if basename.startswith(\'lib\'+library_name):\n                    basename_end = basename[len(\'lib\'+library_name):]\n                elif basename.startswith(library_name):\n                    basename_end = basename[len(library_name):]\n                else:\n                    continue\n                for file_extension in library_file_extensions:\n                    if basename_end.startswith(file_extension):\n                        if basename_end[len(file_extension):][:1] in (\'\', \'.\'):\n                            candidates.add(filename)\n                    if basename_end.endswith(file_extension):\n                        basename_middle = basename_end[:-len(file_extension)]\n                        if all(c in \'0123456789.\' for c in basename_middle):\n                            candidates.add(filename)\n    return candidates\n\n\ndef _load_library(library_names, library_file_extensions,\n                  library_search_paths, version_check_callback):\n    """"""\n    Finds, loads and returns the most recent version of the library.\n    """"""\n    candidates = _find_library_candidates(library_names,\n                                          library_file_extensions,\n                                          library_search_paths)\n    library_versions = []\n    for filename in candidates:\n        version = version_check_callback(filename)\n        if version is not None and version >= (3, 0, 0):\n            library_versions.append((version, filename))\n\n    if not library_versions:\n        return None\n    library_versions.sort()\n    return ctypes.CDLL(library_versions[-1][1])\n\n\ndef _glfw_get_version(filename):\n    """"""\n    Queries and returns the library version tuple or None by using a\n    subprocess.\n    """"""\n    version_checker_source = \'\'\'\n        import sys\n        import ctypes\n        def get_version(library_handle):\n            """"""\n            Queries and returns the library version tuple or None.\n            """"""\n            major_value = ctypes.c_int(0)\n            major = ctypes.pointer(major_value)\n            minor_value = ctypes.c_int(0)\n            minor = ctypes.pointer(minor_value)\n            rev_value = ctypes.c_int(0)\n            rev = ctypes.pointer(rev_value)\n            if hasattr(library_handle, \'glfwGetVersion\'):\n                library_handle.glfwGetVersion(major, minor, rev)\n                version = (major_value.value,\n                           minor_value.value,\n                           rev_value.value)\n                return version\n            else:\n                return None\n        try:\n            input_func = raw_input\n        except NameError:\n            input_func = input\n        filename = input_func().strip()\n        try:\n            library_handle = ctypes.CDLL(filename)\n        except OSError:\n            pass\n        else:\n            version = get_version(library_handle)\n            print(version)\n    \'\'\'\n\n    args = [sys.executable, \'-c\', textwrap.dedent(version_checker_source)]\n    process = subprocess.Popen(args, universal_newlines=True,\n                               stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n    out = process.communicate(filename)[0]\n    out = out.strip()\n    if out:\n        return eval(out)\n    else:\n        return None\n\n\ndef _get_library_search_paths():\n    """"""\n    Returns a list of library search paths, considering of the current working\n    directory, default paths and paths from environment variables.\n    """"""\n    search_paths = [\n        \'\',\n        \'/usr/lib64\',\n        \'/usr/local/lib64\',\n        \'/usr/lib\', \'/usr/local/lib\',\n        \'/run/current-system/sw/lib\',\n        \'/usr/lib/x86_64-linux-gnu/\'\n    ]\n\n    if sys.platform == \'darwin\':\n        path_environment_variable = \'DYLD_LIBRARY_PATH\'\n    else:\n        path_environment_variable = \'LD_LIBRARY_PATH\'\n    if path_environment_variable in os.environ:\n        search_paths.extend(os.environ[path_environment_variable].split(\':\'))\n    return search_paths\n\nif os.environ.get(\'PYGLFW_LIBRARY\', \'\'):\n    try:\n        _glfw = ctypes.CDLL(os.environ[\'PYGLFW_LIBRARY\'])\n    except OSError:\n        _glfw = None\nelif sys.platform == \'win32\':\n    # only try glfw3.dll on windows\n    try:\n        _glfw = ctypes.CDLL(\'glfw3.dll\')\n    except OSError:\n        _glfw = None\nelse:\n    _glfw = _load_library([\'glfw\', \'glfw3\'], [\'.so\', \'.dylib\'],\n                          _get_library_search_paths(), _glfw_get_version)\n\nif _glfw is None:\n    raise ImportError(""Failed to load GLFW3 shared library."")\n\n\n# Load it\n# _glfw = ctypes.CDLL(_glfw_file)\n\n\n# Ensure it\'s new enough\ndef glfwGetVersion():\n    major, minor, rev = c_int(0), c_int(0), c_int(0)\n    _glfw.glfwGetVersion(byref(major), byref(minor), byref(rev))\n    return major.value, minor.value, rev.value\n\nversion = glfwGetVersion()\n\nif version[0] != 3:\n    version = \'.\'.join([str(v) for v in version])\n    raise OSError(\'Need GLFW library version 3, found version %s\' % version)\n\n\n# --- Version -----------------------------------------------------------------\nGLFW_VERSION_MAJOR      = version[0]\nGLFW_VERSION_MINOR      = version[1]\nGLFW_VERSION_REVISION   = version[2]\n__version__ = GLFW_VERSION_MAJOR, GLFW_VERSION_MINOR, GLFW_VERSION_REVISION\n\n# --- Input handling definitions ----------------------------------------------\nGLFW_RELEASE            = 0\nGLFW_PRESS              = 1\nGLFW_REPEAT             = 2\n\n# --- Keys --------------------------------------------------------------------\n\n# --- The unknown key ---------------------------------------------------------\nGLFW_KEY_UNKNOWN          = -1\n\n# --- Printable keys ----------------------------------------------------------\nGLFW_KEY_SPACE            = 32\nGLFW_KEY_APOSTROPHE       = 39 # \'\'\nGLFW_KEY_COMMA            = 44 # ,\nGLFW_KEY_MINUS            = 45 # -\nGLFW_KEY_PERIOD           = 46 # .\nGLFW_KEY_SLASH            = 47 # /\nGLFW_KEY_0                = 48\nGLFW_KEY_1                = 49\nGLFW_KEY_2                = 50\nGLFW_KEY_3                = 51\nGLFW_KEY_4                = 52\nGLFW_KEY_5                = 53\nGLFW_KEY_6                = 54\nGLFW_KEY_7                = 55\nGLFW_KEY_8                = 56\nGLFW_KEY_9                = 57\nGLFW_KEY_SEMICOLON        = 59 # ;\nGLFW_KEY_EQUAL            = 61 # =\nGLFW_KEY_A                = 65\nGLFW_KEY_B                = 66\nGLFW_KEY_C                = 67\nGLFW_KEY_D                = 68\nGLFW_KEY_E                = 69\nGLFW_KEY_F                = 70\nGLFW_KEY_G                = 71\nGLFW_KEY_H                = 72\nGLFW_KEY_I                = 73\nGLFW_KEY_J                = 74\nGLFW_KEY_K                = 75\nGLFW_KEY_L                = 76\nGLFW_KEY_M                = 77\nGLFW_KEY_N                = 78\nGLFW_KEY_O                = 79\nGLFW_KEY_P                = 80\nGLFW_KEY_Q                = 81\nGLFW_KEY_R                = 82\nGLFW_KEY_S                = 83\nGLFW_KEY_T                = 84\nGLFW_KEY_U                = 85\nGLFW_KEY_V                = 86\nGLFW_KEY_W                = 87\nGLFW_KEY_X                = 88\nGLFW_KEY_Y                = 89\nGLFW_KEY_Z                = 90\nGLFW_KEY_LEFT_BRACKET     = 91  # [\nGLFW_KEY_BACKSLASH        = 92  # \\\nGLFW_KEY_RIGHT_BRACKET    = 93  # ]\nGLFW_KEY_GRAVE_ACCENT     = 96  # `\nGLFW_KEY_WORLD_1          = 161 # non-US #1\nGLFW_KEY_WORLD_2          = 162 # non-US #2\n\n# --- Function keys -----------------------------------------------------------\nGLFW_KEY_ESCAPE           = 256\nGLFW_KEY_ENTER            = 257\nGLFW_KEY_TAB              = 258\nGLFW_KEY_BACKSPACE        = 259\nGLFW_KEY_INSERT           = 260\nGLFW_KEY_DELETE           = 261\nGLFW_KEY_RIGHT            = 262\nGLFW_KEY_LEFT             = 263\nGLFW_KEY_DOWN             = 264\nGLFW_KEY_UP               = 265\nGLFW_KEY_PAGE_UP          = 266\nGLFW_KEY_PAGE_DOWN        = 267\nGLFW_KEY_HOME             = 268\nGLFW_KEY_END              = 269\nGLFW_KEY_CAPS_LOCK        = 280\nGLFW_KEY_SCROLL_LOCK      = 281\nGLFW_KEY_NUM_LOCK         = 282\nGLFW_KEY_PRINT_SCREEN     = 283\nGLFW_KEY_PAUSE            = 284\nGLFW_KEY_F1               = 290\nGLFW_KEY_F2               = 291\nGLFW_KEY_F3               = 292\nGLFW_KEY_F4               = 293\nGLFW_KEY_F5               = 294\nGLFW_KEY_F6               = 295\nGLFW_KEY_F7               = 296\nGLFW_KEY_F8               = 297\nGLFW_KEY_F9               = 298\nGLFW_KEY_F10              = 299\nGLFW_KEY_F11              = 300\nGLFW_KEY_F12              = 301\nGLFW_KEY_F13              = 302\nGLFW_KEY_F14              = 303\nGLFW_KEY_F15              = 304\nGLFW_KEY_F16              = 305\nGLFW_KEY_F17              = 306\nGLFW_KEY_F18              = 307\nGLFW_KEY_F19              = 308\nGLFW_KEY_F20              = 309\nGLFW_KEY_F21              = 310\nGLFW_KEY_F22              = 311\nGLFW_KEY_F23              = 312\nGLFW_KEY_F24              = 313\nGLFW_KEY_F25              = 314\nGLFW_KEY_KP_0             = 320\nGLFW_KEY_KP_1             = 321\nGLFW_KEY_KP_2             = 322\nGLFW_KEY_KP_3             = 323\nGLFW_KEY_KP_4             = 324\nGLFW_KEY_KP_5             = 325\nGLFW_KEY_KP_6             = 326\nGLFW_KEY_KP_7             = 327\nGLFW_KEY_KP_8             = 328\nGLFW_KEY_KP_9             = 329\nGLFW_KEY_KP_DECIMAL       = 330\nGLFW_KEY_KP_DIVIDE        = 331\nGLFW_KEY_KP_MULTIPLY      = 332\nGLFW_KEY_KP_SUBTRACT      = 333\nGLFW_KEY_KP_ADD           = 334\nGLFW_KEY_KP_ENTER         = 335\nGLFW_KEY_KP_EQUAL         = 336\nGLFW_KEY_LEFT_SHIFT       = 340\nGLFW_KEY_LEFT_CONTROL     = 341\nGLFW_KEY_LEFT_ALT         = 342\nGLFW_KEY_LEFT_SUPER       = 343\nGLFW_KEY_RIGHT_SHIFT      = 344\nGLFW_KEY_RIGHT_CONTROL    = 345\nGLFW_KEY_RIGHT_ALT        = 346\nGLFW_KEY_RIGHT_SUPER      = 347\nGLFW_KEY_MENU             = 348\nGLFW_KEY_LAST             = GLFW_KEY_MENU\n\n\n# --- Modifiers ---------------------------------------------------------------\nGLFW_MOD_SHIFT            = 0x0001\nGLFW_MOD_CONTROL          = 0x0002\nGLFW_MOD_ALT              = 0x0004\nGLFW_MOD_SUPER            = 0x0008\n\n# --- Mouse -------------------------------------------------------------------\nGLFW_MOUSE_BUTTON_1       = 0\nGLFW_MOUSE_BUTTON_2       = 1\nGLFW_MOUSE_BUTTON_3       = 2\nGLFW_MOUSE_BUTTON_4       = 3\nGLFW_MOUSE_BUTTON_5       = 4\nGLFW_MOUSE_BUTTON_6       = 5\nGLFW_MOUSE_BUTTON_7       = 6\nGLFW_MOUSE_BUTTON_8       = 7\nGLFW_MOUSE_BUTTON_LAST    = GLFW_MOUSE_BUTTON_8\nGLFW_MOUSE_BUTTON_LEFT    = GLFW_MOUSE_BUTTON_1\nGLFW_MOUSE_BUTTON_RIGHT   = GLFW_MOUSE_BUTTON_2\nGLFW_MOUSE_BUTTON_MIDDLE  = GLFW_MOUSE_BUTTON_3\n\n\n# --- Joystick ----------------------------------------------------------------\nGLFW_JOYSTICK_1           = 0\nGLFW_JOYSTICK_2           = 1\nGLFW_JOYSTICK_3           = 2\nGLFW_JOYSTICK_4           = 3\nGLFW_JOYSTICK_5           = 4\nGLFW_JOYSTICK_6           = 5\nGLFW_JOYSTICK_7           = 6\nGLFW_JOYSTICK_8           = 7\nGLFW_JOYSTICK_9           = 8\nGLFW_JOYSTICK_10          = 9\nGLFW_JOYSTICK_11          = 10\nGLFW_JOYSTICK_12          = 11\nGLFW_JOYSTICK_13          = 12\nGLFW_JOYSTICK_14          = 13\nGLFW_JOYSTICK_15          = 14\nGLFW_JOYSTICK_16          = 15\nGLFW_JOYSTICK_LAST        = GLFW_JOYSTICK_16\n\n\n# --- Error codes -------------------------------------------------------------\nGLFW_NOT_INITIALIZED        = 0x00010001\nGLFW_NO_CURRENT_CONTEXT     = 0x00010002\nGLFW_INVALID_ENUM           = 0x00010003\nGLFW_INVALID_VALUE          = 0x00010004\nGLFW_OUT_OF_MEMORY          = 0x00010005\nGLFW_API_UNAVAILABLE        = 0x00010006\nGLFW_VERSION_UNAVAILABLE    = 0x00010007\nGLFW_PLATFORM_ERROR         = 0x00010008\nGLFW_FORMAT_UNAVAILABLE     = 0x00010009\n\n# ---\nGLFW_FOCUSED                = 0x00020001\nGLFW_ICONIFIED              = 0x00020002\nGLFW_RESIZABLE              = 0x00020003\nGLFW_VISIBLE                = 0x00020004\nGLFW_DECORATED              = 0x00020005\n\n# ---\nGLFW_RED_BITS               = 0x00021001\nGLFW_GREEN_BITS             = 0x00021002\nGLFW_BLUE_BITS              = 0x00021003\nGLFW_ALPHA_BITS             = 0x00021004\nGLFW_DEPTH_BITS             = 0x00021005\nGLFW_STENCIL_BITS           = 0x00021006\nGLFW_ACCUM_RED_BITS         = 0x00021007\nGLFW_ACCUM_GREEN_BITS       = 0x00021008\nGLFW_ACCUM_BLUE_BITS        = 0x00021009\nGLFW_ACCUM_ALPHA_BITS       = 0x0002100A\nGLFW_AUX_BUFFERS            = 0x0002100B\nGLFW_STEREO                 = 0x0002100C\nGLFW_SAMPLES                = 0x0002100D\nGLFW_SRGB_CAPABLE           = 0x0002100E\nGLFW_REFRESH_RATE           = 0x0002100F\n\n# ---\nGLFW_CLIENT_API             = 0x00022001\nGLFW_CONTEXT_VERSION_MAJOR  = 0x00022002\nGLFW_CONTEXT_VERSION_MINOR  = 0x00022003\nGLFW_CONTEXT_REVISION       = 0x00022004\nGLFW_CONTEXT_ROBUSTNESS     = 0x00022005\nGLFW_OPENGL_FORWARD_COMPAT  = 0x00022006\nGLFW_OPENGL_DEBUG_CONTEXT   = 0x00022007\nGLFW_OPENGL_PROFILE         = 0x00022008\n\n# ---\nGLFW_OPENGL_API             = 0x00030001\nGLFW_OPENGL_ES_API          = 0x00030002\n\n# ---\nGLFW_NO_ROBUSTNESS          =          0\nGLFW_NO_RESET_NOTIFICATION  = 0x00031001\nGLFW_LOSE_CONTEXT_ON_RESET  = 0x00031002\n\n# ---\nGLFW_OPENGL_ANY_PROFILE     =          0\nGLFW_OPENGL_CORE_PROFILE    = 0x00032001\nGLFW_OPENGL_COMPAT_PROFILE  = 0x00032002\n\n# ---\nGLFW_CURSOR                 = 0x00033001\nGLFW_STICKY_KEYS            = 0x00033002\nGLFW_STICKY_MOUSE_BUTTONS   = 0x00033003\n\n# ---\nGLFW_CURSOR_NORMAL          = 0x00034001\nGLFW_CURSOR_HIDDEN          = 0x00034002\nGLFW_CURSOR_DISABLED        = 0x00034003\n\n# ---\nGLFW_CONNECTED              = 0x00040001\nGLFW_DISCONNECTED           = 0x00040002\n\n\n# --- Structures --------------------------------------------------------------\nclass GLFWvidmode(Structure):\n    _fields_ = [ (\'width\',       c_int),\n                 (\'height\',      c_int),\n                 (\'redBits\',     c_int),\n                 (\'greenBits\',   c_int),\n                 (\'blueBits\',    c_int),\n                 (\'refreshRate\', c_int) ]\n\nclass GLFWgammaramp(Structure):\n    _fields_ = [ (\'red\',     POINTER(c_ushort)),\n                 (\'green\',   POINTER(c_ushort)),\n                 (\'blue\',    POINTER(c_ushort)),\n                 (\'size\',    c_int) ]\n\nclass GLFWwindow(Structure): pass\nclass GLFWmonitor(Structure): pass\n\n# --- Callbacks ---------------------------------------------------------------\nerrorfun           = CFUNCTYPE(None, c_int, c_char_p)\nwindowposfun       = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int)\nwindowsizefun      = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int)\nwindowclosefun     = CFUNCTYPE(None, POINTER(GLFWwindow))\nwindowrefreshfun   = CFUNCTYPE(None, POINTER(GLFWwindow))\nwindowfocusfun     = CFUNCTYPE(None, POINTER(GLFWwindow), c_int)\nwindowiconifyfun   = CFUNCTYPE(None, POINTER(GLFWwindow), c_int)\nframebuffersizefun = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int)\nmousebuttonfun     = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int, c_int)\ncursorposfun       = CFUNCTYPE(None, POINTER(GLFWwindow), c_double, c_double)\ncursorenterfun     = CFUNCTYPE(None, POINTER(GLFWwindow), c_int)\nscrollfun          = CFUNCTYPE(None, POINTER(GLFWwindow), c_double, c_double)\nkeyfun             = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int, c_int, c_int)\ncharfun            = CFUNCTYPE(None, POINTER(GLFWwindow), c_uint)\nmonitorfun         = CFUNCTYPE(None, POINTER(GLFWmonitor), c_int)\n\n# --- Init --------------------------------------------------------------------\nglfwInit                        = _glfw.glfwInit\nglfwTerminate                   = _glfw.glfwTerminate\n#glfwGetVersion                 = _glfw.glfwGetVersion\n\n# --- Error -------------------------------------------------------------------\n# glfwSetErrorCallback            = _glfw.glfwSetErrorCallback\n\n# --- Monitor -----------------------------------------------------------------\n# glfwGetMonitors                 = _glfw.glfwGetMonitors\n# glfwGetMonitors.restype         = POINTER(GLFWmonitor)\nglfwGetPrimaryMonitor           = _glfw.glfwGetPrimaryMonitor\nglfwGetPrimaryMonitor.restype   = POINTER(GLFWmonitor)\n\n# glfwGetMonitorPos               = _glfw.glfwGetMonitorPos\n# glfwGetMonitorPhysicalSize      = _glfw.glfwGetMonitorPhysicalSize\nglfwGetMonitorName              = _glfw.glfwGetMonitorName\nglfwGetMonitorName.restype = c_char_p\n# glfwSetMonitorCallback          = _glfw.glfwSetMonitorCallback\n# glfwGetVideoModes               = _glfw.glfwGetVideoModes\n# glfwGetVideoMode                = _glfw.glfwGetVideoMode\n\n# --- Gama --------------------------------------------------------------------\nglfwSetGamma                   = _glfw.glfwSetGamma\n# glfwGetGammaRamp               = _glfw.glfwGetGammaRamp\n# glfwSetGammaRamp               = _glfw.glfwSetGammaRamp\n\n# --- Window ------------------------------------------------------------------\nglfwDefaultWindowHints         = _glfw.glfwDefaultWindowHints\nglfwWindowHint                 = _glfw.glfwWindowHint\n# glfwCreateWindow              = _glfw.glfwCreateWindow\n# glfwDestroyWindow              = _glfw.glfwDestroyWindow\nglfwWindowShouldClose          = _glfw.glfwWindowShouldClose\nglfwSetWindowShouldClose       = _glfw.glfwSetWindowShouldClose\nglfwSetWindowTitle             = _glfw.glfwSetWindowTitle\n# glfwGetWindowPos              = _glfw.glfwGetWindowPos\nglfwSetWindowPos               = _glfw.glfwSetWindowPos\n# glfwGetWindowSize             = _glfw.glfwGetWindowSize\nglfwSetWindowSize              = _glfw.glfwSetWindowSize\n# glfwGetFramebufferSize        = _glfw.glfwGetFramebufferSize\nglfwIconifyWindow              = _glfw.glfwIconifyWindow\nglfwRestoreWindow              = _glfw.glfwRestoreWindow\nglfwShowWindow                 = _glfw.glfwShowWindow\nglfwHideWindow                 = _glfw.glfwHideWindow\nglfwGetWindowMonitor           = _glfw.glfwGetWindowMonitor\nglfwGetWindowAttrib            = _glfw.glfwGetWindowAttrib\nglfwSetWindowUserPointer       = _glfw.glfwSetWindowUserPointer\nglfwGetWindowUserPointer       = _glfw.glfwGetWindowUserPointer\n# glfwSetWindowPosCallback       = _glfw.glfwSetWindowPosCallback\n# glfwSetWindowSizeCallback      = _glfw.glfwSetWindowSizeCallback\n# glfwSetWindowCloseCallback     = _glfw.glfwSetWindowCloseCallback\n# glfwSetWindowRefreshCallback   = _glfw.glfwSetWindowRefreshCallback\n# glfwSetWindowFocusCallback     = _glfw.glfwSetWindowFocusCallback\n# glfwSetWindowIconifyCallback   = _glfw.glfwSetWindowIconifyCallback\n# glfwSetFramebufferSizeCallback = _glfw.glfwSetFramebufferSizeCallback\nglfwPollEvents                 = _glfw.glfwPollEvents\nglfwWaitEvents                 = _glfw.glfwWaitEvents\n\n# --- Input -------------------------------------------------------------------\nglfwGetInputMode               = _glfw.glfwGetInputMode\nglfwSetInputMode               = _glfw.glfwSetInputMode\nglfwGetKey                     = _glfw.glfwGetKey\nglfwGetMouseButton             = _glfw.glfwGetMouseButton\n# glfwGetCursorPos               = _glfw.glfwGetCursorPos\nglfwSetCursorPos               = _glfw.glfwSetCursorPos\n# glfwSetKeyCallback             = _glfw.glfwSetKeyCallback\n# glfwSetCharCallback            = _glfw.glfwSetCharCallback\n# glfwSetMouseButtonCallback     = _glfw.glfwSetMouseButtonCallback\n# glfwSetCursorPosCallback       = _glfw.glfwSetCursorPosCallback\n# glfwSetCursorEnterCallback     = _glfw.glfwSetCursorEnterCallback\n# glfwSetScrollCallback          = _glfw.glfwSetScrollCallback\nglfwJoystickPresent            = _glfw.glfwJoystickPresent\n# glfwGetJoystickAxes            = _glfw.glfwGetJoystickAxes\n# glfwGetJoystickButtons         = _glfw.glfwGetJoystickButtons\nglfwGetJoystickName            = _glfw.glfwGetJoystickName\nglfwGetJoystickName.restype = c_char_p\n\n# --- Clipboard ---------------------------------------------------------------\nglfwSetClipboardString         = _glfw.glfwSetClipboardString\nglfwGetClipboardString         = _glfw.glfwGetClipboardString\nglfwGetClipboardString.restype = c_char_p\n\n# --- Timer -------------------------------------------------------------------\nglfwGetTime                    = _glfw.glfwGetTime\nglfwGetTime.restype = c_double\nglfwSetTime                    = _glfw.glfwSetTime\n\n# --- Context -----------------------------------------------------------------\nglfwMakeContextCurrent         = _glfw.glfwMakeContextCurrent\nglfwGetCurrentContext          = _glfw.glfwGetCurrentContext\nglfwSwapBuffers                = _glfw.glfwSwapBuffers\nglfwSwapInterval               = _glfw.glfwSwapInterval\nglfwExtensionSupported         = _glfw.glfwExtensionSupported\nglfwGetProcAddress             = _glfw.glfwGetProcAddress\n\n\n\n# --- Pythonizer --------------------------------------------------------------\n\n# This keeps track of current windows\n__windows__ = []\n__destroyed__ = []\n\n# This is to prevent garbage collection on callbacks\n__c_callbacks__ = {}\n__py_callbacks__ = {}\n__c_error_callback__ = None\n\n\ndef glfwCreateWindow(width=640, height=480, title=""GLFW Window"",\n                     monitor=None, share=None):\n    _glfw.glfwCreateWindow.restype = POINTER(GLFWwindow)\n    if not isinstance(title,bytes):\n        title = title.encode(""ascii"")\n    window = _glfw.glfwCreateWindow(width,height,title,monitor,share)\n    __windows__.append(window)\n    __destroyed__.append(False)\n    index = __windows__.index(window)\n    __c_callbacks__[index] = {}\n    __py_callbacks__[index] = { \'errorfun\'           : None,\n                                \'monitorfun\'         : None,\n                                \'windowposfun\'       : None,\n                                \'windowsizefun\'      : None,\n                                \'windowclosefun\'     : None,\n                                \'windowrefreshfun\'   : None,\n                                \'windowfocusfun\'     : None,\n                                \'windowiconifyfun\'   : None,\n                                \'framebuffersizefun\' : None,\n                                \'keyfun\'             : None,\n                                \'charfun\'            : None,\n                                \'mousebuttonfun\'     : None,\n                                \'cursorposfun\'       : None,\n                                \'cursorenterfun\'     : None,\n                                \'scrollfun\'          : None }\n    return window\n\n\ndef glfwDestroyWindow(window):\n    index = __windows__.index(window)\n    if not __destroyed__[index]:\n        _glfw.glfwDestroyWindow(window)\n        # We do not delete window from the list (or it would impact numbering)\n        del __c_callbacks__[index]\n        del __py_callbacks__[index]\n        # del __windows__[index]\n    __destroyed__[index] = True\n\n\ndef glfwGetWindowPos(window):\n    xpos, ypos = c_int(0), c_int(0)\n    _glfw.glfwGetWindowPos(window, byref(xpos), byref(ypos))\n    return xpos.value, ypos.value\n\n\ndef glfwGetCursorPos(window):\n    xpos, ypos = c_double(0), c_double(0)\n    _glfw.glfwGetCursorPos(window, byref(xpos), byref(ypos))\n    return int(xpos.value), int(ypos.value)\n\n\ndef glfwGetWindowSize(window):\n    width, height = c_int(0), c_int(0)\n    _glfw.glfwGetWindowSize(window, byref(width), byref(height))\n    return width.value, height.value\n\n\ndef glfwGetFramebufferSize(window):\n    width, height = c_int(0), c_int(0)\n    _glfw.glfwGetFramebufferSize(window, byref(width), byref(height))\n    return width.value, height.value\n\n\ndef glfwGetMonitors():\n    count = c_int(0)\n    _glfw.glfwGetMonitors.restype = POINTER(POINTER(GLFWmonitor))\n    c_monitors = _glfw.glfwGetMonitors( byref(count) )\n    return [c_monitors[i] for i in range(count.value)]\n\n\ndef glfwGetVideoModes(monitor):\n    count = c_int(0)\n    _glfw.glfwGetVideoModes.restype = POINTER(GLFWvidmode)\n    c_modes = _glfw.glfwGetVideoModes( monitor, byref(count) )\n    modes = []\n    for i in range(count.value):\n        modes.append( (c_modes[i].width,\n                       c_modes[i].height,\n                       c_modes[i].redBits,\n                       c_modes[i].blueBits,\n                       c_modes[i].greenBits,\n                       c_modes[i].refreshRate ) )\n    return modes\n\n\ndef glfwGetMonitorPos(monitor):\n    xpos, ypos = c_int(0), c_int(0)\n    _glfw.glfwGetMonitorPos(monitor, byref(xpos), byref(ypos))\n    return xpos.value, ypos.value\n\n\ndef glfwGetMonitorPhysicalSize(monitor):\n    width, height = c_int(0), c_int(0)\n    _glfw.glfwGetMonitorPhysicalSize(monitor, byref(width), byref(height))\n    return width.value, height.value\n\n\ndef glfwGetVideoMode(monitor):\n    _glfw.glfwGetVideoMode.restype = POINTER(GLFWvidmode)\n    c_modes = _glfw.glfwGetVideoModes(monitor)\n    return (c_modes.width,\n            c_modes.height,\n            c_modes.redBits,\n            c_modes.blueBits,\n            c_modes.greenBits,\n            c_modes.refreshRate )\n\n\ndef GetGammaRamp(monitor):\n    _glfw.glfwGetGammaRamp.restype = POINTER(GLFWgammaramp)\n    c_gamma = _glfw.glfwGetGammaRamp(monitor).contents\n    gamma = {\'red\':[], \'green\':[], \'blue\':[]}\n    if c_gamma:\n        for i in range(c_gamma.size):\n            gamma[\'red\'].append(c_gamma.red[i])\n            gamma[\'green\'].append(c_gamma.green[i])\n            gamma[\'blue\'].append(c_gamma.blue[i])\n    return gamma\n\n\ndef glfwGetJoystickAxes(joy):\n    count = c_int(0)\n    _glfw.glfwGetJoystickAxes.restype = POINTER(c_float)\n    c_axes = _glfw.glfwGetJoystickAxes(joy, byref(count))\n    axes = [c_axes[i].value for i in range(count)]\n    return axes\n\n\ndef glfwGetJoystickButtons(joy):\n    count = c_int(0)\n    _glfw.glfwGetJoystickButtons.restype = POINTER(c_int)\n    c_buttons = _glfw.glfwGetJoystickButtons(joy, byref(count))\n    buttons = [c_buttons[i].value for i in range(count)]\n    return buttons\n\n\n# --- Callbacks ---------------------------------------------------------------\n\ndef __callback__(name):\n    callback = \'glfwSet%sCallback\' % name\n    fun      = \'%sfun\' % name.lower()\n    code = """"""\ndef %(callback)s(window, callback = None):\n    index = __windows__.index(window)\n    old_callback = __py_callbacks__[index][\'%(fun)s\']\n    __py_callbacks__[index][\'%(fun)s\'] = callback\n    if callback: callback = %(fun)s(callback)\n    __c_callbacks__[index][\'%(fun)s\'] = callback\n    _glfw.%(callback)s(window, callback)\n    return old_callback""""""  % {\'callback\': callback, \'fun\': fun}\n    return code\n\nexec(__callback__(\'Monitor\'))\nexec(__callback__(\'WindowPos\'))\nexec(__callback__(\'WindowSize\'))\nexec(__callback__(\'WindowClose\'))\nexec(__callback__(\'WindowRefresh\'))\nexec(__callback__(\'WindowFocus\'))\nexec(__callback__(\'WindowIconify\'))\nexec(__callback__(\'FramebufferSize\'))\nexec(__callback__(\'Key\'))\nexec(__callback__(\'Char\'))\nexec(__callback__(\'MouseButton\'))\nexec(__callback__(\'CursorPos\'))\nexec(__callback__(\'CursorEnter\'))\nexec(__callback__(\'Scroll\'))\n\n\n# Error callback does not take window parameter\ndef glfwSetErrorCallback(callback = None):\n    global __c_error_callback__\n    __c_error_callback__ = errorfun(callback)\n    _glfw.glfwSetErrorCallback(__c_error_callback__)\n'"
glumpy/ext/inputhook.py,0,"b'# coding: utf-8\n""""""\nInputhook management for GUI event loop integration.\n""""""\n\n#-----------------------------------------------------------------------------\n#  Copyright (C) 2008-2011  The IPython Development Team\n#\n#  Distributed under the terms of the BSD License.  The full license is in\n#  the file COPYING, distributed as part of this software.\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Imports\n#-----------------------------------------------------------------------------\n\ntry:\n    import ctypes\nexcept ImportError:\n    ctypes = None\nexcept SystemError: # IronPython issue, 2/8/2014\n    ctypes = None\nimport os\nimport sys\n\n\n#-----------------------------------------------------------------------------\n# Utilities\n#-----------------------------------------------------------------------------\n\ndef _stdin_ready_posix():\n    """"""Return True if there\'s something to read on stdin (posix version).""""""\n    infds, outfds, erfds = select.select([sys.stdin],[],[],0)\n    return bool(infds)\n\ndef _stdin_ready_nt():\n    """"""Return True if there\'s something to read on stdin (nt version).""""""\n    return msvcrt.kbhit()\n\ndef _stdin_ready_other():\n    """"""Return True, assuming there\'s something to read on stdin.""""""\n    return True #\n\n\ndef _ignore_CTRL_C_posix():\n    """"""Ignore CTRL+C (SIGINT).""""""\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\ndef _allow_CTRL_C_posix():\n    """"""Take CTRL+C into account (SIGINT).""""""\n    signal.signal(signal.SIGINT, signal.default_int_handler)\n\ndef _ignore_CTRL_C_other():\n    """"""Ignore CTRL+C (not implemented).""""""\n    pass\n\ndef _allow_CTRL_C_other():\n    """"""Take CTRL+C into account (not implemented).""""""\n    pass\n\nif os.name == \'posix\':\n    import select\n    import signal\n    stdin_ready = _stdin_ready_posix\n    ignore_CTRL_C = _ignore_CTRL_C_posix\n    allow_CTRL_C = _allow_CTRL_C_posix\nelif os.name == \'nt\':\n    import msvcrt\n    stdin_ready = _stdin_ready_nt\n    ignore_CTRL_C = _ignore_CTRL_C_other\n    allow_CTRL_C = _allow_CTRL_C_other\nelse:\n    stdin_ready = _stdin_ready_other\n    ignore_CTRL_C = _ignore_CTRL_C_other\n    allow_CTRL_C = _allow_CTRL_C_other\n\n\n#-----------------------------------------------------------------------------\n# Main InputHookManager class\n#-----------------------------------------------------------------------------\n\n\nclass InputHookManager(object):\n    """"""Manage PyOS_InputHook for different GUI toolkits.\n\n    This class installs various hooks under ``PyOSInputHook`` to handle\n    GUI event loop integration.\n    """"""\n\n    def __init__(self):\n        if ctypes is None:\n            warn(""IPython GUI event loop requires ctypes, %gui will not be available"")\n            return\n        self.PYFUNC = ctypes.PYFUNCTYPE(ctypes.c_int)\n        self._reset()\n\n    def _reset(self):\n        self._callback_pyfunctype = None\n        self._callback = None\n        self._installed = False\n\n    def get_pyos_inputhook(self):\n        """"""Return the current PyOS_InputHook as a ctypes.c_void_p.""""""\n        return ctypes.c_void_p.in_dll(ctypes.pythonapi,""PyOS_InputHook"")\n\n    def get_pyos_inputhook_as_func(self):\n        """"""Return the current PyOS_InputHook as a ctypes.PYFUNCYPE.""""""\n        return self.PYFUNC.in_dll(ctypes.pythonapi,""PyOS_InputHook"")\n\n    def set_inputhook(self, callback):\n        """"""Set PyOS_InputHook to callback and return the previous one.""""""\n        # On platforms with \'readline\' support, it\'s all too likely to\n        # have a KeyboardInterrupt signal delivered *even before* an\n        # initial ``try:`` clause in the callback can be executed, so\n        # we need to disable CTRL+C in this situation.\n        ignore_CTRL_C()\n        self._callback = callback\n        self._callback_pyfunctype = self.PYFUNC(callback)\n        pyos_inputhook_ptr = self.get_pyos_inputhook()\n        original = self.get_pyos_inputhook_as_func()\n        pyos_inputhook_ptr.value = \\\n            ctypes.cast(self._callback_pyfunctype, ctypes.c_void_p).value\n        self._installed = True\n        return original\n\n    def clear_inputhook(self, app=None):\n        """"""Set PyOS_InputHook to NULL and return the previous one.\n\n        Parameters\n        ----------\n        app : optional, ignored\n          This parameter is allowed only so that clear_inputhook() can be\n          called with a similar interface as all the ``enable_*`` methods.  But\n          the actual value of the parameter is ignored.  This uniform interface\n          makes it easier to have user-level entry points in the main IPython\n          app like :meth:`enable_gui`.""""""\n        pyos_inputhook_ptr = self.get_pyos_inputhook()\n        original = self.get_pyos_inputhook_as_func()\n        pyos_inputhook_ptr.value = ctypes.c_void_p(None).value\n        allow_CTRL_C()\n        self._reset()\n        return original\n\ninputhook_manager = InputHookManager()\n'"
glumpy/ext/png.py,0,"b'#!/usr/bin/env python\n\n# png.py - PNG encoder/decoder in pure Python\n#\n# Copyright (C) 2006 Johann C. Rocholl <johann@browsershots.org>\n# Portions Copyright (C) 2009 David Jones <drj@pobox.com>\n# And probably portions Copyright (C) 2006 Nicko van Someren <nicko@nicko.org>\n#\n# Original concept by Johann C. Rocholl.\n#\n# LICENCE (MIT)\n#\n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation files\n# (the ""Software""), to deal in the Software without restriction,\n# including without limitation the rights to use, copy, modify, merge,\n# publish, distribute, sublicense, and/or sell copies of the Software,\n# and to permit persons to whom the Software is furnished to do so,\n# subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\n""""""\nPure Python PNG Reader/Writer\n\nThis Python module implements support for PNG images (see PNG\nspecification at http://www.w3.org/TR/2003/REC-PNG-20031110/ ). It reads\nand writes PNG files with all allowable bit depths\n(1/2/4/8/16/24/32/48/64 bits per pixel) and colour combinations:\ngreyscale (1/2/4/8/16 bit); RGB, RGBA, LA (greyscale with alpha) with\n8/16 bits per channel; colour mapped images (1/2/4/8 bit).\nAdam7 interlacing is supported for reading and\nwriting.  A number of optional chunks can be specified (when writing)\nand understood (when reading): ``tRNS``, ``bKGD``, ``gAMA``.\n\nFor help, type ``import png; help(png)`` in your python interpreter.\n\nA good place to start is the :class:`Reader` and :class:`Writer`\nclasses.\n\nRequires Python 2.3.  Limited support is available for Python 2.2, but\nnot everything works.  Best with Python 2.4 and higher.  Installation is\ntrivial, but see the ``README.txt`` file (with the source distribution)\nfor details.\n\nThis file can also be used as a command-line utility to convert\n`Netpbm <http://netpbm.sourceforge.net/>`_ PNM files to PNG, and the\nreverse conversion from PNG to PNM. The interface is similar to that\nof the ``pnmtopng`` program from Netpbm.  Type ``python png.py --help``\nat the shell prompt for usage and a list of options.\n\nA note on spelling and terminology\n----------------------------------\n\nGenerally British English spelling is used in the documentation.  So\nthat\'s ""greyscale"" and ""colour"".  This not only matches the author\'s\nnative language, it\'s also used by the PNG specification.\n\nThe major colour models supported by PNG (and hence by PyPNG) are:\ngreyscale, RGB, greyscale--alpha, RGB--alpha.  These are sometimes\nreferred to using the abbreviations: L, RGB, LA, RGBA.  In this case\neach letter abbreviates a single channel: *L* is for Luminance or Luma\nor Lightness which is the channel used in greyscale images; *R*, *G*,\n*B* stand for Red, Green, Blue, the components of a colour image; *A*\nstands for Alpha, the opacity channel (used for transparency effects,\nbut higher values are more opaque, so it makes sense to call it \nopacity).\n\nA note on formats\n-----------------\n\nWhen getting pixel data out of this module (reading) and presenting\ndata to this module (writing) there are a number of ways the data could\nbe represented as a Python value.  Generally this module uses one of\nthree formats called ""flat row flat pixel"", ""boxed row flat pixel"", and\n""boxed row boxed pixel"".  Basically the concern is whether each pixel\nand each row comes in its own little tuple (box), or not.\n\nConsider an image that is 3 pixels wide by 2 pixels high, and each pixel\nhas RGB components:\n\nBoxed row flat pixel::\n\n  list([R,G,B, R,G,B, R,G,B],\n       [R,G,B, R,G,B, R,G,B])\n\nEach row appears as its own list, but the pixels are flattened so\nthat three values for one pixel simply follow the three values for\nthe previous pixel.  This is the most common format used, because it\nprovides a good compromise between space and convenience.  PyPNG regards\nitself as at liberty to replace any sequence type with any sufficiently\ncompatible other sequence type; in practice each row is an array (from\nthe array module), and the outer list is sometimes an iterator rather\nthan an explicit list (so that streaming is possible).\n\nFlat row flat pixel::\n\n  [R,G,B, R,G,B, R,G,B,\n   R,G,B, R,G,B, R,G,B]\n\nThe entire image is one single giant sequence of colour values.\nGenerally an array will be used (to save space), not a list.\n\nBoxed row boxed pixel::\n\n  list([ (R,G,B), (R,G,B), (R,G,B) ],\n       [ (R,G,B), (R,G,B), (R,G,B) ])\n\nEach row appears in its own list, but each pixel also appears in its own\ntuple.  A serious memory burn in Python.\n\nIn all cases the top row comes first, and for each row the pixels are\nordered from left-to-right.  Within a pixel the values appear in the\norder, R-G-B-A (or L-A for greyscale--alpha).\n\nThere is a fourth format, mentioned because it is used internally,\nis close to what lies inside a PNG file itself, and has some support\nfrom the public API.  This format is called packed.  When packed,\neach row is a sequence of bytes (integers from 0 to 255), just as\nit is before PNG scanline filtering is applied.  When the bit depth\nis 8 this is essentially the same as boxed row flat pixel; when the\nbit depth is less than 8, several pixels are packed into each byte;\nwhen the bit depth is 16 (the only value more than 8 that is supported\nby the PNG image format) each pixel value is decomposed into 2 bytes\n(and `packed` is a misnomer).  This format is used by the\n:meth:`Writer.write_packed` method.  It isn\'t usually a convenient\nformat, but may be just right if the source data for the PNG image\ncomes from something that uses a similar format (for example, 1-bit\nBMPs, or another PNG file).\n\nAnd now, my famous members\n--------------------------\n""""""\n\n# http://www.python.org/doc/2.2.3/whatsnew/node5.html\nfrom __future__ import generators\nfrom __future__ import print_function\n__version__ = ""0.0.17""\n\nfrom array import array\ntry: # See :pyver:old\n    import itertools\nexcept ImportError:\n    pass\nimport math\n# http://www.python.org/doc/2.4.4/lib/module-operator.html\nimport operator\nimport struct\nimport sys\nimport zlib\n# http://www.python.org/doc/2.4.4/lib/module-warnings.html\nimport warnings\ntry:\n    # `cpngfilters` is a Cython module: it must be compiled by\n    # Cython for this import to work.\n    # If this import does work, then it overrides pure-python\n    # filtering functions defined later in this file (see `class\n    # pngfilters`).\n    import cpngfilters as pngfilters\nexcept ImportError:\n    pass\n\n\n__all__ = [\'Image\', \'Reader\', \'Writer\', \'write_chunks\', \'from_array\']\n\n\n# The PNG signature.\n# http://www.w3.org/TR/PNG/#5PNG-file-signature\n_signature = struct.pack(\'8B\', 137, 80, 78, 71, 13, 10, 26, 10)\n\n_adam7 = ((0, 0, 8, 8),\n          (4, 0, 8, 8),\n          (0, 4, 4, 8),\n          (2, 0, 4, 4),\n          (0, 2, 2, 4),\n          (1, 0, 2, 2),\n          (0, 1, 1, 2))\n\ndef group(s, n):\n    # See http://www.python.org/doc/2.6/library/functions.html#zip\n    return zip(*[iter(s)]*n)\n\ndef isarray(x):\n    """"""Same as ``isinstance(x, array)`` except on Python 2.2, where it\n    always returns ``False``.  This helps PyPNG work on Python 2.2.\n    """"""\n\n    try:\n        return isinstance(x, array)\n    except TypeError:\n        # Because on Python 2.2 array.array is not a type.\n        return False\n\ntry:\n    array.tobytes\nexcept AttributeError:\n    try:  # see :pyver:old\n        array.tostring\n    except AttributeError:\n        def tostring(row):\n            l = len(row)\n            return struct.pack(\'%dB\' % l, *row)\n    else:\n        def tostring(row):\n            """"""Convert row of bytes to string.  Expects `row` to be an\n            ``array``.\n            """"""\n            return row.tostring()\nelse:\n    def tostring(row):\n        """""" Python3 definition, array.tostring() is deprecated in Python3\n        """"""\n        return row.tobytes()\n\n# Conditionally convert to bytes.  Works on Python 2 and Python 3.\ntry:\n    bytes(\'\', \'ascii\')\n    def strtobytes(x): return bytes(x, \'iso8859-1\')\n    def bytestostr(x): return str(x, \'iso8859-1\')\nexcept (NameError, TypeError):\n    # We get NameError when bytes() does not exist (most Python\n    # 2.x versions), and TypeError when bytes() exists but is on\n    # Python 2.x (when it is an alias for str() and takes at most\n    # one argument).\n    strtobytes = str\n    bytestostr = str\n\ndef interleave_planes(ipixels, apixels, ipsize, apsize):\n    """"""\n    Interleave (colour) planes, e.g. RGB + A = RGBA.\n\n    Return an array of pixels consisting of the `ipsize` elements of\n    data from each pixel in `ipixels` followed by the `apsize` elements\n    of data from each pixel in `apixels`.  Conventionally `ipixels`\n    and `apixels` are byte arrays so the sizes are bytes, but it\n    actually works with any arrays of the same type.  The returned\n    array is the same type as the input arrays which should be the\n    same type as each other.\n    """"""\n\n    itotal = len(ipixels)\n    atotal = len(apixels)\n    newtotal = itotal + atotal\n    newpsize = ipsize + apsize\n    # Set up the output buffer\n    # See http://www.python.org/doc/2.4.4/lib/module-array.html#l2h-1356\n    out = array(ipixels.typecode)\n    # It\'s annoying that there is no cheap way to set the array size :-(\n    out.extend(ipixels)\n    out.extend(apixels)\n    # Interleave in the pixel data\n    for i in range(ipsize):\n        out[i:newtotal:newpsize] = ipixels[i:itotal:ipsize]\n    for i in range(apsize):\n        out[i+ipsize:newtotal:newpsize] = apixels[i:atotal:apsize]\n    return out\n\ndef check_palette(palette):\n    """"""Check a palette argument (to the :class:`Writer` class)\n    for validity.  Returns the palette as a list if okay; raises an\n    exception otherwise.\n    """"""\n\n    # None is the default and is allowed.\n    if palette is None:\n        return None\n\n    p = list(palette)\n    if not (0 < len(p) <= 256):\n        raise ValueError(""a palette must have between 1 and 256 entries"")\n    seen_triple = False\n    for i,t in enumerate(p):\n        if len(t) not in (3,4):\n            raise ValueError(\n              ""palette entry %d: entries must be 3- or 4-tuples."" % i)\n        if len(t) == 3:\n            seen_triple = True\n        if seen_triple and len(t) == 4:\n            raise ValueError(\n              ""palette entry %d: all 4-tuples must precede all 3-tuples"" % i)\n        for x in t:\n            if int(x) != x or not(0 <= x <= 255):\n                raise ValueError(\n                  ""palette entry %d: values must be integer: 0 <= x <= 255"" % i)\n    return p\n\ndef check_sizes(size, width, height):\n    """"""Check that these arguments, in supplied, are consistent.\n    Return a (width, height) pair.\n    """"""\n\n    if not size:\n        return width, height\n\n    if len(size) != 2:\n        raise ValueError(\n          ""size argument should be a pair (width, height)"")\n    if width is not None and width != size[0]:\n        raise ValueError(\n          ""size[0] (%r) and width (%r) should match when both are used.""\n            % (size[0], width))\n    if height is not None and height != size[1]:\n        raise ValueError(\n          ""size[1] (%r) and height (%r) should match when both are used.""\n            % (size[1], height))\n    return size\n\ndef check_color(c, greyscale, which):\n    """"""Checks that a colour argument for transparent or\n    background options is the right form.  Returns the colour\n    (which, if it\'s a bar integer, is ""corrected"" to a 1-tuple).\n    """"""\n\n    if c is None:\n        return c\n    if greyscale:\n        try:\n            l = len(c)\n        except TypeError:\n            c = (c,)\n        if len(c) != 1:\n            raise ValueError(""%s for greyscale must be 1-tuple"" %\n                which)\n        if not isinteger(c[0]):\n            raise ValueError(\n                ""%s colour for greyscale must be integer"" % which)\n    else:\n        if not (len(c) == 3 and\n                isinteger(c[0]) and\n                isinteger(c[1]) and\n                isinteger(c[2])):\n            raise ValueError(\n                ""%s colour must be a triple of integers"" % which)\n    return c\n\nclass Error(Exception):\n    def __str__(self):\n        return self.__class__.__name__ + \': \' + \' \'.join(self.args)\n\nclass FormatError(Error):\n    """"""Problem with input file format.  In other words, PNG file does\n    not conform to the specification in some way and is invalid.\n    """"""\n\nclass ChunkError(FormatError):\n    pass\n\n\nclass Writer:\n    """"""\n    PNG encoder in pure Python.\n    """"""\n\n    def __init__(self, width=None, height=None,\n                 size=None,\n                 greyscale=False,\n                 alpha=False,\n                 bitdepth=8,\n                 palette=None,\n                 transparent=None,\n                 background=None,\n                 gamma=None,\n                 compression=None,\n                 interlace=False,\n                 bytes_per_sample=None, # deprecated\n                 planes=None,\n                 colormap=None,\n                 maxval=None,\n                 chunk_limit=2**20):\n        """"""\n        Create a PNG encoder object.\n\n        Arguments:\n\n        width, height\n          Image size in pixels, as two separate arguments.\n        size\n          Image size (w,h) in pixels, as single argument.\n        greyscale\n          Input data is greyscale, not RGB.\n        alpha\n          Input data has alpha channel (RGBA or LA).\n        bitdepth\n          Bit depth: from 1 to 16.\n        palette\n          Create a palette for a colour mapped image (colour type 3).\n        transparent\n          Specify a transparent colour (create a ``tRNS`` chunk).\n        background\n          Specify a default background colour (create a ``bKGD`` chunk).\n        gamma\n          Specify a gamma value (create a ``gAMA`` chunk).\n        compression\n          zlib compression level: 0 (none) to 9 (more compressed);\n          default: -1 or None.\n        interlace\n          Create an interlaced image.\n        chunk_limit\n          Write multiple ``IDAT`` chunks to save memory.\n\n        The image size (in pixels) can be specified either by using the\n        `width` and `height` arguments, or with the single `size`\n        argument.  If `size` is used it should be a pair (*width*,\n        *height*).\n\n        `greyscale` and `alpha` are booleans that specify whether\n        an image is greyscale (or colour), and whether it has an\n        alpha channel (or not).\n\n        `bitdepth` specifies the bit depth of the source pixel values.\n        Each source pixel value must be an integer between 0 and\n        ``2**bitdepth-1``.  For example, 8-bit images have values\n        between 0 and 255.  PNG only stores images with bit depths of\n        1,2,4,8, or 16.  When `bitdepth` is not one of these values,\n        the next highest valid bit depth is selected, and an ``sBIT``\n        (significant bits) chunk is generated that specifies the\n        original precision of the source image.  In this case the\n        supplied pixel values will be rescaled to fit the range of\n        the selected bit depth.\n\n        The details of which bit depth / colour model combinations the\n        PNG file format supports directly, are somewhat arcane\n        (refer to the PNG specification for full details).  Briefly:\n        ""small"" bit depths (1,2,4) are only allowed with greyscale and\n        colour mapped images; colour mapped images cannot have bit depth\n        16.\n\n        For colour mapped images (in other words, when the `palette`\n        argument is specified) the `bitdepth` argument must match one of\n        the valid PNG bit depths: 1, 2, 4, or 8.  (It is valid to have a\n        PNG image with a palette and an ``sBIT`` chunk, but the meaning\n        is slightly different; it would be awkward to press the\n        `bitdepth` argument into service for this.)\n\n        The `palette` option, when specified, causes a colour mapped\n        image to be created: the PNG colour type is set to 3; greyscale\n        must not be set; alpha must not be set; transparent must not be\n        set; the bit depth must be 1,2,4, or 8.  When a colour mapped\n        image is created, the pixel values are palette indexes and\n        the `bitdepth` argument specifies the size of these indexes\n        (not the size of the colour values in the palette).\n\n        The palette argument value should be a sequence of 3- or\n        4-tuples.  3-tuples specify RGB palette entries; 4-tuples\n        specify RGBA palette entries.  If both 4-tuples and 3-tuples\n        appear in the sequence then all the 4-tuples must come\n        before all the 3-tuples.  A ``PLTE`` chunk is created; if there\n        are 4-tuples then a ``tRNS`` chunk is created as well.  The\n        ``PLTE`` chunk will contain all the RGB triples in the same\n        sequence; the ``tRNS`` chunk will contain the alpha channel for\n        all the 4-tuples, in the same sequence.  Palette entries\n        are always 8-bit.\n\n        If specified, the `transparent` and `background` parameters must\n        be a tuple with three integer values for red, green, blue, or\n        a simple integer (or singleton tuple) for a greyscale image.\n\n        If specified, the `gamma` parameter must be a positive number\n        (generally, a float).  A ``gAMA`` chunk will be created.\n        Note that this will not change the values of the pixels as\n        they appear in the PNG file, they are assumed to have already\n        been converted appropriately for the gamma specified.\n\n        The `compression` argument specifies the compression level to\n        be used by the ``zlib`` module.  Values from 1 to 9 specify\n        compression, with 9 being ""more compressed"" (usually smaller\n        and slower, but it doesn\'t always work out that way).  0 means\n        no compression.  -1 and ``None`` both mean that the default\n        level of compession will be picked by the ``zlib`` module\n        (which is generally acceptable).\n\n        If `interlace` is true then an interlaced image is created\n        (using PNG\'s so far only interace method, *Adam7*).  This does\n        not affect how the pixels should be presented to the encoder,\n        rather it changes how they are arranged into the PNG file.\n        On slow connexions interlaced images can be partially decoded\n        by the browser to give a rough view of the image that is\n        successively refined as more image data appears.\n\n        .. note ::\n\n          Enabling the `interlace` option requires the entire image\n          to be processed in working memory.\n\n        `chunk_limit` is used to limit the amount of memory used whilst\n        compressing the image.  In order to avoid using large amounts of\n        memory, multiple ``IDAT`` chunks may be created.\n        """"""\n\n        # At the moment the `planes` argument is ignored;\n        # its purpose is to act as a dummy so that\n        # ``Writer(x, y, **info)`` works, where `info` is a dictionary\n        # returned by Reader.read and friends.\n        # Ditto for `colormap`.\n\n        width, height = check_sizes(size, width, height)\n        del size\n\n        if width <= 0 or height <= 0:\n            raise ValueError(""width and height must be greater than zero"")\n        if not isinteger(width) or not isinteger(height):\n            raise ValueError(""width and height must be integers"")\n        # http://www.w3.org/TR/PNG/#7Integers-and-byte-order\n        if width > 2**32-1 or height > 2**32-1:\n            raise ValueError(""width and height cannot exceed 2**32-1"")\n\n        if alpha and transparent is not None:\n            raise ValueError(\n                ""transparent colour not allowed with alpha channel"")\n\n        if bytes_per_sample is not None:\n            warnings.warn(\'please use bitdepth instead of bytes_per_sample\',\n                          DeprecationWarning)\n            if bytes_per_sample not in (0.125, 0.25, 0.5, 1, 2):\n                raise ValueError(\n                    ""bytes per sample must be .125, .25, .5, 1, or 2"")\n            bitdepth = int(8*bytes_per_sample)\n        del bytes_per_sample\n        if not isinteger(bitdepth) or bitdepth < 1 or 16 < bitdepth:\n            raise ValueError(""bitdepth (%r) must be a positive integer <= 16"" %\n              bitdepth)\n\n        self.rescale = None\n        if palette:\n            if bitdepth not in (1,2,4,8):\n                raise ValueError(""with palette, bitdepth must be 1, 2, 4, or 8"")\n            if transparent is not None:\n                raise ValueError(""transparent and palette not compatible"")\n            if alpha:\n                raise ValueError(""alpha and palette not compatible"")\n            if greyscale:\n                raise ValueError(""greyscale and palette not compatible"")\n        else:\n            # No palette, check for sBIT chunk generation.\n            if alpha or not greyscale:\n                if bitdepth not in (8,16):\n                    targetbitdepth = (8,16)[bitdepth > 8]\n                    self.rescale = (bitdepth, targetbitdepth)\n                    bitdepth = targetbitdepth\n                    del targetbitdepth\n            else:\n                assert greyscale\n                assert not alpha\n                if bitdepth not in (1,2,4,8,16):\n                    if bitdepth > 8:\n                        targetbitdepth = 16\n                    elif bitdepth == 3:\n                        targetbitdepth = 4\n                    else:\n                        assert bitdepth in (5,6,7)\n                        targetbitdepth = 8\n                    self.rescale = (bitdepth, targetbitdepth)\n                    bitdepth = targetbitdepth\n                    del targetbitdepth\n\n        if bitdepth < 8 and (alpha or not greyscale and not palette):\n            raise ValueError(\n              ""bitdepth < 8 only permitted with greyscale or palette"")\n        if bitdepth > 8 and palette:\n            raise ValueError(\n                ""bit depth must be 8 or less for images with palette"")\n\n        transparent = check_color(transparent, greyscale, \'transparent\')\n        background = check_color(background, greyscale, \'background\')\n\n        # It\'s important that the true boolean values (greyscale, alpha,\n        # colormap, interlace) are converted to bool because Iverson\'s\n        # convention is relied upon later on.\n        self.width = width\n        self.height = height\n        self.transparent = transparent\n        self.background = background\n        self.gamma = gamma\n        self.greyscale = bool(greyscale)\n        self.alpha = bool(alpha)\n        self.colormap = bool(palette)\n        self.bitdepth = int(bitdepth)\n        self.compression = compression\n        self.chunk_limit = chunk_limit\n        self.interlace = bool(interlace)\n        self.palette = check_palette(palette)\n\n        self.color_type = 4*self.alpha + 2*(not greyscale) + 1*self.colormap\n        assert self.color_type in (0,2,3,4,6)\n\n        self.color_planes = (3,1)[self.greyscale or self.colormap]\n        self.planes = self.color_planes + self.alpha\n        # :todo: fix for bitdepth < 8\n        self.psize = (self.bitdepth/8) * self.planes\n\n    def make_palette(self):\n        """"""Create the byte sequences for a ``PLTE`` and if necessary a\n        ``tRNS`` chunk.  Returned as a pair (*p*, *t*).  *t* will be\n        ``None`` if no ``tRNS`` chunk is necessary.\n        """"""\n\n        p = array(\'B\')\n        t = array(\'B\')\n\n        for x in self.palette:\n            p.extend(x[0:3])\n            if len(x) > 3:\n                t.append(x[3])\n        p = tostring(p)\n        t = tostring(t)\n        if t:\n            return p,t\n        return p,None\n\n    def write(self, outfile, rows):\n        """"""Write a PNG image to the output file.  `rows` should be\n        an iterable that yields each row in boxed row flat pixel\n        format.  The rows should be the rows of the original image,\n        so there should be ``self.height`` rows of ``self.width *\n        self.planes`` values.  If `interlace` is specified (when\n        creating the instance), then an interlaced PNG file will\n        be written.  Supply the rows in the normal image order;\n        the interlacing is carried out internally.\n\n        .. note ::\n\n          Interlacing will require the entire image to be in working\n          memory.\n        """"""\n\n        if self.interlace:\n            fmt = \'BH\'[self.bitdepth > 8]\n            a = array(fmt, itertools.chain(*rows))\n            return self.write_array(outfile, a)\n\n        nrows = self.write_passes(outfile, rows)\n        if nrows != self.height:\n            raise ValueError(\n              ""rows supplied (%d) does not match height (%d)"" %\n              (nrows, self.height))\n\n    def write_passes(self, outfile, rows, packed=False):\n        """"""\n        Write a PNG image to the output file.\n\n        Most users are expected to find the :meth:`write` or\n        :meth:`write_array` method more convenient.\n        \n        The rows should be given to this method in the order that\n        they appear in the output file.  For straightlaced images,\n        this is the usual top to bottom ordering, but for interlaced\n        images the rows should have already been interlaced before\n        passing them to this function.\n\n        `rows` should be an iterable that yields each row.  When\n        `packed` is ``False`` the rows should be in boxed row flat pixel\n        format; when `packed` is ``True`` each row should be a packed\n        sequence of bytes.\n        """"""\n\n        # http://www.w3.org/TR/PNG/#5PNG-file-signature\n        outfile.write(_signature)\n\n        # http://www.w3.org/TR/PNG/#11IHDR\n        write_chunk(outfile, \'IHDR\',\n                    struct.pack(""!2I5B"", self.width, self.height,\n                                self.bitdepth, self.color_type,\n                                0, 0, self.interlace))\n\n        # See :chunk:order\n        # http://www.w3.org/TR/PNG/#11gAMA\n        if self.gamma is not None:\n            write_chunk(outfile, \'gAMA\',\n                        struct.pack(""!L"", int(round(self.gamma*1e5))))\n\n        # See :chunk:order\n        # http://www.w3.org/TR/PNG/#11sBIT\n        if self.rescale:\n            write_chunk(outfile, \'sBIT\',\n                struct.pack(\'%dB\' % self.planes,\n                            *[self.rescale[0]]*self.planes))\n        \n        # :chunk:order: Without a palette (PLTE chunk), ordering is\n        # relatively relaxed.  With one, gAMA chunk must precede PLTE\n        # chunk which must precede tRNS and bKGD.\n        # See http://www.w3.org/TR/PNG/#5ChunkOrdering\n        if self.palette:\n            p,t = self.make_palette()\n            write_chunk(outfile, \'PLTE\', p)\n            if t:\n                # tRNS chunk is optional. Only needed if palette entries\n                # have alpha.\n                write_chunk(outfile, \'tRNS\', t)\n\n        # http://www.w3.org/TR/PNG/#11tRNS\n        if self.transparent is not None:\n            if self.greyscale:\n                write_chunk(outfile, \'tRNS\',\n                            struct.pack(""!1H"", *self.transparent))\n            else:\n                write_chunk(outfile, \'tRNS\',\n                            struct.pack(""!3H"", *self.transparent))\n\n        # http://www.w3.org/TR/PNG/#11bKGD\n        if self.background is not None:\n            if self.greyscale:\n                write_chunk(outfile, \'bKGD\',\n                            struct.pack(""!1H"", *self.background))\n            else:\n                write_chunk(outfile, \'bKGD\',\n                            struct.pack(""!3H"", *self.background))\n\n        # http://www.w3.org/TR/PNG/#11IDAT\n        if self.compression is not None:\n            compressor = zlib.compressobj(self.compression)\n        else:\n            compressor = zlib.compressobj()\n\n        # Choose an extend function based on the bitdepth.  The extend\n        # function packs/decomposes the pixel values into bytes and\n        # stuffs them onto the data array.\n        data = array(\'B\')\n        if self.bitdepth == 8 or packed:\n            extend = data.extend\n        elif self.bitdepth == 16:\n            # Decompose into bytes\n            def extend(sl):\n                fmt = \'!%dH\' % len(sl)\n                data.extend(array(\'B\', struct.pack(fmt, *sl)))\n        else:\n            # Pack into bytes\n            assert self.bitdepth < 8\n            # samples per byte\n            spb = int(8/self.bitdepth)\n            def extend(sl):\n                a = array(\'B\', sl)\n                # Adding padding bytes so we can group into a whole\n                # number of spb-tuples.\n                l = float(len(a))\n                extra = math.ceil(l / float(spb))*spb - l\n                a.extend([0]*int(extra))\n                # Pack into bytes\n                l = group(a, spb)\n                l = map(lambda e: reduce(lambda x,y:\n                                           (x << self.bitdepth) + y, e), l)\n                data.extend(l)\n        if self.rescale:\n            oldextend = extend\n            factor = \\\n              float(2**self.rescale[1]-1) / float(2**self.rescale[0]-1)\n            def extend(sl):\n                oldextend(map(lambda x: int(round(factor*x)), sl))\n\n        # Build the first row, testing mostly to see if we need to\n        # changed the extend function to cope with NumPy integer types\n        # (they cause our ordinary definition of extend to fail, so we\n        # wrap it).  See\n        # http://code.google.com/p/pypng/issues/detail?id=44\n        enumrows = enumerate(rows)\n        del rows\n\n        # First row\'s filter type.\n        data.append(0)\n        # :todo: Certain exceptions in the call to ``.next()`` or the\n        # following try would indicate no row data supplied.\n        # Should catch.\n        i,row = next(enumrows)\n        try:\n            # If this fails...\n            extend(row)\n        except:\n            # ... try a version that converts the values to int first.\n            # Not only does this work for the (slightly broken) NumPy\n            # types, there are probably lots of other, unknown, ""nearly""\n            # int types it works for.\n            def wrapmapint(f):\n                return lambda sl: f(map(int, sl))\n            extend = wrapmapint(extend)\n            del wrapmapint\n            extend(row)\n\n        for i,row in enumrows:\n            # Add ""None"" filter type.  Currently, it\'s essential that\n            # this filter type be used for every scanline as we do not\n            # mark the first row of a reduced pass image; that means we\n            # could accidentally compute the wrong filtered scanline if\n            # we used ""up"", ""average"", or ""paeth"" on such a line.\n            data.append(0)\n            extend(row)\n            if len(data) > self.chunk_limit:\n                compressed = compressor.compress(tostring(data))\n                if len(compressed):\n                    write_chunk(outfile, \'IDAT\', compressed)\n                # Because of our very witty definition of ``extend``,\n                # above, we must re-use the same ``data`` object.  Hence\n                # we use ``del`` to empty this one, rather than create a\n                # fresh one (which would be my natural FP instinct).\n                del data[:]\n        if len(data):\n            compressed = compressor.compress(tostring(data))\n        else:\n            compressed = strtobytes(\'\')\n        flushed = compressor.flush()\n        if len(compressed) or len(flushed):\n            write_chunk(outfile, \'IDAT\', compressed + flushed)\n        # http://www.w3.org/TR/PNG/#11IEND\n        write_chunk(outfile, \'IEND\')\n        return i+1\n\n    def write_array(self, outfile, pixels):\n        """"""\n        Write an array in flat row flat pixel format as a PNG file on\n        the output file.  See also :meth:`write` method.\n        """"""\n\n        if self.interlace:\n            self.write_passes(outfile, self.array_scanlines_interlace(pixels))\n        else:\n            self.write_passes(outfile, self.array_scanlines(pixels))\n\n    def write_packed(self, outfile, rows):\n        """"""\n        Write PNG file to `outfile`.  The pixel data comes from `rows`\n        which should be in boxed row packed format.  Each row should be\n        a sequence of packed bytes.\n\n        Technically, this method does work for interlaced images but it\n        is best avoided.  For interlaced images, the rows should be\n        presented in the order that they appear in the file.\n\n        This method should not be used when the source image bit depth\n        is not one naturally supported by PNG; the bit depth should be\n        1, 2, 4, 8, or 16.\n        """"""\n\n        if self.rescale:\n            raise Error(""write_packed method not suitable for bit depth %d"" %\n              self.rescale[0])\n        return self.write_passes(outfile, rows, packed=True)\n\n    def convert_pnm(self, infile, outfile):\n        """"""\n        Convert a PNM file containing raw pixel data into a PNG file\n        with the parameters set in the writer object.  Works for\n        (binary) PGM, PPM, and PAM formats.\n        """"""\n\n        if self.interlace:\n            pixels = array(\'B\')\n            pixels.fromfile(infile,\n                            (self.bitdepth/8) * self.color_planes *\n                            self.width * self.height)\n            self.write_passes(outfile, self.array_scanlines_interlace(pixels))\n        else:\n            self.write_passes(outfile, self.file_scanlines(infile))\n\n    def convert_ppm_and_pgm(self, ppmfile, pgmfile, outfile):\n        """"""\n        Convert a PPM and PGM file containing raw pixel data into a\n        PNG outfile with the parameters set in the writer object.\n        """"""\n        pixels = array(\'B\')\n        pixels.fromfile(ppmfile,\n                        (self.bitdepth/8) * self.color_planes *\n                        self.width * self.height)\n        apixels = array(\'B\')\n        apixels.fromfile(pgmfile,\n                         (self.bitdepth/8) *\n                         self.width * self.height)\n        pixels = interleave_planes(pixels, apixels,\n                                   (self.bitdepth/8) * self.color_planes,\n                                   (self.bitdepth/8))\n        if self.interlace:\n            self.write_passes(outfile, self.array_scanlines_interlace(pixels))\n        else:\n            self.write_passes(outfile, self.array_scanlines(pixels))\n\n    def file_scanlines(self, infile):\n        """"""\n        Generates boxed rows in flat pixel format, from the input file\n        `infile`.  It assumes that the input file is in a ""Netpbm-like""\n        binary format, and is positioned at the beginning of the first\n        pixel.  The number of pixels to read is taken from the image\n        dimensions (`width`, `height`, `planes`) and the number of bytes\n        per value is implied by the image `bitdepth`.\n        """"""\n\n        # Values per row\n        vpr = self.width * self.planes\n        row_bytes = vpr\n        if self.bitdepth > 8:\n            assert self.bitdepth == 16\n            row_bytes *= 2\n            fmt = \'>%dH\' % vpr\n            def line():\n                return array(\'H\', struct.unpack(fmt, infile.read(row_bytes)))\n        else:\n            def line():\n                scanline = array(\'B\', infile.read(row_bytes))\n                return scanline\n        for y in range(self.height):\n            yield line()\n\n    def array_scanlines(self, pixels):\n        """"""\n        Generates boxed rows (flat pixels) from flat rows (flat pixels)\n        in an array.\n        """"""\n\n        # Values per row\n        vpr = self.width * self.planes\n        stop = 0\n        for y in range(self.height):\n            start = stop\n            stop = start + vpr\n            yield pixels[start:stop]\n\n    def array_scanlines_interlace(self, pixels):\n        """"""\n        Generator for interlaced scanlines from an array.  `pixels` is\n        the full source image in flat row flat pixel format.  The\n        generator yields each scanline of the reduced passes in turn, in\n        boxed row flat pixel format.\n        """"""\n\n        # http://www.w3.org/TR/PNG/#8InterlaceMethods\n        # Array type.\n        fmt = \'BH\'[self.bitdepth > 8]\n        # Value per row\n        vpr = self.width * self.planes\n        for xstart, ystart, xstep, ystep in _adam7:\n            if xstart >= self.width:\n                continue\n            # Pixels per row (of reduced image)\n            ppr = int(math.ceil((self.width-xstart)/float(xstep)))\n            # number of values in reduced image row.\n            row_len = ppr*self.planes\n            for y in range(ystart, self.height, ystep):\n                if xstep == 1:\n                    offset = y * vpr\n                    yield pixels[offset:offset+vpr]\n                else:\n                    row = array(fmt)\n                    # There\'s no easier way to set the length of an array\n                    row.extend(pixels[0:row_len])\n                    offset = y * vpr + xstart * self.planes\n                    end_offset = (y+1) * vpr\n                    skip = self.planes * xstep\n                    for i in range(self.planes):\n                        row[i::self.planes] = \\\n                            pixels[offset+i:end_offset:skip]\n                    yield row\n\ndef write_chunk(outfile, tag, data=strtobytes(\'\')):\n    """"""\n    Write a PNG chunk to the output file, including length and\n    checksum.\n    """"""\n\n    # http://www.w3.org/TR/PNG/#5Chunk-layout\n    outfile.write(struct.pack(""!I"", len(data)))\n    tag = strtobytes(tag)\n    outfile.write(tag)\n    outfile.write(data)\n    checksum = zlib.crc32(tag)\n    checksum = zlib.crc32(data, checksum)\n    checksum &= 2**32-1\n    outfile.write(struct.pack(""!I"", checksum))\n\ndef write_chunks(out, chunks):\n    """"""Create a PNG file by writing out the chunks.""""""\n\n    out.write(_signature)\n    for chunk in chunks:\n        write_chunk(out, *chunk)\n\ndef filter_scanline(type, line, fo, prev=None):\n    """"""Apply a scanline filter to a scanline.  `type` specifies the\n    filter type (0 to 4); `line` specifies the current (unfiltered)\n    scanline as a sequence of bytes; `prev` specifies the previous\n    (unfiltered) scanline as a sequence of bytes. `fo` specifies the\n    filter offset; normally this is size of a pixel in bytes (the number\n    of bytes per sample times the number of channels), but when this is\n    < 1 (for bit depths < 8) then the filter offset is 1.\n    """"""\n\n    assert 0 <= type < 5\n\n    # The output array.  Which, pathetically, we extend one-byte at a\n    # time (fortunately this is linear).\n    out = array(\'B\', [type])\n\n    def sub():\n        ai = -fo\n        for x in line:\n            if ai >= 0:\n                x = (x - line[ai]) & 0xff\n            out.append(x)\n            ai += 1\n    def up():\n        for i,x in enumerate(line):\n            x = (x - prev[i]) & 0xff\n            out.append(x)\n    def average():\n        ai = -fo\n        for i,x in enumerate(line):\n            if ai >= 0:\n                x = (x - ((line[ai] + prev[i]) >> 1)) & 0xff\n            else:\n                x = (x - (prev[i] >> 1)) & 0xff\n            out.append(x)\n            ai += 1\n    def paeth():\n        # http://www.w3.org/TR/PNG/#9Filter-type-4-Paeth\n        ai = -fo # also used for ci\n        for i,x in enumerate(line):\n            a = 0\n            b = prev[i]\n            c = 0\n\n            if ai >= 0:\n                a = line[ai]\n                c = prev[ai]\n            p = a + b - c\n            pa = abs(p - a)\n            pb = abs(p - b)\n            pc = abs(p - c)\n            if pa <= pb and pa <= pc:\n                Pr = a\n            elif pb <= pc:\n                Pr = b\n            else:\n                Pr = c\n\n            x = (x - Pr) & 0xff\n            out.append(x)\n            ai += 1\n\n    if not prev:\n        # We\'re on the first line.  Some of the filters can be reduced\n        # to simpler cases which makes handling the line ""off the top""\n        # of the image simpler.  ""up"" becomes ""none""; ""paeth"" becomes\n        # ""left"" (non-trivial, but true). ""average"" needs to be handled\n        # specially.\n        if type == 2: # ""up""\n            type = 0\n        elif type == 3:\n            prev = [0]*len(line)\n        elif type == 4: # ""paeth""\n            type = 1\n    if type == 0:\n        out.extend(line)\n    elif type == 1:\n        sub()\n    elif type == 2:\n        up()\n    elif type == 3:\n        average()\n    else: # type == 4\n        paeth()\n    return out\n\n\ndef from_array(a, mode=None, info={}):\n    """"""Create a PNG :class:`Image` object from a 2- or 3-dimensional\n    array.  One application of this function is easy PIL-style saving:\n    ``png.from_array(pixels, \'L\').save(\'foo.png\')``.\n\n    .. note :\n\n      The use of the term *3-dimensional* is for marketing purposes\n      only.  It doesn\'t actually work.  Please bear with us.  Meanwhile\n      enjoy the complimentary snacks (on request) and please use a\n      2-dimensional array.\n    \n    Unless they are specified using the *info* parameter, the PNG\'s\n    height and width are taken from the array size.  For a 3 dimensional\n    array the first axis is the height; the second axis is the width;\n    and the third axis is the channel number.  Thus an RGB image that is\n    16 pixels high and 8 wide will use an array that is 16x8x3.  For 2\n    dimensional arrays the first axis is the height, but the second axis\n    is ``width*channels``, so an RGB image that is 16 pixels high and 8\n    wide will use a 2-dimensional array that is 16x24 (each row will be\n    8*3==24 sample values).\n\n    *mode* is a string that specifies the image colour format in a\n    PIL-style mode.  It can be:\n\n    ``\'L\'``\n      greyscale (1 channel)\n    ``\'LA\'``\n      greyscale with alpha (2 channel)\n    ``\'RGB\'``\n      colour image (3 channel)\n    ``\'RGBA\'``\n      colour image with alpha (4 channel)\n\n    The mode string can also specify the bit depth (overriding how this\n    function normally derives the bit depth, see below).  Appending\n    ``\';16\'`` to the mode will cause the PNG to be 16 bits per channel;\n    any decimal from 1 to 16 can be used to specify the bit depth.\n\n    When a 2-dimensional array is used *mode* determines how many\n    channels the image has, and so allows the width to be derived from\n    the second array dimension.\n\n    The array is expected to be a ``numpy`` array, but it can be any\n    suitable Python sequence.  For example, a list of lists can be used:\n    ``png.from_array([[0, 255, 0], [255, 0, 255]], \'L\')``.  The exact\n    rules are: ``len(a)`` gives the first dimension, height;\n    ``len(a[0])`` gives the second dimension; ``len(a[0][0])`` gives the\n    third dimension, unless an exception is raised in which case a\n    2-dimensional array is assumed.  It\'s slightly more complicated than\n    that because an iterator of rows can be used, and it all still\n    works.  Using an iterator allows data to be streamed efficiently.\n\n    The bit depth of the PNG is normally taken from the array element\'s\n    datatype (but if *mode* specifies a bitdepth then that is used\n    instead).  The array element\'s datatype is determined in a way which\n    is supposed to work both for ``numpy`` arrays and for Python\n    ``array.array`` objects.  A 1 byte datatype will give a bit depth of\n    8, a 2 byte datatype will give a bit depth of 16.  If the datatype\n    does not have an implicit size, for example it is a plain Python\n    list of lists, as above, then a default of 8 is used.\n\n    The *info* parameter is a dictionary that can be used to specify\n    metadata (in the same style as the arguments to the\n    :class:``png.Writer`` class).  For this function the keys that are\n    useful are:\n    \n    height\n      overrides the height derived from the array dimensions and allows\n      *a* to be an iterable.\n    width\n      overrides the width derived from the array dimensions.\n    bitdepth\n      overrides the bit depth derived from the element datatype (but\n      must match *mode* if that also specifies a bit depth).\n\n    Generally anything specified in the\n    *info* dictionary will override any implicit choices that this\n    function would otherwise make, but must match any explicit ones.\n    For example, if the *info* dictionary has a ``greyscale`` key then\n    this must be true when mode is ``\'L\'`` or ``\'LA\'`` and false when\n    mode is ``\'RGB\'`` or ``\'RGBA\'``.\n    """"""\n\n    # We abuse the *info* parameter by modifying it.  Take a copy here.\n    # (Also typechecks *info* to some extent).\n    info = dict(info)\n\n    # Syntax check mode string.\n    bitdepth = None\n    try:\n        # Assign the \'L\' or \'RGBA\' part to `gotmode`.\n        if mode.startswith(\'L\'):\n            gotmode = \'L\'\n            mode = mode[1:]\n        elif mode.startswith(\'RGB\'):\n            gotmode = \'RGB\'\n            mode = mode[3:]\n        else:\n            raise Error()\n        if mode.startswith(\'A\'):\n            gotmode += \'A\'\n            mode = mode[1:]\n\n        # Skip any optional \';\'\n        while mode.startswith(\';\'):\n            mode = mode[1:]\n\n        # Parse optional bitdepth\n        if mode:\n            try:\n                bitdepth = int(mode)\n            except (TypeError, ValueError):\n                raise Error()\n    except Error:\n        raise Error(""mode string should be \'RGB\' or \'L;16\' or similar."")\n    mode = gotmode\n\n    # Get bitdepth from *mode* if possible.\n    if bitdepth:\n        if info.get(\'bitdepth\') and bitdepth != info[\'bitdepth\']:\n            raise Error(""mode bitdepth (%d) should match info bitdepth (%d)."" %\n              (bitdepth, info[\'bitdepth\']))\n        info[\'bitdepth\'] = bitdepth\n\n    # Fill in and/or check entries in *info*.\n    # Dimensions.\n    if \'size\' in info:\n        # Check width, height, size all match where used.\n        for dimension,axis in [(\'width\', 0), (\'height\', 1)]:\n            if dimension in info:\n                if info[dimension] != info[\'size\'][axis]:\n                    raise Error(\n                      ""info[%r] should match info[\'size\'][%r]."" %\n                      (dimension, axis))\n        info[\'width\'],info[\'height\'] = info[\'size\']\n    if \'height\' not in info:\n        try:\n            l = len(a)\n        except TypeError:\n            raise Error(\n              ""len(a) does not work, supply info[\'height\'] instead."")\n        info[\'height\'] = l\n    # Colour format.\n    if \'greyscale\' in info:\n        if bool(info[\'greyscale\']) != (\'L\' in mode):\n            raise Error(""info[\'greyscale\'] should match mode."")\n    info[\'greyscale\'] = \'L\' in mode\n    if \'alpha\' in info:\n        if bool(info[\'alpha\']) != (\'A\' in mode):\n            raise Error(""info[\'alpha\'] should match mode."")\n    info[\'alpha\'] = \'A\' in mode\n\n    planes = len(mode)\n    if \'planes\' in info:\n        if info[\'planes\'] != planes:\n            raise Error(""info[\'planes\'] should match mode."")\n\n    # In order to work out whether we the array is 2D or 3D we need its\n    # first row, which requires that we take a copy of its iterator.\n    # We may also need the first row to derive width and bitdepth.\n    a,t = itertools.tee(a)\n    row = next(t)\n    del t\n    try:\n        row[0][0]\n        threed = True\n        testelement = row[0]\n    except (IndexError, TypeError):\n        threed = False\n        testelement = row\n    if \'width\' not in info:\n        if threed:\n            width = len(row)\n        else:\n            width = len(row) // planes\n        info[\'width\'] = width\n\n    # Not implemented yet\n    assert not threed\n\n    if \'bitdepth\' not in info:\n        try:\n            dtype = testelement.dtype\n            # goto the ""else:"" clause.  Sorry.\n        except AttributeError:\n            try:\n                # Try a Python array.array.\n                bitdepth = 8 * testelement.itemsize\n            except AttributeError:\n                # We can\'t determine it from the array element\'s\n                # datatype, use a default of 8.\n                bitdepth = 8\n        else:\n            # If we got here without exception, we now assume that\n            # the array is a numpy array.\n            if dtype.kind == \'b\':\n                bitdepth = 1\n            else:\n                bitdepth = 8 * dtype.itemsize\n        info[\'bitdepth\'] = bitdepth\n\n    for thing in \'width height bitdepth greyscale alpha\'.split():\n        assert thing in info\n    return Image(a, info)\n\n# So that refugee\'s from PIL feel more at home.  Not documented.\nfromarray = from_array\n\nclass Image:\n    """"""A PNG image.  You can create an :class:`Image` object from\n    an array of pixels by calling :meth:`png.from_array`.  It can be\n    saved to disk with the :meth:`save` method.\n    """"""\n\n    def __init__(self, rows, info):\n        """"""\n        .. note ::\n        \n          The constructor is not public.  Please do not call it.\n        """"""\n        \n        self.rows = rows\n        self.info = info\n\n    def save(self, file):\n        """"""Save the image to *file*.  If *file* looks like an open file\n        descriptor then it is used, otherwise it is treated as a\n        filename and a fresh file is opened.\n\n        In general, you can only call this method once; after it has\n        been called the first time and the PNG image has been saved, the\n        source data will have been streamed, and cannot be streamed\n        again.\n        """"""\n\n        w = Writer(**self.info)\n\n        try:\n            file.write\n            def close(): pass\n        except AttributeError:\n            file = open(file, \'wb\')\n            def close(): file.close()\n\n        try:\n            w.write(file, self.rows)\n        finally:\n            close()\n\nclass _readable:\n    """"""\n    A simple file-like interface for strings and arrays.\n    """"""\n\n    def __init__(self, buf):\n        self.buf = buf\n        self.offset = 0\n\n    def read(self, n):\n        r = self.buf[self.offset:self.offset+n]\n        if isarray(r):\n            r = r.tostring()\n        self.offset += n\n        return r\n\n\nclass Reader:\n    """"""\n    PNG decoder in pure Python.\n    """"""\n\n    def __init__(self, _guess=None, **kw):\n        """"""\n        Create a PNG decoder object.\n\n        The constructor expects exactly one keyword argument. If you\n        supply a positional argument instead, it will guess the input\n        type. You can choose among the following keyword arguments:\n\n        filename\n          Name of input file (a PNG file).\n        file\n          A file-like object (object with a read() method).\n        bytes\n          ``array`` or ``string`` with PNG data.\n\n        """"""\n        if ((_guess is not None and len(kw) != 0) or\n            (_guess is None and len(kw) != 1)):\n            raise TypeError(""Reader() takes exactly 1 argument"")\n\n        # Will be the first 8 bytes, later on.  See validate_signature.\n        self.signature = None\n        self.transparent = None\n        # A pair of (len,type) if a chunk has been read but its data and\n        # checksum have not (in other words the file position is just\n        # past the 4 bytes that specify the chunk type).  See preamble\n        # method for how this is used.\n        self.atchunk = None\n\n        if _guess is not None:\n            if isarray(_guess):\n                kw[""bytes""] = _guess\n            elif isinstance(_guess, str):\n                kw[""filename""] = _guess\n            elif hasattr(_guess, \'read\'):\n                kw[""file""] = _guess\n\n        if ""filename"" in kw:\n            self.file = open(kw[""filename""], ""rb"")\n        elif ""file"" in kw:\n            self.file = kw[""file""]\n        elif ""bytes"" in kw:\n            self.file = _readable(kw[""bytes""])\n        else:\n            raise TypeError(""expecting filename, file or bytes array"")\n\n\n    def chunk(self, seek=None, lenient=False):\n        """"""\n        Read the next PNG chunk from the input file; returns a\n        (*type*,*data*) tuple.  *type* is the chunk\'s type as a string\n        (all PNG chunk types are 4 characters long).  *data* is the\n        chunk\'s data content, as a string.\n\n        If the optional `seek` argument is\n        specified then it will keep reading chunks until it either runs\n        out of file or finds the type specified by the argument.  Note\n        that in general the order of chunks in PNGs is unspecified, so\n        using `seek` can cause you to miss chunks.\n\n        If the optional `lenient` argument evaluates to True,\n        checksum failures will raise warnings rather than exceptions.\n        """"""\n\n        self.validate_signature()\n\n        while True:\n            # http://www.w3.org/TR/PNG/#5Chunk-layout\n            if not self.atchunk:\n                self.atchunk = self.chunklentype()\n            length,type = self.atchunk\n            self.atchunk = None\n            data = self.file.read(length)\n            if len(data) != length:\n                raise ChunkError(\'Chunk %s too short for required %i octets.\'\n                  % (type, length))\n            checksum = self.file.read(4)\n            if len(checksum) != 4:\n                raise ValueError(\'Chunk %s too short for checksum.\', tag)\n            if seek and type != seek:\n                continue\n            verify = zlib.crc32(strtobytes(type))\n            verify = zlib.crc32(data, verify)\n            # Whether the output from zlib.crc32 is signed or not varies\n            # according to hideous implementation details, see\n            # http://bugs.python.org/issue1202 .\n            # We coerce it to be positive here (in a way which works on\n            # Python 2.3 and older).\n            verify &= 2**32 - 1\n            verify = struct.pack(\'!I\', verify)\n            if checksum != verify:\n                (a, ) = struct.unpack(\'!I\', checksum)\n                (b, ) = struct.unpack(\'!I\', verify)\n                message = ""Checksum error in %s chunk: 0x%08X != 0x%08X."" % (type, a, b)\n                if lenient:\n                    warnings.warn(message, RuntimeWarning)\n                else:\n                    raise ChunkError(message)\n            return type, data\n\n    def chunks(self):\n        """"""Return an iterator that will yield each chunk as a\n        (*chunktype*, *content*) pair.\n        """"""\n\n        while True:\n            t,v = self.chunk()\n            yield t,v\n            if t == \'IEND\':\n                break\n\n    def undo_filter(self, filter_type, scanline, previous):\n        """"""Undo the filter for a scanline.  `scanline` is a sequence of\n        bytes that does not include the initial filter type byte.\n        `previous` is decoded previous scanline (for straightlaced\n        images this is the previous pixel row, but for interlaced\n        images, it is the previous scanline in the reduced image, which\n        in general is not the previous pixel row in the final image).\n        When there is no previous scanline (the first row of a\n        straightlaced image, or the first row in one of the passes in an\n        interlaced image), then this argument should be ``None``.\n\n        The scanline will have the effects of filtering removed, and the\n        result will be returned as a fresh sequence of bytes.\n        """"""\n\n        # :todo: Would it be better to update scanline in place?\n        # Yes, with the Cython extension making the undo_filter fast,\n        # updating scanline inplace makes the code 3 times faster\n        # (reading 50 images of 800x800 went from 40s to 16s)\n        result = scanline\n\n        if filter_type == 0:\n            return result\n\n        if filter_type not in (1,2,3,4):\n            raise FormatError(\'Invalid PNG Filter Type.\'\n              \'  See http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .\')\n\n        # Filter unit.  The stride from one pixel to the corresponding\n        # byte from the previous pixel.  Normally this is the pixel\n        # size in bytes, but when this is smaller than 1, the previous\n        # byte is used instead.\n        fu = max(1, self.psize)\n\n        # For the first line of a pass, synthesize a dummy previous\n        # line.  An alternative approach would be to observe that on the\n        # first line \'up\' is the same as \'null\', \'paeth\' is the same\n        # as \'sub\', with only \'average\' requiring any special case.\n        if not previous:\n            previous = array(\'B\', [0]*len(scanline))\n\n        def sub():\n            """"""Undo sub filter.""""""\n\n            ai = 0\n            # Loop starts at index fu.  Observe that the initial part\n            # of the result is already filled in correctly with\n            # scanline.\n            for i in range(fu, len(result)):\n                x = scanline[i]\n                a = result[ai]\n                result[i] = (x + a) & 0xff\n                ai += 1\n\n        def up():\n            """"""Undo up filter.""""""\n\n            for i in range(len(result)):\n                x = scanline[i]\n                b = previous[i]\n                result[i] = (x + b) & 0xff\n\n        def average():\n            """"""Undo average filter.""""""\n\n            ai = -fu\n            for i in range(len(result)):\n                x = scanline[i]\n                if ai < 0:\n                    a = 0\n                else:\n                    a = result[ai]\n                b = previous[i]\n                result[i] = (x + ((a + b) >> 1)) & 0xff\n                ai += 1\n\n        def paeth():\n            """"""Undo Paeth filter.""""""\n\n            # Also used for ci.\n            ai = -fu\n            for i in range(len(result)):\n                x = scanline[i]\n                if ai < 0:\n                    a = c = 0\n                else:\n                    a = result[ai]\n                    c = previous[ai]\n                b = previous[i]\n                p = a + b - c\n                pa = abs(p - a)\n                pb = abs(p - b)\n                pc = abs(p - c)\n                if pa <= pb and pa <= pc:\n                    pr = a\n                elif pb <= pc:\n                    pr = b\n                else:\n                    pr = c\n                result[i] = (x + pr) & 0xff\n                ai += 1\n\n        # Call appropriate filter algorithm.  Note that 0 has already\n        # been dealt with.\n        (None,\n         pngfilters.undo_filter_sub,\n         pngfilters.undo_filter_up,\n         pngfilters.undo_filter_average,\n         pngfilters.undo_filter_paeth)[filter_type](fu, scanline, previous, result)\n        return result\n\n    def deinterlace(self, raw):\n        """"""\n        Read raw pixel data, undo filters, deinterlace, and flatten.\n        Return in flat row flat pixel format.\n        """"""\n\n        # Values per row (of the target image)\n        vpr = self.width * self.planes\n\n        # Make a result array, and make it big enough.  Interleaving\n        # writes to the output array randomly (well, not quite), so the\n        # entire output array must be in memory.\n        fmt = \'BH\'[self.bitdepth > 8]\n        a = array(fmt, [0]*vpr*self.height)\n        source_offset = 0\n\n        for xstart, ystart, xstep, ystep in _adam7:\n            if xstart >= self.width:\n                continue\n            # The previous (reconstructed) scanline.  None at the\n            # beginning of a pass to indicate that there is no previous\n            # line.\n            recon = None\n            # Pixels per row (reduced pass image)\n            ppr = int(math.ceil((self.width-xstart)/float(xstep)))\n            # Row size in bytes for this pass.\n            row_size = int(math.ceil(self.psize * ppr))\n            for y in range(ystart, self.height, ystep):\n                filter_type = raw[source_offset]\n                source_offset += 1\n                scanline = raw[source_offset:source_offset+row_size]\n                source_offset += row_size\n                recon = self.undo_filter(filter_type, scanline, recon)\n                # Convert so that there is one element per pixel value\n                flat = self.serialtoflat(recon, ppr)\n                if xstep == 1:\n                    assert xstart == 0\n                    offset = y * vpr\n                    a[offset:offset+vpr] = flat\n                else:\n                    offset = y * vpr + xstart * self.planes\n                    end_offset = (y+1) * vpr\n                    skip = self.planes * xstep\n                    for i in range(self.planes):\n                        a[offset+i:end_offset:skip] = \\\n                            flat[i::self.planes]\n        return a\n\n    def iterboxed(self, rows):\n        """"""Iterator that yields each scanline in boxed row flat pixel\n        format.  `rows` should be an iterator that yields the bytes of\n        each row in turn.\n        """"""\n\n        def asvalues(raw):\n            """"""Convert a row of raw bytes into a flat row.  Result will\n            be a freshly allocated object, not shared with\n            argument.\n            """"""\n\n            if self.bitdepth == 8:\n                return array(\'B\', raw)\n            if self.bitdepth == 16:\n                raw = tostring(raw)\n                return array(\'H\', struct.unpack(\'!%dH\' % (len(raw)//2), raw))\n            assert self.bitdepth < 8\n            width = self.width\n            # Samples per byte\n            spb = 8//self.bitdepth\n            out = array(\'B\')\n            mask = 2**self.bitdepth - 1\n            shifts = map(self.bitdepth.__mul__, reversed(range(spb)))\n            for o in raw:\n                out.extend(map(lambda i: mask&(o>>i), shifts))\n            return out[:width]\n\n        return itertools.imap(asvalues, rows)\n\n    def serialtoflat(self, bytes, width=None):\n        """"""Convert serial format (byte stream) pixel data to flat row\n        flat pixel.\n        """"""\n\n        if self.bitdepth == 8:\n            return bytes\n        if self.bitdepth == 16:\n            bytes = tostring(bytes)\n            return array(\'H\',\n              struct.unpack(\'!%dH\' % (len(bytes)//2), bytes))\n        assert self.bitdepth < 8\n        if width is None:\n            width = self.width\n        # Samples per byte\n        spb = 8//self.bitdepth\n        out = array(\'B\')\n        mask = 2**self.bitdepth - 1\n        shifts = map(self.bitdepth.__mul__, reversed(range(spb)))\n        l = width\n        for o in bytes:\n            out.extend([(mask&(o>>s)) for s in shifts][:l])\n            l -= spb\n            if l <= 0:\n                l = width\n        return out\n\n    def iterstraight(self, raw):\n        """"""Iterator that undoes the effect of filtering, and yields\n        each row in serialised format (as a sequence of bytes).\n        Assumes input is straightlaced.  `raw` should be an iterable\n        that yields the raw bytes in chunks of arbitrary size.\n        """"""\n\n        # length of row, in bytes\n        rb = self.row_bytes\n        a = array(\'B\')\n        # The previous (reconstructed) scanline.  None indicates first\n        # line of image.\n        recon = None\n        for some in raw:\n            a.extend(some)\n            while len(a) >= rb + 1:\n                filter_type = a[0]\n                scanline = a[1:rb+1]\n                del a[:rb+1]\n                recon = self.undo_filter(filter_type, scanline, recon)\n                yield recon\n        if len(a) != 0:\n            # :file:format We get here with a file format error:\n            # when the available bytes (after decompressing) do not\n            # pack into exact rows.\n            raise FormatError(\n              \'Wrong size for decompressed IDAT chunk.\')\n        assert len(a) == 0\n\n    def validate_signature(self):\n        """"""If signature (header) has not been read then read and\n        validate it; otherwise do nothing.\n        """"""\n\n        if self.signature:\n            return\n        self.signature = self.file.read(8)\n        if self.signature != _signature:\n            raise FormatError(""PNG file has invalid signature."")\n\n    def preamble(self, lenient=False):\n        """"""\n        Extract the image metadata by reading the initial part of\n        the PNG file up to the start of the ``IDAT`` chunk.  All the\n        chunks that precede the ``IDAT`` chunk are read and either\n        processed for metadata or discarded.\n\n        If the optional `lenient` argument evaluates to True, checksum\n        failures will raise warnings rather than exceptions.\n        """"""\n\n        self.validate_signature()\n\n        while True:\n            if not self.atchunk:\n                self.atchunk = self.chunklentype()\n                if self.atchunk is None:\n                    raise FormatError(\n                      \'This PNG file has no IDAT chunks.\')\n            if self.atchunk[1] == \'IDAT\':\n                return\n            self.process_chunk(lenient=lenient)\n\n    def chunklentype(self):\n        """"""Reads just enough of the input to determine the next\n        chunk\'s length and type, returned as a (*length*, *type*) pair\n        where *type* is a string.  If there are no more chunks, ``None``\n        is returned.\n        """"""\n\n        x = self.file.read(8)\n        if not x:\n            return None\n        if len(x) != 8:\n            raise FormatError(\n              \'End of file whilst reading chunk length and type.\')\n        length,type = struct.unpack(\'!I4s\', x)\n        type = bytestostr(type)\n        if length > 2**31-1:\n            raise FormatError(\'Chunk %s is too large: %d.\' % (type,length))\n        return length,type\n\n    def process_chunk(self, lenient=False):\n        """"""Process the next chunk and its data.  This only processes the\n        following chunk types, all others are ignored: ``IHDR``,\n        ``PLTE``, ``bKGD``, ``tRNS``, ``gAMA``, ``sBIT``.\n\n        If the optional `lenient` argument evaluates to True,\n        checksum failures will raise warnings rather than exceptions.\n        """"""\n\n        type, data = self.chunk(lenient=lenient)\n        method = \'_process_\' + type\n        m = getattr(self, method, None)\n        if m:\n            m(data)\n\n    def _process_IHDR(self, data):\n        # http://www.w3.org/TR/PNG/#11IHDR\n        if len(data) != 13:\n            raise FormatError(\'IHDR chunk has incorrect length.\')\n        (self.width, self.height, self.bitdepth, self.color_type,\n         self.compression, self.filter,\n         self.interlace) = struct.unpack(""!2I5B"", data)\n\n        check_bitdepth_colortype(self.bitdepth, self.color_type)\n\n        if self.compression != 0:\n            raise Error(""unknown compression method %d"" % self.compression)\n        if self.filter != 0:\n            raise FormatError(""Unknown filter method %d,""\n              "" see http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .""\n              % self.filter)\n        if self.interlace not in (0,1):\n            raise FormatError(""Unknown interlace method %d,""\n              "" see http://www.w3.org/TR/2003/REC-PNG-20031110/#8InterlaceMethods .""\n              % self.interlace)\n\n        # Derived values\n        # http://www.w3.org/TR/PNG/#6Colour-values\n        colormap =  bool(self.color_type & 1)\n        greyscale = not (self.color_type & 2)\n        alpha = bool(self.color_type & 4)\n        color_planes = (3,1)[greyscale or colormap]\n        planes = color_planes + alpha\n\n        self.colormap = colormap\n        self.greyscale = greyscale\n        self.alpha = alpha\n        self.color_planes = color_planes\n        self.planes = planes\n        self.psize = float(self.bitdepth)/float(8) * planes\n        if int(self.psize) == self.psize:\n            self.psize = int(self.psize)\n        self.row_bytes = int(math.ceil(self.width * self.psize))\n        # Stores PLTE chunk if present, and is used to check\n        # chunk ordering constraints.\n        self.plte = None\n        # Stores tRNS chunk if present, and is used to check chunk\n        # ordering constraints.\n        self.trns = None\n        # Stores sbit chunk if present.\n        self.sbit = None\n\n    def _process_PLTE(self, data):\n        # http://www.w3.org/TR/PNG/#11PLTE\n        if self.plte:\n            warnings.warn(""Multiple PLTE chunks present."")\n        self.plte = data\n        if len(data) % 3 != 0:\n            raise FormatError(\n              ""PLTE chunk\'s length should be a multiple of 3."")\n        if len(data) > (2**self.bitdepth)*3:\n            raise FormatError(""PLTE chunk is too long."")\n        if len(data) == 0:\n            raise FormatError(""Empty PLTE is not allowed."")\n\n    def _process_bKGD(self, data):\n        try:\n            if self.colormap:\n                if not self.plte:\n                    warnings.warn(\n                      ""PLTE chunk is required before bKGD chunk."")\n                self.background = struct.unpack(\'B\', data)\n            else:\n                self.background = struct.unpack(""!%dH"" % self.color_planes,\n                  data)\n        except struct.error:\n            raise FormatError(""bKGD chunk has incorrect length."")\n\n    def _process_tRNS(self, data):\n        # http://www.w3.org/TR/PNG/#11tRNS\n        self.trns = data\n        if self.colormap:\n            if not self.plte:\n                warnings.warn(""PLTE chunk is required before tRNS chunk."")\n            else:\n                if len(data) > len(self.plte)/3:\n                    # Was warning, but promoted to Error as it\n                    # would otherwise cause pain later on.\n                    raise FormatError(""tRNS chunk is too long."")\n        else:\n            if self.alpha:\n                raise FormatError(\n                  ""tRNS chunk is not valid with colour type %d."" %\n                  self.color_type)\n            try:\n                self.transparent = \\\n                    struct.unpack(""!%dH"" % self.color_planes, data)\n            except struct.error:\n                raise FormatError(""tRNS chunk has incorrect length."")\n\n    def _process_gAMA(self, data):\n        try:\n            self.gamma = struct.unpack(""!L"", data)[0] / 100000.0\n        except struct.error:\n            raise FormatError(""gAMA chunk has incorrect length."")\n\n    def _process_sBIT(self, data):\n        self.sbit = data\n        if (self.colormap and len(data) != 3 or\n            not self.colormap and len(data) != self.planes):\n            raise FormatError(""sBIT chunk has incorrect length."")\n\n    def read(self, lenient=False):\n        """"""\n        Read the PNG file and decode it.  Returns (`width`, `height`,\n        `pixels`, `metadata`).\n\n        May use excessive memory.\n\n        `pixels` are returned in boxed row flat pixel format.\n\n        If the optional `lenient` argument evaluates to True,\n        checksum failures will raise warnings rather than exceptions.\n        """"""\n\n        def iteridat():\n            """"""Iterator that yields all the ``IDAT`` chunks as strings.""""""\n            while True:\n                try:\n                    type, data = self.chunk(lenient=lenient)\n                except ValueError as e:\n                    raise ChunkError(e.args[0])\n                if type == \'IEND\':\n                    # http://www.w3.org/TR/PNG/#11IEND\n                    break\n                if type != \'IDAT\':\n                    continue\n                # type == \'IDAT\'\n                # http://www.w3.org/TR/PNG/#11IDAT\n                if self.colormap and not self.plte:\n                    warnings.warn(""PLTE chunk is required before IDAT chunk"")\n                yield data\n\n        def iterdecomp(idat):\n            """"""Iterator that yields decompressed strings.  `idat` should\n            be an iterator that yields the ``IDAT`` chunk data.\n            """"""\n\n            # Currently, with no max_length parameter to decompress,\n            # this routine will do one yield per IDAT chunk: Not very\n            # incremental.\n            d = zlib.decompressobj()\n            # Each IDAT chunk is passed to the decompressor, then any\n            # remaining state is decompressed out.\n            for data in idat:\n                # :todo: add a max_length argument here to limit output\n                # size.\n                yield array(\'B\', d.decompress(data))\n            yield array(\'B\', d.flush())\n\n        self.preamble(lenient=lenient)\n        raw = iterdecomp(iteridat())\n\n        if self.interlace:\n            raw = array(\'B\', itertools.chain(*raw))\n            arraycode = \'BH\'[self.bitdepth>8]\n            # Like :meth:`group` but producing an array.array object for\n            # each row.\n            pixels = itertools.imap(lambda *row: array(arraycode, row),\n                       *[iter(self.deinterlace(raw))]*self.width*self.planes)\n        else:\n            pixels = self.iterboxed(self.iterstraight(raw))\n        meta = dict()\n        for attr in \'greyscale alpha planes bitdepth interlace\'.split():\n            meta[attr] = getattr(self, attr)\n        meta[\'size\'] = (self.width, self.height)\n        for attr in \'gamma transparent background\'.split():\n            a = getattr(self, attr, None)\n            if a is not None:\n                meta[attr] = a\n        if self.plte:\n            meta[\'palette\'] = self.palette()\n        return self.width, self.height, pixels, meta\n\n\n    def read_flat(self):\n        """"""\n        Read a PNG file and decode it into flat row flat pixel format.\n        Returns (*width*, *height*, *pixels*, *metadata*).\n\n        May use excessive memory.\n\n        `pixels` are returned in flat row flat pixel format.\n\n        See also the :meth:`read` method which returns pixels in the\n        more stream-friendly boxed row flat pixel format.\n        """"""\n\n        x, y, pixel, meta = self.read()\n        arraycode = \'BH\'[meta[\'bitdepth\']>8]\n        pixel = array(arraycode, itertools.chain(*pixel))\n        return x, y, pixel, meta\n\n    def palette(self, alpha=\'natural\'):\n        """"""Returns a palette that is a sequence of 3-tuples or 4-tuples,\n        synthesizing it from the ``PLTE`` and ``tRNS`` chunks.  These\n        chunks should have already been processed (for example, by\n        calling the :meth:`preamble` method).  All the tuples are the\n        same size: 3-tuples if there is no ``tRNS`` chunk, 4-tuples when\n        there is a ``tRNS`` chunk.  Assumes that the image is colour type\n        3 and therefore a ``PLTE`` chunk is required.\n\n        If the `alpha` argument is ``\'force\'`` then an alpha channel is\n        always added, forcing the result to be a sequence of 4-tuples.\n        """"""\n\n        if not self.plte:\n            raise FormatError(\n                ""Required PLTE chunk is missing in colour type 3 image."")\n        plte = group(array(\'B\', self.plte), 3)\n        if self.trns or alpha == \'force\':\n            trns = array(\'B\', self.trns or \'\')\n            trns.extend([255]*(len(plte)-len(trns)))\n            plte = map(operator.add, plte, group(trns, 1))\n        return plte\n\n    def asDirect(self):\n        """"""Returns the image data as a direct representation of an\n        ``x * y * planes`` array.  This method is intended to remove the\n        need for callers to deal with palettes and transparency\n        themselves.  Images with a palette (colour type 3)\n        are converted to RGB or RGBA; images with transparency (a\n        ``tRNS`` chunk) are converted to LA or RGBA as appropriate.\n        When returned in this format the pixel values represent the\n        colour value directly without needing to refer to palettes or\n        transparency information.\n\n        Like the :meth:`read` method this method returns a 4-tuple:\n\n        (*width*, *height*, *pixels*, *meta*)\n\n        This method normally returns pixel values with the bit depth\n        they have in the source image, but when the source PNG has an\n        ``sBIT`` chunk it is inspected and can reduce the bit depth of\n        the result pixels; pixel values will be reduced according to\n        the bit depth specified in the ``sBIT`` chunk (PNG nerds should\n        note a single result bit depth is used for all channels; the\n        maximum of the ones specified in the ``sBIT`` chunk.  An RGB565\n        image will be rescaled to 6-bit RGB666).\n\n        The *meta* dictionary that is returned reflects the `direct`\n        format and not the original source image.  For example, an RGB\n        source image with a ``tRNS`` chunk to represent a transparent\n        colour, will have ``planes=3`` and ``alpha=False`` for the\n        source image, but the *meta* dictionary returned by this method\n        will have ``planes=4`` and ``alpha=True`` because an alpha\n        channel is synthesized and added.\n\n        *pixels* is the pixel data in boxed row flat pixel format (just\n        like the :meth:`read` method).\n\n        All the other aspects of the image data are not changed.\n        """"""\n\n        self.preamble()\n\n        # Simple case, no conversion necessary.\n        if not self.colormap and not self.trns and not self.sbit:\n            return self.read()\n\n        x,y,pixels,meta = self.read()\n\n        if self.colormap:\n            meta[\'colormap\'] = False\n            meta[\'alpha\'] = bool(self.trns)\n            meta[\'bitdepth\'] = 8\n            meta[\'planes\'] = 3 + bool(self.trns)\n            plte = self.palette()\n            def iterpal(pixels):\n                for row in pixels:\n                    row = map(plte.__getitem__, row)\n                    yield array(\'B\', itertools.chain(*row))\n            pixels = iterpal(pixels)\n        elif self.trns:\n            # It would be nice if there was some reasonable way\n            # of doing this without generating a whole load of\n            # intermediate tuples.  But tuples does seem like the\n            # easiest way, with no other way clearly much simpler or\n            # much faster.  (Actually, the L to LA conversion could\n            # perhaps go faster (all those 1-tuples!), but I still\n            # wonder whether the code proliferation is worth it)\n            it = self.transparent\n            maxval = 2**meta[\'bitdepth\']-1\n            planes = meta[\'planes\']\n            meta[\'alpha\'] = True\n            meta[\'planes\'] += 1\n            typecode = \'BH\'[meta[\'bitdepth\']>8]\n            def itertrns(pixels):\n                for row in pixels:\n                    # For each row we group it into pixels, then form a\n                    # characterisation vector that says whether each\n                    # pixel is opaque or not.  Then we convert\n                    # True/False to 0/maxval (by multiplication),\n                    # and add it as the extra channel.\n                    row = group(row, planes)\n                    opa = map(it.__ne__, row)\n                    opa = map(maxval.__mul__, opa)\n                    opa = zip(opa) # convert to 1-tuples\n                    yield array(typecode,\n                      itertools.chain(*map(operator.add, row, opa)))\n            pixels = itertrns(pixels)\n        targetbitdepth = None\n        if self.sbit:\n            sbit = struct.unpack(\'%dB\' % len(self.sbit), self.sbit)\n            targetbitdepth = max(sbit)\n            if targetbitdepth > meta[\'bitdepth\']:\n                raise Error(\'sBIT chunk %r exceeds bitdepth %d\' %\n                    (sbit,self.bitdepth))\n            if min(sbit) <= 0:\n                raise Error(\'sBIT chunk %r has a 0-entry\' % sbit)\n            if targetbitdepth == meta[\'bitdepth\']:\n                targetbitdepth = None\n        if targetbitdepth:\n            shift = meta[\'bitdepth\'] - targetbitdepth\n            meta[\'bitdepth\'] = targetbitdepth\n            def itershift(pixels):\n                for row in pixels:\n                    yield map(shift.__rrshift__, row)\n            pixels = itershift(pixels)\n        return x,y,pixels,meta\n\n    def asFloat(self, maxval=1.0):\n        """"""Return image pixels as per :meth:`asDirect` method, but scale\n        all pixel values to be floating point values between 0.0 and\n        *maxval*.\n        """"""\n\n        x,y,pixels,info = self.asDirect()\n        sourcemaxval = 2**info[\'bitdepth\']-1\n        del info[\'bitdepth\']\n        info[\'maxval\'] = float(maxval)\n        factor = float(maxval)/float(sourcemaxval)\n        def iterfloat():\n            for row in pixels:\n                yield map(factor.__mul__, row)\n        return x,y,iterfloat(),info\n\n    def _as_rescale(self, get, targetbitdepth):\n        """"""Helper used by :meth:`asRGB8` and :meth:`asRGBA8`.""""""\n\n        width,height,pixels,meta = get()\n        maxval = 2**meta[\'bitdepth\'] - 1\n        targetmaxval = 2**targetbitdepth - 1\n        factor = float(targetmaxval) / float(maxval)\n        meta[\'bitdepth\'] = targetbitdepth\n        def iterscale():\n            for row in pixels:\n                yield map(lambda x: int(round(x*factor)), row)\n        if maxval == targetmaxval:\n            return width, height, pixels, meta\n        else:\n            return width, height, iterscale(), meta\n\n    def asRGB8(self):\n        """"""Return the image data as an RGB pixels with 8-bits per\n        sample.  This is like the :meth:`asRGB` method except that\n        this method additionally rescales the values so that they\n        are all between 0 and 255 (8-bit).  In the case where the\n        source image has a bit depth < 8 the transformation preserves\n        all the information; where the source image has bit depth\n        > 8, then rescaling to 8-bit values loses precision.  No\n        dithering is performed.  Like :meth:`asRGB`, an alpha channel\n        in the source image will raise an exception.\n\n        This function returns a 4-tuple:\n        (*width*, *height*, *pixels*, *metadata*).\n        *width*, *height*, *metadata* are as per the\n        :meth:`read` method.\n        \n        *pixels* is the pixel data in boxed row flat pixel format.\n        """"""\n\n        return self._as_rescale(self.asRGB, 8)\n\n    def asRGBA8(self):\n        """"""Return the image data as RGBA pixels with 8-bits per\n        sample.  This method is similar to :meth:`asRGB8` and\n        :meth:`asRGBA`:  The result pixels have an alpha channel, *and*\n        values are rescaled to the range 0 to 255.  The alpha channel is\n        synthesized if necessary (with a small speed penalty).\n        """"""\n\n        return self._as_rescale(self.asRGBA, 8)\n\n    def asRGB(self):\n        """"""Return image as RGB pixels.  RGB colour images are passed\n        through unchanged; greyscales are expanded into RGB\n        triplets (there is a small speed overhead for doing this).\n\n        An alpha channel in the source image will raise an\n        exception.\n\n        The return values are as for the :meth:`read` method\n        except that the *metadata* reflect the returned pixels, not the\n        source image.  In particular, for this method\n        ``metadata[\'greyscale\']`` will be ``False``.\n        """"""\n\n        width,height,pixels,meta = self.asDirect()\n        if meta[\'alpha\']:\n            raise Error(""will not convert image with alpha channel to RGB"")\n        if not meta[\'greyscale\']:\n            return width,height,pixels,meta\n        meta[\'greyscale\'] = False\n        typecode = \'BH\'[meta[\'bitdepth\'] > 8]\n        def iterrgb():\n            for row in pixels:\n                a = array(typecode, [0]) * 3 * width\n                for i in range(3):\n                    a[i::3] = row\n                yield a\n        return width,height,iterrgb(),meta\n\n    def asRGBA(self):\n        """"""Return image as RGBA pixels.  Greyscales are expanded into\n        RGB triplets; an alpha channel is synthesized if necessary.\n        The return values are as for the :meth:`read` method\n        except that the *metadata* reflect the returned pixels, not the\n        source image.  In particular, for this method\n        ``metadata[\'greyscale\']`` will be ``False``, and\n        ``metadata[\'alpha\']`` will be ``True``.\n        """"""\n\n        width,height,pixels,meta = self.asDirect()\n        if meta[\'alpha\'] and not meta[\'greyscale\']:\n            return width,height,pixels,meta\n        typecode = \'BH\'[meta[\'bitdepth\'] > 8]\n        maxval = 2**meta[\'bitdepth\'] - 1\n        maxbuffer = struct.pack(\'=\' + typecode, maxval) * 4 * width\n        def newarray():\n            return array(typecode, maxbuffer)\n\n        if meta[\'alpha\'] and meta[\'greyscale\']:\n            # LA to RGBA\n            def convert():\n                for row in pixels:\n                    # Create a fresh target row, then copy L channel\n                    # into first three target channels, and A channel\n                    # into fourth channel.\n                    a = newarray()\n                    pngfilters.convert_la_to_rgba(row, a)\n                    yield a\n        elif meta[\'greyscale\']:\n            # L to RGBA\n            def convert():\n                for row in pixels:\n                    a = newarray()\n                    pngfilters.convert_l_to_rgba(row, a)\n                    yield a\n        else:\n            assert not meta[\'alpha\'] and not meta[\'greyscale\']\n            # RGB to RGBA\n            def convert():\n                for row in pixels:\n                    a = newarray()\n                    pngfilters.convert_rgb_to_rgba(row, a)\n                    yield a\n        meta[\'alpha\'] = True\n        meta[\'greyscale\'] = False\n        return width,height,convert(),meta\n\ndef check_bitdepth_colortype(bitdepth, colortype):\n    """"""Check that `bitdepth` and `colortype` are both valid,\n    and specified in a valid combination. Returns if valid,\n    raise an Exception if not valid.\n    """"""\n\n    if bitdepth not in (1,2,4,8,16):\n        raise FormatError(""invalid bit depth %d"" % bitdepth)\n    if colortype not in (0,2,3,4,6):\n        raise FormatError(""invalid colour type %d"" % colortype)\n    # Check indexed (palettized) images have 8 or fewer bits\n    # per pixel; check only indexed or greyscale images have\n    # fewer than 8 bits per pixel.\n    if colortype & 1 and bitdepth > 8:\n        raise FormatError(\n          ""Indexed images (colour type %d) cannot""\n          "" have bitdepth > 8 (bit depth %d).""\n          "" See http://www.w3.org/TR/2003/REC-PNG-20031110/#table111 .""\n          % (bitdepth, colortype))\n    if bitdepth < 8 and colortype not in (0,3):\n        raise FormatError(""Illegal combination of bit depth (%d)""\n          "" and colour type (%d).""\n          "" See http://www.w3.org/TR/2003/REC-PNG-20031110/#table111 .""\n          % (bitdepth, colortype))\n\ndef isinteger(x):\n    try:\n        return int(x) == x\n    except (TypeError, ValueError):\n        return False\n\n\n# === Legacy Version Support ===\n\n# :pyver:old:  PyPNG works on Python versions 2.3 and 2.2, but not\n# without some awkward problems.  Really PyPNG works on Python 2.4 (and\n# above); it works on Pythons 2.3 and 2.2 by virtue of fixing up\n# problems here.  It\'s a bit ugly (which is why it\'s hidden down here).\n#\n# Generally the strategy is one of pretending that we\'re running on\n# Python 2.4 (or above), and patching up the library support on earlier\n# versions so that it looks enough like Python 2.4.  When it comes to\n# Python 2.2 there is one thing we cannot patch: extended slices\n# http://www.python.org/doc/2.3/whatsnew/section-slices.html.\n# Instead we simply declare that features that are implemented using\n# extended slices will not work on Python 2.2.\n#\n# In order to work on Python 2.3 we fix up a recurring annoyance involving\n# the array type.  In Python 2.3 an array cannot be initialised with an\n# array, and it cannot be extended with a list (or other sequence).\n# Both of those are repeated issues in the code.  Whilst I would not\n# normally tolerate this sort of behaviour, here we ""shim"" a replacement\n# for array into place (and hope no-one notices).  You never read this.\n#\n# In an amusing case of warty hacks on top of warty hacks... the array\n# shimming we try and do only works on Python 2.3 and above (you can\'t\n# subclass array.array in Python 2.2).  So to get it working on Python\n# 2.2 we go for something much simpler and (probably) way slower.\ntry:\n    array(\'B\').extend([])\n    array(\'B\', array(\'B\'))\n# :todo:(drj) Check that TypeError is correct for Python 2.3\nexcept TypeError:\n    # Expect to get here on Python 2.3\n    try:\n        class _array_shim(array):\n            true_array = array\n            def __new__(cls, typecode, init=None):\n                super_new = super(_array_shim, cls).__new__\n                it = super_new(cls, typecode)\n                if init is None:\n                    return it\n                it.extend(init)\n                return it\n            def extend(self, extension):\n                super_extend = super(_array_shim, self).extend\n                if isinstance(extension, self.true_array):\n                    return super_extend(extension)\n                if not isinstance(extension, (list, str)):\n                    # Convert to list.  Allows iterators to work.\n                    extension = list(extension)\n                return super_extend(self.true_array(self.typecode, extension))\n        array = _array_shim\n    except TypeError:\n        # Expect to get here on Python 2.2\n        def array(typecode, init=()):\n            if type(init) == str:\n                return map(ord, init)\n            return list(init)\n\n# Further hacks to get it limping along on Python 2.2\ntry:\n    enumerate\nexcept NameError:\n    def enumerate(seq):\n        i=0\n        for x in seq:\n            yield i,x\n            i += 1\n\ntry:\n    reversed\nexcept NameError:\n    def reversed(l):\n        l = list(l)\n        l.reverse()\n        for x in l:\n            yield x\n\ntry:\n    itertools\nexcept NameError:\n    class _dummy_itertools:\n        pass\n    itertools = _dummy_itertools()\n    def _itertools_imap(f, seq):\n        for x in seq:\n            yield f(x)\n    itertools.imap = _itertools_imap\n    def _itertools_chain(*iterables):\n        for it in iterables:\n            for element in it:\n                yield element\n    itertools.chain = _itertools_chain\n\n\n# === Support for users without Cython ===\n\ntry:\n    pngfilters\nexcept NameError:\n    class pngfilters(object):\n        def undo_filter_sub(filter_unit, scanline, previous, result):\n            """"""Undo sub filter.""""""\n\n            ai = 0\n            # Loops starts at index fu.  Observe that the initial part\n            # of the result is already filled in correctly with\n            # scanline.\n            for i in range(filter_unit, len(result)):\n                x = scanline[i]\n                a = result[ai]\n                result[i] = (x + a) & 0xff\n                ai += 1\n        undo_filter_sub = staticmethod(undo_filter_sub)\n\n        def undo_filter_up(filter_unit, scanline, previous, result):\n            """"""Undo up filter.""""""\n\n            for i in range(len(result)):\n                x = scanline[i]\n                b = previous[i]\n                result[i] = (x + b) & 0xff\n        undo_filter_up = staticmethod(undo_filter_up)\n\n        def undo_filter_average(filter_unit, scanline, previous, result):\n            """"""Undo up filter.""""""\n\n            ai = -filter_unit\n            for i in range(len(result)):\n                x = scanline[i]\n                if ai < 0:\n                    a = 0\n                else:\n                    a = result[ai]\n                b = previous[i]\n                result[i] = (x + ((a + b) >> 1)) & 0xff\n                ai += 1\n        undo_filter_average = staticmethod(undo_filter_average)\n\n        def undo_filter_paeth(filter_unit, scanline, previous, result):\n            """"""Undo Paeth filter.""""""\n\n            # Also used for ci.\n            ai = -filter_unit\n            for i in range(len(result)):\n                x = scanline[i]\n                if ai < 0:\n                    a = c = 0\n                else:\n                    a = result[ai]\n                    c = previous[ai]\n                b = previous[i]\n                p = a + b - c\n                pa = abs(p - a)\n                pb = abs(p - b)\n                pc = abs(p - c)\n                if pa <= pb and pa <= pc:\n                    pr = a\n                elif pb <= pc:\n                    pr = b\n                else:\n                    pr = c\n                result[i] = (x + pr) & 0xff\n                ai += 1\n        undo_filter_paeth = staticmethod(undo_filter_paeth)\n\n        def convert_la_to_rgba(row, result):\n            for i in range(3):\n                result[i::4] = row[0::2]\n            result[3::4] = row[1::2]\n        convert_la_to_rgba = staticmethod(convert_la_to_rgba)\n\n        def convert_l_to_rgba(row, result):\n            """"""Convert a grayscale image to RGBA. This method assumes\n            the alpha channel in result is already correctly\n            initialized.\n            """"""\n            for i in range(3):\n                result[i::4] = row\n        convert_l_to_rgba = staticmethod(convert_l_to_rgba)\n\n        def convert_rgb_to_rgba(row, result):\n            """"""Convert an RGB image to RGBA. This method assumes the\n            alpha channel in result is already correctly initialized.\n            """"""\n            for i in range(3):\n                result[i::4] = row[i::3]\n        convert_rgb_to_rgba = staticmethod(convert_rgb_to_rgba)\n\n\n# === Command Line Support ===\n\ndef read_pam_header(infile):\n    """"""\n    Read (the rest of a) PAM header.  `infile` should be positioned\n    immediately after the initial \'P7\' line (at the beginning of the\n    second line).  Returns are as for `read_pnm_header`.\n    """"""\n    \n    # Unlike PBM, PGM, and PPM, we can read the header a line at a time.\n    header = dict()\n    while True:\n        l = infile.readline().strip()\n        if l == strtobytes(\'ENDHDR\'):\n            break\n        if not l:\n            raise EOFError(\'PAM ended prematurely\')\n        if l[0] == strtobytes(\'#\'):\n            continue\n        l = l.split(None, 1)\n        if l[0] not in header:\n            header[l[0]] = l[1]\n        else:\n            header[l[0]] += strtobytes(\' \') + l[1]\n\n    required = [\'WIDTH\', \'HEIGHT\', \'DEPTH\', \'MAXVAL\']\n    required = [strtobytes(x) for x in required]\n    WIDTH,HEIGHT,DEPTH,MAXVAL = required\n    present = [x for x in required if x in header]\n    if len(present) != len(required):\n        raise Error(\'PAM file must specify WIDTH, HEIGHT, DEPTH, and MAXVAL\')\n    width = int(header[WIDTH])\n    height = int(header[HEIGHT])\n    depth = int(header[DEPTH])\n    maxval = int(header[MAXVAL])\n    if (width <= 0 or\n        height <= 0 or\n        depth <= 0 or\n        maxval <= 0):\n        raise Error(\n          \'WIDTH, HEIGHT, DEPTH, MAXVAL must all be positive integers\')\n    return \'P7\', width, height, depth, maxval\n\ndef read_pnm_header(infile, supported=(\'P5\',\'P6\')):\n    """"""\n    Read a PNM header, returning (format,width,height,depth,maxval).\n    `width` and `height` are in pixels.  `depth` is the number of\n    channels in the image; for PBM and PGM it is synthesized as 1, for\n    PPM as 3; for PAM images it is read from the header.  `maxval` is\n    synthesized (as 1) for PBM images.\n    """"""\n\n    # Generally, see http://netpbm.sourceforge.net/doc/ppm.html\n    # and http://netpbm.sourceforge.net/doc/pam.html\n\n    supported = [strtobytes(x) for x in supported]\n\n    # Technically \'P7\' must be followed by a newline, so by using\n    # rstrip() we are being liberal in what we accept.  I think this\n    # is acceptable.\n    type = infile.read(3).rstrip()\n    if type not in supported:\n        raise NotImplementedError(\'file format %s not supported\' % type)\n    if type == strtobytes(\'P7\'):\n        # PAM header parsing is completely different.\n        return read_pam_header(infile)\n    # Expected number of tokens in header (3 for P4, 4 for P6)\n    expected = 4\n    pbm = (\'P1\', \'P4\')\n    if type in pbm:\n        expected = 3\n    header = [type]\n\n    # We have to read the rest of the header byte by byte because the\n    # final whitespace character (immediately following the MAXVAL in\n    # the case of P6) may not be a newline.  Of course all PNM files in\n    # the wild use a newline at this point, so it\'s tempting to use\n    # readline; but it would be wrong.\n    def getc():\n        c = infile.read(1)\n        if not c:\n            raise Error(\'premature EOF reading PNM header\')\n        return c\n\n    c = getc()\n    while True:\n        # Skip whitespace that precedes a token.\n        while c.isspace():\n            c = getc()\n        # Skip comments.\n        while c == \'#\':\n            while c not in \'\\n\\r\':\n                c = getc()\n        if not c.isdigit():\n            raise Error(\'unexpected character %s found in header\' % c)\n        # According to the specification it is legal to have comments\n        # that appear in the middle of a token.\n        # This is bonkers; I\'ve never seen it; and it\'s a bit awkward to\n        # code good lexers in Python (no goto).  So we break on such\n        # cases.\n        token = strtobytes(\'\')\n        while c.isdigit():\n            token += c\n            c = getc()\n        # Slight hack.  All ""tokens"" are decimal integers, so convert\n        # them here.\n        header.append(int(token))\n        if len(header) == expected:\n            break\n    # Skip comments (again)\n    while c == \'#\':\n        while c not in \'\\n\\r\':\n            c = getc()\n    if not c.isspace():\n        raise Error(\'expected header to end with whitespace, not %s\' % c)\n\n    if type in pbm:\n        # synthesize a MAXVAL\n        header.append(1)\n    depth = (1,3)[type == strtobytes(\'P6\')]\n    return header[0], header[1], header[2], depth, header[3]\n\ndef write_pnm(file, width, height, pixels, meta):\n    """"""Write a Netpbm PNM/PAM file.\n    """"""\n\n    bitdepth = meta[\'bitdepth\']\n    maxval = 2**bitdepth - 1\n    # Rudely, the number of image planes can be used to determine\n    # whether we are L (PGM), LA (PAM), RGB (PPM), or RGBA (PAM).\n    planes = meta[\'planes\']\n    # Can be an assert as long as we assume that pixels and meta came\n    # from a PNG file.\n    assert planes in (1,2,3,4)\n    if planes in (1,3):\n        if 1 == planes:\n            # PGM\n            # Could generate PBM if maxval is 1, but we don\'t (for one\n            # thing, we\'d have to convert the data, not just blat it\n            # out).\n            fmt = \'P5\'\n        else:\n            # PPM\n            fmt = \'P6\'\n        header = \'%s %d %d %d\\n\' % (fmt, width, height, maxval)\n    if planes in (2,4):\n        # PAM\n        # See http://netpbm.sourceforge.net/doc/pam.html\n        if 2 == planes:\n            tupltype = \'GRAYSCALE_ALPHA\'\n        else:\n            tupltype = \'RGB_ALPHA\'\n        header = (\'P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\n\'\n                  \'TUPLTYPE %s\\nENDHDR\\n\' %\n                  (width, height, planes, maxval, tupltype))\n    file.write(header.encode(\'ascii\'))\n    # Values per row\n    vpr = planes * width\n    # struct format\n    fmt = \'>%d\' % vpr\n    if maxval > 0xff:\n        fmt = fmt + \'H\'\n    else:\n        fmt = fmt + \'B\'\n    for row in pixels:\n        file.write(struct.pack(fmt, *row))\n    file.flush()\n\ndef color_triple(color):\n    """"""\n    Convert a command line colour value to a RGB triple of integers.\n    FIXME: Somewhere we need support for greyscale backgrounds etc.\n    """"""\n    if color.startswith(\'#\') and len(color) == 4:\n        return (int(color[1], 16),\n                int(color[2], 16),\n                int(color[3], 16))\n    if color.startswith(\'#\') and len(color) == 7:\n        return (int(color[1:3], 16),\n                int(color[3:5], 16),\n                int(color[5:7], 16))\n    elif color.startswith(\'#\') and len(color) == 13:\n        return (int(color[1:5], 16),\n                int(color[5:9], 16),\n                int(color[9:13], 16))\n\ndef _add_common_options(parser):\n    """"""Call *parser.add_option* for each of the options that are\n    common between this PNG--PNM conversion tool and the gen\n    tool.\n    """"""\n    parser.add_option(""-i"", ""--interlace"",\n                      default=False, action=""store_true"",\n                      help=""create an interlaced PNG file (Adam7)"")\n    parser.add_option(""-t"", ""--transparent"",\n                      action=""store"", type=""string"", metavar=""#RRGGBB"",\n                      help=""mark the specified colour as transparent"")\n    parser.add_option(""-b"", ""--background"",\n                      action=""store"", type=""string"", metavar=""#RRGGBB"",\n                      help=""save the specified background colour"")\n    parser.add_option(""-g"", ""--gamma"",\n                      action=""store"", type=""float"", metavar=""value"",\n                      help=""save the specified gamma value"")\n    parser.add_option(""-c"", ""--compression"",\n                      action=""store"", type=""int"", metavar=""level"",\n                      help=""zlib compression level (0-9)"")\n    return parser\n\ndef _main(argv):\n    """"""\n    Run the PNG encoder with options from the command line.\n    """"""\n\n    # Parse command line arguments\n    from optparse import OptionParser\n    import re\n    version = \'%prog \' + __version__\n    parser = OptionParser(version=version)\n    parser.set_usage(""%prog [options] [imagefile]"")\n    parser.add_option(\'-r\', \'--read-png\', default=False,\n                      action=\'store_true\',\n                      help=\'Read PNG, write PNM\')\n    parser.add_option(""-a"", ""--alpha"",\n                      action=""store"", type=""string"", metavar=""pgmfile"",\n                      help=""alpha channel transparency (RGBA)"")\n    _add_common_options(parser)\n\n    (options, args) = parser.parse_args(args=argv[1:])\n\n    # Convert options\n    if options.transparent is not None:\n        options.transparent = color_triple(options.transparent)\n    if options.background is not None:\n        options.background = color_triple(options.background)\n\n    # Prepare input and output files\n    if len(args) == 0:\n        infilename = \'-\'\n        infile = sys.stdin\n    elif len(args) == 1:\n        infilename = args[0]\n        infile = open(infilename, \'rb\')\n    else:\n        parser.error(""more than one input file"")\n    outfile = sys.stdout\n    if sys.platform == ""win32"":\n        import msvcrt, os\n        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n\n    if options.read_png:\n        # Encode PNG to PPM\n        png = Reader(file=infile)\n        width,height,pixels,meta = png.asDirect()\n        write_pnm(outfile, width, height, pixels, meta) \n    else:\n        # Encode PNM to PNG\n        format, width, height, depth, maxval = \\\n          read_pnm_header(infile, (\'P5\',\'P6\',\'P7\'))\n        # When it comes to the variety of input formats, we do something\n        # rather rude.  Observe that L, LA, RGB, RGBA are the 4 colour\n        # types supported by PNG and that they correspond to 1, 2, 3, 4\n        # channels respectively.  So we use the number of channels in\n        # the source image to determine which one we have.  We do not\n        # care about TUPLTYPE.\n        greyscale = depth <= 2\n        pamalpha = depth in (2,4)\n        supported = map(lambda x: 2**x-1, range(1,17))\n        try:\n            mi = supported.index(maxval)\n        except ValueError:\n            raise NotImplementedError(\n              \'your maxval (%s) not in supported list %s\' %\n              (maxval, str(supported)))\n        bitdepth = mi+1\n        writer = Writer(width, height,\n                        greyscale=greyscale,\n                        bitdepth=bitdepth,\n                        interlace=options.interlace,\n                        transparent=options.transparent,\n                        background=options.background,\n                        alpha=bool(pamalpha or options.alpha),\n                        gamma=options.gamma,\n                        compression=options.compression)\n        if options.alpha:\n            pgmfile = open(options.alpha, \'rb\')\n            format, awidth, aheight, adepth, amaxval = \\\n              read_pnm_header(pgmfile, \'P5\')\n            if amaxval != \'255\':\n                raise NotImplementedError(\n                  \'maxval %s not supported for alpha channel\' % amaxval)\n            if (awidth, aheight) != (width, height):\n                raise ValueError(""alpha channel image size mismatch""\n                                 "" (%s has %sx%s but %s has %sx%s)""\n                                 % (infilename, width, height,\n                                    options.alpha, awidth, aheight))\n            writer.convert_ppm_and_pgm(infile, pgmfile, outfile)\n        else:\n            writer.convert_pnm(infile, outfile)\n\n\nif __name__ == \'__main__\':\n    try:\n        _main(sys.argv)\n    except Error as e:\n        print(e, file=sys.stderr)\n'"
glumpy/ext/six.py,0,"b'""""""Utilities for writing code that runs on Python 2 and 3""""""\n\n# Copyright (c) 2010-2014 Benjamin Peterson\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport functools\nimport operator\nimport sys\nimport types\n\n__author__ = ""Benjamin Peterson <benjamin@python.org>""\n__version__ = ""1.6.1""\n\n\n# Useful for very coarse version differentiation.\nPY2 = sys.version_info[0] == 2\nPY3 = sys.version_info[0] == 3\n\nif PY3:\n    string_types = str,\n    integer_types = int,\n    class_types = type,\n    text_type = str\n    binary_type = bytes\n\n    MAXSIZE = sys.maxsize\nelse:\n    string_types = basestring,\n    integer_types = (int, long)\n    class_types = (type, types.ClassType)\n    text_type = unicode\n    binary_type = str\n\n    if sys.platform.startswith(""java""):\n        # Jython always uses 32 bits.\n        MAXSIZE = int((1 << 31) - 1)\n    else:\n        # It\'s possible to have sizeof(long) != sizeof(Py_ssize_t).\n        class X(object):\n            def __len__(self):\n                return 1 << 31\n        try:\n            len(X())\n        except OverflowError:\n            # 32-bit\n            MAXSIZE = int((1 << 31) - 1)\n        else:\n            # 64-bit\n            MAXSIZE = int((1 << 63) - 1)\n        del X\n\n\ndef _add_doc(func, doc):\n    """"""Add documentation to a function.""""""\n    func.__doc__ = doc\n\n\ndef _import_module(name):\n    """"""Import module, returning the module after the last dot.""""""\n    __import__(name)\n    return sys.modules[name]\n\n\nclass _LazyDescr(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, obj, tp):\n        try:\n            result = self._resolve()\n        except ImportError:\n            # See the nice big comment in MovedModule.__getattr__.\n            raise AttributeError(""%s could not be imported "" % self.name)\n        setattr(obj, self.name, result) # Invokes __set__.\n        # This is a bit ugly, but it avoids running this again.\n        delattr(obj.__class__, self.name)\n        return result\n\n\nclass MovedModule(_LazyDescr):\n\n    def __init__(self, name, old, new=None):\n        super(MovedModule, self).__init__(name)\n        if PY3:\n            if new is None:\n                new = name\n            self.mod = new\n        else:\n            self.mod = old\n\n    def _resolve(self):\n        return _import_module(self.mod)\n\n    def __getattr__(self, attr):\n        # It turns out many Python frameworks like to traverse sys.modules and\n        # try to load various attributes. This causes problems if this is a\n        # platform-specific module on the wrong platform, like _winreg on\n        # Unixes. Therefore, we silently pretend unimportable modules do not\n        # have any attributes. See issues #51, #53, #56, and #63 for the full\n        # tales of woe.\n        #\n        # First, if possible, avoid loading the module just to look at __file__,\n        # __name__, or __path__.\n        if (attr in (""__file__"", ""__name__"", ""__path__"") and\n            self.mod not in sys.modules):\n            raise AttributeError(attr)\n        try:\n            _module = self._resolve()\n        except ImportError:\n            raise AttributeError(attr)\n        value = getattr(_module, attr)\n        setattr(self, attr, value)\n        return value\n\n\nclass _LazyModule(types.ModuleType):\n\n    def __init__(self, name):\n        super(_LazyModule, self).__init__(name)\n        self.__doc__ = self.__class__.__doc__\n\n    def __dir__(self):\n        attrs = [""__doc__"", ""__name__""]\n        attrs += [attr.name for attr in self._moved_attributes]\n        return attrs\n\n    # Subclasses should override this\n    _moved_attributes = []\n\n\nclass MovedAttribute(_LazyDescr):\n\n    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):\n        super(MovedAttribute, self).__init__(name)\n        if PY3:\n            if new_mod is None:\n                new_mod = name\n            self.mod = new_mod\n            if new_attr is None:\n                if old_attr is None:\n                    new_attr = name\n                else:\n                    new_attr = old_attr\n            self.attr = new_attr\n        else:\n            self.mod = old_mod\n            if old_attr is None:\n                old_attr = name\n            self.attr = old_attr\n\n    def _resolve(self):\n        module = _import_module(self.mod)\n        return getattr(module, self.attr)\n\n\n\nclass _MovedItems(_LazyModule):\n    """"""Lazy loading of moved objects""""""\n\n\n_moved_attributes = [\n    MovedAttribute(""cStringIO"", ""cStringIO"", ""io"", ""StringIO""),\n    MovedAttribute(""filter"", ""itertools"", ""builtins"", ""ifilter"", ""filter""),\n    MovedAttribute(""filterfalse"", ""itertools"", ""itertools"", ""ifilterfalse"", ""filterfalse""),\n    MovedAttribute(""input"", ""__builtin__"", ""builtins"", ""raw_input"", ""input""),\n    MovedAttribute(""map"", ""itertools"", ""builtins"", ""imap"", ""map""),\n    MovedAttribute(""range"", ""__builtin__"", ""builtins"", ""xrange"", ""range""),\n    MovedAttribute(""reload_module"", ""__builtin__"", ""imp"", ""reload""),\n    MovedAttribute(""reduce"", ""__builtin__"", ""functools""),\n    MovedAttribute(""StringIO"", ""StringIO"", ""io""),\n    MovedAttribute(""UserDict"", ""UserDict"", ""collections""),\n    MovedAttribute(""UserList"", ""UserList"", ""collections""),\n    MovedAttribute(""UserString"", ""UserString"", ""collections""),\n    MovedAttribute(""xrange"", ""__builtin__"", ""builtins"", ""xrange"", ""range""),\n    MovedAttribute(""zip"", ""itertools"", ""builtins"", ""izip"", ""zip""),\n    MovedAttribute(""zip_longest"", ""itertools"", ""itertools"", ""izip_longest"", ""zip_longest""),\n\n    MovedModule(""builtins"", ""__builtin__""),\n    MovedModule(""configparser"", ""ConfigParser""),\n    MovedModule(""copyreg"", ""copy_reg""),\n    MovedModule(""dbm_gnu"", ""gdbm"", ""dbm.gnu""),\n    MovedModule(""_dummy_thread"", ""dummy_thread"", ""_dummy_thread""),\n    MovedModule(""http_cookiejar"", ""cookielib"", ""http.cookiejar""),\n    MovedModule(""http_cookies"", ""Cookie"", ""http.cookies""),\n    MovedModule(""html_entities"", ""htmlentitydefs"", ""html.entities""),\n    MovedModule(""html_parser"", ""HTMLParser"", ""html.parser""),\n    MovedModule(""http_client"", ""httplib"", ""http.client""),\n    MovedModule(""email_mime_multipart"", ""email.MIMEMultipart"", ""email.mime.multipart""),\n    MovedModule(""email_mime_text"", ""email.MIMEText"", ""email.mime.text""),\n    MovedModule(""email_mime_base"", ""email.MIMEBase"", ""email.mime.base""),\n    MovedModule(""BaseHTTPServer"", ""BaseHTTPServer"", ""http.server""),\n    MovedModule(""CGIHTTPServer"", ""CGIHTTPServer"", ""http.server""),\n    MovedModule(""SimpleHTTPServer"", ""SimpleHTTPServer"", ""http.server""),\n    MovedModule(""cPickle"", ""cPickle"", ""pickle""),\n    MovedModule(""queue"", ""Queue""),\n    MovedModule(""reprlib"", ""repr""),\n    MovedModule(""socketserver"", ""SocketServer""),\n    MovedModule(""_thread"", ""thread"", ""_thread""),\n    MovedModule(""tkinter"", ""Tkinter""),\n    MovedModule(""tkinter_dialog"", ""Dialog"", ""tkinter.dialog""),\n    MovedModule(""tkinter_filedialog"", ""FileDialog"", ""tkinter.filedialog""),\n    MovedModule(""tkinter_scrolledtext"", ""ScrolledText"", ""tkinter.scrolledtext""),\n    MovedModule(""tkinter_simpledialog"", ""SimpleDialog"", ""tkinter.simpledialog""),\n    MovedModule(""tkinter_tix"", ""Tix"", ""tkinter.tix""),\n    MovedModule(""tkinter_ttk"", ""ttk"", ""tkinter.ttk""),\n    MovedModule(""tkinter_constants"", ""Tkconstants"", ""tkinter.constants""),\n    MovedModule(""tkinter_dnd"", ""Tkdnd"", ""tkinter.dnd""),\n    MovedModule(""tkinter_colorchooser"", ""tkColorChooser"",\n                ""tkinter.colorchooser""),\n    MovedModule(""tkinter_commondialog"", ""tkCommonDialog"",\n                ""tkinter.commondialog""),\n    MovedModule(""tkinter_tkfiledialog"", ""tkFileDialog"", ""tkinter.filedialog""),\n    MovedModule(""tkinter_font"", ""tkFont"", ""tkinter.font""),\n    MovedModule(""tkinter_messagebox"", ""tkMessageBox"", ""tkinter.messagebox""),\n    MovedModule(""tkinter_tksimpledialog"", ""tkSimpleDialog"",\n                ""tkinter.simpledialog""),\n    MovedModule(""urllib_parse"", __name__ + "".moves.urllib_parse"", ""urllib.parse""),\n    MovedModule(""urllib_error"", __name__ + "".moves.urllib_error"", ""urllib.error""),\n    MovedModule(""urllib"", __name__ + "".moves.urllib"", __name__ + "".moves.urllib""),\n    MovedModule(""urllib_robotparser"", ""robotparser"", ""urllib.robotparser""),\n    MovedModule(""xmlrpc_client"", ""xmlrpclib"", ""xmlrpc.client""),\n    MovedModule(""xmlrpc_server"", ""xmlrpclib"", ""xmlrpc.server""),\n    MovedModule(""winreg"", ""_winreg""),\n]\nfor attr in _moved_attributes:\n    setattr(_MovedItems, attr.name, attr)\n    if isinstance(attr, MovedModule):\n        sys.modules[__name__ + "".moves."" + attr.name] = attr\ndel attr\n\n_MovedItems._moved_attributes = _moved_attributes\n\nmoves = sys.modules[__name__ + "".moves""] = _MovedItems(__name__ + "".moves"")\n\n\nclass Module_six_moves_urllib_parse(_LazyModule):\n    """"""Lazy loading of moved objects in six.moves.urllib_parse""""""\n\n\n_urllib_parse_moved_attributes = [\n    MovedAttribute(""ParseResult"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""SplitResult"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""parse_qs"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""parse_qsl"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""urldefrag"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""urljoin"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""urlparse"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""urlsplit"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""urlunparse"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""urlunsplit"", ""urlparse"", ""urllib.parse""),\n    MovedAttribute(""quote"", ""urllib"", ""urllib.parse""),\n    MovedAttribute(""quote_plus"", ""urllib"", ""urllib.parse""),\n    MovedAttribute(""unquote"", ""urllib"", ""urllib.parse""),\n    MovedAttribute(""unquote_plus"", ""urllib"", ""urllib.parse""),\n    MovedAttribute(""urlencode"", ""urllib"", ""urllib.parse""),\n    MovedAttribute(""splitquery"", ""urllib"", ""urllib.parse""),\n]\nfor attr in _urllib_parse_moved_attributes:\n    setattr(Module_six_moves_urllib_parse, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes\n\nsys.modules[__name__ + "".moves.urllib_parse""] = sys.modules[__name__ + "".moves.urllib.parse""] = Module_six_moves_urllib_parse(__name__ + "".moves.urllib_parse"")\n\n\nclass Module_six_moves_urllib_error(_LazyModule):\n    """"""Lazy loading of moved objects in six.moves.urllib_error""""""\n\n\n_urllib_error_moved_attributes = [\n    MovedAttribute(""URLError"", ""urllib2"", ""urllib.error""),\n    MovedAttribute(""HTTPError"", ""urllib2"", ""urllib.error""),\n    MovedAttribute(""ContentTooShortError"", ""urllib"", ""urllib.error""),\n]\nfor attr in _urllib_error_moved_attributes:\n    setattr(Module_six_moves_urllib_error, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes\n\nsys.modules[__name__ + "".moves.urllib_error""] = sys.modules[__name__ + "".moves.urllib.error""] = Module_six_moves_urllib_error(__name__ + "".moves.urllib.error"")\n\n\nclass Module_six_moves_urllib_request(_LazyModule):\n    """"""Lazy loading of moved objects in six.moves.urllib_request""""""\n\n\n_urllib_request_moved_attributes = [\n    MovedAttribute(""urlopen"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""install_opener"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""build_opener"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""pathname2url"", ""urllib"", ""urllib.request""),\n    MovedAttribute(""url2pathname"", ""urllib"", ""urllib.request""),\n    MovedAttribute(""getproxies"", ""urllib"", ""urllib.request""),\n    MovedAttribute(""Request"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""OpenerDirector"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPDefaultErrorHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPRedirectHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPCookieProcessor"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""ProxyHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""BaseHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPPasswordMgr"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPPasswordMgrWithDefaultRealm"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""AbstractBasicAuthHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPBasicAuthHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""ProxyBasicAuthHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""AbstractDigestAuthHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPDigestAuthHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""ProxyDigestAuthHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPSHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""FileHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""FTPHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""CacheFTPHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""UnknownHandler"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""HTTPErrorProcessor"", ""urllib2"", ""urllib.request""),\n    MovedAttribute(""urlretrieve"", ""urllib"", ""urllib.request""),\n    MovedAttribute(""urlcleanup"", ""urllib"", ""urllib.request""),\n    MovedAttribute(""URLopener"", ""urllib"", ""urllib.request""),\n    MovedAttribute(""FancyURLopener"", ""urllib"", ""urllib.request""),\n    MovedAttribute(""proxy_bypass"", ""urllib"", ""urllib.request""),\n]\nfor attr in _urllib_request_moved_attributes:\n    setattr(Module_six_moves_urllib_request, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes\n\nsys.modules[__name__ + "".moves.urllib_request""] = sys.modules[__name__ + "".moves.urllib.request""] = Module_six_moves_urllib_request(__name__ + "".moves.urllib.request"")\n\n\nclass Module_six_moves_urllib_response(_LazyModule):\n    """"""Lazy loading of moved objects in six.moves.urllib_response""""""\n\n\n_urllib_response_moved_attributes = [\n    MovedAttribute(""addbase"", ""urllib"", ""urllib.response""),\n    MovedAttribute(""addclosehook"", ""urllib"", ""urllib.response""),\n    MovedAttribute(""addinfo"", ""urllib"", ""urllib.response""),\n    MovedAttribute(""addinfourl"", ""urllib"", ""urllib.response""),\n]\nfor attr in _urllib_response_moved_attributes:\n    setattr(Module_six_moves_urllib_response, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes\n\nsys.modules[__name__ + "".moves.urllib_response""] = sys.modules[__name__ + "".moves.urllib.response""] = Module_six_moves_urllib_response(__name__ + "".moves.urllib.response"")\n\n\nclass Module_six_moves_urllib_robotparser(_LazyModule):\n    """"""Lazy loading of moved objects in six.moves.urllib_robotparser""""""\n\n\n_urllib_robotparser_moved_attributes = [\n    MovedAttribute(""RobotFileParser"", ""robotparser"", ""urllib.robotparser""),\n]\nfor attr in _urllib_robotparser_moved_attributes:\n    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes\n\nsys.modules[__name__ + "".moves.urllib_robotparser""] = sys.modules[__name__ + "".moves.urllib.robotparser""] = Module_six_moves_urllib_robotparser(__name__ + "".moves.urllib.robotparser"")\n\n\nclass Module_six_moves_urllib(types.ModuleType):\n    """"""Create a six.moves.urllib namespace that resembles the Python 3 namespace""""""\n    parse = sys.modules[__name__ + "".moves.urllib_parse""]\n    error = sys.modules[__name__ + "".moves.urllib_error""]\n    request = sys.modules[__name__ + "".moves.urllib_request""]\n    response = sys.modules[__name__ + "".moves.urllib_response""]\n    robotparser = sys.modules[__name__ + "".moves.urllib_robotparser""]\n\n    def __dir__(self):\n        return [\'parse\', \'error\', \'request\', \'response\', \'robotparser\']\n\n\nsys.modules[__name__ + "".moves.urllib""] = Module_six_moves_urllib(__name__ + "".moves.urllib"")\n\n\ndef add_move(move):\n    """"""Add an item to six.moves.""""""\n    setattr(_MovedItems, move.name, move)\n\n\ndef remove_move(name):\n    """"""Remove item from six.moves.""""""\n    try:\n        delattr(_MovedItems, name)\n    except AttributeError:\n        try:\n            del moves.__dict__[name]\n        except KeyError:\n            raise AttributeError(""no such move, %r"" % (name,))\n\n\nif PY3:\n    _meth_func = ""__func__""\n    _meth_self = ""__self__""\n\n    _func_closure = ""__closure__""\n    _func_code = ""__code__""\n    _func_defaults = ""__defaults__""\n    _func_globals = ""__globals__""\nelse:\n    _meth_func = ""im_func""\n    _meth_self = ""im_self""\n\n    _func_closure = ""func_closure""\n    _func_code = ""func_code""\n    _func_defaults = ""func_defaults""\n    _func_globals = ""func_globals""\n\n\ntry:\n    advance_iterator = next\nexcept NameError:\n    def advance_iterator(it):\n        return it.next()\nnext = advance_iterator\n\n\ntry:\n    callable = callable\nexcept NameError:\n    def callable(obj):\n        return any(""__call__"" in klass.__dict__ for klass in type(obj).__mro__)\n\n\nif PY3:\n    def get_unbound_function(unbound):\n        return unbound\n\n    create_bound_method = types.MethodType\n\n    Iterator = object\nelse:\n    def get_unbound_function(unbound):\n        return unbound.im_func\n\n    def create_bound_method(func, obj):\n        return types.MethodType(func, obj, obj.__class__)\n\n    class Iterator(object):\n\n        def next(self):\n            return type(self).__next__(self)\n\n    callable = callable\n_add_doc(get_unbound_function,\n         """"""Get the function out of a possibly unbound function"""""")\n\n\nget_method_function = operator.attrgetter(_meth_func)\nget_method_self = operator.attrgetter(_meth_self)\nget_function_closure = operator.attrgetter(_func_closure)\nget_function_code = operator.attrgetter(_func_code)\nget_function_defaults = operator.attrgetter(_func_defaults)\nget_function_globals = operator.attrgetter(_func_globals)\n\n\nif PY3:\n    def iterkeys(d, **kw):\n        return iter(d.keys(**kw))\n\n    def itervalues(d, **kw):\n        return iter(d.values(**kw))\n\n    def iteritems(d, **kw):\n        return iter(d.items(**kw))\n\n    def iterlists(d, **kw):\n        return iter(d.lists(**kw))\nelse:\n    def iterkeys(d, **kw):\n        return iter(d.iterkeys(**kw))\n\n    def itervalues(d, **kw):\n        return iter(d.itervalues(**kw))\n\n    def iteritems(d, **kw):\n        return iter(d.iteritems(**kw))\n\n    def iterlists(d, **kw):\n        return iter(d.iterlists(**kw))\n\n_add_doc(iterkeys, ""Return an iterator over the keys of a dictionary."")\n_add_doc(itervalues, ""Return an iterator over the values of a dictionary."")\n_add_doc(iteritems,\n         ""Return an iterator over the (key, value) pairs of a dictionary."")\n_add_doc(iterlists,\n         ""Return an iterator over the (key, [values]) pairs of a dictionary."")\n\n\nif PY3:\n    def b(s):\n        return s.encode(""latin-1"")\n    def u(s):\n        return s\n    unichr = chr\n    if sys.version_info[1] <= 1:\n        def int2byte(i):\n            return bytes((i,))\n    else:\n        # This is about 2x faster than the implementation above on 3.2+\n        int2byte = operator.methodcaller(""to_bytes"", 1, ""big"")\n    byte2int = operator.itemgetter(0)\n    indexbytes = operator.getitem\n    iterbytes = iter\n    import io\n    StringIO = io.StringIO\n    BytesIO = io.BytesIO\nelse:\n    def b(s):\n        return s\n    # Workaround for standalone backslash\n    def u(s):\n        return unicode(s.replace(r\'\\\\\', r\'\\\\\\\\\'), ""unicode_escape"")\n    unichr = unichr\n    int2byte = chr\n    def byte2int(bs):\n        return ord(bs[0])\n    def indexbytes(buf, i):\n        return ord(buf[i])\n    def iterbytes(buf):\n        return (ord(byte) for byte in buf)\n    import StringIO\n    StringIO = BytesIO = StringIO.StringIO\n_add_doc(b, """"""Byte literal"""""")\n_add_doc(u, """"""Text literal"""""")\n\n\nif PY3:\n    exec_ = getattr(moves.builtins, ""exec"")\n\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\nelse:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        """"""Execute code in a namespace.""""""\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(""""""exec _code_ in _globs_, _locs_"""""")\n\n\n    exec_(""""""def reraise(tp, value, tb=None):\n    raise tp, value, tb\n"""""")\n\n\nprint_ = getattr(moves.builtins, ""print"", None)\nif print_ is None:\n    def print_(*args, **kwargs):\n        """"""The new-style print function for Python 2.4 and 2.5.""""""\n        fp = kwargs.pop(""file"", sys.stdout)\n        if fp is None:\n            return\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            if (isinstance(fp, file) and\n                isinstance(data, unicode) and\n                fp.encoding is not None):\n                errors = getattr(fp, ""errors"", None)\n                if errors is None:\n                    errors = ""strict""\n                data = data.encode(fp.encoding, errors)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(""sep"", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(""sep must be None or a string"")\n        end = kwargs.pop(""end"", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(""end must be None or a string"")\n        if kwargs:\n            raise TypeError(""invalid keyword arguments to print()"")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(""\\n"")\n            space = unicode("" "")\n        else:\n            newline = ""\\n""\n            space = "" ""\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\n\n_add_doc(reraise, """"""Reraise an exception."""""")\n\nif sys.version_info[0:2] < (3, 4):\n    def wraps(wrapped):\n        def wrapper(f):\n            f = functools.wraps(wrapped)(f)\n            f.__wrapped__ = wrapped\n            return f\n        return wrapper\nelse:\n    wraps = functools.wraps\n\ndef with_metaclass(meta, *bases):\n    """"""Create a base class with a metaclass.""""""\n    # This requires a bit of explanation: the basic idea is to make a\n    # dummy metaclass for one level of class instantiation that replaces\n    # itself with the actual metaclass.  Because of internal type checks\n    # we also need to make sure that we downgrade the custom metaclass\n    # for one level to something closer to type (that\'s why __call__ and\n    # __init__ comes back from type etc.).\n    class metaclass(meta):\n        __call__ = type.__call__\n        __init__ = type.__init__\n        def __new__(cls, name, this_bases, d):\n            if this_bases is None:\n                return type.__new__(cls, name, (), d)\n            return meta(name, bases, d)\n    return metaclass(\'temporary_class\', None, {})\n\n\ndef add_metaclass(metaclass):\n    """"""Class decorator for creating a class with a metaclass.""""""\n    def wrapper(cls):\n        orig_vars = cls.__dict__.copy()\n        orig_vars.pop(\'__dict__\', None)\n        orig_vars.pop(\'__weakref__\', None)\n        slots = orig_vars.get(\'__slots__\')\n        if slots is not None:\n            if isinstance(slots, str):\n                slots = [slots]\n            for slots_var in slots:\n                orig_vars.pop(slots_var)\n        return metaclass(cls.__name__, cls.__bases__, orig_vars)\n    return wrapper\n'"
glumpy/geometry/__init__.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom .normals import normals\nfrom .parametric import surface\nfrom .colorcube import colorcube\n'
glumpy/geometry/arc.py,1,"b'# ----------------------------------------------------------------------------\n#  Anti-Grain Geometry (AGG) - Version 2.5\n#  A high quality rendering engine for C++\n#  Copyright (C) 2002-2006 Maxim Shemanarev\n#  Contact: mcseem@antigrain.com\n#           mcseemagg@yahoo.com\n#           http://antigrain.com\n#  \n#  AGG is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#  \n#  AGG is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#  \n#  You should have received a copy of the GNU General Public License\n#  along with AGG; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, \n#  MA 02110-1301, USA.\n# ----------------------------------------------------------------------------\n#\n# Python translation by Nicolas P. Rougier\n# Copyright (C) 2013 Nicolas P. Rougier. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n# 1. Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n# \n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY NICOLAS P. ROUGIER \'\'AS IS\'\' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL NICOLAS P. ROUGIER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Nicolas P. Rougier.\n#\n# ----------------------------------------------------------------------------\nimport math\nimport numpy as np\n\ndef elliptical_arc(x0, y0, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2):\n    """"""\n    """"""\n\n    radii_ok = True\n    cos_a = math.cos(angle)\n    sin_a = math.sin(angle)\n    if rx < 0.0: rx = -rx\n    if ry < 0.0: ry = -rx\n\n    # Calculate the middle point between \n    # the current and the final points\n    # ------------------------\n    dx2 = (x0 - x2) / 2.0\n    dy2 = (y0 - y2) / 2.0\n\n    # Calculate (x1, y1)\n    # ------------------------\n    x1 =  cos_a * dx2 + sin_a * dy2\n    y1 = -sin_a * dx2 + cos_a * dy2\n\n    # Check that radii are large enough\n    # ------------------------\n    prx,pry = rx * rx, ry * ry\n    px1,py1 = x1 * x1, y1 * y1\n\n    radii_check = px1/prx + py1/pry\n    if radii_check > 1.0:\n        rx = math.sqrt(radii_check) * rx\n        ry = math.sqrt(radii_check) * ry\n        prx = rx * rx\n        pry = ry * ry\n        if radii_check > 10.0:\n            radii_ok = False\n\n    # Calculate (cx1, cy1)\n    # ------------------------\n    if large_arc_flag == sweep_flag:\n        sign = -1\n    else:\n        sign = +1\n    sq   = (prx*pry - prx*py1 - pry*px1) / (prx*py1 + pry*px1)\n    coef = sign*math.sqrt( max(sq,0) )\n    cx1  = coef *  ((rx * y1) / ry)\n    cy1  = coef * -((ry * x1) / rx)\n\n    # Calculate (cx, cy) from (cx1, cy1)\n    # ------------------------\n    sx2 = (x0 + x2) / 2.0\n    sy2 = (y0 + y2) / 2.0\n    cx = sx2 + (cos_a * cx1 - sin_a * cy1)\n    cy = sy2 + (sin_a * cx1 + cos_a * cy1)\n\n    # Calculate the start_angle (angle1) and the sweep_angle (dangle)\n    # ------------------------\n    ux =  (x1 - cx1) / rx\n    uy =  (y1 - cy1) / ry\n    vx = (-x1 - cx1) / rx\n    vy = (-y1 - cy1) / ry\n\n    # Calculate the angle start\n    # ------------------------\n    n = math.sqrt(ux*ux + uy*uy)\n    p = ux;\n    if uy < 0:\n        sign = -1.0\n    else:\n        sign = +1.0\n    v = p / n\n    if v < -1.0:\n        v = -1.0\n    if v >  1.0:\n        v =  1.0\n    start_angle = sign * math.acos(v)\n\n    # Calculate the sweep angle\n    # ------------------------\n    n = math.sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy))\n    p = ux * vx + uy * vy\n    if ux * vy - uy * vx < 0:\n        sign = -1.0\n    else:\n        sign = +1.0\n    v = p / n\n    v = min(max(v,-1.0),+1.0)\n    sweep_angle = sign * math.acos(v)\n    if not sweep_flag and sweep_angle > 0:\n        sweep_angle -= math.pi * 2.0\n    elif sweep_flag and sweep_angle < 0:\n        sweep_angle += math.pi * 2.0\n\n    start_angle = math.fmod(start_angle, 2.0 * math.pi)\n    if sweep_angle >=  2.0 * math.pi:\n        sweep_angle =  2.0 * math.pi\n    if sweep_angle <= -2.0 * math.pi:\n        sweep_angle = -2.0 * math.pi\n\n    V = arc( cx, cy, rx, ry, start_angle, start_angle+sweep_angle, sweep_flag )\n    c = math.cos(angle)\n    s = math.sin(angle)\n    X,Y = V[:,0]-cx, V[:,1]-cy\n    V[:,0] = c*X - s*Y + cx\n    V[:,1] = s*X + c*Y + cy\n    return V\n\n\ndef arc(cx, cy, rx, ry, a1, a2, ccw=False):\n    """"""\n    """"""\n    scale = 1.0\n    ra = (abs(rx) + abs(ry)) / 2.0\n    da = math.acos(ra / (ra + 0.125 / scale)) * 2.0\n    if ccw:\n        while a2 < a1:\n            a2 += math.pi * 2.0\n    else:\n        while a1 < a2:\n            a1 += math.pi * 2.0\n        da = -da\n    a_start = a1\n    a_end   = a2\n\n    vertices =[]\n    angle = a_start\n    while (angle < a_end - da/4) == ccw:\n        x = cx + math.cos(angle) * rx\n        y = cy + math.sin(angle) * ry\n        vertices.append( (x,y) )\n        angle += da\n    x = cx + math.cos(a_end) * rx\n    y = cy + math.sin(a_end) * ry\n    vertices.append( (x,y) )\n    return np.array(vertices).reshape(len(vertices),2)\n\n'"
glumpy/geometry/colorcube.py,16,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import gloo\n\n\ndef colorcube(size=2.0):\n    """""" Generate vertices & indices for a filled and outlined cube """"""\n\n    vtype = [(\'position\', np.float32, 3),\n             (\'texcoord\', np.float32, 2),\n             (\'normal\',   np.float32, 3),\n             (\'color\',    np.float32, 4)]\n    itype = np.uint32\n\n    # Vertices positions\n    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],\n                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]], dtype=float)\n    p *= size/2.0\n\n    # Face Normals\n    n = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0],\n                  [-1, 0, 1], [0, -1, 0], [0, 0, -1]])\n\n    # Vertice colors\n    c = np.array([[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 0, 1],\n                  [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1]])\n\n    # Texture coords\n    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])\n\n    faces_p = [0, 1, 2, 3,\n               0, 3, 4, 5,\n               0, 5, 6, 1,\n               1, 6, 7, 2,\n               7, 4, 3, 2,\n               4, 7, 6, 5]\n    faces_c = [0, 1, 2, 3,\n               0, 3, 4, 5,\n               0, 5, 6, 1,\n               1, 6, 7, 2,\n               7, 4, 3, 2,\n               4, 7, 6, 5]\n    faces_n = [0, 0, 0, 0,\n               1, 1, 1, 1,\n               2, 2, 2, 2,\n               3, 3, 3, 3,\n               4, 4, 4, 4,\n               5, 5, 5, 5]\n    faces_t = [0, 1, 2, 3,\n               0, 1, 2, 3,\n               0, 1, 2, 3,\n               3, 2, 1, 0,\n               0, 1, 2, 3,\n               0, 1, 2, 3]\n\n    vertices = np.zeros(24, vtype)\n    vertices[\'position\'] = p[faces_p]\n    vertices[\'normal\'] = n[faces_n]\n    vertices[\'color\'] = c[faces_c]\n    vertices[\'texcoord\'] = t[faces_t]\n\n    filled = np.resize(\n        np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))\n    filled += np.repeat(4 * np.arange(6, dtype=itype), 6)\n\n    outline = np.resize(\n        np.array([0, 1, 1, 2, 2, 3, 3, 0], dtype=itype), 6 * (2 * 4))\n    outline += np.repeat(4 * np.arange(6, dtype=itype), 8)\n\n    vertices = vertices.view(gloo.VertexBuffer)\n    filled   = filled.view(gloo.IndexBuffer)\n    outline  = outline.view(gloo.IndexBuffer)\n    return vertices, filled, outline\n'"
glumpy/geometry/colored_cube.py,16,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import gloo\n\n\ndef colored_cube(size=2.0):\n    """""" Generate vertices & indices for a filled and outlined cube """"""\n\n    vtype = [(\'position\', np.float32, 3),\n             (\'texcoord\', np.float32, 2),\n             (\'normal\',   np.float32, 3),\n             (\'color\',    np.float32, 4)]\n    itype = np.uint32\n\n    # Vertices positions\n    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],\n                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]])\n    p *= size/2.0\n\n    # Face Normals\n    n = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0],\n                  [-1, 0, 1], [0, -1, 0], [0, 0, -1]])\n\n    # Vertice colors\n    c = np.array([[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 0, 1],\n                  [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1]])\n\n    # Texture coords\n    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])\n\n    faces_p = [0, 1, 2, 3,\n               0, 3, 4, 5,\n               0, 5, 6, 1,\n               1, 6, 7, 2,\n               7, 4, 3, 2,\n               4, 7, 6, 5]\n    faces_c = [0, 1, 2, 3,\n               0, 3, 4, 5,\n               0, 5, 6, 1,\n               1, 6, 7, 2,\n               7, 4, 3, 2,\n               4, 7, 6, 5]\n    faces_n = [0, 0, 0, 0,\n               1, 1, 1, 1,\n               2, 2, 2, 2,\n               3, 3, 3, 3,\n               4, 4, 4, 4,\n               5, 5, 5, 5]\n    faces_t = [0, 1, 2, 3,\n               0, 1, 2, 3,\n               0, 1, 2, 3,\n               3, 2, 1, 0,\n               0, 1, 2, 3,\n               0, 1, 2, 3]\n\n    vertices = np.zeros(24, vtype)\n    vertices[\'position\'] = p[faces_p]\n    vertices[\'normal\'] = n[faces_n]\n    vertices[\'color\'] = c[faces_c]\n    vertices[\'texcoord\'] = t[faces_t]\n\n    filled = np.resize(\n        np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))\n    filled += np.repeat(4 * np.arange(6, dtype=itype), 6)\n\n    outline = np.resize(\n        np.array([0, 1, 1, 2, 2, 3, 3, 0], dtype=itype), 6 * (2 * 4))\n    outline += np.repeat(4 * np.arange(6, dtype=itype), 8)\n\n    vertices = vertices.view(gloo.VertexBuffer)\n    filled   = filled.view(gloo.IndexBuffer)\n    outline  = outline.view(gloo.IndexBuffer)\n    return vertices, filled, outline\n'"
glumpy/geometry/curves.py,2,"b""# ----------------------------------------------------------------------------\n#  Anti-Grain Geometry (AGG) - Version 2.5\n#  A high quality rendering engine for C++\n#  Copyright (C) 2002-2006 Maxim Shemanarev\n#  Contact: mcseem@antigrain.com\n#           mcseemagg@yahoo.com\n#           http://antigrain.com\n#  \n#  AGG is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#  \n#  AGG is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#  \n#  You should have received a copy of the GNU General Public License\n#  along with AGG; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, \n#  MA 02110-1301, USA.\n# ----------------------------------------------------------------------------\n#\n# Python translation by Nicolas P. Rougier\n# Copyright (C) 2013 Nicolas P. Rougier. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n# 1. Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n# \n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY NICOLAS P. ROUGIER ''AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL NICOLAS P. ROUGIER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Nicolas P. Rougier.\n#\n# ----------------------------------------------------------------------------\nimport math\nimport numpy as np\n\ncurve_distance_epsilon        = 1e-30\ncurve_collinearity_epsilon    = 1e-30\ncurve_angle_tolerance_epsilon = 0.01\ncurve_recursion_limit         = 32\nm_cusp_limit                  = 0.0\nm_angle_tolerance             = 10*math.pi/180.0\nm_approximation_scale         = 1.0\nm_distance_tolerance_square   = (0.5 / m_approximation_scale)**2\n\n\n# -----------------------------------------------------------------------------\ndef calc_sq_distance( x1,y1, x2,y2 ):\n    dx = x2-x1\n    dy = y2-y1\n    return dx * dx + dy * dy\n\n\n# -----------------------------------------------------------------------------\ndef curve3_recursive_bezier( points, x1, y1, x2, y2, x3, y3, level = 0 ):\n    if level > curve_recursion_limit:\n        return\n\n    # Calculate all the mid-points of the line segments\n    # -------------------------------------------------\n    x12  = (x1 + x2) / 2.\n    y12  = (y1 + y2) / 2.\n    x23  = (x2 + x3) / 2.\n    y23  = (y2 + y3) / 2.\n    x123 = (x12 + x23) / 2.\n    y123 = (y12 + y23) / 2.\n\n    dx = x3 - x1\n    dy = y3 - y1\n    d = math.fabs((x2-x3)*dy - (y2-y3)*dx)\n\n    if d > curve_collinearity_epsilon:\n        # Regular case\n        # ------------\n        if d*d <= m_distance_tolerance_square * (dx*dx + dy*dy):\n            # If the curvature doesn't exceed the distance_tolerance value\n            # we tend to finish subdivisions.\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append( (x123,y123) )\n                return\n\n            # Angle & Cusp Condition\n            da = math.fabs(math.atan2(y3 - y2, x3 - x2) - math.atan2(y2 - y1, x2 - x1))\n            if da >= math.pi:\n                da = 2*math.pi - da\n\n            if da < m_angle_tolerance:\n                # Finally we can stop the recursion\n                points.append( (x123,y123) )\n                return\n    else:\n        # Collinear case\n        # --------------\n        da = dx*dx + dy*dy\n        if da == 0:\n            d = calc_sq_distance(x1, y1, x2, y2)\n        else:\n            d = ((x2 - x1)*dx + (y2 - y1)*dy) / da\n            if d > 0 and d < 1:\n                # Simple collinear case, 1---2---3, we can leave just two endpoints\n                return\n            if(d <= 0):\n                d = calc_sq_distance(x2, y2, x1, y1)\n            elif d >= 1:\n                d = calc_sq_distance(x2, y2, x3, y3)\n            else:\n               d = calc_sq_distance(x2, y2, x1 + d*dx, y1 + d*dy)\n\n        if d < m_distance_tolerance_square:\n            points.append( (x2,y2) )\n            return\n\n    # Continue subdivision\n    # --------------------\n    curve3_recursive_bezier( points, x1, y1, x12, y12, x123, y123, level + 1 )\n    curve3_recursive_bezier( points, x123, y123, x23, y23, x3, y3, level + 1 )\n\n\n# -----------------------------------------------------------------------------\ndef curve4_recursive_bezier( points, x1, y1, x2, y2, x3, y3, x4, y4, level=0):\n    if level > curve_recursion_limit: \n        return\n\n    # Calculate all the mid-points of the line segments\n    # -------------------------------------------------\n    x12   = (x1 + x2) / 2.\n    y12   = (y1 + y2) / 2.\n    x23   = (x2 + x3) / 2.\n    y23   = (y2 + y3) / 2.\n    x34   = (x3 + x4) / 2.\n    y34   = (y3 + y4) / 2.\n    x123  = (x12 + x23) / 2.\n    y123  = (y12 + y23) / 2.\n    x234  = (x23 + x34) / 2.\n    y234  = (y23 + y34) / 2.\n    x1234 = (x123 + x234) / 2.\n    y1234 = (y123 + y234) / 2.\n\n\n    # Try to approximate the full cubic curve by a single straight line\n    # -----------------------------------------------------------------\n    dx = x4 - x1\n    dy = y4 - y1\n    d2 = math.fabs(((x2 - x4) * dy - (y2 - y4) * dx))\n    d3 = math.fabs(((x3 - x4) * dy - (y3 - y4) * dx))\n\n    s =  int((d2 > curve_collinearity_epsilon) << 1) + int(d3 > curve_collinearity_epsilon)\n\n    if s == 0:\n        # All collinear OR p1==p4\n        # ----------------------\n        k = dx*dx + dy*dy\n        if k == 0:\n            d2 = calc_sq_distance(x1, y1, x2, y2)\n            d3 = calc_sq_distance(x4, y4, x3, y3)\n\n        else:\n            k   = 1. / k\n            da1 = x2 - x1\n            da2 = y2 - y1\n            d2  = k * (da1*dx + da2*dy)\n            da1 = x3 - x1\n            da2 = y3 - y1\n            d3  = k * (da1*dx + da2*dy)\n            if d2 > 0 and d2 < 1 and d3 > 0 and d3 < 1:\n                # Simple collinear case, 1---2---3---4\n                # We can leave just two endpoints\n                return\n             \n            if d2 <= 0:\n                d2 = calc_sq_distance(x2, y2, x1, y1)\n            elif d2 >= 1:\n                d2 = calc_sq_distance(x2, y2, x4, y4)\n            else:\n                d2 = calc_sq_distance(x2, y2, x1 + d2*dx, y1 + d2*dy)\n\n            if d3 <= 0:\n                d3 = calc_sq_distance(x3, y3, x1, y1)\n            elif d3 >= 1:\n                d3 = calc_sq_distance(x3, y3, x4, y4)\n            else:\n                d3 = calc_sq_distance(x3, y3, x1 + d3*dx, y1 + d3*dy)\n\n        if d2 > d3:\n            if d2 < m_distance_tolerance_square:\n                points.append( (x2, y2) )\n                return\n        else:\n            if d3 < m_distance_tolerance_square:\n                points.append( (x3, y3) )\n                return\n\n    elif s == 1:\n        # p1,p2,p4 are collinear, p3 is significant\n        # -----------------------------------------\n        if d3 * d3 <= m_distance_tolerance_square * (dx*dx + dy*dy):\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x23, y23) )\n                return\n            \n            # Angle Condition\n            # ---------------\n            da1 = math.fabs(math.atan2(y4 - y3, x4 - x3) - math.atan2(y3 - y2, x3 - x2))\n            if da1 >= math.pi:\n                da1 = 2*math.pi - da1\n            \n            if da1 < m_angle_tolerance:\n                points.extend( [(x2, y2),(x3, y3)] )\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append( (x3, y3) )\n                    return\n\n    elif s == 2:\n        # p1,p3,p4 are collinear, p2 is significant\n        # -----------------------------------------\n        if d2 * d2 <= m_distance_tolerance_square * (dx*dx + dy*dy):\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append( (x23, y23) )\n                return\n            \n            # Angle Condition\n            # ---------------\n            da1 = math.fabs(math.atan2(y3 - y2, x3 - x2) - math.atan2(y2 - y1, x2 - x1))\n            if da1 >= math.pi:\n                da1 = 2*math.pi - da1\n            \n            if da1 < m_angle_tolerance:\n                points.extend( [(x2, y2),(x3, y3)] )\n                return\n            \n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append( (x2, y2) )\n                    return\n        \n    elif s == 3:\n        # Regular case\n        # ------------\n        if (d2 + d3)*(d2 + d3) <= m_distance_tolerance_square * (dx*dx + dy*dy):\n            # If the curvature doesn't exceed the distance_tolerance value\n            # we tend to finish subdivisions.\n\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append( (x23, y23) )\n                return\n            \n            # Angle & Cusp Condition\n            # ----------------------\n            k   = math.atan2(y3 - y2, x3 - x2)\n            da1 = math.fabs(k - math.atan2(y2 - y1, x2 - x1))\n            da2 = math.fabs(math.atan2(y4 - y3, x4 - x3) - k)\n            if da1 >= math.pi:\n                da1 = 2*math.pi - da1\n            if da2 >= math.pi:\n                da2 = 2*math.pi - da2\n\n            if da1 + da2 < m_angle_tolerance:\n                # Finally we can stop the recursion\n                # ---------------------------------\n                points.append( (x23, y23) )\n                return\n            \n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append( (x2, y2) )\n                    return\n                \n                if da2 > m_cusp_limit:\n                    points.append( (x3, y3) )\n                    return\n    \n    # Continue subdivision\n    # --------------------\n    curve4_recursive_bezier( points, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1 )\n    curve4_recursive_bezier( points, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1 )\n\n\n# -----------------------------------------------------------------------------\ndef curve3_bezier( p1, p2, p3 ):\n    x1,y1 = p1\n    x2,y2 = p2\n    x3,y3 = p3\n    points = []\n    curve3_recursive_bezier( points, x1,y1, x2,y2, x3,y3 )\n\n    dx,dy = points[0][0]-x1, points[0][1]-y1\n    if (dx*dx+dy*dy) > 1e-10: points.insert(0, (x1,y1) )\n\n    dx,dy = points[-1][0]-x3, points[-1][1]-y3\n    if (dx*dx+dy*dy) > 1e-10: points.append( (x3,y3) )\n\n    return np.array( points ).reshape(len(points),2)\n\n\n# -----------------------------------------------------------------------------\ndef curve4_bezier( p1, p2, p3, p4 ):\n    x1,y1 = p1\n    x2,y2 = p2\n    x3,y3 = p3\n    x4,y4 = p4\n    points = []\n    curve4_recursive_bezier( points, x1,y1, x2,y2, x3,y3, x4,y4 )\n\n    dx,dy = points[0][0]-x1, points[0][1]-y1\n    if (dx*dx+dy*dy) > 1e-10: points.insert(0, (x1,y1) )\n    dx,dy = points[-1][0]-x4, points[-1][1]-y4\n    if (dx*dx+dy*dy) > 1e-10: points.append( (x4,y4) )\n\n    return np.array( points ).reshape(len(points),2)\n\n\n"""
glumpy/geometry/normals.py,15,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\n\n\ndef compact(vertices, indices, tolerance=1e-3):\n    """""" Compact vertices and indices within given tolerance """"""\n\n    # Transform vertices into a structured array for np.unique to work\n    n = len(vertices)\n    V = np.zeros(n, dtype=[(""pos"", np.float32, 3)])\n    V[""pos""][:,0] = vertices[:,0]\n    V[""pos""][:,1] = vertices[:,1]\n    V[""pos""][:,2] = vertices[:,2]\n\n    epsilon = 1e-3\n    decimals = int(np.log(epsilon)/np.log(1/10.))\n\n    # Round all vertices within given decimals\n    V_ = np.zeros_like(V)\n    X = V[""pos""][:,0].round(decimals=decimals)\n    X[np.where(abs(X) < epsilon)] = 0\n\n    V_[""pos""][:,0] = X\n    Y = V[""pos""][:,1].round(decimals=decimals)\n    Y[np.where(abs(Y) < epsilon)] = 0\n    V_[""pos""][:,1] = Y\n\n    Z = V[""pos""][:,2].round(decimals=decimals)\n    Z[np.where(abs(Z) < epsilon)] = 0\n    V_[""pos""][:,2] = Z\n\n    # Find the unique vertices AND the mapping\n    U, RI = np.unique(V_, return_inverse=True)\n\n    # Translate indices from original vertices into the reduced set (U)\n    indices = indices.ravel()\n    I_ = indices.copy().ravel()\n    for i in range(len(indices)):\n        I_[i] = RI[indices[i]]\n    I_ = I_.reshape(len(indices)//3,3)\n\n    # Return reduced vertices set, transalted indices and mapping that allows\n    # to go from U to V\n    return U.view(np.float32).reshape(len(U),3), I_, RI\n\n\n\ndef normals(vertices, indices):\n    """"""\n    Compute normals over a triangulated surface\n\n    Parameters\n    ----------\n\n    vertices : ndarray (n,3)\n        triangles vertices\n\n    indices : ndarray (p,3)\n        triangles indices\n    """"""\n\n    # Compact similar vertices\n    vertices, indices, mapping = compact(vertices, indices)\n\n\n    T = vertices[indices]\n    N = np.cross(T[:,1 ]-T[:,0], T[:,2]-T[:,0])\n    L = np.sqrt(np.sum(N*N,axis=1))\n    L[L==0] = 1.0  # prevent divide-by-zero\n    N /= L[:, np.newaxis]\n    normals = np.zeros_like(vertices)\n    normals[indices[:,0] ] += N\n    normals[indices[:,1] ] += N\n    normals[indices[:,2] ] += N\n    L = np.sqrt(np.sum(normals*normals, axis=1))\n    L[L== 0] = 1.0\n    normals /= L[:,np.newaxis]\n\n    return normals[mapping]\n'"
glumpy/geometry/parametric.py,12,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom . import normals\nfrom glumpy import gloo\n\n\n\ndef surface(func, umin=0, umax=2*np.pi, ucount=64, urepeat=1.0,\n                  vmin=0, vmax=2*np.pi, vcount=64, vrepeat=1.0):\n    """"""\n    Computes the parameterization of a parametric surface\n\n    func: function(u,v)\n        Parametric function used to build the surface\n    """"""\n\n    vtype = [(\'position\', np.float32, 3),\n             (\'texcoord\', np.float32, 2),\n             (\'normal\',   np.float32, 3)]\n    itype = np.uint32\n\n    # umin, umax, ucount = 0, 2*np.pi, 64\n    # vmin, vmax, vcount = 0, 2*np.pi, 64\n\n    vcount += 1\n    ucount += 1\n    n = vcount*ucount\n\n    Un = np.repeat(np.linspace(0, 1, ucount, endpoint=True), vcount)\n    Vn = np.tile  (np.linspace(0, 1, vcount, endpoint=True), ucount)\n    U = umin+Un*(umax-umin)\n    V = vmin+Vn*(vmax-vmin)\n\n    vertices = np.zeros(n, dtype=vtype)\n    for i,(u,v) in enumerate(zip(U,V)):\n        vertices[""position""][i] = func(u,v)\n\n    vertices[""texcoord""][:,0] = Un*urepeat\n    vertices[""texcoord""][:,1] = Vn*vrepeat\n\n    indices = []\n    for i in range(ucount-1):\n        for j in range(vcount-1):\n            indices.append(i*(vcount) + j        )\n            indices.append(i*(vcount) + j+1      )\n            indices.append(i*(vcount) + j+vcount+1)\n            indices.append(i*(vcount) + j+vcount  )\n            indices.append(i*(vcount) + j+vcount+1)\n            indices.append(i*(vcount) + j        )\n    indices = np.array(indices, dtype=itype)\n    vertices[""normal""] = normals(vertices[""position""],\n                                 indices.reshape(len(indices)//3,3))\n\n    return vertices.view(gloo.VertexBuffer), indices.view(gloo.IndexBuffer)\n'"
glumpy/geometry/path.py,1,"b""# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\nimport string\nfrom . import arc, curves\n\nclass Path(object):\n\n    # ---------------------------------\n    def __init__(self):\n        self.vertices = []\n        self.current = None\n        self.last_control3 = None\n        self.last_control4 = None\n\n    # ---------------------------------\n    def svg_parse(self, cmd, points):\n        relative = cmd in string.lowercase\n        cmd = string.capitalize(cmd)\n        if cmd == 'M':   self.moveto(points,relative)\n        elif cmd == 'Z': self.close()\n        elif cmd == 'L': self.lineto(points,relative)\n        elif cmd == 'H': self.horizontal_lineto(points,relative)\n        elif cmd == 'V': self.vertical_lineto(points,relative)\n        elif cmd == 'C': self.curveto(points,relative)\n        elif cmd == 'Q': self.quadratic_curveto(points,relative)\n        elif cmd == 'A': self.elliptical_arc(points, relative)\n\n    # ---------------------------------\n    def moveto(self, points, relative = False):\n        ox,oy = 0,0\n        if len(self.vertices) and len(self.vertices[-1]) <= 1:\n            del self.vertices[-1]\n        self.vertices.append([])\n        vertices = self.vertices[-1]\n        x,y = points[:2]\n        vertices.append( [x+ox,y+oy] )\n        self.current = x+ox,y+oy\n        if len(points[2:]):\n            self.lineto(points[2:], relative)\n        self.current = vertices[-1]\n        self.last_control3 = None\n        self.last_control4 = None\n\n    # ---------------------------------\n    def lineto(self, points, relative = False):\n        if relative:\n            ox,oy = self.current\n        else:\n            ox,oy = 0,0\n        vertices = self.vertices[-1]\n        for i in range(0,len(points),2):\n            x,y = points[i],points[i+1]\n            vertices.append( [x+ox,y+oy] )\n        self.current = vertices[-1]\n        self.last_control3 = None\n        self.last_control4 = None\n\n    # ---------------------------------\n    def horizontal_lineto(self, points, relative=False):\n        if relative:\n            ox,oy = self.current\n        else:\n            ox,oy = 0,self.current[1]\n        vertices = self.vertices[-1]\n        x = points[-1]\n        vertices.append( [x+ox,oy] )\n        self.current = vertices[-1]\n        self.last_control3 = None\n        self.last_control4 = None\n\n    # ---------------------------------\n    def vertical_lineto(self, points, relative=False):\n        if relative:\n            ox,oy = self.current\n        else:\n            ox,oy = self.current[0],0\n        vertices = self.vertices[-1]\n        y = points[-1]\n        vertices.append( [ox,y+oy] )\n        self.current = vertices[-1]\n        self.last_control3 = None\n        self.last_control4 = None\n\n    # ---------------------------------\n    def close(self):\n        vertices = self.vertices[-1]\n        vertices.append( vertices[0] )\n        self.last_control3 = None\n        self.last_control4 = None\n\n    # ---------------------------------\n    def curveto(self, points, relative=False):\n        if relative:\n            ox,oy = self.current\n        else:\n            ox,oy = 0,0\n        vertices = self.vertices[-1]\n\n        x0, y0 = self.current\n        for i in range(0,len(points),6):\n            x1,y1 = points[i+0], points[i+1]\n            x2,y2 = points[i+2], points[i+3]\n            self.last_control4 = x2,y2\n            x3,y3 = points[i+4], points[i+5]\n            V = curves.curve4_bezier((x0+ox,y0+oy),\n                                     (x1+ox,y1+oy),\n                                     (x2+ox,y2+oy),\n                                     (x3+ox,y3+oy))\n            vertices.extend(V[1:].tolist())\n            x0,y0 = vertices[-1]\n        self.current = vertices[-1]\n\n    # ---------------------------------\n    def quadratic_curveto(self, points, relative=False):\n        if relative:\n            ox,oy = self.current\n        else:\n            ox,oy = 0,0\n        vertices = self.vertices[-1]\n\n        x0, y0 = self.current\n        for i in len(0,range(points),4):\n            x1,y1 = points[i+0], points[i+1]\n            self.last_control3 = x1,y1\n            x2,y2 = points[i+2], points[i+3]\n            V = curves.curve3_bezier((x0+dx,y0+dy),\n                                     (x1+dx,y1+dy),\n                                     (x2+dx,y2+dy))\n            vertices.extend(V[1:].tolist())\n            x0,y0 = vertices[-1]\n        self.current = vertices[-1]\n\n\n    # ---------------------------------\n    def smooth_curveto(self, points, relative=False):\n        raise NotImplemented\n\n    # ---------------------------------\n    def smooth_quadratic_curveto(self, points, relative=False):\n        raise NotImplemented\n\n    # ---------------------------------\n    def elliptical_arc(self, points, relative=False):\n        if relative:\n            ox,oy = self.current\n        else:\n            ox,oy = 0,0\n        vertices = self.vertices[-1]\n\n        x0, y0 = self.current\n        for i in range(0,len(points),7):\n            rx    = points[i+0]\n            ry    = points[i+1]\n            angle = np.pi*points[i+2]/180.\n            large = points[i+3]\n            sweep = points[i+4]\n            x2    = points[i+5]\n            y2    = points[i+6]\n            V = arc.elliptical_arc(x0, y0, rx, ry, angle, large, sweep, x2+ox, y2+oy)\n            vertices.extend(V[1:].tolist())\n            x0,y0 = vertices[-1]\n        self.current = vertices[-1]\n        self.last_control3 = None\n        self.last_control4 = None\n"""
glumpy/geometry/primitives.py,68,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import gloo, data\n\n\ndef plane(size=1.0, n=2):\n    """"""\n    Plane centered at origin, lying on the XY-plane\n\n    Parameters\n    ----------\n    size : float\n       plane length size\n\n    n : int\n        Tesselation level\n    """"""\n\n    n = max(2,n)\n\n    T = np.linspace(0,1,n,endpoint=True)\n    X,Y = np.meshgrid(T-0.5,T-0.5)\n    X = X.ravel()*size\n    Y = Y.ravel()*size\n    U,V = np.meshgrid(T,T)\n    U = U.ravel()\n    V = V.ravel()\n\n    I = (np.arange((n-1)*(n),dtype=np.uint32).reshape(n-1,n))[:,:-1].T\n    I = np.repeat(I.ravel(),6).reshape(n-1,n-1,6)\n    I[:,:] += np.array([0,1,n+1, 0,n+1,n], dtype=np.uint32)\n\n    vtype = [(\'position\', np.float32, 3),\n             (\'texcoord\', np.float32, 2),\n             (\'normal\',   np.float32, 3)]\n    itype = np.uint32\n\n    vertices = np.zeros((6,n*n), dtype=vtype)\n    vertices[""texcoord""][...,0] = U\n    vertices[""texcoord""][...,1] = V\n    vertices[""position""][0,:,0] = X\n    vertices[""position""][0,:,1] = Y\n    vertices[""position""][0,:,2] = 0\n    vertices[""normal""][0] = 0,0,1\n\n    vertices = vertices.ravel()\n    indices = np.array(I, dtype=itype).ravel()\n    return vertices.view(gloo.VertexBuffer), indices.view(gloo.IndexBuffer)\n\n\n\ndef cube(size=1.0, n=2):\n    """"""\n    Cube centered at origin\n\n    Parameters\n    ----------\n    size : float\n       cube length size\n\n    n : int\n        Tesselation level\n    """"""\n\n    n = max(2,n)\n\n    T = np.linspace(0,1,n,endpoint=True)\n    X,Y = np.meshgrid(T-0.5,T-0.5)\n    X = X.ravel()*size\n    Y = Y.ravel()*size\n    Z = np.ones_like(X)*0.5*size\n    U,V = np.meshgrid(T,T)\n    U = U.ravel()\n    V = V.ravel()\n\n    I = (np.arange((n-1)*(n),dtype=np.uint32).reshape(n-1,n))[:,:-1].T\n    I = np.repeat(I.ravel(),6).reshape(n-1,n-1,6)\n    I[:,:] += np.array([0,1,n+1, 0,n+1,n], dtype=np.uint32)\n\n    vtype = [(\'position\', np.float32, 3),\n             (\'texcoord\', np.float32, 2),\n             (\'normal\',   np.float32, 3)]\n    itype = np.uint32\n    vertices = np.zeros((6,n*n), dtype=vtype)\n\n    vertices[""texcoord""][...,0] = U\n    vertices[""texcoord""][...,1] = V\n\n    # Top\n    vertices[""position""][0,:,0] = X\n    vertices[""position""][0,:,1] = Y\n    vertices[""position""][0,:,2] = Z\n    vertices[""normal""][0] = 0,0,1\n\n    # Bottom\n    vertices[""position""][1,:,0] = X\n    vertices[""position""][1,:,1] = Y\n    vertices[""position""][1,:,2] = -Z\n    vertices[""normal""][1] = 0,0,-1\n\n    # Front\n    vertices[""position""][2,:,0] = Z\n    vertices[""position""][2,:,1] = X\n    vertices[""position""][2,:,2] = Y\n    vertices[""normal""][2] = 1,0,0\n\n    # Back\n    vertices[""position""][3,:,0] = -Z\n    vertices[""position""][3,:,1] = X\n    vertices[""position""][3,:,2] = Y\n    vertices[""normal""][3] = -1,0,0\n\n    # Left\n    vertices[""position""][4,:,0] = X\n    vertices[""position""][4,:,1] = Z\n    vertices[""position""][4,:,2] = Y\n    vertices[""normal""][4] = 0,1,0\n\n    # Right\n    vertices[""position""][5,:,0] = X\n    vertices[""position""][5,:,1] = -Z\n    vertices[""position""][5,:,2] = Y\n    vertices[""normal""][5] = 0,-1,0\n\n    I = I.ravel()\n    indices = np.zeros((6,len(I)), dtype=itype)\n    indices[:] = I\n    indices += (np.arange(6,dtype=np.uint32)*n*n).reshape(6,1)\n\n    vertices = vertices.ravel()\n    indices = indices.ravel()\n    return vertices.view(gloo.VertexBuffer), indices.view(gloo.IndexBuffer)\n\n\n\ndef tube(top_radius=1.0, base_radius=1.0, height=2.0, slices=32, caps=(True,True)):\n    """"""\n    Z-axis aligned tube centered at origin.\n\n    Parameters\n    ----------\n    top_radius : float\n        The radius at the top of the cylinder\n    base_radius : float\n        The radius at the base of the cylinder\n    height : float\n        The height of the cylinder\n    slices : float\n        The number of subdivisions around the Z axis.\n    caps : bool, bool\n        Whether to add caps at top and bottom\n    """"""\n\n    vtype = [(\'position\', np.float32, 3),\n             (\'texcoord\', np.float32, 2),\n             (\'normal\',   np.float32, 3)]\n    itype = np.uint32\n\n    if top_radius <= 0.0:\n        caps[0] = False\n    if base_radius <= 0.0:\n        caps[1] = False\n\n    theta  = np.linspace(0,2*np.pi, slices+1, endpoint=True)\n    cos_theta = np.cos(theta)\n    sin_theta = np.sin(theta)\n\n    n_side = slices+1\n    n_cap  = slices+1\n    n = 2*n_side + caps[0]*n_cap + caps[1]*n_cap\n\n    i0 = 0           # Start index of base side\n    i1 = i0 + n_side # Start index of top side\n\n    vertices = np.zeros(n, dtype=vtype)\n    sides    = vertices[:2*n_side]\n    topside  = sides[:+n_side]\n    baseside = sides[-n_side:]\n    if caps[0] and caps[1]:\n        C = vertices[-2*n_cap:]\n        topcap   = C[:+n_cap]\n        basecap  = C[-n_cap:]\n        i2 = i1 + n_side # Start index of top cap\n        i3 = i2 + n_cap  # Start index of base cap\n    elif caps[0]:\n        topcap = vertices[-n_cap:]\n        basecap = None\n        i2 = i1 + n_side # Start index of top cap\n        i3 = None\n    elif caps[1]:\n        topcap = None\n        basecap = vertices[-n_cap:]\n        i2 = None\n        i3 = i1 + n_side # Start index of top cap\n\n    r = (top_radius-base_radius)\n    hypothenus = np.sqrt(r*r + height*height)\n\n    topside[""position""][:,0] = cos_theta * top_radius\n    topside[""position""][:,1] = sin_theta * top_radius\n    topside[""position""][:,2] = +height/2.0\n    topside[""texcoord""][:,0] = np.linspace(0,1,slices+1,endpoint=True)\n    topside[""texcoord""][:,1] = 0\n    topside[""normal""][:,0] = cos_theta * height/hypothenus\n    topside[""normal""][:,1] = sin_theta * height/hypothenus\n    topside[""normal""][:,2] = -(top_radius-base_radius)/hypothenus\n\n\n    baseside[""position""][:,0] = cos_theta * base_radius\n    baseside[""position""][:,1] = sin_theta * base_radius\n    baseside[""position""][:,2] = -height/2.0\n    baseside[""texcoord""][:,0] = np.linspace(0,1,slices+1,endpoint=True)\n    baseside[""texcoord""][:,1] = 1\n    baseside[""normal""][:,0] = cos_theta * height/hypothenus\n    baseside[""normal""][:,1] = sin_theta * height/hypothenus\n    baseside[""normal""][:,2] = -(top_radius-base_radius)/hypothenus\n\n    if caps[0]:\n        topcap[""position""][1:] = topside[""position""][:-1]\n        topcap[""position""][0]  = 0, 0, +height/2.0\n        topcap[""texcoord""][1:,0] = (1+cos_theta[:-1])/2\n        topcap[""texcoord""][1:,1] = (1+sin_theta[:-1])/2\n        topcap[""texcoord""][0]  = 0.5, 0.5\n        topcap[""normal""]  = 0,0,+1\n    if caps[1]:\n        basecap[""position""][1:] = baseside[""position""][:-1]\n        basecap[""position""][0]  = 0, 0, -height/2.0\n        basecap[""texcoord""][1:,0] = (1+cos_theta[:-1])/2\n        basecap[""texcoord""][1:,1] = (1+sin_theta[:-1])/2\n        basecap[""texcoord""][0]  = 0.5, 0.5\n        basecap[""normal""]  = 0,0,-1\n\n    indices = []\n    # side triangles\n    for i in range(slices):\n        indices.extend([i0+i, i0+i+1, i1+i  ])\n        indices.extend([i1+i, i1+i+1, i0+i+1])\n\n    # caps triangles\n    for i in range(slices+1):\n        if caps[0]:\n            indices.extend([i2,i2+1+i%slices,i2+1+(i+1)%slices])\n        if caps[1]:\n            indices.extend([i3,i3+1+i%slices,i3+1+(i+1)%slices])\n\n    indices = np.array(indices, dtype=itype)\n    return vertices.view(gloo.VertexBuffer), indices.view(gloo.IndexBuffer)\n\n\n\ndef cylinder(radius=0.5, height=2.0, slices=32, caps=(True,True)):\n    """"""\n    Z-axis aligned cylinder centered a origin.\n\n    Parameters\n    ----------\n    radius : float\n        The radius of the cylinder\n    height : float\n        The height of the cylinder\n    slices : float\n        The number of subdivisions around the Z axis.\n    caps : bool, bool\n        Whether to add caps at top and bottom\n    """"""\n\n    return tube(radius, radius, height, slices, caps)\n\n\ndef cone(radius=1.0, height=1.0, slices=32, cap=True):\n    """"""\n    Z-axis aligned cone.\n\n    The base of the cone is placed at z=0, and the top at z=+height. The\n    cone is subdivided around the Z axis into slices.\n\n    Parameters\n    ----------\n    radius : float\n        The radius of the base of the cone.\n    height : float\n        The height of the cone.\n    slices : float\n        The number of subdivisions around the Z axis.\n    cap : bool\n        Whether to add cap at base\n    """"""\n    vertices, indices = tube(0, radius, height, slices, caps=[False,cap])\n    vertices[""position""] += 0,0, height/2.0\n    return vertices, indices\n\n\ndef pyramid(radius=1.0, height=1.0, cap=True):\n    """"""\n    Z-axis aligned pyramid.\n\n    The base of the cone is placed at z=0, and the top at z=+height. The\n    cone is subdivided around the Z axis into slices.\n\n    Parameters\n    ----------\n    radius : float\n        The radius of the base of the cone.\n    height : float\n        The height of the cone.\n    slices : float\n        The number of subdivisions around the Z axis.\n    cap : bool\n        Whether to add cap at base\n    """"""\n    vertices, indices = tube(0, radius, height, 4, caps=[False,cap])\n    vertices[""position""] += 0,0, height/2.0\n    return vertices, indices\n\n\ndef torus(inner_radius=0.25, outer_radius=1.0, sides=32, rings=48):\n    """"""\n    Z-axis aligned torus (doughnut) centered at origin.\n\n    Parameters\n    ----------\n    inner_radius : float\n        Inner radius of the torus.\n    outer_radius : float\n        Outer radius of the torus.\n    sides : int\n        Number of sides for each radial section.\n    rings : int\n        Number of radial divisions for the torus.\n    """"""\n\n    vtype = [(\'position\', np.float32, 3),\n             (\'texcoord\', np.float32, 2),\n             (\'normal\',   np.float32, 3)]\n    itype = np.uint32\n    sides += 1\n    rings += 1\n    n = rings * sides\n\n    vertices = np.zeros(n, dtype=vtype)\n    theta1 = np.tile  (np.linspace(0, 2 * np.pi, sides, endpoint=True), rings)\n    theta2 = np.repeat(np.linspace(0, 2 * np.pi, rings, endpoint=True), sides)\n    C = inner_radius*np.cos(theta1) - outer_radius\n\n    vertices[""position""][:,0] = C*np.cos(theta2)\n    vertices[""position""][:,1] = C*np.sin(theta2)\n    vertices[""position""][:,2] = inner_radius*np.sin(theta1)\n    vertices[""normal""][:,0] = (C+outer_radius)*np.cos(theta2)\n    vertices[""normal""][:,1] = (C+outer_radius)*np.sin(theta2)\n    vertices[""normal""][:,2] = vertices[""position""][:,2]\n    vertices[""texcoord""][:,0] = np.tile(np.linspace(0,1,sides,endpoint=True),rings)\n    vertices[""texcoord""][:,1] = np.repeat(np.linspace(0,1,rings,endpoint=True),sides)\n\n    indices = []\n    for i in range(rings-1):\n        for j in range(sides-1):\n            indices.append(i*(sides) + j        )\n            indices.append(i*(sides) + j+1      )\n            indices.append(i*(sides) + j+sides+1)\n            indices.append(i*(sides) + j+sides  )\n            indices.append(i*(sides) + j+sides+1)\n            indices.append(i*(sides) + j        )\n\n    indices = np.array(indices, dtype=itype)\n    return vertices.view(gloo.VertexBuffer), indices.view(gloo.IndexBuffer)\n\n\ndef sphere(radius=1.0, slices=32, stacks=32):\n    """"""\n    Sphere centered at origin.\n\n    The sphere is subdivided around the Z axis into slices and along the Z axis\n    into stacks.\n\n    Parameters\n    ----------\n    radius : float\n        The radius of the sphere.\n    slices : float\n        The number of subdivisions around the Z axis (similar to lines of longitude).\n    stacks : float\n        The number of subdivisions along the Z axis (similar to lines of latitude).\n    """"""\n\n    vtype = [(\'position\', np.float32, 3),\n             (\'texcoord\', np.float32, 2),\n             (\'normal\',   np.float32, 3)]\n    itype = np.uint32\n    slices += 1\n    stacks += 1\n    n = slices*stacks\n\n    vertices = np.zeros(n, dtype=vtype)\n    theta1 = np.repeat(np.linspace(0,     np.pi, stacks, endpoint=True), slices)\n    theta2 = np.tile  (np.linspace(0, 2 * np.pi, slices, endpoint=True), stacks)\n\n    vertices[""position""][:,1] = np.sin(theta1) * np.cos(theta2) * radius\n    vertices[""position""][:,2] =                  np.cos(theta1) * radius\n    vertices[""position""][:,0] = np.sin(theta1) * np.sin(theta2) * radius\n    vertices[""normal""] = vertices[""position""]\n    vertices[""texcoord""][:,0] = np.tile(np.linspace(0, 1, slices, endpoint=True), stacks)\n    vertices[""texcoord""][:,1] = np.repeat(np.linspace(1, 0, stacks, endpoint=True), slices)\n\n    indices = []\n    for i in range(stacks-1):\n        for j in range(slices-1):\n            indices.append(i*(slices) + j        )\n            indices.append(i*(slices) + j+1      )\n            indices.append(i*(slices) + j+slices+1)\n            indices.append(i*(slices) + j+slices  )\n            indices.append(i*(slices) + j+slices+1)\n            indices.append(i*(slices) + j        )\n\n    indices = np.array(indices, dtype=itype)\n    return vertices.view(gloo.VertexBuffer), indices.view(gloo.IndexBuffer)\n\n\ndef cubesphere(radius=1.0, n=32):\n    """"""\n    Cubesphere (cube warped into sphere) centered at origin.\n\n    Parameters\n    ----------\n    radius : float\n        The radius of the sphere.\n    n : int\n        Tesselation level\n    """"""\n\n    vertices, indices = cube(1.0,n)\n    L = np.sqrt((vertices[""position""]**2).sum(axis=1))\n    vertices[""position""] /= L.reshape(len(vertices),1)/radius\n    vertices[""normal""] = vertices[""position""]\n    return vertices, indices\n\n\n\n\ndef teapot(size=1.0):\n    """"""\n    Z-axis aligned Utah teapot\n\n    Parameters\n    ----------\n\n    size : float\n        Relative size of the teapot.\n    """"""\n\n    vertices, indices = data.get(""teapot.obj"")\n    xmin = vertices[""position""][:,0].min()\n    xmax = vertices[""position""][:,0].max()\n    ymin = vertices[""position""][:,1].min()\n    ymax = vertices[""position""][:,1].max()\n    zmin = vertices[""position""][:,2].min()\n    zmax = vertices[""position""][:,2].max()\n\n    # Centering\n    vertices[""position""][:,0] -= xmin + (xmax-xmin)/2\n    vertices[""position""][:,1] -= ymin + (ymax-ymin)/2\n    vertices[""position""][:,2] -= zmin + (zmax-zmin)/2\n\n    # Rotation to align on Z-axis\n    X = vertices[""position""][:,0].copy()\n    Y = vertices[""position""][:,1].copy()\n    Z = vertices[""position""][:,2].copy()\n    NX = vertices[""normal""][:,0].copy()\n    NY = vertices[""normal""][:,1].copy()\n    NZ = vertices[""normal""][:,2].copy()\n    vertices[""position""][:,0] = X\n    vertices[""position""][:,1] = Z\n    vertices[""position""][:,2] = Y\n    vertices[""normal""][:,0] = NX\n    vertices[""normal""][:,1] = NZ\n    vertices[""normal""][:,2] = NY\n\n    # Scaling according to height\n    vertices[""position""] *= 2.0*size/(zmax-zmin)\n\n    return vertices, indices\n'"
glumpy/gloo/__init__.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . atlas import Atlas\nfrom . snippet import Snippet\nfrom . program import Program\nfrom . gpudata import GPUData\nfrom . globject import GLObject\nfrom . variable import Variable, Attribute, Uniform\nfrom . uniforms import Uniforms\nfrom . texture import Texture\nfrom . texture import TextureCube\nfrom . texture import Texture1D, Texture2D\nfrom . texture import TextureFloat1D, TextureFloat2D\nfrom . texture import DepthTexture\nfrom . array import VertexArray\nfrom . buffer import Buffer\nfrom . buffer import VertexBuffer, IndexBuffer\nfrom . shader import Shader\nfrom . shader import VertexShader, FragmentShader, GeometryShader\nfrom . framebuffer import FrameBuffer\nfrom . framebuffer import RenderBuffer,ColorBuffer, DepthBuffer, StencilBuffer\n'"
glumpy/gloo/array.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nVertex Array objects are OpenGL objects that store all of the state needed\nto supply vertex data. Only available from GL > 3.2.\n\nRead more on buffer objects on `OpenGL Wiki\n<https://www.opengl.org/wiki/Vertex_Specification>`_\n\n**Example usage**:\n\n  .. code:: python\n\n     dtype = [(""position"", np.float32, 3),\n              (""color"",    np.float32, 4)]\n     V = np.zeros(4,dtype).view(gloo.VertexArray)\n""""""\nimport numpy as np\n\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.gloo.gpudata import GPUData\nfrom glumpy.gloo.globject import GLObject\nfrom glumpy.gloo.buffer import VertexBuffer\n\nclass VertexArray(GPUData,GLObject):\n    """"""\n    Vertex array.\n\n    A vertex array is an interface used to specify vertex data structure.\n    """"""\n\n    def __init__(self, usage=gl.GL_DYNAMIC_DRAW):\n        GLObject.__init__(self)\n        self._target = gl.GL_ARRAY_BUFFER\n        self._buffer = self.view(VertexBuffer)\n        self._buffer.__init__(usage)\n\n\n    @property\n    def need_update(self):\n        """""" Whether object needs to be updated """"""\n\n        return self._buffer.need_update\n\n\n    def _update(self):\n        """""" Upload all pending data to GPU. """"""\n\n        self._buffer._update()\n\n    \n    def _create(self):\n        """""" Create vertex array on GPU """"""\n\n        self._handle = gl.glGenVertexArrays(1)\n        log.debug(""GPU: Creating vertex array (id=%d)"" % self._id)\n        self._deactivate()\n        self._buffer._create()\n\n        \n    def _delete(self):\n        """""" Delete vertex array from GPU """"""\n\n        if self._handle > -1:\n            self._buffer._delete()\n            gl.glDeleteVertexArrays(1, np.array([self._handle]))\n\n\n    def _activate(self):\n        """""" Bind the array """"""\n\n        log.debug(""GPU: Activating array (id=%d)"" % self._id)\n        gl.glBindVertexArray(self._handle)\n        self._buffer._activate()\n        \n\n    def _deactivate(self):\n        """""" Unbind the current bound array """"""\n\n        self._buffer._deactivate()\n        log.debug(""GPU: Deactivating array (id=%d)"" % self._id)\n        gl.glBindVertexArray(0)\n'"
glumpy/gloo/atlas.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nA Texture atlas allows to group multiple small data regions into a larger\ntexture.\n\nThe algorithm is based on the article by Jukka Jyla\xcc\x88nki : ""A Thousand Ways\nto Pack the Bin - A Practical Approach to Two-Dimensional Rectangle Bin\nPacking"", February 27, 2010. More precisely, this is an implementation of\nthe Skyline Bottom-Left algorithm based on C++ sources provided by Jukka\nJyla\xcc\x88nki at: http://clb.demon.fi/files/RectangleBinPack/\n\nExample usage:\n--------------\n""""""\nimport sys\nfrom glumpy.log import log\nfrom . texture import Texture2D\n\n\nclass Atlas(Texture2D):\n    """""" Texture Atlas (two dimensional)\n\n    Parameters\n\n    data : ndarray\n        Texture data (optional)\n\n    shape : tuple of integers\n        Texture shape (optional)\n\n    dtype : dtype\n        Texture data type (optional)\n\n    store : bool\n        Specify whether this object stores a reference to the data,\n        allowing the data to be updated regardless of striding. Note\n        that modifying the data after passing it here might result in\n        undesired behavior, unless a copy is given. Default True.\n\n    format : ENUM\n        The format of the texture: GL_LUMINANCE, ALPHA, GL_LUMINANCE_ALPHA,\n        or GL_RGB, GL_RGBA. If not given the format is chosen automatically\n        based on the number of channels. When the data has one channel,\n        GL_LUMINANCE is assumed.\n    """"""\n\n\n    def __init__(self):\n        Texture2D.__init__(self)\n        self.nodes  = [(0,0,self.width),]\n        self.used   = 0\n\n\n    def allocate(self, shape):\n        """"""\n        Allocate a new region of given shape.\n\n        Parameters\n        ----------\n\n        shape : (int,int)\n            Shape of region  as (heigth, width)\n\n        Return\n        ------\n            Texture2D or None\n        """"""\n\n        height, width = shape\n        best_height = sys.maxsize\n        best_index = -1\n        best_width = sys.maxsize\n        region = 0, 0, width, height\n\n        for i in range(len(self.nodes)):\n            y = self._fit(i, width, height)\n            if y >= 0:\n                node = self.nodes[i]\n                if (y+height < best_height or\n                    (y+height == best_height and node[2] < best_width)):\n                    best_height = y+height\n                    best_index = i\n                    best_width = node[2]\n                    region = node[0], y, width, height\n\n        if best_index == -1:\n            log.warn(""No enough free space in atlas"")\n            return None\n\n        node = region[0], region[1]+height, width\n        self.nodes.insert(best_index, node)\n\n        i = best_index+1\n        while i < len(self.nodes):\n            node = self.nodes[i]\n            prev_node = self.nodes[i-1]\n            if node[0] < prev_node[0]+prev_node[2]:\n                shrink = prev_node[0]+prev_node[2] - node[0]\n                x,y,w = self.nodes[i]\n                self.nodes[i] = x+shrink, y, w-shrink\n                if self.nodes[i][2] <= 0:\n                    del self.nodes[i]\n                    i -= 1\n                else:\n                    break\n            else:\n                break\n            i += 1\n\n        self._merge()\n        self.used += width*height\n        x,y,width,height = region\n        return region\n        # return self[y:y+height, x:x+width]\n        # return self[x:x+width, y:y+height]\n\n\n\n    def _fit(self, index, width, height):\n        """"""\n        Test if region (width,height) fit into self.nodes[index]\n\n        Parameters\n        ----------\n\n        index : int\n            Index of the internal node to be tested\n\n        width : int\n            Width or the region to be tested\n\n        height : int\n            Height or the region to be tested\n        """"""\n\n        node = self.nodes[index]\n        x,y = node[0], node[1]\n        width_left = width\n\n        if x+width > self.width:\n            return -1\n\n        i = index\n        while width_left > 0:\n            node = self.nodes[i]\n            y = max(y, node[1])\n            if y+height > self.height:\n                return -1\n            width_left -= node[2]\n            i += 1\n        return y\n\n\n    def _merge(self):\n        """""" Merge nodes. """"""\n\n        i = 0\n        while i < len(self.nodes)-1:\n            node = self.nodes[i]\n            next_node = self.nodes[i+1]\n            if node[1] == next_node[1]:\n                self.nodes[i] = node[0], node[1], node[2]+next_node[2]\n                del self.nodes[i+1]\n            else:\n                i += 1\n'"
glumpy/gloo/buffer.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nBuffer objects are OpenGL objects that store an array of unformatted memory\nallocated by the OpenGL context (aka: the GPU). These can be used to store\nvertex data, pixel data retrieved from images or the framebuffer, and a variety\nof other things.\n\nRead more on buffer objects on `OpenGL Wiki\n<https://www.opengl.org/wiki/Buffer_Object>`_\n\n**Example usage**:\n\n  .. code:: python\n\n     dtype = [(""position"", np.float32, 3),\n              (""color"",    np.float32, 4)]\n     V = np.zeros(4,dtype).view(gloo.VertexBuffer)\n\n""""""\nimport numpy as np\n\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.gloo.gpudata import GPUData\nfrom glumpy.gloo.globject import GLObject\n\n\nclass Buffer(GPUData,GLObject):\n    """"""\n    Generic GPU buffer.\n\n    A generic buffer is an interface used to upload data to a GPU array buffer\n    (gl.GL_ARRAY_BUFFER or gl.GL_ELEMENT_ARRAY_BUFFER).\n    """"""\n\n    def __init__(self, target, usage):\n        GLObject.__init__(self)\n        self._target = target\n        self._usage = usage\n\n\n    @property\n    def need_update(self):\n        """""" Whether object needs to be updated """"""\n\n        return self.pending_data is not None\n\n\n    def _create(self):\n        """""" Create buffer on GPU """"""\n\n        self._handle = gl.glGenBuffers(1)\n        self._activate()\n        log.debug(""GPU: Creating buffer (id=%d)"" % self._id)\n        gl.glBufferData(self._target, self.nbytes, None, self._usage)\n        self._deactivate()\n\n\n    def _delete(self):\n        """""" Delete buffer from GPU """"""\n\n        if self._handle > -1:\n            gl.glDeleteBuffers(1, np.array([self._handle]))\n\n\n    def _activate(self):\n        """""" Bind the buffer to some target """"""\n\n        log.debug(""GPU: Activating buffer (id=%d)"" % self._id)\n        gl.glBindBuffer(self._target, self._handle)\n\n\n    def _deactivate(self):\n        """""" Unbind the current bound buffer """"""\n\n        log.debug(""GPU: Deactivating buffer (id=%d)"" % self._id)\n        gl.glBindBuffer(self._target, 0)\n\n\n    def _update(self):\n        """""" Upload all pending data to GPU. """"""\n\n        if self.pending_data:\n            start, stop = self.pending_data\n            offset, nbytes = start, stop-start\n            # offset, nbytes = self.pending_data\n            data = self.ravel().view(np.ubyte)[offset:offset+nbytes]\n            gl.glBufferSubData(self.target, offset, nbytes, data)\n        self._pending_data = None\n        self._need_update = False\n\n\n\nclass VertexBuffer(Buffer):\n    """""" Buffer for vertex attribute data """"""\n\n    def __init__(self, usage=gl.GL_DYNAMIC_DRAW):\n        Buffer.__init__(self, gl.GL_ARRAY_BUFFER, usage)\n\n\nclass IndexBuffer(Buffer):\n    """""" Buffer for index data """"""\n\n    def __init__(self, usage=gl.GL_DYNAMIC_DRAW):\n        Buffer.__init__(self, gl.GL_ELEMENT_ARRAY_BUFFER, usage)\n'"
glumpy/gloo/framebuffer.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nA framebuffer is a collection of buffers that can be used as the destination\nfor rendering. OpenGL has two kinds of framebuffers: the default framebuffer,\nwhich is provided by the OpenGL Context; and user-created framebuffers called\nframebuffer objects (FBOs). The buffers for default framebuffers are part of\nthe context and usually represent a window or display device. The buffers for\nFBOs reference images from either textures or render buffers; they are never\ndirectly visible.\n\nRead more on framebuffers on `OpenGL Wiki\n<https://www.opengl.org/wiki/Framebuffer>`_\n\n**Example usage**\n\n  .. code:: python\n\n     ...\n     texture = np.zeros((512,512,4),np.float32).view(gloo.TextureFloat2D)\n     framebuffer = gloo.FrameBuffer(color=[texture])\n     ...\n\n     @window.event\n     def on_draw(dt):\n         framebuffer.activate()\n         window.clear()\n         quad.draw(gl.GL_TRIANGLE_STRIP)\n         framebuffer.deactivate()\n""""""\nimport numpy as np\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.gloo.globject import GLObject\nfrom glumpy.gloo.texture import Texture2D\n\n\nclass RenderBuffer(GLObject):\n    """""" Base class for render buffer object.\n\n    :param GLEnum format: Buffer format\n    :param int width:     Buffer width (pixels)\n    :param int height:    Buffer height (pixel)\n    """"""\n\n    def __init__(self, width, height, format):\n        GLObject.__init__(self)\n        self._width = width\n        self._height = height\n        self._target = gl.GL_RENDERBUFFER\n        self._format = format\n        self._need_resize = True\n\n\n    @property\n    def width(self):\n        """""" Buffer width (read-only). """"""\n\n        return self._width\n\n\n    @property\n    def height(self):\n        """""" Buffer height (read-only). """"""\n        return self._height\n\n\n    def resize(self, width, height):\n        """""" Resize the buffer (deferred operation).\n\n        :param int width:  New buffer width (pixels)\n        :param int height: New buffer height (pixels)\n        """"""\n\n        if width != self._width or height != self._height:\n            self._need_resize = True\n            self._width = width\n            self._height = height\n\n    def _create(self):\n        """""" Create buffer on GPU """"""\n\n        log.debug(""GPU: Create render buffer"")\n        self._handle = gl.glGenRenderbuffers(1)\n\n\n    def _delete(self):\n        """""" Delete buffer from GPU """"""\n\n        log.debug(""GPU: Deleting render buffer"")\n        gl.glDeleteRenderbuffer(self._handle)\n\n\n    def _activate(self):\n        """""" Activate buffer on GPU """"""\n\n        log.debug(""GPU: Activate render buffer"")\n        gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, self._handle)\n        if self._need_resize:\n            self._resize()\n            self._need_resize = False\n\n\n    def _deactivate(self):\n        """""" Deactivate buffer on GPU """"""\n\n        log.debug(""GPU: Deactivate render buffer"")\n        gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, 0)\n\n\n    def _resize(self):\n        """""" Buffer resize on GPU """"""\n\n        # WARNING: width/height should be checked against maximum size\n        # maxsize = gl.glGetParameter(gl.GL_MAX_RENDERBUFFER_SIZE)\n        log.debug(""GPU: Resize render buffer"")\n        gl.glRenderbufferStorage(self._target, self._format,\n                                 self._width, self._height)\n\n\n\n\nclass ColorBuffer(RenderBuffer):\n    """""" Color buffer object.\n\n    :param int width:     Buffer width (pixels)\n    :param int height:    Buffer height (pixel)\n    :param GLEnum format: Buffer format (default is gl.GL_RGBA)\n    """"""\n\n    def __init__(self, width, height, format=gl.GL_RGBA):\n        # if format not in (gl.GL_RGB565, gl.GL_RGBA4, gl.GL_RGB5_A1):\n        #     raise ValueError(""Format not allowed for color buffer"")\n        RenderBuffer.__init__(self, width, height, format)\n\n\n\n\n\nclass DepthBuffer(RenderBuffer):\n    """""" Depth buffer object.\n\n    :param int width:     Buffer width (pixels)\n    :param int height:    Buffer height (pixel)\n    :param GLEnum format: Buffer format (default is gl.GL_DEPTH_COMPONENT)\n    """"""\n\n    def __init__(self, width, height, format=gl.GL_DEPTH_COMPONENT):\n        #if format not in (gl.GL_DEPTH_COMPONENT16,):\n        #    raise ValueError(""Format not allowed for depth buffer"")\n        RenderBuffer.__init__(self, width, height, format)\n\n\n\nclass StencilBuffer(RenderBuffer):\n    """""" Stencil buffer object\n\n    :param int width:     Buffer width (pixels)\n    :param int height:    Buffer height (pixel)\n    :param GLEnum format: Buffer format (default is gl.GL_STENCIL_INDEX8)\n    """"""\n\n    def __init__(self, width, height, format=gl.GL_STENCIL_INDEX8):\n        # if format not in (gl.GL_STENCIL_INDEX,):\n        #     raise ValueError(""Format not allowed for color buffer"")\n        RenderBuffer.__init__(self, width, height, format)\n\n\n\n\nclass FrameBuffer(GLObject):\n    """""" Framebuffer object.\n\n    :param ColorBuffer color:     One or several color buffers or None\n    :param DepthBuffer depth:     A depth buffer or None\n    :param StencilBuffer stencil: A stencil buffer or None\n    """"""\n\n    def __init__(self, color=None, depth=None, stencil=None):\n        """"""\n        """"""\n\n        GLObject.__init__(self)\n\n        self._width = None\n        self._height = None\n        self._color = None\n        self._depth = None\n        self._stencil = None\n        self._need_attach = True\n        self._pending_attachments = []\n\n        if color is not None:\n            self.color = color\n        if depth is not None:\n            self.depth = depth\n        if stencil is not None:\n            self.stencil = stencil\n\n    @property\n    def color(self):\n        """""" Color buffer attachment(s) (read/write) """"""\n\n        return self._color\n\n\n    @color.setter\n    def color(self, buffers):\n        """""" Color buffer attachment(s) (read/write) """"""\n\n        if not isinstance(buffers,list):\n            buffers = [buffers]\n\n        self._color = []\n\n        for i,buffer in enumerate(buffers):\n            if self.width is not None and self.width != buffer.width:\n                raise ValueError(""Buffer width does not match"")\n            elif self.height is not None and self.height != buffer.height:\n                raise ValueError(""Buffer height does not match"")\n            self._width = buffer.width\n            self._height = buffer.height\n\n            target = gl.GL_COLOR_ATTACHMENT0+i\n            self._color.append(buffer)\n\n            if isinstance(buffer, (ColorBuffer, Texture2D)) or buffer is None:\n                self._pending_attachments.append((target, buffer))\n            else:\n                raise ValueError(\n                    ""Buffer must be a ColorBuffer, Texture2D or None"")\n        self._need_attach = True\n\n\n    @property\n    def depth(self):\n        """""" Depth buffer attachment (read/write) """"""\n\n        return self._depth\n\n\n    @depth.setter\n    def depth(self, buffer):\n        """""" Depth buffer attachment (read/write) """"""\n\n        if self.width is not None and self.width != buffer.width:\n            raise ValueError(""Buffer width does not match"")\n        elif self.height is not None and self.height != buffer.height:\n            raise ValueError(""Buffer height does not match"")\n        self._width = buffer.width\n        self._height = buffer.height\n\n        target = gl.GL_DEPTH_ATTACHMENT\n        self._depth = buffer\n        if isinstance(buffer, (DepthBuffer, Texture2D)) or buffer is None:\n            self._pending_attachments.append((target, buffer))\n        else:\n            raise ValueError(\n                ""Buffer must be a DepthBuffer, Texture2D or None"")\n        self._need_attach = True\n\n\n    @property\n    def stencil(self):\n        """""" Stencil buffer attachment (read/write) """"""\n\n        return self._stencil\n\n\n    @stencil.setter\n    def stencil(self, buffer):\n        """""" Stencil buffer attachment (read/write) """"""\n\n        if self.width is not None and self.width != buffer.width:\n            raise ValueError(""Buffer width does not match"")\n        elif self.height is not None and self.height != buffer.height:\n            raise ValueError(""Buffer height does not match"")\n        self._width = buffer.width\n        self._height = buffer.height\n\n        target = gl.GL_STENCIL_ATTACHMENT\n        self._stencil = buffer\n        if isinstance(buffer, StencilBuffer) or buffer is None:\n            self._pending_attachments.append((target, buffer))\n        else:\n            raise ValueError(\n                ""Buffer must be a StencilBuffer, Texture2D or None"")\n        self._need_attach = True\n\n\n    @property\n    def width(self):\n        """""" Buffer width (read only, pixels) """"""\n\n        return self._width\n\n\n    @property\n    def height(self):\n        """""" Buffer height (read only, pixels) """"""\n\n        return self._height\n\n\n    def resize(self, width, height):\n        """""" Resize the buffer (deferred operation).\n\n        This method will also resize any attached buffers.\n\n        :param int width:  New buffer width (pixels)\n        :param int height: New buffer height (pixels)\n        """"""\n\n        self._width = width\n        self._height = height\n\n        for i, buffer in enumerate(self.color):\n            if isinstance(buffer, ColorBuffer):\n                buffer.resize(width, height)\n            elif isinstance(buffer, Texture2D):\n                newbuffer = np.resize(buffer, (height,width,buffer.shape[2]))\n                newbuffer = newbuffer.view(buffer.__class__)\n                self.color[i] = newbuffer\n                buffer.delete()\n\n                target = gl.GL_COLOR_ATTACHMENT0+i\n                self._pending_attachments.append((target, self.color[i]))\n                self._need_attach = True\n\n        if isinstance(self.depth, DepthBuffer):\n            self.depth.resize(width, height)\n        elif isinstance(self.depth, Texture2D):\n            depth = np.resize(self.depth, (height,width, self.depth.shape[2]))\n            depth = depth.view(self.depth.__class__)\n            self.depth.delete()\n            self.depth = depth\n\n            target = gl.GL_DEPTH_ATTACHMENT\n            self._pending_attachments.append((target, self.depth))\n            self._need_attach = True\n\n        if isinstance(self.stencil, StencilBuffer):\n            self.stencil.resize(width, height)\n        elif isinstance(self.stencil, Texture2D):\n            stencil = np.resize(self.stencil, (height,width, self.stencil.shape[2]))\n            stencil = stencil.view(self.stencil.__class__)\n            self.stencil.delete()\n            self.stencil = stencil\n\n            target = gl.GL_STENCIL_ATTACHMENT\n            self._pending_attachments.append((target, self.stencil))\n            self._need_attach = True\n\n\n    def _create(self):\n        """""" Create framebuffer on GPU """"""\n\n        log.debug(""GPU: Create framebuffer"")\n        self._handle = gl.glGenFramebuffers(1)\n\n\n    def _delete(self):\n        """""" Delete buffer from GPU """"""\n\n        log.debug(""GPU: Delete framebuffer"")\n        gl.glDeleteFramebuffers(1, np.array([self._handle]))\n\n\n    def _activate(self):\n        """""" Activate framebuffer on GPU """"""\n\n        log.debug(""GPU: Activate render framebuffer"")\n        gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, self._handle)\n\n        if self._need_attach:\n            self._attach()\n            self._need_attach = False\n        attachments = [gl.GL_COLOR_ATTACHMENT0+i for i in range(len(self.color))]\n        gl.glDrawBuffers(np.array(attachments,dtype=np.uint32))\n\n\n    def _deactivate(self):\n        """""" Deactivate framebuffer on GPU """"""\n\n        log.debug(""GPU: Deactivate render framebuffer"")\n        gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, 0)\n        # gl.glDrawBuffers([gl.GL_COLOR_ATTACHMENT0])\n\n\n    def _attach(self):\n        """""" Attach render buffers to framebuffer """"""\n\n        log.debug(""GPU: Attach render buffers"")\n        while self._pending_attachments:\n            attachment, buffer = self._pending_attachments.pop(0)\n            if buffer is None:\n                gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER, attachment,\n                                             gl.GL_RENDERBUFFER, 0)\n            elif isinstance(buffer, RenderBuffer):\n                buffer.activate()\n                gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER, attachment,\n                                             gl.GL_RENDERBUFFER, buffer.handle)\n                buffer.deactivate()\n            elif isinstance(buffer, Texture2D):\n                buffer.activate()\n                # INFO: 0 is for mipmap level 0 (default) of the texture\n                gl.glFramebufferTexture2D(gl.GL_FRAMEBUFFER, attachment,\n                                          buffer.target, buffer.handle, 0)\n                buffer.deactivate()\n            else:\n                raise ValueError(""Invalid attachment"")\n\n\n        res = gl.glCheckFramebufferStatus(gl.GL_FRAMEBUFFER)\n        if res == gl.GL_FRAMEBUFFER_COMPLETE:\n            pass\n        elif res == 0:\n            raise RuntimeError(\'Target not equal to GL_FRAMEBUFFER\')\n        elif res == gl.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            raise RuntimeError(\n                \'FrameBuffer attachments are incomplete.\')\n        elif res == gl.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            raise RuntimeError(\n                \'No valid attachments in the FrameBuffer.\')\n        elif res == gl.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            raise RuntimeError(\n                \'attachments do not have the same width and height.\')\n        elif res == gl.GL_FRAMEBUFFER_INCOMPLETE_FORMATS:\n            raise RuntimeError(\'Internal format of attachment \'\n                               \'is not renderable.\')\n        elif res == gl.GL_FRAMEBUFFER_UNSUPPORTED:\n            raise RuntimeError(\'Combination of internal formats used \'\n                               \'by attachments is not supported.\')\n'"
glumpy/gloo/globject.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n\nclass GLObject(object):\n    """""" Generic GL object that may live both on CPU and GPU """"""\n\n    # Internal id counter to keep track of GPU objects\n    _idcount = 0\n\n    def __init__(self):\n        """""" Initialize the object in the default state """"""\n\n        self._handle = -1\n        self._target = None\n        self._need_setup = True\n        self._need_create = True\n        self._need_update = True\n        self._need_delete = False\n\n        GLObject._idcount += 1\n        self._id = GLObject._idcount\n\n\n    # def __del__(self):\n    #     """""" Fake deletion """"""\n    #     # You never know when this is goint to happen. The window might\n    #     # already be closed and no OpenGL context might be available.\n    #     # Worse, there might be multiple contexts and calling delete()\n    #     # at the wrong moment might remove other gl objects, leading to\n    #     # very strange and hard to debug behavior.\n    #     #\n    #     # So we don\'t do anything.\n    #     if hasattr(self, ""_handle""):\n    #         if self._handle > -1:\n    #             self._delete()\n    #     else:\n    #         print ""Deleting something""\n\n    def __enter__(self):\n        self.activate()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.deactivate()\n\n    @property\n    def need_create(self):\n        """""" Whether object needs to be created """"""\n        return self._need_create\n\n\n    @property\n    def need_update(self):\n        """""" Whether object needs to be updated """"""\n        return self._need_update\n\n\n    @property\n    def need_setup(self):\n        """""" Whether object needs to be setup """"""\n        return self._need_setup\n\n\n    @property\n    def need_delete(self):\n        """""" Whether object needs to be deleted """"""\n        return self._need_delete\n\n\n    def delete(self):\n        """""" Delete the object from GPU memory """"""\n\n        #if self.need_delete:\n        self._delete()\n        self._handle = -1\n        self._need_setup = True\n        self._need_create = True\n        self._need_update = True\n        self._need_delete = False\n\n\n    def activate(self):\n        """""" Activate the object on GPU """"""\n\n        if hasattr(self, ""base"") and isinstance(self.base,GLObject):\n            self.base.activate()\n            return\n\n        if self.need_create:\n            self._create()\n            self._need_create = False\n\n        self._activate()\n\n        if self.need_setup:\n            self._setup()\n            self._need_setup = False\n\n        if self.need_update:\n            self._update()\n            self._need_update = False\n\n\n    def deactivate(self):\n        """""" Deactivate the object on GPU """"""\n\n        if hasattr(self,""base"") and isinstance(self.base,GLObject):\n            self.base.deactivate()\n        else:\n            self._deactivate()\n\n\n    @property\n    def handle(self):\n        """""" Name of this object on the GPU """"""\n\n        if hasattr(self, ""base"") and isinstance(self.base,GLObject):\n            if hasattr(self.base, ""_handle""):\n                return self.base._handle\n        return self._handle\n        #return self._handle\n\n\n    @property\n    def target(self):\n        """""" OpenGL type of object. """"""\n\n        if hasattr(self, ""base"") and isinstance(self.base,GLObject):\n            return self.base._target\n        return self._target\n        #return self._handle\n\n\n    def _create(self):\n        """""" Dummy create method """"""\n\n        pass\n\n\n    def _delete(self):\n        """""" Dummy delete method """"""\n\n        pass\n\n\n    def _activate(self):\n        """""" Dummy activate method """"""\n\n        pass\n\n\n    def _deactivate(self):\n        """""" Dummy deactivate method """"""\n\n        pass\n\n\n    def _setup(self):\n        """""" Dummy setup method """"""\n\n        pass\n\n\n    def _update(self):\n        """""" Dummy update method """"""\n\n        pass\n'"
glumpy/gloo/gpudata.py,13,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nGPU data is the base class for any data that needs to co-exist on both CPU and\nGPU memory. It keeps track of the smallest contiguous area that needs to be\nuploaded to GPU to keep the CPU and GPU data synced. This allows to update the\ndata in one operation. Even though this might be sub-optimal in a few cases, it\nprovides a greater usage flexibility and most of the time, it will be faster.\n\nThis is done transparently and user can use a GPU buffer as a regular numpy\narray. The `pending_data` property indicates the region (offset/nbytes) of\nthe base array that needs to be uploaded.\n\n**Example**:\n\n  .. code::\n\n     data = np.zeros((5,5)).view(GPUData)\n     print data.pending_data\n     (0, 200)\n""""""\nimport numpy as np\n\n\nclass GPUData(np.ndarray):\n    """"""\n    Memory tracked numpy array.\n    """"""\n\n    def __new__(cls, *args, **kwargs):\n        return np.ndarray.__new__(cls, *args, **kwargs)\n\n    def __init__(self, *args, **kwargs):\n        pass\n\n    def __array_finalize__(self, obj):\n        if not isinstance(obj, GPUData):\n            self._extents = 0, self.size*self.itemsize\n            self.__class__.__init__(self)\n            self._pending_data = self._extents\n        else:\n            self._extents = obj._extents\n\n\n    @property\n    def pending_data(self):\n        """""" Pending data region as (byte offset, byte size) """"""\n\n        if isinstance(self.base, GPUData):\n            return self.base.pending_data\n\n        if self._pending_data:\n            return self._pending_data\n            # start, stop = self._pending_data\n            # WARN: semantic is offset, nbytes\n            # extents semantic is start, stop\n            # return start, stop-start\n            return start, stop\n        else:\n            return None\n\n    @property\n    def stride(self):\n        """""" Item stride in the base array. """"""\n\n        if self.base is None:\n            return self.ravel().strides[0]\n        else:\n            return self.base.ravel().strides[0]\n\n    @property\n    def offset(self):\n        """""" Byte offset in the base array. """"""\n\n        return self._extents[0]\n\n\n    def _add_pending_data(self, start, stop):\n        """"""\n        Add pending data, taking care of previous pending data such that it\n        is always a contiguous area.\n        """"""\n        base = self.base\n        if isinstance(base, GPUData):\n            base._add_pending_data(start, stop)\n        else:\n            if self._pending_data is None:\n                self._pending_data = start, stop\n            else:\n                start = min(self._pending_data[0], start)\n                stop = max(self._pending_data[1], stop)\n                self._pending_data = start, stop\n\n    def _compute_extents(self, Z):\n        """"""\n        Compute extents (start, stop) in the base array.\n        """"""\n\n        if self.base is not None:\n            base = self.base.__array_interface__[\'data\'][0]\n            view = Z.__array_interface__[\'data\'][0]\n            offset = view - base\n            shape = np.array(Z.shape) - 1\n            strides = np.array(Z.strides)\n            size = (shape*strides).sum() + Z.itemsize\n            return offset, offset+size\n        else:\n            return 0, self.size*self.itemsize\n\n\n    def __getitem__(self, key):\n        """""" FIXME: Need to take care of case where key is a list or array """"""\n\n        Z = np.ndarray.__getitem__(self, key)\n        if not hasattr(Z,\'shape\') or Z.shape == ():\n            return Z\n        Z._extents = self._compute_extents(Z)\n        return Z\n\n    def __setitem__(self, key, value):\n        """""" FIXME: Need to take care of case where key is a list or array """"""\n        \n        Z = np.ndarray.__getitem__(self, key)\n        if Z.shape == ():\n            # WARN: Be careful with negative indices !\n            key = np.mod(np.array(key)+self.shape, self.shape)\n            offset = self._extents[0]+(key * self.strides).sum()\n            size = Z.itemsize\n            self._add_pending_data(offset, offset+size)\n            key = tuple(key)\n        else:\n            Z._extents = self._compute_extents(Z)\n            self._add_pending_data(Z._extents[0], Z._extents[1])\n        np.ndarray.__setitem__(self, key, value)\n\n\n    def __getslice__(self, start, stop):\n        return self.__getitem__(slice(start, stop))\n\n    def __setslice__(self, start, stop,  value):\n        return self.__setitem__(slice(int(start), int(stop)), value)\n\n    def __iadd__(self, other):\n        self._add_pending_data(self._extents[0], self._extents[1])\n        return np.ndarray.__iadd__(self, other)\n\n    def __isub__(self, other):\n        self._add_pending_data(self._extents[0], self._extents[1])\n        return np.ndarray.__isub__(self, other)\n\n    def __imul__(self, other):\n        self._add_pending_data(self._extents[0], self._extents[1])\n        return np.ndarray.__imul__(self, other)\n\n    def __idiv__(self, other):\n        self._add_pending_data(self._extents[0], self._extents[1])\n        return np.ndarray.__idiv__(self, other)\n'"
glumpy/gloo/parser.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\nimport numpy as np\nimport OpenGL.GL as gl\nfrom glumpy import library\nfrom glumpy.log import log\n\n\ndef remove_comments(code):\n    """""" Remove C-style comment from GLSL code string """"""\n\n    pattern = r""(\\"".*?\\""|\\\'.*?\\\')|(/\\*.*?\\*/|//[^\\r\\n]*\\n)""\n    # first group captures quoted strings (double or single)\n    # second group captures comments (//single-line or /* multi-line */)\n    regex = re.compile(pattern, re.MULTILINE|re.DOTALL)\n\n    def do_replace(match):\n        # if the 2nd group (capturing comments) is not None,\n        # it means we have captured a non-quoted (real) comment string.\n        if match.group(2) is not None:\n            return """" # so we will return empty to remove the comment\n        else: # otherwise, we will return the 1st group\n            return match.group(1) # captured quoted-string\n\n    return regex.sub(do_replace, code)\n\n\ndef remove_version(code):\n    """""" Remove any version directive """"""\n\n    pattern = \'\\#\\s*version[^\\r\\n]*\\n\'\n    regex = re.compile(pattern, re.MULTILINE|re.DOTALL)\n    return regex.sub(\'\\n\', code)\n\n\ndef merge_includes(code):\n    """""" Merge all includes recursively """"""\n\n    # pattern = \'\\#\\s*include\\s*""(?P<filename>[a-zA-Z0-9\\-\\.\\/]+)""[^\\r\\n]*\\n\'\n    pattern = \'\\#\\s*include\\s*""(?P<filename>[a-zA-Z0-9\\-\\.\\/\\_]+)""\'\n    regex = re.compile(pattern)\n    includes = []\n\n    def replace(match):\n        filename = match.group(""filename"")\n\n        if filename not in includes:\n            includes.append(filename)\n            path = library.find(filename)\n            if not path:\n                log.critical(\'""%s"" not found\' % filename)\n                raise RuntimeError(""File not found"")\n            text = \'\\n// --- start of ""%s"" ---\\n\' % filename\n            text += remove_comments(open(path).read())\n            text += \'// --- end of ""%s"" ---\\n\' % filename\n            return text\n        return \'\'\n\n    # Limit recursion to depth 10\n    for i in range(10):\n        if re.search(regex, code):\n            code = re.sub(regex, replace, code)\n        else:\n            break;\n\n    return code\n\n\ndef preprocess(code):\n    """""" Preprocess a code by removing comments, version and merging includes """"""\n\n    if code:\n        code = remove_comments(code)\n        code = remove_version(code)\n        code = merge_includes(code)\n    return code\n\n\ndef get_declarations(code, qualifier = """"):\n    """""" Extract declarations of type:\n\n        qualifier type name[,name,...];\n    """"""\n\n    if not len(code):\n        return []\n\n    variables = []\n\n    if isinstance(qualifier,list):\n        qualifier = ""("" + ""|"".join([str(q) for q in qualifier]) + "")""\n    \n    if qualifier != """":\n        re_type = re.compile(""""""\n                             %s                               # Variable qualifier\n                             \\s+(?P<type>\\w+)                 # Variable type\n                             \\s+(?P<names>[\\w,\\[\\]\\n =\\.$]+); # Variable name(s)\n                             """""" % qualifier, re.VERBOSE)\n    else:\n        re_type = re.compile(""""""\n                             \\s*(?P<type>\\w+)         # Variable type\n                             \\s+(?P<names>[\\w\\[\\] ]+) # Variable name(s)\n                             """""", re.VERBOSE)\n\n    re_names = re.compile(""""""\n                          (?P<name>\\w+)           # Variable name\n                          \\s*(\\[(?P<size>\\d+)\\])? # Variable size\n                          (\\s*[^,]+)?\n                          """""", re.VERBOSE)\n\n    for match in re.finditer(re_type, code):\n        vtype = match.group(\'type\')\n        names = match.group(\'names\')\n        for match in re.finditer(re_names, names):\n            name = match.group(\'name\')\n            size = match.group(\'size\')\n            if size is None:\n                variables.append((name, vtype))\n            else:\n                size = int(size)\n                if size == 0:\n                    raise RuntimeError(""Size of a variable array cannot be zero"")\n                for i in range(size):\n                    iname = \'%s[%d]\' % (name,i)\n                    variables.append((iname, vtype))\n    return variables\n\ndef get_hooks(code):\n    if not len(code):\n        return []\n\n    hooks = []\n    # re_hooks = re.compile(""""""\\<(?P<hook>\\w+)\n    #                           (\\.(?P<subhook>\\w+))?\n    #                           (\\([^<>]+\\))?\\>"""""", re.VERBOSE )\n    re_hooks = re.compile(""""""\\<(?P<hook>\\w+)\n                              (\\.(?P<subhook>.+))?\n                              (\\([^<>]+\\))?\\>"""""", re.VERBOSE )\n    # re_hooks = re.compile(""\\<(?P<hook>\\w+)\\>"", re.VERBOSE)\n    for match in re.finditer(re_hooks, code):\n        # hooks.append( (match.group(\'hook\'),match.group(\'subhook\')) )\n        hooks.append((match.group(\'hook\'), None))\n        # print match.group(\'hook\')\n        # print match.group(\'subhook\')\n    # print set(hooks)\n    return list(set(hooks))\n\ndef get_args(code):\n    return get_declarations(code, qualifier = """")\n\ndef get_externs(code):\n    return get_declarations(code, qualifier = ""extern"")\n\ndef get_consts(code):\n    return get_declarations(code, qualifier = ""const"")\n\ndef get_uniforms(code):\n    return get_declarations(code, qualifier = ""uniform"")\n\ndef get_attributes(code):\n    return get_declarations(code, qualifier = [""attribute"", ""in""])\n\ndef get_varyings(code):\n    return get_declarations(code, qualifier = ""varying"")\n\ndef get_functions(code):\n    def brace_matcher (n):\n        # From stack overflow: python-how-to-match-nested-parentheses-with-regex\n        # poor man\'s matched brace scanning, gives up\n        # after n+1 levels.  Matches any string with balanced\n        # braces inside; add the outer braces yourself if needed.\n        # Nongreedy.\n        return r""[^{}]*?(?:{""*n+r""[^{}]*?""+r""}[^{}]*?)*?""*n\n\n    functions = []\n    regex = re.compile(""""""\n                       \\s*(?P<type>\\w+)    # Function return type\n                       \\s+(?P<name>[\\w]+)   # Function name\n                       \\s*\\((?P<args>.*?)\\) # Function arguments\n                       \\s*\\{(?P<code>%s)\\} # Function content\n                       """""" % brace_matcher(5), re.VERBOSE | re.DOTALL)\n\n    for match in re.finditer(regex, code):\n        rtype = match.group(\'type\')\n        name = match.group(\'name\')\n        args = match.group(\'args\')\n        fcode = match.group(\'code\')\n        if name not in (""if"", ""while""):\n            functions.append( (rtype, name, args, fcode) )\n    return functions\n\n\ndef parse(code):\n    """""" Parse a shader """"""\n\n    code      = preprocess(code)\n    externs   = get_externs(code) if code else []\n    consts    = get_consts(code) if code else []\n    uniforms  = get_uniforms(code) if code else []\n    attributes= get_attributes(code) if code else []\n    varyings  = get_varyings(code) if code else []\n    hooks     = get_hooks(code) if code else []\n    functions = get_functions(code) if code else []\n\n    return { \'externs\'   : externs,\n             \'consts\'    : consts,\n             \'uniforms\'  : uniforms,\n             \'attributes\': attributes,\n             \'varyings\'  : varyings,\n             \'hooks\'     : hooks,\n             \'functions\' : functions }\n\n\n# -----------------------------------------------------------------------------\nif __name__ == \'__main__\':\n    code = """"""\n    #version 120\n\n    #include ""colormaps/colormaps.glsl""\n\n    extern float extern_a[2] /* comment */,\n                 extern_b,   /* comment */\n                 extern_c    /* comment */;\n\n    const float const_a = <hook_1>;\n    const float const_b = 2.0, const_c = 3.0;\n\n    uniform float uniform_a;\n    uniform float uniform_b;\n    uniform float uniform_c[2];\n    uniform float <hook_2>;\n\n    attribute float attribute_a[2] , attribute_b , attribute_c;\n\n    varying float varying_a[2];\n    varying vec4 varying_b;\n    varying mat4 varying_c;\n\n    <hook_3>;\n    <hook_4(args)>;\n    <hook_5.subhook>;\n    <hook_6.subhook(args)>;\n\n    void\n    function_a(int a, int b, int c)\n    {\n        float a = 1;\n    }\n\n    void function_b(int a, int b, int c) {}\n    """"""\n\n\n    code = preprocess(code)\n    print(get_hooks(code))\n\n\n    # for key in p.keys():\n    #     print key\n    #     if key not in[""functions"", ""hooks""]:\n    #         for (name,vtype) in p[key]:\n    #             print "" - %s (%s)""%  (name,vtype)\n    #         print\n    #     elif key == ""hooks"":\n    #         for name in p[key]:\n    #             print "" - %s "" % name\n    #         print\n    #     else:\n    #         for (rtype,name,args,func) in p[key]:\n    #             print "" - %s %s (%s) { ... }""%  (rtype, name, args)\n    #         print\n'"
glumpy/gloo/program.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\nimport numpy as np\n\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy import library\nfrom . snippet import Snippet\nfrom . globject import GLObject\nfrom . array import VertexArray\nfrom . buffer import VertexBuffer, IndexBuffer\nfrom . shader import VertexShader, FragmentShader, GeometryShader\nfrom . variable import gl_typeinfo, Uniform, Attribute\n\n\n\n# ----------------------------------------------------------- Program class ---\nclass Program(GLObject):\n    """"""\n    A Program is an object to which shaders can be attached and linked to create\n    a shader program.\n\n    :param str|None vertex:\n      Vertex shader object (as code or filename)\n    :param str|None fragment:\n      Fragment shader object (as code or filename)\n    :param str|None geometry:\n      Geometry shader object (as code or filename)\n    :param int count:\n      Optional. Number of vertices this program will use. This can be\n      specified to initialize a VertexBuffer during program initialization.\n    :param str version:\n      GLSL version to use\n    .. warning::\n\n       If a shader is given as a string and contains a ``{``, glumpy considers\n       the string to be actual code. Else, glumpy will try to locate the file\n       in the library (``glumpy/library``).\n\n    The actual compilation of a program is a complex operation since include\n    msut be resolved and hooks must be inserted at the proper place.\n    """"""\n\n    # ---------------------------------\n    def __init__(self, vertex=None, fragment=None, geometry=None, count=0, version=""120""):\n        """"""\n        Initialize the program and optionnaly buffer.\n        """"""\n\n        GLObject.__init__(self)\n        self._count = count\n        self._buffer = None\n        self._vertex =  None\n        self._fragment = None\n        self._geometry = None\n        self._version = version\n        \n        if vertex is not None:\n            if isinstance(vertex, str):\n                if not \'{\' in vertex:\n                    vertex = library.get(vertex)\n                self._vertex = VertexShader(vertex, version=version)\n            elif isinstance(vertex,VertexShader):\n                self._vertex = vertex\n                self._vertex._version = version\n            else:\n                log.error(""vertex must be a string or a VertexShader"")\n\n        if fragment is not None:\n            if isinstance(fragment, str):\n                if not \'{\' in fragment:\n                    fragment = library.get(fragment)\n                self._fragment = FragmentShader(fragment, version=version)\n            elif isinstance(fragment, FragmentShader):\n                self._fragment = fragment\n                self._fragment._version = version\n            else:\n                log.error(""fragment must be a string or a FragmentShader"")\n\n        if geometry is not None:\n            if isinstance(geometry, str):\n                if not \'{\' in geometry:\n                    geometry = library.get(geometry)\n                self._geometry = GeometryShader(geometry, version=version)\n            elif isinstance(geometry, GeometryShader):\n                self._geometry = geometry\n                self._geometry._version = version\n            else:\n                log.error(""geometry must be a string or a GeometryShader"")\n                \n\n        self._uniforms = {}\n        self._attributes = {}\n\n        # Build hooks, uniforms and attributes\n        self._build_hooks()\n        self._build_uniforms()\n        self._build_attributes()\n\n        # Build associated structured vertex buffer if count is given\n        if self._count > 0:\n            dtype = []\n            for attribute in self._attributes.values():\n                dtype.append(attribute.dtype)\n            self._buffer = np.zeros(self._count, dtype=dtype).view(VertexBuffer)\n            self.bind(self._buffer)\n\n\n    def __len__(self):\n        if self._buffer is not None:\n            return len(self._buffer)\n        else:\n            return None\n\n\n    @property\n    def vertex(self):\n        """""" Vertex shader object """"""\n        return self._vertex\n\n\n    @property\n    def fragment(self):\n        """""" Fragment shader object """"""\n        return self._fragment\n\n    \n    @property\n    def geometry(self):\n        """""" Geometry shader object """"""\n        return self._geometry\n\n\n    @property\n    def hooks(self):\n        """"""\n        Hook names collected from vertex, fragment and geometry shaders.\n\n\n        Hooks are placeholder in a shader source code where shader snippet can\n        be inserted.\n\n        Example:\n\n        .. code:: C\n\n           attribute vec3 position;\n           void main () {\n               gl_Position = <transform>(position); # ""transform"" is a hook\n           }\n        """"""\n\n        return tuple(self._vert_hooks.keys()) + \\\n               tuple(self._frag_hooks.keys()) + \\\n               tuple(self._geom_hooks.keys())\n\n\n    def _setup(self):\n        """""" Setup the program by resolving all pending hooks. """"""\n        pass\n\n\n    def _create(self):\n        """"""\n        Build (link) the program and checks everything\'s ok.\n\n        A GL context must be available to be able to build (link)\n        """"""\n\n        log.debug(""GPU: Creating program"")\n\n        # Check if program has been created\n        if self._handle <= 0:\n            self._handle = gl.glCreateProgram()\n            if not self._handle:\n                raise ValueError(""Cannot create program object"")\n\n        self._build_shaders(self._handle)\n\n        log.debug(""GPU: Linking program"")\n\n        # Link the program\n        gl.glLinkProgram(self._handle)\n        if not gl.glGetProgramiv(self._handle, gl.GL_LINK_STATUS):\n            print(gl.glGetProgramInfoLog(self._handle))\n            raise ValueError(\'Linking error\')\n\n        # Activate uniforms\n        active_uniforms = [name for (name,gtype) in self.active_uniforms]\n        for uniform in self._uniforms.values():\n            if uniform.name in active_uniforms:\n                uniform.active = True\n            else:\n                uniform.active = False\n\n        # Activate attributes\n        active_attributes = [name for (name,gtype) in self.active_attributes]\n        for attribute in self._attributes.values():\n            if attribute.name in active_attributes:\n                attribute.active = True\n            else:\n                attribute.active = False\n\n\n    def _build_shaders(self, program):\n        """""" Build and attach shaders """"""\n\n        # Check if we have at least something to attach\n        if not self._vertex:\n            raise ValueError(""No vertex shader has been given"")\n        if not self._fragment:\n            raise ValueError(""No fragment shader has been given"")\n\n        log.debug(""GPU: Attaching shaders to program"")\n\n        # Attach shaders\n        attached = gl.glGetAttachedShaders(program)\n        shaders = [self._vertex, self._fragment]\n        if self._geometry is not None:\n            shaders.append(self._geometry)\n\n        for shader in shaders:\n            if shader.need_update:\n                if shader.handle in attached:\n                    gl.glDetachShader(program, shader.handle)\n                shader.activate()\n                if isinstance(shader, GeometryShader):\n                    if shader.vertices_out is not None:\n                        gl.glProgramParameteriEXT(self._handle,\n                                                  gl.GL_GEOMETRY_VERTICES_OUT_EXT,\n                                                  shader.vertices_out)\n                    if shader.input_type is not None:\n                        gl.glProgramParameteriEXT(self._handle,\n                                                  gl.GL_GEOMETRY_INPUT_TYPE_EXT,\n                                                  shader.input_type)\n                    if shader.output_type is not None:\n                        gl.glProgramParameteriEXT(self._handle,\n                                                  gl.GL_GEOMETRY_OUTPUT_TYPE_EXT,\n                                                  shader.output_type)\n                gl.glAttachShader(program, shader.handle)\n                shader._program = self\n\n\n    def _build_hooks(self):\n        """""" Build hooks """"""\n\n        self._vert_hooks = {}\n        self._frag_hooks = {}\n        self._geom_hooks = {}\n\n        if self._vertex is not None:\n            for (hook,subhook) in self._vertex.hooks:\n                self._vert_hooks[hook] = None\n        if self._fragment is not None:\n            for (hook,subhook) in self._fragment.hooks:\n                self._frag_hooks[hook] = None\n        if self._geometry is not None:\n            for (hook,subhook) in self._geometry.hooks:\n                self._geom_hooks[hook] = None\n\n\n\n    def _build_uniforms(self):\n        """""" Build the uniform objects """"""\n\n        # We might rebuild the program because of snippets but we must\n        # keep already bound uniforms\n\n        count = 0\n        for (name,gtype) in self.all_uniforms:\n            if name not in self._uniforms.keys():\n                uniform = Uniform(self, name, gtype)\n            else:\n                uniform = self._uniforms[name]\n            gtype = uniform.gtype\n            if gtype in (gl.GL_SAMPLER_1D, gl.GL_SAMPLER_2D, gl.GL_SAMPLER_CUBE):\n                uniform._texture_unit = count\n                count += 1\n            self._uniforms[name] = uniform\n        self._need_update = True\n\n\n    def _build_attributes(self):\n        """""" Build the attribute objects """"""\n\n        # We might rebuild the program because of snippets but we must\n        # keep already bound attributes\n\n        dtype = []\n        for (name,gtype) in self.all_attributes:\n            if name not in self._attributes.keys():\n                attribute = Attribute(self, name, gtype)\n            else:\n                attribute = self._attributes[name]\n\n            self._attributes[name] = attribute\n            dtype.append(attribute.dtype)\n\n\n    def bind(self, data):\n        """"""\n        Bind a vertex buffer to the program, matching buffer record names with\n        program attributes.\n\n        Several buffers can be bound but the size of the different buffers must\n        match.\n        """"""\n\n        if isinstance(data, (VertexBuffer,VertexArray)):\n            for name in data.dtype.names:\n                if name in self._attributes.keys():\n                    self._attributes[name].set_data(data.ravel()[name])\n\n\n\n    def __setitem__(self, name, data):\n\n        vhooks = self._vert_hooks.keys()\n        fhooks = self._frag_hooks.keys()\n\n        if name in tuple(vhooks) + tuple(fhooks):\n            snippet = data\n\n            if name in vhooks:\n                self._vertex[name] = snippet\n                self._vert_hooks[name] = snippet\n            if name in fhooks:\n                self._fragment[name] = snippet\n                self._frag_hooks[name] = snippet\n\n            if isinstance(data, Snippet):\n                snippet.attach(self)\n\n            self._build_uniforms()\n            self._build_attributes()\n            self._need_update = True\n\n        # if name in self._hooks.keys():\n        #     shader, snippet = self._hooks[name]\n        #     snippet = data\n        #     shader[name] = snippet\n        #     self._hooks[name] = shader, snippet\n        #     if isinstance(data, Snippet):\n        #         snippet.attach(self)\n        #     self._build_uniforms()\n        #     self._build_attributes()\n        #     self._need_update = True\n\n        elif name in self._uniforms.keys():\n            self._uniforms[name].set_data(data)\n        elif name in self._attributes.keys():\n            self._attributes[name].set_data(data)\n        else:\n            raise IndexError(""Unknown item (no corresponding hook, uniform or attribute)"")\n\n\n    def __getitem__(self, name):\n        if name in self._vert_hooks.keys():\n            return self._vert_hooks[name]\n        elif name in self._frag_hooks.keys():\n            return self._frag_hooks[name]\n#        if name in self._hooks.keys():\n#            return self._hooks[name][1]\n        elif name in self._uniforms.keys():\n            return self._uniforms[name].data\n        elif name in self._attributes.keys():\n            return self._attributes[name].data\n        else:\n            raise IndexError(""Unknown item (no corresponding hook, uniform or attribute)"")\n\n    # def keys(self):\n    #     """""" Uniforme and attribute names """"""\n\n    #     return self._uniforms.keys() + self._attributes.keys()\n\n\n    def _activate(self):\n        """"""Activate the program as part of current rendering state.""""""\n\n        log.debug(""GPU: Activating program (id=%d)"" % self._id)\n        gl.glUseProgram(self.handle)\n\n        for uniform in self._uniforms.values():\n            if uniform.active:\n                uniform.activate()\n\n        # Need fix when dealing with vertex arrays (only need to active the array)\n        for attribute in self._attributes.values():\n            if attribute.active:\n                attribute.activate()\n\n\n    def _deactivate(self):\n        """"""Deactivate the program.""""""\n\n        gl.glUseProgram(0)\n\n        for uniform in self._uniforms.values():\n            uniform.deactivate()\n\n        # Need fix when dealing with vertex arrays (only need to active the array)\n        for attribute in self._attributes.values():\n            attribute.deactivate()\n        log.debug(""GPU: Deactivating program (id=%d)"" % self._id)\n\n\n    @property\n    def all_uniforms(self):\n        """"""\n        List of all uniform parsed from shaders source (read only).\n        """"""\n\n        uniforms = []\n        shaders = [self._vertex, self._fragment]\n        if self._geometry is not None:\n            shaders.append(self._geometry)\n\n        for shader in shaders:\n            uniforms.extend(shader.uniforms)\n        uniforms = list(set(uniforms))\n        return uniforms\n\n\n    @property\n    def active_uniforms(self):\n        """"""\n        List of active uniform requested from GPU (read only).\n\n        .. note:: \n\n           An inactive uniform is a uniform that has been declared but that is\n           not actually used in the shader.\n\n           Example:\n\n           .. code::\n\n              uniform vec3 color;     # Inactive\n              void main() {\n                  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n              }\n        """"""\n\n        count = gl.glGetProgramiv(self.handle, gl.GL_ACTIVE_UNIFORMS)\n\n        # This match a name of the form ""name[size]"" (= array)\n        regex = re.compile(""""""(?P<name>\\w+)\\s*(\\[(?P<size>\\d+)\\])\\s*"""""")\n        uniforms = []\n        for i in range(count):\n            name, size, gtype = gl.glGetActiveUniform(self.handle, i)\n            name = name.decode()\n            # This checks if the uniform is an array\n            # Name will be something like xxx[0] instead of xxx\n            m = regex.match(name)\n            # When uniform is an array, size corresponds to the highest used index\n            if m:\n                name = m.group(\'name\')\n                if size >= 1:\n                    for i in range(size):\n                        name = \'%s[%d]\' % (m.group(\'name\'),i)\n                        uniforms.append((name, gtype))\n            else:\n                uniforms.append((name, gtype))\n\n        return uniforms\n\n\n    @property\n    def inactive_uniforms(self):\n        """"""\n        List of inactive uniforms requested from GPU (read only).\n\n        .. note:: \n\n           An inactive uniform is a uniform that has been declared but that is\n           not actually used in the shader.\n\n           Example:\n\n           .. code::\n\n              uniform vec3 color;     # Inactive\n              void main() {\n                  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n              }\n        """"""\n\n        active_uniforms = self.active_uniforms\n        inactive_uniforms = self.all_uniforms\n        for uniform in active_uniforms:\n            if uniform in inactive_uniforms:\n                inactive_uniforms.remove(uniform)\n        return inactive_uniforms\n\n    @property\n    def all_attributes(self):\n        """"""\n        List of all attributes parsed from shaders source (read only).\n        """"""\n\n        attributes= []\n        attributes.extend(self._vertex.attributes)\n        attributes = list(set(attributes))\n        return attributes\n\n\n    @property\n    def active_attributes(self):\n        """"""\n        List of active attributes requested from GPU (read only).\n\n        .. note:: \n\n           An inactive attribute is an attribute that has been declared\n           but that is not actually used in the shader.\n\n           Example:\n\n           .. code::\n\n              attribute vec3 normal;    # Inactive\n              attribute vec3 position;  # Active\n              void main() {\n                  gl_Position = vec4(position, 1.0);\n              }\n        """"""\n\n        count = gl.glGetProgramiv(self.handle, gl.GL_ACTIVE_ATTRIBUTES)\n        attributes = []\n\n        # This match a name of the form ""name[size]"" (= array)\n        regex = re.compile(""""""(?P<name>\\w+)\\s*(\\[(?P<size>\\d+)\\])"""""")\n\n        for i in range(count):\n            name, size, gtype = gl.glGetActiveAttrib(self.handle, i)\n            name = name.decode()\n\n            # This checks if the attribute is an array\n            # Name will be something like xxx[0] instead of xxx\n            m = regex.match(name)\n            # When attribute is an array, size corresponds to the highest used index\n            if m:\n                name = m.group(\'name\')\n                if size >= 1:\n                    for i in range(size):\n                        name = \'%s[%d]\' % (m.group(\'name\'),i)\n                        attributes.append((name, gtype))\n            else:\n                attributes.append((name, gtype))\n\n        return attributes\n\n\n    @property\n    def inactive_attributes(self):\n        """"""\n        List of inactive attributes requested from GPU (read only).\n\n        .. note:: \n\n           An inactive attribute is an attribute that has been declared\n           but that is not actually used in the shader.\n\n           Example:\n\n           .. code::\n\n              attribute vec3 normal;    # Inactive\n              attribute vec3 position;  # Active\n              void main() {\n                  gl_Position = vec4(position, 1.0);\n              }\n        """"""\n\n        active_attributes = self.active_attributes\n        inactive_attributes = self.all_attributes\n        for attribute in active_attributes:\n            if attribute in inactive_attributes:\n                inactive_attributes.remove(attribute)\n        return inactive_attributes\n\n\n    def draw(self, mode = gl.GL_TRIANGLES, indices=None): #first=0, count=None):\n        """""" Draw using the specified mode & indices.\n\n        :param gl.GLEnum mode: \n          One of\n            * GL_POINTS\n            * GL_LINES\n            * GL_LINE_STRIP\n            * GL_LINE_LOOP,\n            * GL_TRIANGLES\n            * GL_TRIANGLE_STRIP\n            * GL_TRIANGLE_FAN\n\n        :param IndexBuffer|None indices:\n            Vertex indices to be drawn. If none given, everything is drawn.\n        """"""\n\n        self.activate()\n        attributes = self._attributes.values()\n\n        # Get buffer size first attribute\n        # We need more tests here\n        #  - do we have at least 1 attribute ?\n        #  - does all attributes report same count ?\n        # count = (count or attributes[0].size) - first\n\n        if isinstance(indices, IndexBuffer):\n            indices.activate()\n            gltypes = { np.dtype(np.uint8) : gl.GL_UNSIGNED_BYTE,\n                        np.dtype(np.uint16): gl.GL_UNSIGNED_SHORT,\n                        np.dtype(np.uint32): gl.GL_UNSIGNED_INT }\n            gl.glDrawElements(mode, indices.size, gltypes[indices.dtype], None)\n            indices.deactivate()\n        else:\n            first = 0\n            # count = (self._count or attributes[0].size) - first\n            count = len(tuple(attributes)[0])\n            gl.glDrawArrays(mode, first, count)\n\n        gl.glBindBuffer( gl.GL_ARRAY_BUFFER, 0 )\n        self.deactivate()\n'"
glumpy/gloo/shader.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nA Shader is a user-defined program designed to run on some stage of a\ngraphics processor. Its purpose is to execute one of the programmable stages of\nthe rendering pipeline.\n\nRead more on shaders on `OpenGL Wiki <https://www.opengl.org/wiki/Shader>`_\n\n**Example usage**\n\n  .. code:: python\n\n     vertex = \'\'\'\n         attribute vec2 position;\n         void main (void)\n         {\n             gl_Position = vec4(0.85*position, 0.0, 1.0);\n         } \'\'\'\n     fragment = \'\'\'\n         void main(void)\n         {\n             gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n         } \'\'\'\n\n     quad = gloo.Program(vertex, fragment, count=4)\n     quad[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\n""""""\nimport re\nimport os.path\nimport numpy as np\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom . snippet import Snippet\nfrom . globject import GLObject\nfrom . parser import (remove_comments, preprocess,\n                      get_uniforms, get_attributes, get_hooks)\n\n\n\n# ------------------------------------------------------------ Shader class ---\nclass Shader(GLObject):\n    """"""\n    Abstract shader class.\n\n    :param gl.GLEnum target:\n\n       * gl.GL_VERTEX_SHADER\n       * gl.GL_FRAGMENT_SHADER\n       * gl.GL_GEOMETRY_SHADER\n\n    :param str code: Shader code or a filename containing shader code\n\n    .. note::\n    \n       If the shader code is actually a filename, the filename must be prefixed\n       with ``file:``. Note that you can also get shader code from the library\n       module.\n    """"""\n\n    _gtypes = {\n        \'float\':       gl.GL_FLOAT,\n        \'vec2\':        gl.GL_FLOAT_VEC2,\n        \'vec3\':        gl.GL_FLOAT_VEC3,\n        \'vec4\':        gl.GL_FLOAT_VEC4,\n        \'int\':         gl.GL_INT,\n        \'ivec2\':       gl.GL_INT_VEC2,\n        \'ivec3\':       gl.GL_INT_VEC3,\n        \'ivec4\':       gl.GL_INT_VEC4,\n        \'bool\':        gl.GL_BOOL,\n        \'bvec2\':       gl.GL_BOOL_VEC2,\n        \'bvec3\':       gl.GL_BOOL_VEC3,\n        \'bvec4\':       gl.GL_BOOL_VEC4,\n        \'mat2\':        gl.GL_FLOAT_MAT2,\n        \'mat3\':        gl.GL_FLOAT_MAT3,\n        \'mat4\':        gl.GL_FLOAT_MAT4,\n        \'sampler1D\':   gl.GL_SAMPLER_1D,\n        \'sampler2D\':   gl.GL_SAMPLER_2D,\n        \'samplerCube\': gl.GL_SAMPLER_CUBE,\n    }\n\n\n    def __init__(self, target, code, version=""120""):\n        """"""\n        Initialize the shader.\n        """"""\n\n        GLObject.__init__(self)\n        self._target = target\n        self._snippets = {}\n        self._version = version\n\n        if os.path.isfile(code):\n            with open(code, \'rt\') as file:\n                self._code = preprocess(file.read())\n                self._source = os.path.basename(code)\n        else:\n            self._code = preprocess(code)\n            self._source = \'<string>\'\n\n        self._hooked = self._code\n        self._need_update = True\n        self._program = None\n\n\n    def __setitem__(self, name, snippet):\n        """"""\n        Set a snippet on the given hook in the source code.\n        """"""\n\n        self._snippets[name] = snippet\n\n\n    def _replace_hooks(self, name, snippet):\n\n        #re_hook = r""(?P<hook>%s)(\\.(?P<subhook>\\w+))?"" % name\n        re_hook = r""(?P<hook>%s)(\\.(?P<subhook>[\\.\\w\\!]+))?"" % name\n        re_args = r""(\\((?P<args>[^<>]+)\\))?""\n        re_hooks = re.compile(""\\<""+re_hook+re_args+""\\>"" , re.VERBOSE )\n        pattern = ""\\<"" + re_hook + re_args + ""\\>""\n\n        # snippet is not a Snippet (it should be a string)\n        if not isinstance(snippet,Snippet):\n            def replace(match):\n                hook = match.group(\'hook\')\n                subhook = match.group(\'subhook\')\n                if subhook:\n                    return snippet + \'.\' + subhook\n                return snippet\n            self._hooked = re.sub(pattern, replace, self._hooked)\n            return\n\n        # Store snippet code for later inclusion\n        # self._snippets.append(snippet)\n\n        # Replace expression of type <hook.subhook(args)>\n        def replace_with_args(match):\n            hook = match.group(\'hook\')\n            subhook = match.group(\'subhook\')\n            args = match.group(\'args\')\n\n            if subhook and \'.\' in subhook:\n                s = snippet\n                for item in subhook.split(\'.\')[:-1]:\n                    if isinstance(s[item], Snippet):\n                        s = s[item]\n                subhook = subhook.split(\'.\')[-1]\n\n                # If the last snippet name endswith ""!"" this means to call\n                # the snippet with given arguments and not the ones stored.\n                # If S = A(B(C))(""t""):\n                #   <S>     -> A(B(C(""t"")))\n                #   <S!>(t) -> A(""t"")\n                override = False\n                if subhook[-1] == ""!"":\n                    override = True\n                    subhook = subhook[:-1]\n\n                # Do we have a class alias ? We don\'t return it yet since we\n                # need its translation from the symbol table\n                if subhook in s.aliases.keys():\n                    subhook = s.aliases[subhook]\n                # If subhook is a variable (uniform/attribute/varying)\n                if subhook in s.globals:\n                    return s.globals[subhook]\n                return s.mangled_call(subhook, match.group(""args""), override=override)\n\n            # If subhook is a variable (uniform/attribute/varying)\n            if subhook in snippet.globals:\n                return snippet.globals[subhook]\n            return snippet.mangled_call(subhook, match.group(""args""))\n\n\n        self._hooked = re.sub(pattern, replace_with_args, self._hooked)\n\n\n    def reset(self):\n        """""" Reset shader snippets """"""\n\n        self._snippets = {}\n\n\n    @property\n    def code(self):\n        """""" Shader source code (built from original and snippet codes) """"""\n\n        # Last minute hook settings\n        self._hooked = self._code\n        for name,snippet in self._snippets.items():\n            self._replace_hooks(name,snippet)\n\n        snippet_code = ""// --- Snippets code : start --- //\\n""\n        deps = []\n        for snippet in self._snippets.values():\n            if isinstance(snippet, Snippet):\n                deps.extend(snippet.dependencies)\n        for snippet in list(set(deps)):\n            snippet_code += snippet.mangled_code()\n        snippet_code += ""// --- Snippets code : end --- //\\n""\n        return snippet_code + self._hooked\n\n\n\n    def _create(self):\n        """""" Create the shader """"""\n\n        log.debug(""GPU: Creating shader"")\n\n        # Check if we have something to compile\n        if not self.code:\n            raise RuntimeError(""No code has been given"")\n\n        # Check that shader object has been created\n        if self._handle <= 0:\n            self._handle = gl.glCreateShader(self._target)\n            if self._handle <= 0:\n                raise RuntimeError(""Cannot create shader object"")\n\n\n    def _update(self):\n        """""" Compile the source and checks everything\'s ok """"""\n\n        log.debug(""GPU: Compiling shader"")\n\n        if len(self.hooks):\n            hooks = [name for name,snippet in self.hooks]\n            error = ""Shader has pending hooks (%s), cannot compile"" % hooks\n            raise RuntimeError(error)\n\n        # Set shader version\n        code = (""#version %s\\n"" % self._version) + self.code\n        gl.glShaderSource(self._handle, code)\n\n        # Actual compilation\n        gl.glCompileShader(self._handle)\n        status = gl.glGetShaderiv(self._handle, gl.GL_COMPILE_STATUS)\n        if not status:\n            error = gl.glGetShaderInfoLog(self._handle).decode()\n            parsed_errors = self._parse_error(error)\n            for lineno, mesg in parsed_errors:\n                self._print_error(mesg, lineno - 1)\n            raise RuntimeError(""Shader compilation error"")\n\n    def _delete(self):\n        """""" Delete shader from GPU memory (if it was present). """"""\n\n        gl.glDeleteShader(self._handle)\n\n    _ERROR_RE = [\n        # Nvidia\n        # 0(7): error C1008: undefined variable ""MV""\n        # 0(2) : error C0118: macros prefixed with \'__\' are reserved\n        re.compile(r\'^\\s*(\\d+)\\((?P<line_no>\\d+)\\)\\s*:\\s(?P<error_msg>.*)\', re.MULTILINE),\n        # ATI / Intel\n        # ERROR: 0:131: \'{\' : syntax error parse error\n        re.compile(r\'^\\s*ERROR:\\s(\\d+):(?P<line_no>\\d+):\\s(?P<error_msg>.*)\', re.MULTILINE),\n        # Nouveau\n        # 0:28(16): error: syntax error, unexpected \')\', expecting \'(\'\n        re.compile(r\'^\\s*(\\d+):(?P<line_no>\\d+)\\((\\d+)\\):\\s(?P<error_msg>.*)\', re.MULTILINE)\n    ]\n\n    def _parse_error(self, error):\n        """"""\n        Parses a single GLSL error and extracts the line number and error\n        description.\n\n        Parameters\n        ----------\n        error : str\n            An error string as returned by the compilation process\n        """"""\n        for error_re in self._ERROR_RE:\n            matches = list(error_re.finditer(error))\n            if matches:\n                errors = [(int(m.group(\'line_no\')), m.group(\'error_msg\')) for m in matches]\n                return sorted(errors, key=lambda elem: elem[0])\n        else:\n            raise ValueError(\'Unknown GLSL error format:\\n{}\\n\'.format(error))\n\n\n    def _print_error(self, error, lineno):\n        """"""\n        Print error and show the faulty line + some context\n\n        Parameters\n        ----------\n        error : str\n            An error string as returned byt the compilation process\n\n        lineno: int\n            Line where error occurs\n        """"""\n        lines = self.code.split(\'\\n\')\n        start = max(0,lineno-3)\n        end = min(len(lines),lineno+3)\n\n        print(\'Error in %s\' % (repr(self)))\n        print(\' -> %s\' % error)\n        print()\n        if start > 0:\n            print(\' ...\')\n        for i, line in enumerate(lines[start:end]):\n            if (i+start) == lineno:\n                print(\' %03d %s\' % (i+start, line))\n            else:\n                if len(line):\n                    print(\' %03d %s\' % (i+start,line))\n        if end < len(lines):\n            print(\' ...\')\n        print()\n\n\n    @property\n    def hooks(self):\n        """""" Shader hooks (place where snippets can be inserted) """"""\n\n        # We get hooks from the original code, not the hooked one\n        code = remove_comments(self._hooked)\n        return get_hooks(code)\n\n\n    @property\n    def uniforms(self):\n        """""" Shader uniforms obtained from source code """"""\n\n        code = remove_comments(self.code)\n        gtypes = Shader._gtypes\n        return [ (n,gtypes[t]) for (n,t) in get_uniforms(code) ]\n\n\n    @property\n    def attributes(self):\n        """""" Shader attributes obtained from source code """"""\n\n        code = remove_comments(self.code)\n        gtypes = Shader._gtypes\n        return [(n,gtypes[t]) for (n,t) in get_attributes(code)]\n\n\n\n# ------------------------------------------------------ VertexShader class ---\nclass VertexShader(Shader):\n    """""" Vertex shader class """"""\n\n    def __init__(self, code=None, version=""120""):\n        Shader.__init__(self, gl.GL_VERTEX_SHADER, code, version)\n\n    @property\n    def code(self):\n        code = super(VertexShader, self).code\n        code = ""#define _GLUMPY__VERTEX_SHADER__\\n"" + code\n        return code\n\n\n    def __repr__(self):\n        return ""Vertex shader %d (%s)"" % (self._id, self._source)\n\n\n\n\nclass FragmentShader(Shader):\n    """""" Fragment shader class """"""\n\n\n    def __init__(self, code=None, version=""120""):\n        Shader.__init__(self, gl.GL_FRAGMENT_SHADER, code, version)\n\n    @property\n    def code(self):\n        code = super(FragmentShader, self).code\n        code = ""#define _GLUMPY__FRAGMENT_SHADER__\\n"" + code\n        return code\n\n\n    def __repr__(self):\n        return ""Fragment shader %d (%s)"" % (self._id, self._source)\n\n\n\nclass GeometryShader(Shader):\n    """""" Geometry shader class.\n\n        :param str code: Shader code or a filename containing shader code\n        :param int vertices_out: Number of output vertices\n        :param gl.GLEnum input_type:\n\n           * GL_POINTS\n           * GL_LINES\xe2\x80\x8b, GL_LINE_STRIP\xe2\x80\x8b, GL_LINE_LIST\n           * GL_LINES_ADJACENCY\xe2\x80\x8b, GL_LINE_STRIP_ADJACENCY\n           * GL_TRIANGLES\xe2\x80\x8b, GL_TRIANGLE_STRIP\xe2\x80\x8b, GL_TRIANGLE_FAN\n           * GL_TRIANGLES_ADJACENCY\xe2\x80\x8b, GL_TRIANGLE_STRIP_ADJACENCY\n\n        :param gl.GLEnum output_type:\n\n           * GL_POINTS, GL_LINES\xe2\x80\x8b, GL_LINE_STRIP\n           * GL_TRIANGLES\xe2\x80\x8b, GL_TRIANGLE_STRIP\xe2\x80\x8b, GL_TRIANGLE_FAN\n    """"""\n\n\n    def __init__(self, code=None,\n                 vertices_out=None, input_type=None, output_type=None, version=""120""):\n        Shader.__init__(self, gl.GL_GEOMETRY_SHADER_EXT, code, version)\n\n        self._vertices_out = vertices_out\n\n        # GL_POINTS\n        # GL_LINES\xe2\x80\x8b, GL_LINE_STRIP\xe2\x80\x8b, GL_LINE_LIST\n        # GL_LINES_ADJACENCY\xe2\x80\x8b, GL_LINE_STRIP_ADJACENCY\n        # GL_TRIANGLES\xe2\x80\x8b, GL_TRIANGLE_STRIP\xe2\x80\x8b, GL_TRIANGLE_FAN\n        # GL_TRIANGLES_ADJACENCY\xe2\x80\x8b, GL_TRIANGLE_STRIP_ADJACENCY\n        self._input_type = input_type\n\n        # GL_POINTS, GL_LINES\xe2\x80\x8b, GL_LINE_STRIP\n        # GL_TRIANGLES\xe2\x80\x8b, GL_TRIANGLE_STRIP\xe2\x80\x8b, GL_TRIANGLE_FAN\n        self._output_type = output_type\n\n    @property\n    def vertices_out(self):\n        return self._vertices_out\n\n    @vertices_out.setter\n    def vertices_out(self, value):\n        self._vertices_out = value\n\n    @property\n    def input_type(self):\n        """""" """"""\n        return self._input_type\n\n    @input_type.setter\n    def input_type(self, value):\n        self._input_type = value\n\n    @property\n    def output_type(self):\n        return self._output_type\n\n    @output_type.setter\n    def output_type(self, value):\n        self._output_type = value\n\n    def __repr__(self):\n        return ""Geometry shader %d (%s)"" % (self._id, self._source)\n'"
glumpy/gloo/snippet.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\nimport copy\nfrom . import parser\n\n\nclass Snippet(object):\n    """"""\n    A snippet is a piece of GLSL code that can be injected into an another GLSL\n    code. It provides the necessary machinery to take care of name collisions,\n    external variables and snippet composition (call, +, -, /, \\*).\n\n    :param string code: Shader code\n    :param string default: Default function to be called if none is specified.\n    :param list args: Arguments\n    :param dict kwargs: Keyword arguments\n\n    A snippet can declare uniforms, const, attributes and varying using random\n    names. However, these names will be later mangled such as to avoid name\n    collisions with other snippets and/or main code. This means that any\n    snippet variable must be accessed through the snippet (snippet[""variable""])\n    to be able to change its value within the main program.\n\n    Snippet can be composed together through call::\n\n      A = Snippet(code=""..."")\n      B = Snippet(code=""..."")\n      C = A(B(""P""))\n\n    .. warning::\n\n       Calling a snippet does not create a new snippet but instead links it the\n       called snippet to the calling one. In the example above, the ``A._call``\n       is now ``B``.\n\n\n    and arithmetic composition::\n\n      A = Snippet(code=""..."")\n      B = Snippet(code=""..."")\n      C = A(""P"") + B(""P"")\n    """"""\n\n    # Internal id counter for automatic snippets name mangling\n    _id_counter = 1\n\n    # Class aliases\n    aliases = { }\n\n    def __init__(self, code=None, default=None, *args, **kwargs):\n\n        # Original source code\n        self._source_code = parser.merge_includes(code)\n\n        # Variables and functions name parsed from source code\n        self._objects = parser.parse(code)\n\n        # Arguments (other snippets or strings)\n        for arg in args:\n            if isinstance(arg,Snippet) and self in arg.snippets:\n                raise ValueError(""Recursive call is forbidden."")\n        self._args = list(args)\n\n        # No chained snippet yet\n        self._next = None\n\n        # No name\n        self._name = None\n\n        # No default call\n        self._call = None\n\n        # Snippet identification\n        self._id = Snippet._id_counter\n        Snippet._id_counter += 1\n\n        # Process kwargs (name and call)\n        self.process_kwargs(**kwargs)\n\n        # If no name has been given, set a default one\n        if self._name is None:\n            classname = self.__class__.__name__\n            self._name = ""%s_%d"" % (classname, self._id)\n\n        # Symbol table\n        self._symbols = {}\n        for (name,dtype) in self._objects[""attributes""]:\n            self._symbols[name] = ""%s_%d"" % (name,self._id)\n        for (name,dtype) in self._objects[""uniforms""]:\n            self._symbols[name] = ""%s_%d"" % (name,self._id)\n        for (name,dtype) in self._objects[""varyings""]:\n            self._symbols[name] = ""%s_%d"" % (name,self._id)\n        for (name,dtype) in self._objects[""consts""]:\n            self._symbols[name] = ""%s_%d"" % (name,self._id)\n        for (rtype,name,args,code) in self._objects[""functions""]:\n            self._symbols[name] = ""%s_%d"" % (name,self._id)\n\n        # Aliases (through kwargs)\n        for name,alias in kwargs.items():\n            self._symbols[name] = alias\n\n        # Attached programs\n        self._programs = []\n\n\n    def process_kwargs(self, **kwargs):\n        """""" Process kwargs as given in __init__() or __call__() """"""\n\n        if ""name"" in kwargs.keys():\n            self._name = kwargs[""name""]\n            del kwargs[""name""]\n\n        if ""call"" in kwargs.keys():\n            self._call = kwargs[""call""]\n            del kwargs[""call""]\n\n\n    @property\n    def name(self):\n        """""" Name of the snippet """"""\n\n        return self._name\n\n\n    @property\n    def programs(self):\n        """""" Currently attached programs """"""\n\n        return self._programs\n\n\n    @property\n    def objects(self):\n        """"""\n        Objects composing this snippet only.\n\n        Object are uniforms, attributes, consts, varying and functions.\n        """"""\n\n        return self._objects\n\n\n    @property\n    def symbols(self):\n        """"""\n        Symbol table defined as a list of (name, mangled_name).\n        """"""\n\n        return self._symbols\n\n\n    @property\n    def locals(self):\n        """"""\n        Local table of symbols defined from the code of this snippet only, not\n        taking into account symbols from arguments (call) or next (operators).\n        """"""\n\n        symbols = {}\n        objects = self._objects\n        for name,dtype in objects[""uniforms""]+ objects[""attributes""] + objects[""varyings""]:\n            symbols[name] = self.symbols[name]\n        # return self._symbols\n        return symbols\n\n\n    @property\n    def globals(self):\n        """"""\n        Global string symbols generated from all the codes composing this snippet,\n        taking into account symbols from arguments (call) and next (operators).\n        """"""\n\n        """""" Global symbols """"""\n\n        symbols = {}\n        for snippet in self.snippets:\n            symbols.update(snippet.locals)\n        return symbols\n\n\n    @property\n    def args(self):\n        """""" Call arguments """"""\n\n        return list(self._args)\n\n\n    @property\n    def next(self):\n        """""" Next snippet in the arihmetic chain. """"""\n\n        if self._next:\n            return self._next[1]\n        return None\n\n\n    @property\n    def last(self):\n        """"""\n        Get last snippet in the arithmetic chain\n\n        **Example**::\n\n          A,B,C = Snippet(...), Snippet(...), Snippet(...)\n          D = A(B) + C\n          D.last # C\n        """"""\n\n        if self.next:\n            snippet = self.next\n            if isinstance(snippet, Snippet):\n                return snippet.last\n        return self\n\n\n    @property\n    def snippets(self):\n        """""" \n        Get all snippets composing this snippet (including self).\n\n        **Example**::\n\n          A,B,C = Snippet(...), Snippet(...), Snippet(...)\n          D = A(B) + C\n          D.snippets # [A,B,C]\n        """"""\n\n        all = [self,]\n        for snippet in self._args:\n            if isinstance(snippet, Snippet):\n                all.extend(snippet.snippets)\n        if self.next:\n            operand, snippet = self._next\n            if isinstance(snippet, Snippet):\n                all.extend(snippet.snippets)\n        return all\n\n\n    @property\n    def is_attached(self):\n        """""" \n        Whether snippet is attached to one or several programs.\n        """"""\n        return len(self._programs) > 0\n\n\n    def lookup(self, name, deepsearch=True):\n        """"""\n        Search for a specific symbol.\n\n        :param str name: Name to be search in symbols \n        :param bool deepsearch: Whether to restrict search to self (False)\n                                or to search into all snippets (True)\n        """"""\n\n        if deepsearch:\n            for snippet in self.snippets:\n                symbols = snippet._symbols\n                if name in symbols.keys():\n                    return symbols[name]\n            return None\n\n        return self.symbols.get(name,None)\n\n\n    def attach(self, program):\n        """"""\n        Attach this snippet to a program\n\n        .. note::\n        \n           Attachment is recursive and will attach all the snippets composing\n           self.\n        """"""\n\n        \n        if program not in self._programs:\n            self._programs.append(program)\n\n        for snippet in self.snippets[1:]:\n            if isinstance(snippet, Snippet):\n                snippet.attach(program)\n\n        # WARN: Do we need to build hooks ?\n        # program._build_hooks()\n        program._build_uniforms()\n        program._build_attributes()\n\n\n    def detach(self, program):\n        """"""\n        Detach this snippet from a program\n\n        :param Program program: Program to detach this snippet from\n\n        .. note::\n        \n           Detachment is recursive and will detach all the snippets composing\n           self.\n        """"""\n\n        if program in self._programs:\n            index = self._programs.indexof(program)\n            del self._programs[index]\n        for snippet in list(self._args) + [self.next]:\n            if isinstance(snippet, Snippet):\n                snippet.detach(program)\n\n\n    @property\n    def dependencies(self):\n        """"""\n        Compute all snippet dependencies.\n\n        **Example**::\n        \n          A,B,C,D = Snippet(...), Snippet(...), Snippet(...), Snippet(...)\n          AB = A(B)\n          CD = C(D)\n          S = AB+CD\n          S.dependencies # [A,B,C,D]\n        """"""\n\n        deps = [self]\n        for snippet in self._args:\n            if isinstance(snippet, Snippet):\n                deps.extend(snippet.dependencies)\n        if self.next:\n            operand, snippet = self._next\n            if isinstance(snippet, Snippet):\n                deps.extend(snippet.dependencies)\n\n        return list(set(deps))\n\n\n    @property\n    def code(self):\n        """""" Mangled code """"""\n\n        code = """"\n        for snippet in self.dependencies:\n            code += snippet.mangled_code()\n        return code\n\n\n    def mangled_code(self):\n        """""" Generate mangled code """"""\n\n        code = self._source_code\n        objects = self._objects\n        functions = objects[""functions""]\n        names = objects[""uniforms""] + objects[""attributes""] + objects[""varyings""]\n        for _,name,_,_ in functions:\n            symbol = self.symbols[name]\n            code = re.sub(r""(?<=[^\\w])(%s)(?=\\()"" % name, symbol, code)\n        for name, _ in names:\n            # Variable starting ""__"" are protected and unaliased\n            #if not name.startswith(""__""):\n            symbol = self.symbols[name]\n            code = re.sub(r""(?<=[^\\w])(%s)(?=[^\\w])"" % name, symbol, code)\n        return code\n\n\n    @property\n    def call(self):\n        """""" Computes and returns the GLSL code that correspond to the call """"""\n        self.mangled_code()\n        return self.mangled_call()\n\n\n    def mangled_call(self, function=None, arguments=None, override=False):\n        """"""\n        Compute tGLSL code that corresponds to the actual call of the snippet\n\n        :param string function: Snippet\'s function to be called\n        :param list arguments: Arguments to give to the function call\n        :param bool override: Whether to override python arguments\n                              with shader arguments\n        """"""\n\n        s = """"\n\n        # Is there a function defined in the snippet ?\n        # (It may happen a snippet only has uniforms, like the Viewport snippet)\n        # WARN: what about Viewport(Transform) ?\n        if len(self._objects[""functions""]):\n\n            # Is there a function specified in the shader source ?\n            # Such as <transform.forward>\n            if function:\n                name = function\n\n            # Has a function be specified when building the snippet ?\n            # Snippet(..., call=""some_function"")\n            elif self._call is not None:\n                name = self._call\n            else:\n                _,name,_,_ = self._objects[""functions""][0]\n\n            s = self.lookup(name, deepsearch=False) or name\n\n            if len(self._args) and override is False:\n                s += ""(""\n                for i,arg in enumerate(self._args):\n                    if isinstance(arg,Snippet):\n                        # We do not propagate given function to to other snippets\n                        # s += arg.mangled_call(function,arguments)\n                        s += arg.mangled_call(None,arguments)\n                    else:\n                        #  This handle call of the form: transform(\'.x\')\n                        if arguments is not None and arg.startswith(\'.\'):\n                            s += arguments\n                        s += str(arg)\n\n                    if i < (len(self._args)-1):\n                        s += "", ""\n                s += "")""\n            else:\n                # If an argument has been given, we put it at the end\n                # This handles hooks of the form <transform(args)>\n                if arguments is not None:\n                    s += ""(%s)"" % arguments\n                else:\n                    s += ""()""\n            if self.next:\n                operand, other = self._next\n                if operand in ""+-/*"":\n                    call = other.mangled_call(function,arguments).strip()\n                    if len(call):\n                        s += \' \' + operand + \' \' + call\n\n        # No function defined in this snippet, we look for next one\n        else:\n            if self._next:\n                operand, other = self.next\n                if operand in ""+-/*"":\n                    s = other.mangled_call(function,arguments)\n        return s\n\n\n    def __call__(self, *args, **kwargs):\n        """"""\n        Call with new arguments and keyword arguments.\n\n        IMPORTANT: The returned snippet is `self`, not a copy.\n        """"""\n\n        for arg in args:\n            if isinstance(arg,Snippet) and self in arg.snippets:\n                raise ValueError(""Recursive call is forbidden"")\n\n        # Override call arguments\n        self._args = args\n\n        # Here we process kwargs as if they were given in __init__()\n        self.process_kwargs(**kwargs)\n\n        # Remaining kwargs are aliases\n        for name, alias in kwargs.items():\n           self._symbols[name] = alias\n\n        return self\n\n\n    def copy(self, deep=False):\n        """""" Shallow or deep copy of the snippet """"""\n\n        if deep:\n            snippet = copy.deepcopy(self)\n        else:\n            snippet = copy.copy(self)\n        return snippet\n\n\n    def __op__(self, operand, other):\n        snippet = self.copy()\n        snippet.last._next = operand,other\n        return snippet\n\n    def __add__(self, other):\n        return self.__op__(""+"", other)\n\n    def __and__(self, other):\n        return self.__op__(""&"", other)\n\n    def __sub__(self, other):\n        return self.__op__(""-"", other)\n\n    def __mul__(self, other):\n        return self.__op__(""*"", other)\n\n    def __div__(self, other):\n        return self.__op__(""/"", other)\n\n    def __radd__(self, other):\n        return self.__op__(""+"", other)\n\n    def __rand__(self, other):\n        return self.__op__(""&"", other)\n\n    def __rsub__(self, other):\n        return self.__op__(""-"", other)\n\n    def __rmul__(self, other):\n        return self.__op__(""*"", other)\n\n    def __rdiv__(self, other):\n        return self.__op__(""/"", other)\n\n    def __rshift__(self, other):\n        return self.__op__("";"", other)\n\n    def __repr__(self):\n        # return self.generate_call()\n\n        s = self._name\n        # s = self.__class__.__name__\n        s += ""(""\n        if len(self._args):\n            s += "" ""\n            for i,snippet in enumerate(self._args):\n                s += repr(snippet)\n                if i < len(self._args)-1:\n                    s+= "", ""\n            s += "" ""\n        s += "")""\n        if self._next:\n            s += "" %s %s"" % self._next\n\n        return s\n\n\n    def __getitem__(self, key):\n        """"""\n        Get an item from:\n\n          1. this snippet\n          2. the children (args)\n          3. the sibling (next)\n          4. the attached programs\n        """"""\n\n        # First we look in all snippets\n        for snippet in self.snippets:\n            if snippet.name == key:\n                return snippet\n\n            if hasattr(snippet, key):\n                return getattr(snippet, key)\n\n        # Then we look into all attached program\n        if len(self._programs) > 0:\n            name = self.lookup(key)\n            for program in self._programs:\n                try:\n                    return program[name]\n                except AttributeError:\n                    pass\n\n        # No luck, we raise exception\n        raise AttributeError\n\n\n    def __setitem__(self, key, value):\n        """"""\n        Set an item in:\n\n          1. this snippet\n          2. the children (args)\n          3. the sibling (next)\n          4. the attached programs\n        """"""\n\n        name = self.lookup(key) or key\n\n        found = False\n\n        # First we look in all snippets for the actual key\n        for snippet in self.snippets:\n            if hasattr(snippet, name):\n                setattr(snippet, name, value)\n                found = True\n\n\n        # Then we look into all attached program\n        if len(self._programs) > 0:\n            for program in self._programs:\n                try:\n                    program[name] = value\n                except IndexError:\n                    pass\n                else:\n                    found = True\n\n        if not found:\n            error = \'Snippet does not have such key (""%s"")\' % key\n            raise IndexError(error)\n'"
glumpy/gloo/texture.py,9,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nA texture is an OpenGL Object that contains one or more images that all\nhave the same image format. A texture can be used in two ways. It can be the\nsource of a texture access from a Shader, or it can be used as a render target.\n\nRead more on framebuffers on `OpenGL Wiki <https://www.opengl.org/wiki/Texture>`_\n\n**Example usage**:\n\n  .. code::\n\n     ...\n    fragment = \'\'\'\n        uniform sampler2D texture;\n        varying vec2 v_texcoord;\n        void main()\n        {\n           gl_FragColor = texture2D(texture, v_texcoord);\n        } \'\'\'\n\n    ...\n    quad = gloo.Program(vertex, fragment, count=4)\n    quad[\'texture\'] = data.get(\'lena.png\')\n    ...\n""""""\n\nimport numpy as np\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.gloo.gpudata import GPUData\nfrom glumpy.gloo.globject import GLObject\n\n\nclass Texture(GPUData,GLObject):\n    """""" Generic texture """"""\n\n    _cpu_formats = { 1: gl.GL_RED,\n                     2: gl.GL_RG,\n                     3: gl.GL_RGB,\n                     4: gl.GL_RGBA }\n\n    _gpu_formats = { 1: gl.GL_RED,\n                     2: gl.GL_RG,\n                     3: gl.GL_RGB,\n                     4: gl.GL_RGBA }\n\n    _gpu_float_formats = { 1: gl.GL_R32F,\n                           2: gl.GL_RG32F,\n                           3: gl.GL_RGB32F,\n                           4: gl.GL_RGBA32F }\n\n    _gtypes = { np.dtype(np.int8):    gl.GL_BYTE,\n                np.dtype(np.uint8):   gl.GL_UNSIGNED_BYTE,\n                np.dtype(np.int16):   gl.GL_SHORT,\n                np.dtype(np.uint16):  gl.GL_UNSIGNED_SHORT,\n                np.dtype(np.int32):   gl.GL_INT,\n                np.dtype(np.uint32):  gl.GL_UNSIGNED_INT,\n                np.dtype(np.float32): gl.GL_FLOAT }\n\n    def __init__(self, target):\n        GLObject.__init__(self)\n        self._target = target\n        # self._interpolation = gl.GL_LINEAR, gl.GL_LINEAR\n        self._interpolation = gl.GL_NEAREST, gl.GL_NEAREST\n        self._wrapping = gl.GL_CLAMP_TO_EDGE\n        self._cpu_format = None\n        self._gpu_format = None\n\n    def _check_shape(self, shape, ndims):\n        """""" Check and normalize shape. """"""\n\n        if len(shape) < ndims:\n            raise ValueError(""Too few dimensions for texture"")\n        elif len(shape) > ndims+1:\n            raise ValueError(""Too many dimensions for texture"")\n        elif len(shape) == ndims:\n            shape = list(shape) + [1,]\n        elif len(shape) == ndims+1:\n            if shape[-1] > 4:\n                raise ValueError(""Too many channels for texture"")\n        return shape\n\n\n    @property\n    def need_update(self):\n        """""" Whether object needs to be updated """"""\n\n        return self.pending_data is not None\n\n\n    @property\n    def cpu_format(self):\n        """"""\n        Texture CPU format (read/write).\n       \n        Depending on integer or float textures, one of:\n\n        * gl.GL_RED  / gl.GLR32F\n        * gl.GL_RG   / gl.GL_RG32F\n        * gl.GL_RGB  / gl.GL_RGB32F\n        * gl.GL_RGBA / gl.GL_RGBA32F\n        """"""\n\n        return self._cpu_format\n\n    @property\n    def gpu_format(self):\n        """""" \n        Texture GPU format (read/write).\n\n        Depending on integer or float textures, one of:\n\n        * gl.GL_RED  / gl.GLR32F\n        * gl.GL_RG   / gl.GL_RG32F\n        * gl.GL_RGB  / gl.GL_RGB32F\n        * gl.GL_RGBA / gl.GL_RGBA32F\n        """"""\n\n        return self._gpu_format\n\n\n    @gpu_format.setter\n    def gpu_format(self, value):\n        """""" Texture GPU format. """"""\n\n        self._gpu_format = value\n        self._need_setup = True\n\n\n    @property\n    def gtype(self):\n        if self.dtype in Texture._gtypes.keys():\n            return Texture._gtypes[self.dtype]\n        else:\n            raise TypeError(""No available GL type equivalent"")\n\n    @property\n    def wrapping(self):\n        """""" Texture wrapping mode """"""\n\n        return self._wrapping\n\n    @wrapping.setter\n    def wrapping(self, value):\n        """""" Texture wrapping mode """"""\n\n        self._wrapping = value\n        self._need_setup = True\n\n    @property\n    def interpolation(self):\n        """""" Texture interpolation for minification and magnification. """"""\n\n        return self._interpolation\n\n    @interpolation.setter\n    def interpolation(self, value):\n        """""" Texture interpolation for minication and magnification. """"""\n\n        if isinstance(value, (list,tuple)):\n            self._interpolation = value\n        else:\n            self._interpolation = value,value\n        self._need_setup = True\n\n\n    def _setup(self):\n        """""" Setup texture on GPU """"""\n\n        min_filter, mag_filter = self._interpolation\n        wrapping = self._wrapping\n\n        gl.glTexParameterf(self.target, gl.GL_TEXTURE_MIN_FILTER, min_filter)\n        gl.glTexParameterf(self.target, gl.GL_TEXTURE_MAG_FILTER, mag_filter)\n        gl.glTexParameterf(self.target, gl.GL_TEXTURE_WRAP_S, wrapping)\n        gl.glTexParameterf(self.target, gl.GL_TEXTURE_WRAP_T, wrapping)\n        gl.glTexParameterf(self.target, gl.GL_TEXTURE_WRAP_R, gl.GL_CLAMP_TO_EDGE)\n        self._need_setup = False\n\n\n    def _activate(self):\n        """""" Activate texture on GPU """"""\n\n        log.debug(""GPU: Activate texture"")\n        gl.glBindTexture(self.target, self._handle)\n        if self._need_setup:\n            self._setup()\n\n\n    def _deactivate(self):\n        """""" Deactivate texture on GPU """"""\n\n        log.debug(""GPU: Deactivate texture"")\n        gl.glBindTexture(self._target, 0)\n\n\n    def _create(self):\n        """""" Create texture on GPU """"""\n\n        log.debug(""GPU: Creating texture"")\n        self._handle = gl.glGenTextures(1)\n\n    def _delete(self):\n        """""" Delete texture from GPU """"""\n\n        log.debug(""GPU: Deleting texture"")\n        if self.handle > -1:\n            gl.glDeleteTextures(np.array([self.handle], dtype=np.uint32))\n\n    def get(self):\n        """""" Read the texture data back into CPU memory """"""\n        host = np.zeros(self.shape, self.dtype)\n        gl.glBindTexture(self.target, self._handle)\n        gl.glGetTexImage(self.target, 0, self.cpu_format, self.gtype, host)\n        return host\n\n\nclass Texture1D(Texture):\n    """"""\n    One dimensional texture.\n    """"""\n\n    def __init__(self):\n        Texture.__init__(self, gl.GL_TEXTURE_1D)\n        self.shape = self._check_shape(self.shape, 1)\n        self._cpu_format = Texture._cpu_formats[self.shape[-1]]\n        self._gpu_format = Texture._gpu_formats[self.shape[-1]]\n\n\n    @property\n    def width(self):\n        """""" \n        Texture width\n        """"""\n\n        return self.shape[0]\n\n    \n#    def _create(self):\n#        Texture._create(self)\n#        log.debug(""GPU: Resizing texture(%s)""% (self.width))\n#        gl.glBindTexture(self.target, self._handle)\n#        gl.glTexImage1D(self.target, 0, self.format, self.width,\n#                        0, self.format, self.gtype, None)\n\n    def _setup(self):\n        """""" Setup texture on GPU """"""\n\n        Texture._setup(self)\n        gl.glBindTexture(self.target, self._handle)\n        gl.glTexImage1D(self.target, 0, self._gpu_format, self.width,\n                        0, self._cpu_format, self.gtype, None)\n        self._need_setup = False\n\n    def _update(self):\n\n        log.debug(""GPU: Updating texture"")\n        if self.pending_data:\n            start, stop = self.pending_data\n            offset, nbytes = start, stop-start\n            itemsize = self.strides[0]\n            x = offset // itemsize\n            width = nbytes//itemsize\n            gl.glTexSubImage1D(self.target, 0, x, width, self._cpu_format, self.gtype, self)\n\n            # x,width = self.pending_data\n            # itemsize = self.strides[0]\n            # x /= itemsize\n            # width /= itemsize\n            # gl.glTexSubImage1D(self.target, 0, x, width, self._cpu_format, self.gtype, self)\n        self._pending_data = None\n        self._need_update = False\n\n\nclass TextureFloat1D(Texture1D):\n    """"""\n    One dimensional float texture.\n    """"""\n\n    def __init__(self):\n        Texture1D.__init__(self)\n        self._gpu_format = Texture._gpu_float_formats[self.shape[-1]]\n\n\n\nclass Texture2D(Texture):\n    """""" 2D texture """"""\n\n    def __init__(self):\n        Texture.__init__(self, gl.GL_TEXTURE_2D)\n        self.shape = self._check_shape(self.shape, 2)\n        self._cpu_format = Texture._cpu_formats[self.shape[-1]]\n        self._gpu_format = Texture._gpu_formats[self.shape[-1]]\n\n    @property\n    def width(self):\n        """""" Texture width """"""\n\n        return self.shape[1]\n\n\n    @property\n    def height(self):\n        """""" Texture height """"""\n\n        return self.shape[0]\n\n\n    # def _create(self):\n    #     """""" Create texture on GPU """"""\n\n    #     Texture._create(self)\n    #     log.debug(""GPU: Resizing texture(%sx%s)""% (self.width,self.height))\n    #     gl.glBindTexture(self.target, self._handle)\n    #     gl.glTexImage2D(self.target, 0, self.format, self.width, self.height,\n    #                     0, self.format, self.gtype, None)\n    #     """"""\n    #     if self.format == gl.GL_RED:\n    #         gl.glTexImage2D(self.target, 0, gl.GL_R32F, self.width, self.height,\n    #                         0, self.format, self.gtype, None)\n\n    #     elif self.format == gl.GL_RG:\n    #         gl.glTexImage2D(self.target, 0, gl.GL_RG32F, self.width, self.height,\n    #                         0, self.format, self.gtype, None)\n    #     elif self.format == gl.GL_RGB:\n    #         gl.glTexImage2D(self.target, 0, gl.GL_RGB32F, self.width, self.height,\n    #                         0, self.format, self.gtype, None)\n    #     elif self.format == gl.GL_RGBA:\n    #         gl.glTexImage2D(self.target, 0, gl.GL_RGBA32F, self.width, self.height,\n    #                         0, self.format, self.gtype, None)\n    #     """"""\n\n    def _setup(self):\n        """""" Setup texture on GPU """"""\n\n        Texture._setup(self)\n        gl.glBindTexture(self.target, self._handle)\n        gl.glTexImage2D(self.target, 0, self._gpu_format, self.width, self.height,\n                        0, self._cpu_format, self.gtype, None)\n        self._need_setup = False\n\n\n    def _update(self):\n        """""" Update texture on GPU """"""\n\n        if self.pending_data:\n            log.debug(""GPU: Updating texture"")\n\n            start, stop = self.pending_data\n            offset, nbytes = start, stop-start\n\n            itemsize = self.strides[1]\n            offset /= itemsize\n            nbytes /= itemsize\n\n            nbytes += offset % self.width\n            offset -= offset % self.width\n            nbytes += (self.width - ((offset + nbytes) % self.width)) % self.width\n\n            x = 0\n            y = offset // self.width\n            width = self.width\n            height = nbytes // self.width\n            gl.glBindTexture(self._target, self.handle)\n            gl.glTexSubImage2D(self.target, 0, x, y, width, height,\n                               self._cpu_format, self.gtype, self)\n            gl.glBindTexture(self._target, self.handle)\n\n        self._pending_data = None\n        self._need_update = False\n\n\n\nclass TextureFloat2D(Texture2D):\n    """""" 2D float texture """"""\n\n    def __init__(self):\n        Texture2D.__init__(self)\n        self._gpu_format = Texture._gpu_float_formats[self.shape[-1]]\n\n\nclass DepthTexture(Texture2D):\n    """""" Depth texture """"""\n\n    def __init__(self):\n        Texture2D.__init__(self)\n        self._cpu_format = gl.GL_DEPTH_COMPONENT\n        self._gpu_format = gl.GL_DEPTH_COMPONENT\n\n\n\nclass TextureCube(Texture):\n    """""" Cube texture """"""\n\n    def __init__(self):\n\n        Texture.__init__(self, gl.GL_TEXTURE_CUBE_MAP)\n        if self.shape[0] != 6:\n            error = ""Texture cube require arrays first dimension to be 6""\n            log.error(error)\n            raise RuntimeError(error)\n\n        self.shape = [6] + list(self._check_shape(self.shape[1:], 2))\n        self._cpu_format = Texture._cpu_formats[self.shape[-1]]\n        self._gpu_format = Texture._gpu_formats[self.shape[-1]]\n\n    @property\n    def width(self):\n        """""" Texture width """"""\n\n        return self.shape[2]\n\n\n    @property\n    def height(self):\n        """""" Texture height """"""\n\n        return self.shape[1]\n\n\n    def _setup(self):\n        """""" Setup texture on GPU """"""\n\n        Texture._setup(self)\n        gl.glEnable(gl.GL_TEXTURE_CUBE_MAP)\n        gl.glBindTexture(self.target, self._handle)\n        targets = [ gl.GL_TEXTURE_CUBE_MAP_POSITIVE_X,\n                    gl.GL_TEXTURE_CUBE_MAP_NEGATIVE_X,\n                    gl.GL_TEXTURE_CUBE_MAP_POSITIVE_Y,\n                    gl.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,\n                    gl.GL_TEXTURE_CUBE_MAP_POSITIVE_Z,\n                    gl.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z ]\n        for i,target in enumerate(targets):\n            gl.glTexImage2D(target, 0, self._gpu_format, self.width, self.height,\n                            0, self._cpu_format, self.gtype, None)\n        self._need_setup = False\n\n\n    def _update(self):\n        log.debug(""GPU: Updating texture cube"")\n\n        if self.need_update:\n            gl.glEnable(gl.GL_TEXTURE_CUBE_MAP)\n            gl.glBindTexture(self.target, self.handle)\n\n            targets = [ gl.GL_TEXTURE_CUBE_MAP_POSITIVE_X,\n                        gl.GL_TEXTURE_CUBE_MAP_NEGATIVE_X,\n                        gl.GL_TEXTURE_CUBE_MAP_POSITIVE_Y,\n                        gl.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,\n                        gl.GL_TEXTURE_CUBE_MAP_POSITIVE_Z,\n                        gl.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z ]\n\n            for i,target in enumerate(targets):\n                face = self[i]\n                pending = self.pending_data\n                extents = face._extents\n                if pending is None:         continue\n                if pending[1] < extents[0]: continue\n                if pending[0] > extents[1]: continue\n                start = max(extents[0], pending[0]) - extents[0]\n                stop = min(extents[1], pending[1]) - extents[0]\n                offset,nbytes = start, stop-start\n                itemsize = face.strides[1]\n                offset /= itemsize\n                nbytes /= itemsize\n                nbytes += offset % self.width\n                offset -= offset % self.width\n                nbytes += (self.width - ((offset + nbytes) % self.width)) % self.width\n                x = 0\n                y = offset // self.width\n                width = self.width\n                height = nbytes // self.width\n                gl.glTexSubImage2D(target, 0, x, y, width, height,\n                                   self._cpu_format, self.gtype, face)\n\n        self._pending_data = None\n        self._need_update = False\n\n    def _activate(self):\n        """""" Activate texture on GPU """"""\n\n        log.debug(""GPU: Activate texture cube"")\n        gl.glEnable(gl.GL_TEXTURE_CUBE_MAP)\n        gl.glBindTexture(self.target, self._handle)\n        if self._need_setup:\n            self._setup()\n\n\n    def _deactivate(self):\n        """""" Deactivate texture on GPU """"""\n\n        log.debug(""GPU: Deactivate texture cube"")\n        gl.glBindTexture(self._target, 0)\n        gl.glDisable(gl.GL_TEXTURE_CUBE_MAP)\n'"
glumpy/gloo/uniforms.py,11,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n""""""\nimport sys\nimport math\nimport numpy as np\nfrom operator import mul\nfrom functools import reduce\nfrom glumpy.log import log\nfrom . texture import Texture2D\n\n\ndef dtype_reduce(dtype, level=0, depth=0):\n    """"""\n    Try to reduce dtype up to a given level when it is possible\n\n    dtype =  [ (\'vertex\',  [(\'x\', \'f4\'), (\'y\', \'f4\'), (\'z\', \'f4\')]),\n               (\'normal\',  [(\'x\', \'f4\'), (\'y\', \'f4\'), (\'z\', \'f4\')]),\n               (\'color\',   [(\'r\', \'f4\'), (\'g\', \'f4\'), (\'b\', \'f4\'), (\'a\', \'f4\')])]\n\n    level 0: [\'color,vertex,normal,\', 10, \'float32\']\n    level 1: [[\'color\', 4, \'float32\']\n              [\'normal\', 3, \'float32\']\n              [\'vertex\', 3, \'float32\']]\n    """"""\n    dtype = np.dtype(dtype)\n    fields = dtype.fields\n\n    # No fields\n    if fields is None:\n        if dtype.shape:\n            count = reduce(mul, dtype.shape)\n        else:\n            count = 1\n        size = dtype.itemsize/count\n        if dtype.subdtype:\n            name = str( dtype.subdtype[0] )\n        else:\n            name = str( dtype )\n        return [\'\', count, name]\n    else:\n        items = []\n        name = \'\'\n        # Get reduced fields\n        for key,value in fields.items():\n            l = dtype_reduce(value[0], level, depth+1)\n            if type(l[0]) is str:\n                items.append( [key, l[1], l[2]] )\n            else:\n                items.append( l )\n            name += key+\',\'\n\n        # Check if we can reduce item list\n        ctype = None\n        count = 0\n        for i,item in enumerate(items):\n            # One item is a list, we cannot reduce\n            if type(item[0]) is not str:\n                return items\n            else:\n                if i==0:\n                    ctype = item[2]\n                    count += item[1]\n                else:\n                    if item[2] != ctype:\n                        return items\n                    count += item[1]\n        if depth >= level:\n            return [name, count, ctype]\n        else:\n            return items\n\n\n\nclass Uniforms(Texture2D):\n    """"""\n    Uniforms data texture holder.\n\n    This class is used in conjunction with collections in order to store a\n    number of uniforms in a texture such that each vertices can retrieve a\n    specific group of uniforms. The data type can be structured but must be\n    reduceable to n x np.float32. Note that you don\'t need to manipulate\n    directly this function, it is done automagically in collections.\n\n    .. note::\n \n       The code needed to retrieve a specific item is given from the ``code``\n       function and is generated specifically for the actual data type.\n\n    :param int size: Number of items to be stored in the texture\n    :param numpy.dtype dtype: Item data type (must be reduceable to n x np.float32)\n    """"""\n\n    def __init__(self, size, dtype):\n        """""" Initialization """"""\n\n        # Check dtype is made of float32 only\n        dtype = eval(str(np.dtype(dtype)))\n        rtype = dtype_reduce(dtype)\n        if type(rtype[0]) is not str or rtype[2] != \'float32\':\n            raise RuntimeError(""Uniform type cannot be reduced to float32 only"")\n\n        # True dtype (the one given in args)\n        self._original_dtype = np.dtype(dtype)\n\n        # Equivalent float count\n        self._original_count = rtype[1]\n\n        # Make dtype a multiple of 4 floats\n        count = 4*(rtype[1]//4)\n        if rtype[1] % 4:\n            count += 4\n        if (count - rtype[1]) > 0:\n            dtype.append((\'unused\', \'<f4\', count - rtype[1]))\n\n        # Complete dtype, multiple of 4 floats\n        self._complete_dtype = dtype\n\n        # Equivalent float count\n        self._complete_count = count\n\n        # max_texsize = gl.glGetInteger(gl.GL_MAX_TEXTURE_SIZE)\n        max_texsize = 512\n        width = max_texsize\n        height = 1 + size//width\n\n        cols = max_texsize//(count/4)\n        rows = size // cols\n        if size % cols: rows += 1\n\n        Texture2D.__init__(self, shape=(rows,cols,4), dtype=np.float32,\n                           resizeable=False, store=True)\n        data = self._data.ravel()\n        self._typed_data = data.view(self._complete_dtype)\n        self._size = size\n\n\n    def __setitem__(self, key, value):\n        """""" x.__getitem__(y) <==> x[y] """"""\n\n\n        if self.base is not None and not self._valid:\n            raise ValueError(""This uniforms view has been invalited"")\n\n        size = self._size\n        if isinstance(key, int):\n            if key < 0:\n                key += size\n            if key < 0 or key > size:\n                raise IndexError(""Uniforms assignment index out of range"")\n            start, stop = key, key + 1\n        elif isinstance(key, slice):\n            start, stop, step = key.indices(size)\n            if step != 1:\n                raise ValueError(""Cannot access non-contiguous uniforms data"")\n            if stop < start:\n                start, stop = stop, start\n        elif key == Ellipsis:\n            start = 0\n            stop = size\n        else:\n            raise TypeError(""Uniforms indices must be integers"")\n\n\n        # First we set item using the typed data\n        shape = self._typed_data[start:stop].shape\n        dtype = self._original_dtype\n        data = self._typed_data\n        # data[start:stop] = np.array(value, dtype=dtype).reshape(shape)\n        data[start:stop] = np.array(value, dtype=dtype)\n\n\n        # Second, we tell texture where to update\n        count  = self._complete_count\n        start = np.unravel_index(start*count, self.shape)\n        stop = np.unravel_index(stop*count, self.shape)\n        if start[0] == stop[0]:\n            start = start[:2]\n            stop  = stop[:2]\n        else:\n            start = start[0], 0\n            stop  = stop[0], self.shape[1]-1\n\n        offset = start[0], start[1], 0\n        data = self._data[start[0]:stop[0]+1,start[1]:stop[1]]\n        self.set_data(data=data, offset=offset, copy=False)\n\n\n\n    def code(self, prefix=""u_""):\n        """"""\n        Generate the GLSL code needed to retrieve fake uniform values from a texture.\n        The generated uniform names can be prefixed with the given prefix.\n        """"""\n\n        dtype = np.dtype(self._original_dtype)\n        _dtype = dtype_reduce(dtype, level=1)\n\n        header = """"""uniform sampler2D u_uniforms;\\n""""""\n\n        # Header generation (easy)\n        types = { 1 : \'float\', 2 : \'vec2 \', 3 : \'vec3 \',\n                  4 : \'vec4 \', 9 : \'mat3 \', 16 : \'mat4 \'}\n        for name,count,_ in _dtype:\n            header += ""varying %s %s%s;\\n"" % (types[count],prefix,name)\n\n\n        # Body generation (not so easy)\n        rows, cols = self.shape[0], self.shape[1]\n        count = self._complete_count\n\n        body = """"""\\nvoid fetch_uniforms(float index) {\n        float rows   = %.1f;\n        float cols   = %.1f;\n        float count  = %.1f;\n        int index_x  = int(mod(index, (floor(cols/(count/4.0))))) * int(count/4.0);\n        int index_y  = int(floor(index / (floor(cols/(count/4.0)))));\n        float size_x = cols - 1.0;\n        float size_y = rows - 1.0;\n        float ty     = 0.0;\n        if (size_y > 0.0)\n            ty = float(index_y)/size_y;\n        int i = index_x;\n        vec4 _uniform;\\n"""""" % (rows, cols, count)\n\n\n        _dtype = {name: count for name,count,_ in _dtype}\n        store = 0\n        # Be very careful with utype name order (_utype.keys is wrong)\n        for name in dtype.names:\n            count, shift =_dtype[name], 0\n            while count:\n                if store == 0:\n                    body += ""\\n    _uniform = texture2D(u_uniforms, vec2(float(i++)/size_x,ty));\\n""\n                    store = 4\n                if   store == 4: a = ""xyzw""\n                elif store == 3: a = ""yzw""\n                elif store == 2: a = ""zw""\n                elif store == 1: a = ""w""\n                if shift == 0:   b = ""xyzw""\n                elif shift == 1: b = ""yzw""\n                elif shift == 2: b = ""zw""\n                elif shift == 3: b = ""w""\n\n                i = min(min(len(b), count), len(a))\n                body += ""    %s%s.%s = _uniforms.%s;\\n"" % (prefix,name,b[:i],a[:i])\n                count -= i\n                shift += i\n                store -= i\n\n        body += """"""}""""""\n        return header + body\n'"
glumpy/gloo/variable.py,50,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nVariables are entry points in the shader that allow to upload CPU data to\nthe GPU. For OpenGL ES 2.0, there are mainly two types: uniforms and\nattributes. The correspondance betwenn GPU and CPU data types is given in the\ntable below.\n\n=========== ================== == ================== ==============\nGLSL Type   GLSL/GL Type       #  GL elementary type Numpy type\n=========== ================== == ================== ==============\nfloat       gl.GL_FLOAT        1  gl.GL_FLOAT        np.float32\nvec2        gl.GL_FLOAT_VEC2   2  gl.GL_FLOAT        np.float32\nvec3        gl.GL_FLOAT_VEC3   3  gl.GL_FLOAT        np.float32\nvec4        gl.GL_FLOAT_VEC4   4  gl.GL_FLOAT        np.float32\nint         gl.GL_INT          1  gl.GL_INT          np.int32\nivec2       gl.GL_INT_VEC2     2  gl.GL_INT          np.int32\nivec3       gl.GL_INT_VEC3     3  gl.GL_INT          np.int32\nivec4       gl.GL_INT_VEC4     4  gl.GL_INT          np.int32\nbool        gl.GL_BOOL         1  gl.GL_BOOL         np.bool\nbvec2       gl.GL_BOOL_VEC2    2  gl.GL_BOOL         np.bool\nbvec3       gl.GL_BOOL_VEC3    3  gl.GL_BOOL         np.bool\nbvec4       gl.GL_BOOL_VEC4    4  gl.GL_BOOL         np.bool\nmat2        gl.GL_FLOAT_MAT2   4  gl.GL_FLOAT        np.float32\nmat3        gl.GL_FLOAT_MAT3   9  gl.GL_FLOAT        np.float32\nmat4        gl.GL_FLOAT_MAT4   16 gl.GL_FLOAT        np.float32\nsampler1D   gl.GL_SAMPLER_1D   1  gl.GL_UNSIGNED_INT np.uint32\nsampler2D   gl.GL_SAMPLER_2D   1  gl.GL_UNSIGNED_INT np.uint32\nsamplerCube gl.GL_SAMPLER_CUBE 1  gl.GL_UNSIGNED_INT np.uint32\n=========== ================== == ================== ==============\n\n.. note:: \n\n   Most of the time, you don\'t need to directly manipulate such variables\n   since they are created automatically when shader code is parsed.\n\n**Example usage**\n\n  .. code::\n\n     vertex = \'\'\'\n         attribute vec3 position;\n         void main (void)\n         {\n             gl_Position = vec4(position, 1.0);\n         } \'\'\'\n     fragment = \'\'\'\n         uniform vec4 color;\n         void main(void)\n         {\n             gl_FragColor = color;\n         } \'\'\'\n     program = gloo.Program(vertex, fragment, count=4)\n     # program[""position""] type is Attribute\n     # program[""color""] type is Uniform\n""""""\nimport ctypes\nimport numpy as np\n\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.gloo.globject import GLObject\nfrom glumpy.gloo.array import VertexArray\nfrom glumpy.gloo.buffer import VertexBuffer\nfrom glumpy.gloo.texture import TextureCube\nfrom glumpy.gloo.texture import Texture1D, Texture2D\nfrom glumpy.gloo.texture import TextureFloat1D, TextureFloat2D\n\n\n# ------------------------------------------------------------- gl_typeinfo ---\ngl_typeinfo = {\n    gl.GL_FLOAT        : ( 1, gl.GL_FLOAT,        np.float32),\n    gl.GL_FLOAT_VEC2   : ( 2, gl.GL_FLOAT,        np.float32),\n    gl.GL_FLOAT_VEC3   : ( 3, gl.GL_FLOAT,        np.float32),\n    gl.GL_FLOAT_VEC4   : ( 4, gl.GL_FLOAT,        np.float32),\n    gl.GL_INT          : ( 1, gl.GL_INT,          np.int32),\n    gl.GL_INT_VEC2     : ( 2, gl.GL_INT,          np.int32),\n    gl.GL_INT_VEC3     : ( 3, gl.GL_INT,          np.int32),\n    gl.GL_INT_VEC4     : ( 4, gl.GL_INT,          np.int32),\n    gl.GL_BOOL         : ( 1, gl.GL_BOOL,         np.bool),\n    gl.GL_BOOL_VEC2    : ( 2, gl.GL_BOOL,         np.bool),\n    gl.GL_BOOL_VEC3    : ( 3, gl.GL_BOOL,         np.bool),\n    gl.GL_BOOL_VEC4    : ( 4, gl.GL_BOOL,         np.bool),\n    gl.GL_FLOAT_MAT2   : ( 4, gl.GL_FLOAT,        np.float32),\n    gl.GL_FLOAT_MAT3   : ( 9, gl.GL_FLOAT,        np.float32),\n    gl.GL_FLOAT_MAT4   : (16, gl.GL_FLOAT,        np.float32),\n    gl.GL_SAMPLER_1D   : ( 1, gl.GL_UNSIGNED_INT, np.uint32),\n    gl.GL_SAMPLER_2D   : ( 1, gl.GL_UNSIGNED_INT, np.uint32),\n    gl.GL_SAMPLER_CUBE : ( 1, gl.GL_UNSIGNED_INT, np.uint32)\n}\n\n\n\n# ---------------------------------------------------------- Variable class ---\nclass Variable(GLObject):\n    """""" A variable is an interface between a program and data """"""\n\n    def __init__(self, program, name, gtype):\n        """""" Initialize the data into default state """"""\n\n        # Make sure variable type is allowed (for ES 2.0 shader)\n        if gtype not in [gl.GL_FLOAT,      gl.GL_FLOAT_VEC2,\n                         gl.GL_FLOAT_VEC3, gl.GL_FLOAT_VEC4,\n                         gl.GL_INT,        gl.GL_BOOL,\n                         gl.GL_FLOAT_MAT2, gl.GL_FLOAT_MAT3,\n                         gl.GL_FLOAT_MAT4, gl.GL_SAMPLER_1D,\n                         gl.GL_SAMPLER_2D, gl.GL_SAMPLER_CUBE]:\n            raise TypeError(""Unknown variable type"")\n\n        GLObject.__init__(self)\n\n        # Program this variable belongs to\n        self._program = program\n\n        # Name of this variable in the program\n        self._name = name\n\n        # Build dtype\n        size, _, base = gl_typeinfo[gtype]\n        self._dtype = (name,base,size)\n\n        # GL type\n        self._gtype = gtype\n\n        # CPU data\n        self._data = None\n\n        # Whether this variable is active\n        self._active = True\n\n\n    @property\n    def name(self):\n        """""" Variable name """"""\n\n        return self._name\n\n\n    @property\n    def program(self):\n        """""" Program this variable belongs to """"""\n\n        return self._program\n\n\n    @property\n    def gtype(self):\n        """""" Type of the underlying variable (as a GL constant) """"""\n\n        return self._gtype\n\n    @property\n    def dtype(self):\n        """""" Equivalent dtype of the variable """"""\n\n        return self._dtype\n\n\n    @property\n    def active(self):\n        """""" Whether this variable is active in the program """"""\n        return self._active\n\n\n    @active.setter\n    def active(self, active):\n        """""" Whether this variable is active in the program """"""\n        self._active = active\n\n\n    @property\n    def data(self):\n        """""" CPU data """"""\n\n        return self._data\n\n\n\n# ----------------------------------------------------------- Uniform class ---\nclass Uniform(Variable):\n    """""" A Uniform represents a program uniform variable. """"""\n\n    _ufunctions = {\n        gl.GL_FLOAT:        gl.glUniform1fv,\n        gl.GL_FLOAT_VEC2:   gl.glUniform2fv,\n        gl.GL_FLOAT_VEC3:   gl.glUniform3fv,\n        gl.GL_FLOAT_VEC4:   gl.glUniform4fv,\n        gl.GL_INT:          gl.glUniform1iv,\n        gl.GL_BOOL:         gl.glUniform1iv,\n        gl.GL_FLOAT_MAT2:   gl.glUniformMatrix2fv,\n        gl.GL_FLOAT_MAT3:   gl.glUniformMatrix3fv,\n        gl.GL_FLOAT_MAT4:   gl.glUniformMatrix4fv,\n        gl.GL_SAMPLER_1D:   gl.glUniform1i,\n        gl.GL_SAMPLER_2D:   gl.glUniform1i,\n        gl.GL_SAMPLER_CUBE: gl.glUniform1i\n    }\n\n\n    def __init__(self, program, name, gtype):\n        """""" Initialize the input into default state """"""\n\n        Variable.__init__(self, program, name, gtype)\n        size, _, dtype = gl_typeinfo[self._gtype]\n        self._data = np.zeros(size, dtype)\n        self._ufunction = Uniform._ufunctions[self._gtype]\n        self._texture_unit = -1\n\n\n    def set_data(self, data):\n        """""" Assign new data to the variable (deferred operation) """"""\n\n        # Textures need special handling\n        if self._gtype == gl.GL_SAMPLER_1D:\n\n            if isinstance(data, Texture1D):\n                self._data = data\n\n            elif isinstance(self._data, Texture1D):\n                self._data.set_data(data)\n\n            # Automatic texture creation if required\n            else:\n                data = np.array(data,copy=False)\n                if data.dtype in [np.float16, np.float32, np.float64]:\n                    self._data = data.astype(np.float32).view(Texture1D)\n                else:\n                    self._data = data.view(Texture1D)\n\n        elif self._gtype == gl.GL_SAMPLER_2D:\n            if isinstance(data, Texture2D):\n                self._data = data\n            elif isinstance(self._data, Texture2D):\n                #self._data.set_data(data)\n                self._data[...] = data.reshape(self._data.shape)\n\n            # Automatic texture creation if required\n            else:\n                data = np.array(data,copy=False)\n                if data.dtype in [np.float16, np.float32, np.float64]:\n                    self._data = data.astype(np.float32).view(Texture2D)\n                else:\n                    self._data = data.view(Texture2D)\n\n        elif self._gtype == gl.GL_SAMPLER_CUBE:\n            if isinstance(data, TextureCube):\n                self._data = data\n            elif isinstance(self._data, TextureCube):\n                self._data[...] = data.reshape(self._data.shape)\n\n            # Automatic texture creation if required\n            else:\n                data = np.array(data,copy=False)\n                if data.dtype in [np.float16, np.float32, np.float64]:\n                    self._data = data.astype(np.float32).view(TextureCube)\n                else:\n                    self._data = data.view(TextureCube)\n\n        else:\n            self._data[...] = np.array(data,copy=False).ravel()\n\n        self._need_update = True\n\n\n    def _activate(self):\n        if self._gtype in (gl.GL_SAMPLER_1D, gl.GL_SAMPLER_2D, gl.GL_SAMPLER_CUBE):\n            if self.data is not None:\n                log.debug(""GPU: Active texture is %d"" % self._texture_unit)\n                gl.glActiveTexture(gl.GL_TEXTURE0 + self._texture_unit)\n                self.data.activate()\n\n    def _update(self):\n\n        # Check active status (mandatory)\n        if not self._active:\n            raise RuntimeError(""Uniform variable is not active"")\n\n        # WARNING : Uniform are supposed to keep their value between program\n        #           activation/deactivation (from the GL documentation). It has\n        #           been tested on some machines but if it is not the case on\n        #           every machine, we can expect nasty bugs from this early\n        #           return\n\n        # Matrices (need a transpose argument)\n        if self._gtype in (gl.GL_FLOAT_MAT2, gl.GL_FLOAT_MAT3, gl.GL_FLOAT_MAT4):\n            # OpenGL ES 2.0 does not support transpose\n            transpose = False\n            self._ufunction(self._handle, 1, transpose, self._data)\n\n        # Textures (need to get texture count)\n        elif self._gtype in (gl.GL_SAMPLER_1D, gl.GL_SAMPLER_2D, gl.GL_SAMPLER_CUBE):\n            # texture = self.data\n            log.debug(""GPU: Activactin texture %d"" % self._texture_unit)\n            # gl.glActiveTexture(gl.GL_TEXTURE0 + self._unit)\n            # gl.glBindTexture(texture.target, texture.handle)\n            gl.glUniform1i(self._handle, self._texture_unit)\n\n        # Regular uniform\n        else:\n            self._ufunction(self._handle, 1, self._data)\n\n\n    def _create(self):\n        """""" Create uniform on GPU (get handle) """"""\n\n        self._handle = gl.glGetUniformLocation(self._program.handle, self._name)\n\n\n\n\n# --------------------------------------------------------- Attribute class ---\nclass Attribute(Variable):\n    """""" An Attribute represents a program attribute variable """"""\n\n    _afunctions = {\n        gl.GL_FLOAT:      gl.glVertexAttrib1f,\n        gl.GL_FLOAT_VEC2: gl.glVertexAttrib2f,\n        gl.GL_FLOAT_VEC3: gl.glVertexAttrib3f,\n        gl.GL_FLOAT_VEC4: gl.glVertexAttrib4f\n    }\n\n    def __init__(self, program, name, gtype):\n        """""" Initialize the input into default state """"""\n\n        Variable.__init__(self, program, name, gtype)\n\n        # Number of elements this attribute links to (in the attached buffer)\n        self._size = 0\n\n        # Whether this attribure is generic\n        self._generic = False\n\n\n\n    def set_data(self, data):\n        """""" Assign new data to the variable (deferred operation) """"""\n\n        isnumeric = isinstance(data, (float, int))\n\n        # New vertex buffer\n        if isinstance(data, (VertexBuffer,VertexArray)):\n            self._data = data\n\n        # We already have a vertex buffer\n        elif isinstance(self._data, (VertexBuffer,VertexArray)):\n            self._data[...] = data\n\n        # Data is a tuple with size <= 4, we assume this designates a generate\n        # vertex attribute.\n        elif (isnumeric or (isinstance(data, (tuple, list)) and\n                            len(data) in (1, 2, 3, 4) and\n                            isinstance(data[0], (float, int)))):\n            # Let numpy convert the data for us\n            _, _, dtype = gl_typeinfo[self._gtype]\n            self._data = np.array(data).astype(dtype)\n            self._generic = True\n            self._need_update = True\n            self._afunction = Attribute._afunctions[self._gtype]\n            return\n\n        # For array-like, we need to build a proper VertexBuffer to be able to\n        # upload it later to GPU memory.\n        else: #lif not isinstance(data, VertexBuffer):\n            name,base,count = self.dtype\n            data = np.array(data,dtype=base,copy=False)\n            data = data.ravel().view([self.dtype])\n            # WARNING : transform data with the right type\n            # data = np.array(data,copy=False)\n            self._data = data.view(VertexBuffer)\n\n        self._generic = False\n\n\n    def _activate(self):\n        if isinstance(self.data, (VertexBuffer, VertexArray)):\n            self.data.activate()\n            size, gtype, dtype = gl_typeinfo[self._gtype]\n            stride = self.data.stride\n            offset = ctypes.c_void_p(self.data.offset)\n            gl.glEnableVertexAttribArray(self.handle)\n            gl.glVertexAttribPointer(self.handle, size, gtype, gl.GL_FALSE, stride, offset)\n\n    def _deactivate(self):\n        if isinstance(self.data,VertexBuffer):\n            self.data.deactivate()\n            if self.handle >= 0:\n                gl.glDisableVertexAttribArray(self.handle)\n        elif isinstance(self.data,VertexArray):\n            self.data.deactivate()\n\n\n    def _update(self):\n        """""" Actual upload of data to GPU memory  """"""\n\n        log.debug(""GPU: Updating %s"" % self.name)\n\n        # Check active status (mandatory)\n#        if not self._active:\n#            raise RuntimeError(""Attribute variable is not active"")\n#        if self._data is None:\n#            raise RuntimeError(""Attribute variable data is not set"")\n\n        # Generic vertex attribute (all vertices receive the same value)\n        if self._generic:\n            if self._handle >= 0:\n                gl.glDisableVertexAttribArray(self._handle)\n                self._afunction(self._handle, *self._data)\n\n        # Regular vertex buffer\n        elif self.handle >= 0:\n            #if self._need_update:\n            #    self.data._update()\n            #    self._need_update = False\n\n            # Get relevant information from gl_typeinfo\n            size, gtype, dtype = gl_typeinfo[self._gtype]\n            stride = self.data.stride\n\n            # Make offset a pointer, or it will be interpreted as a small array\n            offset = ctypes.c_void_p(self.data.offset)\n            gl.glEnableVertexAttribArray(self.handle)\n            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.data.handle)\n            gl.glVertexAttribPointer(self.handle, size, gtype,  gl.GL_FALSE, stride, offset)\n\n\n    def _create(self):\n        """""" Create attribute on GPU (get handle) """"""\n\n        self._handle = gl.glGetAttribLocation(self._program.handle, self.name)\n\n\n    @property\n    def size(self):\n        """""" Size of the underlying vertex buffer """"""\n\n        if self._data is None:\n            return 0\n        return self._data.size\n\n\n    def __len__(self):\n        """""" Length of the underlying vertex buffer """"""\n\n        if self._data is None:\n            return 0\n        return len(self._data)\n'"
glumpy/graphics/__init__.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n'
glumpy/graphics/filter.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport os\nimport numpy as np\nimport glumpy.gl as gl\nimport glumpy.gloo as gloo\nfrom glumpy.log import log\n\n\nvertex = """"""\nattribute vec2 position;\nattribute vec2 texcoord;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n    v_texcoord = texcoord;\n}\n""""""\n\nfragment = """"""\nuniform sampler2D original;\nuniform sampler2D filtered;\nuniform vec2 texsize;\nvarying vec2 v_texcoord;\nvoid main()\n{\n    gl_FragColor = <filter>;\n}\n""""""\n\n\nclass Filter(object):\n    """""" Post-processing filter """"""\n\n    def __init__(self, width, height, *args):\n\n        # We need 3 framebuffers:\n        # 1 is used to store original rendering\n        # 2 & 3 are used for ping-pong rendering\n        #  -> gives 2 as input, render in 3\n        #  -> gives 3 as input, render in 2\n        #  -> ...\n        self._framebuffers = []\n        for i in range(3):\n            depth = gloo.DepthBuffer(width, height)\n            # depth = np.zeros((height,width),np.float32).view(gloo.DepthTexture)\n            color = np.zeros((height,width,3),np.float32).view(gloo.Texture2D)\n            framebuffer = gloo.FrameBuffer(color=color, depth=depth)\n            self._framebuffers.append(framebuffer)\n\n        # Build filter programs\n        self._build_programs(*args)\n        self._viewport = 0, 0, width, height\n\n\n    def _build_programs(self, *args):\n        """""" Build all filter programs """"""\n\n        index = 0\n        self._programs = []\n\n        # We add an extra do-nothing program for unfiltered rendering because\n        # it will be rendered at original viewport size and we want all filters\n        # to use the same framebuffer size.\n        args = list(args) + [""texture2D(filtered, v_texcoord)""]\n\n        for i,code in enumerate(args):\n            if not isinstance(code,gloo.Snippet):\n                snippet = gloo.Snippet(code)\n            else:\n                snippet = code\n            program = gloo.Program(vertex, fragment, count=4)\n            program[\'position\'] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]\n            program[\'texcoord\'] = [(0, 0), (0, 1), (1, 0), (1, 1)]\n            program[\'original\'] = self._framebuffers[0].color[0]\n            program[\'original\'].interpolation = gl.GL_LINEAR\n            program[\'filtered\'] = self._framebuffers[index].color[0]\n            program[\'filtered\'].interpolation = gl.GL_LINEAR\n            program[\'texsize\'] = self.width, self.height\n            if i < len(args)-1:\n                original_snippet = snippet\n                # Walk through snippet arguments to fill last one\n                while len(snippet.args) > 0:\n                    if len(snippet.args) > 1:\n                        raise ValueError(""Filter snippet cannot have more than 1 argument"")\n                    elif not isinstance(snippet.args[0], gloo.Snippet):\n                        raise ValueError(""Filter snippet argument must be a Snippet"")\n                    else:\n                        snippet = snippet.args[0]\n                snippet._args = ""original"", ""filtered"", ""v_texcoord"", ""texsize""\n                program[\'filter\'] = original_snippet\n            else:\n                program[\'filter\'] = code\n            self._programs.append(program)\n            index = (index+1)%2\n\n\n    @property\n    def width(self):\n        return self._framebuffers[0].width\n\n\n    @property\n    def height(self):\n        return self._framebuffers[0].height\n\n\n    @property\n    def viewport(self):\n        return self._viewport\n\n\n    @viewport.setter\n    def viewport(self, xywh):\n        (x, y, width, height) = xywh\n        self._viewport = x, y, width, height\n\n\n    def __getitem__(self, name):\n        for program in self._programs:\n            snippet = program[""filter""]\n            if isinstance(snippet, gloo.Snippet) and name in snippet.globals.keys():\n                return snippet[name]\n            if name in program.keys():\n                return program[name]\n        raise IndexError(""Unknown uniform or attribute"")\n\n    def __setitem__(self, name, value):\n        for program in self._programs:\n            snippet = program[""filter""]\n            if isinstance(snippet, gloo.Snippet) and name in snippet.globals.keys():\n                snippet[name] = value\n                return\n            if name in program.keys():\n                program[name] = value\n                return\n        raise IndexError(""Unknown uniform or attribute"")\n\n\n    def __enter__(self):\n        # Save viewport for final rendering\n        self._viewport = gl.glGetIntegerv(gl.GL_VIEWPORT)\n\n        # Prepare framebuffer for ""original"" rendering\n        gl.glViewport(0, 0, self.width, self.height)\n        self._framebuffers[0].activate()\n\n\n    def __exit__(self, type, value, traceback):\n        # Done with ""original"" rendering\n        self._framebuffers[0].deactivate()\n\n        # Actual filtering starts here\n        gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n        gl.glDisable(gl.GL_DEPTH_TEST)\n\n        # Apply all filters using ping-pong framebuffers\n        index = 0\n        for i in range(len(self._programs)-1):\n            program = self._programs[i]\n            if i == 0: # special case for first rendering\n                program[\'filtered\'] = self._framebuffers[0].color[0]\n            else:\n                program[\'filtered\'] = self._framebuffers[1+index].color[0]\n            index = (index + 1) % 2 # ping-pong\n            self._framebuffers[index+1].activate()\n            self._programs[i].draw(gl.GL_TRIANGLE_STRIP)\n            self._framebuffers[index+1].deactivate()\n\n        # Final rendering (no transformation) at original viewport size\n        program = self._programs[-1]\n        program[\'filtered\'] = self._framebuffers[index+1].color[0]\n        gl.glViewport( *self._viewport )\n        gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n        gl.glDisable(gl.GL_DEPTH_TEST)\n        program.draw(gl.GL_TRIANGLE_STRIP)\n'"
glumpy/library/__init__.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport os\nfrom glumpy.log import log\n\ndef find(name):\n    """""" Locate a filename into the shader library """"""\n\n    if os.path.exists(name):\n        return name\n\n    path = os.path.dirname(__file__) or \'.\'\n    filename = os.path.abspath(os.path.join(path,name))\n    if os.path.exists(filename):\n        return filename\n\n    for d in os.listdir(path):\n        fullpath = os.path.abspath(os.path.join(path,d))\n        if os.path.isdir(fullpath):\n            filename = os.path.abspath(os.path.join(fullpath,name))\n            if os.path.exists(filename):\n                return filename\n    return None\n\n\ndef get(name):\n    """""" Retrieve code from the given filename """"""\n\n    filename = find(name)\n    if filename == None:\n        return name\n    return open(filename).read()\n'"
glumpy/library/build-spatial-filters.py,6,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n\'\'\'\nA filter is a shader that transform the current displayed texture. Since\nshaders cannot be easily serialized within the GPU, they have to be well\nstructured on the python side such that we can possibly merge them into a\nsingle source code for both vertex and fragment. Consequently, there is a\ndefault code for both vertex and fragment with specific entry points such that\nfilter knows where to insert their specific code (declarations, functions and\ncall (or code) to be inserted in the main function).\n\nSpatial interpolation filter classes for OpenGL textures.\n\nEach filter generates a one-dimensional lookup table (weights value from 0 to\nceil(radius)) that is uploaded to video memory (as a 1d texture) and is then\nread by the shader when necessary. It avoids computing weight values for each\npixel. Furthemore, each 2D-convolution filter is separable and can be computed\nusing 2 1D-convolution with same 1d-kernel (= the lookup table values).\n\nAvailable filters:\n\n  - Nearest  (radius 0.5)\n  - Bilinear (radius 1.0)\n  - Hanning (radius 1.0)\n  - Hamming (radius 1.0)\n  - Hermite (radius 1.0)\n  - Kaiser (radius 1.0)\n  - Quadric (radius 1.5)\n  - Bicubic (radius 2.0)\n  - CatRom (radius 2.0)\n  - Mitchell (radius 2.0)\n  - Spline16 (radius 2.0)\n  - Spline36 (radius 4.0)\n  - Gaussian (radius 2.0)\n  - Bessel (radius 3.2383)\n  - Sinc (radius 4.0)\n  - Lanczos (radius 4.0)\n  - Blackman (radius 4.0)\n\n\nNote::\n\n  Weights code has been translated from the antigrain geometry library available\n  at http://www.antigrain.com/\n\'\'\'\n\nimport os\nfrom . import math\nimport numpy as np\nimport OpenGL.GL as gl\nimport OpenGL.GLUT as glut\n\n\n\nclass SpatialFilter(object):\n    \'\'\' \'\'\'\n\n    def __init__(self, radius=1.0):\n        self.radius = radius\n\n\n    def weight(self, x):\n        \'\'\'\n        Return filter weight for a distance x.\n\n        :Parameters:\n            ``x`` : 0 < float < ceil(self.radius)\n                Distance to be used to compute weight.\n        \'\'\'\n        raise NotImplemented\n\n\n    def kernel(self, size=4*512):\n        radius = self.radius\n        r = int(max(1.0,math.ceil(radius)))\n        samples = size / r\n        n = size # r*samples\n        kernel = np.zeros(n)\n        X = np.linspace(0,r,n)\n        for i in range(n):\n            kernel[i] = self.weight(X[i])\n        N = np.zeros(samples)\n        for i in range(r):\n            N += kernel[::+1][i*samples:(i+1)*samples]\n            N += kernel[::-1][i*samples:(i+1)*samples]\n        for i in range(r):\n            kernel[i*samples:(i+1)*samples:+1] /= N\n        return kernel\n\n\n    def filter_code(self):\n\n        n = int(math.ceil(self.radius))\n        filter_1 = \'filter1D_radius%d\' % n\n        filter_2 = \'filter2D_radius%d\' % n\n\n        code = \'\'\n        code += \'vec4\\n\'\n        code += \'%s( sampler2D kernel, float index, float x, \' % filter_1\n        for i in range(2*n):\n            if i == 2*n-1:\n                code += \'vec4 c%d )\\n\' % i\n            else:\n                code += \'vec4 c%d, \' % i\n        code += \'{\\n\'\n        code += \'    float w, w_sum = 0.0;\\n\'\n        code += \'    vec4 r = vec4(0.0,0.0,0.0,0.0);\\n\'\n        for i in range(n):\n            code += \'    w = texture2D(kernel, vec2(%f+(x/%.1f),index) ).r;\\n\' % (1.0-(i+1)/float(n),n)\n            code += \'    w = w*kernel_scale + kernel_bias;\\n\';\n            # code += \'   w_sum += w;\'\n            code += \'    r += c%d * w;\\n\' % i\n            code += \'    w = texture2D(kernel, vec2(%f-(x/%.1f),index) ).r;\\n\' % ((i+1)/float(n),n)\n            code += \'    w = w*kernel_scale + kernel_bias;\\n\';\n            # code += \'   w_sum += w;\'\n            code += \'    r += c%d * w;\\n\' % (i+n)\n        # code += \'    return r/w_sum;\\n\'\n        code += \'    return r;\\n\'\n        code += \'}\\n\'\n        code += \'vec4\\n\'\n        code += \'%s\' % filter_2\n        code += \'(sampler2D texture, sampler2D kernel, float index, vec2 uv, vec2 pixel )\\n\'\n        code += \'{\\n\'\n        code += \'    vec2 texel = uv/pixel - vec2(0.5,0.5) ;\\n\'\n        code += \'    vec2 f = fract(texel);\\n\'\n        code += \'    texel = (texel-fract(texel)+vec2(0.001,0.001))*pixel;\\n\'\n        for i in range(2*n):\n            code += \'    vec4 t%d = %s(kernel, index, f.x,\\n\' % (i,filter_1)\n            for j in range(2*n):\n                x,y = (-n+1+j,-n+1+i)\n                code += \'        texture2D( texture, texel + vec2(%d,%d)*pixel),\\n\' % (x,y)\n\n            # Remove last trailing\',\' and close function call\n            code = code[:-2] + \');\\n\'\n\n        code += \'    return %s(kernel, index, f.y, \' % filter_1\n        for i in range(2*n):\n            code += \'t%d, \' % i\n\n        # Remove last trailing\',\' and close function call\n        code = code[:-2] + \');\\n\'\n        code += \'}\\n\'\n\n        return code\n\n\n    def call_code(self, index):\n        code = """"\n        n = int(math.ceil(self.radius))\n        filter_1 = \'filter1D_radius%d\' % n\n        filter_2 = \'filter2D_radius%d\' % n\n\n        code += \'vec4 %s(sampler2D texture, vec2 shape, vec2 uv)\\n\' % self.__class__.__name__\n        code += \'{\'\n        code += \' return %s(texture, u_kernel, %f, uv, 1.0/shape); \' % (filter_2,index)\n        code += \'}\\n\'\n        return code\n\n\n\nclass Nearest(SpatialFilter):\n    \'\'\'\n    Nearest (=None) filter (radius = 0.5).\n\n    Weight function::\n\n      w(x) = 1\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=.5)\n\n    def weight(self, x):\n        return 1.0\n\n    def _get_code(self):\n        self.build_LUT()\n        code += \'vec4\\n\'\n        code += \'interpolate( sampler2D texture, sampler1D kernel, vec2 uv, vec2 pixel )\\n\'\n        code += \'{\\n   return texture2D( texture, uv );\\n}\\n\'\n        return code\n    code = property(_get_code, doc=\'\'\'filter functions code\'\'\')\n\n\n\n\nclass Bilinear(SpatialFilter):\n    \'\'\'\n    Bilinear filter (radius = 1.0).\n\n    Weight function::\n\n      w(x) = 1 - x\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def weight(self, x):\n        return 1.0 - x\n\n\nclass Hanning(SpatialFilter):\n    \'\'\'\n    Hanning filter (radius = 1.0).\n\n    Weight function::\n\n      w(x) = 0.5 + 0.5 * cos(pi * x)\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def weight(self, x):\n        return 0.5 + 0.5 * math.cos(math.pi * x)\n\n\n\nclass Hamming(SpatialFilter):\n    \'\'\'\n    Hamming filter (radius = 1.0).\n\n    Weight function::\n\n      w(x) = 0.54 + 0.46 * cos(pi * x)\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def weight(self, x):\n        return 0.54 + 0.46 * math.cos(math.pi * x)\n\n\n\nclass Hermite(SpatialFilter):\n    \'\'\' Hermite filter (radius = 1.0).\n\n    Weight function::\n\n      w(x) = (2*x-3)*x^2 + 1\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def weight(self, x):\n        return (2.0 * x - 3.0) * x * x + 1.0\n\n\n\nclass Quadric(SpatialFilter):\n    \'\'\'\n    Quadric filter (radius = 1.5).\n\n    Weight function::\n\n             |  0.0 \xe2\x89\xa4 x < 0.5: 0.75 - x*x\n      w(x) = |  0.5 \xe2\x89\xa4 x < 1.5: 0.5 - (x-1.5)^2\n             |  1.5 \xe2\x89\xa4 x      : 0\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=1.5)\n\n    def weight(self, x):\n        if x <  0.75:\n            return 0.75 - x * x\n        elif x <  1.5:\n            t = x - 1.5\n            return 0.5 * t * t\n        else:\n            return 0.0\n\n\n\nclass Bicubic(SpatialFilter):\n    \'\'\'\n    Bicubic filter (radius = 2.0).\n\n    Weight function::\n\n      w(x) = 1/6((x+2)^3 - 4*(x+1)^3 + 6*x^3 -4*(x-1)^3)\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def pow3(self, x):\n        if x <= 0:\n            return 0\n        else:\n            return x * x * x\n\n    def weight(self, x):\n        return (1.0/6.0) * (      self.pow3(x + 2)\n                            - 4 * self.pow3(x + 1)\n                            + 6 * self.pow3(x    )\n                            - 4 * self.pow3(x - 1))\n\n\n\nclass Kaiser(SpatialFilter):\n    \'\'\'\n    Kaiser filter (radius = 1.0).\n\n\n    Weight function::\n\n      w(x) = bessel_i0(a sqrt(1-x^2)* 1/bessel_i0(b)\n\n    \'\'\'\n\n    def __init__(self, b=6.33):\n        self.a = b\n        self.epsilon = 1e-12\n        self.i0a = 1.0 / self.bessel_i0(b)\n        SpatialFilter.__init__(self, radius=1.0)\n\n    def bessel_i0(self, x):\n        s = 1.0\n        y = x * x / 4.0\n        t = y\n        i=2\n        while t > self.epsilon:\n            s += t\n            t *= float(y) / (i * i)\n            i += 1\n        return s\n\n    def weight(self, x):\n        if x > 1: return 0\n        return self.bessel_i0(self.a * math.sqrt(1.0 - x * x)) * self.i0a\n\n\n\n\nclass CatRom(SpatialFilter):\n    \'\'\'\n    Catmull-Rom filter (radius = 2.0).\n\n    Weight function::\n\n             |  0 \xe2\x89\xa4 x < 1: 0.5*(2 + x^2*(-5+x*3))\n      w(x) = |  1 \xe2\x89\xa4 x < 2: 0.5*(4 + x*(-8+x*(5-x)))\n             |  2 \xe2\x89\xa4 x    : 0\n\n    \'\'\'\n\n    def __init__(self, size=256*8):\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def weight(self, x):\n        if x < 1.0:\n            return 0.5 * (2.0 + x * x * (-5.0 + x * 3.0))\n        elif x <  2.0:\n            return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)))\n        else:\n            return 0.0\n\n\n\nclass Mitchell(SpatialFilter):\n    \'\'\'\n    Mitchell-Netravali filter (radius = 2.0).\n\n    Weight function::\n\n             |  0 \xe2\x89\xa4 x < 1: p0 + x^2*(p2 + x*p3)\n      w(x) = |  1 \xe2\x89\xa4 x < 2: q0 + x*(q1 + x*(q2 + x*q3))\n             |  2 \xe2\x89\xa4 x    : 0\n\n    \'\'\'\n\n    def __init__(self, b=1.0/3.0, c = 1.0/3.0):\n        self.p0 = (6.0 - 2.0 * b) / 6.0\n        self.p2 = (-18.0 + 12.0 * b + 6.0 * c) / 6.0\n        self.p3 = (12.0 - 9.0 * b - 6.0 * c) / 6.0\n        self.q0 = (8.0 * b + 24.0 * c) / 6.0\n        self.q1 = (-12.0 * b - 48.0 * c) / 6.0\n        self.q2 = (6.0 * b + 30.0 * c) / 6.0\n        self.q3 = (-b - 6.0 * c) / 6.0\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def weight(self, x):\n        if x < 1.0:\n            return self.p0 + x * x * (self.p2 + x * self.p3)\n        elif x < 2.0:\n            return self.q0 + x * (self.q1 + x * (self.q2 + x * self.q3))\n        else:\n            return 0.0\n\n\n\nclass Spline16(SpatialFilter):\n    \'\'\'\n    Spline16 filter (radius = 2.0).\n\n    Weight function::\n\n             |  0 \xe2\x89\xa4 x < 1: ((x-9/5)*x - 1/5)*x + 1\n      w(x) = |\n             |  1 \xe2\x89\xa4 x < 2: ((-1/3*(x-1) + 4/5)*(x-1) - 7/15 )*(x-1)\n\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def weight(self, x):\n        if x < 1.0:\n            return ((x - 9.0/5.0 ) * x - 1.0/5.0 ) * x + 1.0\n        else:\n            return ((-1.0/3.0 * (x-1) + 4.0/5.0) * (x-1) - 7.0/15.0 ) * (x-1)\n\n\n\nclass Spline36(SpatialFilter):\n    \'\'\'\n    Spline36 filter (radius = 3.0).\n\n    Weight function::\n\n             |  0 \xe2\x89\xa4 x < 1: ((13/11*x - 453/209)*x -3/209)*x +1\n      w(x) = |  1 \xe2\x89\xa4 x < 2: ((-6/11*(x-1) - 270/209)*(x-1) -156/209)*(x-1)\n             |  2 \xe2\x89\xa4 x < 3: (( 1/11*(x-2) - 45/209)*(x-2) + 26/209)*(x-2)\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=3.0)\n\n    def weight(self, x):\n        if x < 1.0:\n            return ((13.0/11.0 * x - 453.0/209.0) * x - 3.0/209.0) * x + 1.0\n        elif x < 2.0:\n            return ((-6.0/11.0 * (x-1) + 270.0/209.0) * (x-1) - 156.0/ 209.0) * (x-1)\n        else:\n           return ((1.0/11.0 * (x-2) - 45.0/209.0) * (x-2) +  26.0/209.0) * (x-2)\n\n\n\nclass Gaussian(SpatialFilter):\n    \'\'\'\n    Gaussian filter (radius = 2.0).\n\n    Weight function::\n\n      w(x) = exp(-2x^2) * sqrt(2/pi)\n\n    Note::\n\n      This filter does not seem to be correct since:\n\n        x = np.linspace(0, 1.0, 100 )\n        f = weight\n        z = f(x+1)+f(x)+f(1-x)+f(2-x)\n\n        z should be 1 everywhere but it is not the case and it produces ""grid\n        effects"".\n    \'\'\'\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=2.0)\n\n    def weight(self, x):\n        return math.exp(-2.0 * x * x) * math.sqrt(2.0 / math.pi)\n\n\n\nclass Bessel(SpatialFilter):\n    \'\'\'\n    Bessel filter (radius = 3.2383).\n    \'\'\'\n\n    def __init__(self):\n        SpatialFilter.__init__(self, radius=3.2383)\n\n\n    def besj(self, x, n):\n        \'\'\'\n        Function BESJ calculates Bessel function of first kind of order n\n        Arguments:\n            n - an integer (>=0), the order\n            x - value at which the Bessel function is required\n        --------------------\n        C++ Mathematical Library\n        Converted from equivalent FORTRAN library\n        Converted by Gareth Walker for use by course 392 computational project\n        All functions tested and yield the same results as the corresponding\n        FORTRAN versions.\n\n        If you have any problems using these functions please report them to\n        M.Muldoon@UMIST.ac.uk\n\n        Documentation available on the web\n        http://www.ma.umist.ac.uk/mrm/Teaching/392/libs/392.html\n        Version 1.0   8/98\n        29 October, 1999\n        --------------------\n        Adapted for use in AGG library by\n                    Andy Wilk (castor.vulgaris@gmail.com)\n        Adapted for use in vispy library by\n                    Nicolas P. Rougier (Nicolas.Rougier@inria.fr)\n        -----------------------------------------------------------------------\n        \'\'\'\n        if n < 0:\n            return 0.0\n\n        d = 1e-6\n        b = 0\n        if math.fabs(x) <= d:\n            if n != 0:\n                return 0\n            return 1\n\n        b1 = 0 # b1 is the value from the previous iteration\n        # Set up a starting order for recurrence\n        m1 = int(math.fabs(x)) + 6\n        if math.fabs(x) > 5:\n            m1 = int(math.fabs(1.4 * x + 60 / x))\n\n        m2 = int(n + 2 + math.fabs(x) / 4)\n        if m1 > m2:\n            m2 = m1\n\n        # Apply recurrence down from curent max order\n        while True:\n            c3 = 0\n            c2 = 1e-30\n            c4 = 0\n            m8 = 1\n            if m2 / 2 * 2 == m2:\n                m8 = -1\n\n            imax = m2 - 2\n            for i in range(1,imax+1):\n                c6 = 2 * (m2 - i) * c2 / x - c3\n                c3 = c2\n                c2 = c6\n                if m2 - i - 1 == n:\n                    b = c6\n                m8 = -1 * m8\n                if m8 > 0:\n                    c4 = c4 + 2 * c6\n\n            c6 = 2 * c2 / x - c3\n            if n == 0:\n                b = c6\n            c4 += c6\n            b /= c4\n            if math.fabs(b - b1) < d:\n                return b\n            b1 = b\n            m2 += 3\n\n\n    def weight(self, x):\n        if x == 0.0:\n            return math.pi/4.0\n        else:\n            return self.besj(math.pi * x, 1) / (2.0 * x)\n\n\n\nclass Sinc(SpatialFilter):\n    \'\'\'\n    Sinc filter (radius = 4.0).\n\n    Weight function::\n\n\n    \'\'\'\n\n    def __init__(self, size=256, radius=4.0):\n        SpatialFilter.__init__(self, radius=max(radius,2.0))\n\n    def weight(self, x):\n        if x == 0.0:\n            return 1.0\n        x *= math.pi\n        return (math.sin(x) / x)\n\n\n\nclass Lanczos(SpatialFilter):\n    \'\'\'\n    Lanczos filter (radius = 4.0).\n\n    Weight function::\n\n\n    \'\'\'\n\n    def __init__(self, size=256, radius=4.0):\n        SpatialFilter.__init__(self, radius=max(radius,2.0))\n\n    def weight(self, x):\n        if x == 0.0:\n            return 1.0\n        elif x > self.radius:\n            return 0.0\n        x *= math.pi\n        xr = x / self.radius\n        return (math.sin(x) / x) * (math.sin(xr)/xr)\n\n\n\nclass Blackman(SpatialFilter):\n    \'\'\'\n    Blackman filter (radius = 4.0).\n    \'\'\'\n\n    def __init__(self, size=256, radius=4.0):\n        SpatialFilter.__init__(self, radius=max(radius,2.0))\n\n    def weight(self, x):\n        if x == 0.0:\n            return 1.0\n        elif x > self.radius:\n            return 0.0\n        x *= math.pi\n        xr = x / self.radius\n        return (math.sin(x) / x) * (0.42 + 0.5*math.cos(xr) + 0.08*math.cos(2*xr))\n\n\n\n# Generate kernels texture (16 x 1024)\nfilters = [Bilinear(), Hanning(),  Hamming(),  Hermite(),\n           Kaiser(),   Quadric(),  Bicubic(),  CatRom(),\n           Mitchell(), Spline16(), Spline36(), Gaussian(),\n           Bessel(),   Sinc(),     Lanczos(),  Blackman()]\n\nn = 1024\nK = np.zeros((16,n))\nfor i,f in enumerate(filters):\n    K[i] = f.kernel(n)\n#    print f.call_code(i/15.0)\n\nbias = K.min()\nscale = K.max()-K.min()\nK = (K-bias)/scale\nnp.save(""spatial-filters.npy"", K.astype(np.float32))\n\nprint(""// ------------------------------------"")\nprint(""// Automatically generated, do not edit"")\nprint(""// ------------------------------------"")\nprint("""")\nprint(""const float kernel_bias  = %f;"" % bias)\nprint(""const float kernel_scale = %f;"" % scale)\nprint(""uniform sampler2D u_kernel;"")\nprint("""")\n\nF = SpatialFilter(1.0)\nprint(F.filter_code())\nF = SpatialFilter(2.0)\nprint(F.filter_code())\nF = SpatialFilter(3.0)\nprint(F.filter_code())\nF = SpatialFilter(4.0)\nprint(F.filter_code())\n\n# Generate filter functions\n# Special case for nearest\nprint(""""""vec4 Nearest(sampler2D texture, vec2 shape, vec2 uv)"""""")\nprint(""""""{ return texture2D(texture,uv); }\\n"""""")\n\nfor i,f in enumerate(filters):\n    print(f.call_code((i+0.5)/16.0))\n'"
glumpy/transforms/__init__.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . panzoom import PanZoom\nfrom . viewport import Viewport\nfrom . arcball import Arcball\nfrom . trackball import Trackball\nfrom . trackball_pan import TrackballPan\nfrom . xyz import X,Y,Z\nfrom . rotate import Rotate\nfrom . position import Position\nfrom . geoposition import GeoPosition\nfrom . translate import Translate\nfrom . transform import Transform\n\n\nfrom .albers import Albers\nfrom .polar import PolarProjection\nfrom .hammer import HammerProjection\nfrom .identity import IdentityProjection\nfrom .conic_equal_area import ConicEqualArea\nfrom .transverse_mercator import TransverseMercatorProjection\nfrom .azimuthal_equal_area import AzimuthalEqualAreaProjection\nfrom .azimuthal_equidistant import AzimuthalEquidistantProjection\n\n\n\nfrom .pvm_projection import PVMProjection\n# from perpective_projection import PerspectiveProjection\nfrom .orthographic_projection import OrthographicProjection\n\nfrom . quantitative_scale import QuantitativeScale\nfrom . log_scale import LogScale\nfrom . power_scale import PowerScale\nfrom . linear_scale import LinearScale\n'"
glumpy/transforms/_trackball.py,2,"b'# -*- coding: utf-8 -*-\n#\n# Copyright (c)  2014 Nicolas Rougier\n#                2008 Roger Allen\n#                1993, 1994, Silicon Graphics, Inc.\n# ALL RIGHTS RESERVED\n# Permission to use, copy, modify, and distribute this software for\n# any purpose and without fee is hereby granted, provided that the above\n# copyright notice appear in all copies and that both the copyright notice\n# and this permission notice appear in supporting documentation, and that\n# the name of Silicon Graphics, Inc. not be used in advertising\n# or publicity pertaining to distribution of the software without specific,\n# written prior permission.\n#\n# THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU ""AS-IS""\n# AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,\n# INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR\n# FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON\n# GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,\n# SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY\n# KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,\n# LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF\n# THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN\n# ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON\n# ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE\n# POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.\n#\n# US Government Users Restricted Rights\n# Use, duplication, or disclosure by the Government is subject to\n# restrictions set forth in FAR 52.227.19(c)(2) or subparagraph\n# (c)(1)(ii) of the Rights in Technical Data and Computer Software\n# clause at DFARS 252.227-7013 and/or in similar or successor\n# clauses in the FAR or the DOD or NASA FAR Supplement.\n# Unpublished-- rights reserved under the copyright laws of the\n# United States.  Contractor/manufacturer is Silicon Graphics,\n# Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.\n#\n# Originally implemented by Gavin Bell, lots of ideas from Thant Tessman\n# and the August \'88 issue of Siggraph\'s ""Computer Graphics,"" pp. 121-129.\n# and David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli\n#\n# Note: See the following for more information on quaternions:\n#\n# - Shoemake, K., Animating rotation with quaternion curves, Computer\n#   Graphics 19, No 3 (Proc. SIGGRAPH\'85), 245-254, 1985.\n# - Pletinckx, D., Quaternion calculus as a basic tool in computer\n#   graphics, The Visual Computer 5, 2-13, 1989.\n# -----------------------------------------------------------------------------\n\'\'\' Provides a virtual trackball for 3D scene viewing\n\nExample usage:\n\n   trackball = Trackball(45,30)\n\n   @window.event\n   def on_mouse_drag(x, y, dx, dy, button):\n       trackball.drag(x,y,dx,dy)\n\n   @window.event\n   def on_resize(width,height):\n       glViewport(0, 0, window.width, window.height)\n       glMatrixMode(GL_PROJECTION)\n       glLoadIdentity()\n       gluPerspective(45, window.width / float(window.height), .1, 1000)\n       glMatrixMode (GL_MODELVIEW)\n       glLoadIdentity ()\n       glTranslatef (0, 0, -3)\n       glMultMatrixf(trackball.model)\n\nYou can also set trackball orientation directly by setting theta and phi value\nexpressed in degrees. Theta relates to the rotation angle around X axis while\nphi relates to the rotation angle around Z axis.\n\'\'\'\nimport math\nimport numpy as np\n\n\n# Some useful functions on vectors\n# -----------------------------------------------------------------------------\ndef _v_add(v1, v2):\n    return [v1[0]+v2[0], v1[1]+v2[1], v1[2]+v2[2]]\ndef _v_sub(v1, v2):\n    return [v1[0]-v2[0], v1[1]-v2[1], v1[2]-v2[2]]\ndef _v_mul(v, s):\n    return [v[0]*s, v[1]*s, v[2]*s]\ndef _v_dot(v1, v2):\n    return v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2]\ndef _v_cross(v1, v2):\n    return [(v1[1]*v2[2]) - (v1[2]*v2[1]),\n            (v1[2]*v2[0]) - (v1[0]*v2[2]),\n            (v1[0]*v2[1]) - (v1[1]*v2[0])]\ndef _v_length(v):\n    return math.sqrt(_v_dot(v,v))\ndef _v_normalize(v):\n    try:                      return _v_mul(v,1.0/_v_length(v))\n    except ZeroDivisionError: return v\n\n# Some useful functions on quaternions\n# -----------------------------------------------------------------------------\ndef _q_add(q1,q2):\n    t1 = _v_mul(q1, q2[3])\n    t2 = _v_mul(q2, q1[3])\n    t3 = _v_cross(q2, q1)\n    tf = _v_add(t1, t2)\n    tf = _v_add(t3, tf)\n    tf.append(q1[3]*q2[3]-_v_dot(q1,q2))\n    return tf\ndef _q_mul(q, s):\n    return [q[0]*s, q[1]*s, q[2]*s, q[3]*s]\ndef _q_dot(q1, q2):\n    return q1[0]*q2[0] + q1[1]*q2[1] + q1[2]*q2[2] + q1[3]*q2[3]\ndef _q_length(q):\n    return math.sqrt(_q_dot(q,q))\ndef _q_normalize(q):\n    try:                      return _q_mul(q,1.0/_q_length(q))\n    except ZeroDivisionError: return q\ndef _q_from_axis_angle(v, phi):\n    q = _v_mul(_v_normalize(v), math.sin(phi/2.0))\n    q.append(math.cos(phi/2.0))\n    return q\ndef _q_rotmatrix(q):\n    m = np.zeros(16,np.float32)\n    m[0*4+0] = 1.0 - 2.0*(q[1]*q[1] + q[2]*q[2])\n    m[0*4+1] = 2.0 * (q[0]*q[1] - q[2]*q[3])\n    m[0*4+2] = 2.0 * (q[2]*q[0] + q[1]*q[3])\n    m[0*4+3] = 0.0\n    m[1*4+0] = 2.0 * (q[0]*q[1] + q[2]*q[3])\n    m[1*4+1] = 1.0 - 2.0*(q[2]*q[2] + q[0]*q[0])\n    m[1*4+2] = 2.0 * (q[1]*q[2] - q[0]*q[3])\n    m[1*4+3] = 0.0\n    m[2*4+0] = 2.0 * (q[2]*q[0] - q[1]*q[3])\n    m[2*4+1] = 2.0 * (q[1]*q[2] + q[0]*q[3])\n    m[2*4+2] = 1.0 - 2.0*(q[1]*q[1] + q[0]*q[0])\n    m[3*4+3] = 1.0\n    return m.reshape(4,4)\n\n\n\nclass Trackball(object):\n    """""" Virtual trackball for 3D scene viewing """"""\n\n    def __init__(self, theta=0, phi=0):\n        """""" Build a new trackball with specified view """"""\n\n        self._rotation = [0,0,0,1]\n        self._count = 0\n        self._model = np.zeros((4,4),np.float32)\n        self._RENORMCOUNT = 97\n        self._TRACKBALLSIZE = 0.8\n        self._set_orientation(theta,phi)\n        self._x = 0.0\n        self._y = 0.0\n\n    def drag_to (self, x, y, dx, dy):\n        """""" Move trackball view from x,y to x+dx,y+dy. """"""\n\n        q = self._rotate(x,y,dx,dy)\n        self._rotation = _q_add(q,self._rotation)\n        self._count += 1\n        if self._count > self._RENORMCOUNT:\n            self._rotation = _q_normalize(self._rotation)\n            self._count = 0\n        self._model = _q_rotmatrix(self._rotation)\n\n    @property\n    def model(self):\n        """""" Model transformation (read-only) """"""\n        return self._model\n\n    @property\n    def theta(self):\n        """""" Angle (in degrees) around the z axis """"""\n        self._theta, _ = self._get_orientation()\n        return self._theta\n\n    @theta.setter\n    def theta(self, theta):\n        self._set_orientation(math.fmod(theta,360.0),\n                              math.fmod(self._phi,360.0))\n\n    @property\n    def phi(self):\n        """""" Angle (in degrees) around the x axis """"""\n        _, self._phi = self._get_orientation()\n        return self._phi\n\n    @phi.setter\n    def phi(self, phi):\n        self._set_orientation(math.fmod(self._theta,360.),\n                              math.fmod(phi,360.0))\n\n\n    def _get_orientation(self):\n        \'\'\' Return current computed orientation (theta,phi). \'\'\'\n\n        q0,q1,q2,q3 = self._rotation\n        ax = math.atan(2*(q0*q1+q2*q3)/(1-2*(q1*q1+q2*q2)))*180.0/math.pi\n        az = math.atan(2*(q0*q3+q1*q2)/(1-2*(q2*q2+q3*q3)))*180.0/math.pi\n        return -az,ax\n\n    def _set_orientation(self, theta, phi):\n        \'\'\' Computes rotation corresponding to theta and phi. \'\'\'\n\n        self._theta = theta\n        self._phi = phi\n        angle = self._theta*(math.pi/180.0)\n        sine = math.sin(0.5*angle)\n        xrot = [1*sine, 0, 0, math.cos(0.5*angle)]\n        angle = self._phi*(math.pi/180.0)\n        sine = math.sin(0.5*angle);\n        zrot = [0, 0, sine, math.cos(0.5*angle)]\n        self._rotation = _q_add(xrot, zrot)\n        self._model = _q_rotmatrix(self._rotation)\n\n\n    def _project(self, r, x, y):\n        \'\'\' Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet\n            if we are away from the center of the sphere.\n        \'\'\'\n\n        d = math.sqrt(x*x + y*y)\n        if (d < r * 0.70710678118654752440):    # Inside sphere\n            z = math.sqrt(r*r - d*d)\n        else:                                   # On hyperbola\n            t = r / 1.41421356237309504880\n            z = t*t / d\n        return z\n\n\n    def _rotate(self, x, y, dx, dy):\n        \'\'\' Simulate a track-ball.\n\n            Project the points onto the virtual trackball, then figure out the\n            axis of rotation, which is the cross product of x,y and x+dx,y+dy.\n\n            Note: This is a deformed trackball-- this is a trackball in the\n            center, but is deformed into a hyperbolic sheet of rotation away\n            from the center.  This particular function was chosen after trying\n            out several variations.\n        \'\'\'\n\n        if not dx and not dy:\n            return [ 0.0, 0.0, 0.0, 1.0]\n        last = [x, y,       self._project(self._TRACKBALLSIZE, x, y)]\n        new  = [x+dx, y+dy, self._project(self._TRACKBALLSIZE, x+dx, y+dy)]\n        a = _v_cross(new, last)\n        d = _v_sub(last, new)\n        t = _v_length(d) / (2.0*self._TRACKBALLSIZE)\n        if (t > 1.0): t = 1.0\n        if (t < -1.0): t = -1.0\n        phi = 2.0 * math.asin(t)\n        return _q_from_axis_angle(a,phi)\n'"
glumpy/transforms/albers.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAn alias for ConicEqualArea, with USA-centric defaults:\n\n   scale:      1285\n   translate:  (960, 500)\n   rotation:   96\xc2\xb0, 0\xc2\xb0\n   center:     -0.6\xc2\xb0, 38.7\xc2\xb0\n   parallels:  29.5\xc2\xb0, 45.5\xc2\xb0\n\nThis makes it suitable for displaying the United States, centered around\nHutchinson, Kansas in a 960\xc3\x97500 area. The central meridian and parallels are\nspecified by the USGS in the 1970 National Atlas.  Albers projection\n\nSee: https://github.com/mbostock/d3/blob/master/src/geo/conic-equal-area.js\n     http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html\n     http://en.wikipedia.org/wiki/Albers_projection\n""""""\nfrom . conic_equal_area import ConicEqualArea\n\nAlbers = ConicEqualArea(scale=1285,\n                        parallels = (29.5, 45.5),\n                        rotate = (96,0),\n                        translate = (480,250),\n                        center = (0.01, -0.6)) # to be fixed using geo_rotation\n'"
glumpy/transforms/arcball.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom . transform import Transform\nfrom glumpy import gl, glm, library\n\n\nclass Arcball(Transform):\n    """"""\n    3D arcball transform\n\n    :param float aspect:\n       Indicate what is the aspect ratio of the object displayed. This is\n       necessary to convert pixel drag move in oject space coordinates.\n       Default is None.\n\n    :param float znear:\n       Near clip plane. Default is 2.\n\n    :param float zfar: \n       Distance clip plane. Default is 1000.\n\n    :param float theta:\n       Angle (in degrees) around the z axis. Default is 0.\n\n    :param float phi: \n       Angle (in degrees) around the x axis. Default is 0.\n\n    :param float distance:\n       Distance from the arcball to the object.  Default is 8.\n\n    :param float zoom:\n           Zoom level. Default is 35.\n\n    The arcball transform simulates a virtual arcball (3D) that can rotate\n    around the origin using intuitive mouse gestures.\n\n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n      * ``on_resize``: Tranform update to maintain aspect\n      * ``on_mouse_scroll``: Zoom in & out (user action)\n      * ``on_mouse_grab``: Drag (user action)\n\n    **Usage example**:\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec2 position;\n         void main()\n         {\n             gl_Position = <transform>(vec4(position, 0.0, 1.0));\n         } \'\'\'\n\n         ...\n         window = app.Window(width=800, height=800)\n         program = gloo.Program(vertex, fragment, count=4)\n         ...\n         program[\'transform\'] = Arcball(aspect=1)\n         window.attach(program[\'transform\'])\n         ...\n    """"""\n\n    aliases = { ""view""       : ""arcball_view"",\n                ""model""      : ""arcball_model"",\n                ""projection"" : ""arcball_projection"" }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        """"""\n\n        code = library.get(""transforms/arcball.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n        self._aspect = Transform._get_kwarg(""aspect"", kwargs) or 1\n        self._znear = Transform._get_kwarg(""znear"", kwargs) or 2.0\n        self._zfar = Transform._get_kwarg(""zfar"", kwargs) or 1000.0\n        self._theta = Transform._get_kwarg(""theta"", kwargs) or 0\n        self._phi = Transform._get_kwarg(""phi"", kwargs) or 0\n        self._distance = Transform._get_kwarg(""distance"", kwargs) or 8\n        self._zoom = Transform._get_kwarg(""zoom"", kwargs) or 35\n        self._width = 1\n        self._height = 1\n        self._window_aspect = 1\n\n        self._projection = np.eye(4, dtype=np.float32)\n        self._view = np.eye(4, dtype=np.float32)\n        self._model = np.eye(4, dtype=np.float32)\n        glm.translate(self._view, 0, 0, -abs(self._distance))\n\n\n    @property\n    def distance(self):\n        """""" Distance from the trackball to the object """"""\n\n        return self._distance\n\n    @distance.setter\n    def distance(self, distance):\n        """""" Distance from the trackball to the object """"""\n\n        self._distance = abs(distance)\n        self._view = np.eye(4, dtype=np.float32)\n        glm.translate(self._view, 0, 0, -abs(self._distance))\n        self[""view""] = self._view\n\n\n    @property\n    def theta(self):\n        """""" Angle (in degrees) around the z axis """"""\n\n        return self._theta\n\n    @theta.setter\n    def theta(self, theta):\n        """""" Angle (in degrees) around the z axis """"""\n\n        self._theta = theta\n        model = np.eye(4, dtype=np.float32)\n        glm.rotate(model, self._theta, 0, 0, 1)\n        glm.rotate(model, self._phi, 1, 0, 0)\n        self[""model""] = model\n\n    @property\n    def phi(self):\n        """""" Angle (in degrees) around the x axis """"""\n\n        return self._trackball.phi\n\n    @phi.setter\n    def phi(self, phi):\n        """""" Angle (in degrees) around the x axis """"""\n\n        self._phi = phi\n        model = np.eye(4, dtype=np.float32)\n        glm.rotate(model, self._theta, 0, 0, 1)\n        glm.rotate(model, self._phi, 1, 0, 0)\n        self[""model""] = model\n\n\n    @property\n    def zoom(self):\n        """""" Zoom level (aperture angle in degrees) """"""\n\n        return self._zoom\n\n\n    @phi.setter\n    def zoom(self, value):\n        """""" Zoom level (aperture angle in degrees) """"""\n\n        aspect = self._window_aspect * self._aspect\n        self._zoom = min(max(value, 1.0), 179.0)\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n\n    @property\n    def aspect(self):\n        """""" Projection aspect """"""\n\n        return self._aspect\n\n\n    @aspect.setter\n    def aspect(self, value):\n        """""" Projection aspect """"""\n\n        aspect = self._window_aspect * self._aspect\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n    \n\n    def on_attach(self, program):\n        self[""view""] = self._view\n        self[""model""] = self._model\n        self[""projection""] = self._projection\n\n\n    def on_resize(self, width, height):\n        self._width  = float(width)\n        self._height = float(height)\n        self._window_aspect = self._width / self._height\n        aspect = self._window_aspect * self._aspect\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n        Transform.on_resize(self, width, height)\n\n\n    def on_mouse_drag(self, x, y, dx, dy, button):\n        model = np.eye(4, dtype=np.float32)\n        self._theta -= dx/5.0\n        self._phi += dy/5.0\n        glm.rotate(model, self._theta, 0, 0, 1)\n        glm.rotate(model, self._phi, 1, 0, 0)\n        self[""model""] = model\n\n\n    def on_mouse_scroll(self, x, y, dx, dy):\n        width = self._width\n        height = self._height\n        aspect = self._window_aspect * self._aspect\n        self._zoom = min(max(self._zoom*(1-dy/100), 1.0), 179.0)\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n'"
glumpy/transforms/azimuthal_equal_area.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAzimuthal Equal Area projection\n""""""\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass AzimuthalEqualAreaProjection(Transform):\n    """""" Azimuthal Equal Area projection """"""\n\n    aliases = {  }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        Note that parameters must be passed by name (param=value).\n\n        Kwargs parameters\n        -----------------\n        """"""\n\n        code = library.get(""transforms/azimuthal-equal-area.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n\n    def on_attach(self, program):\n        """""" Initialization event """"""\n\n        pass\n'"
glumpy/transforms/azimuthal_equidistant.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAzimuthal Equidistant projection\n""""""\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass AzimuthalEquidistantProjection(Transform):\n    """""" Azimuthal Equidistant projection """"""\n\n    aliases = {  }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        Note that parameters must be passed by name (param=value).\n\n        Kwargs parameters\n        -----------------\n        """"""\n\n        code = library.get(""transforms/azimuthal-equidistant.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n\n    def on_attach(self, program):\n        """""" Initialization event """"""\n\n        pass\n'"
glumpy/transforms/conic_equal_area.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nConic Equal Area projection\n\nSee: https://github.com/mbostock/d3/blob/master/src/geo/conic-equal-area.js\n     http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html\n     http://en.wikipedia.org/wiki/Albers_projection\n""""""\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass ConicEqualArea(Transform):\n    """""" Conic Equal Area projection """"""\n\n    aliases = { ""clip""      : ""conic_clip"",\n                ""scale""     : ""conic_scale"",\n                ""center""    : ""conic_center"",\n                ""rotate""    : ""conic_rotate"",\n                ""translate"" : ""conic_translate"",\n                ""parallels"" : ""conic_parallels"" }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        Note that parameters must be passed by name (param=value).\n\n        Kwargs parameters\n        -----------------\n\n\n        clip : tuple of 4 floats\n\n\n        scale : float\n            Scale factor applied to normalized Cartesian coordinates\n\n        center : float, float\n            Center of the projection as (longitude,latitude)\n\n        rotate : float, float, [float]\n            Rotation as yaw, pitch and roll.\n\n        translate : float, float\n            Translation (in scaled coordinates)\n\n        parallels : float, float\n            Parallels as define in conic equal area projection.\n        """"""\n\n        self._clip = Transform._get_kwarg(""clip"", kwargs, (-180,180,-90,90))\n        self._scale = Transform._get_kwarg(""scale"", kwargs, 1.0)\n        self._center = Transform._get_kwarg(""center"", kwargs, (0,0))\n        self._rotate = Transform._get_kwarg(""rotate"", kwargs, (0,0))\n        self._translate = Transform._get_kwarg(""translate"", kwargs, (0,0))\n        self._parallels = Transform._get_kwarg(""parallels"", kwargs, (0,90))\n        code = library.get(""transforms/conic-equal-area.glsl"")\n\n        # Make sure to call the forward function\n        kwargs[""call""] = ""forward""\n\n        Transform.__init__(self, code, *args, **kwargs)\n\n\n    @property\n    def scale(self):\n        return self._scale\n\n    @scale.setter\n    def scale(self, value):\n        self._scale = float(value)\n        if self.is_attached:\n            self[""scale""] = self._scale\n\n    @property\n    def clip(self):\n        return self._clip\n\n    @clip.setter\n    def clip(self, value):\n        self._clip = float(value)\n        if self.is_attached:\n            self[""clip""] = self._clip\n\n\n    @property\n    def translate(self):\n        return self._translate\n\n    @translate.setter\n    def translate(self, value):\n        self._translate = float(value)\n        if self.is_attached:\n            self[""translate""] = self._translate\n\n    @property\n    def center(self):\n        return self._center\n\n    @center.setter\n    def center(self, value):\n        self._center = value\n        if self.is_attached:\n            self[""center""] = self._center\n\n    @property\n    def rotate(self):\n        return self._rotate\n\n    @rotate.setter\n    def rotate(self, value):\n        self._rotate = value\n        if self.is_attached:\n            self[""rotate""] = self._rotate\n\n    @property\n    def parallels(self):\n        return self._parallels\n\n    @parallels.setter\n    def parallels(self, value):\n        self._parallels = value\n        if self.is_attached:\n            self[""parallels""] = self._parallels\n\n\n    def on_attach(self, program):\n        """""" Initialization event """"""\n\n        self[""clip""] = self._clip\n        self[""scale""] = self._scale\n        self[""center""] = self._center\n        self[""rotate""] = self._rotate\n        self[""translate""] = self._translate\n        self[""parallels""] = self._parallels\n'"
glumpy/transforms/geoposition.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass GeoPosition(Transform):\n    \n    def __init__(self, *args, **kwargs):\n        code = library.get(""transforms/geo-position.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n'"
glumpy/transforms/hammer.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nHammer projection (http://en.wikipedia.org/wiki/Hammer_projection)\n""""""\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass HammerProjection(Transform):\n    """""" Hammer projection """"""\n\n    aliases = {  }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        Note that parameters must be passed by name (param=value).\n\n        Kwargs parameters\n        -----------------\n        """"""\n\n        code = library.get(""transforms/hammer.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n\n    def on_attach(self, program):\n        """""" Initialization event """"""\n\n        pass\n'"
glumpy/transforms/identity.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import library\nfrom . transform import Transform\n\nclass IdentityProjection(Transform):\n    def __init__(self, *args, **kwargs):\n        code = library.get(""transforms/position.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n'"
glumpy/transforms/linear_scale.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import library\nfrom . transform import Transform\nfrom . quantitative_scale import QuantitativeScale\n\n\nclass LinearScale(QuantitativeScale):\n    """"""\n    Linear scales are the most common scale, and a good default choice to map a\n    continuous input domain to a continuous output range. The mapping is linear\n    in that the output range value y can be expressed as a linear function of\n    the input domain value x: y = mx + b. The input domain is typically a\n    dimension of the data that you want to visualize, such as the height of\n    students (measured in meters) in a sample population. The output range is\n    typically a dimension of the desired output visualization, such as the\n    height of bars (measured in pixels) in a histogram.\n\n    :param 2-tuple domain: Input domains. Default is (-1,+1).\n    :param 2-tuple range: Output range. Default is (-1,+1).\n    :param bool clamp: Clamping test. Default is False.\n    :param bool discard: Discard test. Default is True.\n    """"""\n\n    aliases = { ""domain""  : ""linear_scale_domain"",\n                ""range""   : ""linear_scale_range"",\n                ""clamp""   : ""linear_scale_clamp"",\n                ""discard"" : ""linear_scale_discard"" }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        """"""\n        code = library.get(""transforms/linear-scale.glsl"")\n        QuantitativeScale.__init__(self, code, *args, **kwargs)\n'"
glumpy/transforms/log_scale.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import library\nfrom . transform import Transform\nfrom . quantitative_scale import QuantitativeScale\n\n\nclass LogScale(QuantitativeScale):\n    """"""\n    Log scales are similar to linear scales, except there\'s a logarithmic\n    transform that is applied to the input domain value before the output range\n    value is computed. The mapping to the output range value y can be expressed\n    as a function of the input domain value x: y = m log(x) + b.\n\n    As log(0) is negative infinity, a log scale must have either an\n    exclusively-positive or exclusively-negative domain; the domain must not\n    include or cross zero. A log scale with a positive domain has a\n    well-defined behavior for positive values, and a log scale with a negative\n    domain has a well-defined behavior for negative values (the input value is\n    multiplied by -1, and the resulting output value is also multiplied by\n    -1). The behavior of the scale is undefined if you pass a negative value to\n    a log scale with a positive domain or vice versa.\n\n\n    :param 2-tuple domain: Input domains. Default is (-1,+1).\n    :param 2-tuple range: Output range. Default is (-1,+1).\n    :param float base: Log base. Default is 10.\n    :param bool clamp: Clamping test. Default is False.\n    :param bool discard: Discard test. Default is True.\n    """"""\n\n    aliases = { ""domain""  : ""log_scale_domain"",\n                ""range""   : ""log_scale_range"",\n                ""clamp""   : ""log_scale_clamp"",\n                ""base""    : ""log_scale_base"",\n                ""discard"" : ""log_scale_discard"" }\n\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform\n        """"""\n\n        self._base = float(Transform._get_kwarg(""base"", kwargs) or 10.0)\n        kwargs[""domain""] = kwargs.get(""domain"", (1,10))\n        code = library.get(""transforms/log-scale.glsl"")\n        QuantitativeScale.__init__(self, code, *args, **kwargs)\n\n\n\n    @property\n    def base(self):\n        """""" Input base """"""\n        return self._base\n\n\n    @base.setter\n    def base(self, value):\n        """""" Input base """"""\n        self._base = np.abs(float(value))\n        if self.is_attached:\n            self[""base""] = self._base\n            self[""domain""] = self._process_domain()\n\n\n    def on_attach(self, program):\n        QuantitativeScale.on_attach(self, program)\n        self[""base""] = self._base\n\n\n    def _scale(self,index):\n        domain = self._domain\n        base = self._base\n        return np.copysign(1.0,domain) * np.log(np.abs(domain))/np.log(base)\n'"
glumpy/transforms/orthographic_projection.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import glm, library\nfrom . transform import Transform\n\nclass OrthographicProjection(Transform):\n    """"""\n    Orthographic projection (or orthogonal projection) is a means of\n    representing a three-dimensional object in two dimensions. It is a form of\n    parallel projection, where all the projection lines are orthogonal to the\n    projection plane, resulting in every plane of the scene appearing in\n    affine transformation on the viewing surface.\n\n    :param float aspect: \n       Aspect ratio (width/height). Default is None.\n\n    :param bool xinvert:\n       Whether to invert X axis. Default is False.\n\n    :param bool yinvert: \n       Whether to invert Y axis. Default is False.\n\n    :param int znear: \n       Z near clipping place. Default is -1000.\n\n    :param int zfar: \n       Z far clipping place. Default is +1000.\n\n    :param bool normalize: \n       Whether to use normalized device coordinates. Default is False\n\n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n      * ``on_resize``: Recompute projection matrix\n\n\n    **Usage example**\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec2 position;\n         void main()\n         {\n             gl_Position = <transform>;\n         } \'\'\'\n         fragment = \'\'\'\n         void main()\n         {\n             gl_FragColor = vec4(1,0,0,1);\n         } \'\'\'\n\n         window = app.Window()\n       \n         @window.event\n         def on_draw(dt):\n             window.clear()\n             quad.draw(gl.GL_TRIANGLE_STRIP)\n\n         @window.event\n         def on_resize(w, h):\n             quad[\'position\'] = [(w-100,h-100), (w-100,h), (w,h-100), (w,h)]\n\n         quad = gloo.Program(vertex, fragment, count=4)\n         quad[""transform""] = OrthographicProjection(Position(""position""))\n         window.attach(quad[""transform""])\n         app.run()\n    """"""\n\n    def __init__(self, *args, **kwargs):\n\n        code = library.get(""transforms/projection.glsl"")\n\n        self._width     = None\n        self._height    = None\n        self._aspect    = Transform._get_kwarg(""aspect"", kwargs) or None\n        self._xinvert   = Transform._get_kwarg(""xinvert"", kwargs) or False\n        self._yinvert   = Transform._get_kwarg(""yinvert"", kwargs) or False\n        self._znear     = Transform._get_kwarg(""znear"", kwargs) or -1000\n        self._zfar      = Transform._get_kwarg(""znear"", kwargs) or +1000\n        self._normalize = Transform._get_kwarg(""normalize"", kwargs) or False\n        Transform.__init__(self, code, *args, **kwargs)\n\n        \n    @property\n    def aspect(self):\n        """""" Aspect ratio """"""\n        \n        return self._aspect\n\n    @aspect.setter\n    def aspect(self, value):\n        """""" Aspect ratio """"""\n        \n        self._aspect = value\n        self._build_projection()\n\n    @property\n    def normalize(self):\n        """""" Whether to use normalized coordinates """"""\n        \n        return self._normalize\n\n    @normalize.setter\n    def normalize(self, value):\n        """""" Whether to use normalized coordinates """"""\n        \n        self._normalize = value\n        self._build_projection()\n\n    @property\n    def xinvert(self):\n        """""" Whether to invert x axis """"""\n        \n        return self._xinvert\n\n    @xinvert.setter\n    def xinvert(self, value):\n        """""" Whether to invert x axis """"""\n        \n        self._xinvert = value\n        self._build_projection()\n\n    @property\n    def yinvert(self):\n        """""" Whether to invert y axis """"""\n\n        return self._xinvert\n\n    @yinvert.setter\n    def yinvert(self, value):\n        """""" Whether to invert y axis """"""\n\n        self._yinvert = value\n        self._build_projection()\n\n        \n    @property\n    def znear(self):\n        """""" Z near clipping place """"""\n\n        return self._znear\n\n    @znear.setter\n    def znear(self, value):\n        """""" Z near clipping place """"""\n\n        if value < self._zfar:\n            self._znear = value\n            self._build_projection()\n\n        \n    @property\n    def zfar(self):\n        """""" Z far clipping place """"""\n        return self._znear\n\n    @zfar.setter\n    def zfar(self, value):\n        """""" Z near clipping place """"""\n\n        if value > self._znear:\n            self._zfar = value\n            self._build_projection()\n\n            \n    def on_resize(self, width, height):\n        self._width  = width\n        self._height = height\n\n        # Build projection matrix\n        self._build_projection()\n        \n        # Propagate event to children\n        Transform.on_resize(self, width, height)\n\n        \n    def _build_projection(self):\n\n        # We need to have caught at least one resize event\n        if self._width is None: return\n        \n        # Compute new Projection\n        xmin, xmax = 0, self._width\n        ymin, ymax = 0, self._height\n        if self._normalize:\n            xmin, xmax = -1, +1\n            ymin, ymax = -1, +1\n        if self._xinvert:\n            xmin, xmax = xmax, xmin\n        if self._yinvert:\n            ymin, ymax = ymax, ymin\n\n        aspect = self._aspect\n        if aspect is not None:\n            if aspect > 1.0:\n                xmin *= (aspect*self._width)/self._height\n                xmax *= (aspect*self._width)/self._height\n            else:\n                ymin /= (aspect*self._width)/self._height\n                ymax /= (aspect*self._width)/self._height\n\n        znear, zfar = self._znear, self._zfar\n        self[""projection""] = glm.ortho(xmin, xmax, ymin, ymax, znear, zfar)\n'"
glumpy/transforms/panzoom.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import library\nfrom . transform import Transform\n\nclass PanZoom(Transform):\n    """"""\n    2D pan & zoom transform.\n\n    :param float aspect:\n       Indicate what is the aspect ratio of the object displayed. This is\n       necessary to convert pixel drag move in oject space coordinates.\n       Default is None.\n\n    :param float,float pan: \n       Initial translation. Default is (0,0)\n\n    :param float,float zoom: \n       Initial zoom level. Default is (1,1)\n\n    :param float zoom_min:\n       Minimal zoom level. Default is 0.01\n\n    :param float zoom_max:\n        Minimal zoom level. Default is 1000.0\n\n\n    The panzoom transform allow to translate and scale a scene in the window\n    space coordinate (2D). This means that whatever point you grab on the\n    screen, it should remains under the mouse pointer. Zoom is realized using\n    the mouse scroll and is always centered on the mouse pointer.\n\n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n      * ``on_resize``: Tranform update to maintain aspect\n      * ``on_mouse_scroll``: Zoom in & out (user action)\n      * ``on_mouse_grab``: Pan (user action)\n\n\n    **Usage example**:\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec2 position;\n         void main()\n         {\n             gl_Position = <transform>(vec4(position, 0.0, 1.0));\n         } \'\'\'\n\n         ...\n         window = app.Window(width=800, height=800)\n         program = gloo.Program(vertex, fragment, count=4)\n         ...\n         program[\'transform\'] = PanZoom(aspect=1)\n         window.attach(program[\'transform\'])\n         ...\n    """"""\n\n    aliases = { ""pan""       : ""panzoom_translate"",\n                ""translate"" : ""panzoom_translate"",\n                ""zoom""      : ""panzoom_scale"",\n                ""scale""     : ""panzoom_scale"" }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        """"""\n\n        code = library.get(""transforms/panzoom.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n        self._aspect = Transform._get_kwarg(""aspect"", kwargs) or None\n        self._pan = np.array(Transform._get_kwarg(""pan"", kwargs) or (0.,0.))\n        self._zoom_min = Transform._get_kwarg(""zoom_min"", kwargs) or 0.01\n        self._zoom_max = Transform._get_kwarg(""zoom_max"", kwargs) or 1000\n        self._zoom = Transform._get_kwarg(""zoom"", kwargs) or 1\n        self._width = 1\n        self._height = 1\n        self._window_aspect = np.asarray([1.,1.])\n\n\n    @property\n    def aspect(self):\n        """""" Aspect (width/height) """"""\n\n        return self._aspect\n\n    @aspect.setter\n    def aspect(self, value):\n        """""" Aspect (width/height) """"""\n\n        self._aspect = value\n\n\n    @property\n    def pan(self):\n        """""" Panning (translation) """"""\n        return self._pan\n\n    @pan.setter\n    def pan(self, value):\n        """""" Panning (translation) """"""\n\n        self._pan = np.asarray(value)\n        if self.is_attached:\n            self[""pan""] = self._pan\n\n\n    @property\n    def zoom(self):\n        """""" Zoom level """"""\n\n        return self._zoom\n\n    @zoom.setter\n    def zoom(self, value):\n        """""" Zoom level """"""\n\n        self._zoom = np.clip(value, self._zoom_min, self._zoom_max)\n\n        if self.is_attached:\n            aspect = 1.0\n            if self._aspect is not None:\n                aspect = self._window_aspect * self._aspect\n            self[""zoom""] = self._zoom * aspect\n\n\n    @property\n    def zoom_min(self):\n        """""" Minimal zoom level """"""\n\n        return self._zoom_min\n\n    @zoom_min.setter\n    def zoom_min(self, value):\n        """""" Minimal zoom level """"""\n\n        self._zoom_min = min(value, self._zoom_max)\n\n\n    @property\n    def zoom_max(self):\n        """""" Maximal zoom level """"""\n\n        return self._zoom_max\n\n    @zoom_max.setter\n    def zoom_max(self, value):\n        """""" Maximal zoom level """"""\n\n        self._zoom_max = max(value, self._zoom_min)\n\n\n    def reset(self):\n        """""" Reset transform (zoom=1, pan=(0,0)) """"""\n\n        self.zoom = 1\n        self.pan = 0,0\n\n\n    def on_attach(self, program):\n        self[""pan""] = self.pan\n        aspect = 1.0\n        if self._aspect is not None:\n            aspect = self._window_aspect * self._aspect\n        self[""zoom""] = self.zoom * aspect\n\n\n    def on_resize(self, width, height):\n        self._width = float(width)\n        self._height = float(height)\n        aspect = self._width/self._height\n        if aspect > 1.0:\n            self._window_aspect = np.array([1.0/aspect, 1.0])\n        else:\n            self._window_aspect = np.array([1.0, aspect/1.0])\n\n        aspect = 1.0\n        if self._aspect is not None:\n            aspect = self._window_aspect * self._aspect\n        self[""zoom""] = self.zoom * aspect\n\n        # Transmit signal to other transforms\n        Transform.on_resize(self, width, height)\n\n\n    def on_mouse_scroll(self, x, y, dx, dy):\n        # Normalize mouse coordinates and invert y axis\n        x = x/(self._width/2.) - 1.\n        y = 1.0 - y/(self._height/2.)\n\n        zoom = np.clip(self._zoom*(1.0+dy/100.0), self.zoom_min, self.zoom_max)\n        ratio = zoom / self.zoom\n        xpan = x-ratio*(x-self.pan[0])\n        ypan = y-ratio*(y-self.pan[1])\n        self.zoom = zoom\n        self.pan = xpan, ypan\n\n\n    def on_mouse_drag(self, x, y, dx, dy, button):\n        dx =  2*(dx / self._width)\n        dy = -2*(dy / self._height)\n        self.pan = self.pan + (dx,dy)\n'"
glumpy/transforms/perspective_projection.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import glm\nfrom . transforms import Transform\n\n\nclass PerspectiveProjection(Transform):\n\n    shaderfile = ""projection.glsl""\n\n    def __init__(self, *args, **kwargs):\n        Transform.__init__(self, *args, **kwargs)\n\n        self._fovy = 40\n        self._znear, self._zfar = 0, 1000\n        self._projection = np.eye(4)\n\n\n    def on_resize(self, width, height):\n        fovy = self._fovy\n        aspect = width / float(height)\n        znear, zfar = self._znear, _zfar\n        self[""projection""] = glm.perspective(fovy, aspect, znear, zfar)\n'"
glumpy/transforms/polar.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nPolar projection\n\nRegular projection using x as rho and y as theta.\n\n\nThe transform is connected to the following events:\n\n * attach (initialization)\n\n""""""\nfrom glumpy import library\nfrom . transform import Transform\n\nclass PolarProjection(Transform):\n    """""" Polar projection """"""\n\n    aliases = { ""origin"" : ""polar_origin"" }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        Note that parameters must be passed by name (param=value).\n\n        Kwargs parameters\n        -----------------\n\n        origin : float (default is 0)\n            Angle origin (radians)\n        """"""\n\n        self._origin = Transform._get_kwarg(""origin"", kwargs) or 0.0\n        code = library.get(""transforms/polar.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n\n\n    @property\n    def origin(self):\n        """""" Angle origin (radians) """"""\n\n        return self._origin\n\n\n    @origin.setter\n    def origin(self, value):\n        """""" Angle origin (radians) """"""\n\n        self._origin = float(value)\n        if self.is_attached:\n            self[""origin""] = self._origin\n\n\n    def on_attach(self, program):\n        """""" Initialization event """"""\n\n        self[""origin""] = self._origin\n'"
glumpy/transforms/position.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass Position(Transform):\n    """"""\n    Generic position transform\n\n    The position transform is a convenient transform that takes any positional\n    format and transform it in a vec4 format. It works thanks to GLSL function\n    overloading.\n\n    **Usage example**:\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec2 position;\n         void main()\n         {\n             ... \n             gl_Position = <transform>;\n         } \'\'\'\n\n         fragment = ...\n \n         window = app.Window(400,400)\n         ...\n         program = Program(vertex, fragment)\n         program[""transform""] = Position(""position"")\n         # or program[""transform""] = Position(""position.y"",""position.x"")\n         # or program[""transform""] = Position(""vec2(position.y,position.x""))\n         ...\n    """"""\n    \n    def __init__(self, *args, **kwargs):\n        code = library.get(""transforms/position.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n'"
glumpy/transforms/power_scale.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import library\nfrom . transform import Transform\nfrom . quantitative_scale import QuantitativeScale\n\n\nclass PowerScale(QuantitativeScale):\n    """"""\n    Power scales are similar to linear scales, except there\'s an exponential\n    transform that is applied to the input domain value before the output range\n    value is computed. The mapping to the output range value y can be expressed\n    as a function of the input domain value x: y = mx^k + b, where k is the\n    exponent value. Power scales also support negative values, in which case\n    the input value is multiplied by -1, and the resulting output value is also\n    multiplied by -1.\n\n    :param 2-tuple domain: Input domains. Default is (-1,+1).\n    :param 2-tuple range: Output range. Default is (-1,+1).\n    :param float exponent: Power exponent. Default is 1.\n    :param bool clamp: Clamping test. Default is False.\n    :param bool discard: Discard test. Default is True.\n    """"""\n\n    aliases = { ""domain""   : ""power_scale_domain"",\n                ""range""    : ""power_scale_range"",\n                ""clamp""    : ""power_scale_clamp"",\n                ""discard""  : ""power_scale_discard"",\n                ""exponent"" : ""power_scale_exponent"" }\n\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        """"""\n\n        self._exponents = Transform._get_kwarg(""exponent"", kwargs, 1.0)\n        code = library.get(""transforms/power-scale.glsl"")\n        QuantitativeScale.__init__(self, code, *args, **kwargs)\n\n\n    @property\n    def exponent(self):\n        """""" Input exponent for xyz """"""\n        return self._exponents\n\n\n    @exponent.setter\n    def exponent(self, value):\n        self._exponents = abs(float(value))\n        if self.is_attached:\n            self[""exponent""] = self._exponents\n            self[""domain""] = self._process_domain()\n\n\n    def on_attach(self, program):\n        QuantitativeScale.on_attach(self, program)\n        self[""exponent""] = self._exponents\n\n\n    def _process_domain(self):\n        domain = self._domain\n        exponent = self._exponents\n        domain = np.copysign(1,domain) * np.power(np.abs(domain), exponent)\n        return domain\n'"
glumpy/transforms/pvm_projection.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom . transform import Transform\nfrom glumpy import gl, glm, library\n\n\nclass PVMProjection(Transform):\n    """"""\n    Perspective projection is an approximate representation, on a flat surface\n    of an image as it is seen by the eye. The two most characteristic features\n    of perspective are that objects are smaller as their distance from the\n    observer increases; and that they are subject to foreshortening, meaning\n    that an object\'s dimensions along the line of sight are shorter than its\n    dimensions across the line of sight.\n\n    :param float distance:\n       Distance of the camera to the origin. Default is 5.\n\n    :param bool fovy: \n       Field of view along y axis. Default is 40.\n\n    :param int znear: \n       Z near clipping place. Default is 2.\n\n    :param int zfar: \n       Z far clipping place. Default is 100.\n\n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n      * ``on_resize``: Recompute projection matrix\n\n    **Usage example**\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec3 position;\n         attribute vec4 color;\n         void main()\n         {\n             v_color = color;\n             gl_Position = <transform>;\n         } \'\'\'\n\n         fragment = \'\'\'\n         varying vec4 v_color;\n         void main()\n         {\n             gl_FragColor = v_color;\n         } \'\'\'\n\n         window = app.Window()\n\n         @window.event\n         def on_draw(dt):\n             global phi, theta\n             window.clear()\n             cube.draw(gl.GL_TRIANGLES, I)\n\n             theta += 0.5 # degrees\n             phi += 0.5 # degrees\n             model = np.eye(4, dtype=np.float32)\n             glm.rotate(model, theta, 0, 0, 1)\n             glm.rotate(model, phi, 0, 1, 0)\n             cube[\'transform\'][\'model\'] = model\n\n         V, I, O = colorcube()\n         cube = gloo.Program(vertex, fragment)\n         cube.bind(V)\n         cube[\'transform\'] = PVMProjection(Position(""position""))\n         window.attach(cube[\'transform\'])\n\n         phi, theta = 0, 0\n         app.run()\n    \n    \n    """"""\n\n    \n    def __init__(self, *args, **kwargs):\n        code = library.get(""transforms/pvm.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n        self._width     = None\n        self._height    = None\n        self._distance = Transform._get_kwarg(""distance"", kwargs) or 5\n        self._fovy     = Transform._get_kwarg(""fovy"", kwargs) or 40\n        self._znear    = Transform._get_kwarg(""znear"", kwargs) or 2.0\n        self._zfar     = Transform._get_kwarg(""zfar"", kwargs) or 100.0\n        self._view = np.eye(4, dtype=np.float32)\n        self._model = np.eye(4, dtype=np.float32)\n        self._projection = np.eye(4, dtype=np.float32)\n        glm.translate(self._view, 0, 0, -self._distance)\n\n\n    @property\n    def view(self):\n        """""" View matrix """"""\n\n        return self._view\n\n    @property\n    def model(self):\n        """""" Model matrix """"""\n\n        return self._model\n\n    @property\n    def projection(self):\n        """""" Projection matrix """"""\n\n        return self._projection\n\n    @property\n    def distance(self):\n        """""" Distance of the camera to the origin """"""\n\n        return self._distance\n\n    @distance.setter\n    def distance(self, value):\n        """""" Distance of the camera to the origin """"""\n\n        if value > 1:\n            self._distance = value\n            self._view = np.eye(4, dtype=np.float32)\n            glm.translate(self._view, 0, 0, -self._distance)\n            self[""view""] = self._view\n\n    @property\n    def fovy(self):\n        """""" Field of view along y axis """"""\n\n        return self._fovy\n\n    @fovy.setter\n    def fovy(self, value):\n        """""" Field of view along y axis """"""\n\n        if 0 < fovy < 90:\n            self._fovy = value\n            self._build_projection()\n\n    @property\n    def znear(self):\n        """""" Z near clipping place """"""\n\n        return self._znear\n\n    @znear.setter\n    def znear(self, value):\n        """""" Z near clipping place """"""\n\n        if value < self._zfar:\n            self._znear = value\n            self._build_projection()\n\n        \n    @property\n    def zfar(self):\n        """""" Z far clipping place """"""\n        return self._zfar\n\n    @zfar.setter\n    def zfar(self, value):\n        """""" Z far clipping place """"""\n\n        if value > self._zfar:\n            self._zfar = value\n            self._build_projection()\n\n    def on_attach(self, program):\n        self[""view""] = self._view\n        self[""model""] = self._model\n        self[""projection""] = self._projection\n\n\n    def on_resize(self, width, height):\n        self._width  = width\n        self._height = height\n\n        # Build projection matrix\n        self._build_projection()\n        \n        # Propagate event to children\n        Transform.on_resize(self, width, height)\n        \n    def _build_projection(self):\n        # We need to have caught at least one resize event\n        if self._width is None: return\n\n        aspect = self._width / float(self._height)\n        self[\'projection\'] = glm.perspective(self.fovy, aspect,\n                                             self._znear, self._zfar)\n'"
glumpy/transforms/quantitative_scale.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAbstract quantitative scale\n\nScales are functions that map from an input domain to an output\nrange. Quantitative scales have a continuous domain, such as the set of real\nnumbers, or dates. There are also ordinal scales, which have a discrete\ndomain, such as a set of names or categories.\n""""""\nimport numpy as np\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass QuantitativeScale(Transform):\n    """"""\n    Abstract quantitative scale.\n    \n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n    """"""\n\n    aliases = { }\n\n\n    def __init__(self, code, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        """"""\n\n        self._clamp   = False\n        self._discard = True\n        self._domain  = np.array([-1,+1], dtype=np.float32)\n        self._range   = np.array([-1,+1], dtype=np.float32)\n        self.process_kwargs(**kwargs)\n\n        Transform.__init__(self, code, *args, **kwargs)\n\n\n    def process_kwargs(self, **kwargs):\n\n        self._domain  = Transform._get_kwarg(""domain"", kwargs, self._domain)\n        self._range   = Transform._get_kwarg(""range"",  kwargs, self._range)\n        self._clamp   = Transform._get_kwarg(""clamp"",  kwargs, self._clamp)\n        self._discard = Transform._get_kwarg(""discard"", kwargs, self._discard)\n        self._domain  = np.asarray(self._domain, dtype=np.float32)\n        self._range   = np.asarray(self._range, dtype=np.float32)\n        Transform.process_kwargs(self, **kwargs)\n\n\n    @property\n    def domain(self):\n        """""" Input domain """"""\n\n        return self._domain\n\n    @domain.setter\n    def domain(self, value):\n        """""" Input domain """"""\n\n        self._domain = np.asarray(value,dtype=np.float32)\n        if self.is_attached:\n            self[""domain""] = self._process_domain()\n\n\n    @property\n    def range(self):\n        """""" Output range """"""\n\n        return self._range\n\n\n    @range.setter\n    def range(self, value):\n        """""" Output range """"""\n\n        self._range = np.asarray(value, dtype=np.float32)\n        if self.is_attached:\n            self[""range""] = self._process_range()\n\n    @property\n    def clamp(self):\n        """""" Whether to clamp value when out of range """"""\n\n        return self._clamp\n\n\n    @clamp.setter\n    def clamp(self, value):\n        """""" Whether to clamp value when out of range """"""\n\n        self._clamp = value\n        if self.is_attached:\n            self[""clamp""] = self._clamp\n\n\n    @property\n    def discard(self):\n        """""" Whether to discard value when out of range """"""\n\n        return self._discard\n\n\n    @discard.setter\n    def discard(self, value):\n        """""" Whether to discard value when out of range """"""\n\n        self._discard = value\n        if self.is_attached:\n            self[""discard""] = self._discard\n\n\n    def _process_range(self):\n        # To be overridden\n        return self._range\n\n    def _process_domain(self):\n        # To be overridden\n        return self._domain\n\n\n    def on_attach(self, program):\n        self[""discard""] = self._discard\n        self[""clamp""]   = self._clamp\n        self[""range""]   = self._process_range()\n        self[""domain""]  = self._process_domain()\n'"
glumpy/transforms/rotate.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport math\nimport numpy as np\nfrom glumpy import library\nfrom glumpy.transforms.transform import Transform\n\n\ndef _rotation(angle, x, y, z):\n    angle = math.pi * angle / 180\n    c, s = math.cos(angle), math.sin(angle)\n    n = math.sqrt(x * x + y * y + z * z)\n    x,y,z = x/n, y/n, z/n\n    cx, cy, cz = (1 - c) * x, (1 - c) * y, (1 - c) * z\n    return np.array([[cx * x + c, cy * x - z * s, cz * x + y * s, 0],\n                     [cx * y + z * s, cy * y + c, cz * y - x * s, 0],\n                     [cx * z - y * s, cy * z + x * s, cz * z + c, 0],\n                     [0, 0, 0, 1]], dtype=np.float32).T\n\n\nclass Rotate(Transform):\n    """"""\n    Rotation transform\n\n    :param 3-tuple axis:\n       Rotation axis. Default is (0,0,1).\n\n    :param float angle:\n       Rotation angle. Default is 0.\n\n    :param 3-tuple origin:\n       Rotation origin. Default is (0,0,0).\n\n\n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n\n    **Usage example**:\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec2 position;\n         void main()\n         {\n             gl_Position = <transform>;\n         } \'\'\'\n\n         ...\n         window = app.Window(width=800, height=800)\n         program = gloo.Program(vertex, fragment, count=4)\n         ...\n         program[\'transform\'] = Rotate(""position"", angle=15)\n         window.attach(program[\'transform\'])\n         ...\n    """"""\n\n    aliases = { ""axis""    : ""rotate_axis"",\n                ""angle""   : ""rotate_angle"",\n                ""origin""  : ""rotate_origin"",\n                ""forward"" : ""rotate_forward_matrix"",\n                ""inverse"" : ""rotate_inverse_matrix"" }\n\n    def __init__(self, *args, **kwargs):\n        """""" Initialize the transform.  """"""\n        self._forward = np.zeros((4,4), dtype=np.float32)\n        self._inverse = np.zeros((4,4), dtype=np.float32)\n        self._axis = Transform._get_kwarg(""axis"", kwargs, (0,0,1))\n        self._angle = Transform._get_kwarg(""angle"", kwargs, 0.0)\n        self._origin = Transform._get_kwarg(""origin"", kwargs, (0.,0.,0.))\n\n        code = library.get(""transforms/rotate.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n        # Force building of rotation matrices\n        self.axis = self._axis\n\n    @property\n    def axis(self):\n        """""" Rotation axis """"""\n\n        return self._axis\n\n    @axis.setter\n    def axis(self, value):\n        """""" Rotation axis """"""\n\n        self._axis = np.array(value, dtype=np.float32)\n        x,y,z = self._axis\n        self._forward = _rotation(+self._angle, x, y, z)\n        self._inverse = _rotation(-self._angle, x, y, z)\n        if self.is_attached:\n            self[""axis""] = self._axis\n            self[""forward""] = self._forward\n            self[""inverse""] = self._inverse\n\n    @property\n    def origin(self):\n        """""" Rotation origin """"""\n\n        return self._origin\n\n    @origin.setter\n    def origin(self, value):\n        """""" Rotation origin """"""\n\n        self._origin = np.array(value, dtype=np.float32)\n        if self.is_attached:\n            self[""origin""] = self._origin\n\n    @property\n    def angle(self):\n        """""" Rotation angle (degrees) """"""\n\n        return self._angle\n\n    @angle.setter\n    def angle(self, value):\n        """""" Rotation angle (degrees) """"""\n\n        self._angle = float(value)\n        x,y,z = self._axis\n\n        self._forward[...] = _rotation(+self._angle, x, y, z)\n        self._inverse[...] = _rotation(-self._angle, x, y, z)\n        if self.is_attached:\n            self[""angle""] = self._angle\n            self[""forward""] = self._forward\n            self[""inverse""] = self._inverse\n\n\n    def on_attach(self, program):\n        self[""axis""] = self._axis\n        self[""angle""] = self._angle\n        self[""origin""] = self._origin\n        self[""forward""] = self._forward\n        self[""inverse""] = self._inverse\n'"
glumpy/transforms/trackball.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom . import _trackball\nfrom . transform import Transform\nfrom glumpy import gl, glm, library\n\n\nclass Trackball(Transform):\n    """"""\n    3D trackball transform\n\n    :param float aspect:\n       Indicate what is the aspect ratio of the object displayed. This is\n       necessary to convert pixel drag move in oject space coordinates.\n       Default is None.\n\n    :param float znear:\n       Near clip plane. Default is 2.\n\n    :param float zfar: \n       Distance clip plane. Default is 1000.\n\n    :param float theta:\n       Angle (in degrees) around the z axis. Default is 45.\n\n    :param float phi: \n       Angle (in degrees) around the x axis. Default is 45.\n\n    :param float distance:\n       Distance from the trackball to the object.  Default is 8.\n\n    :param float zoom:\n           Zoom level. Default is 35.\n\n    The trackball transform simulates a virtual trackball (3D) that can rotate\n    around the origin using intuitive mouse gestures.\n\n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n      * ``on_resize``: Tranform update to maintain aspect\n      * ``on_mouse_scroll``: Zoom in & out (user action)\n      * ``on_mouse_grab``: Drag (user action)\n\n    **Usage example**:\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec2 position;\n         void main()\n         {\n             gl_Position = <transform>(vec4(position, 0.0, 1.0));\n         } \'\'\'\n\n         ...\n         window = app.Window(width=800, height=800)\n         program = gloo.Program(vertex, fragment, count=4)\n         ...\n         program[\'transform\'] = Trackball(aspect=1)\n         window.attach(program[\'transform\'])\n         ...\n    """"""\n\n    aliases = { ""view""       : ""trackball_view"",\n                ""model""      : ""trackball_model"",\n                ""projection"" : ""trackball_projection"" }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        """"""\n\n        code = library.get(""transforms/trackball.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n        self._aspect = Transform._get_kwarg(""aspect"", kwargs) or 1\n        self._znear = Transform._get_kwarg(""znear"", kwargs) or 2.0\n        self._zfar = Transform._get_kwarg(""zfar"", kwargs) or 1000.0\n        theta = Transform._get_kwarg(""theta"", kwargs) or 45\n        phi = Transform._get_kwarg(""phi"", kwargs) or 45\n        self._distance = Transform._get_kwarg(""distance"", kwargs) or 8\n        self._zoom = Transform._get_kwarg(""zoom"", kwargs) or 35\n        self._width = 1\n        self._height = 1\n        self._window_aspect = 1\n\n        self._trackball = _trackball.Trackball(45,45)\n        aspect = self._window_aspect * self._aspect\n        self._projection = glm.perspective(self._zoom, aspect,\n                                           self._znear, self._zfar)\n        self._view = np.eye(4, dtype=np.float32)\n        glm.translate(self._view, 0, 0, -abs(self._distance))\n\n\n\n    @property\n    def distance(self):\n        """""" Distance from the trackball to the object """"""\n\n        return self._distance\n\n    @distance.setter\n    def distance(self, distance):\n        """""" Distance from the trackball to the object """"""\n\n        self._distance = abs(distance)\n        self._view = np.eye(4, dtype=np.float32)\n        glm.translate(self._view, 0, 0, -abs(self._distance))\n        self[""view""] = self._view\n\n\n    @property\n    def theta(self):\n        """""" Angle (in degrees) around the z axis """"""\n\n        return self._trackball.theta\n\n    @theta.setter\n    def theta(self, theta):\n        """""" Angle (in degrees) around the z axis """"""\n\n        self._trackball.theta = theta\n        self[""model""] = self._trackball.model\n\n\n    @property\n    def phi(self):\n        """""" Angle (in degrees) around the x axis """"""\n\n        return self._trackball.phi\n\n    @phi.setter\n    def phi(self, phi):\n        """""" Angle (in degrees) around the x axis """"""\n\n        self._trackball.phi = phi\n        self[""model""] = self._trackball.model\n\n\n    @property\n    def zoom(self):\n        """""" Zoom level (aperture angle in degrees) """"""\n\n        return self._zoom\n\n\n    @phi.setter\n    def zoom(self, value):\n        """""" Zoom level (aperture angle in degrees) """"""\n\n        aspect = self._window_aspect * self._aspect\n        self._zoom = min(max(value, 1.0), 179.0)\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n\n    @property\n    def aspect(self):\n        """""" Projection aspect """"""\n\n        return self._aspect\n\n\n    @aspect.setter\n    def aspect(self, value):\n        """""" Projection aspect """"""\n\n        aspect = self._window_aspect * self._aspect\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n\n\n    def on_attach(self, program):\n        self[""view""] = self._view\n        self[""model""] = self._trackball.model\n        self[""projection""] = self._projection\n\n\n    def on_resize(self, width, height):\n        self._width  = float(width)\n        self._height = float(height)\n        self._window_aspect = self._width / self._height\n        aspect = self._window_aspect * self._aspect\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n        Transform.on_resize(self, width, height)\n\n\n\n    def on_mouse_drag(self, x, y, dx, dy, button):\n        width = self._width\n        height = self._height\n        x  = (x*2.0 - width)/width\n        dx = (2.*dx)/width\n        y  = (height - y*2.0)/height\n        dy = -(2.*dy)/height\n        self._trackball.drag_to(x,y,dx,dy)\n        self[""model""] = self._trackball.model\n\n\n    def on_mouse_scroll(self, x, y, dx, dy):\n        width = self._width\n        height = self._height\n        aspect = self._window_aspect * self._aspect\n        self._zoom = min(max(self._zoom*(1-dy/100), 1.0), 179.0)\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n'"
glumpy/transforms/trackball_pan.py,3,"b'import numpy as np\nfrom . import _trackball\nfrom . transform import Transform\nfrom glumpy import gl, glm, library\n\n\nclass TrackballPan(Transform):\n    """"""\n    3D trackball transform\n\n    :param float aspect:\n       Indicate what is the aspect ratio of the object displayed. This is\n       necessary to convert pixel drag move in oject space coordinates.\n       Default is None.\n\n    :param float znear:\n       Near clip plane. Default is 2.\n\n    :param float zfar: \n       Distance clip plane. Default is 1000.\n\n    :param float theta:\n       Angle (in degrees) around the z axis. Default is 45.\n\n    :param float phi: \n       Angle (in degrees) around the x axis. Default is 45.\n\n    :param float distance:\n       Distance from the trackball to the object.  Default is 8.\n\n    :param float zoom:\n           Zoom level. Default is 35.\n\n    The trackball transform simulates a virtual trackball (3D) that can rotate\n    around the origin using intuitive mouse gestures.\n\n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n      * ``on_resize``: Tranform update to maintain aspect\n      * ``on_mouse_scroll``: Zoom in & out (user action)\n      * ``on_mouse_grab``: Drag (user action)\n\n    **Usage example**:\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec2 position;\n         void main()\n         {\n             gl_Position = <transform>(vec4(position, 0.0, 1.0));\n         } \'\'\'\n\n         ...\n         window = app.Window(width=800, height=800)\n         program = gloo.Program(vertex, fragment, count=4)\n         ...\n         program[\'transform\'] = Trackball(aspect=1)\n         window.attach(program[\'transform\'])\n         ...\n    """"""\n\n    aliases = { ""view""       : ""trackball_view"",\n                ""model""      : ""trackball_model"",\n                ""projection"" : ""trackball_projection"",\n                ""pan""        : ""trackball_pan"" }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        """"""\n\n        code = library.get(""transforms/trackball-pan.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n        self._aspect = Transform._get_kwarg(""aspect"", kwargs) or 1\n        self._znear = Transform._get_kwarg(""znear"", kwargs) or 2.0\n        self._zfar = Transform._get_kwarg(""zfar"", kwargs) or 1000.0\n        theta = Transform._get_kwarg(""theta"", kwargs) or 45\n        phi = Transform._get_kwarg(""phi"", kwargs) or 45\n        self._distance = Transform._get_kwarg(""distance"", kwargs) or 8\n        self._zoom = Transform._get_kwarg(""zoom"", kwargs) or 35\n        self._width = 1\n        self._height = 1\n        self._window_aspect = 1\n        self._view_x = 0\n        self._view_y = 0\n        self._shift = False\n\n        self._trackball = _trackball.Trackball(45,45)\n        self._projection = np.eye(4, dtype=np.float32)\n        self._view = np.eye(4, dtype=np.float32)\n        glm.translate(self._view, 0, 0, -abs(self._distance))\n\n\n\n    @property\n    def distance(self):\n        """""" Distance from the trackball to the object """"""\n\n        return self._distance\n\n    @distance.setter\n    def distance(self, distance):\n        """""" Distance from the trackball to the object """"""\n\n        self._distance = abs(distance)\n        self._view = np.eye(4, dtype=np.float32)\n        glm.translate(self._view, 0, 0, -abs(self._distance))\n        self[""view""] = self._view\n\n\n    @property\n    def theta(self):\n        """""" Angle (in degrees) around the z axis """"""\n\n        return self._trackball.theta\n\n    @theta.setter\n    def theta(self, theta):\n        """""" Angle (in degrees) around the z axis """"""\n\n        self._trackball.theta = theta\n        self[""model""] = self._trackball.model\n\n\n    @property\n    def phi(self):\n        """""" Angle (in degrees) around the x axis """"""\n\n        return self._trackball.phi\n\n    @phi.setter\n    def phi(self, phi):\n        """""" Angle (in degrees) around the x axis """"""\n\n        self._trackball.phi = phi\n        self[""model""] = self._trackball.model\n\n\n    @property\n    def zoom(self):\n        """""" Zoom level (aperture angle in degrees) """"""\n\n        return self._zoom\n\n\n    @phi.setter\n    def zoom(self, value):\n        """""" Zoom level (aperture angle in degrees) """"""\n\n        aspect = self._window_aspect * self._aspect\n        self._zoom = min(max(value, 1.0), 179.0)\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n\n    @property\n    def aspect(self):\n        """""" Projection aspect """"""\n\n        return self._aspect\n\n\n    @aspect.setter\n    def aspect(self, value):\n        """""" Projection aspect """"""\n\n        aspect = self._window_aspect * self._aspect\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n\n\n    def on_attach(self, program):\n        self[""view""] = self._view\n        self[""model""] = self._trackball.model\n        self[""projection""] = self._projection\n\n\n    def on_resize(self, width, height):\n        self._width  = float(width)\n        self._height = float(height)\n        self._window_aspect = self._width / self._height\n        aspect = self._window_aspect * self._aspect\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n        Transform.on_resize(self, width, height)\n\n\n\n    def on_mouse_drag(self, x, y, dx, dy, button):\n        if self._shift: # shift button is currently pressed\n            # print(self._znear, self._zfar)\n            dx = 2 * (dx / self._width)\n            dy = -2 * (dy / self._height)\n            self[\'pan\'] = self._view_x, self._view_y\n            self._view_x += dx\n            self._view_y += dy\n            aspect = self._window_aspect * self._aspect\n        else:\n            width = self._width\n            height = self._height\n            x  = (x*2.0 - width)/width\n            dx = (2.*dx)/width\n            y  = (height - y*2.0)/height\n            dy = -(2.*dy)/height\n            self._trackball.drag_to(x,y,dx,dy)\n            self[""model""] = self._trackball.model\n\n    def on_mouse_scroll(self, x, y, dx, dy):\n        width = self._width\n        height = self._height\n        aspect = self._window_aspect * self._aspect\n        self._zoom = min(max(self._zoom*(1-dy/100), 1.0), 179.0)\n        #print(self._zoom)\n        self[\'projection\'] = glm.perspective(self._zoom, aspect,\n                                             self._znear, self._zfar)\n\n    def on_key_press(self, k, m):\n        #print(\'p\', k, m)\n        if m == 1:\n            self._shift = True\n\n    def on_key_release(self, k, m):\n        self._shift = False'"
glumpy/transforms/transform.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport os\nimport numpy as np\nfrom glumpy.gloo import Snippet\nfrom glumpy.app.window.event import EventDispatcher\n\n\nclass Transform(Snippet,EventDispatcher):\n    """"""\n    Transform\n\n    Transforms are snippets that can handle and propagate events such that they\n    are able to react to window event.\n\n    A Transform can be connected to the following events:\n\n    * ``on_attach``\n    * ``on_resize``\n    * ``on_mouse_scroll``\n    * ``on_mouse_grab``\n    * ``on_mouse_press``\n    * ``on_mouse_release``\n    """"""\n\n    aliases = { }\n\n    @classmethod\n    def _get_kwarg(cls, key, kwargs, default=None):\n        """""" Return a given parameter from the kwargs and remove it """"""\n        if  key in kwargs.keys():\n            value = kwargs[key]\n            del kwargs[key]\n            return value\n        return default\n\n\n    def __init__(self, code, *args, **kwargs):\n        Snippet.__init__(self, code, None, *args, **kwargs)\n        EventDispatcher.__init__(self)\n        self._window = None\n\n\n    def __getitem__(self, key):\n        """""" Override getitem to enforce aliases """"""\n\n        key = self.__class__.aliases.get(key, key)\n        return Snippet.__getitem__(self, key)\n\n\n    def __setitem__(self, key, value):\n        """""" Override getitem to enforce aliases """"""\n\n        key = self.__class__.aliases.get(key, key)\n        Snippet.__setitem__(self, key, value)\n\n\n\n\n    def attach(self, program):\n        """""" Attach the transform to a program """"""\n\n        if program not in self._programs:\n            self._programs.append(program)\n        program._build_uniforms()\n        program._build_attributes()\n\n        for snippet in self.snippets[1:]:\n            snippet.attach(program)\n\n        self.dispatch_event(""on_attach"", program)\n\n\n    def on_resize(self, width, height):\n        for snippet in list(self._args):\n            if isinstance(snippet, Snippet):\n                snippet.dispatch_event(""on_resize"", width, height)\n        if self._next:\n            operator, snippet = self._next\n            snippet.dispatch_event(""on_resize"", width, height)\n\n\n    def on_mouse_drag(self, x, y, dx, dy, button):\n        for snippet in list(self._args):\n            if isinstance(snippet, Snippet):\n                snippet.dispatch_event(""on_mouse_drag"", x, y, dx, dy, button)\n        if self._next:\n            operator, snippet = self._next\n            snippet.dispatch_event(""on_mouse_drag"", x, y, dx, dy, button)\n\n\n    def on_mouse_scroll(self, x, y, dx, dy):\n        for snippet in list(self._args):\n            if isinstance(snippet, Snippet):\n                snippet.dispatch_event(""on_mouse_scroll"", x, y, dx, dy)\n        if self._next:\n            operator, snippet = self._next\n            snippet.dispatch_event(""on_mouse_scroll"", x, y, dx, dy)\n\n\n    # def on_data(self):\n    #     for snippet in self._args:\n    #         if isinstance(snippet, Snippet):\n    #             snippet.dispatch_event(""on_data"")\n    #     if self._next:\n    #         operator, snippet = self._next\n    #         snippet.dispatch_event(""on_data"")\n\n\n\nTransform.register_event_type(\'on_attach\')\nTransform.register_event_type(\'on_resize\')\nTransform.register_event_type(\'on_mouse_drag\')\nTransform.register_event_type(\'on_mouse_scroll\')\nTransform.register_event_type(\'on_mouse_press\')\nTransform.register_event_type(\'on_mouse_release\')\n'"
glumpy/transforms/translate.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import library\nfrom glumpy.transforms.transform import Transform\nimport numpy as np\n\n\nclass Translate(Transform):\n    """"""\n    Translation transform\n\n    :param 3-tuple translate:\n       Translation vector. Default is (0,0,0).\n\n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n\n    **Usage example**:\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec2 position;\n         void main()\n         {\n             gl_Position = <transform>;\n         } \'\'\'\n\n         ...\n         window = app.Window(width=800, height=800)\n         program = gloo.Program(vertex, fragment, count=4)\n         ...\n         program[\'transform\'] = Translate(""position"", translate=(0,0,0))\n         window.attach(program[\'transform\'])\n         ...\n    """"""\n\n    aliases = { ""translate"" : ""translate_translate"" }\n\n\n    def __init__(self, *args, **kwargs):\n        code = library.get(""transforms/translate.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n        self.translate = Transform._get_kwarg(""translate"", kwargs) or (0,0,0)\n\n\n    @property\n    def translate(self):\n        """""" Translate vector """"""\n\n        return self._translate\n\n\n    @translate.setter\n    def translate(self, value):\n        """""" Translate vector """"""\n\n        self._translate = np.asarray(value,dtype=np.float32)\n        if self.is_attached:\n            self[""translate""] = self._translate\n\n\n    def on_attach(self, program):\n        self[""translate""] = self._translate\n'"
glumpy/transforms/transverse_mercator.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nTransverse Mercator projection\nhttp://en.wikipedia.org/wiki/Transverse_Mercator_projection\n""""""\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass TransverseMercatorProjection(Transform):\n    """""" Transverse Mercator projection """"""\n\n    aliases = {  }\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Initialize the transform.\n        Note that parameters must be passed by name (param=value).\n\n        Kwargs parameters\n        -----------------\n        """"""\n\n        code = library.get(""transforms/transverse_mercator.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\n\n    def on_attach(self, program):\n        """""" Initialization event """"""\n\n        pass\n'"
glumpy/transforms/viewport.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass Viewport(Transform):\n    """"""\n    Viewport transform\n\n    :param bool transform:\n        Whether to enforce viewport transformation. Default is true.\n\n    :param nool clipping: \n        Whether to enforce viewport clipping. Default is true.\n\n    :param tuple viewport:\n        Viewport (x,y,w,h) in absolute window coordinates. Default is None.\n\n\n    The viewport transform allows to restrict the display of a scene to a local\n    viewport.\n\n    The transform is connected to the following events:\n\n      * ``on_attach``: Transform initialization\n      * ``on_resize``: Tranform update to maintain aspect\n\n    **Usage example**:\n\n      .. code:: python\n\n         vertex = \'\'\'\n         attribute vec2 position;\n         void main()\n         {\n             ... \n             gl_Position = vec4(position,0,1);\n             <viewport.transform>;\n         } \'\'\'\n\n         fragment = \'\'\'\n         void main()\n         {\n             <viewport.clipping>;\n             ...\n             gl_FragColor = vec4(1,0,0,1);\n         } \'\'\'\n \n         window = app.Window(400,400)\n         ...\n         program = Program(vertex, fragment)\n         program[""viewport""] = transforms.Viewport(viewport=(10,10,390,390))\n         window.attach(program[""viewport""])\n         ...\n    """"""\n\n    aliases = { ""clipping""  : ""viewport_clipping"",\n                ""transform"" : ""viewport_transform"",\n                ""local""     : ""viewport_local"",\n                ""extents""   : ""viewport_local"",\n                ""global""    : ""viewport_global"" }\n\n    def __init__(self, code=None, *args, **kwargs):\n        if code is None:\n            code = library.get(""transforms/viewport.glsl"")\n\n        self._global = 0,0,512,512\n        self._local = Transform._get_kwarg(""viewport"", kwargs) or None\n        self._clipping = Transform._get_kwarg(""clipping"", kwargs) or True\n        self._transform = Transform._get_kwarg(""transform"", kwargs) or True\n\n        Transform.__init__(self, code, *args, **kwargs)\n\n\n\n    @property\n    def extents(self):\n        """""" Viewport extents as (x,y,w,h) (absolute coordinates) """"""\n\n        return self._local\n\n\n    @extents.setter\n    def extents(self, value):\n        """""" Viewport extents as (x,y,w,h) (absolute coordinates) """"""\n\n        self._local = value\n        if self.is_attached:\n            if self._local is None:\n                self[""local""] = self._global\n            else:\n                self[""local""] = self._local\n            self[""clipping""] = self._clipping\n            self[""transform""] = self._transform\n\n\n    @property\n    def clipping(self):\n        """""" Whether to enforce viewport clipping """"""\n\n        return self._clipping\n\n\n    @clipping.setter\n    def clipping(self, value):\n        """""" Whether to enforce viewport clipping """"""\n\n        self._clipping = value\n        if self.is_attached:\n            self[""clipping""] = self._clipping\n\n\n    @property\n    def transform(self):\n        """""" Whether to enforce viewport transform """"""\n\n        return self._transform\n\n\n    @transform.setter\n    def transform(self, value):\n        """""" Whether to enforce viewport transform """"""\n\n        self._transform = value\n        if self.is_attached:\n            self[""transform""] = self._transform\n\n\n\n    def on_attach(self, program):\n        self[""global""] = self._global\n        if self._local is None:\n            self[""local""] = self._global\n        else:\n            self[""local""] = self._local\n        self[""clipping""] = self._clipping\n        self[""transform""] = self._transform\n\n\n    def on_resize(self, width, height):\n        self._global = 0, 0, width, height\n        self[""global""] = self._global\n        if self._local is None:\n            self[""local""] = self._global\n\n        # Transmit signal to other transforms\n        Transform.on_resize(self, width, height)\n'"
glumpy/transforms/xyz.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import library\nfrom . transform import Transform\n\n\nclass X(Transform):\n    def __init__(self, *args, **kwargs):\n        code = library.get(""transforms/x.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\nclass Y(Transform):\n    def __init__(self, *args, **kwargs):\n        code = library.get(""transforms/y.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n\nclass Z(Transform):\n    def __init__(self, *args, **kwargs):\n        code = library.get(""transforms/z.glsl"")\n        Transform.__init__(self, code, *args, **kwargs)\n'"
glumpy/api/matplotlib/__init__.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . figure import Figure\nfrom glumpy.transforms import *\nfrom glumpy.graphics.collections import *\n'
glumpy/api/matplotlib/axes.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import app, gloo, gl, transforms\nfrom glumpy.graphics.collections import PointCollection\n\n\nvertex = """"""\nattribute vec2 position;\nvoid main()\n{\n    gl_Position = vec4(position,0,1);\n    <viewport.transform>;\n}\n""""""\n\nfragment = """"""\nuniform vec4 color;\nvoid main()\n{\n    gl_FragColor = color;\n    <viewport.clipping>;\n}\n""""""\n\nclass Axes(app.Viewport):\n    """""" """"""\n\n    def __init__(self, rect=[0,0,1,1], facecolor=(1,1,1,1),\n                 xscale = None, yscale = None, zscale = None,\n                 projection = None, interface = None, aspect=None):\n\n        size = rect[2], rect[3]\n        position = rect[0]+size[0]/2, rect[1]+size[1]/2\n        anchor = 0.5, 0.5\n        app.Viewport.__init__(self, size, position, anchor, aspect)\n        xscale = xscale if xscale is not None else transforms.LinearScale()\n        yscale = yscale if yscale is not None else transforms.LinearScale()\n        zscale = zscale if zscale is not None else transforms.LinearScale()\n        projection = projection if projection is not None else transforms.IdentityProjection()\n        interface = interface if interface is not None else transforms.Position()\n\n        self._viewport = transforms.Viewport()\n        xscale = xscale(\'.x\', name = \'xscale\')\n        yscale = yscale(\'.y\', name = \'yscale\')\n        zscale = zscale(\'.z\', name = \'zscale\')\n\n        self._scale = transforms.Position(xscale, yscale, zscale)\n        self._projection = projection #transforms.IdentityProjection()\n        self._interface = interface(aspect=aspect)\n\n        self.program = gloo.Program(vertex, fragment, count=4)\n        self.program[\'position\'] = [(-1,-1), (-1,+1), (+1,-1), (+1,+1)]\n        self.program[\'color\'] = facecolor\n        self.program[\'viewport\'] = self._viewport\n\n        self._transform = self._interface(self._projection(self._scale))\n        self.attach(self._transform)\n        self._drawables = []\n\n\n    def add_drawable(self, collection):\n        drawable = collection.view(transform=self._transform, viewport= self._viewport)\n        self._drawables.append(drawable)\n\n\n    @property\n    def viewport(self):\n        """""" Viewport transform  """"""\n\n        return self._viewport\n\n    @property\n    def transform(self):\n        """""" Global transform """"""\n\n        return self._transform\n\n    @property\n    def scale(self):\n        """""" Scale transform """"""\n\n        return self._scale\n\n\n    def add_axes(self, rect=[0,0,1,1], facecolor=(1,1,1,1),\n                 xscale = None, yscale = None, zscale = None,\n                 projection = None, interface = None, aspect=None):\n        axes = Axes(rect=rect,facecolor=facecolor, aspect=aspect,\n                    xscale=xscale, yscale=yscale, zscale=zscale,\n                    projection=projection, interface=interface)\n        self.add(axes)\n        return axes\n\n\n    def on_draw(self, dt):\n        self.program.draw(gl.GL_TRIANGLE_STRIP)\n        for drawable in self._drawables:\n            drawable.draw()\n        app.Viewport.on_draw(self,dt)\n\n\n    def on_resize(self, width, height):\n        if self.parent == None:\n            self._requested_size = width, height\n        self._compute_viewport()\n        self.dispatcher.dispatch_event(""on_resize"", self.size[0], self.size[1])\n\n        if self.viewport.is_attached:\n            # self._viewport.dispatch_event(""on_resize"", width, height)\n            self._viewport[""global""]  = self.root.extents\n            self._viewport[""extents""] = self.extents\n\n        for child in self._children:\n            child.dispatch_event(""on_resize"", width, height)\n'"
glumpy/api/matplotlib/figure.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom glumpy import app, gloo, gl, transforms\nfrom . axes import Axes\n\nclass Figure(object):\n    """""" """"""\n\n    def __init__(self, figsize=(10,10), dpi=72, color=(.95,.95,.95,1)):\n        width = int(round(figsize[0] * dpi))\n        height = int(round(figsize[1] * dpi))\n        self.window = app.Window(width=width, height=height, color=color,\n                                 title = ""Figure (matplotlib API)"")\n        self.viewport = app.Viewport()\n\n\n    def on_draw(self, dt):\n        self.window.clear()\n\n\n    def show(self):\n        self.window.push_handlers(self.viewport)\n        self.window.push_handlers(self)\n        app.run()\n\n\n    def add_axes(self, rect=[0,0,1,1], facecolor=(1,1,1,1),\n                 xscale = None, yscale = None, zscale = None,\n                 projection = None, interface = None, aspect=None):\n        axes = Axes(rect=rect, facecolor=facecolor, aspect=aspect,\n                    xscale=xscale, yscale=yscale, zscale=zscale,\n                    projection=projection, interface=interface)\n        self.viewport.add(axes)\n        return axes\n'"
glumpy/app/window/__init__.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . window import Window\nfrom . event import EventDispatcher\n'
glumpy/app/window/event.py,0,"b'# ----------------------------------------------------------------------------\n# pyglet\n# Copyright (c) 2006-2008 Alex Holkner\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n#  * Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in\n#    the documentation and/or other materials provided with the\n#    distribution.\n#  * Neither the name of pyglet nor the names of its\n#    contributors may be used to endorse or promote products\n#    derived from this software without specific prior written\n#    permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n# ----------------------------------------------------------------------------\n\n\'\'\' Event dispatch framework (adapted from pyglet).\n\nAll objects that produce events in glumpy implement `EventDispatcher`,\nproviding a consistent interface for registering and manipulating event\nhandlers.  A commonly used event dispatcher is `glumpy.window.Window`.\n\nEvent types\n===========\n\nFor each event dispatcher there is a set of events that it dispatches; these\ncorrespond with the type of event handlers you can attach.  Event types are\nidentified by their name, for example, \'\'on_resize\'\'.  If you are creating a\nnew class which implements `EventDispatcher`, you must call\n`EventDispatcher.register_event_type` for each event type.\n\nAttaching event handlers\n========================\n\nAn event handler is simply a function or method.  You can attach an event\nhandler by setting the appropriate function on the instance::\n\n    def on_resize(width, height):\n        # ...\n    dispatcher.on_resize = on_resize\n\nThere is also a convenience decorator that reduces typing::\n\n    @dispatcher.event\n    def on_resize(width, height):\n        # ...\n\nYou may prefer to subclass and override the event handlers instead::\n\n    class MyDispatcher(DispatcherClass):\n        def on_resize(self, width, height):\n            # ...\n\nEvent handler stack\n===================\n\nWhen attaching an event handler to a dispatcher using the above methods, it\nreplaces any existing handler (causing the original handler to no longer be\ncalled).  Each dispatcher maintains a stack of event handlers, allowing you to\ninsert an event handler ""above"" the existing one rather than replacing it.\n\nThere are two main use cases for ""pushing"" event handlers:\n\n* Temporarily intercepting the events coming from the dispatcher by pushing a\n  custom set of handlers onto the dispatcher, then later ""popping"" them all\n  off at once.\n* Creating ""chains"" of event handlers, where the event propogates from the\n  top-most (most recently added) handler to the bottom, until a handler\n  takes care of it.\n\nUse `EventDispatcher.push_handlers` to create a new level in the stack and\nattach handlers to it.  You can push several handlers at once::\n\n    dispatcher.push_handlers(on_resize, on_key_press)\n\nIf your function handlers have different names to the events they handle, use\nkeyword arguments::\n\n    dispatcher.push_handlers(on_resize=my_resize,\n                             on_key_press=my_key_press)\n\nAfter an event handler has processed an event, it is passed on to the\nnext-lowest event handler, unless the handler returns `EVENT_HANDLED`, which\nprevents further propogation.\n\nTo remove all handlers on the top stack level, use\n`EventDispatcher.pop_handlers`.\n\nNote that any handlers pushed onto the stack have precedence over the\nhandlers set directly on the instance (for example, using the methods\ndescribed in the previous section), regardless of when they were set.\nFor example, handler ``foo`` is called before handler ``bar`` in the following\nexample::\n\n    dispatcher.push_handlers(on_resize=foo)\n    dispatcher.on_resize = bar\n\nDispatching events\n==================\n\nglumpy uses a single-threaded model for all application code.  Event\nhandlers are only ever invoked as a result of calling\nEventDispatcher.dispatch_events`.\n\nIt is up to the specific event dispatcher to queue relevant events until they\ncan be dispatched, at which point the handlers are called in the order the\nevents were originally generated.\n\nThis implies that your application runs with a main loop that continously\nupdates the application state and checks for new events::\n\n    while True:\n        dispatcher.dispatch_events()\n        # ... additional per-frame processing\n\nNot all event dispatchers require the call to ``dispatch_events``; check with\nthe particular class documentation.\n\n\'\'\'\nfrom sys import version_info;\nif version_info[0]==3:\n    unicode = str\n__docformat__ = \'restructuredtext\'\n__version__ = \'$Id: event.py 2319 2008-10-12 02:50:08Z Alex.Holkner $\'\n\nimport inspect\n\nEVENT_HANDLED = True\nEVENT_UNHANDLED = None\n\nclass EventException(Exception):\n    \'\'\'An exception raised when an event handler could not be attached.\n    \'\'\'\n    pass\n\nclass EventDispatcher(object):\n    \'\'\'Generic event dispatcher interface.\n\n    See the module docstring for usage.\n    \'\'\'\n    # Placeholder empty stack; real stack is created only if needed\n    _event_stack = ()\n\n    @classmethod\n    def register_event_type(cls, name):\n        \'\'\'Register an event type with the dispatcher.\n\n        Registering event types allows the dispatcher to validate event\n        handler names as they are attached, and to search attached objects for\n        suitable handlers.\n\n        :param string name:\n            Name of the event to register.\n\n        \'\'\'\n        if not hasattr(cls, \'event_types\'):\n            cls.event_types = []\n        cls.event_types.append(name)\n        return name\n\n    def attach(self, *args, **kwargs):\n        \'\'\'Push a level onto the top of the handler stack, then attach zero or\n        more event handlers.\n\n        If keyword arguments are given, they name the event type to attach.\n        Otherwise, a callable\'s `__name__` attribute will be used.  Any other\n        object may also be specified, in which case it will be searched for\n        callables with event names.\n        \'\'\'\n\n        self.push_handlers(*args, **kwargs)\n\n\n    def push_handlers(self, *args, **kwargs):\n        \'\'\'Push a level onto the top of the handler stack, then attach zero or\n        more event handlers.\n\n        If keyword arguments are given, they name the event type to attach.\n        Otherwise, a callable\'s `__name__` attribute will be used.  Any other\n        object may also be specified, in which case it will be searched for\n        callables with event names.\n        \'\'\'\n        # Create event stack if necessary\n        if type(self._event_stack) is tuple:\n            self._event_stack = []\n\n        # Place dict full of new handlers at beginning of stack\n        self._event_stack.insert(0, {})\n        self.set_handlers(*args, **kwargs)\n\n    def _get_handlers(self, args, kwargs):\n        \'\'\'Implement handler matching on arguments for set_handlers and\n        remove_handlers.\n        \'\'\'\n        for object in args:\n            if inspect.isroutine(object):\n                # Single magically named function\n                name = object.__name__\n                if name not in self.event_types:\n                    raise EventException(\'Unknown event ""%s""\' % name)\n                yield name, object\n            else:\n                # Single instance with magically named methods\n                for name in dir(object):\n                    if name in self.event_types:\n                        yield name, getattr(object, name)\n        for name, handler in kwargs.items():\n            # Function for handling given event (no magic)\n            if name not in self.event_types:\n                raise EventException(\'Unknown event ""%s""\' % name)\n            yield name, handler\n\n    def set_handlers(self, *args, **kwargs):\n        \'\'\'\n        Attach one or more event handlers to the top level of the handler\n        stack.\n\n        See `push_handlers` for the accepted argument types.\n        \'\'\'\n\n        # Create event stack if necessary\n        if type(self._event_stack) is tuple:\n            self._event_stack = [{}]\n\n        for name, handler in self._get_handlers(args, kwargs):\n            self.set_handler(name, handler)\n\n    def set_handler(self, name, handler):\n        \'\'\'Attach a single event handler.\n\n        :param string name:\n            Name of the event type to attach to.\n\n        :param callable handler:\n            Event handler to attach.\n        \'\'\'\n        # Create event stack if necessary\n        if type(self._event_stack) is tuple:\n            self._event_stack = [{}]\n\n        self._event_stack[0][name] = handler\n\n    def pop_handlers(self):\n        \'\'\'\n        Pop the top level of event handlers off the stack.\n        \'\'\'\n        assert self._event_stack and \'No handlers pushed\'\n\n        del self._event_stack[0]\n\n    def remove_handlers(self, *args, **kwargs):\n        \'\'\'Remove event handlers from the event stack.\n\n        See push_handlers for the accepted argument types.  All handlers\n        are removed from the first stack frame that contains any of the given\n        handlers.  No error is raised if any handler does not appear in that\n        frame, or if no stack frame contains any of the given handlers.\n\n        If the stack frame is empty after removing the handlers, it is\n        removed from the stack.  Note that this interferes with the expected\n        symmetry of push_handlers and pop_handlers.\n        \'\'\'\n        handlers = list(self._get_handlers(args, kwargs))\n\n        # Find the first stack frame containing any of the handlers\n        def find_frame():\n            for frame in self._event_stack:\n                for name, handler in handlers:\n                    try:\n                        if frame[name] == handler:\n                            return frame\n                    except KeyError:\n                        pass\n        frame = find_frame()\n\n        # No frame matched; no error.\n        if not frame:\n            return\n\n        # Remove each handler from the frame.\n        for name, handler in handlers:\n            try:\n                if frame[name] == handler:\n                    del frame[name]\n            except KeyError:\n                pass\n\n        # Remove the frame if it\'s empty.\n        if not frame:\n            self._event_stack.remove(frame)\n\n    def remove_handler(self, name, handler):\n        \'\'\'Remove a single event handler.\n\n        The given event handler is removed from the first handler stack frame\n        it appears in.  The handler must be the exact same callable as passed\n        to `set_handler`, `set_handlers` or `push_handlers`; and the name\n        must match the event type it is bound to.\n\n        No error is raised if the event handler is not set.\n\n        :param string name:\n             Name of the event type to remove.\n\n        :param callable handler:\n             Event handler to remove.\n        \'\'\'\n        for frame in self._event_stack:\n            try:\n                if frame[name] is handler:\n                    del frame[name]\n                    break\n            except KeyError:\n                pass\n\n    def get_handler(self, name):\n        \'\'\'Get a single event handler by name.\n\n        Returns the first handler function that matches name.\n\n\tRaises KeyError if name is not found.\n\n        :param string name:\n             Name of the event type to get.\n\n        \'\'\'\n        for frame in self._event_stack:\n            try:\n                return frame[name]\n            except KeyError:\n                pass\n\n        raise KeyError(\'Event handler {} not found.\'.format(name))\n\n    def dispatch_event(self, event_type, *args):\n        \'\'\'Dispatch a single event to the attached handlers.\n\n        The event is propogated to all handlers from from the top of the stack\n        until one returns True. This method should be used only by\n        EventDispatcher implementors; applications should call the\n        dispatch_events method.\n\n\n        :param string event_type:\n            Name of the event.\n\n        :param sequence args:\n            Arguments to pass to the event handler.\n\n        :rtype: bool or None\n        :return:\n            True if an event handler returned True; False if one or more event\n            handlers were invoked but returned only Fasle.\n        \'\'\'\n        assert event_type in self.event_types\n\n        invoked = False\n\n        #if event_type == ""on_draw"":\n        #    print self._event_stack[0][""on_draw""]\n\n        # Search handler stack for matching event handlers\n        for frame in list(self._event_stack):\n            handler = frame.get(event_type, None)\n            if handler:\n                try:\n                    invoked = True\n                    if handler(*args):\n                        return EVENT_HANDLED\n                except TypeError:\n                    self._raise_dispatch_exception(event_type, args, handler)\n\n\n        # Check instance for an event handler\n        if hasattr(self, event_type):\n            try:\n                invoked = True\n                if getattr(self, event_type)(*args):\n                    return EVENT_HANDLED\n            except TypeError:\n                self._raise_dispatch_exception(\n                    event_type, args, getattr(self, event_type))\n\n        if invoked:\n            return EVENT_UNHANDLED\n\n        return False\n\n    def _raise_dispatch_exception(self, event_type, args, handler):\n        # A common problem in applications is having the wrong number of\n        # arguments in an event handler.  This is caught as a TypeError in\n        # dispatch_event but the error message is obfuscated.\n        #\n        # Here we check if there is indeed a mismatch in argument count,\n        # and construct a more useful exception message if so.  If this method\n        # doesn\'t find a problem with the number of arguments, the error\n        # is re-raised as if we weren\'t here.\n\n        n_args = len(args)\n\n        # Inspect the handler\n        handler_args, handler_varargs, _, handler_defaults = \\\n            inspect.getargspec(handler)\n        n_handler_args = len(handler_args)\n\n        # Remove ""self"" arg from handler if it\'s a bound method\n        if inspect.ismethod(handler) and handler.__self__:\n            n_handler_args -= 1\n\n        # Allow *args varargs to overspecify arguments\n        if handler_varargs:\n            n_handler_args = max(n_handler_args, n_args)\n\n        # Allow default values to overspecify arguments\n        if (n_handler_args > n_args and\n            handler_defaults and\n            n_handler_args - len(handler_defaults) <= n_args):\n            n_handler_args = n_args\n\n        if n_handler_args != n_args:\n            if inspect.isfunction(handler) or inspect.ismethod(handler):\n                descr = \'%s at %s:%d\' % (\n                    handler.func_name,\n                    handler.func_code.co_filename,\n                    handler.func_code.co_firstlineno)\n            else:\n                descr = repr(handler)\n\n            raise TypeError(\n                \'%s event was dispatched with %d arguments, but \'\n                \'handler %s has an incompatible function signature\' %\n                (event_type, len(args), descr))\n        else:\n            raise\n\n    def event(self, *args):\n        \'\'\'Function decorator for an event handler.\n\n        Usage::\n\n            win = window.Window()\n\n            @win.event\n            def on_resize(self, width, height):\n                # ...\n\n        or::\n\n            @win.event(\'on_resize\')\n            def foo(self, width, height):\n                # ...\n\n        \'\'\'\n        if len(args) == 0:                      # @window.event()\n            def decorator(func):\n                name = func.__name__\n                self.set_handler(name, func)\n                return func\n            return decorator\n        elif inspect.isroutine(args[0]):        # @window.event\n            func = args[0]\n            name = func.__name__\n            self.set_handler(name, func)\n            return args[0]\n        elif type(args[0]) in (str, unicode):   # @window.event(\'on_resize\')\n            name = args[0]\n            def decorator(func):\n                self.set_handler(name, func)\n                return func\n            return decorator\n'"
glumpy/app/window/key.py,0,"b'# ----------------------------------------------------------------------------\n# pyglet\n# Copyright (c) 2006-2008 Alex Holkner\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n#  * Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in\n#    the documentation and/or other materials provided with the\n#    distribution.\n#  * Neither the name of pyglet nor the names of its\n#    contributors may be used to endorse or promote products\n#    derived from this software without specific prior written\n#    permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n# ----------------------------------------------------------------------------\n\n\'\'\'Key constants and utilities for pyglet.window.\n\nUsage::\n\n    from pyglet.window import Window\n    from pyglet.window import key\n\n    window = Window()\n\n    @window.event\n    def on_key_press(symbol, modifiers):\n        # Symbolic names:\n        if symbol == key.RETURN:\n\n        # Alphabet keys:\n        elif symbol == key.Z:\n\n        # Number keys:\n        elif symbol == key._1:\n\n        # Number keypad keys:\n        elif symbol == key.NUM_1:\n\n        # Modifiers:\n        if modifiers & key.MOD_CTRL:\n\n\'\'\'\n\n__docformat__ = \'restructuredtext\'\n__version__ = \'$Id: key.py 1919 2008-03-19 07:47:01Z Alex.Holkner $\'\n\nclass KeyStateHandler(dict):\n    \'\'\'Simple handler that tracks the state of keys on the keyboard. If a\n    key is pressed then this handler holds a True value for it.\n\n    For example::\n\n        >>> win = window.Window\n        >>> keyboard = key.KeyStateHandler()\n        >>> win.push_handlers(keyboard)\n\n        # Hold down the ""up"" arrow...\n\n        >>> keyboard[key.UP]\n        True\n        >>> keyboard[key.DOWN]\n        False\n\n    \'\'\'\n    def on_key_press(self, symbol, modifiers):\n        self[symbol] = True\n    def on_key_release(self, symbol, modifiers):\n        self[symbol] = False\n    def __getitem__(self, key):\n        return self.get(key, False)\n\ndef modifiers_string(modifiers):\n    \'\'\'Return a string describing a set of modifiers.\n\n    Example::\n\n        >>> modifiers_string(MOD_SHIFT | MOD_CTRL)\n        \'MOD_SHIFT|MOD_CTRL\'\n\n    :Parameters:\n        `modifiers` : int\n            Bitwise combination of modifier constants.\n\n    :rtype: str\n    \'\'\'\n    mod_names = []\n    if modifiers & MOD_SHIFT:\n        mod_names.append(\'MOD_SHIFT\')\n    if modifiers & MOD_CTRL:\n        mod_names.append(\'MOD_CTRL\')\n    if modifiers & MOD_ALT:\n        mod_names.append(\'MOD_ALT\')\n    if modifiers & MOD_CAPSLOCK:\n        mod_names.append(\'MOD_CAPSLOCK\')\n    if modifiers & MOD_NUMLOCK:\n        mod_names.append(\'MOD_NUMLOCK\')\n    if modifiers & MOD_SCROLLLOCK:\n        mod_names.append(\'MOD_SCROLLLOCK\')\n    if modifiers & MOD_COMMAND:\n        mod_names.append(\'MOD_COMMAND\')\n    if modifiers & MOD_OPTION:\n        mod_names.append(\'MOD_OPTION\')\n    return \'|\'.join(mod_names)\n\ndef symbol_string(symbol):\n    \'\'\'Return a string describing a key symbol.\n\n    Example::\n\n        >>> symbol_string(BACKSPACE)\n        \'BACKSPACE\'\n\n    :Parameters:\n        `symbol` : int\n            Symbolic key constant.\n\n    :rtype: str\n    \'\'\'\n    if symbol < 1 << 32:\n        return _key_names.get(symbol, str(symbol))\n    else:\n        return \'user_key(%x)\' % (symbol >> 32)\n\ndef motion_string(motion):\n    \'\'\'Return a string describing a text motion.\n\n    Example::\n\n        >>> motion_string(MOTION_NEXT_WORD):\n        \'MOTION_NEXT_WORD\'\n\n    :Parameters:\n        `motion` : int\n            Text motion constant.\n\n    :rtype: str\n    \'\'\'\n    return _motion_names.get(motion, str(motion))\n\ndef user_key(scancode):\n    \'\'\'Return a key symbol for a key not supported by pyglet.\n\n    This can be used to map virtual keys or scancodes from unsupported\n    keyboard layouts into a machine-specific symbol.  The symbol will\n    be meaningless on any other machine, or under a different keyboard layout.\n\n    Applications should use user-keys only when user explicitly binds them\n    (for example, mapping keys to actions in a game options screen).\n    \'\'\'\n    assert scancode > 0\n    return scancode << 32\n\n# Modifier mask constants\nMOD_SHIFT       = 1 << 0\nMOD_CTRL        = 1 << 1\nMOD_ALT         = 1 << 2\nMOD_CAPSLOCK    = 1 << 3\nMOD_NUMLOCK     = 1 << 4\nMOD_WINDOWS     = 1 << 5\nMOD_COMMAND     = 1 << 6\nMOD_OPTION      = 1 << 7\nMOD_SCROLLLOCK  = 1 << 8\n\n#: Accelerator modifier.  On Windows and Linux, this is ``MOD_CTRL``, on\n#: Mac OS X it\'s ``MOD_COMMAND``.\nMOD_ACCEL       = MOD_CTRL\nimport sys as _sys\nif _sys.platform == \'darwin\':\n    MOD_ACCEL   = MOD_COMMAND\n\n\n# Key symbol constants\n\nUNKNOWN = -1\n\n# ASCII commands\n\nBACKSPACE     = 0xff08\nTAB           = 0xff09\nLINEFEED      = 0xff0a\nCLEAR         = 0xff0b\nRETURN        = 0xff0d\nENTER         = 0xff0d      # synonym\nPAUSE         = 0xff13\nSCROLLLOCK    = 0xff14\nSYSREQ        = 0xff15\nESCAPE        = 0xff1b\nSPACE         = 0xff20\n\n# Cursor control and motion\nHOME          = 0xff50\nLEFT          = 0xff51\nUP            = 0xff52\nRIGHT         = 0xff53\nDOWN          = 0xff54\nPAGEUP        = 0xff55\nPAGEDOWN      = 0xff56\nEND           = 0xff57\nBEGIN         = 0xff58\n\n# Misc functions\nDELETE        = 0xffff\nSELECT        = 0xff60\nPRINT         = 0xff61\nEXECUTE       = 0xff62\nINSERT        = 0xff63\nUNDO          = 0xff65\nREDO          = 0xff66\nMENU          = 0xff67\nFIND          = 0xff68\nCANCEL        = 0xff69\nHELP          = 0xff6a\nBREAK         = 0xff6b\nMODESWITCH    = 0xff7e\nSCRIPTSWITCH  = 0xff7e\n\n# Text motion constants: these are allowed to clash with key constants\nMOTION_UP                = UP\nMOTION_RIGHT             = RIGHT\nMOTION_DOWN              = DOWN\nMOTION_LEFT              = LEFT\nMOTION_NEXT_WORD         = 1\nMOTION_PREVIOUS_WORD     = 2\nMOTION_BEGINNING_OF_LINE = 3\nMOTION_END_OF_LINE       = 4\nMOTION_NEXT_PAGE         = PAGEDOWN\nMOTION_PREVIOUS_PAGE     = PAGEUP\nMOTION_BEGINNING_OF_FILE = 5\nMOTION_END_OF_FILE       = 6\nMOTION_BACKSPACE         = BACKSPACE\nMOTION_DELETE            = DELETE\n\n# Number pad\nNUMLOCK       = 0xff7f\nNUM_SPACE     = 0xff80\nNUM_TAB       = 0xff89\nNUM_ENTER     = 0xff8d\nNUM_F1        = 0xff91\nNUM_F2        = 0xff92\nNUM_F3        = 0xff93\nNUM_F4        = 0xff94\nNUM_HOME      = 0xff95\nNUM_LEFT      = 0xff96\nNUM_UP        = 0xff97\nNUM_RIGHT     = 0xff98\nNUM_DOWN      = 0xff99\nNUM_PRIOR     = 0xff9a\nNUM_PAGE_UP   = 0xff9a\nNUM_NEXT      = 0xff9b\nNUM_PAGE_DOWN = 0xff9b\nNUM_END       = 0xff9c\nNUM_BEGIN     = 0xff9d\nNUM_INSERT    = 0xff9e\nNUM_DELETE    = 0xff9f\nNUM_EQUAL     = 0xffbd\nNUM_MULTIPLY  = 0xffaa\nNUM_ADD       = 0xffab\nNUM_SEPARATOR = 0xffac\nNUM_SUBTRACT  = 0xffad\nNUM_DECIMAL   = 0xffae\nNUM_DIVIDE    = 0xffaf\n\nNUM_0         = 0xffb0\nNUM_1         = 0xffb1\nNUM_2         = 0xffb2\nNUM_3         = 0xffb3\nNUM_4         = 0xffb4\nNUM_5         = 0xffb5\nNUM_6         = 0xffb6\nNUM_7         = 0xffb7\nNUM_8         = 0xffb8\nNUM_9         = 0xffb9\n\n# Function keys\nF1            = 0xffbe\nF2            = 0xffbf\nF3            = 0xffc0\nF4            = 0xffc1\nF5            = 0xffc2\nF6            = 0xffc3\nF7            = 0xffc4\nF8            = 0xffc5\nF9            = 0xffc6\nF10           = 0xffc7\nF11           = 0xffc8\nF12           = 0xffc9\nF13           = 0xffca\nF14           = 0xffcb\nF15           = 0xffcc\nF16           = 0xffcd\n\n# Modifiers\nLSHIFT        = 0xffe1\nRSHIFT        = 0xffe2\nLCTRL         = 0xffe3\nRCTRL         = 0xffe4\nCAPSLOCK      = 0xffe5\nLMETA         = 0xffe7\nRMETA         = 0xffe8\nLALT          = 0xffe9\nRALT          = 0xffea\nLWINDOWS      = 0xffeb\nRWINDOWS      = 0xffec\nLCOMMAND      = 0xffed\nRCOMMAND      = 0xffee\nLOPTION       = 0xffd0\nROPTION       = 0xffd1\n\n# Latin-1\nSPACE         = 0x020\nEXCLAMATION   = 0x021\nDOUBLEQUOTE   = 0x022\nHASH          = 0x023\nPOUND         = 0x023  # synonym\nDOLLAR        = 0x024\nPERCENT       = 0x025\nAMPERSAND     = 0x026\nAPOSTROPHE    = 0x027\nPARENLEFT     = 0x028\nPARENRIGHT    = 0x029\nASTERISK      = 0x02a\nPLUS          = 0x02b\nCOMMA         = 0x02c\nMINUS         = 0x02d\nPERIOD        = 0x02e\nSLASH         = 0x02f\n_0            = 0x030\n_1            = 0x031\n_2            = 0x032\n_3            = 0x033\n_4            = 0x034\n_5            = 0x035\n_6            = 0x036\n_7            = 0x037\n_8            = 0x038\n_9            = 0x039\nCOLON         = 0x03a\nSEMICOLON     = 0x03b\nLESS          = 0x03c\nEQUAL         = 0x03d\nGREATER       = 0x03e\nQUESTION      = 0x03f\nAT            = 0x040\nBRACKETLEFT   = 0x05b\nBACKSLASH     = 0x05c\nBRACKETRIGHT  = 0x05d\nASCIICIRCUM   = 0x05e\nUNDERSCORE    = 0x05f\nGRAVE         = 0x060\nQUOTELEFT     = 0x060\nA             = 0x061\nB             = 0x062\nC             = 0x063\nD             = 0x064\nE             = 0x065\nF             = 0x066\nG             = 0x067\nH             = 0x068\nI             = 0x069\nJ             = 0x06a\nK             = 0x06b\nL             = 0x06c\nM             = 0x06d\nN             = 0x06e\nO             = 0x06f\nP             = 0x070\nQ             = 0x071\nR             = 0x072\nS             = 0x073\nT             = 0x074\nU             = 0x075\nV             = 0x076\nW             = 0x077\nX             = 0x078\nY             = 0x079\nZ             = 0x07a\nBRACELEFT     = 0x07b\nBAR           = 0x07c\nBRACERIGHT    = 0x07d\nASCIITILDE    = 0x07e\n\n_key_names = {}\n_motion_names = {}\nfor _name, _value in locals().copy().items():\n    if _name[:2] != \'__\' and _name.upper() == _name and \\\n       not _name.startswith(\'MOD_\'):\n        if _name.startswith(\'MOTION_\'):\n            _motion_names[_value] = _name\n        else:\n            _key_names[_value] = _name\n'"
glumpy/app/window/mouse.py,0,"b'# ----------------------------------------------------------------------------\n# pyglet\n# Copyright (c) 2006-2008 Alex Holkner\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n#  * Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in\n#    the documentation and/or other materials provided with the\n#    distribution.\n#  * Neither the name of pyglet nor the names of its\n#    contributors may be used to endorse or promote products\n#    derived from this software without specific prior written\n#    permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n# ----------------------------------------------------------------------------\n\n\'\'\'Mouse constants and utilities for pyglet.window.\n\'\'\'\n\n__docformat__ = \'restructuredtext\'\n__version__ = \'$Id: mouse.py 1579 2008-01-15 14:47:19Z Alex.Holkner $\'\n\ndef buttons_string(buttons):\n    \'\'\'Return a string describing a set of active mouse buttons.\n\n    Example::\n\n        >>> buttons_string(LEFT | RIGHT)\n        \'LEFT|RIGHT\'\n\n    :Parameters:\n        `buttons` : int\n            Bitwise combination of mouse button constants.\n\n    :rtype: str\n    \'\'\'\n    button_names = []\n    if buttons & NONE:\n        button_names.append(\'NONE\')\n    if buttons & LEFT:\n        button_names.append(\'LEFT\')\n    if buttons & MIDDLE:\n        button_names.append(\'MIDDLE\')\n    if buttons & RIGHT:\n        button_names.append(\'RIGHT\')\n    return \'|\'.join(button_names)\n\n# Symbolic names for the mouse buttons\nNONE    = 1 << 0\nLEFT    = 1 << 1\nMIDDLE  = 1 << 2\nRIGHT   = 1 << 3\nUNKNOWN = -1\n'"
glumpy/app/window/window.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom . import key\nfrom . import mouse\nfrom . import event\n\n\nclass Window(event.EventDispatcher):\n    """"""\n    Platform independent window.\n\n    :param int width:\n      Initial width (pixels)\n\n    :param int height:\n      Initial height (pixels)\n\n    :param strtitle:\n       Window title\n\n    :param bool visible:\n       Initial visibility status\n\n    :param bool decoration:\n       Whether window is decorated\n\n    :param bool fullscreen:\n       Initial fullscreen status\n\n    :param config:\n       GL Configuration\n\n    :param Window context:\n       Window to share GL context with\n\n    :param 4-tuple color:\n       Clear color\n\n\n    The content area of a window is filled entirely with an OpenGL viewport.\n    Applications have no access to operating system widgets or controls; all\n    rendering must be done via OpenGL.\n\n    Windows may appear as floating regions or can be set to fill an entire\n    screen (fullscreen).  When floating, windows may appear borderless or\n    decorated with a platform-specific frame (including, for example, the\n    title bar, minimize and close buttons, resize handles, and so on).\n\n    While it is possible to set the location of a window, it is recommended\n    that applications allow the platform to place it according to local\n    conventions.  This will ensure it is not obscured by other windows,\n    and appears on an appropriate screen for the user.\n\n    It is the responsability of the window backend to dispatch the following\n    events when necessary:\n\n    **Keyboard**::\n\n      def on_key_press(symbol, modifiers):\n          \'A key on the keyboard was pressed.\'\n          pass\n\n      def on_key_release(symbol, modifiers):\n          \'A key on the keyboard was released.\'\n          pass\n\n      def on_character(text):\n          \'A character has been typed\'\n          pass\n\n    **Mouse**::\n\n      def on_mouse_press(self, x, y, button):\n          \'A mouse button was pressed.\'\n          pass\n\n      def on_mouse_release(self, x, y, button):\n          \'A mouse button was released.\'\n          pass\n\n      def on_mouse_motion(x, y, dx, dy):\n          \'The mouse was moved with no buttons held down.\'\n          pass\n\n      def on_mouse_drag(x, y, dx, dy, buttons):\n          \'The mouse was moved with some buttons pressed.\'\n          pass\n\n      def on_mouse_scroll(self, dx, dy):\n          \'The mouse wheel was scrolled by (dx,dy).\'\n          pass\n\n\n    **Window**::\n\n      def on_init(self):\n          \'The window has just initialized iself.\'\n          pass\n\n      def on_show(self):\n          \'The window was shown.\'\n          pass\n\n      def on_hide(self):\n          \'The window was hidden.\'\n          pass\n\n      def on_close(self):\n          \'The user closed the window.\'\n          pass\n\n      def on_resize(self, width, height):\n          \'The window was resized to (width,height)\'\n          pass\n\n      def on_draw(self, dt):\n          \'The window contents must be redrawn.\'\n          pass\n\n      def on_idle(self, dt):\n          \'The window is inactive.\'\n          pass\n\n    """"""\n\n    def __init__(self, width=256, height=256, title=None, visible=True, aspect=None,\n                 decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1)):\n        """"""\n        Create a window.\n        """"""\n\n        event.EventDispatcher.__init__(self)\n        self._mouse_x = 0\n        self._mouse_y = 0\n        self._button = mouse.NONE\n        self._x = 0\n        self._y = 0\n        self._width = width\n        self._height = height\n        self._title = (title or sys.argv[0])\n        self._visible = visible\n        self._fullscreen = fullscreen\n        self._decoration = decoration\n        self._clock = None\n        self._timer_stack = []\n        self._timer_date = []\n        self._backend = None\n        self._color = color\n\n        self._clearflags = gl.GL_COLOR_BUFFER_BIT\n        if config._depth_size:\n            self._clearflags |= gl.GL_DEPTH_BUFFER_BIT\n        if config._stencil_size:\n            self._clearflags |= gl.GL_STENCIL_BUFFER_BIT\n\n\n    @property\n    def width(self):\n        """""" Window width (pixels, read-only) """"""\n\n        return self._width\n\n    \n    @property\n    def height(self):\n        """""" Window height (pixels, read-only) """"""\n\n        return self._height\n\n    @property\n    def fps(self):\n        """""" Frame per second (read-only). """"""\n\n        return self._clock.get_fps()\n\n    \n    @property\n    def config(self):\n        return self._config\n\n    @property\n    def color(self):\n        """""" Window clear color (read/write) """"""\n        \n        return self._color\n\n    \n    @color.setter\n    def color(self, color):\n        self._color = color\n        gl.glClearColor(*self._color)\n\n        \n    def clear(self,color=None, clearflags=None):\n        """""" Clear the whole window """"""\n\n        if color is not None:\n            gl.glClearColor(*color)\n            if  clearflags is not None: gl.glClear(clearflags)\n            else:                       gl.glClear(self._clearflags)\n        else:\n            gl.glClearColor(*self._color)\n            if  clearflags is not None: gl.glClear(clearflags)\n            else:                       gl.glClear(self._clearflags)\n\n    def on_init(self):\n        """""" Window initialization """"""\n\n        gl.glClearColor(*self._color)\n\n\n    def on_resize(self, width, height):\n        """""""" Default resize handler that set viewport """"""\n        gl.glViewport(0, 0, width, height)\n        self.dispatch_event(\'on_draw\', 0.0)\n        self.swap()\n\n    def on_key_press(self, k, modifiers):\n        """""""" Default key handler that close window on escape """"""\n        if k == key.ESCAPE:\n            self.close()\n            return True\n        elif k == key.F10:\n            import os, sys\n            import numpy as np\n            from glumpy.ext import png\n            framebuffer = np.zeros((self.height, self.width * 3), dtype=np.uint8)\n            gl.glReadPixels(0, 0, self.width, self.height,\n                            gl.GL_RGB, gl.GL_UNSIGNED_BYTE, framebuffer)\n\n            basename = os.path.basename(os.path.realpath(sys.argv[0]))\n            dirname = os.path.dirname(os.path.realpath(sys.argv[0]))\n            basename = \'.\'.join(basename.split(\'.\')[:-1])\n            filename = os.path.join(dirname,""%s.png"" % basename)\n            png.from_array(framebuffer[::-1], \'RGB\').save(filename)\n#            index = 0\n#            filename = ""%s-%04d.png"" % (basename,index)\n#            while os.path.exists(os.path.join(dirname, filename)):\n#                index += 1\n#                filename = ""%s-%04d.png"" % (basename, index)\n#            png.from_array(framebuffer, \'RGB\').save(filename)\n            return True\n\n    def show(self):\n        """""" Make the window visible """"""\n        log.warn(\'%s backend cannot show window\' % self._backend.name())\n\n    def hide(self):\n        """""" Hide the window """"""\n        log.warn(\'%s backend cannot hide window\' % self._backend.name())\n\n    def close(self):\n        """""" Close (destroy) the window """"""\n        log.warn(\'%s backend cannot close window\' % self._backend.name())\n\n    def set_title(self, title):\n        """""" Set window title """"""\n        log.warn(\'%s backend cannot set window title\' % self._backend.name())\n\n    def get_title(self):\n        """""" Get window title """"""\n        log.warn(\'%s backend cannot get window title\' % self._backend.name())\n\n    def set_size(self, width, height):\n        """""" Set window size """"""\n        log.warn(\'%s backend cannot set window size\' % self._backend.name())\n\n    def get_size(self):\n        """""" Get window size """"""\n        log.warn(\'%s backend cannot get window size\' %  self._backend.name())\n\n    def set_position(self, x, y):\n        """""" Set window position """"""\n        log.warn(\'%s backend cannot set window position\' %  self._backend.name())\n\n    def get_position(self):\n        """""" Get window position """"""\n        log.warn(\'%s backend cannot get position\' %  self._backend.name())\n\n    def set_fullscreen(self, fullsrceen):\n        """""" Set window fullscreen mode """"""\n        log.warn(\'%s backend cannot set fullscreen mode\' % self._backend.name())\n\n    def get_fullscreen(self):\n        """""" Get window fullscreen mode """"""\n        log.warn(\'%s backend cannot get fullscreen mode\' % self._backend.name())\n\n    def swap(self):\n        """""" Swap GL buffers """"""\n        log.warn(\'%s backend cannot swap buffers\' % self._backend.name())\n\n    def activate(self):\n        """""" Activate window """"""\n        log.warn(\'%s backend cannot make window active\' % self._backend.name())\n\n    def timer(self, delay):\n        """"""Function decorator for timed handlers.\n\n        :Parameters:\n\n            ``delay``: int\n                Delay in second\n\n        Usage::\n\n            window = window.Window()\n\n            @window.timer(0.1)\n            def timer(dt):\n                do_something ...\n        """"""\n\n        def decorator(func):\n            self._timer_stack.append((func, delay))\n            self._timer_date.append(0)\n            return func\n        return decorator\n\n\n\nWindow.register_event_type(\'on_enter\')\nWindow.register_event_type(\'on_leave\')\nWindow.register_event_type(\'on_draw\')\nWindow.register_event_type(\'on_resize\')\nWindow.register_event_type(\'on_mouse_motion\')\nWindow.register_event_type(\'on_mouse_drag\')\nWindow.register_event_type(\'on_mouse_press\')\nWindow.register_event_type(\'on_mouse_release\')\nWindow.register_event_type(\'on_mouse_scroll\')\nWindow.register_event_type(\'on_character\')\nWindow.register_event_type(\'on_key_press\')\nWindow.register_event_type(\'on_key_release\')\nWindow.register_event_type(\'on_init\')\nWindow.register_event_type(\'on_show\')\nWindow.register_event_type(\'on_hide\')\nWindow.register_event_type(\'on_close\')\nWindow.register_event_type(\'on_idle\')\n'"
glumpy/ext/freetype/__init__.py,0,"b""#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n'''\nFreeType high-level python API\n\nThis the bindings for the high-level API of FreeType (that must be installed\nsomewhere on your system).\n\nNote:\n  C Library will be searched using the ctypes.util.find_library. However, this\n  search might fail. In such a case (or for other reasons), you can specify the\n  FT_library_filename before importing the freetype library and freetype will use\n  the specified one.\n'''\nfrom ctypes import *\nfrom .ft_types import *\nfrom .ft_enums import *\nfrom .ft_errors import *\nfrom .ft_structs import *\nimport ctypes.util\nfrom glumpy.ext.six import text_type\n\n\n__dll__    = None\n__handle__ = None\nFT_Library_filename = ctypes.util.find_library('freetype')\nif not FT_Library_filename:\n    import platform\n    ft_versions = (str(v) for v in (255, 254, 253, 252, 251, 250,\n                                    2412, 2411, 2410, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240,\n                                    2312, 2311, 2310, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230,\n                                    221))  # versions of freetype2 to check\n    for v in ft_versions:\n        FT_Library_filename = ctypes.util.find_library('freetype' + v)\n        if FT_Library_filename:\n            break\nif not FT_Library_filename:\n    try:\n        __dll__ = ctypes.CDLL('libfreetype.so.6')\n    except OSError:\n        __dll__ = None\nif not FT_Library_filename and not __dll__:\n    raise RuntimeError('Freetype library not found')\nif not __dll__:\n  __dll__ = ctypes.CDLL(FT_Library_filename)\n\n\n\n# -----------------------------------------------------------------------------\n# High-level API of FreeType 2\n# -----------------------------------------------------------------------------\nFT_Init_FreeType       = __dll__.FT_Init_FreeType\nFT_Done_FreeType       = __dll__.FT_Done_FreeType\nFT_Library_Version     = __dll__.FT_Library_Version\n\ndef __del_library__(self):\n    global __handle__\n    if __handle__:\n        try:\n            FT_Done_FreeType(self)\n            __handle__ = None\n        except:\n            pass\nFT_Library.__del__ = __del_library__\n\ndef get_handle():\n    '''\n    Get unique FT_Library handle\n    '''\n    global __handle__\n    if not __handle__:\n        __handle__ = FT_Library( )\n        error = FT_Init_FreeType( byref(__handle__) )\n        if error: raise FT_Exception(error)\n        try:\n            set_lcd_filter( FT_LCD_FILTER_DEFAULT )\n        except:\n            pass\n        if error: raise FT_Exception(error)\n    return __handle__\n\ndef version():\n    '''\n    Return the version of the FreeType library being used as a tuple of\n    ( major version number, minor version number, patch version number )\n    '''\n    amajor = FT_Int()\n    aminor = FT_Int()\n    apatch = FT_Int()\n    library = get_handle()\n    FT_Library_Version(library, byref(amajor), byref(aminor), byref(apatch))\n    return (amajor.value, aminor.value, apatch.value)\n\n\ntry:\n    FT_Library_SetLcdFilter= __dll__.FT_Library_SetLcdFilter\nexcept:\n    def FT_Library_SetLcdFilter (*args, **kwargs):\n        return 0\nif version()>=(2,4,0):\n    FT_Library_SetLcdFilterWeights = __dll__.FT_Library_SetLcdFilterWeights\nFT_New_Face            = __dll__.FT_New_Face\nFT_New_Memory_Face     = __dll__.FT_New_Memory_Face\nFT_Open_Face           = __dll__.FT_Open_Face\nFT_Attach_File         = __dll__.FT_Attach_File\nFT_Attach_Stream       = __dll__.FT_Attach_Stream\nif version()>=(2,4,2):\n    FT_Reference_Face      = __dll__.FT_Reference_Face\nFT_Done_Face           = __dll__.FT_Done_Face\nFT_Done_Glyph          = __dll__.FT_Done_Glyph\nFT_Select_Size         = __dll__.FT_Select_Size\nFT_Request_Size        = __dll__.FT_Request_Size\nFT_Set_Char_Size       = __dll__.FT_Set_Char_Size\nFT_Set_Pixel_Sizes     = __dll__.FT_Set_Pixel_Sizes\nFT_Load_Glyph          = __dll__.FT_Load_Glyph\nFT_Load_Char           = __dll__.FT_Load_Char\nFT_Set_Transform       = __dll__.FT_Set_Transform\nFT_Render_Glyph        = __dll__.FT_Render_Glyph\nFT_Get_Kerning         = __dll__.FT_Get_Kerning\nFT_Get_Track_Kerning   = __dll__.FT_Get_Track_Kerning\nFT_Get_Glyph_Name      = __dll__.FT_Get_Glyph_Name\nFT_Get_Glyph           = __dll__.FT_Get_Glyph\n\nFT_Glyph_Get_CBox      = __dll__.FT_Glyph_Get_CBox\n\nFT_Get_Postscript_Name = __dll__.FT_Get_Postscript_Name\nFT_Get_Postscript_Name.restype = c_char_p\nFT_Select_Charmap      = __dll__.FT_Select_Charmap\nFT_Set_Charmap         = __dll__.FT_Set_Charmap\nFT_Get_Charmap_Index   = __dll__.FT_Get_Charmap_Index\nFT_Get_CMap_Language_ID= __dll__.FT_Get_CMap_Language_ID\nFT_Get_CMap_Format     = __dll__.FT_Get_CMap_Format\nFT_Get_Char_Index      = __dll__.FT_Get_Char_Index\nFT_Get_First_Char      = __dll__.FT_Get_First_Char\nFT_Get_Next_Char       = __dll__.FT_Get_Next_Char\nFT_Get_Name_Index      = __dll__.FT_Get_Name_Index\nFT_Get_SubGlyph_Info   = __dll__.FT_Get_SubGlyph_Info\nif version()>=(2,3,8):\n    FT_Get_FSType_Flags    = __dll__.FT_Get_FSType_Flags\n    FT_Get_FSType_Flags.restype  = c_ushort\n\nFT_Get_X11_Font_Format = __dll__.FT_Get_X11_Font_Format\nFT_Get_X11_Font_Format.restype = c_char_p\n\nFT_Get_Sfnt_Name_Count = __dll__.FT_Get_Sfnt_Name_Count\nFT_Get_Sfnt_Name       = __dll__.FT_Get_Sfnt_Name\nFT_Get_Advance         = __dll__.FT_Get_Advance\n\n\nFT_Outline_GetInsideBorder  = __dll__.FT_Outline_GetInsideBorder\nFT_Outline_GetOutsideBorder = __dll__.FT_Outline_GetOutsideBorder\nFT_Outline_Get_BBox         = __dll__.FT_Outline_Get_BBox\nFT_Outline_Get_CBox         = __dll__.FT_Outline_Get_CBox\nFT_Stroker_New              = __dll__.FT_Stroker_New\nFT_Stroker_Set              = __dll__.FT_Stroker_Set\nFT_Stroker_Rewind           = __dll__.FT_Stroker_Rewind\nFT_Stroker_ParseOutline     = __dll__.FT_Stroker_ParseOutline\nFT_Stroker_BeginSubPath     = __dll__.FT_Stroker_BeginSubPath\nFT_Stroker_EndSubPath       = __dll__.FT_Stroker_EndSubPath\nFT_Stroker_LineTo           = __dll__.FT_Stroker_LineTo\nFT_Stroker_ConicTo          = __dll__.FT_Stroker_ConicTo\nFT_Stroker_CubicTo          = __dll__.FT_Stroker_CubicTo\nFT_Stroker_GetBorderCounts  = __dll__.FT_Stroker_GetBorderCounts\nFT_Stroker_ExportBorder     = __dll__.FT_Stroker_ExportBorder\nFT_Stroker_GetCounts        = __dll__.FT_Stroker_GetCounts\nFT_Stroker_Export           = __dll__.FT_Stroker_Export\nFT_Stroker_Done             = __dll__.FT_Stroker_Done\nFT_Glyph_Stroke             = __dll__.FT_Glyph_Stroke\nFT_Glyph_StrokeBorder       = __dll__.FT_Glyph_StrokeBorder\nFT_Glyph_To_Bitmap          = __dll__.FT_Glyph_To_Bitmap\n\n\n\n# -----------------------------------------------------------------------------\n#  Stand alone functions\n# -----------------------------------------------------------------------------\ndef set_lcd_filter(filt):\n    '''\n    This function is used to apply color filtering to LCD decimated bitmaps,\n    like the ones used when calling FT_Render_Glyph with FT_RENDER_MODE_LCD or\n    FT_RENDER_MODE_LCD_V.\n\n    **Note**\n\n    This feature is always disabled by default. Clients must make an explicit\n    call to this function with a 'filter' value other than FT_LCD_FILTER_NONE\n    in order to enable it.\n\n    Due to PATENTS covering subpixel rendering, this function doesn't do\n    anything except returning 'FT_Err_Unimplemented_Feature' if the\n    configuration macro FT_CONFIG_OPTION_SUBPIXEL_RENDERING is not defined in\n    your build of the library, which should correspond to all default builds of\n    FreeType.\n\n    The filter affects glyph bitmaps rendered through FT_Render_Glyph,\n    FT_Outline_Get_Bitmap, FT_Load_Glyph, and FT_Load_Char.\n\n    It does not affect the output of FT_Outline_Render and\n    FT_Outline_Get_Bitmap.\n\n    If this feature is activated, the dimensions of LCD glyph bitmaps are\n    either larger or taller than the dimensions of the corresponding outline\n    with regards to the pixel grid. For example, for FT_RENDER_MODE_LCD, the\n    filter adds up to 3 pixels to the left, and up to 3 pixels to the right.\n\n    The bitmap offset values are adjusted correctly, so clients shouldn't need\n    to modify their layout and glyph positioning code when enabling the filter.\n    '''\n    library = get_handle()\n    error = FT_Library_SetLcdFilter(library, filt)\n    if error: raise FT_Exception(error)\n\n\n\ndef set_lcd_filter_weights(a,b,c,d,e):\n    '''\n    Use this function to override the filter weights selected by\n    FT_Library_SetLcdFilter. By default, FreeType uses the quintuple (0x00,\n    0x55, 0x56, 0x55, 0x00) for FT_LCD_FILTER_LIGHT, and (0x10, 0x40, 0x70,\n    0x40, 0x10) for FT_LCD_FILTER_DEFAULT and FT_LCD_FILTER_LEGACY.\n\n    **Note**\n\n    Only available if version > 2.4.0\n    '''\n    if version()>=(2,4,0):\n        library = get_handle()\n        weights = FT_Char(5)(a,b,c,d,e)\n        error = FT_Library_SetLcdFilterWeights(library, weights)\n        if error: raise FT_Exception(error)\n    else:\n        raise RuntimeError('set_lcd_filter_weights require freetype > 2.4.0')\n\n\n\n# -----------------------------------------------------------------------------\n#  Direct wrapper (simple renaming)\n# -----------------------------------------------------------------------------\nVector = FT_Vector\nMatrix = FT_Matrix\n\n\n\n# -----------------------------------------------------------------------------\nclass BBox( object ):\n    '''\n    FT_BBox wrapper.\n\n    A structure used to hold an outline's bounding box, i.e., the coordinates\n    of its extrema in the horizontal and vertical directions.\n\n    **Note**\n\n    The bounding box is specified with the coordinates of the lower left and\n    the upper right corner. In PostScript, those values are often called\n    (llx,lly) and (urx,ury), respectively.\n\n    If 'yMin' is negative, this value gives the glyph's descender. Otherwise,\n    the glyph doesn't descend below the baseline. Similarly, if 'ymax' is\n    positive, this value gives the glyph's ascender.\n\n    'xMin' gives the horizontal distance from the glyph's origin to the left\n    edge of the glyph's bounding box. If 'xMin' is negative, the glyph\n    extends to the left of the origin.\n    '''\n\n    def __init__(self, bbox):\n        '''\n        Create a new BBox object.\n\n        :param bbox: a FT_BBox or a tuple of 4 values\n        '''\n        if type(bbox) is FT_BBox:\n            self._FT_BBox = bbox\n        else:\n            self._FT_BBox = FT_BBox(*bbox)\n\n    xMin = property(lambda self: self._FT_BBox.xMin,\n                    doc = 'The horizontal minimum (left-most).')\n\n    yMin = property(lambda self: self._FT_BBox.yMin,\n                    doc = 'The vertical minimum (bottom-most).')\n\n    xMax = property(lambda self: self._FT_BBox.xMax,\n                    doc = 'The horizontal maximum (right-most).')\n\n    yMax = property(lambda self: self._FT_BBox.yMax,\n                    doc = 'The vertical maximum (top-most).')\n\n\n\n\n\n# -----------------------------------------------------------------------------\nclass GlyphMetrics( object ):\n    '''\n\n    A structure used to model the metrics of a single glyph. The values are\n    expressed in 26.6 fractional pixel format; if the flag FT_LOAD_NO_SCALE has\n    been used while loading the glyph, values are expressed in font units\n    instead.\n\n    **Note**\n\n    If not disabled with FT_LOAD_NO_HINTING, the values represent dimensions of\n    the hinted glyph (in case hinting is applicable).\n\n    Stroking a glyph with an outside border does not increase \xe2\x80\x98horiAdvance\xe2\x80\x99 or\n    \xe2\x80\x98vertAdvance\xe2\x80\x99; you have to manually adjust these values to account for the\n    added width and height.\n    '''\n\n    def __init__(self, metrics ):\n        '''\n        Create a new GlyphMetrics object.\n\n        :param metrics: a FT_Glyph_Metrics\n        '''\n        self._FT_Glyph_Metrics = metrics\n\n    width = property( lambda self: self._FT_Glyph_Metrics.width,\n       doc = '''The glyph's width.''' )\n\n    height = property( lambda self: self._FT_Glyph_Metrics.height,\n       doc = '''The glyph's height.''' )\n\n    horiBearingX = property( lambda self: self._FT_Glyph_Metrics.horiBearingX,\n       doc = '''Left side bearing for horizontal layout.''' )\n\n    horiBearingY = property( lambda self: self._FT_Glyph_Metrics.horiBearingY,\n       doc = '''Top side bearing for horizontal layout.''' )\n\n    horiAdvance = property( lambda self: self._FT_Glyph_Metrics.horiAdvance,\n       doc = '''Advance width for horizontal layout.''' )\n\n    vertBearingX = property( lambda self: self._FT_Glyph_Metrics.vertBearingX,\n       doc = '''Left side bearing for vertical layout.''' )\n\n    vertBearingY = property( lambda self: self._FT_Glyph_Metrics.vertBearingY,\n       doc = '''Top side bearing for vertical layout. Larger positive values\n                mean further below the vertical glyph origin.''' )\n\n    vertAdvance = property( lambda self: self._FT_Glyph_Metrics.vertAdvance,\n       doc = '''Advance height for vertical layout. Positive values mean the\n                glyph has a positive advance downward.''' )\n\n\n# -----------------------------------------------------------------------------\nclass SizeMetrics( object ):\n    '''\n    The size metrics structure gives the metrics of a size object.\n\n    **Note**\n\n    The scaling values, if relevant, are determined first during a size\n    changing operation. The remaining fields are then set by the driver. For\n    scalable formats, they are usually set to scaled values of the\n    corresponding fields in Face.\n\n    Note that due to glyph hinting, these values might not be exact for certain\n    fonts. Thus they must be treated as unreliable with an error margin of at\n    least one pixel!\n\n    Indeed, the only way to get the exact metrics is to render all glyphs. As\n    this would be a definite performance hit, it is up to client applications\n    to perform such computations.\n\n    The SizeMetrics structure is valid for bitmap fonts also.\n    '''\n\n    def __init__(self, metrics ):\n        '''\n        Create a new SizeMetrics object.\n\n        :param metrics: a FT_SizeMetrics\n        '''\n        self._FT_Size_Metrics = metrics\n\n    x_ppem = property( lambda self: self._FT_Size_Metrics.x_ppem,\n       doc = '''The width of the scaled EM square in pixels, hence the term\n                'ppem' (pixels per EM). It is also referred to as 'nominal\n                width'.''' )\n\n    y_ppem = property( lambda self: self._FT_Size_Metrics.y_ppem,\n       doc = '''The height of the scaled EM square in pixels, hence the term\n                'ppem' (pixels per EM). It is also referred to as 'nominal\n                height'.''' )\n\n    x_scale = property( lambda self: self._FT_Size_Metrics.x_scale,\n        doc = '''A 16.16 fractional scaling value used to convert horizontal\n                 metrics from font units to 26.6 fractional pixels. Only\n                 relevant for scalable font formats.''' )\n\n    y_scale = property( lambda self: self._FT_Size_Metrics.y_scale,\n        doc = '''A 16.16 fractional scaling value used to convert vertical\n                 metrics from font units to 26.6 fractional pixels. Only\n                 relevant for scalable font formats.''' )\n\n    ascender = property( lambda self: self._FT_Size_Metrics.ascender,\n         doc = '''The ascender in 26.6 fractional pixels. See Face for the\n                  details.''' )\n\n    descender = property( lambda self: self._FT_Size_Metrics.descender,\n          doc = '''The descender in 26.6 fractional pixels. See Face for the\n                    details.''' )\n\n    height = property( lambda self: self._FT_Size_Metrics.height,\n       doc = '''The height in 26.6 fractional pixels. See Face for the details.''' )\n\n    max_advance = property(lambda self: self._FT_Size_Metrics.max_advance,\n            doc = '''The maximal advance width in 26.6 fractional pixels. See\n                      Face for the details.''' )\n\n\n\n# -----------------------------------------------------------------------------\nclass BitmapSize( object ):\n    '''\n    FT_Bitmap_Size wrapper\n\n    This structure models the metrics of a bitmap strike (i.e., a set of glyphs\n    for a given point size and resolution) in a bitmap font. It is used for the\n    'available_sizes' field of Face.\n\n    **Note**\n\n    Windows FNT: The nominal size given in a FNT font is not reliable. Thus\n    when the driver finds it incorrect, it sets 'size' to some calculated\n    values and sets 'x_ppem' and 'y_ppem' to the pixel width and height given\n    in the font, respectively.\n\n    TrueType embedded bitmaps: 'size', 'width', and 'height' values are not\n    contained in the bitmap strike itself. They are computed from the global\n    font parameters.\n    '''\n    def __init__(self, size ):\n        '''\n        Create a new SizeMetrics object.\n\n        :param size: a FT_Bitmap_Size\n        '''\n        self._FT_Bitmap_Size = size\n\n    height = property( lambda self: self._FT_Bitmap_Size.height,\n       doc = '''The vertical distance, in pixels, between two consecutive\n                baselines. It is always positive.''')\n\n    width = property( lambda self: self._FT_Bitmap_Size.width,\n      doc = '''The average width, in pixels, of all glyphs in the strike.''')\n\n    size = property( lambda self: self._FT_Bitmap_Size.size,\n     doc = '''The nominal size of the strike in 26.6 fractional points. This\n              field is not very useful.''')\n\n    x_ppem = property( lambda self: self._FT_Bitmap_Size.x_ppem,\n       doc = '''The horizontal ppem (nominal width) in 26.6 fractional\n                pixels.''')\n\n    y_ppem = property( lambda self: self._FT_Bitmap_Size.y_ppem,\n       doc = '''The vertical ppem (nominal width) in 26.6 fractional\n                pixels.''')\n\n\n# -----------------------------------------------------------------------------\nclass Bitmap(object):\n    '''\n    FT_Bitmap wrapper\n\n    A structure used to describe a bitmap or pixmap to the raster. Note that we\n    now manage pixmaps of various depths through the 'pixel_mode' field.\n\n    *Note*:\n\n      For now, the only pixel modes supported by FreeType are mono and\n      grays. However, drivers might be added in the future to support more\n      'colorful' options.\n    '''\n    def __init__(self, bitmap):\n        '''\n        Create a new Bitmap object.\n\n        :param bitmap: a FT_Bitmap\n        '''\n        self._FT_Bitmap = bitmap\n\n    rows = property(lambda self: self._FT_Bitmap.rows,\n     doc = '''The number of bitmap rows.''')\n\n    width = property(lambda self: self._FT_Bitmap.width,\n      doc = '''The number of pixels in bitmap row.''')\n\n    pitch = property(lambda self: self._FT_Bitmap.pitch,\n      doc = '''The pitch's absolute value is the number of bytes taken by one\n               bitmap row, including padding. However, the pitch is positive\n               when the bitmap has a 'down' flow, and negative when it has an\n               'up' flow. In all cases, the pitch is an offset to add to a\n               bitmap pointer in order to go down one row.\n\n               Note that 'padding' means the alignment of a bitmap to a byte\n               border, and FreeType functions normally align to the smallest\n               possible integer value.\n\n               For the B/W rasterizer, 'pitch' is always an even number.\n\n               To change the pitch of a bitmap (say, to make it a multiple of\n               4), use FT_Bitmap_Convert. Alternatively, you might use callback\n               functions to directly render to the application's surface; see\n               the file 'example2.py' in the tutorial for a demonstration.''')\n\n    def _get_buffer(self):\n        data = [self._FT_Bitmap.buffer[i] for i in range(self.rows*self.pitch)]\n        return data\n    buffer = property(_get_buffer,\n       doc = '''A typeless pointer to the bitmap buffer. This value should be\n                aligned on 32-bit boundaries in most cases.''')\n\n    num_grays = property(lambda self: self._FT_Bitmap.num_grays,\n          doc = '''This field is only used with FT_PIXEL_MODE_GRAY; it gives\n                   the number of gray levels used in the bitmap.''')\n\n    pixel_mode = property(lambda self: self._FT_Bitmap.pixel_mode,\n           doc = '''The pixel mode, i.e., how pixel bits are stored. See\n                    FT_Pixel_Mode for possible values.''')\n\n    palette_mode = property(lambda self: self._FT_Bitmap.palette_mode,\n             doc ='''This field is intended for paletted pixel modes; it\n                     indicates how the palette is stored. Not used currently.''')\n\n    palette = property(lambda self: self._FT_Bitmap.palette,\n        doc = '''A typeless pointer to the bitmap palette; this field is\n                 intended for paletted pixel modes. Not used currently.''')\n\n\n\n\n# -----------------------------------------------------------------------------\nclass Charmap( object ):\n    '''\n    FT_Charmap wrapper.\n\n    A handle to a given character map. A charmap is used to translate character\n    codes in a given encoding into glyph indexes for its parent's face. Some\n    font formats may provide several charmaps per font.\n\n    Each face object owns zero or more charmaps, but only one of them can be\n    'active' and used by FT_Get_Char_Index or FT_Load_Char.\n\n    The list of available charmaps in a face is available through the\n    'face.num_charmaps' and 'face.charmaps' fields of FT_FaceRec.\n\n    The currently active charmap is available as 'face.charmap'. You should\n    call FT_Set_Charmap to change it.\n\n    **Note**:\n\n      When a new face is created (either through FT_New_Face or FT_Open_Face),\n      the library looks for a Unicode charmap within the list and automatically\n      activates it.\n\n    **See also**:\n\n      See FT_CharMapRec for the publicly accessible fields of a given character\n      map.\n    '''\n\n    def __init__( self, charmap ):\n        '''\n        Create a new Charmap object.\n\n        Parameters:\n        -----------\n        charmap : a FT_Charmap\n        '''\n        self._FT_Charmap = charmap\n\n    encoding = property( lambda self: self._FT_Charmap.contents.encoding,\n         doc = '''An FT_Encoding tag identifying the charmap. Use this with\n                  FT_Select_Charmap.''')\n\n    platform_id = property( lambda self: self._FT_Charmap.contents.platform_id,\n            doc = '''An ID number describing the platform for the following\n                     encoding ID. This comes directly from the TrueType\n                     specification and should be emulated for other\n                     formats.''')\n\n    encoding_id = property( lambda self: self._FT_Charmap.contents.encoding_id,\n            doc = '''A platform specific encoding number. This also comes from\n                     the TrueType specification and should be emulated\n                     similarly.''')\n\n    def _get_encoding_name(self):\n        encoding = self.encoding\n        for key,value in FT_ENCODINGS.items():\n            if encoding == value:\n                return key\n        return 'Unknown encoding'\n    encoding_name = property( _get_encoding_name,\n              doc = '''A platform specific encoding name. This also comes from\n                     the TrueType specification and should be emulated\n                     similarly.''')\n\n    def _get_index( self ):\n        return FT_Get_Charmap_Index( self._FT_Charmap )\n    index = property( _get_index,\n      doc = '''The index into the array of character maps within the face to\n               which 'charmap' belongs. If an error occurs, -1 is returned.''')\n\n    def _get_cmap_language_id( self ):\n        return FT_Get_CMap_Language_ID( self._FT_Charmap )\n    cmap_language_id = property( _get_cmap_language_id,\n                 doc = '''The language ID of 'charmap'. If 'charmap' doesn't\n                          belong to a TrueType/sfnt face, just return 0 as the\n                          default value.''')\n\n    def _get_cmap_format( self ):\n        return FT_Get_CMap_Format( self._FT_Charmap )\n    cmap_format = property( _get_cmap_format,\n            doc = '''The format of 'charmap'. If 'charmap' doesn't belong to a\n                     TrueType/sfnt face, return -1.''')\n\n\n\n# -----------------------------------------------------------------------------\nclass Outline( object ):\n    '''\n    FT_Outline wrapper.\n\n    This structure is used to describe an outline to the scan-line converter.\n    '''\n    def __init__( self, outline ):\n        '''\n        Create a new Outline object.\n\n        :param charmap: a FT_Outline\n        '''\n        self._FT_Outline = outline\n\n    n_contours = property(lambda self: self._FT_Outline.n_contours)\n    def _get_contours(self):\n        n = self._FT_Outline.n_contours\n        data = [self._FT_Outline.contours[i] for i in range(n)]\n        return data\n    contours = property(_get_contours,\n         doc = '''The number of contours in the outline.''')\n\n    n_points = property(lambda self: self._FT_Outline.n_points)\n    def _get_points(self):\n        n = self._FT_Outline.n_points\n        data = []\n        for i in range(n):\n            v = self._FT_Outline.points[i]\n            data.append( (v.x,v.y) )\n        return data\n    points = property( _get_points,\n       doc = '''The number of points in the outline.''')\n\n    def _get_tags(self):\n        n = self._FT_Outline.n_points\n        data = [self._FT_Outline.tags[i] for i in range(n)]\n        return data\n    tags = property(_get_tags,\n     doc = '''A list of 'n_points' chars, giving each outline point's type.\n\n              If bit 0 is unset, the point is 'off' the curve, i.e., a Bezier\n              control point, while it is 'on' if set.\n\n              Bit 1 is meaningful for 'off' points only. If set, it indicates a\n              third-order Bezier arc control point; and a second-order control\n              point if unset.\n\n              If bit 2 is set, bits 5-7 contain the drop-out mode (as defined\n              in the OpenType specification; the value is the same as the\n              argument to the SCANMODE instruction).\n\n              Bits 3 and 4 are reserved for internal purposes.''')\n\n    flags = property(lambda self: self._FT_Outline.flags,\n      doc = '''A set of bit flags used to characterize the outline and give\n               hints to the scan-converter and hinter on how to\n               convert/grid-fit it. See FT_OUTLINE_FLAGS.''')\n\n    def get_inside_border( self ):\n        '''\n        Retrieve the FT_StrokerBorder value corresponding to the 'inside'\n        borders of a given outline.\n\n        :return: The border index. FT_STROKER_BORDER_RIGHT for empty or invalid\n                 outlines.\n        '''\n        return FT_Outline_GetInsideBorder( self._FT_Outline )\n\n    def get_outside_border( self ):\n        '''\n        Retrieve the FT_StrokerBorder value corresponding to the 'outside'\n        borders of a given outline.\n\n        :return: The border index. FT_STROKER_BORDER_RIGHT for empty or invalid\n                 outlines.\n        '''\n        return FT_Outline_GetInsideBorder( self._FT_Outline )\n\n    def get_bbox(self):\n        '''\n        Compute the exact bounding box of an outline. This is slower than\n        computing the control box. However, it uses an advanced algorithm which\n        returns very quickly when the two boxes coincide. Otherwise, the\n        outline Bezier arcs are traversed to extract their extrema.\n        '''\n        bbox = FT_BBox()\n        error = FT_Outline_Get_BBox(byref(self._FT_Outline), byref(bbox))\n        if error: raise FT_Exception(error)\n        return bbox\n\n    def get_cbox(self):\n        '''\n        Return an outline's 'control box'. The control box encloses all the\n        outline's points, including Bezier control points. Though it coincides\n        with the exact bounding box for most glyphs, it can be slightly larger\n        in some situations (like when rotating an outline which contains Bezier\n        outside arcs).\n\n        Computing the control box is very fast, while getting the bounding box\n        can take much more time as it needs to walk over all segments and arcs\n        in the outline. To get the latter, you can use the 'ftbbox' component\n        which is dedicated to this single task.\n        '''\n        bbox = FT_BBox()\n        error = FT_Outline_Get_CBox(byref(self._FT_Outline), byref(bbox))\n        if error: raise FT_Exception(error)\n        return BBox(bbox)\n\n\n\n\n# -----------------------------------------------------------------------------\nclass Glyph( object ):\n    '''\n    FT_Glyph wrapper.\n\n    The root glyph structure contains a given glyph image plus its advance\n    width in 16.16 fixed float format.\n    '''\n    def __init__( self, glyph ):\n        '''\n        Create Glyph object from an FT glyph.\n\n        :param glyph: valid FT_Glyph object\n        '''\n        self._FT_Glyph = glyph\n\n    def __del__( self ):\n        '''\n        Destroy glyph.\n        '''\n        FT_Done_Glyph( self._FT_Glyph )\n\n    def _get_format( self ):\n        return self._FT_Glyph.contents.format\n    format = property( _get_format,\n       doc = '''The format of the glyph's image.''')\n\n\n    def stroke( self, stroker, destroy=False ):\n        '''\n        Stroke a given outline glyph object with a given stroker.\n\n        :param stroker: A stroker handle.\n\n        :param destroy: A Boolean. If 1, the source glyph object is destroyed on\n                        success.\n\n        **Note**:\n\n          The source glyph is untouched in case of error.\n        '''\n        error = FT_Glyph_Stroke( byref(self._FT_Glyph),\n                                 stroker._FT_Stroker, destroy )\n        if error: raise FT_Exception( error )\n\n    def to_bitmap( self, mode, origin, destroy=False ):\n        '''\n        Convert a given glyph object to a bitmap glyph object.\n\n        :param mode: An enumeration that describes how the data is rendered.\n\n        :param origin: A pointer to a vector used to translate the glyph image\n                       before rendering. Can be 0 (if no translation). The origin is\n                       expressed in 26.6 pixels.\n\n        :param destroy: A boolean that indicates that the original glyph image\n                        should be destroyed by this function. It is never destroyed\n                        in case of error.\n\n        **Note**:\n\n          This function does nothing if the glyph format isn't scalable.\n\n          The glyph image is translated with the 'origin' vector before\n          rendering.\n\n          The first parameter is a pointer to an FT_Glyph handle, that will be\n          replaced by this function (with newly allocated data). Typically, you\n          would use (omitting error handling):\n        '''\n        error = FT_Glyph_To_Bitmap( byref(self._FT_Glyph),\n                                    mode, origin, destroy)\n        if error: raise FT_Exception( error )\n        return BitmapGlyph( self._FT_Glyph )\n\n    def get_cbox(self, bbox_mode):\n        '''\n        Return an outline's 'control box'. The control box encloses all the\n        outline's points, including Bezier control points. Though it coincides\n        with the exact bounding box for most glyphs, it can be slightly larger\n        in some situations (like when rotating an outline which contains Bezier\n        outside arcs).\n\n        Computing the control box is very fast, while getting the bounding box\n        can take much more time as it needs to walk over all segments and arcs\n        in the outline. To get the latter, you can use the 'ftbbox' component\n        which is dedicated to this single task.\n\n        :param mode: The mode which indicates how to interpret the returned\n                     bounding box values.\n\n        **Note**:\n\n          Coordinates are relative to the glyph origin, using the y upwards\n          convention.\n\n          If the glyph has been loaded with FT_LOAD_NO_SCALE, 'bbox_mode' must be\n          set to FT_GLYPH_BBOX_UNSCALED to get unscaled font units in 26.6 pixel\n          format. The value FT_GLYPH_BBOX_SUBPIXELS is another name for this\n          constant.\n\n          Note that the maximum coordinates are exclusive, which means that one\n          can compute the width and height of the glyph image (be it in integer\n          or 26.6 pixels) as:\n\n          width  = bbox.xMax - bbox.xMin;\n          height = bbox.yMax - bbox.yMin;\n\n          Note also that for 26.6 coordinates, if 'bbox_mode' is set to\n          FT_GLYPH_BBOX_GRIDFIT, the coordinates will also be grid-fitted, which\n          corresponds to:\n\n          bbox.xMin = FLOOR(bbox.xMin);\n          bbox.yMin = FLOOR(bbox.yMin);\n          bbox.xMax = CEILING(bbox.xMax);\n          bbox.yMax = CEILING(bbox.yMax);\n\n          To get the bbox in pixel coordinates, set 'bbox_mode' to\n          FT_GLYPH_BBOX_TRUNCATE.\n\n          To get the bbox in grid-fitted pixel coordinates, set 'bbox_mode' to\n          FT_GLYPH_BBOX_PIXELS.\n        '''\n        bbox = FT_BBox()\n        error = FT_Glyph_Get_CBox(byref(self._FT_Glyph), bbox_mode,byref(bbox))\n        if error: raise FT_Exception(error)\n        return BBox(bbox)\n\n\n\n# -----------------------------------------------------------------------------\nclass BitmapGlyph( object ):\n    '''\n    FT_BitmapGlyph wrapper.\n\n    A structure used for bitmap glyph images. This really is a 'sub-class' of\n    FT_GlyphRec.\n    '''\n    def __init__( self, glyph ):\n        '''\n        Create Glyph object from an FT glyph.\n\n        Parameters:\n        -----------\n          glyph: valid FT_Glyph object\n        '''\n        self._FT_BitmapGlyph = cast(glyph, FT_BitmapGlyph)\n\n    # def __del__( self ):\n    #     '''\n    #     Destroy glyph.\n    #     '''\n    #     FT_Done_Glyph( cast(self._FT_BitmapGlyph, FT_Glyph) )\n\n\n    def _get_format( self ):\n        return self._FT_BitmapGlyph.contents.format\n    format = property( _get_format,\n       doc = '''The format of the glyph's image.''')\n\n\n    def _get_bitmap( self ):\n        return Bitmap( self._FT_BitmapGlyph.contents.bitmap )\n    bitmap = property( _get_bitmap,\n       doc = '''A descriptor for the bitmap.''')\n\n\n    def _get_left( self ):\n        return self._FT_BitmapGlyph.contents.left\n    left = property( _get_left,\n     doc = '''The left-side bearing, i.e., the horizontal distance from the\n              current pen position to the left border of the glyph bitmap.''')\n\n\n    def _get_top( self ):\n        return self._FT_BitmapGlyph.contents.top\n    top = property( _get_top,\n    doc = '''The top-side bearing, i.e., the vertical distance from the\n             current pen position to the top border of the glyph bitmap.\n             This distance is positive for upwards y!''')\n\n\n# -----------------------------------------------------------------------------\nclass GlyphSlot( object ):\n    '''\n    FT_GlyphSlot wrapper.\n\n    FreeType root glyph slot class structure. A glyph slot is a container where\n    individual glyphs can be loaded, be they in outline or bitmap format.\n    '''\n\n    def __init__( self, slot ):\n        '''\n        Create GlyphSlot object from an FT glyph slot.\n\n        Parameters:\n        -----------\n          glyph: valid FT_GlyphSlot object\n        '''\n        self._FT_GlyphSlot = slot\n\n    def get_glyph( self ):\n        '''\n        A function used to extract a glyph image from a slot. Note that the\n        created FT_Glyph object must be released with FT_Done_Glyph.\n        '''\n        aglyph = FT_Glyph()\n        error = FT_Get_Glyph( self._FT_GlyphSlot, byref(aglyph) )\n        if error: raise FT_Exception( error )\n        return Glyph( aglyph )\n\n    def _get_bitmap( self ):\n        return Bitmap( self._FT_GlyphSlot.contents.bitmap )\n    bitmap = property( _get_bitmap,\n       doc = '''This field is used as a bitmap descriptor when the slot format\n                is FT_GLYPH_FORMAT_BITMAP. Note that the address and content of\n                the bitmap buffer can change between calls of FT_Load_Glyph and\n                a few other functions.''')\n\n    def _get_metrics( self ):\n        return GlyphMetrics( self._FT_GlyphSlot.contents.metrics )\n    metrics = property( _get_metrics,\n       doc = '''The metrics of the last loaded glyph in the slot. The returned\n       values depend on the last load flags (see the FT_Load_Glyph API\n       function) and can be expressed either in 26.6 fractional pixels or font\n       units. Note that even when the glyph image is transformed, the metrics\n       are not.''')\n\n    def _get_next( self ):\n        return GlyphSlot( self._FT_GlyphSlot.contents.next )\n    next = property( _get_next,\n     doc = '''In some cases (like some font tools), several glyph slots per\n              face object can be a good thing. As this is rare, the glyph slots\n              are listed through a direct, single-linked list using its 'next'\n              field.''')\n\n    advance = property( lambda self: self._FT_GlyphSlot.contents.advance,\n        doc = '''This shorthand is, depending on FT_LOAD_IGNORE_TRANSFORM, the\n                 transformed advance width for the glyph (in 26.6 fractional\n                 pixel format). As specified with FT_LOAD_VERTICAL_LAYOUT, it\n                 uses either the 'horiAdvance' or the 'vertAdvance' value of\n                 'metrics' field.''')\n\n    def _get_outline( self ):\n        return Outline( self._FT_GlyphSlot.contents.outline )\n    outline = property( _get_outline,\n        doc = '''The outline descriptor for the current glyph image if its\n                 format is FT_GLYPH_FORMAT_OUTLINE. Once a glyph is loaded,\n                 'outline' can be transformed, distorted, embolded,\n                 etc. However, it must not be freed.''')\n\n    format = property( lambda self: self._FT_GlyphSlot.contents.format,\n       doc = '''This field indicates the format of the image contained in the\n                glyph slot. Typically FT_GLYPH_FORMAT_BITMAP,\n                FT_GLYPH_FORMAT_OUTLINE, or FT_GLYPH_FORMAT_COMPOSITE, but\n                others are possible.''')\n\n    bitmap_top  = property( lambda self:\n                             self._FT_GlyphSlot.contents.bitmap_top,\n            doc = '''This is the bitmap's top bearing expressed in integer\n                     pixels. Remember that this is the distance from the\n                     baseline to the top-most glyph scanline, upwards y\n                     coordinates being positive.''')\n\n    bitmap_left = property( lambda self:\n                            self._FT_GlyphSlot.contents.bitmap_left,\n            doc = '''This is the bitmap's left bearing expressed in integer\n                     pixels. Of course, this is only valid if the format is\n                     FT_GLYPH_FORMAT_BITMAP.''')\n\n    linearHoriAdvance = property( lambda self:\n                                  self._FT_GlyphSlot.contents.linearHoriAdvance,\n                  doc = '''The advance width of the unhinted glyph. Its value\n                           is expressed in 16.16 fractional pixels, unless\n                           FT_LOAD_LINEAR_DESIGN is set when loading the glyph.\n                           This field can be important to perform correct\n                           WYSIWYG layout. Only relevant for outline glyphs.''')\n\n    linearVertAdvance = property( lambda self:\n                                  self._FT_GlyphSlot.contents.linearVertAdvance,\n                  doc = '''The advance height of the unhinted glyph. Its value\n                           is expressed in 16.16 fractional pixels, unless\n                           FT_LOAD_LINEAR_DESIGN is set when loading the glyph.\n                           This field can be important to perform correct\n                           WYSIWYG layout. Only relevant for outline glyphs.''')\n\n\n# -----------------------------------------------------------------------------\n#  Face wrapper\n# -----------------------------------------------------------------------------\nclass Face( object ):\n    '''\n    FT_Face wrapper\n\n    FreeType root face class structure. A face object models a typeface in a\n    font file.\n    '''\n    def __init__( self, filename, index = 0 ):\n        '''\n        Build a new Face\n\n        :param str filename:\n            A path to the font file.\n\n        :param int index:\n               The index of the face within the font.\n               The first face has index 0.\n        '''\n        library = get_handle( )\n        face = FT_Face( )\n        self._FT_Face = None\n        #error = FT_New_Face( library, filename, 0, byref(face) )\n        u_filename = c_char_p(filename.encode())\n        error = FT_New_Face( library, u_filename, index, byref(face) )\n        if error: raise FT_Exception( error )\n        self._filename = filename\n        self._index = index\n        self._FT_Face = face\n\n    def __del__( self ):\n        '''\n        Discard  face object, as well as all of its child slots and sizes.\n        '''\n        if self._FT_Face is not None:\n            FT_Done_Face( self._FT_Face )\n\n\n    def attach_file( self, filename ):\n        '''\n        Attach data to a face object. Normally, this is used to read\n        additional information for the face object. For example, you can attach\n        an AFM file that comes with a Type 1 font to get the kerning values and\n        other metrics.\n\n        :param filename: Filename to attach\n\n        **Note**\n\n        The meaning of the 'attach' (i.e., what really happens when the new\n        file is read) is not fixed by FreeType itself. It really depends on the\n        font format (and thus the font driver).\n\n        Client applications are expected to know what they are doing when\n        invoking this function. Most drivers simply do not implement file\n        attachments.\n        '''\n\n        error = FT_Attach_File( self._FT_Face, filename)\n        if error: raise FT_Exception( error)\n\n\n    def set_char_size( self, width=0, height=0, hres=72, vres=72 ):\n        '''\n        This function calls FT_Request_Size to request the nominal size (in\n        points).\n\n        :param float width: The nominal width, in 26.6 fractional points.\n\n        :param float height: The nominal height, in 26.6 fractional points.\n\n        :param float hres: The horizontal resolution in dpi.\n\n        :param float vres: The vertical resolution in dpi.\n\n        **Note**\n\n        If either the character width or height is zero, it is set equal to the\n        other value.\n\n        If either the horizontal or vertical resolution is zero, it is set\n        equal to the other value.\n\n        A character width or height smaller than 1pt is set to 1pt; if both\n        resolution values are zero, they are set to 72dpi.\n\n        Don't use this function if you are using the FreeType cache API.\n        '''\n        error = FT_Set_Char_Size( self._FT_Face, width, height, hres, vres )\n        if error: raise FT_Exception( error)\n\n    def set_pixel_sizes( self, width, height ):\n        '''\n        This function calls FT_Request_Size to request the nominal size (in\n        pixels).\n\n        :param width: The nominal width, in pixels.\n\n        :param height: The nominal height, in pixels.\n        '''\n        error = FT_Set_Pixel_Sizes( self._FT_Face, width, height )\n        if error: raise FT_Exception(error)\n\n    def select_charmap( self, encoding ):\n        '''\n        Select a given charmap by its encoding tag (as listed in 'freetype.h').\n\n        **Note**:\n\n          This function returns an error if no charmap in the face corresponds to\n          the encoding queried here.\n\n          Because many fonts contain more than a single cmap for Unicode\n          encoding, this function has some special code to select the one which\n          covers Unicode best ('best' in the sense that a UCS-4 cmap is preferred\n          to a UCS-2 cmap). It is thus preferable to FT_Set_Charmap in this case.\n        '''\n        error = FT_Select_Charmap( self._FT_Face, encoding )\n        if error: raise FT_Exception(error)\n\n    def set_charmap( self, charmap ):\n        '''\n        Select a given charmap for character code to glyph index mapping.\n\n        :param charmap: A handle to the selected charmap.\n        '''\n        error = FT_Set_Charmap( self._FT_Face, charmap._FT_Charmap )\n        if error : raise FT_Exception(error)\n\n    def get_char_index( self, charcode ):\n        '''\n        Return the glyph index of a given character code. This function uses a\n        charmap object to do the mapping.\n\n        :param charcode: The character code.\n\n        **Note**:\n\n          If you use FreeType to manipulate the contents of font files directly,\n          be aware that the glyph index returned by this function doesn't always\n          correspond to the internal indices used within the file. This is done\n          to ensure that value 0 always corresponds to the 'missing glyph'.\n        '''\n        if type( charcode ) in (str,text_type):\n            charcode = ord( charcode )\n        return FT_Get_Char_Index( self._FT_Face, charcode )\n\n    def get_first_char( self ):\n        '''\n        This function is used to return the first character code in the current\n        charmap of a given face. It also returns the corresponding glyph index.\n\n        :return: Glyph index of first character code. 0 if charmap is empty.\n\n        **Note**:\n\n          You should use this function with get_next_char to be able to parse\n          all character codes available in a given charmap. The code should look\n          like this:\n\n          Note that 'agindex' is set to 0 if the charmap is empty. The result\n          itself can be 0 in two cases: if the charmap is empty or if the value 0\n          is the first valid character code.\n        '''\n        agindex = FT_UInt()\n        charcode = FT_Get_First_Char( self._FT_Face, byref(agindex) )\n        return charcode, agindex.value\n\n    def get_next_char( self, charcode, agindex ):\n        '''\n        This function is used to return the next character code in the current\n        charmap of a given face following the value 'charcode', as well as the\n        corresponding glyph index.\n\n        :param charcode: The starting character code.\n\n        :param agindex: Glyph index of next character code. 0 if charmap is empty.\n\n        **Note**:\n\n          You should use this function with FT_Get_First_Char to walk over all\n          character codes available in a given charmap. See the note for this\n          function for a simple code example.\n\n          Note that 'agindex' is set to 0 when there are no more codes in the\n          charmap.\n        '''\n        agindex = FT_UInt( 0 ) #agindex )\n        charcode = FT_Get_Next_Char( self._FT_Face, charcode, byref(agindex) )\n        return charcode, agindex.value\n\n    def get_name_index( self, name ):\n        '''\n        Return the glyph index of a given glyph name. This function uses driver\n        specific objects to do the translation.\n\n        :param name: The glyph name.\n        '''\n        return FT_Get_Name_Index( self._FT_Face, name )\n\n    def set_transform( self, matrix, delta ):\n        '''\n        A function used to set the transformation that is applied to glyph\n        images when they are loaded into a glyph slot through FT_Load_Glyph.\n\n        :param matrix: A pointer to the transformation's 2x2 matrix.\n                       Use 0 for the identity matrix.\n\n        :parm delta: A pointer to the translation vector.\n                     Use 0 for the null vector.\n\n        **Note**:\n\n          The transformation is only applied to scalable image formats after the\n          glyph has been loaded. It means that hinting is unaltered by the\n          transformation and is performed on the character size given in the last\n          call to FT_Set_Char_Size or FT_Set_Pixel_Sizes.\n\n          Note that this also transforms the 'face.glyph.advance' field, but\n          not the values in 'face.glyph.metrics'.\n        '''\n        FT_Set_Transform( self._FT_Face,\n                          byref(matrix), byref(delta) )\n\n    def select_size( self, strike_index ):\n        '''\n        Select a bitmap strike.\n\n        :param strike_index: The index of the bitmap strike in the\n                             'available_sizes' field of Face object.\n        '''\n        error = FT_Select_Size( self._FT_Face, strike_index )\n        if error: raise FT_Exception( error )\n\n    def load_glyph( self, index, flags = FT_LOAD_RENDER ):\n        '''\n        A function used to load a single glyph into the glyph slot of a face\n        object.\n\n        :param index: The index of the glyph in the font file. For CID-keyed\n                      fonts (either in PS or in CFF format) this argument\n                      specifies the CID value.\n\n        :param flags: A flag indicating what to load for this glyph. The FT_LOAD_XXX\n                      constants can be used to control the glyph loading process\n                      (e.g., whether the outline should be scaled, whether to load\n                      bitmaps or not, whether to hint the outline, etc).\n\n        **Note**:\n\n          The loaded glyph may be transformed. See FT_Set_Transform for the\n          details.\n\n          For subsetted CID-keyed fonts, 'FT_Err_Invalid_Argument' is returned\n          for invalid CID values (this is, for CID values which don't have a\n          corresponding glyph in the font). See the discussion of the\n          FT_FACE_FLAG_CID_KEYED flag for more details.\n        '''\n        error = FT_Load_Glyph( self._FT_Face, index, flags )\n        if error: raise FT_Exception( error )\n\n    def load_char( self, char, flags = FT_LOAD_RENDER ):\n        '''\n        A function used to load a single glyph into the glyph slot of a face\n        object, according to its character code.\n\n        :param char: The glyph's character code, according to the current\n                     charmap used in the face.\n\n        :param flags: A flag indicating what to load for this glyph. The\n                      FT_LOAD_XXX constants can be used to control the glyph\n                      loading process (e.g., whether the outline should be\n                      scaled, whether to load bitmaps or not, whether to hint\n                      the outline, etc).\n\n        **Note**:\n\n          This function simply calls FT_Get_Char_Index and FT_Load_Glyph.\n        '''\n\n        if len(char) == 1:\n            char = ord(char)\n        error = FT_Load_Char( self._FT_Face, char, flags )\n        if error: raise FT_Exception( error )\n\n\n    def get_advance( self, gindex, flags ):\n        '''\n        Retrieve the advance value of a given glyph outline in an FT_Face. By\n        default, the unhinted advance is returned in font units.\n\n        :param gindex: The glyph index.\n\n        :param flags: A set of bit flags similar to those used when calling\n                      FT_Load_Glyph, used to determine what kind of advances\n                      you need.\n\n        :return: The advance value, in either font units or 16.16 format.\n\n                 If FT_LOAD_VERTICAL_LAYOUT is set, this is the vertical\n                 advance corresponding to a vertical layout. Otherwise, it is\n                 the horizontal advance in a horizontal layout.\n        '''\n\n        padvance = FT_Fixed(0)\n        error = FT_Get_Advance( self._FT_Face, gindex, flags, byref(padvance) )\n        if error: raise FT_Exception( error )\n        return padvance.value\n\n\n\n    def get_kerning( self, left, right, mode = FT_KERNING_DEFAULT ):\n        '''\n        Return the kerning vector between two glyphs of a same face.\n\n        :param left: The index of the left glyph in the kern pair.\n\n        :param right: The index of the right glyph in the kern pair.\n\n        :param mode: See FT_Kerning_Mode for more information. Determines the scale\n                     and dimension of the returned kerning vector.\n\n        **Note**:\n\n          Only horizontal layouts (left-to-right & right-to-left) are supported\n          by this method. Other layouts, or more sophisticated kernings, are out\n          of the scope of this API function -- they can be implemented through\n          format-specific interfaces.\n        '''\n        left_glyph = self.get_char_index( left )\n        right_glyph = self.get_char_index( right )\n        kerning = FT_Vector(0,0)\n        error = FT_Get_Kerning( self._FT_Face,\n                                left_glyph, right_glyph, mode, byref(kerning) )\n        if error: raise FT_Exception( error )\n        return kerning\n\n    def get_format(self):\n        '''\n        Return a string describing the format of a given face, using values\n        which can be used as an X11 FONT_PROPERTY. Possible values are\n        'TrueType', 'Type 1', 'BDF', \xe2\x80\x98PCF', \xe2\x80\x98Type 42', \xe2\x80\x98CID Type 1', \xe2\x80\x98CFF',\n        'PFR', and \xe2\x80\x98Windows FNT'.\n        '''\n\n        return FT_Get_X11_Font_Format( self._FT_Face )\n\n\n    def get_fstype(self):\n        '''\n        Return the fsType flags for a font (embedding permissions).\n\n        The return value is a tuple containing the freetype enum name\n        as a string and the actual flag as an int\n        '''\n\n        flag = FT_Get_FSType_Flags( self._FT_Face )\n        for k, v in FT_FSTYPE_XXX.items():\n            if v == flag:\n                return k, v\n\n\n    def _get_sfnt_name_count(self):\n        return FT_Get_Sfnt_Name_Count( self._FT_Face )\n    sfnt_name_count = property(_get_sfnt_name_count,\n                doc = '''Number of name strings in the SFNT 'name' table.''')\n\n    def get_sfnt_name( self, index ):\n        '''\n        Retrieve a string of the SFNT 'name' table for a given index\n\n        :param index: The index of the 'name' string.\n\n        **Note**:\n\n          The 'string' array returned in the 'aname' structure is not\n          null-terminated. The application should deallocate it if it is no\n          longer in use.\n\n          Use FT_Get_Sfnt_Name_Count to get the total number of available\n          'name' table entries, then do a loop until you get the right\n          platform, encoding, and name ID.\n        '''\n        name = FT_SfntName( )\n        error = FT_Get_Sfnt_Name( self._FT_Face, index, byref(name) )\n        if error: raise FT_Exception( error )\n        return SfntName( name )\n\n    def _get_postscript_name( self ):\n        return FT_Get_Postscript_Name( self._FT_Face )\n    postscript_name = property( _get_postscript_name,\n                doc = '''ASCII PostScript name of face, if available. This only\n                         works with PostScript and TrueType fonts.''')\n\n    def _has_horizontal( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_HORIZONTAL )\n    has_horizontal = property( _has_horizontal,\n               doc = '''True whenever a face object contains horizontal metrics\n               (this is true for all font formats though).''')\n\n    def _has_vertical( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_VERTICAL )\n    has_vertical = property( _has_vertical,\n             doc = '''True whenever a face object contains vertical metrics.''')\n\n    def _has_kerning( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_KERNING )\n    has_kerning = property( _has_kerning,\n            doc = '''True whenever a face object contains kerning data that can\n                     be accessed with FT_Get_Kerning.''')\n\n    def _is_scalable( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_SCALABLE )\n    is_scalable = property( _is_scalable,\n            doc = '''true whenever a face object contains a scalable font face\n                     (true for TrueType, Type 1, Type 42, CID, OpenType/CFF,\n                     and PFR font formats.''')\n\n    def _is_sfnt( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_SFNT )\n    is_sfnt = property( _is_sfnt,\n        doc = '''true whenever a face object contains a font whose format is\n                 based on the SFNT storage scheme. This usually means: TrueType\n                 fonts, OpenType fonts, as well as SFNT-based embedded bitmap\n                 fonts.\n\n                 If this macro is true, all functions defined in\n                 FT_SFNT_NAMES_H and FT_TRUETYPE_TABLES_H are available.''')\n\n    def _is_fixed_width( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_FIXED_WIDTH )\n    is_fixed_width = property( _is_fixed_width,\n               doc = '''True whenever a face object contains a font face that\n                        contains fixed-width (or 'monospace', 'fixed-pitch',\n                        etc.) glyphs.''')\n\n    def _has_fixed_sizes( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_FIXED_SIZES )\n    has_fixed_sizes = property( _has_fixed_sizes,\n                doc = '''True whenever a face object contains some embedded\n                bitmaps. See the 'available_sizes' field of the FT_FaceRec\n                structure.''')\n\n    def _has_glyph_names( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_GLYPH_NAMES )\n    has_glyph_names = property( _has_glyph_names,\n                doc = '''True whenever a face object contains some glyph names\n                         that can be accessed through FT_Get_Glyph_Name.''')\n\n    def _has_multiple_masters( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_MULTIPLE_MASTERS )\n    has_multiple_masters = property( _has_multiple_masters,\n                     doc = '''True whenever a face object contains some\n                              multiple masters. The functions provided by\n                              FT_MULTIPLE_MASTERS_H are then available to\n                              choose the exact design you want.''')\n\n    def _is_cid_keyed( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_CID_KEYED )\n    is_cid_keyed = property( _is_cid_keyed,\n             doc = '''True whenever a face object contains a CID-keyed\n                      font. See the discussion of FT_FACE_FLAG_CID_KEYED for\n                      more details.\n\n                      If this macro is true, all functions defined in FT_CID_H\n                      are available.''')\n\n    def _is_tricky( self ):\n        return bool( self.face_flags & FT_FACE_FLAG_TRICKY )\n    is_tricky = property( _is_tricky,\n          doc = '''True whenever a face represents a 'tricky' font. See the\n                   discussion of FT_FACE_FLAG_TRICKY for more details.''')\n\n\n    num_faces = property(lambda self: self._FT_Face.contents.num_faces,\n          doc = '''The number of faces in the font file. Some font formats can\n                   have multiple faces in a font file.''')\n\n    face_index = property(lambda self: self._FT_Face.contents.face_index,\n           doc = '''The index of the face in the font file. It is set to 0 if\n                    there is only one face in the font file.''')\n\n    face_flags = property(lambda self: self._FT_Face.contents.face_flags,\n           doc = '''A set of bit flags that give important information about\n                    the face; see FT_FACE_FLAG_XXX for the details.''')\n\n    style_flags = property(lambda self: self._FT_Face.contents.style_flags,\n            doc = '''A set of bit flags indicating the style of the face; see\n                     FT_STYLE_FLAG_XXX for the details.''')\n\n    num_glyphs = property(lambda self: self._FT_Face.contents.num_glyphs,\n           doc = '''The number of glyphs in the face. If the face is scalable\n           and has sbits (see 'num_fixed_sizes'), it is set to the number of\n           outline glyphs.\n\n           For CID-keyed fonts, this value gives the highest CID used in the\n           font.''')\n\n    family_name = property(lambda self: self._FT_Face.contents.family_name,\n            doc = '''The face's family name. This is an ASCII string, usually\n                     in English, which describes the typeface's family (like\n                     'Times New Roman', 'Bodoni', 'Garamond', etc). This is a\n                     least common denominator used to list fonts. Some formats\n                     (TrueType & OpenType) provide localized and Unicode\n                     versions of this string. Applications should use the\n                     format specific interface to access them. Can be NULL\n                     (e.g., in fonts embedded in a PDF file).''')\n\n    style_name = property(lambda self: self._FT_Face.contents.style_name,\n           doc = '''The face's style name. This is an ASCII string, usually in\n                    English, which describes the typeface's style (like\n                    'Italic', 'Bold', 'Condensed', etc). Not all font formats\n                    provide a style name, so this field is optional, and can be\n                    set to NULL. As for 'family_name', some formats provide\n                    localized and Unicode versions of this string. Applications\n                    should use the format specific interface to access them.''')\n\n    num_fixed_sizes = property(lambda self: self._FT_Face.contents.num_fixed_sizes,\n                doc = '''The number of bitmap strikes in the face. Even if the\n                         face is scalable, there might still be bitmap strikes,\n                         which are called 'sbits' in that case.''')\n\n    def _get_available_sizes( self ):\n        sizes = []\n        n = self.num_fixed_sizes\n        FT_sizes = self._FT_Face.contents.available_sizes\n        for i in range(n):\n            sizes.append( BitmapSize(FT_sizes[i]) )\n        return sizes\n    available_sizes = property(_get_available_sizes,\n                doc = '''A list of FT_Bitmap_Size for all bitmap strikes in the\n                face. It is set to NULL if there is no bitmap strike.''')\n\n    num_charmaps = property(lambda self: self._FT_Face.contents.num_charmaps)\n    def _get_charmaps( self ):\n        charmaps = []\n        n = self._FT_Face.contents.num_charmaps\n        FT_charmaps = self._FT_Face.contents.charmaps\n        for i in range(n):\n            charmaps.append( Charmap(FT_charmaps[i]) )\n        return charmaps\n    charmaps = property(_get_charmaps,\n         doc = '''A list of the charmaps of the face.''')\n\n    #       ('generic', FT_Generic),\n\n    def _get_bbox( self ):\n        return BBox( self._FT_Face.contents.bbox )\n    bbox = property( _get_bbox,\n     doc = '''The font bounding box. Coordinates are expressed in font units\n              (see 'units_per_EM'). The box is large enough to contain any\n              glyph from the font. Thus, 'bbox.yMax' can be seen as the\n              'maximal ascender', and 'bbox.yMin' as the 'minimal\n              descender'. Only relevant for scalable formats.\n\n              Note that the bounding box might be off by (at least) one pixel\n              for hinted fonts. See FT_Size_Metrics for further discussion.''')\n\n    units_per_EM = property(lambda self: self._FT_Face.contents.units_per_EM,\n             doc = '''The number of font units per EM square for this\n                      face. This is typically 2048 for TrueType fonts, and 1000\n                      for Type 1 fonts. Only relevant for scalable formats.''')\n\n    ascender = property(lambda self: self._FT_Face.contents.ascender,\n         doc = '''The typographic ascender of the face, expressed in font\n                  units. For font formats not having this information, it is\n                  set to 'bbox.yMax'. Only relevant for scalable formats.''')\n\n    descender = property(lambda self: self._FT_Face.contents.descender,\n          doc = '''The typographic descender of the face, expressed in font\n                   units. For font formats not having this information, it is\n                   set to 'bbox.yMin'. Note that this field is usually\n                   negative. Only relevant for scalable formats.''')\n\n    height = property(lambda self: self._FT_Face.contents.height,\n       doc = '''The height is the vertical distance between two consecutive\n                baselines, expressed in font units. It is always positive. Only\n                relevant for scalable formats.''')\n\n    max_advance_width = property(lambda self: self._FT_Face.contents.max_advance_width,\n                  doc = '''The maximal advance width, in font units, for all\n                           glyphs in this face. This can be used to make word\n                           wrapping computations faster. Only relevant for\n                           scalable formats.''')\n\n    max_advance_height = property(lambda self: self._FT_Face.contents.max_advance_height,\n                   doc = '''The maximal advance height, in font units, for all\n                            glyphs in this face. This is only relevant for\n                            vertical layouts, and is set to 'height' for fonts\n                            that do not provide vertical metrics. Only relevant\n                            for scalable formats.''')\n\n    underline_position = property(lambda self: self._FT_Face.contents.underline_position,\n                   doc = '''The position, in font units, of the underline line\n                            for this face. It is the center of the underlining\n                            stem. Only relevant for scalable formats.''')\n\n    underline_thickness = property(lambda self: self._FT_Face.contents.underline_thickness,\n                    doc = '''The thickness, in font units, of the underline for\n                             this face. Only relevant for scalable formats.''')\n\n\n    def _get_glyph( self ):\n        return GlyphSlot( self._FT_Face.contents.glyph )\n    glyph = property( _get_glyph,\n      doc = '''The face's associated glyph slot(s).''')\n\n    def _get_size( self ):\n        size = self._FT_Face.contents.size\n        metrics = size.contents.metrics\n        return SizeMetrics(metrics)\n    size = property( _get_size,\n     doc = '''The current active size for this face.''')\n\n    def _get_charmap( self ):\n        return Charmap( self._FT_Face.contents.charmap)\n    charmap = property( _get_charmap,\n        doc = '''The current active charmap for this face.''')\n\n\n\n# -----------------------------------------------------------------------------\n#  SfntName wrapper\n# -----------------------------------------------------------------------------\nclass SfntName( object ):\n    '''\n    SfntName wrapper\n\n    A structure used to model an SFNT 'name' table entry.\n    '''\n    def __init__(self, name):\n        '''\n        Create a new SfntName object.\n\n        :param name : SFNT 'name' table entry.\n\n        '''\n        self._FT_SfntName = name\n\n    platform_id = property(lambda self: self._FT_SfntName.platform_id,\n            doc = '''The platform ID for 'string'.''')\n\n    encoding_id = property(lambda self: self._FT_SfntName.encoding_id,\n            doc = '''The encoding ID for 'string'.''')\n\n    language_id = property(lambda self: self._FT_SfntName.language_id,\n            doc = '''The language ID for 'string'.''')\n\n    name_id = property(lambda self: self._FT_SfntName.name_id,\n        doc = '''An identifier for 'string'.''')\n\n    #string      = property(lambda self: self._FT_SfntName.string)\n\n    string_len = property(lambda self: self._FT_SfntName.string_len,\n           doc = '''The length of 'string' in bytes.''')\n\n    def _get_string(self):\n    #     #s = self._FT_SfntName\n         s = string_at(self._FT_SfntName.string, self._FT_SfntName.string_len)\n         return s\n    #     #return s.decode('utf-16be', 'ignore')\n    #     return s.decode('utf-8', 'ignore')\n    #     #n = s.string_len\n    #     #data = [s.string[i] for i in range(n)]\n    #     #return data\n    string = property(_get_string,\n       doc = '''The 'name' string. Note that its format differs depending on\n                the (platform,encoding) pair. It can be a Pascal String, a\n                UTF-16 one, etc.\n\n                Generally speaking, the string is not zero-terminated. Please\n                refer to the TrueType specification for details.''')\n\n\n\n# -----------------------------------------------------------------------------\nclass Stroker( object ):\n    '''\n    FT_Stroker wrapper\n\n    This component generates stroked outlines of a given vectorial glyph. It\n    also allows you to retrieve the 'outside' and/or the 'inside' borders of\n    the stroke.\n\n    This can be useful to generate 'bordered' glyph, i.e., glyphs displayed\n    with a coloured (and anti-aliased) border around their shape.\n    '''\n\n    def __init__( self ):\n        '''\n        Create a new Stroker object.\n        '''\n        library = get_handle( )\n        stroker = FT_Stroker( )\n        error = FT_Stroker_New( library, byref(stroker) )\n        if error: raise FT_Exception( error )\n        self._FT_Stroker = stroker\n\n\n    def __del__( self ):\n        '''\n        Destroy object.\n        '''\n        FT_Stroker_Done( self._FT_Stroker )\n\n\n    def set( self, radius, line_cap, line_join, miter_limit ):\n        '''\n        Reset a stroker object's attributes.\n\n        :param radius: The border radius.\n\n        :param line_cap: The line cap style.\n\n        :param line_join: The line join style.\n\n        :param miter_limit: The miter limit for the FT_STROKER_LINEJOIN_MITER\n                            style, expressed as 16.16 fixed point value.\n\n        **Note**:\n\n          The radius is expressed in the same units as the outline coordinates.\n        '''\n        FT_Stroker_Set( self._FT_Stroker,\n                        radius, line_cap, line_join, miter_limit )\n\n\n    def rewind( self ):\n        '''\n        Reset a stroker object without changing its attributes. You should call\n        this function before beginning a new series of calls to\n        FT_Stroker_BeginSubPath or FT_Stroker_EndSubPath.\n        '''\n        FT_Stroker_Rewind( self._FT_Stroker )\n\n\n    def parse_outline( self, outline, opened ):\n        '''\n        A convenience function used to parse a whole outline with the\n        stroker. The resulting outline(s) can be retrieved later by functions\n        like FT_Stroker_GetCounts and FT_Stroker_Export.\n\n        :param outline: The source outline.\n\n        :pram opened: A boolean. If 1, the outline is treated as an open path\n                      instead of a closed one.\n\n        **Note**:\n\n          If 'opened' is 0 (the default), the outline is treated as a closed\n          path, and the stroker generates two distinct 'border' outlines.\n\n          If 'opened' is 1, the outline is processed as an open path, and the\n          stroker generates a single 'stroke' outline.\n\n          This function calls 'rewind' automatically.\n        '''\n        error = FT_Stroker_ParseOutline( self._FT_Stroker, outline, opened)\n        if error: raise FT_Exception( error )\n\n\n    def begin_subpath( self, to, _open ):\n        '''\n        Start a new sub-path in the stroker.\n\n        :param to A pointer to the start vector.\n\n        :param _open: A boolean. If 1, the sub-path is treated as an open one.\n\n        **Note**:\n\n          This function is useful when you need to stroke a path that is not\n          stored as an 'Outline' object.\n        '''\n        error = FT_Stroker_BeginSubPath( self._FT_Stroker, to, _open )\n        if error: raise FT_Exception( error )\n\n\n    def end_subpath( self ):\n        '''\n        Close the current sub-path in the stroker.\n\n        **Note**:\n\n          You should call this function after 'begin_subpath'. If the subpath\n          was not 'opened', this function 'draws' a single line segment to the\n          start position when needed.\n        '''\n        error = FT_Stroker_EndSubPath( self._FT_Stroker)\n        if error: raise FT_Exception( error )\n\n\n    def line_to( self, to ):\n        '''\n        'Draw' a single line segment in the stroker's current sub-path, from\n        the last position.\n\n        :param to: A pointer to the destination point.\n\n        **Note**:\n\n          You should call this function between 'begin_subpath' and\n          'end_subpath'.\n        '''\n        error = FT_Stroker_LineTo( self._FT_Stroker, to )\n        if error: raise FT_Exception( error )\n\n\n    def conic_to( self, control, to ):\n        '''\n        'Draw' a single quadratic Bezier in the stroker's current sub-path,\n        from the last position.\n\n        :param control: A pointer to a Bezier control point.\n\n        :param to: A pointer to the destination point.\n\n        **Note**:\n\n          You should call this function between 'begin_subpath' and\n          'end_subpath'.\n        '''\n        error = FT_Stroker_ConicTo( self._FT_Stroker, control, to )\n        if error: raise FT_Exception( error )\n\n\n    def cubic_to( self, control1, control2, to ):\n        '''\n        'Draw' a single quadratic Bezier in the stroker's current sub-path,\n        from the last position.\n\n        :param control1: A pointer to the first Bezier control point.\n\n        :param control2: A pointer to second Bezier control point.\n\n        :param to: A pointer to the destination point.\n\n        **Note**:\n\n          You should call this function between 'begin_subpath' and\n          'end_subpath'.\n        '''\n        error = FT_Stroker_CubicTo( self._FT_Stroker, control1, control2, to )\n        if error: raise FT_Exception( error )\n\n\n    def get_border_counts( self, border ):\n        '''\n        Call this function once you have finished parsing your paths with the\n        stroker. It returns the number of points and contours necessary to\n        export one of the 'border' or 'stroke' outlines generated by the\n        stroker.\n\n        :param border: The border index.\n\n        :return: number of points, number of contours\n        '''\n        anum_points = FT_UInt()\n        anum_contours = FT_UInt()\n        error = FT_Stroker_GetBorderCounts( self._FT_Stroker, border,\n                                    byref(anum_points), byref(anum_contours) )\n        if error: raise FT_Exception( error )\n        return anum_points.value, anum_contours.value\n\n\n    def export_border( self , border, outline ):\n        '''\n        Call this function after 'get_border_counts' to export the\n        corresponding border to your own 'Outline' structure.\n\n        Note that this function appends the border points and contours to your\n        outline, but does not try to resize its arrays.\n\n        :param border:  The border index.\n\n        :param outline: The target outline.\n\n        **Note**:\n\n          Always call this function after get_border_counts to get sure that\n          there is enough room in your 'Outline' object to receive all new\n          data.\n\n          When an outline, or a sub-path, is 'closed', the stroker generates two\n          independent 'border' outlines, named 'left' and 'right'\n\n          When the outline, or a sub-path, is 'opened', the stroker merges the\n          'border' outlines with caps. The 'left' border receives all points,\n          while the 'right' border becomes empty.\n\n          Use the function export instead if you want to retrieve all borders\n          at once.\n        '''\n        FT_Stroker_ExportBorder( self._FT_Stroker, border, outline._FT_Outline )\n\n\n    def get_counts( self ):\n        '''\n        Call this function once you have finished parsing your paths with the\n        stroker. It returns the number of points and contours necessary to\n        export all points/borders from the stroked outline/path.\n\n        :return: number of points, number of contours\n        '''\n\n        anum_points = FT_UInt()\n        anum_contours = FT_UInt()\n        error = FT_Stroker_GetCounts( self._FT_Stroker,\n                                      byref(anum_points), byref(anum_contours) )\n        if error: raise FT_Exception( error )\n        return anum_points.value, anum_contours.value\n\n\n    def export( self, outline ):\n        '''\n        Call this function after get_border_counts to export all borders to\n        your own 'Outline' structure.\n\n        Note that this function appends the border points and contours to your\n        outline, but does not try to resize its arrays.\n\n        :param outline: The target outline.\n        '''\n        FT_Stroker_Export( self._FT_Stroker, outline._FT_Outline )\n"""
glumpy/ext/freetype/ft_errors.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n\'\'\'\nInternal exception with freetype error message\n\'\'\'\nclass FT_Exception(Exception):\n    def __init__(self, errcode, message=\'\'):\n        self.message = message\n        self.errcode = errcode\n\n    def __str__(self):\n        return \'%s: %s (%s)\'%(self.__class__.__name__, self.message,\n            self._errors.get(self.errcode, \'unknown error\'))\n\n    _errors = {\n        0x00: ""no error"" ,\n        0x01: ""cannot open resource"" ,\n        0x02: ""unknown file format"" ,\n        0x03: ""broken file"" ,\n        0x04: ""invalid FreeType version"" ,\n        0x05: ""module version is too low"" ,\n        0x06: ""invalid argument"" ,\n        0x07: ""unimplemented feature"" ,\n        0x08: ""broken table"" ,\n        0x09: ""broken offset within table"" ,\n        0x10: ""invalid glyph index"" ,\n        0x11: ""invalid character code"" ,\n        0x12: ""unsupported glyph image format"" ,\n        0x13: ""cannot render this glyph format"" ,\n        0x14: ""invalid outline"" ,\n        0x15: ""invalid composite glyph"" ,\n        0x16: ""too many hints"" ,\n        0x17: ""invalid pixel size"" ,\n        0x20: ""invalid object handle"" ,\n        0x21: ""invalid library handle"" ,\n        0x22: ""invalid module handle"" ,\n        0x23: ""invalid face handle"" ,\n        0x24: ""invalid size handle"" ,\n        0x25: ""invalid glyph slot handle"" ,\n        0x26: ""invalid charmap handle"" ,\n        0x27: ""invalid cache manager handle"" ,\n        0x28: ""invalid stream handle"" ,\n        0x30: ""too many modules"" ,\n        0x31: ""too many extensions"" ,\n        0x40: ""out of memory"" ,\n        0x41: ""unlisted object"" ,\n        0x51: ""cannot open stream"" ,\n        0x52: ""invalid stream seek"" ,\n        0x53: ""invalid stream skip"" ,\n        0x54: ""invalid stream read"" ,\n        0x55: ""invalid stream operation"" ,\n        0x56: ""invalid frame operation"" ,\n        0x57: ""nested frame access"" ,\n        0x58: ""invalid frame read"" ,\n        0x60: ""raster uninitialized"" ,\n        0x61: ""raster corrupted"" ,\n        0x62: ""raster overflow"" ,\n        0x63: ""negative height while rastering"" ,\n        0x70: ""too many registered caches"" ,\n        0x80: ""invalid opcode"" ,\n        0x81: ""too few arguments"" ,\n        0x82: ""stack overflow"" ,\n        0x83: ""code overflow"" ,\n        0x84: ""bad argument"" ,\n        0x85: ""division by zero"" ,\n        0x86: ""invalid reference"" ,\n        0x87: ""found debug opcode"" ,\n        0x88: ""found ENDF opcode in execution stream"" ,\n        0x89: ""nested DEFS"" ,\n        0x8A: ""invalid code range"" ,\n        0x8B: ""execution context too long"" ,\n        0x8C: ""too many function definitions"" ,\n        0x8D: ""too many instruction definitions"" ,\n        0x8E: ""SFNT font table missing"" ,\n        0x8F: ""horizontal header (hhea, table missing"" ,\n        0x90: ""locations (loca, table missing"" ,\n        0x91: ""name table missing"" ,\n        0x92: ""character map (cmap, table missing"" ,\n        0x93: ""horizontal metrics (hmtx, table missing"" ,\n        0x94: ""PostScript (post, table missing"" ,\n        0x95: ""invalid horizontal metrics"" ,\n        0x96: ""invalid character map (cmap, format"" ,\n        0x97: ""invalid ppem value"" ,\n        0x98: ""invalid vertical metrics"" ,\n        0x99: ""could not find context"" ,\n        0x9A: ""invalid PostScript (post, table format"" ,\n        0x9B: ""invalid PostScript (post, table"" ,\n        0xA0: ""opcode syntax error"" ,\n        0xA1: ""argument stack underflow"" ,\n        0xA2: ""ignore"" ,\n        0xB0: ""`STARTFONT\' field missing"" ,\n        0xB1: ""`FONT\' field missing"" ,\n        0xB2: ""`SIZE\' field missing"" ,\n        0xB3: ""`CHARS\' field missing"" ,\n        0xB4: ""`STARTCHAR\' field missing"" ,\n        0xB5: ""`ENCODING\' field missing"" ,\n        0xB6: ""`BBX\' field missing"" ,\n        0xB7: ""`BBX\' too big"" ,\n    }\n'"
glumpy/ext/freetype/ft_structs.py,0,"b""#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n'''\nFreetype structured types\n-------------------------\n\nFT_Library: A handle to a FreeType library instance.\n\nFT_Vector: A simple structure used to store a 2D vector.\n\nFT_BBox: A structure used to hold an outline's bounding box.\n\nFT_Matrix: A simple structure used to store a 2x2 matrix.\n\nFT_UnitVector: A simple structure used to store a 2D vector unit vector.\n\nFT_Bitmap: A structure used to describe a bitmap or pixmap to the raster.\n\nFT_Data: Read-only binary data represented as a pointer and a length.\n\nFT_Generic: Client applications generic data.\n\nFT_Bitmap_Size: Metrics of a bitmap strike.\n\nFT_Charmap: The base charmap structure.\n\nFT_Glyph_Metrics:A structure used to model the metrics of a single glyph.\n\nFT_Outline: This structure is used to describe an outline to the scan-line\n            converter.\n\nFT_GlyphSlot: FreeType root glyph slot class structure.\n\nFT_Glyph: The root glyph structure contains a given glyph image plus its\n           advance width in 16.16 fixed float format.\n\nFT_Size_Metrics: The size metrics structure gives the metrics of a size object.\n\nFT_Size: FreeType root size class structure.\n\nFT_Face: FreeType root face class structure.\n\nFT_Parameter: A simple structure used to pass more or less generic parameters\n              to FT_Open_Face.\n\nFT_Open_Args: A structure used to indicate how to open a new font file or\n              stream.\n\nFT_SfntName: A structure used to model an SFNT 'name' table entry.\n\nFT_Stroker: Opaque handler to a path stroker object.\n\nFT_BitmapGlyph: A structure used for bitmap glyph images.\n'''\nfrom .ft_types import *\n\n\n# -----------------------------------------------------------------------------\n# A handle to a FreeType library instance. Each 'library' is completely\n# independent from the others; it is the 'root' of a set of objects like fonts,\n# faces, sizes, etc.\nclass FT_LibraryRec(Structure):\n    '''\n    A handle to a FreeType library instance. Each 'library' is completely\n    independent from the others; it is the 'root' of a set of objects like\n    fonts, faces, sizes, etc.\n    '''\n    _fields_ = [ ]\nFT_Library = POINTER(FT_LibraryRec)\n\n\n\n# -----------------------------------------------------------------------------\n# A simple structure used to store a 2D vector; coordinates are of the FT_Pos\n# type.\nclass FT_Vector(Structure):\n    '''\n    A simple structure used to store a 2D vector; coordinates are of the FT_Pos\n    type.\n\n    x: The horizontal coordinate.\n    y: The vertical coordinate.\n    '''\n    _fields_ = [('x', FT_Pos),\n                ('y', FT_Pos)]\n\n\n\n# -----------------------------------------------------------------------------\n# A structure used to hold an outline's bounding box, i.e., the coordinates of\n# its extrema in the horizontal and vertical directions.\n#\n# The bounding box is specified with the coordinates of the lower left and the\n# upper right corner. In PostScript, those values are often called (llx,lly)\n# and (urx,ury), respectively.\n#\n# If 'yMin' is negative, this value gives the glyph's descender. Otherwise, the\n# glyph doesn't descend below the baseline. Similarly, if 'ymax' is positive,\n# this value gives the glyph's ascender.\n#\n# 'xMin' gives the horizontal distance from the glyph's origin to the left edge\n# of the glyph's bounding box. If 'xMin' is negative, the glyph extends to the\n# left of the origin.\nclass FT_BBox(Structure):\n    '''\n    A structure used to hold an outline's bounding box, i.e., the coordinates\n    of its extrema in the horizontal and vertical directions.\n\n    The bounding box is specified with the coordinates of the lower left and\n    the upper right corner. In PostScript, those values are often called\n    (llx,lly) and (urx,ury), respectively.\n\n    If 'yMin' is negative, this value gives the glyph's descender. Otherwise,\n    the glyph doesn't descend below the baseline. Similarly, if 'ymax' is\n    positive, this value gives the glyph's ascender.\n\n    'xMin' gives the horizontal distance from the glyph's origin to the left\n    edge of the glyph's bounding box. If 'xMin' is negative, the glyph extends\n    to the left of the origin.\n\n    xMin: The horizontal minimum (left-most).\n    yMin: The vertical minimum (bottom-most).\n    xMax: The horizontal maximum (right-most).\n    yMax: The vertical maximum (top-most).\n    '''\n    _fields_ = [('xMin', FT_Pos),\n                ('yMin', FT_Pos),\n                ('xMax', FT_Pos),\n                ('yMax', FT_Pos)]\n\n\n\n# -----------------------------------------------------------------------------\n# A simple structure used to store a 2x2 matrix. Coefficients are in 16.16\n# fixed float format. The computation performed is:\n#   x' = x*xx + y*xy                                             \n#   y' = x*yx + y*yy   \nclass FT_Matrix(Structure):\n    '''\n    A simple structure used to store a 2x2 matrix. Coefficients are in 16.16\n    fixed float format. The computation performed is:\n\n    x' = x*xx + y*xy                                             \n    y' = x*yx + y*yy   \n\n    xx: Matrix coefficient.\n    xy: Matrix coefficient.\n    yx: Matrix coefficient.\n    yy: Matrix coefficient.\n    '''\n    _fields_ = [('xx', FT_Fixed),\n                ('xy', FT_Fixed),\n                ('yx', FT_Fixed),\n                ('yy', FT_Fixed)]\n\n\n\n# -----------------------------------------------------------------------------\n# A simple structure used to store a 2D vector unit vector. Uses FT_F2Dot14\n# types.\nclass FT_UnitVector(Structure):\n    '''\n    A simple structure used to store a 2D vector unit vector. Uses FT_F2Dot14\n    types.\n\n    x: The horizontal coordinate.\n    y: The vertical coordinate.\n    '''\n    _fields_ = [('x', FT_F2Dot14),\n                ('y', FT_F2Dot14)]\n\n\n\n# -----------------------------------------------------------------------------\n# A structure used to describe a bitmap or pixmap to the raster. Note that we\n# now manage pixmaps of various depths through the 'pixel_mode' field.\nclass FT_Bitmap(Structure):\n    '''\n    A structure used to describe a bitmap or pixmap to the raster. Note that we\n    now manage pixmaps of various depths through the 'pixel_mode' field.\n\n    rows: The number of bitmap rows.\n\n    width: The number of pixels in bitmap row.\n\n    pitch: The pitch's absolute value is the number of bytes taken by one\n           bitmap row, including padding. However, the pitch is positive when\n           the bitmap has a 'down' flow, and negative when it has an 'up'\n           flow. In all cases, the pitch is an offset to add to a bitmap\n           pointer in order to go down one row.\n\n           Note that 'padding' means the alignment of a bitmap to a byte\n           border, and FreeType functions normally align to the smallest\n           possible integer value.\n\n           For the B/W rasterizer, 'pitch' is always an even number.\n\n           To change the pitch of a bitmap (say, to make it a multiple of 4),\n           use FT_Bitmap_Convert. Alternatively, you might use callback\n           functions to directly render to the application's surface; see the\n           file 'example2.py' in the tutorial for a demonstration.\n\n    buffer: A typeless pointer to the bitmap buffer. This value should be\n            aligned on 32-bit boundaries in most cases.\n\n    num_grays: This field is only used with FT_PIXEL_MODE_GRAY; it gives the\n    number of gray levels used in the bitmap.\n\n    pixel_mode: The pixel mode, i.e., how pixel bits are stored. See\n    FT_Pixel_Mode for possible values.\n\n    palette_mode: This field is intended for paletted pixel modes; it indicates\n    how the palette is stored. Not used currently.\n\n    palette: A typeless pointer to the bitmap palette; this field is intended\n    for paletted pixel modes. Not used currently.\n    '''\n    _fields_ = [\n        ('rows',         c_int),\n        ('width',        c_int),\n        ('pitch',        c_int),\n        # declaring buffer as c_char_p confuses ctypes\n        ('buffer',       POINTER(c_ubyte)),\n        ('num_grays',    c_short),\n        ('pixel_mode',   c_ubyte),\n        ('palette_mode', c_char),\n        ('palette',      c_void_p) ]\n\n\n\n# -----------------------------------------------------------------------------\n# Read-only binary data represented as a pointer and a length.\nclass FT_Data(Structure):\n    '''\n    Read-only binary data represented as a pointer and a length.\n\n    pointer: The data.\n    length: The length of the data in bytes.\n    '''\n    _fields_ = [('pointer', POINTER(FT_Byte)),\n                ('y',       FT_Int)]\n\n\n\n# -----------------------------------------------------------------------------\n# Client applications often need to associate their own data to a variety of\n# FreeType core objects. For example, a text layout API might want to associate\n# a glyph cache to a given size object.\n#\n# Most FreeType object contains a 'generic' field, of type FT_Generic, which\n# usage is left to client applications and font servers.\n#\n# It can be used to store a pointer to client-specific data, as well as the\n# address of a 'finalizer' function, which will be called by FreeType when the\n# object is destroyed (for example, the previous client example would put the\n# address of the glyph cache destructor in the 'finalizer' field).\nclass FT_Generic(Structure):\n    '''\n    Client applications often need to associate their own data to a variety of\n    FreeType core objects. For example, a text layout API might want to\n    associate a glyph cache to a given size object.\n    \n    Most FreeType object contains a 'generic' field, of type FT_Generic, which\n    usage is left to client applications and font servers.\n\n    It can be used to store a pointer to client-specific data, as well as the\n    address of a 'finalizer' function, which will be called by FreeType when\n    the object is destroyed (for example, the previous client example would put\n    the address of the glyph cache destructor in the 'finalizer' field).\n\n    data: A typeless pointer to any client-specified data. This field is\n          completely ignored by the FreeType library.\n    finalizer: A pointer to a 'generic finalizer' function, which will be\n               called when the object is destroyed. If this field is set to\n               NULL, no code will be called.\n    '''\n    _fields_ = [('data',      c_void_p),\n                ('finalizer', FT_Generic_Finalizer)]\n\n\n\n\n# -----------------------------------------------------------------------------\n# This structure models the metrics of a bitmap strike (i.e., a set of glyphs\n# for a given point size and resolution) in a bitmap font. It is used for the\n# 'available_sizes' field of FT_Face.\nclass FT_Bitmap_Size(Structure):\n    '''\n    This structure models the metrics of a bitmap strike (i.e., a set of glyphs\n    for a given point size and resolution) in a bitmap font. It is used for the\n    'available_sizes' field of FT_Face.\n    \n    height: The vertical distance, in pixels, between two consecutive\n            baselines. It is always positive.\n\n    width: The average width, in pixels, of all glyphs in the strike.\n\n    size: The nominal size of the strike in 26.6 fractional points. This field\n          is not very useful.\n\n    x_ppem: The horizontal ppem (nominal width) in 26.6 fractional pixels.\n\n    y_ppem: The vertical ppem (nominal height) in 26.6 fractional pixels.\n    '''\n    _fields_ = [\n        ('height', FT_Short),\n        ('width',  FT_Short),\n        ('size',   FT_Pos),\n        ('x_ppem', FT_Pos),\n        ('y_ppem', FT_Pos) ]\n\n\n\n# -----------------------------------------------------------------------------\n# The base charmap structure.\nclass FT_CharmapRec(Structure):\n    '''\n    The base charmap structure.\n\n    face : A handle to the parent face object.\n\n    encoding : An FT_Encoding tag identifying the charmap. Use this with\n               FT_Select_Charmap.\n\n    platform_id: An ID number describing the platform for the following\n                 encoding ID. This comes directly from the TrueType\n                 specification and should be emulated for other formats.\n\n    encoding_id: A platform specific encoding number. This also comes from the\n                 TrueType specification and should be emulated similarly.\n    '''\n    _fields_ = [\n        ('face',        c_void_p),  # Shoudl be FT_Face\n        ('encoding',    FT_Encoding),\n        ('platform_id', FT_UShort),\n        ('encoding_id', FT_UShort),\n        ]\nFT_Charmap = POINTER(FT_CharmapRec)\n\n\n\n# -----------------------------------------------------------------------------\n# A structure used to model the metrics of a single glyph. The values are\n# expressed in 26.6 fractional pixel format; if the flag FT_LOAD_NO_SCALE has\n# been used while loading the glyph, values are expressed in font units\n# instead.\nclass FT_Glyph_Metrics(Structure):\n    '''\n    A structure used to model the metrics of a single glyph. The values are\n    expressed in 26.6 fractional pixel format; if the flag FT_LOAD_NO_SCALE has\n    been used while loading the glyph, values are expressed in font units\n    instead.\n\n    width: The glyph's width.\n\n    height: The glyph's height.\n\n    horiBearingX: Left side bearing for horizontal layout.\n\n    horiBearingY: Top side bearing for horizontal layout.\n\n    horiAdvance: Advance width for horizontal layout.\n\n    vertBearingX: Left side bearing for vertical layout.\n\n    vertBearingY: Top side bearing for vertical layout.\n\n    vertAdvance: Advance height for vertical layout.\n    '''\n    _fields_ = [\n        ('width',        FT_Pos),\n        ('height',       FT_Pos),\n        ('horiBearingX', FT_Pos),\n        ('horiBearingY', FT_Pos),\n        ('horiAdvance',  FT_Pos),\n        ('vertBearingX', FT_Pos),\n        ('vertBearingY', FT_Pos),\n        ('vertAdvance',  FT_Pos),\n    ]\n\n\n\n# -----------------------------------------------------------------------------\n# This structure is used to describe an outline to the scan-line converter.\nclass FT_Outline(Structure):\n    '''\n    This structure is used to describe an outline to the scan-line converter.\n\n    n_contours: The number of contours in the outline.\n\n    n_points: The number of points in the outline.\n\n    points: A pointer to an array of 'n_points' FT_Vector elements, giving the\n            outline's point coordinates.\n\n    tags: A pointer to an array of 'n_points' chars, giving each outline\n          point's type.\n\n          If bit 0 is unset, the point is 'off' the curve, i.e., a Bezier\n          control point, while it is 'on' if set.\n\n          Bit 1 is meaningful for 'off' points only. If set, it indicates a\n          third-order Bezier arc control point; and a second-order control\n          point if unset.\n\n          If bit 2 is set, bits 5-7 contain the drop-out mode (as defined in\n          the OpenType specification; the value is the same as the argument to\n          the SCANMODE instruction).\n\n          Bits 3 and 4 are reserved for internal purposes.\n\n    contours: An array of 'n_contours' shorts, giving the end point of each\n              contour within the outline. For example, the first contour is\n              defined by the points '0' to 'contours[0]', the second one is\n              defined by the points 'contours[0]+1' to 'contours[1]', etc.\n\n    flags: A set of bit flags used to characterize the outline and give hints\n           to the scan-converter and hinter on how to convert/grid-fit it. See\n           FT_OUTLINE_FLAGS.\n    '''\n    _fields_ = [\n        ('n_contours', c_short),\n        ('n_points',   c_short),\n        ('points',     POINTER(FT_Vector)),\n        # declaring buffer as c_char_p would prevent us to acces all tags\n        ('tags',       POINTER(c_ubyte)),\n        ('contours',   POINTER(c_short)),\n        ('flags',      c_int),\n    ]\n\n\n# -----------------------------------------------------------------------------\n# The root glyph structure contains a given glyph image plus its advance width\n# in 16.16 fixed float format.\n\nclass FT_GlyphRec(Structure):\n    '''\n    The root glyph structure contains a given glyph image plus its advance\n    width in 16.16 fixed float format.\n\n    library:  A handle to the FreeType library object.\n\n    clazz: A pointer to the glyph's class. Private.\n\n    format: The format of the glyph's image.\n\n    advance: A 16.16 vector that gives the glyph's advance width.\n    '''\n    _fields_ = [\n        ('library',    FT_Library),\n        ('clazz',      c_void_p),\n        ('format',     FT_Glyph_Format),\n        ('advance',    FT_Vector)\n    ]\nFT_Glyph = POINTER(FT_GlyphRec)\n\n\n\n# -----------------------------------------------------------------------------\n# FreeType root glyph slot class structure. A glyph slot is a container where\n# individual glyphs can be loaded, be they in outline or bitmap format.\nclass FT_GlyphSlotRec(Structure):\n    '''\n    FreeType root glyph slot class structure. A glyph slot is a container where\n    individual glyphs can be loaded, be they in outline or bitmap format.\n\n    library: A handle to the FreeType library instance this slot belongs to.\n\n    face: A handle to the parent face object.\n\n    next: In some cases (like some font tools), several glyph slots per face\n          object can be a good thing. As this is rare, the glyph slots are\n          listed through a direct, single-linked list using its 'next' field.\n\n    generic: A typeless pointer which is unused by the FreeType library or any\n             of its drivers. It can be used by client applications to link\n             their own data to each glyph slot object.\n\n    metrics: The metrics of the last loaded glyph in the slot. The returned\n             values depend on the last load flags (see the FT_Load_Glyph API\n             function) and can be expressed either in 26.6 fractional pixels or\n             font units.\n\n             Note that even when the glyph image is transformed, the metrics\n             are not.\n\n    linearHoriAdvance: The advance width of the unhinted glyph. Its value is\n                       expressed in 16.16 fractional pixels, unless\n                       FT_LOAD_LINEAR_DESIGN is set when loading the\n                       glyph. This field can be important to perform correct\n                       WYSIWYG layout. Only relevant for outline glyphs.\n\n    linearVertAdvance: The advance height of the unhinted glyph. Its value is\n                       expressed in 16.16 fractional pixels, unless\n                       FT_LOAD_LINEAR_DESIGN is set when loading the\n                       glyph. This field can be important to perform correct\n                       WYSIWYG layout. Only relevant for outline glyphs.\n\n    advance: This shorthand is, depending on FT_LOAD_IGNORE_TRANSFORM, the\n             transformed advance width for the glyph (in 26.6 fractional pixel\n             format). As specified with FT_LOAD_VERTICAL_LAYOUT, it uses either\n             the 'horiAdvance' or the 'vertAdvance' value of 'metrics' field.\n\n    format: This field indicates the format of the image contained in the glyph\n            slot. Typically FT_GLYPH_FORMAT_BITMAP, FT_GLYPH_FORMAT_OUTLINE, or\n            FT_GLYPH_FORMAT_COMPOSITE, but others are possible.\n\n    bitmap: This field is used as a bitmap descriptor when the slot format is\n            FT_GLYPH_FORMAT_BITMAP. Note that the address and content of the\n            bitmap buffer can change between calls of FT_Load_Glyph and a few\n            other functions.\n\n    bitmap_left: This is the bitmap's left bearing expressed in integer\n                 pixels. Of course, this is only valid if the format is\n                 FT_GLYPH_FORMAT_BITMAP.\n\n    bitmap_top: This is the bitmap's top bearing expressed in integer\n                pixels. Remember that this is the distance from the baseline to\n                the top-most glyph scanline, upwards y coordinates being\n                positive.\n\n    outline: The outline descriptor for the current glyph image if its format\n             is FT_GLYPH_FORMAT_OUTLINE. Once a glyph is loaded, 'outline' can\n             be transformed, distorted, embolded, etc. However, it must not be\n             freed.\n\n    num_subglyphs: The number of subglyphs in a composite glyph. This field is\n                   only valid for the composite glyph format that should\n                   normally only be loaded with the FT_LOAD_NO_RECURSE\n                   flag. For now this is internal to FreeType.\n\n    subglyphs: An array of subglyph descriptors for composite glyphs. There are\n               'num_subglyphs' elements in there. Currently internal to\n               FreeType.\n\n    control_data: Certain font drivers can also return the control data for a\n                  given glyph image (e.g. TrueType bytecode, Type 1\n                  charstrings, etc.). This field is a pointer to such data.\n\n    control_len: This is the length in bytes of the control data.\n\n    other: Really wicked formats can use this pointer to present their own\n           glyph image to client applications. Note that the application needs\n           to know about the image format.\n\n    lsb_delta: The difference between hinted and unhinted left side bearing\n               while autohinting is active. Zero otherwise.\n\n    rsb_delta: The difference between hinted and unhinted right side bearing\n               while autohinting is active. Zero otherwise.\n    '''\n    _fields_ = [\n        ('library',           FT_Library),\n        ('face',              c_void_p),\n        ('next',              c_void_p),\n        ('reserved',          c_uint),\n        ('generic',           FT_Generic),\n\n        ('metrics',           FT_Glyph_Metrics),\n        ('linearHoriAdvance', FT_Fixed),\n        ('linearVertAdvance', FT_Fixed),\n        ('advance',           FT_Vector),\n\n        ('format',            FT_Glyph_Format),\n\n        ('bitmap',            FT_Bitmap),\n        ('bitmap_left',       FT_Int),\n        ('bitmap_top',        FT_Int),\n\n        ('outline',           FT_Outline),\n        ('num_subglyphs',     FT_UInt),\n        ('subglyphs',         c_void_p),\n\n        ('control_data',      c_void_p),\n        ('control_len',       c_long),\n\n        ('lsb_delta',         FT_Pos),\n        ('rsb_delta',         FT_Pos),\n        ('other',             c_void_p),\n        ('internal',          c_void_p),\n    ]\nFT_GlyphSlot = POINTER(FT_GlyphSlotRec)\n\n\n\n# -----------------------------------------------------------------------------\n# The size metrics structure gives the metrics of a size object.\nclass FT_Size_Metrics(Structure):\n    '''\n    The size metrics structure gives the metrics of a size object.\n\n    x_ppem: The width of the scaled EM square in pixels, hence the term 'ppem'\n            (pixels per EM). It is also referred to as 'nominal width'.\n\n    y_ppem: The height of the scaled EM square in pixels, hence the term 'ppem'\n            (pixels per EM). It is also referred to as 'nominal height'.\n\n    x_scale: A 16.16 fractional scaling value used to convert horizontal\n             metrics from font units to 26.6 fractional pixels. Only relevant\n             for scalable font formats.\n\n    y_scale: A 16.16 fractional scaling value used to convert vertical metrics\n             from font units to 26.6 fractional pixels. Only relevant for\n             scalable font formats.\n\n    ascender: The ascender in 26.6 fractional pixels. See FT_FaceRec for the\n              details.\n\n    descender: The descender in 26.6 fractional pixels. See FT_FaceRec for the\n               details.\n\n    height: The height in 26.6 fractional pixels. See FT_FaceRec for the\n            details.\n\n    max_advance: The maximal advance width in 26.6 fractional pixels. See\n                 FT_FaceRec for the details.\n    '''\n    _fields_ = [\n        ('x_ppem',      FT_UShort),\n        ('y_ppem',      FT_UShort),\n\n        ('x_scale',     FT_Fixed),\n        ('y_scale',     FT_Fixed),\n\n        ('ascender',    FT_Pos),\n        ('descender',   FT_Pos),\n        ('height',      FT_Pos),\n        ('max_advance', FT_Pos),\n    ]\n\n\n\n# -----------------------------------------------------------------------------\n# FreeType root size class structure. A size object models a face object at a\n# given size.\nclass FT_SizeRec(Structure):\n    '''\n    FreeType root size class structure. A size object models a face object at a\n    given size.\n\n    face: Handle to the parent face object.\n\n    generic: A typeless pointer, which is unused by the FreeType library or any\n             of its drivers. It can be used by client applications to link\n             their own data to each size object.\n\n    metrics: Metrics for this size object. This field is read-only.\n    '''\n    _fields_ = [\n        ('face',     c_void_p),\n        ('generic',  FT_Generic),\n        ('metrics',  FT_Size_Metrics),\n        ('internal', c_void_p),\n    ]\nFT_Size = POINTER(FT_SizeRec)\n\n\n\n# -----------------------------------------------------------------------------\n# FreeType root face class structure. A face object models a typeface in a font\n# file.\nclass FT_FaceRec(Structure):\n    '''\n    FreeType root face class structure. A face object models a typeface in a\n    font file.\n\n    num_faces: The number of faces in the font file. Some font formats can have\n               multiple faces in a font file.\n\n    face_index: The index of the face in the font file. It is set to 0 if there\n                is only one face in the font file.\n\n    face_flags: A set of bit flags that give important information about the\n                face; see FT_FACE_FLAG_XXX for the details.\n\n    style_flags: A set of bit flags indicating the style of the face; see\n                 FT_STYLE_FLAG_XXX for the details.\n\n    num_glyphs: The number of glyphs in the face. If the face is scalable and\n                has sbits (see 'num_fixed_sizes'), it is set to the number of\n                outline glyphs.\n\n                For CID-keyed fonts, this value gives the highest CID used in\n                the font.\n\n    family_name: The face's family name. This is an ASCII string, usually in\n                 English, which describes the typeface's family (like 'Times\n                 New Roman', 'Bodoni', 'Garamond', etc). This is a least common\n                 denominator used to list fonts. Some formats (TrueType &\n                 OpenType) provide localized and Unicode versions of this\n                 string. Applications should use the format specific interface\n                 to access them. Can be NULL (e.g., in fonts embedded in a PDF\n                 file).\n\n    style_name: The face's style name. This is an ASCII string, usually in\n                English, which describes the typeface's style (like 'Italic',\n                'Bold', 'Condensed', etc). Not all font formats provide a style\n                name, so this field is optional, and can be set to NULL. As for\n                'family_name', some formats provide localized and Unicode\n                versions of this string. Applications should use the format\n                specific interface to access them.\n\n    num_fixed_sizes: The number of bitmap strikes in the face. Even if the face\n                     is scalable, there might still be bitmap strikes, which\n                     are called 'sbits' in that case.\n\n    available_sizes: An array of FT_Bitmap_Size for all bitmap strikes in the\n                     face. It is set to NULL if there is no bitmap strike.\n\n    num_charmaps: The number of charmaps in the face.\n\n    charmaps: An array of the charmaps of the face.\n\n    generic: A field reserved for client uses. See the FT_Generic type\n            description.\n\n    bbox: The font bounding box. Coordinates are expressed in font units (see\n          'units_per_EM'). The box is large enough to contain any glyph from\n          the font. Thus, 'bbox.yMax' can be seen as the 'maximal ascender',\n          and 'bbox.yMin' as the 'minimal descender'. Only relevant for\n          scalable formats.\n\n          Note that the bounding box might be off by (at least) one pixel for\n          hinted fonts. See FT_Size_Metrics for further discussion.\n\n    units_per_EM: The number of font units per EM square for this face. This is\n                  typically 2048 for TrueType fonts, and 1000 for Type 1\n                  fonts. Only relevant for scalable formats.\n\n    ascender: The typographic ascender of the face, expressed in font\n              units. For font formats not having this information, it is set to\n              'bbox.yMax'. Only relevant for scalable formats.\n\n    descender: The typographic descender of the face, expressed in font\n               units. For font formats not having this information, it is set\n               to 'bbox.yMin'. Note that this field is usually negative. Only\n               relevant for scalable formats.\n\n    height: The height is the vertical distance between two consecutive\n            baselines, expressed in font units. It is always positive. Only\n            relevant for scalable formats.\n\n    max_advance_width: The maximal advance width, in font units, for all glyphs\n                       in this face. This can be used to make word wrapping\n                       computations faster. Only relevant for scalable formats.\n\n    max_advance_height: The maximal advance height, in font units, for all\n                        glyphs in this face. This is only relevant for vertical\n                        layouts, and is set to 'height' for fonts that do not\n                        provide vertical metrics. Only relevant for scalable\n                        formats.\n\n    underline_position: The position, in font units, of the underline line for\n                        this face. It is the center of the underlining\n                        stem. Only relevant for scalable formats.\n\n    underline_thickness: The thickness, in font units, of the underline for\n                         this face. Only relevant for scalable formats.\n\n    glyph: The face's associated glyph slot(s).\n\n    size: The current active size for this face.\n\n    charmap: The current active charmap for this face.\n    '''\n    _fields_ = [\n          ('num_faces',  FT_Long),\n          ('face_index', FT_Long),\n\n          ('face_flags',  FT_Long),\n          ('style_flags', FT_Long),\n\n          ('num_glyphs',  FT_Long),\n\n          ('family_name', FT_String_p),\n          ('style_name',  FT_String_p),\n\n          ('num_fixed_sizes', FT_Int),\n          ('available_sizes', POINTER(FT_Bitmap_Size)),\n\n          ('num_charmaps', c_int),\n          ('charmaps',     POINTER(FT_Charmap)),\n\n          ('generic', FT_Generic),\n\n          # The following member variables (down to `underline_thickness')\n          # are only relevant to scalable outlines; cf. @FT_Bitmap_Size\n          # for bitmap fonts.    \n          ('bbox', FT_BBox),\n\n          ('units_per_EM', FT_UShort),\n          ('ascender',     FT_Short),\n          ('descender',    FT_Short),\n          ('height',       FT_Short),\n\n          ('max_advance_width',  FT_Short),\n          ('max_advance_height', FT_Short),\n\n          ('underline_position',  FT_Short),\n          ('underline_thickness', FT_Short),\n\n          ('glyph',   FT_GlyphSlot),\n          ('size',    FT_Size),\n          ('charmap', FT_Charmap),\n\n          # private \n          ('driver',          c_void_p),\n          ('memory',          c_void_p),\n          ('stream',          c_void_p),\n          ('sizes_list_head', c_void_p),\n          ('sizes_list_tail', c_void_p),\n          ('autohint',        FT_Generic),\n          ('extensions',      c_void_p),\n          ('internal',        c_void_p),\n    ]\nFT_Face = POINTER(FT_FaceRec)\n\n\n\n# -----------------------------------------------------------------------------\n# A simple structure used to pass more or less generic parameters to\n# FT_Open_Face.\nclass FT_Parameter(Structure):\n    '''\n    A simple structure used to pass more or less generic parameters to\n    FT_Open_Face.\n\n    tag: A four-byte identification tag.\n\n    data: A pointer to the parameter data\n    '''\n    _fields_ = [\n        ('tag',  FT_ULong),\n        ('data', FT_Pointer) ]\nFT_Parameter_p = POINTER(FT_Parameter)\n\n\n\n# -----------------------------------------------------------------------------\n# A structure used to indicate how to open a new font file or stream. A pointer\n# to such a structure can be used as a parameter for the functions FT_Open_Face\n# and FT_Attach_Stream.\nclass FT_Open_Args(Structure):\n    '''\n    A structure used to indicate how to open a new font file or stream. A pointer\n    to such a structure can be used as a parameter for the functions FT_Open_Face\n    and FT_Attach_Stream.\n\n    flags: A set of bit flags indicating how to use the structure.\n\n    memory_base: The first byte of the file in memory.\n\n    memory_size: The size in bytes of the file in memory.\n\n    pathname: A pointer to an 8-bit file pathname.\n\n    stream: A handle to a source stream object.\n\n    driver: This field is exclusively used by FT_Open_Face; it simply specifies\n            the font driver to use to open the face. If set to 0, FreeType\n            tries to load the face with each one of the drivers in its list.\n\n    num_params: The number of extra parameters.\n\n    params: Extra parameters passed to the font driver when opening a new face.\n    '''\n    _fields_ = [\n        ('flags',        FT_UInt),\n        ('memory_base',  POINTER(FT_Byte)),\n        ('memory_size',  FT_Long),\n        ('pathname',     FT_String_p),\n        ('stream',       c_void_p),\n        ('driver',       c_void_p),\n        ('num_params',   FT_Int),\n        ('params',       FT_Parameter_p) ]\n\n\n\n# -----------------------------------------------------------------------------\n# A structure used to model an SFNT 'name' table entry.\n\nclass FT_SfntName(Structure):\n    '''\n    platform_id: The platform ID for 'string'.\n\n    encoding_id: The encoding ID for 'string'.\n\n    language_id: The language ID for 'string'\n\n    name_id: An identifier for 'string'\n\n    string: The 'name' string. Note that its format differs depending on the\n            (platform,encoding) pair. It can be a Pascal String, a UTF-16 one,\n            etc.\n\n            Generally speaking, the string is not zero-terminated. Please refer\n            to the TrueType specification for details.\n\n    string_len: The length of 'string' in bytes.\n    '''\n\n    _fields_ = [\n        ('platform_id', FT_UShort),\n        ('encoding_id', FT_UShort),\n        ('language_id', FT_UShort),\n        ('name_id',     FT_UShort),\n        # this string is *not* null-terminated!\n        ('string',      POINTER(FT_Byte)),\n        ('string_len',  FT_UInt) ]\n\n\n\n# -----------------------------------------------------------------------------\n# Opaque handler to a path stroker object.\nclass FT_StrokerRec(Structure):\n    '''\n    Opaque handler to a path stroker object.\n    '''\n    _fields_ = [ ]\nFT_Stroker = POINTER(FT_StrokerRec)\n\n\n# -----------------------------------------------------------------------------\n# A structure used for bitmap glyph images. This really is a 'sub-class' of\n# FT_GlyphRec.\n#\nclass FT_BitmapGlyphRec(Structure):\n    '''\n    A structure used for bitmap glyph images. This really is a 'sub-class' of\n    FT_GlyphRec.\n    '''\n    _fields_ = [ \n        ('root' , FT_GlyphRec),\n        ('left', FT_Int),\n        ('top', FT_Int),\n        ('bitmap', FT_Bitmap)\n    ]\nFT_BitmapGlyph = POINTER(FT_BitmapGlyphRec)\n"""
glumpy/ext/freetype/ft_types.py,0,"b""#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n'''\nFreetype basic data types\n-------------------------\n\nFT_Byte : A simple typedef for the unsigned char type.\n\nFT_Bytes : A typedef for constant memory areas.\n\nFT_Char : A simple typedef for the signed char type.\n\nFT_Int : A typedef for the int type.\n\nFT_UInt : A typedef for the unsigned int type.\n\nFT_Int16 : A typedef for a 16bit signed integer type.\n\nFT_UInt16 : A typedef for a 16bit unsigned integer type.\n\nFT_Int32 : A typedef for a 32bit signed integer type.\n\nFT_UInt32 : A typedef for a 32bit unsigned integer type.\n\nFT_Short : A typedef for signed short.\n\nFT_UShort : A typedef for unsigned short.\n\nFT_Long : A typedef for signed long.\n\nFT_ULong : A typedef for unsigned long.\n\nFT_Bool : A typedef of unsigned char, used for simple booleans. As usual,\n          values 1 and 0 represent true and false, respectively.\n\nFT_Offset : This is equivalent to the ANSI C 'size_t' type, i.e., the largest\n            unsigned integer type used to express a file size or position, or\n            a memory block size.\n\nFT_PtrDist : This is equivalent to the ANSI C 'ptrdiff_t' type, i.e., the\n             largest signed integer type used to express the distance between\n             two pointers.\n\nFT_String : A simple typedef for the char type, usually used for strings. \n\nFT_Tag  : A typedef for 32-bit tags (as used in the SFNT format).\n\nFT_Error : The FreeType error code type. A value of 0 is always interpreted as\n           a successful operation.\n\nFT_Fixed : This type is used to store 16.16 fixed float values, like scaling\n           values or matrix coefficients.\n\nFT_Pointer : A simple typedef for a typeless pointer.\n\nFT_Pos : The type FT_Pos is used to store vectorial coordinates. Depending on\n         the context, these can represent distances in integer font units, or\n         16.16, or 26.6 fixed float pixel coordinates.\n\nFT_FWord : A signed 16-bit integer used to store a distance in original font\n           units.\n\nFT_UFWord : An unsigned 16-bit integer used to store a distance in original\n            font units.\n\nFT_F2Dot14 : A signed 2.14 fixed float type used for unit vectors.\n\nFT_F26Dot6 : A signed 26.6 fixed float type used for vectorial pixel\n             coordinates.\n'''\nfrom ctypes import *\n\n\nFT_Byte    = c_ubyte  # A simple typedef for the unsigned char type.\n\nFT_Bytes   = c_char_p # A typedef for constant memory areas.\n\nFT_Char    = c_char   # A simple typedef for the signed char type.\n\nFT_Int     = c_int    # A typedef for the int type.\n\nFT_UInt    = c_uint   # A typedef for the unsigned int type.\n\nFT_Int16   = c_short  # A typedef for a 16bit signed integer type.\n\nFT_UInt16  = c_ushort # A typedef for a 16bit unsigned integer type.\n\nFT_Int32   = c_int32  # A typedef for a 32bit signed integer type.\n\nFT_UInt32  = c_uint32 # A typedef for a 32bit unsigned integer type.\n\nFT_Short   = c_short  # A typedef for signed short.\n\nFT_UShort  = c_ushort # A typedef for unsigned short.\n\nFT_Long    = c_long   # A typedef for signed long.\n\nFT_ULong   = c_ulong  # A typedef for unsigned long.\n\nFT_Bool    = c_char   # A typedef of unsigned char, used for simple booleans. As\n                      # usual, values 1 and 0 represent true and false,\n                      # respectively.\n\nFT_Offset  = c_size_t # This is equivalent to the ANSI C 'size_t' type, i.e.,\n                      # the largest unsigned integer type used to express a file\n                      # size or position, or a memory block size.\n\nFT_PtrDist = c_longlong # This is equivalent to the ANSI C 'ptrdiff_t' type,\n                        # i.e., the largest signed integer type used to express\n                        # the distance between two pointers.\n\nFT_String  = c_char   # A simple typedef for the char type, usually used for strings. \n\nFT_String_p= c_char_p\n\nFT_Tag     = FT_UInt32 # A typedef for 32-bit tags (as used in the SFNT format).\n\nFT_Error   = c_int    # The FreeType error code type. A value of 0 is always\n                      # interpreted as a successful operation.\n\nFT_Fixed   = c_long   # This type is used to store 16.16 fixed float values,\n                      # like scaling values or matrix coefficients.\n\nFT_Pointer = c_void_p # A simple typedef for a typeless pointer.\n\nFT_Pos     = c_long   # The type FT_Pos is used to store vectorial\n                      # coordinates. Depending on the context, these can\n                      # represent distances in integer font units, or 16.16, or\n                      # 26.6 fixed float pixel coordinates.\n\nFT_FWord   = c_short  # A signed 16-bit integer used to store a distance in\n                      # original font units.\n\nFT_UFWord  = c_ushort # An unsigned 16-bit integer used to store a distance in\n                      # original font units.\n\nFT_F2Dot14 = c_short  # A signed 2.14 fixed float type used for unit vectors.\n\nFT_F26Dot6 = c_long   # A signed 26.6 fixed float type used for vectorial pixel\n                      # coordinates.\n\nFT_Glyph_Format = c_int\n\nFT_Encoding     = c_int\n\n\n# Describe a function used to destroy the 'client' data of any FreeType\n# object. See the description of the FT_Generic type for details of usage.\nFT_Generic_Finalizer = CFUNCTYPE(None, c_void_p)\n"""
glumpy/ext/sdf/__init__.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom .sdf import *\n'
glumpy/ext/sdf/setup.py,0,"b'from distutils.core import setup, Extension\nimport numpy\nfrom Cython.Distutils import build_ext\n\nsetup(\n    cmdclass={\'build_ext\': build_ext},\n    ext_modules=[Extension(""sdf"",\n                 sources=[""_sdf.pyx"", ""sdf.c""],\n                 include_dirs=[numpy.get_include()])],\n)\n'"
glumpy/gloo/tests/test_buffer.py,117,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport unittest\nimport numpy as np\n\nfrom glumpy import gl\nfrom glumpy.gloo.buffer import Buffer, DataBuffer, VertexBuffer, IndexBuffer\n\n\n# -----------------------------------------------------------------------------\nclass BufferTest(unittest.TestCase):\n\n    # Default init\n    # ------------\n    def test_init_default(self):\n        B = Buffer()\n        assert B._target == gl.GL_ARRAY_BUFFER\n        assert B._handle == -1\n        assert B._need_create is True\n        assert B._need_update is True\n        assert B._need_resize is True\n        assert B._need_delete is False\n        assert B._nbytes == 0\n        assert B._usage == gl.GL_DYNAMIC_DRAW\n        assert B._resizeable is True\n\n    # Unknown target\n    # --------------\n    def test_init_wrong_target(self):\n        self.assertRaises(ValueError, Buffer, target=-1)\n\n    # No data\n    # -------\n    def test_init_no_data(self):\n        B = Buffer()\n        assert len(B._pending_data) == 0\n\n    # Data\n    # ----\n    def test_init_with_data(self):\n        data = np.zeros(100)\n        B = Buffer(data=data)\n        assert len(B._pending_data) == 1\n\n    # Check setting the whole buffer clear pending operations\n    # -------------------------------------------------------\n    def test_set_whole_data(self):\n        data = np.zeros(100)\n        B = Buffer(data=data)\n        B.set_data(data=data)\n        assert len(B._pending_data) == 1\n\n    # Check stored data is data\n    # -------------------------\n    def test_data_storage(self):\n        data = np.zeros(100)\n        B = Buffer(data=data)\n        B.set_data(data=data[:50], offset=0, copy=False)\n        assert B._pending_data[-1][0].base is data\n\n    # Check stored data is a copy\n    # ----------------------------\n    def test_data_copy(self):\n        data = np.zeros(100)\n        B = Buffer(data=data)\n        B.set_data(data=data[:50], offset=0, copy=True)\n        assert B._pending_data[-1][0].base is not data\n\n    # Check setting oversized data\n    # ----------------------------\n    def test_oversized_data(self):\n        data = np.zeros(10)\n        B = Buffer(data=data, resizeable=False)\n        self.assertRaises(ValueError, B.set_data, np.ones(20))\n\n    # Check negative offset\n    # ---------------------\n    def test_negative_offset(self):\n        data = np.zeros(10)\n        B = Buffer(data=data, resizeable=False)\n        # with self.assertRaises(ValueError):\n        #    B.set_data(np.ones(1), offset=-1)\n        self.assertRaises(ValueError, B.set_data, np.ones(1), offset=-1)\n\n    # Check offlimit offset\n    # ---------------------\n    def test_offlimit_offset(self):\n        data = np.zeros(10)\n        B = Buffer(data=data, resizeable=False)\n        self.assertRaises(ValueError, B.set_data,\n                          np.ones(1), offset=10 * data.dtype.itemsize)\n\n    # Buffer size\n    # -----------\n    def test_buffer_size(self):\n        data = np.zeros(10)\n        B = Buffer(data=data)\n        assert B.nbytes == data.nbytes\n\n    # Resize\n    # ------\n    def test_buffer_resize(self):\n        data = np.zeros(10)\n        B = Buffer(data=data)\n        data = np.zeros(20)\n        B._need_resize = False\n        B.set_data(data)\n        assert B.nbytes == data.nbytes\n        assert B._need_resize is True\n\n    # Forbidden resize\n    # ----------------\n    def test_buffer_forbidden_resize(self):\n        data = np.zeros(10)\n        B = Buffer(data=data, resizeable=False)\n        data = np.zeros(20)\n        self.assertRaises(ValueError, B.set_data, data)\n\n\n# -----------------------------------------------------------------------------\nclass DataBufferTest(unittest.TestCase):\n\n    # Default init\n    # ------------\n    def test_default_init(self):\n        # Check default storage and copy flags\n        data = np.ones(100)\n        B = DataBuffer(data)\n        assert B._store is True\n        assert B._copy is False\n        assert B.nbytes == data.nbytes\n        assert B.offset == 0\n        assert B.size == 100\n        assert B.itemsize == data.itemsize\n        assert B.stride == data.itemsize\n        assert B.dtype == data.dtype\n        assert B._resizeable is True\n\n    # Default init with structured data\n    # ---------------------------------\n    def test_structured_init(self):\n        # Check structured type\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data)\n        assert B.nbytes == data.nbytes\n        assert B.offset == 0\n        assert B.size == 10\n        assert B.itemsize == data.itemsize\n        assert B.stride == data.itemsize\n        assert B.dtype == data.dtype\n\n    # CPU storage\n    # ------------\n    def test_storage(self):\n        data = np.ones(100)\n        B = DataBuffer(data, store=True)\n        assert B.data.base is data\n\n    # Use CPU storage but make a local copy for storage\n    # -------------------------------------------------\n    def test_storage_copy(self):\n        data = np.ones(100, np.float32)\n        B = DataBuffer(data.copy(), store=True)  # we got rid of copy arg\n        assert B.data is not None\n        assert B.data is not data\n        assert B.stride == 4\n\n    # No CPU storage\n    # --------------\n    def test_no_storage_copy(self):\n        data = np.ones(100, np.float32)\n        B = DataBuffer(data, store=False)\n        assert B.data is None\n        assert B.stride == 4\n\n    # Empty init (not allowed)\n    # ------------------------\n    def test_empty_init(self):\n        self.assertRaises(ValueError, DataBuffer)\n\n    # Wrong storage\n    # -------------\n    def test_non_contiguous_storage(self):\n        # Ask to have CPU storage and to use data as storage\n        # Not possible since data[::2] is not contiguous\n        data = np.ones(100)\n        B = DataBuffer(data[::2], store=True, copy=False)\n        assert B._copy == True\n\n        # data = np.ones(100, np.float32)\n        # data_given = data[::2]\n        # B = DataBuffer(data_given, store=True)\n        # assert B._data is not data_given\n        # assert B.stride == 4\n        # B = DataBuffer(data_given, store=False)\n        # assert B._data is not data_given\n        # assert B.stride == 4*2\n\n    # Get buffer field\n    # ----------------\n    def test_getitem_field(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data)\n\n        Z = B[""position""]\n        assert Z.nbytes == 10 * 3 * np.dtype(np.float32).itemsize\n        assert Z.offset == 0\n        assert Z.size == 10\n        assert Z.itemsize == 3 * np.dtype(np.float32).itemsize\n        assert Z.stride == (3 + 2 + 4) * np.dtype(np.float32).itemsize\n        assert Z.dtype == (np.float32, 3)\n\n        Z = B[""texcoord""]\n        assert Z.nbytes == 10 * 2 * np.dtype(np.float32).itemsize\n        assert Z.offset == 3 * np.dtype(np.float32).itemsize\n        assert Z.size == 10\n        assert Z.itemsize == 2 * np.dtype(np.float32).itemsize\n        assert Z.stride == (3 + 2 + 4) * np.dtype(np.float32).itemsize\n        assert Z.dtype == (np.float32, 2)\n\n        Z = B[""color""]\n        assert Z.nbytes == 10 * 4 * np.dtype(np.float32).itemsize\n        assert Z.offset == (2 + 3) * np.dtype(np.float32).itemsize\n        assert Z.size == 10\n        assert Z.itemsize == 4 * np.dtype(np.float32).itemsize\n        assert Z.stride == (3 + 2 + 4) * np.dtype(np.float32).itemsize\n        assert Z.dtype == (np.float32, 4)\n\n    # Get item via index\n    # ------------------\n    def test_getitem_index(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data)\n        Z = B[0]\n        assert Z.nbytes == 1 * (3 + 2 + 4) * np.dtype(np.float32).itemsize\n        assert Z.offset == 0\n        assert Z.size == 1\n        assert Z.itemsize == (3 + 2 + 4) * np.dtype(np.float32).itemsize\n        assert Z.stride == (3 + 2 + 4) * np.dtype(np.float32).itemsize\n        assert Z.dtype == B.dtype\n\n    # View get invalidated when base is resized\n    # -----------------------------------------\n    def test_invalid_view_after_resize(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data)\n        Z = B[5:]\n        B.resize(5)\n        assert Z._valid is False\n\n    # View get invalidated after setting oversized data\n    # -------------------------------------------------\n    def test_invalid_view_after_set_data(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data)\n        Z = B[5:]\n        B.set_data(np.zeros(15, dtype=dtype))\n        assert Z._valid is False\n\n    # Set data on base buffer : ok\n    # ----------------------------\n    def test_set_data_base(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data, store=True)\n        B.set_data(data)\n        assert len(B._pending_data) == 1\n\n    # Set data on view buffer : error\n    # -------------------------------\n    def test_set_data_base_view(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data, store=True)\n        # set_data on field is not allowed because set_data\n        # can result in a buffer resize\n\n        # with self.assertRaises(ValueError):\n        #    B[\'position\'].set_data(data)\n        Z = B[\'position\']\n        self.assertRaises(ValueError, Z.set_data, data)\n\n    # Check set_data using offset in data buffer\n    # ------------------------------------------\n    def test_set_data_offset(self):\n        data = np.zeros(100, np.float32)\n        subdata = data[:10]\n\n        B = DataBuffer(data)\n        B.set_data(subdata, offset=10)\n        offset = B._pending_data[-1][2]\n        print (offset)\n        assert offset == 10*4\n\n    # Setitem + broadcast\n    # ------------------------------------------------------\n    def test_setitem_broadcast(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data, store=True)\n        B[\'position\'] = 1, 2, 3\n        assert np.allclose(data[\'position\'].ravel(), np.resize([1, 2, 3], 30))\n\n    # Setitem ellipsis\n    # ------------------------------------------------------\n    def test_setitem_ellipsis(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data1 = np.zeros(10, dtype=dtype)\n        data2 = np.ones(10, dtype=dtype)\n        B = DataBuffer(data1, store=True)\n        B[...] = data2\n        assert np.allclose(data1[\'position\'], data2[\'position\'])\n        assert np.allclose(data1[\'texcoord\'], data2[\'texcoord\'])\n        assert np.allclose(data1[\'color\'], data2[\'color\'])\n\n    # Set every 2 item\n    # ------------------------------------------------------\n    def test_setitem_strided(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data1 = np.zeros(10, dtype=dtype)\n        data2 = np.ones(10, dtype=dtype)\n        B = DataBuffer(data1, store=True)\n        B[::2] = data2[::2]\n        assert np.allclose(data1[\'position\'][::2], data2[\'position\'][::2])\n        assert np.allclose(data1[\'texcoord\'][::2], data2[\'texcoord\'][::2])\n        assert np.allclose(data1[\'color\'][::2], data2[\'color\'][::2])\n\n    # Set half the array\n    # ------------------------------------------------------\n    def test_setitem_half(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data1 = np.zeros(10, dtype=dtype)\n        data2 = np.ones(10, dtype=dtype)\n        B = DataBuffer(data1, store=True)\n        B[:5] = data2[:5]\n        assert np.allclose(data1[\'position\'][:5], data2[\'position\'][:5])\n        assert np.allclose(data1[\'texcoord\'][:5], data2[\'texcoord\'][:5])\n        assert np.allclose(data1[\'color\'][:5], data2[\'color\'][:5])\n        assert len(B._pending_data) == 2\n\n    # Set field without storage: error\n    # --------------------------------\n    def test_setitem_field_no_storage(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data, store=False)\n        # with self.assertRaises(ValueError):\n        #    B[\'position\'] = 1, 2, 3\n        self.assertRaises(ValueError,  B.__setitem__, \'position\', (1, 2, 3))\n\n    # Set every 2 item without storage:  error\n    # ----------------------------------------\n    def test_every_two_item_no_storage(self):\n        dtype = np.dtype([(\'position\', np.float32, 3),\n                          (\'texcoord\', np.float32, 2),\n                          (\'color\',    np.float32, 4)])\n        data = np.zeros(10, dtype=dtype)\n        B = DataBuffer(data, store=False)\n        # with self.assertRaises(ValueError):\n        #    B[::2] = data[::2]\n        s = slice(None, None, 2)\n        self.assertRaises(ValueError, B.__setitem__, s, data[::2])\n\n    # Resize\n    # ------\n    def test_resize(self):\n        data = np.zeros(10)\n        B = DataBuffer(data=data)\n        data = np.zeros(20)\n        B.set_data(data)\n        assert B.nbytes == data.nbytes\n        assert B._need_resize is True\n\n    # Resize not allowed using ellipsis\n    # --------------------------------\n    def test_no_resize_ellipsis(self):\n        data = np.zeros(10)\n        B = DataBuffer(data=data)\n        data = np.zeros(30)\n        # with self.assertRaises(ValueError):\n        #    B[...] = data\n        self.assertRaises(ValueError, B.__setitem__, Ellipsis, data)\n\n    # Resize when no resizeable\n    # -------------------------\n    def test_resize_no_resizeable(self):\n        data = np.zeros(10)\n        B = DataBuffer(data=data, resizeable=False)\n        data = np.zeros(20)\n        # with self.assertRaises(ValueError):\n        #    B.set_data(data)\n        self.assertRaises(ValueError, B.set_data, data)\n\n\n# -----------------------------------------------------------------------------\nclass VertexBufferTest(unittest.TestCase):\n\n    # VertexBuffer allowed base types\n    # -------------------------------\n    def test_init_allowed_dtype(self):\n        for dtype in (np.uint8, np.int8, np.uint16, np.int16, np.float32):\n            V = VertexBuffer(dtype=dtype)\n            names = V.dtype.names\n            assert V.dtype[names[0]].base == dtype\n            assert V.dtype[names[0]].shape == ()\n\n    # VertexBuffer not allowed base types\n    # -----------------------------------\n    def test_init_not_allowed_dtype(self):\n        for dtype in (np.uint32, np.int32, np.float64):\n            # with self.assertRaises(TypeError):\n            #    V = VertexBuffer(dtype=dtype)\n            self.assertRaises(TypeError, VertexBuffer, dtype=dtype)\n\n# -----------------------------------------------------------------------------\n\n\nclass IndexBufferTest(unittest.TestCase):\n\n    # IndexBuffer allowed base types\n    # ------------------------------\n    def test_init_allowed_dtype(self):\n        for dtype in (np.uint8, np.uint16, np.uint32):\n            V = IndexBuffer(dtype=dtype)\n            assert V.dtype == dtype\n\n    # IndexBuffer not allowed base types\n    # -----------------------------------\n    def test_init_not_allowed_dtype(self):\n        for dtype in (np.int8, np.int16, np.int32,\n                      np.float16, np.float32, np.float64):\n            # with self.assertRaises(TypeError):\n            #    V = IndexBuffer(dtype=dtype)\n            self.assertRaises(TypeError, IndexBuffer, dtype=dtype)\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
glumpy/gloo/tests/test_globject.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport unittest\nfrom glumpy.gloo.globject import GLObject\n\n\n# -----------------------------------------------------------------------------\nclass GLObjectTest(unittest.TestCase):\n\n    # Default init\n    # ------------\n    def test_init_default(self):\n        O = GLObject()\n\n        assert O._handle == -1\n        assert O._target is None\n        assert O._need_create is True\n        assert O._need_update is True\n        assert O._need_delete is False\n        assert O._id > 0\n        assert O._id == GLObject._idcount\nif __name__ == ""__main__"":\n    unittest.main()\n'"
glumpy/gloo/tests/test_program.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport unittest\n\nimport glumpy.gl as gl\nfrom glumpy.gloo.program import Program\nfrom glumpy.gloo.shader import VertexShader, FragmentShader\n\n\nclass ProgramTest(unittest.TestCase):\n\n    def test_init(self):\n        program = Program()\n        assert program._handle == -1\n        assert program.shaders == []\n\n    def test_delete_no_context(self):\n        program = Program()\n        program.delete()\n\n    def test_init_from_string(self):\n        program = Program(""A"", ""B"")\n        assert len(program.shaders) == 2\n        assert program.shaders[0].code == ""A""\n        assert program.shaders[1].code == ""B""\n\n    def test_init_from_shader(self):\n        program = Program(VertexShader(""A""), FragmentShader(""B""))\n        assert len(program.shaders) == 2\n        assert program.shaders[0].code == ""A""\n        assert program.shaders[1].code == ""B""\n\n    def test_unique_shader(self):\n        vert = VertexShader(""A"")\n        frag = FragmentShader(""B"")\n        program = Program([vert, vert], [frag, frag, frag])\n        assert len(program.shaders) == 2\n\n    def test_uniform(self):\n        vert = VertexShader(""uniform float A;"")\n        frag = FragmentShader(""uniform float A; uniform vec4 B;"")\n        program = Program(vert, frag)\n        assert (""A"", gl.GL_FLOAT) in program.all_uniforms\n        assert (""B"", gl.GL_FLOAT_VEC4) in program.all_uniforms\n        assert len(program.all_uniforms) == 2\n\n    def test_attributes(self):\n        vert = VertexShader(""attribute float A;"")\n        frag = FragmentShader("""")\n        program = Program(vert, frag)\n        assert program.all_attributes == [(""A"", gl.GL_FLOAT)]\n\n    def test_attach(self):\n        vert = VertexShader(""A"")\n        frag = FragmentShader(""B"")\n        program = Program(vert)\n        program.attach(frag)\n        assert len(program.shaders) == 2\n        assert program.shaders[0].code == ""A""\n        assert program.shaders[1].code == ""B""\n\n    def test_detach(self):\n        vert = VertexShader(""A"")\n        frag = FragmentShader(""B"")\n        program = Program(vert, frag)\n        program.detach(frag)\n        assert len(program.shaders) == 1\n        assert program.shaders[0].code == ""A""\n\n    def test_failed_build(self):\n        vert = VertexShader(""A"")\n        frag = FragmentShader(""B"")\n\n        program = Program(verts=vert)\n        self.assertRaises(ValueError, program.activate)\n\n        program = Program(frags=frag)\n        self.assertRaises(ValueError, program.activate)\n\n    def test_setitem(self):\n        vert = VertexShader("""")\n        frag = FragmentShader("""")\n\n        program = Program(vert, frag)\n        self.assertRaises(ValueError, program.__setitem__, ""A"", 1)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
glumpy/gloo/tests/test_shader.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport unittest\n\nimport glumpy.gl as gl\nfrom glumpy.gloo.shader import VertexShader, FragmentShader\n\n\n# -----------------------------------------------------------------------------\nclass VertexShaderTest(unittest.TestCase):\n\n    def test_init(self):\n        shader = VertexShader()\n        assert shader._target == gl.GL_VERTEX_SHADER\n\n\n# -----------------------------------------------------------------------------\nclass FragmentShaderTest(unittest.TestCase):\n\n    def test_init(self):\n        shader = FragmentShader()\n        assert shader._target == gl.GL_FRAGMENT_SHADER\n\n\n# -----------------------------------------------------------------------------\nclass ShaderTest(unittest.TestCase):\n\n    def test_init(self):\n        shader = VertexShader()\n        assert shader._handle == -1\n        assert shader.code is None\n        assert shader.source is None\n\n    def test_sourcecode(self):\n        code = ""/* Code */""\n        shader = VertexShader(code)\n        assert shader.code == code\n        assert shader.source == ""<string>""\n\n    def test_empty_build(self):\n        shader = VertexShader()\n        #with self.assertRaises(RuntimeError):\n        #    shader.activate()\n        self.assertRaises(RuntimeError, shader.activate)\n\n    def test_delete_no_context(self):\n        shader = VertexShader()\n        shader.delete()\n\n    def test_uniform_float(self):\n        shader = VertexShader(""uniform float color;"")\n        assert shader.uniforms == [(""color"", gl.GL_FLOAT)]\n\n    def test_uniform_vec4(self):\n        shader = VertexShader(""uniform vec4 color;"")\n        assert shader.uniforms == [(""color"", gl.GL_FLOAT_VEC4)]\n\n    def test_uniform_array(self):\n        shader = VertexShader(""uniform float color[2];"")\n        assert shader.uniforms == [(""color[0]"", gl.GL_FLOAT),\n                                   (""color[1]"", gl.GL_FLOAT)]\n\n    def test_attribute_float(self):\n        shader = VertexShader(""attribute float color;"")\n        assert shader.attributes == [(""color"", gl.GL_FLOAT)]\n\n    def test_attribute_vec4(self):\n        shader = VertexShader(""attribute vec4 color;"")\n        assert shader.attributes == [(""color"", gl.GL_FLOAT_VEC4)]\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
glumpy/gloo/tests/test_texture.py,63,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport unittest\nimport numpy as np\n\nfrom glumpy.gloo.texture import Texture, Texture1D, Texture2D\nfrom glumpy import gl\n\n\n# ----------------------------------------------------------------- Texture ---\nclass TextureTest(unittest.TestCase):\n\n    # No data, no dtype : forbidden\n    # ---------------------------------\n    def test_init_none(self):\n        # with self.assertRaises(ValueError):\n        #    T = Texture()\n        self.assertRaises(ValueError, Texture)\n\n    # Data only\n    # ---------------------------------\n    def test_init_data(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        assert T._shape == (10, 10)\n        assert T._dtype == np.uint8\n        assert T._offset == (0, 0)\n        assert T._store is True\n        assert T._copy is False\n        assert T._need_resize is True\n        assert T._need_update is True\n        assert T._data is data\n        assert len(T._pending_data) == 1\n\n    # Non contiguous data\n    # ---------------------------------\n    def test_init_non_contiguous_data(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data[::2, ::2])\n        assert T._shape == (5, 5)\n        assert T._dtype == np.uint8\n        assert T._offset == (0, 0)\n        assert T._store is True\n        assert T._copy is True\n        assert T._need_resize is True\n        assert T._need_update is True\n        assert T._data is not data\n        assert len(T._pending_data) == 1\n\n    # Dtype and shape\n    # ---------------------------------\n    def test_init_dtype_shape(self):\n        T = Texture(shape=(10, 10), dtype=np.uint8)\n        assert T._shape == (10, 10)\n        assert T._dtype == np.uint8\n        assert T._offset == (0, 0)\n        assert T._store is True\n        assert T._copy is False\n        assert T._need_resize is True\n        assert T._need_update is False\n        assert T._data is not None\n        assert T._data.shape == (10, 10)\n        assert T._data.dtype == np.uint8\n        assert len(T._pending_data) == 0\n\n    # Dtype only\n    # ---------------------------------\n    def test_init_dtype(self):\n        T = Texture(dtype=np.uint8)\n        assert T._shape == ()\n        assert T._dtype == np.uint8\n        assert T._offset == ()\n        assert T._store is True\n        assert T._copy is False\n        assert T._need_resize is False\n        assert T._need_update is False\n        assert T._data is not None\n        assert len(T._pending_data) == 0\n\n    # Data and dtype: dtype prevails\n    # ---------------------------------\n    def test_init_data_dtype(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data, dtype=np.uint16)\n        assert T._shape == (10, 10)\n        assert T._dtype == np.uint16\n        assert T._offset == (0, 0)\n        assert T._store is True\n        assert T._copy is False\n        assert T._need_resize is True\n        assert T._need_update is True\n        assert T._data is not data\n        assert len(T._pending_data) == 1\n\n    # Data, store but no copy\n    # ---------------------------------\n    def test_init_data_store(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data, store=True)\n        assert T._data is data\n\n    # Data, store and copy\n    # ---------------------------------\n    def test_init_data_store_copy(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data.copy(), store=True)\n        assert T._data is not data\n        assert T._data is not None\n\n    # Get a view of the whole texture\n    # ---------------------------------\n    def test_getitem_ellipsis(self):\n\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        Z = T[...]\n        assert Z._base is T\n        assert Z._data.base is T._data\n        assert Z._shape == (10, 10)\n        assert Z._resizeable is False\n        assert len(Z._pending_data) == 0\n\n    # Get a view using ellipsis at start\n    # ---------------------------------\n    def test_getitem_ellipsis_start(self):\n\n        data = np.zeros((10, 10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        Z = T[..., 0]\n        assert Z._base is T\n        assert Z._data.base is T._data\n        assert Z._shape == (10, 10, 1)\n        assert Z._resizeable is False\n        assert len(Z._pending_data) == 0\n\n    # Get a view using ellipsis at end\n    # ---------------------------------\n    def test_getitem_ellipsis_end(self):\n\n        data = np.zeros((10, 10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        Z = T[0, ...]\n        assert Z._base is T\n        assert Z._data.base is T._data\n        assert Z._shape == (1, 10, 10)\n        assert Z._resizeable is False\n        assert len(Z._pending_data) == 0\n\n    # Get a single item\n    # ---------------------------------\n    def test_getitem_single(self):\n\n        data = np.zeros((10, 10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        Z = T[0, 0, 0]\n        assert Z._base is T\n        assert Z._data.base is T._data\n        assert Z._shape == (1, 1, 1)\n        assert Z._resizeable is False\n        assert len(Z._pending_data) == 0\n\n    # Get a partial view\n    # ---------------------------------\n    def test_getitem_partial(self):\n\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        Z = T[2:5, 2:5]\n        assert Z._base is T\n        assert Z._data.base is T._data\n        assert Z._shape == (3, 3)\n        assert Z._offset == (2, 2)\n        assert Z._resizeable is False\n        assert len(Z._pending_data) == 0\n\n    # Get non contiguous view : forbidden\n    # ---------------------------------\n    def test_getitem_non_contiguous(self):\n\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        # with self.assertRaises(ValueError):\n        #    Z = T[::2, ::2]\n        #    print(Z)\n        s = slice(None, None, 2)\n        self.assertRaises(ValueError, T.__getitem__, (s, s))\n\n    # Set data with store\n    # ---------------------------------\n    def test_setitem_all(self):\n\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        T[...] = np.ones((10, 10))\n        assert len(T._pending_data) == 1\n        assert np.allclose(data, np.ones((10, 10)))\n\n    # Set data without store\n    # ---------------------------------\n    def test_setitem_all_no_store(self):\n\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data, store=False)\n        T[...] = np.ones((10, 10), np.uint8)\n        assert len(T._pending_data) == 1\n        assert np.allclose(data, np.zeros((10, 10)))\n\n    # Set a single data\n    # ---------------------------------\n    def test_setitem_single(self):\n\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        T[0, 0] = 1\n        assert len(T._pending_data) == 2\n        assert data[0, 0] == 1, 1\n\n    # Set some data\n    # ---------------------------------\n    def test_setitem_partial(self):\n\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        T[5:, 5:] = 1\n        assert len(T._pending_data) == 2\n        assert np.allclose(data[5:, 5:], np.ones((5, 5)))\n\n    # Set non contiguous data\n    # ---------------------------------\n    def test_setitem_wrong(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        # with self.assertRaises(ValueError):\n        #    T[::2, ::2] = 1\n        s = slice(None, None, 2)\n        self.assertRaises(ValueError, T.__setitem__, (s, s), 1)\n\n    # Set via get (pending data on base)\n    # ---------------------------------\n    def test_getitem_setitem(self):\n\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture(data=data)\n        Z = T[5:, 5:]\n        Z[...] = 1\n        assert len(Z._pending_data) == 0\n        assert len(T._pending_data) == 2\n        assert np.allclose(data[5:, 5:], np.ones((5, 5)))\n\n\n# --------------------------------------------------------------- Texture1D ---\nclass Texture1DTest(unittest.TestCase):\n\n    # Shape extension\n    # ---------------------------------\n    def test_init(self):\n        data = np.zeros(10, dtype=np.uint8)\n        T = Texture1D(data=data)\n        assert T._shape == (10, 1)\n\n    # Width\n    # ---------------------------------\n    def test_width(self):\n        data = np.zeros(10, dtype=np.uint8)\n        T = Texture1D(data=data)\n        assert T.width == 10\n\n    # Set misshaped data\n    # ---------------------------------\n    def test_set_misshaped_data_1D(self):\n        data = np.zeros(10, dtype=np.uint8)\n        T = Texture1D(data=data)\n        # with self.assertRaises(ValueError):\n        #    T.set_data(np.ones((10, 10)))\n        self.assertRaises(ValueError, T.set_data, np.ones((10, 10)))\n\n\n# --------------------------------------------------------------- Texture2D ---\nclass Texture2DTest(unittest.TestCase):\n    # Note: put many tests related to (re)sizing here, because Texture\n    # is not really aware of shape.\n\n    # Shape extension\n    # ---------------------------------\n    def test_init(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        assert T._shape == (10, 10, 1)\n\n    # Width & height\n    # ---------------------------------\n    def test_width_height(self):\n        data = np.zeros((10, 20), dtype=np.uint8)\n        T = Texture2D(data=data)\n        assert T.width == 20\n        assert T.height == 10\n\n    # Resize\n    # ---------------------------------\n    def test_resize(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        T.resize((5, 5))\n        assert T.shape == (5, 5, 1)\n        assert T._data.shape == (5, 5, 1)\n        assert T._need_resize is True\n        assert T._need_update is False\n        assert len(T._pending_data) == 0\n\n    # Resize with bad shape\n    # ---------------------------------\n    def test_resize_bad_shape(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        # with self.assertRaises(ValueError):\n        #    T.resize((5, 5, 5))\n        self.assertRaises(ValueError, T.resize, (5, 5, 5))\n\n    # Resize view (forbidden)\n    # ---------------------------------\n    def test_resize_view(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        # with self.assertRaises(RuntimeError):\n        #    T[...].resize((5, 5))\n        Z = T[...]\n        self.assertRaises(RuntimeError, Z.resize, (5, 5))\n\n    # Resize not resizeable\n    # ---------------------------------\n    def test_resize_unresizeable(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data, resizeable=False)\n        # with self.assertRaises(RuntimeError):\n        #    T.resize((5, 5))\n        self.assertRaises(RuntimeError, T.resize, (5, 5))\n\n    # Set oversized data (-> resize)\n    # ---------------------------------\n    def test_set_oversized_data(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        T.set_data(np.ones((20, 20), np.uint8))\n        assert T.shape == (20, 20, 1)\n        assert T._data.shape == (20, 20, 1)\n        assert len(T._pending_data) == 1\n\n    # Set undersized data\n    # ---------------------------------\n    def test_set_undersized_data(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        T.set_data(np.ones((5, 5), np.uint8))\n        assert T.shape == (5, 5, 1)\n        assert len(T._pending_data) == 1\n\n    # Set misplaced data\n    # ---------------------------------\n    def test_set_misplaced_data(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        # with self.assertRaises(ValueError):\n        #    T.set_data(np.ones((5, 5)), offset=(8, 8))\n        self.assertRaises(ValueError, T.set_data,\n                          np.ones((5, 5)), offset=(8, 8))\n\n    # Set misshaped data\n    # ---------------------------------\n    def test_set_misshaped_data_2D(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        # with self.assertRaises(ValueError):\n        #    T.set_data(np.ones((10, 10)))\n        self.assertRaises(ValueError, T.set_data, np.ones((10,)))\n\n    # Set whole data (clear pending data)\n    # ---------------------------------\n    def test_set_whole_data(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        T.set_data(np.ones((10, 10), np.uint8))\n        assert T.shape == (10, 10, 1)\n        assert len(T._pending_data) == 1\n\n    # Test view get invalidated when base is resized\n    # ----------------------------------------------\n    def test_invalid_views(self):\n        data = np.zeros((10, 10), dtype=np.uint8)\n        T = Texture2D(data=data)\n        Z = T[5:, 5:]\n        T.resize((5, 5))\n        assert Z._valid is False\n\n    # Test set data with different shape\n    # ---------------------------------\n    def test_reset_data_shape(self):\n        shape1 = 10, 10\n        shape3 = 10, 10, 3\n\n        # Init data (explicit shape)\n        data = np.zeros((10, 10, 1), dtype=np.uint8)\n        T = Texture2D(data=data)\n        assert T.shape == (10, 10, 1)\n        assert T._format == gl.GL_LUMINANCE\n\n        # Set data to rgb\n        T.set_data(np.zeros(shape3, np.uint8))\n        assert T.shape == (10, 10, 3)\n        assert T._format == gl.GL_RGB\n\n\n        # Set data to grayscale\n        T.set_data(np.zeros(shape1, np.uint8))\n        assert T.shape == (10, 10, 1)\n        assert T._format == gl.GL_LUMINANCE\n\n        # Set size to rgb\n        T.resize(shape3)\n        assert T.shape == (10, 10, 3)\n        assert T._format == gl.GL_RGB\n\n        # Set size to grayscale\n        T.resize(shape1)\n        assert T.shape == (10, 10, 1)\n        assert T._format == gl.GL_LUMINANCE\n\n    # Test set data with different shape\n    # ---------------------------------\n    def test_reset_data_type(self):\n        shape = 10, 10\n        T = Texture2D(data=np.zeros(shape, dtype=np.uint8))\n        assert T.dtype == np.uint8\n        assert T._gtype == gl.GL_UNSIGNED_BYTE\n\n        newdata = np.zeros(shape, dtype=np.float32)\n        self.assertRaises(ValueError, T.set_data, newdata)\n\n        newdata = np.zeros(shape, dtype=np.int32)\n        self.assertRaises(ValueError, T.set_data, newdata)\n\n\n# -----------------------------------------------------------------------------\nif __name__ == ""__main__"":\n    unittest.main()\n'"
glumpy/gloo/tests/test_variable.py,10,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport unittest\nimport numpy as np\n\nimport glumpy.gl as gl\nfrom glumpy.gloo.variable import Uniform, Variable, Attribute\n\n\n# -----------------------------------------------------------------------------\nclass VariableTest(unittest.TestCase):\n\n    def test_init(self):\n        variable = Variable(None, ""A"", gl.GL_FLOAT)\n        assert variable._handle == -1\n        assert variable.name == ""A""\n        assert variable.data is None\n        assert variable.gtype == gl.GL_FLOAT\n        assert variable.active is True\n\n    def test_init_wrong_type(self):\n        # with self.assertRaises(TypeError):\n        #    v = Variable(None, ""A"", gl.GL_INT_VEC2)\n        self.assertRaises(TypeError, Variable, None, ""A"", gl.GL_INT_VEC2)\n\n        # with self.assertRaises(TypeError):\n        #    v = Variable(None, ""A"", gl.GL_INT_VEC3)\n        self.assertRaises(TypeError, Variable, None, ""A"", gl.GL_INT_VEC3)\n\n        # with self.assertRaises(TypeError):\n        #    v = Variable(None, ""A"", gl.GL_INT_VEC4)\n        self.assertRaises(TypeError, Variable, None, ""A"", gl.GL_INT_VEC4)\n\n        # with self.assertRaises(TypeError):\n        #    v = Variable(None, ""A"", gl.GL_BOOL_VEC2)\n        self.assertRaises(TypeError, Variable, None, ""A"", gl.GL_BOOL_VEC2)\n\n        # with self.assertRaises(TypeError):\n        #    v = Variable(None, ""A"", gl.GL_BOOL_VEC3)\n        self.assertRaises(TypeError, Variable, None, ""A"", gl.GL_BOOL_VEC3)\n\n        # with self.assertRaises(TypeError):\n        #    v = Variable(None, ""A"", gl.GL_BOOL_VEC4)\n        self.assertRaises(TypeError, Variable, None, ""A"", gl.GL_BOOL_VEC4)\n\n\n# -----------------------------------------------------------------------------\nclass UniformTest(unittest.TestCase):\n\n    def test_init(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT)\n        assert uniform._unit == -1\n\n    def test_float(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT)\n        assert uniform.data.dtype == np.float32\n        assert uniform.data.size == 1\n\n    def test_vec2(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT_VEC2)\n        assert uniform.data.dtype == np.float32\n        assert uniform.data.size == 2\n\n    def test_vec3(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT_VEC2)\n        assert uniform.data.dtype == np.float32\n        assert uniform.data.size == 2\n\n    def test_vec4(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT_VEC2)\n        assert uniform.data.dtype == np.float32\n        assert uniform.data.size == 2\n\n    def test_int(self):\n        uniform = Uniform(None, ""A"", gl.GL_INT)\n        assert uniform.data.dtype == np.int32\n        assert uniform.data.size == 1\n\n    def test_mat2(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT_MAT2)\n        assert uniform.data.dtype == np.float32\n        assert uniform.data.size == 4\n\n    def test_mat3(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT_MAT3)\n        assert uniform.data.dtype == np.float32\n        assert uniform.data.size == 9\n\n    def test_mat4(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT_MAT4)\n        assert uniform.data.dtype == np.float32\n        assert uniform.data.size == 16\n\n    def test_set(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT_VEC4)\n\n        uniform.set_data(1)\n        assert (uniform.data == 1).all()\n\n        uniform.set_data([1, 2, 3, 4])\n        assert (uniform.data == [1, 2, 3, 4]).all()\n\n    def test_set_exception(self):\n        uniform = Uniform(None, ""A"", gl.GL_FLOAT_VEC4)\n\n        # with self.assertRaises(ValueError):\n        #    uniform.set_data([1, 2])\n        self.assertRaises(ValueError, uniform.set_data, [1, 2])\n\n        # with self.assertRaises(ValueError):\n        #    uniform.set_data([1, 2, 3, 4, 5])\n        self.assertRaises(ValueError, uniform.set_data, [1, 2, 3, 4, 5])\n\n\n# -----------------------------------------------------------------------------\nclass AttributeTest(unittest.TestCase):\n\n    def test_init(self):\n        attribute = Attribute(None, ""A"", gl.GL_FLOAT)\n        assert attribute.size == 0\n\n    def test_set_generic(self):\n        attribute = Attribute(None, ""A"", gl.GL_FLOAT_VEC4)\n\n        attribute.set_data(1)\n        assert type(attribute.data) is np.ndarray\n\n#    @unittest.expectedFailure\n#    def test_set_generic_2(self):\n#        attribute = Attribute(None, ""A"", gl.GL_FLOAT_VEC4)\n#        attribute.set_data([1, 2, 3, 4])\n#        assert type(attribute.data) is np.ndarray\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
glumpy/graphics/collections/__init__.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . collection import Collection\nfrom . base_collection import BaseCollection\nfrom . path_collection import PathCollection\nfrom . point_collection import PointCollection\nfrom . glyph_collection import GlyphCollection\nfrom . marker_collection import MarkerCollection\nfrom . polygon_collection import PolygonCollection\nfrom . segment_collection import SegmentCollection\nfrom . triangle_collection import TriangleCollection\n\nfrom . raw_path_collection import RawPathCollection\nfrom . raw_triangle_collection import RawTriangleCollection\nfrom . agg_path_collection import AggPathCollection\nfrom . agg_fast_path_collection import AggFastPathCollection\n'
glumpy/graphics/collections/agg_fast_path_collection.py,16,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAntigrain Geometry Fast Path Collection\n\nThis collection provides antialiased and accurate paths with caps and miter\njoins. It consume x4 more memory than regular lines and is a bit slower, but\nthe quality of the output is worth the cost. Note that no control can be made\non miter joins which may result in some glitches on screen.\n""""""\nimport numpy as np\nfrom glumpy import gl, library\nfrom glumpy.transforms import Position, Viewport\nfrom . collection import Collection\n\n\n\nclass AggFastPathCollection(Collection):\n    """"""\n    Antigrain Geometry Fast Path Collection\n\n    This collection provides antialiased and accurate paths with caps and miter\n    joins. It consume x4 more memory than regular lines and is a bit slower,\n    but the quality of the output is worth the cost. Note that no control can\n    be made on miter joins which may result in some glitches on screen.\n    """"""\n\n    def __init__(self, user_dtype=None, transform=None, viewport=None,\n                 vertex=None, fragment=None, **kwargs):\n        """"""\n        Initialize the collection.\n\n        Parameters\n        ----------\n\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        viewport: glumpy.Transforms\n            The viewport to use to rende the collection\n\n        transform: glumpy.Tranforms\n            The default vertex shader apply the supplied transform to the\n            vertices positions before computing the actual vertices positions\n            for path thickness. Note that it is necessary to add the\n            glumpy.transforms.Viewport transform at the end of the supplied transform.\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        caps : string\n            \'local\', \'shared\' or \'global\'\n\n        color : string\n            \'local\', \'shared\' or \'global\'\n\n        linewidth : string\n            \'local\', \'shared\' or \'global\'\n\n        antialias : string\n            \'local\', \'shared\' or \'global\'\n        """"""\n\n        base_dtype = [ (\'prev\',       (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'curr\',       (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'next\',       (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'id\',         (np.float32, 1), \'!local\', 0),\n                       (\'color\',      (np.float32, 4), \'global\', (0,0,0,1)),\n                       (\'linewidth\',  (np.float32, 1), \'global\', 1),\n                       (\'antialias\',  (np.float32, 1), \'global\', 1) ]\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = library.get(\'collections/agg-fast-path.vert\')\n        if fragment is None:\n            fragment = library.get(\'collections/agg-fast-path.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode=gl.GL_TRIANGLE_STRIP,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        if ""transform"" in program.hooks:\n            if transform is not None:\n                program[""transform""] = transform\n            else:\n                program[""transform""] = Position() + Viewport()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n\n    def append(self, P, closed=False, itemsize=None, **kwargs):\n        """"""\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        color : list, array or 4-tuple\n           Path color\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        """"""\n\n        itemsize  = itemsize or len(P)\n        itemcount = len(P)//itemsize\n\n        P = P.reshape(itemcount,itemsize,3)\n        if closed:\n            V = np.empty((itemcount,itemsize+3), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in [\'collection_index\', \'prev\', \'curr\', \'next\']:\n                    V[name][1:-2] = kwargs.get(name, self._defaults[name])\n            V[\'prev\'][:,2:-1] = P\n            V[\'prev\'][:,1]    = V[\'prev\'][:,-2]\n            V[\'curr\'][:,1:-2] = P\n            V[\'curr\'][:,-2]   = V[\'curr\'][:,1]\n            V[\'next\'][:,0:-3] = P\n            V[\'next\'][:,-3]   = V[\'next\'][:,0]\n            V[\'next\'][:,-2]   = V[\'next\'][:,1]\n        else:\n            V = np.empty((itemcount,itemsize+2), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in [\'collection_index\', \'prev\', \'curr\', \'next\']:\n                    V[name][1:-1] = kwargs.get(name, self._defaults[name])\n            V[\'prev\'][:,2:] = P\n            V[\'prev\'][:,1] = V[\'prev\'][:,2]\n            V[\'curr\'][:,1:-1] = P\n            V[\'next\'][:,:-2] = P\n            V[\'next\'][:,-2] = V[\'next\'][:,-3]\n\n        V[:, 0] = V[:, 1]\n        V[:,-1] = V[:,-2]\n        V = V.ravel()\n        V = np.repeat(V,2,axis=0)\n        V[\'id\'] = np.tile([1,-1],len(V)//2)\n        if closed:\n            V = V.reshape(itemcount,2*(itemsize+3))\n        else:\n            V = V.reshape(itemcount,2*(itemsize+2))\n        V[""id""][:,:2 ] = 2,-2\n        V[""id""][:,-2:] = 2,-2\n        V = V.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          itemsize=2*(itemsize+2+closed))\n\n\n\n    def bake(self, P, key=\'curr\', closed=False, itemsize=None):\n        """"""\n        Given a path P, return the baked vertices as they should be copied in the\n        collection if the path has already been appended.\n\n        Example:\n        --------\n\n        paths.append(P)\n        P *= 2\n        paths[\'prev\'][0] = bake(P,\'prev\')\n        paths[\'curr\'][0] = bake(P,\'curr\')\n        paths[\'next\'][0] = bake(P,\'next\')\n        """"""\n\n        itemsize  = itemsize or len(P)\n        itemcount = len(P)//itemsize\n        n = itemsize\n\n        if closed:\n            I = np.arange(n+3)\n            if key == \'prev\':\n                I -= 2\n                I[0], I[1], I[-1] = n-1, n-1, n-1\n            elif key == \'next\':\n                I[0], I[-3], I[-2], I[-1] = 1, 0, 1, 1\n            else:\n                I -= 1\n                I[0], I[-1], I[n+1] = 0, 0, 0\n        else:\n            I = np.arange(n+2)\n            if key == \'prev\':\n                I -= 2\n                I[0], I[1], I[-1] = 0, 0, n-2\n            elif key == \'next\':\n                I[0], I[-1], I[-2] = 1, n-1, n-1\n            else:\n                I -= 1\n                I[0], I[-1] = 0, n-1\n        I = np.repeat(I,2)\n        return P[I]\n\n\n    def draw(self, mode = gl.GL_TRIANGLE_STRIP):\n        """""" Draw collection """"""\n\n        gl.glDepthMask(gl.GL_FALSE)\n        Collection.draw(self, mode)\n        gl.glDepthMask(gl.GL_TRUE)\n'"
glumpy/graphics/collections/agg_glyph_collection.py,10,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom . collection import Collection\nfrom glumpy import gloo, gl, library\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.transforms import Position, Viewport\n\n\nclass AggGlyphCollection(Collection):\n\n    def __init__(self, transform=None, viewport=None, **kwargs):\n        dtype = [(\'position\',  (np.float32, 2), \'!local\', (0, 0)),\n                 (\'texcoord\',  (np.float32, 2), \'!local\', (0, 0)),\n                 (\'offset\',    (np.float32, 1), \'!local\', 0),\n                 (\'origin\',    (np.float32, 3), \'shared\', (0, 0, 0)),\n                 (\'color\',     (np.float32, 4), \'shared\', (0, 0, 0, 1))]\n\n        if ""vertex"" in kwargs.keys():\n            vertex = kwargs[""vertex""]\n            del kwargs[""vertex""]\n        else:\n            vertex = library.get(\'collections/agg-glyph.vert\')\n\n        if ""fragment"" in kwargs.keys():\n            fragment = kwargs[""fragment""]\n            del kwargs[""fragment""]\n        else:\n            fragment = library.get(\'collections/agg-glyph.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,\n                            mode=gl.GL_TRIANGLES,\n                            vertex=vertex, fragment=fragment)\n\n        program = self._programs[0]\n\n        if transform is not None:\n            program[""transform""] = transform\n        else:\n            program[""transform""] = Position()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n        manager = FontManager()\n        atlas = manager.atlas_agg\n        self[\'atlas_data\'] = atlas\n        self[\'atlas_data\'].interpolation = gl.GL_LINEAR\n        self[\'atlas_shape\'] = atlas.shape[1], atlas.shape[0]\n\n    def append(self, text, font,\n               anchor_x=\'center\', anchor_y=\'center\', **kwargs):\n        """"""\n        Append a new text to the collection\n\n        text : str\n            Text to be appended\n\n        font : glumpy.graphics.font.Font\n            Font to be used to render text\n\n        anchor_x : str\n            Text horizontal anchor (\'left\', \'center\', \'right\')\n\n        anchor_y : str\n            Text horizontal anchor (\'top\', \'center\', \'bottom\')\n        """"""\n\n        V, I = self.bake(text, font, anchor_x, anchor_y)\n\n        defaults = self._defaults\n        reserved = [""collection_index"", ""position"", ""texcoord"", ""offset""]\n        for name in self.vtype.names:\n            if name not in reserved:\n                if name in kwargs.keys() or name in defaults.keys():\n                    V[name] = kwargs.get(name, defaults[name])\n\n        if self.utype:\n            U = np.zeros(1, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    if name in kwargs.keys() or name in defaults.keys():\n                        U[name] = kwargs.get(name, defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, indices=I, uniforms=U)\n\n    def bake(self, text, font, anchor_x=\'center\', anchor_y=\'center\'):\n        """""" Bake a text string to be added in the collection """"""\n\n        n = len(text) - text.count(\'\\n\')\n        indices = np.zeros((n, 6), dtype=self.itype)\n        vertices = np.zeros((n, 4), dtype=self.vtype)\n\n        # Current line start index\n        start = 0\n        # Pen position\n        pen = [0, 0]\n        # Previous glyph\n        prev = None\n        # Lines (as start/end index and width (pixels)\n        lines = []\n        # Maximum text width and total height\n        text_width, text_height = 0, 0\n\n        index = 0\n        for charcode in text:\n\n            # Line feed\n            if charcode == \'\\n\':\n                prev = None\n                lines.append(((start, index), pen[0]))\n                start = index\n                text_width = max(text_width, pen[0])\n                pen[1] -= font.height\n                pen[0] = 0\n                # Actual glyph\n            else:\n                glyph = font[charcode]\n                kerning = glyph.get_kerning(prev)\n                x0 = pen[0] + glyph.offset[0] + kerning\n                offset = x0-int(x0)\n                x0 = int(x0)\n                y0 = pen[1] + glyph.offset[1]\n                x1 = x0 + glyph.shape[0]\n                y1 = y0 - glyph.shape[1]\n                u0, v0, u1, v1 = glyph.texcoords\n                vertices[index][\'position\'] = ((x0, y0), (x0, y1),\n                                               (x1, y1), (x1, y0))\n                vertices[index][\'texcoord\'] = ((u0, v0), (u0, v1),\n                                               (u1, v1), (u1, v0))\n                vertices[index][\'offset\'] = offset\n                indices[index] = index*4\n                indices[index] += np.array([0, 1, 2, 0, 2, 3], dtype=np.uint32)\n                pen[0] = pen[0]+glyph.advance[0]/64. + kerning\n                pen[1] = pen[1]+glyph.advance[1]/64.\n                prev = charcode\n                index += 1\n\n        lines.append(((start, index+1), pen[0]))\n        text_height = (len(lines)-1)*font.height\n        text_width = max(text_width, pen[0])\n\n        # Adjusting each line\n        for ((start, end), width) in lines:\n            if anchor_x == \'right\':\n                dx = -width/1.0\n            elif anchor_x == \'center\':\n                dx = -width/2.0\n            else:\n                dx = 0\n            vertices[start:end][\'position\'] += round(dx), 0\n\n        # Adjusting whole label\n        if anchor_y == \'top\':\n            dy = - (font.ascender + font.descender)\n        elif anchor_y == \'center\':\n            dy = (text_height - (font.descender + font.ascender))/2\n        elif anchor_y == \'bottom\':\n            dy = -font.descender + text_height\n        else:\n            dy = 0\n        vertices[\'position\'] += 0, round(dy)\n        vertices = vertices.ravel()\n        indices = indices.ravel()\n        return vertices, indices\n\n    def view(self, transform, viewport=None):\n        """""" Return a view on the collection using provided transform """"""\n\n        return GlyphCollectionView(self, transform, viewport)\n\n\nclass GlyphCollectionView(object):\n\n    def __init__(self, collection, transform=None, viewport=None):\n\n        vertex = collection._vertex\n        fragment = collection._fragment\n        program = gloo.Program(vertex, fragment)\n\n        if ""transform"" in program.hooks and transform is not None:\n            program[""transform""] = transform\n\n        if ""viewport"" in program.hooks and viewport is not None:\n            program[""viewport""] = viewport\n\n        program.bind(collection._vertices_buffer)\n        for name in collection._uniforms.keys():\n            program[name] = collection._uniforms[name]\n\n        collection._programs.append(program)\n        self._program = program\n        self._collection = collection\n\n    def __getitem__(self, key):\n        return self._program[key]\n\n    def __setitem__(self, key, value):\n        self._program[key] = value\n\n    def draw(self):\n        program = self._program\n        collection = self._collection\n        mode = collection._mode\n\n        if collection._need_update:\n            collection._update()\n            # self._program.bind(self._vertices_buffer)\n\n            if collection._uniforms_list is not None:\n                program[""uniforms""] = collection._uniforms_texture\n                program[""uniforms_shape""] = collection._ushape\n\n        atlas = collection[""atlas_data""]\n        program[\'atlas_data\'] = atlas\n        program[\'atlas_data\'].interpolation = gl.GL_LINEAR\n        program[\'atlas_shape\'] = atlas.shape[1], atlas.shape[0]\n\n        if collection._indices_list is not None:\n            program.draw(mode, collection._indices_buffer)\n        else:\n            program.draw(mode)\n'"
glumpy/graphics/collections/agg_path_collection.py,21,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAntigrain Geometry Path Collection\n\nThis collection provides antialiased and accurate paths with caps and joins. It\nis memory hungry (x8) and slow (x.25) so it is to be used sparingly, mainly for\nthick paths where quality is critical.\n""""""\nimport numpy as np\nfrom glumpy import gl, library\nfrom glumpy.transforms import Position, Viewport\nfrom . collection import Collection\n\n\n\nclass AggPathCollection(Collection):\n    """"""\n    Antigrain Geometry Path Collection\n\n    This collection provides antialiased and accurate paths with caps and\n    joins. It is memory hungry (x8) and slow (x.25) so it is to be used\n    sparingly, mainly for thick paths where quality is critical.\n    """"""\n\n    def __init__(self, user_dtype=None, transform=None, viewport=None,\n                 vertex=None, fragment=None, **kwargs):\n        """"""\n        Initialize the collection.\n\n        Parameters\n        ----------\n\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        viewport: glumpy.Transforms\n            The viewport to use to rende the collection\n\n        transform: glumpy.Tranforms\n            The default vertex shader apply the supplied transform to the\n            vertices positions before computing the actual vertices positions\n            for path thickness. Note that it is necessary to add the\n            glumpy.transforms.Viewport transform at the end of the supplied transform.\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        caps : string\n            \'local\', \'shared\' or \'global\'\n\n        join : string\n            \'local\', \'shared\' or \'global\'\n\n        color : string\n            \'local\', \'shared\' or \'global\'\n\n        miter_limit : string\n            \'local\', \'shared\' or \'global\'\n\n        linewidth : string\n            \'local\', \'shared\' or \'global\'\n\n        antialias : string\n            \'local\', \'shared\' or \'global\'\n        """"""\n\n        base_dtype = [ (\'p0\',         (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'p1\',         (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'p2\',         (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'p3\',         (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'uv\',         (np.float32, 2), \'!local\', (0,0)),\n\n                       (\'caps\',       (np.float32, 2), \'global\', (0,0)),\n                       (\'join\',       (np.float32, 1), \'global\', 0),\n                       (\'color\',      (np.float32, 4), \'global\', (0,0,0,1)),\n                       (\'miter_limit\',(np.float32, 1), \'global\', 4),\n                       (\'linewidth\',  (np.float32, 1), \'global\', 1),\n                       (\'antialias\',  (np.float32, 1), \'global\', 1) ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = library.get(\'collections/agg-path.vert\')\n        if fragment is None:\n            fragment = library.get(\'collections/agg-path.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32, mode=gl.GL_TRIANGLES,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        if ""transform"" in program.hooks:\n            if transform is not None:\n                program[""transform""] = transform\n            else:\n                program[""transform""] = Position() + Viewport()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n\n    def append(self, P, closed=False, itemsize=None, **kwargs):\n        """"""\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        join : list, array or float\n           path segment join\n\n        color : list, array or 4-tuple\n           Path color\n\n        miter_limit : list, array or float\n           Miter limit for join\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        """"""\n\n        itemsize  = itemsize or len(P)\n        itemcount = len(P)//itemsize\n\n        # Computes the adjacency information\n        n,p = len(P), P.shape[-1]\n        Z = np.tile(P,2).reshape(2*len(P),p)\n        V = np.empty(n, dtype=self.vtype)\n\n        V[\'p0\'][1:-1]= Z[0::2][:-2]\n        V[\'p1\'][:-1] = Z[1::2][:-1]\n        V[\'p2\'][:-1] = Z[1::2][+1:]\n        V[\'p3\'][:-2] = Z[0::2][+2:]\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in [\'collection_index\', \'p0\', \'p1\', \'p2\', \'p3\']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        # Extract relevant segments only\n        V = (V.reshape(n//itemsize, itemsize)[:,:-1])\n        if closed:\n            V[\'p0\'][:, 0] = V[\'p2\'][:,-1]\n            V[\'p3\'][:,-1] = V[\'p1\'][:, 0]\n        else:\n            V[\'p0\'][:, 0] = V[\'p1\'][:, 0]\n            V[\'p3\'][:,-1] = V[\'p2\'][:,-1]\n        V = V.ravel()\n\n        # Quadruple each point (we\'re using 2 triangles / segment)\n        # No shared vertices between segment because of joins\n        V = np.repeat(V,4,axis=0).reshape((len(V),4))\n        V[\'uv\'] = (-1,-1), (-1,+1), (+1,-1), (+1,+1)\n        V = V.ravel()\n\n        n = itemsize\n        if closed:\n            I = np.resize(np.array([0,1,2, 1,2,3], dtype=np.uint32),n*2*3)\n            I += np.repeat( 4*np.arange(n, dtype=np.uint32), 6)\n            I[-6:] = 4*n-6,4*n-5,0,4*n-5,0,1\n        else:\n            I = np.resize(np.array([0,1,2, 1,2,3], dtype=np.uint32),(n-1)*2*3)\n            I += np.repeat( 4*np.arange(n-1, dtype=np.uint32), 6)\n        I = I.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          indices=I, itemsize=itemsize*4-4)\n\n\n    def draw(self, mode = gl.GL_TRIANGLES):\n        """""" Draw collection """"""\n\n        gl.glDepthMask(gl.GL_FALSE)\n        Collection.draw(self, mode)\n        gl.glDepthMask(gl.GL_TRUE)\n'"
glumpy/graphics/collections/agg_point_collection.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAntigrain Geometry Point Collection\n\nThis collection provides fast points. Output quality is perfect.\n""""""\nfrom glumpy import library\nfrom . raw_point_collection import RawPointCollection\n\n\nclass AggPointCollection(RawPointCollection):\n    """"""\n    Antigrain Geometry Point Collection\n\n    This collection provides fast points. Output quality is perfect.\n    """"""\n\n    def __init__(self, user_dtype=None, transform=None,\n                 viewport=None, vertex=None, fragment=None, **kwargs):\n        """"""\n        Initialize the collection.\n\n        Parameters\n        ----------\n\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform: glumpy.Tranforms\n            The default vertex shader apply the supplied transform to the\n            vertices positions before computing the actual vertices positions\n            for path thickness.\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            \'local\', \'shared\' or \'global\'\n        """"""\n        if vertex is None:\n            vertex = library.get(""collections/agg-point.vert"")\n        if fragment is None:\n            fragment = library.get(""collections/agg-point.frag"")\n\n        RawPointCollection.__init__(self, user_dtype=user_dtype,\n                                    transform=transform, viewport=viewport,\n                                    vertex=vertex, fragment=fragment, **kwargs)\n'"
glumpy/graphics/collections/agg_segment_collection.py,13,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAntigrain Geometry Segment Collection\n\nThis collection provides antialiased and accurate segments with caps. It\nconsume x2 more memory than regular lines and is a bit slower, but the quality\nof the output is worth the cost.\n""""""\nimport numpy as np\nfrom glumpy import gl, library\nfrom glumpy.transforms import Position, Viewport\nfrom . collection import Collection\n\n\nclass AggSegmentCollection(Collection):\n    """"""\n    Antigrain Geometry Segment Collection\n\n    This collection provides antialiased and accurate segments with caps. It\n    consume x2 more memory than regular lines and is a bit slower, but the quality\n    of the output is worth the cost.\n    """"""\n\n    def __init__(self, user_dtype=None, transform=None,\n                 viewport=None, vertex=None, fragment=None, **kwargs):\n        """"""\n        Initialize the collection.\n\n        Parameters\n        ----------\n\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform: glumpy.Transforms\n            The default vertex shader apply the supplied transform to the\n            vertices positions before computing the actual vertices positions\n            for path thickness. Note that it is necessary to add the\n            glumpy.transforms.Viewport transform at the end of the supplied transform.\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        caps : string\n            \'local\', \'shared\' or \'global\'\n\n        color : string\n            \'local\', \'shared\' or \'global\'\n\n        linewidth : string\n            \'local\', \'shared\' or \'global\'\n\n        antialias : string\n            \'local\', \'shared\' or \'global\'\n        """"""\n\n        base_dtype = [ (\'P0\',        (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'P1\',        (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'index\',     (np.float32, 1), \'!local\', 0),\n                       (\'color\',     (np.float32, 4), \'shared\', (0,0,0,1)),\n                       (\'linewidth\', (np.float32, 1), \'shared\', 1),\n                       (\'antialias\', (np.float32, 1), \'shared\', 1) ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = library.get(\'collections/agg-segment.vert\')\n        if fragment is None:\n            fragment = library.get(\'collections/agg-segment.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32, mode=gl.GL_TRIANGLES,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        if ""transform"" in program.hooks:\n            if transform is not None:\n                program[""transform""] = transform\n            else:\n                program[""transform""] = Position() + Viewport()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n\n    def append(self, P0, P1, itemsize=None, **kwargs):\n        """"""\n        Append a new set of segments to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        color : list, array or 4-tuple\n           Path color\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        """"""\n\n        itemsize  = itemsize or 1\n        itemcount = len(P0)//itemsize\n\n        V = np.empty(itemcount, dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in [\'collection_index\', \'P0\', \'P1\', \'index\']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        V[\'P0\'] = P0\n        V[\'P1\'] = P1\n        V = V.repeat(4,axis=0)\n        V[\'index\'] = np.resize([0,1,2,3], 4*itemcount*itemsize)\n\n        I = np.ones((itemcount, 6), dtype=int)\n        I[:] = 0,1,2,0,2,3\n        I[:] += 4*np.arange(itemcount)[:,np.newaxis]\n        I = I.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U, indices=I, itemsize=4*itemcount)\n'"
glumpy/graphics/collections/array_list.py,19,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAn ArrayList is a strongly typed list whose type can be anything that can be\ninterpreted as a numpy data type.\n\nExample\n-------\n\n>>> L = ArrayList( [[0], [1,2], [3,4,5], [6,7,8,9]] )\n>>> print L\n[ [0] [1 2] [3 4 5] [6 7 8 9] ]\n>>> print L.data\n[0 1 2 3 4 5 6 7 8 9]\n\nYou can add several items at once by specifying common or individual size: a\nsingle scalar means all items are the same size while a list of sizes is used\nto specify individual item sizes.\n\nExample\n-------\n\n>>> L = ArrayList( np.arange(10), [3,3,4])\n>>> print L\n[ [0 1 2] [3 4 5] [6 7 8 9] ]\n>>> print L.data\n[0 1 2 3 4 5 6 7 8 9]\n""""""\nimport numpy as np\n\n\nclass ArrayList(object):\n    """"""\n    An ArrayList is a strongly typed list whose type can be anything that can\n    be interpreted as a numpy data type.\n    """"""\n\n    def __init__(self, data=None, itemsize=None, dtype=float,\n                 sizeable=True, writeable=True):\n        """""" Create a new buffer using given data and sizes or dtype\n\n        Parameters\n        ----------\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose succesive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n\n        dtype: np.dtype\n            Any object that can be interpreted as a numpy data type.\n\n        sizeable : boolean\n            Indicate whether item can be appended/inserted/deleted\n\n        writeable : boolean\n            Indicate whether content can be changed\n        """"""\n\n        self._sizeable = sizeable\n        self._writeable = writeable\n\n        if data is not None:\n            if isinstance(data, (list, tuple)):\n                if isinstance(data[0], (list, tuple)):\n                    itemsize = [len(l) for l in data]\n                    data = [item for sublist in data for item in sublist]\n            self._data = np.array(data, copy=False)\n            self._size = self._data.size\n\n            # Default is one group with all data inside\n            _itemsize = np.ones(1) * self._data.size\n\n            # Check item sizes and get items count\n            if itemsize is not None:\n                if isinstance(itemsize, int):\n                    if (self._size % itemsize) != 0:\n                        raise ValueError(""Cannot partition data as requested"")\n                    self._count = self._size // itemsize\n                    _itemsize = np.ones(\n                        self._count, dtype=int) * (self._size // self._count)\n                else:\n                    _itemsize = np.array(itemsize, copy=False)\n                    self._count = len(itemsize)\n                    if _itemsize.sum() != self._size:\n                        raise ValueError(""Cannot partition data as requested"")\n            else:\n                self._count = 1\n\n            # Store items\n            self._items = np.zeros((self._count, 2), int)\n            C = _itemsize.cumsum()\n            self._items[1:, 0] += C[:-1]\n            self._items[0:, 1] += C\n\n        else:\n            self._data = np.zeros(1, dtype=dtype)\n            self._items = np.zeros((1, 2), dtype=int)\n            self._size = 0\n            self._count = 0\n\n    @property\n    def data(self):\n        """""" The array\'s elements, in memory. """"""\n        return self._data[:self._size]\n\n    @property\n    def size(self):\n        """""" Number of base elements, in memory. """"""\n        return self._size\n\n    @property\n    def itemsize(self):\n        """""" Individual item sizes """"""\n        return self._items[:self._count, 1] - self._items[:self._count, 0]\n\n    @property\n    def dtype(self):\n        """""" Describes the format of the elements in the buffer. """"""\n        return self._data.dtype\n\n\n    def reserve(self, capacity):\n        """""" Set current capacity of the underlying array""""""\n\n        if capacity >= self._data.size:\n            capacity = int(2 ** np.ceil(np.log2(capacity)))\n            self._data = np.resize(self._data, capacity)\n\n\n    def __len__(self):\n        """""" x.__len__() <==> len(x) """"""\n        return self._count\n\n    def __str__(self):\n        s = \'[ \'\n        for item in self:\n            s += str(item) + \' \'\n        s += \']\'\n        return s\n\n    def __getitem__(self, key):\n        """""" x.__getitem__(y) <==> x[y] """"""\n\n        if isinstance(key, int):\n            if key < 0:\n                key += len(self)\n            if key < 0 or key >= len(self):\n                raise IndexError(""Tuple index out of range"")\n            dstart = self._items[key][0]\n            dstop = self._items[key][1]\n            return self._data[dstart:dstop]\n\n        elif isinstance(key, slice):\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart, istop = istop, istart\n            dstart = self._items[istart][0]\n            if istart == istop:\n                dstop = dstart\n            else:\n                dstop = self._items[istop - 1][1]\n            return self._data[dstart:dstop]\n\n        elif isinstance(key, str):\n            return self._data[key][:self._size]\n\n        elif key is Ellipsis:\n            return self.data\n\n        else:\n            raise TypeError(""List indices must be integers"")\n\n    def __setitem__(self, key, data):\n        """""" x.__setitem__(i, y) <==> x[i]=y """"""\n\n        if not self._writeable:\n            raise AttributeError(""List is not writeable"")\n\n        if isinstance(key, (int,slice)):\n            if isinstance(key, int):\n                if key < 0:\n                    key += len(self)\n                if key < 0 or key > len(self):\n                    raise IndexError(""List assignment index out of range"")\n                dstart = self._items[key][0]\n                dstop = self._items[key][1]\n                istart = key\n            elif isinstance(key, slice):\n                istart, istop, step = key.indices(len(self))\n                if istart == istop:\n                    return\n                if istart > istop:\n                    istart, istop = istop, istart\n                if istart > len(self) or istop > len(self):\n                    raise IndexError(""Can only assign iterable"")\n                dstart = self._items[istart][0]\n                if istart == istop:\n                    dstop = dstart\n                else:\n                    dstop = self._items[istop - 1][1]\n\n            if hasattr(data, ""__len__""):\n                if len(data) == dstop-dstart: # or len(data) == 1:\n                    self._data[dstart:dstop] = data\n                else:\n                    self.__delitem__(key)\n                    self.insert(istart,data)\n            else: # we assume len(data) = 1\n                if dstop-dstart == 1:\n                    self._data[dstart:dstop] = data\n                else:\n                    self.__delitem__(key)\n                    self.insert(istart,data)\n\n        elif key is Ellipsis:\n            self.data[...] = data\n\n        elif isinstance(key, str):\n            self._data[key][:self._size] = data\n\n        else:\n            raise TypeError(""List assignment indices must be integers"")\n\n    def __delitem__(self, key):\n        """""" x.__delitem__(y) <==> del x[y] """"""\n\n        if not self._sizeable:\n            raise AttributeError(""List is not sizeable"")\n\n        # Deleting a single item\n        if isinstance(key, int):\n            if key < 0:\n                key += len(self)\n            if key < 0 or key > len(self):\n                raise IndexError(""List deletion index out of range"")\n            istart, istop = key, key + 1\n            dstart, dstop = self._items[key]\n\n        # Deleting several items\n        elif isinstance(key, slice):\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart, istop = istop, istart\n            if istart == istop:\n                return\n            dstart = self._items[istart][0]\n            dstop = self._items[istop - 1][1]\n\n        elif key is Ellipsis:\n            istart = 0\n            istop = len(self)\n            dstart = 0\n            dstop = self.size\n        # Error\n        else:\n            raise TypeError(""List deletion indices must be integers"")\n\n        # Remove data\n        size = self._size - (dstop - dstart)\n        self._data[\n            dstart:dstart + self._size - dstop] = self._data[dstop:self._size]\n        self._size -= dstop - dstart\n\n        # Remove corresponding items\n        size = self._count - istop\n        self._items[istart:istart + size] = self._items[istop:istop + size]\n\n        # Update other items\n        size = dstop - dstart\n        self._items[istart:istop + size + 1] -= size, size\n        self._count -= istop - istart\n\n\n    def insert(self, index, data, itemsize=None):\n        """""" Insert data before index\n\n        Parameters\n        ----------\n\n        index : int\n            Index before which data will be inserted.\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose succesive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        """"""\n\n        if not self._sizeable:\n            raise AttributeError(""List is not sizeable"")\n\n        if isinstance(data, (list, tuple)) and isinstance(data[0], (list, tuple)):\n            itemsize = [len(l) for l in data]\n            data = [item for sublist in data for item in sublist]\n\n        data = np.array(data, copy=False).ravel()\n        size = data.size\n\n        # Check item size and get item number\n        if itemsize is not None:\n            if isinstance(itemsize, int):\n                if (size % itemsize) != 0:\n                    raise ValueError(""Cannot partition data as requested"")\n                _count = size // itemsize\n                _itemsize = np.ones(_count, dtype=int) * (size // _count)\n            else:\n                _itemsize = np.array(itemsize, copy=False)\n                _count = len(itemsize)\n                if _itemsize.sum() != size:\n                    raise ValueError(""Cannot partition data as requested"")\n        else:\n            _count = 1\n\n        # Check if data array is big enough and resize it if necessary\n        if self._size + size >= self._data.size:\n            capacity = int(2 ** np.ceil(np.log2(self._size + size)))\n            self._data = np.resize(self._data, capacity)\n\n        # Check if item array is big enough and resize it if necessary\n        if self._count + _count >= len(self._items):\n            capacity = int(2 ** np.ceil(np.log2(self._count + _count)))\n            self._items = np.resize(self._items, (capacity, 2))\n\n        # Check index\n        if index < 0:\n            index += len(self)\n        if index < 0 or index > len(self):\n            raise IndexError(""List insertion index out of range"")\n\n        # Inserting\n        if index < self._count:\n            istart = index\n            dstart = self._items[istart][0]\n            dstop = self._items[istart][1]\n            # Move data\n            Z = self._data[dstart:self._size]\n            self._data[dstart + size:self._size + size] = Z\n            # Update moved items\n            I = self._items[istart:self._count] + size\n            self._items[istart + _count:self._count + _count] = I\n\n        # Appending\n        else:\n            dstart = self._size\n            istart = self._count\n\n        # Only one item (faster)\n        if _count == 1:\n            # Store data\n            self._data[dstart:dstart + size] = data\n            self._size += size\n            # Store data location (= item)\n            self._items[istart][0] = dstart\n            self._items[istart][1] = dstart + size\n            self._count += 1\n\n        # Several items\n        else:\n            # Store data\n            dstop = dstart + size\n            self._data[dstart:dstop] = data\n            self._size += size\n\n            # Store items\n            items = np.ones((_count, 2), int) * dstart\n            C = _itemsize.cumsum()\n            items[1:, 0] += C[:-1]\n            items[0:, 1] += C\n            istop = istart + _count\n            self._items[istart:istop] = items\n            self._count += _count\n\n\n    def append(self, data, itemsize=None):\n        """"""\n        Append data to the end.\n\n        Parameters\n        ----------\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose succesive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        """"""\n\n        self.insert(len(self), data, itemsize)\n\n\nif __name__ == \'__main__\':\n    L = ArrayList(dtype=int)\n    #L.append( (1,2,3), itemsize=1 )\n    #L[0] = 1,2,3\n    #L[1] = 1,2,3\n    #L[2] = 1,2,3\n    #print L\n\n    for i in range(10):\n        L.append(i)\n    print(L)\n    for i in range(10):\n        del L[0]\n\n    for i in range(10):\n        L.insert(0,i)\n    print(L)\n    for i in range(10):\n        del L[-1]\n'"
glumpy/graphics/collections/base_collection.py,33,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport math\nimport numpy as np\nfrom glumpy import gl\nfrom glumpy.gloo.texture import TextureFloat2D\nfrom glumpy.gloo.buffer import VertexBuffer, IndexBuffer\nfrom . util import dtype_reduce\nfrom . array_list import ArrayList\n\n\ndef next_power_of_2(n):\n    """""" Return next power of 2 greater than or equal to n """"""\n    n -= 1  # greater than OR EQUAL TO n\n    shift = 1\n    while (n+1) & n:  # n+1 is not a power of 2 yet\n        n |= n >> shift\n        shift *= 2\n    return max(4, n+1)\n\n\nclass BaseItem(object):\n    """"""\n    An item represent an object within a collection and is created on demand\n    when accessing a specific object of the collection.\n    """"""\n\n    def __init__(self, parent, key, vertices, indices, uniforms):\n        """"""\n        Create an item from an existing collection.\n\n        Parameters\n        ----------\n\n        parent : Collection\n            Collection this item belongs to\n\n        key : int\n            Collection index of this item\n\n        vertices: array-like\n            Vertices of the item\n\n        indices: array-like\n            Indices of the item\n\n        uniforms: array-like\n            Uniform parameters of the item\n        """"""\n\n        self._parent = parent\n        self._key = key\n        self._vertices = vertices\n        self._indices = indices\n        self._uniforms = uniforms\n\n    @property\n    def vertices(self):\n        return self._vertices\n\n    @vertices.setter\n    def vertices(self, data):\n        self._vertices[...] = np.array(data)\n\n    @property\n    def indices(self):\n        return self._indices\n\n    @indices.setter\n    def indices(self, data):\n        if self._indices is None:\n            raise ValueError(""Item has no indices"")\n        start = self._parent.vertices._items[self._key][0]\n        self._indices[...] = np.array(data) + start\n\n    @property\n    def uniforms(self):\n        return self._uniforms\n\n    @uniforms.setter\n    def uniforms(self, data):\n        if self._uniforms is None:\n            raise ValueError(""Item has no associated uniform"")\n        self._uniforms[...] = data\n\n    def __getitem__(self, key):\n        """""" Get a specific uniforms value """"""\n\n        if key in self._vertices.dtype.names:\n            return self._vertices[key]\n        elif key in self._uniforms.dtype.names:\n            return self._uniforms[key]\n        else:\n            raise IndexError(""Unknown key (\'%s\')"" % key)\n\n    def __setitem__(self, key, value):\n        """""" Set a specific uniforms value """"""\n\n        if key in self._vertices.dtype.names:\n            self._vertices[key] = value\n        elif key in self._uniforms.dtype.names:\n            self._uniforms[key] = value\n        else:\n            raise IndexError(""Unknown key"")\n\n    def __str__(self):\n        return ""BaseItem (%s, %s, %s)"" % (\n            self._vertices, self._indices, self._uniforms)\n\n\nclass BaseCollection(object):\n    """"""\n    A collection is a container for several (optionally indexed) objects having\n    the same vertex structure (vtype) and same uniforms type (utype). A\n    collection allows to manipulate objects individually and each object can\n    have its own set of uniforms provided they are a combination of floats\n    because they are internally stored into a texture can be retrieved from\n    within the shader using a specific code (fetchcode).\n\n    :param np.dtype vtype: Vertex type (mandatory)\n    :param np.dtype utype: Uniform type or None\n    :param np.dtype itype: Index type (np.uint32 or None)\n    """"""\n\n    def __init__(self, vtype, utype=None, itype=None):\n\n        # Vertices and type (mandatory)\n        self._vertices_list = None\n        self._vertices_buffer = None\n\n        # Vertex indices and type (optional)\n        self._indices_list = None\n        self._indices_buffer = None\n\n        # Uniforms and type (optional)\n        self._uniforms_list = None\n        self._uniforms_texture = None\n\n        # Make sure types are np.dtype (or None)\n        vtype = np.dtype(vtype) if vtype is not None else None\n        itype = np.dtype(itype) if itype is not None else None\n        utype = np.dtype(utype) if utype is not None else None\n\n        # Vertices type (mandatory)\n        # -------------------------\n        if vtype.names is None:\n            raise ValueError(""vtype must be a structured dtype"")\n\n        # Indices type (optional)\n        # -----------------------\n        if itype is not None:\n            if itype not in [np.uint8, np.uint16, np.uint32]:\n                raise ValueError(""itype must be unsigned integer or None"")\n            self._indices_list = ArrayList(dtype=itype)\n\n        # No program yet\n        self._programs = []\n\n        # Need to update buffers & texture\n        self._need_update = True\n\n        # Uniforms type (optional)\n        # -------------------------\n        if utype is not None:\n\n            if utype.names is None:\n                raise ValueError(""utype must be a structured dtype"")\n\n            # Convert types to lists (in case they were already dtypes) such\n            # that we can append new fields\n            vtype = eval(str(np.dtype(vtype)))\n            # We add a uniform index to access uniform data\n            vtype.append((\'collection_index\', \'f4\'))\n            vtype = np.dtype(vtype)\n\n            # Check utype is made of float32 only\n            utype = eval(str(np.dtype(utype)))\n            r_utype = dtype_reduce(utype)\n            if type(r_utype[0]) is not str or r_utype[2] != \'float32\':\n                raise RuntimeError(""utype cannot be reduced to float32 only"")\n\n            # Make utype divisible by 4\n            # count = ((r_utype[1]-1)//4+1)*4\n\n            # Make utype a power of two\n            count = next_power_of_2(r_utype[1])\n            if (count - r_utype[1]) > 0:\n                utype.append((\'__unused__\', \'f4\', count-r_utype[1]))\n\n            self._uniforms_list = ArrayList(dtype=utype)\n            self._uniforms_float_count = count\n\n            # Reserve some space in texture such that we have\n            # at least one full line\n            shape = self._compute_texture_shape(1)\n            self._uniforms_list.reserve(shape[1]/(count/4))\n\n        # Last since utype may add a new field in vtype (collecion_index)\n        self._vertices_list = ArrayList(dtype=vtype)\n\n        # Record all types\n        self._vtype = np.dtype(vtype)\n        self._itype = np.dtype(itype) if itype is not None else None\n        self._utype = np.dtype(utype) if utype is not None else None\n\n    def __len__(self):\n        """""" Size of the collection in terms of items """"""\n\n        return len(self._vertices_list)\n\n    @property\n    def vtype(self):\n        """""" Vertices dtype """"""\n\n        return self._vtype\n\n    @property\n    def itype(self):\n        """""" Indices dtype """"""\n\n        return self._itype\n\n    @property\n    def utype(self):\n        """""" Uniforms dtype """"""\n\n        return self._utype\n\n    def append(self, vertices, uniforms=None, indices=None, itemsize=None):\n        """"""\n        Parameters\n        ----------\n\n        vertices : numpy array\n            An array whose dtype is compatible with self.vdtype\n\n        uniforms: numpy array\n            An array whose dtype is compatible with self.utype\n\n        indices : numpy array\n            An array whose dtype is compatible with self.idtype\n            All index values must be between 0 and len(vertices)\n\n        itemsize: int, tuple or 1-D array\n            If ``itemsize`` is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If ``itemsize`` is 1-D array, the array will be divided into\n            elements whose succesive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        """"""\n\n        # Vertices\n        # -----------------------------\n        vertices = np.array(vertices).astype(self.vtype).ravel()\n        vsize = self._vertices_list.size\n\n        # No itemsize given\n        # -----------------\n        if itemsize is None:\n            index = 0\n            count = 1\n\n        # Uniform itemsize (int)\n        # ----------------------\n        elif isinstance(itemsize, int):\n            count = len(vertices)//itemsize\n            index = np.repeat(np.arange(count), itemsize)\n\n        # Individual itemsize (array)\n        # ---------------------------\n        elif isinstance(itemsize, (np.ndarray, list)):\n            count = len(itemsize)\n            index = np.repeat(np.arange(count), itemsize)\n        else:\n            raise ValueError(""Itemsize not understood"")\n\n        if self.utype:\n            vertices[""collection_index""] = index + len(self)\n        self._vertices_list.append(vertices, itemsize)\n\n        # Indices\n        # -----------------------------\n        if self.itype is not None:\n            # No indices given (-> automatic generation)\n            if indices is None:\n                indices = vsize + np.arange(len(vertices))\n                self._indices_list.append(indices, itemsize)\n\n            # Indices given\n            # FIXME: variables indices (list of list or ArrayList)\n            else:\n                if itemsize is None:\n                    I = np.array(indices) + vsize\n                elif isinstance(itemsize, int):\n                    I = vsize + (np.tile(indices, count) +\n                                 itemsize*np.repeat(np.arange(count),\n                                                    len(indices)))\n                else:\n                    raise ValueError(""Indices not compatible with items"")\n                self._indices_list.append(I, len(indices))\n\n        # Uniforms\n        # -----------------------------\n        if self.utype:\n            if uniforms is None:\n                uniforms = np.zeros(count, dtype=self.utype)\n            else:\n                uniforms = np.array(uniforms).astype(self.utype).ravel()\n            self._uniforms_list.append(uniforms, itemsize=1)\n\n        self._need_update = True\n\n    def __delitem__(self, index):\n        """""" x.__delitem__(y) <==> del x[y] """"""\n\n        # Deleting one item\n        if isinstance(index, int):\n            if index < 0:\n                index += len(self)\n            if index < 0 or index > len(self):\n                raise IndexError(""Collection deletion index out of range"")\n            istart, istop = index, index+1\n        # Deleting several items\n        elif isinstance(index, slice):\n            istart, istop, _ = index.indices(len(self))\n            if istart > istop:\n                istart, istop = istop, istart\n            if istart == istop:\n                return\n        # Deleting everything\n        elif index is Ellipsis:\n            istart, istop = 0, len(self)\n        # Error\n        else:\n            raise TypeError(""Collection deletion indices must be integers"")\n\n        vsize = len(self._vertices_list[index])\n        if self.itype is not None:\n            del self._indices_list[index]\n            self._indices_list[index:] -= vsize\n\n        if self.utype:\n            self._vertices_list[index:][""collection_index""] -= istop-istart\n        del self._vertices_list[index]\n\n        if self.utype is not None:\n            del self._uniforms_list[index]\n\n        self._need_update = True\n\n    def __getitem__(self, key):\n        """""" """"""\n\n        # WARNING\n        # Here we want to make sure to use buffers and texture (instead of\n        # lists) since only them are aware of any external modification.\n        if self._need_update:\n            self._update()\n\n        V = self._vertices_buffer\n        I = None\n        U = None\n        if self._indices_list is not None:\n            I = self._indices_buffer\n        if self._uniforms_list is not None:\n            U = self._uniforms_texture.ravel().view(self.utype)\n\n        # Getting a whole field\n        if isinstance(key, str):\n            # Getting a named field from vertices\n            if key in V.dtype.names:\n                return V[key]\n            # Getting a named field from uniforms\n            elif U is not None and key in U.dtype.names:\n                # Careful, U is the whole texture that can be bigger than list\n                # return U[key]\n                return U[key][:len(self._uniforms_list)]\n            else:\n                raise IndexError(""Unknonw field name (\'%s\')"" % key)\n\n        # Getting individual item\n        elif isinstance(key, int):\n            vstart, vend = self._vertices_list._items[key]\n            vertices = V[vstart:vend]\n            indices = None\n            uniforms = None\n            if I is not None:\n                istart, iend = self._indices_list._items[key]\n                indices = I[istart:iend]\n\n            if U is not None:\n                ustart, uend = self._uniforms_list._items[key]\n                uniforms = U[ustart:uend]\n\n            return BaseItem(self, key, vertices, indices, uniforms)\n\n        # Error\n        else:\n            raise IndexError(""Cannot get more than one item at once"")\n\n    def __setitem__(self, key, data):\n        """""" x.__setitem__(i, y) <==> x[i]=y """"""\n\n        if len(self._programs):\n            found = False\n            for program in self._programs:\n                if key in program.hooks:\n                    program[key] = data\n                    found = True\n            if found:\n                return\n\n        # WARNING\n        # Here we want to make sure to use buffers and texture (instead of\n        # lists) since only them are aware of any external modification.\n        if self._need_update:\n            self._update()\n\n        V = self._vertices_buffer\n        I = None\n        U = None\n        if self._indices_list is not None:\n            I = self._indices_buffer\n        if self._uniforms_list is not None:\n            U = self._uniforms_texture.ravel().view(self.utype)\n\n        # Setting a whole field\n        if isinstance(key, str):\n            # Setting a named field in vertices\n            if key in self.vtype.names:\n                V[key] = data\n            # Setting a named field in uniforms\n            elif self.utype and key in self.utype.names:\n                # Careful, U is the whole texture that can be bigger than list\n                # U[key] = data\n                U[key][:len(self._uniforms_list)] = data\n            else:\n                raise IndexError(""Unknonw field name (\'%s\')"" % key)\n\n        # # Setting individual item\n        # elif isinstance(key, int):\n        #     #vstart, vend = self._vertices_list._items[key]\n        #     #istart, iend = self._indices_list._items[key]\n        #     #ustart, uend = self._uniforms_list._items[key]\n        #     vertices, indices, uniforms = data\n        #     del self[key]\n        #     self.insert(key, vertices, indices, uniforms)\n\n        else:\n            raise IndexError(""Cannot set more than one item"")\n\n    def _compute_texture_shape(self, size=1):\n        """""" Compute uniform texture shape """"""\n\n        # We should use this line but we may not have a GL context yet\n        # linesize = gl.glGetInteger(gl.GL_MAX_TEXTURE_SIZE)\n        linesize = 1024\n        count = self._uniforms_float_count\n        cols = linesize // float(count/4)\n        rows = max(1, int(math.ceil(size/float(cols))))\n        shape = rows, cols*(count/4), count\n        self._ushape = shape\n        return shape\n\n    def _update(self):\n        """""" Update vertex buffers & texture """"""\n\n        if self._vertices_buffer is not None:\n            self._vertices_buffer._delete()\n        self._vertices_buffer = self._vertices_list.data.view(VertexBuffer)\n\n        if self.itype is not None:\n            if self._indices_buffer is not None:\n                self._indices_buffer._delete()\n            self._indices_buffer = self._indices_list.data.view(IndexBuffer)\n\n        if self.utype is not None:\n            if self._uniforms_texture is not None:\n                self._uniforms_texture._delete()\n\n            # We take the whole array (_data), not the data one\n            texture = self._uniforms_list._data.view(np.float32)\n            size = len(texture)/self._uniforms_float_count\n            shape = self._compute_texture_shape(size)\n\n            # shape[2] = float count is only used in vertex shader code\n            texture = texture.reshape(int(shape[0]), int(shape[1]), 4)\n            self._uniforms_texture = texture.view(TextureFloat2D)\n            self._uniforms_texture.interpolation = gl.GL_NEAREST\n\n        if len(self._programs):\n            for program in self._programs:\n                program.bind(self._vertices_buffer)\n                if self._uniforms_list is not None:\n                    program[""uniforms""] = self._uniforms_texture\n                    program[""uniforms_shape""] = self._ushape\n\n# -----------------------------------------------------------------------------\nif __name__ == \'__main__\':\n    vtype = [(\'value\', \'f4\', 2)]\n    utype = [(\'value_1\', \'f4\', 3),\n             (\'value_2\', \'f4\', 3)]\n    itype = np.uint32\n\n    C = BaseCollection(vtype, utype, itype)\n    V = np.zeros(3, dtype=vtype)\n    for i in range(50000):\n        C.append(V, indices=[0, 1, 2])\n\n    C = BaseCollection(vtype, utype, itype)\n    V = np.zeros(3*50000, dtype=vtype)\n    C.append(V, itemsize=3, indices=[0, 1, 2])\n\n    C = BaseCollection(vtype, utype, itype)\n    V = np.zeros(3*50000, dtype=vtype)\n    C.append(V, itemsize=3*np.ones(50000, dtype=int))\n\n    # C = BaseCollection(vtype, utype, itype)\n    # V = np.zeros(3,dtype=vtype)\n    # for i in range(5):\n    #     C.append(V,indices=[0,1,2])\n    #     V[""value""] += 1\n\n    # for i in range(5):\n    #     print C._vertices_list[""value""]\n    #     print C._vertices_list[""collection_index""]\n    #     print C._indices_list\n    #     del C[0]\n    #     print\n'"
glumpy/graphics/collections/collection.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nA collection is a container for several items having the same data\nstructure (dtype). Each data type can be declared as local (it specific to a\nvertex), shared (it is shared among an item vertices) or global (it is shared\nby all vertices). It is based on the BaseCollection but offers a more intuitive\ninterface.\n""""""\n\nimport os\nimport numpy as np\nfrom glumpy import gloo, gl, library\nfrom glumpy.gloo.program import Program\nfrom glumpy.transforms import Position, Viewport\nfrom . util import fetchcode\nfrom . base_collection import BaseCollection, BaseItem\n\n\n\nclass Collection(BaseCollection):\n    """"""\n    A collection is a container for several items having the same data\n    structure (dtype). Each data type can be declared as local (it is specific\n    to a vertex), shared (it is shared among item vertices) or global (it is\n    shared by all items). It is based on the BaseCollection but offers a more\n    intuitive interface.\n\n    Parameters\n    ----------\n\n    dtype: list\n        Data individual types as (name, dtype, scope, default)\n\n    itype: np.dtype or None\n        Indices data type\n\n    mode : GL_ENUM\n        GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP,\n        GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN\n\n    vertex: str or tuple of str\n       Vertex shader to use to draw this collection\n\n    fragment:  str or tuple of str\n       Fragment shader to use to draw this collection\n\n    kwargs: str\n        Scope can also be specified using keyword argument,\n        where parameter name must be one of the dtype.\n    """"""\n\n    _gtypes = { (\'float32\', 1) : ""float"",\n                (\'float32\', 2) : ""vec2"",\n                (\'float32\', 3) : ""vec3"",\n                (\'float32\', 4) : ""vec4"",\n                (\'int32\', 1)   : ""int"",\n                (\'int32\', 2)   : ""ivec2"",\n                (\'int32\', 3)   : ""ivec3"",\n                (\'int32\', 4)   : ""ivec4"" }\n\n    def __init__(self, dtype, itype, mode, vertex, fragment, geometry=None, **kwargs):\n        """"""\n        """"""\n\n        self._uniforms = {}\n        self._attributes = {}\n        self._varyings = {}\n        self._mode = mode\n        vtype = []\n        utype = []\n\n        # Build vtype and utype according to parameters\n        declarations = {""uniforms""   : """",\n                        ""attributes"" : """",\n                        ""varyings""   : """"}\n        defaults = {}\n        for item in dtype:\n            name, (basetype,count), scope, default = item\n            basetype = np.dtype(basetype).name\n            if scope[0] == ""!"":\n                scope = scope[1:]\n            else:\n                scope = kwargs.get(name, scope)\n            defaults[name] = default\n            gtype = Collection._gtypes[(basetype,count)]\n            if scope == ""local"":\n                vtype.append( (name, basetype, count) )\n                declarations[""attributes""] += ""attribute %s %s;\\n"" % (gtype, name)\n            elif scope == ""shared"":\n                utype.append( (name, basetype, count) )\n                declarations[""varyings""] += ""varying %s %s;\\n"" % (gtype, name)\n            else:\n                declarations[""uniforms""] += ""uniform %s %s;\\n"" % (gtype, name)\n                self._uniforms[name] = None\n\n        vtype = np.dtype(vtype)\n        itype = np.dtype(itype) if itype else None\n        utype = np.dtype(utype) if utype else None\n\n        BaseCollection.__init__(self, vtype=vtype, utype=utype, itype=itype)\n        self._declarations = declarations\n        self._defaults = defaults\n\n        # Build program (once base collection is built)\n        saved = library.get(vertex)\n        vertex = """"\n\n        if self.utype is not None:\n            vertex += fetchcode(self.utype) + vertex\n        else:\n            vertex += ""void fetch_uniforms(void) { }\\n"" + vertex\n        vertex += self._declarations[""uniforms""]\n        vertex += self._declarations[""attributes""]\n        vertex += saved\n\n        self._vertex = vertex\n        self._fragment = fragment\n\n        program = Program(vertex, fragment, geometry)\n        self._programs.append(program)\n\n        # Initialize uniforms\n        for name in self._uniforms.keys():\n            self._uniforms[name] = self._defaults.get(name)\n            program[name] = self._uniforms[name]\n\n\n\n    def view(self, transform, viewport=None):\n        """""" Return a view on the collection using provided transform """"""\n\n        return CollectionView(self, transform, viewport)\n\n        # program = gloo.Program(self._vertex, self._fragment)\n        # if ""transform"" in program.hooks:\n        #     program[""transform""] = transform\n        # if ""viewport"" in program.hooks:\n        #     if viewport is not None:\n        #         program[""viewport""] = viewport\n        #     else:\n        #         program[""viewport""] = Viewport()\n        # self._programs.append(program)\n        # program.bind(self._vertices_buffer)\n        # for name in self._uniforms.keys():\n        #     program[name] = self._uniforms[name]\n        # #if self._uniforms_list is not None:\n        # #    program[""uniforms""] = self._uniforms_texture\n        # #    program[""uniforms_shape""] = self._ushape\n\n        # # Piggy backing\n        # def draw():\n        #     if self._need_update:\n        #         self._update()\n        #         program.bind(self._vertices_buffer)\n        #         if self._uniforms_list is not None:\n        #             program[""uniforms""] = self._uniforms_texture\n        #             program[""uniforms_shape""] = self._ushape\n\n        #     if self._indices_list is not None:\n        #         Program.draw(program, self._mode, self._indices_buffer)\n        #     else:\n        #         Program.draw(program, self._mode)\n\n        # program.draw = draw\n        # return program\n\n\n\n    def __getitem__(self, key):\n\n        program = self._programs[0]\n        if key in program.hooks:\n            return program[key]\n\n        for (name,gtype) in program.all_uniforms:\n            if name == key:\n                return program[key]\n\n        return BaseCollection.__getitem__(self, key)\n\n\n    def __setitem__(self, key, value):\n\n        found = False\n        for program in self._programs:\n            for (name,gtype) in program.all_uniforms:\n                if name == key:\n                    found = True\n                    program[key] = value\n        if not found:\n            BaseCollection.__setitem__(self, key, value)\n\n\n    def draw(self, mode = None):\n        """""" Draw collection """"""\n\n        if self._need_update:\n            self._update()\n\n        program = self._programs[0]\n\n        mode = mode or self._mode\n        if self._indices_list is not None:\n            program.draw(mode, self._indices_buffer)\n        else:\n            program.draw(mode)\n\n\n\nclass CollectionView(object):\n\n    def __init__(self, collection, transform=None, viewport=None):\n\n        vertex = collection._vertex\n        fragment = collection._fragment\n        program = gloo.Program(vertex, fragment)\n\n        if ""transform"" in program.hooks and transform is not None:\n            program[""transform""] = transform\n\n        if ""viewport"" in program.hooks and viewport is not None:\n            program[""viewport""] = viewport\n\n        program.bind(collection._vertices_buffer)\n        for name in collection._uniforms.keys():\n            program[name] = collection._uniforms[name]\n\n        collection._programs.append(program)\n        self._program = program\n        self._collection = collection\n\n\n    def __getitem__(self, key):\n        return self._program[key]\n\n\n    def __setitem__(self, key, value):\n        self._program[key] = value\n\n\n    def draw(self):\n\n        program = self._program\n        collection = self._collection\n        mode = collection._mode\n\n        if collection._need_update:\n            collection._update()\n            # self._program.bind(self._vertices_buffer)\n            if collection._uniforms_list is not None:\n                program[""uniforms""] = collection._uniforms_texture\n                program[""uniforms_shape""] = collection._ushape\n\n        if collection._indices_list is not None:\n            program.draw(mode, collection._indices_buffer)\n        else:\n            program.draw(mode)\n'"
glumpy/graphics/collections/glyph_collection.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . agg_glyph_collection import AggGlyphCollection\nfrom . sdf_glyph_collection import SDFGlyphCollection\n\n\ndef GlyphCollection(mode=""sdf"", *args, **kwargs):\n    """"""\n    mode: string\n      - ""sdf""   (speed: fast,      size: small, output: decent)\n      - ""agg""   (speed: fasteest,  size: big    output: perfect)\n    """"""\n\n    if mode == ""agg"":\n        return AggGlyphCollection(*args, **kwargs)\n    return SDFGlyphCollection(*args, **kwargs)\n'"
glumpy/graphics/collections/marker_collection.py,11,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAntigrain Geometry Marker collection.\n\nThis collection provides antialiased and accurate markers with a unique type.\n""""""\nimport numpy as np\nfrom glumpy import gl, library\nfrom . collection import Collection\nfrom glumpy.transforms import Position, Viewport\n\n\nclass MarkerCollection(Collection):\n    """"""\n    Antigrain Geometry Marker collection.\n\n    This collection provides antialiased and accurate markers with a unique\n    type.\n    """"""\n\n    def __init__(self, marker=\'heart\', user_dtype=None, transform=None,\n                 viewport=None, vertex=None, fragment=None, **kwargs):\n        """"""\n        Initialize the collection.\n\n        Parameters\n        ----------\n\n        user_dtype: list\n            The base dtype can be completed (appended) by the user_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform: glumpy.Tranforms\n            The default vertex shader apply the supplied transform to the\n            vertices positions before computing the actual vertices positions\n            for path thickness. Note that it is necessary to add the\n            glumpy.transforms.Viewport transform at the end of the supplied transform.\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        size : string\n            \'local\', \'shared\' or \'global\'\n\n        orientation : string\n            \'local\', \'shared\' or \'global\'\n\n        fg_color : string\n            \'local\', \'shared\' or \'global\'\n\n        bg_color : string\n            \'local\', \'shared\' or \'global\'\n\n        linewidth : string\n            \'local\', \'shared\' or \'global\'\n\n        antialias : string\n            \'local\', \'shared\' or \'global\'\n        """"""\n\n        base_dtype = [ (\'position\',    (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'size\',        (np.float32, 1), \'local\', 1),\n                       (\'marker\',      (np.float32, 1), \'local\', 1),\n                       (\'orientation\', (np.float32, 1), \'local\', 0.0),\n                       (\'fg_color\',    (np.float32, 4), \'local\', (0,0,0,1)),\n                       (\'bg_color\',    (np.float32, 4), \'local\', (1,1,1,1)),\n                       (\'linewidth\',   (np.float32, 1), \'global\', 1.0),\n                       (\'antialias\',   (np.float32, 1), \'global\', 1.0) ]\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = library.get(\'collections/marker.vert\')\n        if fragment is None:\n            fragment = library.get(\'collections/marker.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode=gl.GL_POINTS,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        if ""transform"" in program.hooks:\n            if transform is not None:\n                program[""transform""] = transform\n            else:\n                program[""transform""] = Position()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n        program[""marker""] = marker\n        program[""paint""] = ""outline""\n\n\n    def append(self, P, itemsize = None, **kwargs):\n        """"""\n        Append a new set of markers the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        itemsize: int or None\n            Size of an individual path\n\n        size: list, array or float\n            Marker size\n\n        fg_color : list, array or 4-tuple\n           Path color\n\n        bg_color : list, array or 4-tuple\n           Path color\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        """"""\n\n        itemsize  = itemsize or 1\n        itemcount = len(P)//itemsize\n\n        V = np.empty(itemcount*itemsize, dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in [\'collection_index\', \'position\']:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[""position""] = P\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U, itemsize=itemsize)\n'"
glumpy/graphics/collections/path_collection.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . raw_path_collection import RawPathCollection\nfrom . agg_path_collection import AggPathCollection\nfrom . agg_fast_path_collection import AggFastPathCollection\n#from agg_dash_path_collection  import AggDashPathCollection\n\n\ndef PathCollection(mode=""agg"", *args, **kwargs):\n    """"""\n    mode: string\n      - ""raw""   (speed: fastest, size: small,   output: ugly, no dash, no thickness)\n      - ""agg""   (speed: medium,  size: medium   output: nice, some flaws, no dash)\n      - ""agg+""  (speed: slow,    size: big,     output: perfect, no dash)\n      - ""agg++"" (speed: slowest, size: biggest  output: perfect)\n    """"""\n\n    if mode == ""raw"":\n        return RawPathCollection(*args, **kwargs)\n    elif mode == ""agg+"":\n        return AggPathCollection(*args, **kwargs)\n    #elif mode.lowercase == ""agg-dash"":\n    #    return AggDashPathCollection(*args, **kwargs)\n    return AggFastPathCollection(*args, **kwargs)\n'"
glumpy/graphics/collections/point_collection.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" """"""\nfrom . raw_point_collection import RawPointCollection\nfrom . agg_point_collection import AggPointCollection\n\n\ndef PointCollection(mode=""raw"", *args, **kwargs):\n    """"""\n    mode: string\n      - ""raw""  (speed: fastest, size: small,   output: ugly)\n      - ""agg""  (speed: fast,    size: small,   output: beautiful)\n    """"""\n\n    if mode == ""raw"":\n        return RawPointCollection(*args, **kwargs)\n    return AggPointCollection(*args, **kwargs)\n'"
glumpy/graphics/collections/polygon_collection.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" """"""\nfrom .raw_polygon_collection import RawPolygonCollection\n#from .agg_polygon_collection import AggPolygonCollection\n#from .agg_fast_polygon_collection import AggPolygonCollection\n\n\ndef PolygonCollection(mode=""raw"", *args, **kwargs):\n    """"""\n    mode: string\n      - ""raw""   (speed: fastest, size: small,   output: ugly, no dash, no thickness)\n      - ""agg""   (speed: medium,  size: medium   output: nice, some flaws, no dash)\n      - ""agg+""  (speed: slow,    size: big,     output: perfect, no dash)\n    """"""\n\n    #if mode == ""raw"":\n    return RawPolygonCollection(*args, **kwargs)\n    #elif mode == ""agg"":\n    #    return AggFastPolygonCollection(*args, **kwargs)\n    #return AggPolygonCollection(*args, **kwargs)\n'"
glumpy/graphics/collections/raw_path_collection.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import gl, library\nfrom glumpy.transforms import Position, Viewport\nfrom  . collection import Collection\n\n\nclass RawPathCollection(Collection):\n    """"""\n    """"""\n\n    def __init__(self, user_dtype=None, transform=None, viewport=None,\n                 vertex = None, fragment = None, **kwargs):\n\n        """"""\n        Initialize the collection.\n\n        Parameters\n        ----------\n\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        viewport: glumpy.Transforms\n            The viewport to use to render the collection\n\n        transform: glumpy.Tranforms\n            The default vertex shader apply the supplied transform to the\n            vertices positions before computing the actual vertices positions\n            for path thickness. Note that it is necessary to add the\n            glumpy.transforms.Viewport transform at the end of the supplied transform.\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            \'local\', \'shared\' or \'global\'\n        """"""\n\n        base_dtype = [(\'position\', (np.float32, 3), \'!local\', (0,0,0)),\n                      (\'id\',       (np.float32, 1), \'!local\', 0),\n                      (\'color\',    (np.float32, 4), \'local\', (0,0,0,1)) ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = library.get(\'collections/raw-path.vert\')\n        if fragment is None:\n            fragment = library.get(\'collections/raw-path.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode=gl.GL_LINE_STRIP,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        if ""transform"" in program.hooks:\n            if transform is not None:\n                program[""transform""] = transform\n            else:\n                program[""transform""] = Position()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n\n\n    def append(self, P, closed=False, itemsize=None, **kwargs):\n        """"""\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        """"""\n\n        itemsize  = itemsize or len(P)\n        itemcount = len(P)//itemsize\n        P = P.reshape(itemcount,itemsize,3)\n        if closed:\n            V = np.empty((itemcount,itemsize+3), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in [\'collection_index\', \'position\']:\n                    V[name][1:-2] = kwargs.get(name, self._defaults[name])\n            V[""position""][:,1:-2] = P\n            V[""position""][:,  -2] = V[""position""][:,1]\n        else:\n            V = np.empty((itemcount,itemsize+2), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in [\'collection_index\', \'position\']:\n                    V[name][1:-1] = kwargs.get(name, self._defaults[name])\n            V[""position""][:,1:-1] = P\n        V[""id""] = 1\n        V[:, 0] = V[:, 1]\n        V[:,-1] = V[:,-2]\n        V[""id""][:, 0] = 0\n        V[""id""][:,-1] = 0\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                                itemsize=itemsize+2+closed)\n'"
glumpy/graphics/collections/raw_point_collection.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nRaw Point Collection\n\nThis collection provides very fast points. Output quality is ugly so it must be\nused at small size only (2/3 pixels). You\'ve been warned.\n""""""\n\nimport numpy as np\nfrom glumpy import gl, library\nfrom . collection import Collection\nfrom glumpy.transforms import Position, Viewport\n\n\nclass RawPointCollection(Collection):\n    """"""\n    Raw Point Collection\n\n    This collection provides very fast points. Output quality is ugly so it\n    must be used at small size only (2/3 pixels). You\'ve been warned.\n    """"""\n\n    def __init__(self, user_dtype=None, transform=None, viewport=None,\n                 vertex=None, fragment=None, **kwargs):\n        """"""\n        Initialize the collection.\n\n        Parameters\n        ----------\n\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        viewport: glumpy.Transforms\n            The viewport to use to render the collection\n\n        transform: glumpy.Tranforms\n            The default vertex shader apply the supplied transform to the\n            vertices positions before computing the actual vertices positions\n            for path thickness.\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            \'local\', \'shared\' or \'global\'\n        """"""\n        base_dtype = [ (\'position\', (np.float32, 3), ""!local"", (0,0,0)),\n                       (\'size\',     (np.float32, 1), ""global"", 3.0),\n                       (\'color\',    (np.float32, 4), ""global"", (0,0,0,1) ) ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = library.get(""collections/raw-point.vert"")\n        if fragment is None:\n            fragment= library.get(""collections/raw-point.frag"")\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode=gl.GL_POINTS,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n\n        if ""transform"" in program.hooks:\n            if transform is not None:\n                # FIXME: this line break things because snippet code will be included\n                #        and it messes with new snippet code\n                # program[""transform""] = Position()\n                program[""transform""] = transform\n            else:\n                program[""transform""] = Position()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                # FIXME: this line break things because snippet code will be included\n                #        and it messes with new snippet code\n                # program[""viewport""] = Viewport()\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n\n\n    def append(self, P, itemsize=None, **kwargs):\n        """"""\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        P : np.array\n            Vertices positions of the points(s) to be added\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        """"""\n\n        itemsize  = itemsize or 1\n        itemcount = len(P)//itemsize\n\n        V = np.empty(len(P), dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in [\'position\', ""collection_index""]:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[""position""] = P\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U, itemsize=itemsize)\n'"
glumpy/graphics/collections/raw_polygon_collection.py,10,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport triangle\n\nfrom glumpy import gl, library\nfrom glumpy.transforms import Position\nfrom . collection import Collection\n\n\ndef triangulate(vertices):\n    n = len(vertices)\n    vertices = np.array(vertices)\n    zmean = vertices[:,2].mean()\n    vertices_2d = vertices[:,:2]\n    segments = np.repeat(np.arange(n+1),2)[1:-1]\n    segments[-2:] = n-1,0\n    segments_2d = segments.reshape((-1, 2))\n    T = triangle.triangulate({\'vertices\': vertices_2d,\n                              \'segments\': segments_2d}, ""p"")\n    vertices_2d = T[""vertices""]\n    triangles   = T[""triangles""]\n    vertices = np.empty((len(vertices_2d),3))\n    vertices[:,:2] = vertices_2d\n    vertices[:,2] = zmean\n    return vertices, triangles\n\n\nclass RawPolygonCollection(Collection):\n\n    def __init__(self, user_dtype=None, transform=None, viewport=None,\n                 vertex = None, fragment = None, **kwargs):\n\n        base_dtype = [(\'position\', (np.float32, 3), \'!local\', (0,0,0)),\n                      (\'color\',    (np.float32, 4), \'local\',  (0,0,0,1)) ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = library.get(\'collections/raw-triangle.vert\')\n        if fragment is None:\n            fragment = library.get(\'collections/raw-triangle.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32, mode=gl.GL_TRIANGLES,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        if ""transform"" in program.hooks:\n            if transform is not None:\n                program[""transform""] = transform\n            else:\n                program[""transform""] = Position()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n\n\n    def append(self, points, **kwargs):\n        """"""\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        points : np.array\n            Vertices composing the triangles\n\n        color : list, array or 4-tuple\n           Path color\n        """"""\n\n        vertices, indices = triangulate(points)\n        itemsize  = len(vertices)\n        itemcount = 1\n\n        V = np.empty(itemcount*itemsize, dtype=self.vtype)\n        for name in self.vtype.names:\n            if name not in [\'collection_index\', \'position\']:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[""position""] = vertices\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        I = np.array(indices).ravel()\n        Collection.append(self, vertices=V, uniforms=U, indices=I,\n                                itemsize=itemsize)\n'"
glumpy/graphics/collections/raw_segment_collection.py,6,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nRaw Segment Collection\n\nThis collection provides fast raw (& ugly) line segments.\n""""""\nimport numpy as np\nfrom glumpy import gl, library\nfrom glumpy.transforms import Position\nfrom . collection import Collection\n\n\nclass RawSegmentCollection(Collection):\n    """"""\n    Raw Segment Collection\n\n    This collection provides fast raw (& ugly) line segments.\n    """"""\n\n    def __init__(self, user_dtype=None, transform=None,\n                 viewport=None, vertex=None, fragment=None, **kwargs):\n        """"""\n        Initialize the collection.\n\n        Parameters\n        ----------\n\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform: glumpy.Tranforms\n            The default vertex shader apply the supplied transform to the\n            vertices positions before computing the actual vertices positions\n            for path thickness. Note that it is necessary to add the\n            glumpy.transforms.Viewport transform at the end of the supplied transform.\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            \'local\', \'shared\' or \'global\'\n        """"""\n\n        base_dtype = [ (\'P\',     (np.float32, 3), \'!local\', (0,0,0)),\n                       (\'color\', (np.float32, 4), \'global\', (0,0,0,1)) ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = library.get(\'collections/raw-segment.vert\')\n        if fragment is None:\n            fragment = library.get(\'collections/raw-segment.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode=gl.GL_LINES,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        if ""transform"" in program.hooks:\n            if transform is not None:\n                program[""transform""] = transform\n            else:\n                program[""transform""] = Position()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n\n    def append(self, P0, P1, itemsize=None, **kwargs):\n        """"""\n        Append a new set of segments to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        """"""\n\n        itemsize  = itemsize or 1\n        itemcount = len(P0)/itemsize\n\n        V = np.empty(itemcount, dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in [\'collection_index\', \'P\']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        V = np.repeat(V,2,axis=0)\n        V[\'P\'][0::2] = P0\n        V[\'P\'][1::2] = P1\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U, itemsize=itemsize)\n'"
glumpy/graphics/collections/raw_triangle_collection.py,8,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom glumpy import gl, library\nfrom glumpy.transforms import Position\nfrom . collection import Collection\n\n\nclass RawTriangleCollection(Collection):\n    """"""\n    """"""\n\n    def __init__(self, user_dtype=None, transform=None, viewport=None,\n                 vertex = None, fragment = None, **kwargs):\n\n        base_dtype = [(\'position\', (np.float32, 3), \'!local\', (0,0,0)),\n                      (\'color\',    (np.float32, 4), \'local\', (0,0,0,1)) ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = library.get(\'collections/raw-triangle.vert\')\n        if fragment is None:\n            fragment = library.get(\'collections/raw-triangle.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32, mode=gl.GL_TRIANGLES,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        if ""transform"" in program.hooks:\n            if transform is not None:\n                program[""transform""] = transform\n            else:\n                program[""transform""] = Position()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n\n    def append(self, points, indices, **kwargs):\n        """"""\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        points : np.array\n            Vertices composing the triangles\n\n        indices : np.array\n            Indices describing triangles\n\n        color : list, array or 4-tuple\n           Path color\n        """"""\n\n        itemsize  = len(points)\n        itemcount = 1\n\n        V = np.empty(itemcount*itemsize, dtype=self.vtype)\n        for name in self.vtype.names:\n            if name not in [\'collection_index\', \'position\']:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[""position""] = points\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        I = np.array(indices).ravel()\n\n        Collection.append(self, vertices=V, uniforms=U, indices=I, itemsize=itemsize)\n'"
glumpy/graphics/collections/sdf_glyph_collection.py,11,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom . collection import Collection\nfrom glumpy import gl, data, library\nfrom glumpy.graphics.text import FontManager\nfrom glumpy.transforms import Position, Viewport\n\n\n\nclass SDFGlyphCollection(Collection):\n\n    def __init__(self, transform=None, viewport=None, **kwargs):\n        dtype = [(\'position\',  (np.float32, 2), \'!local\', (0,0)),\n                 (\'texcoord\',  (np.float32, 2), \'!local\', (0,0)),\n                 (\'origin\',    (np.float32, 3), \'shared\', (0,0,0)),\n                 (\'direction\', (np.float32, 3), \'shared\', (1,0,0)),\n                 (\'scale\',     (np.float32, 1), \'shared\', 0.005),\n                 (\'color\',     (np.float32, 4), \'shared\', (0,0,0,1))]\n\n        if ""vertex"" in kwargs.keys():\n            vertex = library.get(kwargs[""vertex""])\n            del kwargs[""vertex""]\n        else:\n            vertex = library.get(\'collections/sdf-glyph.vert\')\n\n        if ""fragment"" in kwargs.keys():\n            fragment = library.get(kwargs[""fragment""])\n            del kwargs[""fragment""]\n        else:\n            fragment = library.get(\'collections/sdf-glyph.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,\n                            mode = gl.GL_TRIANGLES,\n                            vertex=vertex, fragment=fragment)\n        program = self._programs[0]\n        if transform is not None:\n            program[""transform""] = transform\n#        else:\n#            program[""transform""] = Position()\n\n        if ""viewport"" in program.hooks:\n            if viewport is not None:\n                program[""viewport""] = viewport\n            else:\n                program[""viewport""] = Viewport()\n\n\n        manager = FontManager()\n        atlas = manager.atlas_sdf\n        self[\'u_kernel\'] = data.get(""spatial-filters.npy"")\n        self[\'atlas_data\'] = atlas\n        self[\'atlas_data\'].interpolation = gl.GL_LINEAR\n        self[\'atlas_shape\'] = atlas.shape[1], atlas.shape[0]\n\n\n    def append(self, text, font, anchor_x=\'center\', anchor_y=\'center\', **kwargs):\n        """"""\n        Append a new text to the collection\n\n        text : str\n            Text to be appended\n\n        font : glumpy.graphics.font.Font\n            Font to be used to render text\n\n        anchor_x : str\n            Text horizontal anchor (\'left\', \'center\', \'right\')\n\n        anchor_y : str\n            Text horizontal anchor (\'top\', \'center\', \'bottom\')\n        """"""\n\n        V, I = self.bake(text, font, anchor_x, anchor_y)\n\n        defaults = self._defaults\n        reserved = [""collection_index"", ""position"", ""texcoord""]\n        for name in self.vtype.names:\n            if name not in reserved:\n                if name in kwargs.keys() or name in defaults.keys():\n                    V[name] = kwargs.get(name, defaults[name])\n\n        if self.utype:\n            U = np.zeros(1, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    if name in kwargs.keys() or name in defaults.keys():\n                        U[name] = kwargs.get(name, defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, indices=I ,uniforms=U)\n\n\n    def bake(self, text, font, anchor_x=\'center\', anchor_y=\'center\'):\n        """""" Bake a text string to be added in the collection """"""\n\n        n = len(text) - text.count(\'\\n\')\n        indices = np.zeros((n,6), dtype=self.itype)\n        vertices = np.zeros((n,4), dtype=self.vtype)\n\n        # Current line start index\n        start = 0\n        # Pen position\n        pen = [0,0]\n        # Previous glyph\n        prev = None\n        # Lines (as start/end index and width (pixels)\n        lines = []\n        # Maximum text width and total height\n        text_width, text_height = 0, 0\n\n        index = 0\n        for charcode in text:\n\n            # Line feed\n            if charcode == \'\\n\':\n                prev = None\n                lines.append( ((start, index), pen[0]) )\n                start = index\n                text_width = max(text_width,pen[0])\n                pen[1] -= font.height\n                pen[0] = 0\n                # Actual glyph\n            else:\n                glyph = font[charcode]\n                kerning = glyph.get_kerning(prev)\n                x0 = pen[0] + glyph.offset[0] + kerning\n                y0 = pen[1] + glyph.offset[1]\n                x1 = x0 + glyph.shape[1]\n                y1 = y0 - glyph.shape[0]\n                u0, v0, u1, v1 = glyph.texcoords\n                vertices[index][\'position\'] = (x0,y0),(x0,y1),(x1,y1),(x1,y0)\n                vertices[index][\'texcoord\'] = (u0,v0),(u0,v1),(u1,v1),(u1,v0)\n                indices[index] = index*4\n                indices[index] += np.array([0,1,2,0,2,3], dtype=np.uint32)\n                pen[0] = pen[0]+glyph.advance[0] + kerning\n                pen[1] = pen[1]+glyph.advance[1]\n                prev = charcode\n                index += 1\n\n        lines.append( ((start, index+1), pen[0]) )\n        text_height = (len(lines)-1)*font.height\n        text_width = max(text_width,pen[0])\n\n        # Adjusting each line\n        for ((start, end), width) in lines:\n            if anchor_x == \'right\':\n                dx = -width/1.0\n            elif anchor_x == \'center\':\n                dx = -width/2.0\n            else:\n                dx = 0\n            vertices[start:end][\'position\'] += dx,0\n\n        # Adjusting whole label\n        if anchor_y == \'top\':\n            dy = - (font.ascender + font.descender)\n        elif anchor_y == \'center\':\n            dy = (text_height - (font.descender + font.ascender))/2\n        elif anchor_y == \'bottom\':\n            dy = -font.descender + text_height\n        else:\n            dy = 0\n        vertices[\'position\'] += 0, dy\n\n        vertices = vertices.ravel()\n        indices  = indices.ravel()\n\n        return vertices, indices\n        # return vertices.view(VertexBuffer), indices.view(IndexBuffer)\n'"
glumpy/graphics/collections/segment_collection.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . raw_segment_collection import RawSegmentCollection\nfrom . agg_segment_collection import AggSegmentCollection\n\n\ndef SegmentCollection(mode=""agg-fast"", *args, **kwargs):\n    """"""\n    mode: string\n      - ""raw""      (speed: fastest, size: small,   output: ugly, no dash, no thickness)\n      - ""agg""      (speed: slower,  size: medium,  output: perfect, no dash)\n    """"""\n\n    if mode == ""raw"":\n        return RawSegmentCollection(*args, **kwargs)\n    return AggSegmentCollection(*args, **kwargs)\n'"
glumpy/graphics/collections/test_array_list.py,48,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport unittest\nimport numpy as np\nfrom . array_list import ArrayList\n\n\nclass ArrayListDefault(unittest.TestCase):\n\n    def test_init(self):\n        L = ArrayList()\n        assert L.dtype == float\n        assert len(L) == 0\n\n    def test_init_from_list(self):\n        L = ArrayList([[0], [1, 2], [3, 4, 5]])\n        assert L.dtype == int\n        assert len(L) == 3\n\n    def test_init_exception(self):\n        self.assertRaises(ValueError, ArrayList, [0, 1, 2, 3, 4], 3)\n        self.assertRaises(ValueError, ArrayList, [0, 1, 2, 3, 4], [1, 2, 3])\n\n    def test_datasize(self):\n        L = ArrayList([0, 1, 2, 3, 4, 5], [1, 2, 3])\n        assert L.size == 6\n\n    def test_itemsize(self):\n        L = ArrayList([0, 1, 2, 3, 4, 5], [1, 2, 3])\n        assert np.allclose(L.itemsize, [1, 2, 3])\n\n    def test_append_1(self):\n        L = ArrayList()\n        L.append(1)\n        assert L[0] == 1\n\n    def test_append_2(self):\n        L = ArrayList()\n        L.append(np.arange(10), 2)\n        assert len(L) == 5\n        assert np.allclose(L[4], [8, 9])\n\n    def test_append_3(self):\n        L = ArrayList()\n        L.append(np.arange(10), 1 + np.arange(4))\n        assert len(L) == 4\n        assert np.allclose(L[3], [6, 7, 8, 9])\n\n    def test_insert_1(self):\n        L = ArrayList()\n        L.append(1)\n        L.insert(0, 2)\n        assert len(L) == 2\n        assert L[0] == 2\n\n    def test_insert_2(self):\n        L = ArrayList()\n        L.append(1)\n        L.insert(0, np.arange(10), 2)\n        assert len(L) == 6\n        assert np.allclose(L[4], [8, 9])\n\n    def test_insert_3(self):\n        L = ArrayList()\n        L.append(1)\n        L.insert(0, np.arange(10), 1 + np.arange(4))\n        assert len(L) == 5\n        assert np.allclose(L[3], [6, 7, 8, 9])\n\n    def test_insert_4(self):\n        L = ArrayList()\n        L.append(1)\n        L.insert(-1, np.arange(10), 1 + np.arange(4))\n        assert len(L) == 5\n        assert np.allclose(L[3], [6, 7, 8, 9])\n\n    def test_insert_1(self):\n        L = ArrayList()\n        L.append(0)\n        L.append([[1,2],[3,4,5]])\n        assert len(L) == 3\n        assert np.allclose(L[1], [1,2])\n\n    # Test representation of the list\n    # -------------------------------\n    def test_str(self):\n        L = ArrayList([[0], [1, 2], [3, 4, 5], [6, 7, 8, 9]])\n        assert str(L) == \'[ [0] [1 2] [3 4 5] [6 7 8 9] ]\'\n\n    # Get item using negative index\n    # -----------------------------\n    def test_getitem_negative(self):\n        L = ArrayList(np.arange(10), 1)\n        assert L[-1] == 9\n\n    # Get item range using reversed range\n    # -----------------------------------\n    def test_getitem_reverse(self):\n        L = ArrayList(np.arange(10), 1)\n        assert np.allclose(L[-1:-2], [8])\n\n    # Get empty range\n    # ---------------\n    def test_getitem_empty(self):\n        L = ArrayList(np.arange(10), 1)\n        assert np.allclose(L[1:1], [])\n\n    # Get out of range item\n    # ---------------------\n    def test_getitem_exception(self):\n        L = ArrayList(np.arange(10), 1)\n        self.assertRaises(IndexError, L.__getitem__, -11)\n        self.assertRaises(TypeError, L.__getitem__, ())\n\n    # Get all items using ellipsis\n    # ----------------------------\n    def test_getitem_ellipsis(self):\n        L = ArrayList(np.arange(10), 1)\n        assert np.allclose(L[...], np.arange(10))\n\n    # Get item range using key\n    # -------------------------------\n    def test_getitem_key(self):\n        dtype = [(""x"", float, 1), (""y"", float, 1)]\n        data = np.zeros(3, dtype=dtype)\n        data[""x""] = 1\n        data[""y""] = 2\n        L = ArrayList(data, itemsize=1)\n        assert np.allclose(L[""x""], [1, 1, 1])\n\n    # Set all items using ellipsis\n    # ----------------------------\n    def test_setitem_ellipsis(self):\n        L = ArrayList(np.arange(10), 1)\n        L[...] = 0\n        assert np.allclose(L.data, np.zeros(10))\n\n    # Set a single item\n    # ------------------\n    def test_setitem(self):\n        L = ArrayList(np.arange(10), 1)\n        L[0] = 3\n        assert L[0] == 3\n\n    # Set a single item using negative index\n    # --------------------------------------\n    def test_setitem_negative(self):\n        L = ArrayList(np.arange(10), 1)\n        L[-1] = 0\n        assert L[9] == 0\n\n    # Set out of range item\n    # ---------------------\n    def test_setitem_exception(self):\n        L = ArrayList(np.arange(10), 1)\n        self.assertRaises(IndexError, L.__setitem__, -11, 0)\n        self.assertRaises(TypeError, L.__setitem__, (), 0)\n\n    # Set item range\n    # --------------\n    def test_setitem_range(self):\n        L = ArrayList(np.arange(10), 2)\n        L[:2] = [1, 2, 3, 4]\n        assert np.allclose(L[0], [1, 2])\n        assert np.allclose(L[1], [3, 4])\n\n    # Set item range using reversed range\n    # -----------------------------------\n    def test_setitem_reversed_range(self):\n        L = ArrayList(np.arange(10), 2)\n        L[2:0] = [11, 12, 13, 14]\n        assert np.allclose(L[0], [11, 12])\n        assert np.allclose(L[1], [13, 14])\n\n    # Set item range using null range\n    # -------------------------------\n    def test_setitem_empty_range(self):\n        L = ArrayList(np.arange(10), 2)\n        L[0:0] = []\n        assert np.allclose(L.data, np.arange(10))\n\n    # Set item range using key\n    # -------------------------------\n    def test_setitem_key(self):\n        dtype = [(""x"", float, 1), (""y"", float, 1)]\n        data = np.zeros(3, dtype=dtype)\n        data[""x""] = 1\n        data[""y""] = 2\n        L = ArrayList(data, itemsize=1)\n        assert L[0][""x""] == 1\n        assert L[0][""y""] == 2\n\n    # Delete one item\n    # ---------------\n    def test_delitem_single_item(self):\n        L = ArrayList([[1], [1, 2, 3], [4, 5]])\n        del L[0]\n        assert np.allclose(L[0], [1, 2, 3])\n        assert np.allclose(L[1], [4, 5])\n\n    # Delete last item\n    # ----------------\n    def test_delitem_last_item(self):\n        L = ArrayList([[1], [1, 2, 3], [4, 5]])\n        del L[-1]\n        assert np.allclose(L[0], [1])\n        assert np.allclose(L[1], [1, 2, 3])\n        assert np.allclose(L[-1], [1, 2, 3])\n\n    # Delete many items\n    # -----------------\n    def test_delitem_many_items(self):\n        L = ArrayList()\n        L.append(np.arange(10), 1)\n        del L[1:]\n        assert len(L) == 1\n        assert np.allclose(L[0], 0)\n\n    # Delete all items\n    # -----------------\n    def test_delitem_all_items(self):\n        L = ArrayList()\n        L.append(np.arange(10), 1)\n        del L[:]\n        assert len(L) == 0\n\n    # Delete all items\n    # -----------------\n    def test_delitem_all_items_2(self):\n        L = ArrayList()\n        L.append(np.arange(10), 1)\n        del L[...]\n        assert len(L) == 0\n\n    # Delitem exception\n    # ---------------------\n    def test_detitem_exception(self):\n        L = ArrayList(np.arange(10), 1)\n        self.assertRaises(TypeError, L.__delitem__, ())\n\n    # Sizeable property\n    # -----------------\n    def test_sizeable(self):\n        L = ArrayList(sizeable=False)\n        self.assertRaises(AttributeError, L.__delitem__, 0)\n        self.assertRaises(AttributeError, L.insert, 0, 0)\n\n    # Writeable property\n    # ------------------\n    def test_writeable(self):\n        L = ArrayList([1, 2, 3], writeable=False)\n        self.assertRaises(AttributeError, L.__setitem__, 0, 0)\n\n    # Data property\n    # -------------\n    def test_data(self):\n        data = np.empty(10)\n        L = ArrayList(data)\n        assert np.allclose(L.data, data)\n\n\n# -----------------------------------------------------------------------------\nif __name__ == ""__main__"":\n    unittest.main()\n'"
glumpy/graphics/collections/test_collection.py,14,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport unittest\nimport numpy as np\nfrom . collection import BaseCollection\n\nvtype = [(\'position\', \'f4\', 2)]\nutype = [(\'color\',    \'f4\', 3)]\nitype = np.uint32\n\nvertices = np.zeros(4, dtype=vtype)\nindices  = np.array([0,1,2,0,2,3], dtype=itype)\nuniforms = np.ones(1,dtype=utype)\n\n\nclass BaseCollectionDefault(unittest.TestCase):\n\n\n    def test_init(self):\n        C = BaseCollection(vtype,utype)\n        assert len(C) == 0\n\n    def test_append_one_item(self):\n        C = BaseCollection(vtype, utype, itype)\n        C.append(vertices, uniforms, indices)\n        C.append(vertices, uniforms, indices)\n        assert np.allclose( C[0].indices , indices )\n        assert np.allclose( C[1].indices , 4+indices )\n\n    def test_append_several_item_1(self):\n        C = BaseCollection(vtype, utype, itype)\n        C.append(np.zeros(40,dtype=vtype), uniforms, indices, itemsize=4)\n        assert len(C) == 10\n        for i in xrange(10):\n            assert np.allclose(C[i].indices, 4*i+indices)\n\n    def test_append_several_item_2(self):\n        C = BaseCollection(vtype, utype)\n        C.append(np.zeros(40, dtype=vtype),\n                 np.zeros(10, dtype=itype), itemsize=(4,1))\n        for i in xrange(10):\n            assert np.allclose(C[i].indices, 4*i)\n\n    def test_delete_one_item(self):\n        C = BaseCollection(vtype, utype)\n        C.append(vertices, indices, uniforms)\n        C.append(vertices, indices, uniforms)\n        del C[0]\n        assert np.allclose(C[0].indices , indices)\n\n    def test_delete_several_item(self):\n        C = BaseCollection(vtype, utype)\n        C.append(np.zeros(40, dtype=vtype), indices, uniforms, itemsize=4)\n        del C[:9]\n        assert np.allclose(C[0].indices , indices)\n\n\n# -----------------------------------------------------------------------------\nif __name__ == ""__main__"":\n    unittest.main()\n'"
glumpy/graphics/collections/triangle_collection.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" """"""\nfrom . raw_triangle_collection import RawTriangleCollection\n\n\ndef TriangleCollection(mode=""raw"", *args, **kwargs):\n    """"""\n    mode: string\n      - ""raw""  (speed: fastest, size: small,   output: ugly)\n      - ""agg""  (speed: fast,    size: small,   output: beautiful)\n    """"""\n\n    return RawTriangleCollection(*args, **kwargs)\n'"
glumpy/graphics/collections/unimarker_collection.py,9,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nUnimarker collection is a collection of markers of the same type.\n""""""\n\nimport os\nimport numpy as np\nfrom functools import reduce\nfrom glumpy import gl\nfrom glumpy.gloo.program import Program\nfrom . collection import Collection\n\n\n\nclass UnimarkerCollection(Collection):\n    def __init__(self, marker=\'cross\', **kwargs):\n\n        dtype = [ (\'position\',    (np.float32, 3), \'!local\', (0,0,0)),\n                  (\'size\',        (np.float32, 1), \'local\', 1),\n                  (\'orientation\', (np.float32, 1), \'local\', 0),\n                  (\'fg_color\',    (np.float32, 4), \'local\', (0,0,0,1)),\n                  (\'bg_color\',    (np.float32, 4), \'local\', (1,1,1,1)),\n                  (\'linewidth\',   (np.float32, 1), \'global\', 1.0),\n                  (\'antialias\',   (np.float32, 1), \'global\', 1.0) ]\n\n        vertex = get(\'collections/marker.vert\')\n        fragment = get(\'markers/marker-%s.frag\' % marker)\n        fragment += get(\'antialias/outline.frag\')\n        fragment += get(\'collections/marker.frag\')\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode=gl.GL_POINTS,\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n\n    def append(self, count, itemsize=1, **kwargs):\n        if count <= 0:\n            return\n\n        # defaults = MarkerCollection.defaults\n        V = np.zeros(count, dtype=self.vtype)\n        for name in self.vtype.names:\n            if name not in [""collection_index""]:\n                V[name] = kwargs.get(name, self._defaults[name])\n        if self.utype:\n            U = np.zeros(count, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [""__unused__""]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n        Collection.append(self, vertices=V, uniforms=U, itemsize=itemsize)\n'"
glumpy/graphics/collections/util.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n\n""""""\nimport numpy as np\nfrom operator import mul\nfrom functools import reduce\n\n\ndef dtype_reduce(dtype, level=0, depth=0):\n    """"""\n    Try to reduce dtype up to a given level when it is possible\n\n    dtype =  [ (\'vertex\',  [(\'x\', \'f4\'), (\'y\', \'f4\'), (\'z\', \'f4\')]),\n               (\'normal\',  [(\'x\', \'f4\'), (\'y\', \'f4\'), (\'z\', \'f4\')]),\n               (\'color\',   [(\'r\', \'f4\'), (\'g\', \'f4\'), (\'b\', \'f4\'), (\'a\', \'f4\')])]\n\n    level 0: [\'color,vertex,normal,\', 10, \'float32\']\n    level 1: [[\'color\', 4, \'float32\']\n              [\'normal\', 3, \'float32\']\n              [\'vertex\', 3, \'float32\']]\n    """"""\n    dtype = np.dtype(dtype)\n    fields = dtype.fields\n\n    # No fields\n    if fields is None:\n        if dtype.shape:\n            count = reduce(mul, dtype.shape)\n        else:\n            count = 1\n        size = dtype.itemsize/count\n        if dtype.subdtype:\n            name = str( dtype.subdtype[0] )\n        else:\n            name = str( dtype )\n        return [\'\', count, name]\n    else:\n        items = []\n        name = \'\'\n        # Get reduced fields\n        for key,value in fields.items():\n            l =  dtype_reduce(value[0], level, depth+1)\n            if type(l[0]) is str:\n                items.append( [key, l[1], l[2]] )\n            else:\n                items.append( l )\n            name += key+\',\'\n\n        # Check if we can reduce item list\n        ctype = None\n        count = 0\n        for i,item in enumerate(items):\n            # One item is a list, we cannot reduce\n            if type(item[0]) is not str:\n                return items\n            else:\n                if i==0:\n                    ctype = item[2]\n                    count += item[1]\n                else:\n                    if item[2] != ctype:\n                        return items\n                    count += item[1]\n        if depth >= level:\n            return [name, count, ctype]\n        else:\n            return items\n\n\ndef fetchcode(utype, prefix=""""):\n    """"""\n    Generate the GLSL code needed to retrieve fake uniform values from a texture.\n\n    uniforms : sampler2D\n        Texture to fetch uniforms from\n\n    uniforms_shape: vec3\n        Size of texture (width,height,count) where count is the number of float\n        to be fetched.\n\n    collection_index: float\n        Attribute giving the index of the uniforms to be fetched. This index\n       relates to the index in the uniform array from python side.\n    """"""\n\n    utype = np.dtype(utype)\n    _utype = dtype_reduce(utype, level=1)\n\n    header = """"""\nuniform   sampler2D uniforms;\nuniform   vec3      uniforms_shape;\nattribute float     collection_index;\n\n""""""\n\n    # Header generation (easy)\n    types = { 1 : \'float\', 2 : \'vec2 \', 3 : \'vec3 \',\n              4 : \'vec4 \', 9 : \'mat3 \', 16 : \'mat4 \'}\n    for name,count,_ in _utype:\n        if name != \'__unused__\':\n            header += ""varying %s %s%s;\\n"" % (types[count],prefix,name)\n\n    # Body generation (not so easy)\n    body = """"""\\nvoid fetch_uniforms() {\n    float rows   = uniforms_shape.x;\n    float cols   = uniforms_shape.y;\n    float count  = uniforms_shape.z;\n    float index  = collection_index;\n    int index_x  = int(mod(index, (floor(cols/(count/4.0))))) * int(count/4.0);\n    int index_y  = int(floor(index / (floor(cols/(count/4.0)))));\n    float size_x = cols - 1.0;\n    float size_y = rows - 1.0;\n    float ty     = 0.0;\n    if (size_y > 0.0)\n        ty = float(index_y)/size_y;\n    int i = index_x;\n    vec4 _uniform;\\n""""""\n\n\n    _utype = {name: count for name,count,_ in _utype}\n    store = 0\n    # Be very careful with utype name order (_utype.keys is wrong)\n    for name in utype.names:\n        if name == \'__unused__\':\n            continue\n        count, shift =_utype[name], 0\n        size = count\n        while count:\n            if store == 0:\n                body += ""\\n    _uniform = texture2D(uniforms, vec2(float(i++)/size_x,ty));\\n""\n                store = 4\n            if   store == 4: a = ""xyzw""\n            elif store == 3: a = ""yzw""\n            elif store == 2: a = ""zw""\n            elif store == 1: a = ""w""\n            if shift == 0:   b = ""xyzw""\n            elif shift == 1: b = ""yzw""\n            elif shift == 2: b = ""zw""\n            elif shift == 3: b = ""w""\n            i = min(min(len(b), count), len(a))\n            if size > 1:\n                body += ""    %s%s.%s = _uniform.%s;\\n"" % (prefix,name,b[:i],a[:i])\n            else:\n                body += ""    %s%s = _uniform.%s;\\n"" % (prefix,name,a[:i])\n            count -= i\n            shift += i\n            store -= i\n\n    body += """"""}\\n\\n""""""\n    return header + body\n\n\n# -----------------------------------------------------------------------------\nif __name__ == \'__main__\':\n    utype = [(\'color\',     \'f4\', 4),\n             (\'translate\', \'f4\', 2),\n             (\'scale\',     \'f4\', 1)]\n    utype =  [ (\'vertex\',  [(\'x\', \'f4\'), (\'y\', \'f4\'), (\'z\', \'f4\')]),\n               (\'normal\',  [(\'x\', \'f4\'), (\'y\', \'f4\'), (\'z\', \'f4\')]),\n               (\'color\',   [(\'r\', \'f4\'), (\'g\', \'f4\'), (\'b\', \'f4\'), (\'a\', \'f4\')])]\n\n    print(fetchcode(utype))\n'"
glumpy/graphics/color/__init__.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nA Color is represented using four normalized channels (red, green, blue and\nalpha). Alpha encodes the transparency of the color, with 0 being fully\ntransparent and 1 being fully opaque.\n\nA single color can be manipulated using the Color object while for sequence of\nseveral color, the Colors object is best.\n\nExample usage:\n--------------\n\ncolor = Color(""white"")\ncolors = Colors([""black"", ""gray"", ""white""])\n""""""\n\nfrom .colors import get\nfrom .color import Color, Colors\n'"
glumpy/graphics/color/color.py,18,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom . import colors as _colors\nfrom glumpy.log import log\n\n\nclass Color(object):\n    """"""\n    A Color represent a color using four normalized channels (red, green, blue\n    and alpha).  Alpha encodes the transparency of the color, with 0 being\n    fully transparent and 1 being fully opaque.\n\n    A color can be declared using several different formats:\n\n      color = Color()\n      color = Color( ""#123"", alpha=1)\n      color = Color( ""#123456"" )\n      color = Color( ""#123456ff"" )\n      color = Color( (1,1,1) )\n      color = Color( (1,1,1,1) )\n      color = Color( ""0.5"" )\n      color = Color( ""red"" )\n      color = Color( ""svg:aqua"" )\n      color = Color( ""material:red:500"")\n\n    Note\n    ----\n\n    You can directly affect a color into a numpy array knowing that depending\n    on the type of the array (integer or real), the copied value will be\n    unnormalized or normalized.\n\n    Z = np.zeros((1,4),dtype = int)\n    Z[0] = Color(""white"")\n    # Z[0] is 255,255,255,255\n\n    Z = np.zeros((1,4),dtype = float)\n    Z[0] = Color(""white)\n    # Z[0] is 1,1,1,1\n\n    """"""\n\n    def __init__(self, color=None, alpha=None):\n        """""" Color initialization\n\n        Parameters\n        ----------\n\n        color : str, tuple or ndarray\n           Color description\n\n        alpha : float\n           Alpha channel\n        """"""\n\n        if isinstance(color, np.ndarray):\n            self._rgba = np.clip(color,0,1)\n        else:\n            self._rgba = np.ones(4,dtype=np.float32)*(0,0,0,1)\n            self._rgba[...] = Color.parse(color, alpha)\n\n\n    @classmethod\n    def parse(cls, color, alpha ):\n        """""" Color parsing """"""\n\n        if color is None:\n            return\n\n        if isinstance(color, str):\n            # Named color\n            if color[0] != \'#\':\n                color = color.lower().strip()\n                color = color.replace(\' \',\'\')\n                color = color.replace(\'-\',\'\')\n                color = _colors.get(color)\n\n            if color[0] != \'#\':\n                log.warn(""Unknown color name : %s"" % color)\n                return 0,0,0,1\n\n            # Hexadecimal color\n            color = color[1:]\n            if len(color) == 3:\n                color += \'f\'\n            if len(color) == 4:\n                color = \'\'.join([color[i] for i in [0,0,1,1,2,2,3,3]])\n            if len(color) == 6:\n                color += \'ff\'\n            r,g,b,a = [c/255.0 for c in bytearray.fromhex(color)]\n            if alpha is not None:\n                a  = alpha\n            return r,g,b,a\n\n\n\n        # Tuple/list/array color\n        elif isinstance(color, (list, tuple, np.ndarray)):\n            color = np.clip(color, 0, 1)\n            if alpha is not None:\n                color[3] = alpha\n            return color\n\n        # Unknown format\n        else:\n            log.warn(""Unknown color format : %s"" % color)\n            return 0,0,0,1\n\n\n    def __array__(self, dtype):\n        """""" Array interface """"""\n\n        if np.issubdtype(dtype, np.integer):\n            return self.RGBA.astype(dtype)\n        else:\n            return self.rgba.astype(dtype)\n\n\n    def __int__(self):\n        """""" Integer code """"""\n\n        R,G,B,A = self.RGBA\n        return  A+256*(B+256*(G+256*R))\n\n\n    def hex(self):\n        """""" Hexadecimal representation of the color """"""\n\n        R,G,B,A = self.RGBA\n        h = hex(int(self))\n        return ""#"" + h[2:-1]\n\n\n    def __repr__(self):\n        """""" x.__repr__() <==> repr(x) """"""\n\n        r,g,b,a = self.rgba\n        return ""Color(%g,%g,%g,%g)"" % (r,g,b,a)\n\n\n    @property\n    def red(self):\n        """""" Normalized red channel """"""\n\n        return self._rgba[0]\n\n\n    @property\n    def green(self):\n        """""" Normalized green channel """"""\n\n        return self._rgba[1]\n\n\n    @property\n    def blue(self):\n        """""" Normalized blue channel """"""\n\n        return self._rgba[2]\n\n\n    @property\n    def alpha(self):\n        """""" Normalized alpha channel """"""\n\n        return self._rgba[3]\n\n\n    @property\n    def rgba(self):\n        """""" Normalized r,g,b,a channels """"""\n\n        return self._rgba\n\n    @property\n    def rgb(self):\n        """""" Normalized r,g,b channels """"""\n\n        return self._rgba[:3]\n\n    @property\n    def RGBA(self):\n        """""" r,g,b,a channels """"""\n\n        return np.round((self._rgba*255)).astype(int)\n\n\n    @property\n    def RGB(self):\n        """""" r,g,b,a channels """"""\n\n        return np.round((self._rgba[:3]*255)).astype(int)\n\n\n\nclass Colors(object):\n    """"""\n    Colors represent several color stacked into a numpy array. It it\n    initialized from either a list of color names (or values) or from the\n    number of colors.\n    """"""\n\n    def __init__(self, colors=[], count=0, alpha=None):\n        """""" Colors initialization\n\n        Parameters\n        ----------\n\n        colors : list\n            List of color names or values\n\n        count : int\n            Number of colors\n\n        alpha : float\n           Alpha channels\n        """"""\n\n        if isinstance(colors, str):\n            if colors[0] != \'#\':\n                colors = _colors.get(colors)\n            if isinstance(colors, str):\n                colors = [colors]\n\n        if len(colors) > 0:\n            n = len(colors)\n            self._data = np.zeros((n,4),dtype=np.float32)\n            for i in range(n):\n                self._data[i] = Color(colors[i]).rgba\n\n        elif count > 0:\n            self._data = np.zeros((count,4),dtype=np.float32)\n\n        else:\n            log.warn(""Colors must be declared with a list or a color count"")\n            self._data = np.zeros((1,4),dtype=np.float32)\n\n        if alpha is not None:\n            self._data[:,3] = alpha\n\n\n    def __len__(self):\n        """""" Number of colors """"""\n\n        return len(self._data)\n\n\n    def __getitem__(self, key):\n        """""" Access a specific color """"""\n\n        return Color(self._data[key])\n\n\n    def __setitem__(self, key, value):\n        """""" Set a specific color """"""\n\n        self._data[key] = Color.parse(value)\n\n\n    def __array__(self, dtype):\n        """""" Array interface """"""\n\n        if np.issubdtype(dtype, np.integer):\n            return self.RGBA.astype(dtype)\n        else:\n            return self.rgba.astype(dtype)\n\n\n    @property\n    def RGBA(self):\n        """""" r,g,b,a channels """"""\n\n        return np.round((self._data*255)).astype(int)\n\n\n    @property\n    def RGB(self):\n        """""" r,g,b channels """"""\n\n        return np.round((self._data[:,:3]*255)).astype(int)\n\n\n    @property\n    def rgba(self):\n        """""" Normalized r,g,b,a channels """"""\n\n        return self._data\n\n\n    @property\n    def rgb(self):\n        """""" Normalized r,g,b channels """"""\n\n        return self._data[:,:3]\n\n\n\n    @property\n    def red(self):\n        """""" Normalized red channels """"""\n\n        return self._rgba[:,0]\n\n\n    @property\n    def green(self):\n        """""" Normalized green channels """"""\n\n        return self._rgba[:,1]\n\n\n    @property\n    def blue(self):\n        """""" Normalized blue channels """"""\n\n        return self._rgba[:,2]\n\n\n    @property\n    def alpha(self):\n        """""" Normalized alpha channels """"""\n\n        return self._rgba[:,3]\n\n\n\n# -----------------------------------------------------------------------------\nif __name__ == \'__main__\':\n\n    #print Color(1,1,1,1)\n    print(Color(""material:red:50""))\n    print(Color(""material:red:50"").rgba)\n    print(Color(""material:red:50"").hsv)\n\n    print(Colors(""material:red:*"").rgba)\n    # print Colors(""material:red:*"").hsv\n\n    # colors = Colors([\'red\', \'lime\', \'blue\'])\n    # print colors.rgba\n    # print\n\n    # # Affects an integer array\n    # Z = np.zeros((3,4),dtype = int)\n    # Z[...] = color\n    # print Z\n    # print\n\n    # Z = np.zeros((3,4),dtype = int)\n    # Z[...] = colors\n    # print Z\n'"
glumpy/graphics/color/colors.py,0,"b'from collections import OrderedDict\n\ncolors = OrderedDict( {\n\n    # Colors from Material design by Google\n    # http://www.google.com/design/spec/material-design/introduction.html\n    ""material"" : {\n\n        ""red"":  OrderedDict([\n            (  ""50"" , ""#ffebee""),\n            ( ""100"" , ""#ffcdd2""),\n            ( ""200"" , ""#ef9a9a""),\n            ( ""300"" , ""#e57373""),\n            ( ""400"" , ""#ef5350""),\n            ( ""500"" , ""#f44336""),\n            ( ""600"" , ""#e53935""),\n            ( ""700"" , ""#d32f2f""),\n            ( ""800"" , ""#c62828""),\n            ( ""900"" , ""#b71c1c""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#ff8a80""),\n                (""200"" , ""#ff5252""),\n                (""400"" , ""#ff1744""),\n                (""700"" , ""#d50000"")]))]),\n\n        ""pink"" : OrderedDict([\n            (  ""50"" , ""#fce4ec""),\n            ( ""100"" , ""#f8bbd0""),\n            ( ""200"" , ""#f48fb1""),\n            ( ""300"" , ""#f06292""),\n            ( ""400"" , ""#ec407a""),\n            ( ""500"" , ""#e91e63""),\n            ( ""600"" , ""#d81b60""),\n            ( ""700"" , ""#c2185b""),\n            ( ""800"" , ""#ad1457""),\n            ( ""900"" , ""#880e4f""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#ff80ab""),\n                (""200"" , ""#ff4081""),\n                (""400"" , ""#f50057""),\n                (""700"" , ""#c51162"")]))]),\n\n        ""purple"" : OrderedDict([\n            (  ""50"" , ""#f3e5f5""),\n            ( ""100"" , ""#e1bee7""),\n            ( ""200"" , ""#ce93d8""),\n            ( ""300"" , ""#ba68c8""),\n            ( ""400"" , ""#ab47bc""),\n            ( ""500"" , ""#9c27b0""),\n            ( ""600"" , ""#8e24aa""),\n            ( ""700"" , ""#7b1fa2""),\n            ( ""800"" , ""#6a1b9a""),\n            ( ""900"" , ""#4a148c""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#ea80fc""),\n                (""200"" , ""#e040fb""),\n                (""400"" , ""#d500f9""),\n                (""700"" , ""#aa00ff"")]))]),\n\n        ""deeppurple"" :OrderedDict([\n            (  ""50"" , ""#ede7f6""),\n            ( ""100"" , ""#d1c4e9""),\n            ( ""200"" , ""#b39ddb""),\n            ( ""300"" , ""#9575cd""),\n            ( ""400"" , ""#7e57c2""),\n            ( ""500"" , ""#673ab7""),\n            ( ""600"" , ""#5e35b1""),\n            ( ""700"" , ""#512da8""),\n            ( ""800"" , ""#4527a0""),\n            ( ""900"" , ""#311b92""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#b388ff""),\n                (""200"" , ""#7c4dff""),\n                (""400"" , ""#651fff""),\n                (""700"" , ""#6200ea"")]))]),\n\n        ""indigo"" : OrderedDict([\n            (  ""50"" , ""#e8eaf6""),\n            ( ""100"" , ""#c5cae9""),\n            ( ""200"" , ""#9fa8da""),\n            ( ""300"" , ""#7986cb""),\n            ( ""400"" , ""#5c6bc0""),\n            ( ""500"" , ""#3f51b5""),\n            ( ""600"" , ""#3949ab""),\n            ( ""700"" , ""#303f9f""),\n            ( ""800"" , ""#283593""),\n            ( ""900"" , ""#1a237e""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#8c9eff""),\n                (""200"" , ""#536dfe""),\n                (""400"" , ""#3d5afe""),\n                (""700"" , ""#304ffe"")]))]),\n\n        ""blue"" : OrderedDict([\n            (  ""50"" , ""#e3f2fd""),\n            ( ""100"" , ""#bbdefb""),\n            ( ""200"" , ""#90caf9""),\n            ( ""300"" , ""#64b5f6""),\n            ( ""400"" , ""#42a5f5""),\n            ( ""500"" , ""#2196f3""),\n            ( ""600"" , ""#1e88e5""),\n            ( ""700"" , ""#1976d2""),\n            ( ""800"" , ""#1565c0""),\n            ( ""900"" , ""#0d47a1""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#82b1ff""),\n                (""200"" , ""#448aff""),\n                (""400"" , ""#2979ff""),\n                (""700"" , ""#2962ff"")]))]),\n\n        ""lightblue"" : OrderedDict( [\n            (  ""50"" , ""#e1f5fe""),\n            ( ""100"" , ""#b3e5fc""),\n            ( ""200"" , ""#81d4fa""),\n            ( ""300"" , ""#4fc3f7""),\n            ( ""400"" , ""#29b6f6""),\n            ( ""500"" , ""#03a9f4""),\n            ( ""600"" , ""#039be5""),\n            ( ""700"" , ""#0288d1""),\n            ( ""800"" , ""#0277bd""),\n            ( ""900"" , ""#01579b""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#80d8ff""),\n                (""200"" , ""#40c4ff""),\n                (""400"" , ""#00b0ff""),\n                (""700"" , ""#0091ea"")]))]),\n\n        ""cyan"" : OrderedDict([\n            (  ""50"" , ""#e0f7fa""),\n            ( ""100"" , ""#b2ebf2""),\n            ( ""200"" , ""#80deea""),\n            ( ""300"" , ""#4dd0e1""),\n            ( ""400"" , ""#26c6da""),\n            ( ""500"" , ""#00bcd4""),\n            ( ""600"" , ""#00acc1""),\n            ( ""700"" , ""#0097a7""),\n            ( ""800"" , ""#00838f""),\n            ( ""900"" , ""#006064""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#84ffff""),\n                (""200"" , ""#18ffff""),\n                (""400"" , ""#00e5ff""),\n                (""700"" , ""#00b8d4"")]))]),\n\n        ""teal"" : OrderedDict( [\n            (  ""50"" , ""#e0f2f1""),\n            ( ""100"" , ""#b2dfdb""),\n            ( ""200"" , ""#80cbc4""),\n            ( ""300"" , ""#4db6ac""),\n            ( ""400"" , ""#26a69a""),\n            ( ""500"" , ""#009688""),\n            ( ""600"" , ""#00897b""),\n            ( ""700"" , ""#00796b""),\n            ( ""800"" , ""#00695c""),\n            ( ""900"" , ""#004d40""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#a7ffeb""),\n                (""200"" , ""#64ffda""),\n                (""400"" , ""#1de9b6""),\n                (""700"" , ""#00bfa5"")]))]),\n\n        ""green"" : OrderedDict( [\n            (  ""50"" , ""#e8f5e9""),\n            ( ""100"" , ""#c8e6c9""),\n            ( ""200"" , ""#a5d6a7""),\n            ( ""300"" , ""#81c784""),\n            ( ""400"" , ""#66bb6a""),\n            ( ""500"" , ""#4caf50""),\n            ( ""600"" , ""#43a047""),\n            ( ""700"" , ""#388e3c""),\n            ( ""800"" , ""#2e7d32""),\n            ( ""900"" , ""#1b5e20""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#b9f6ca""),\n                (""200"" , ""#69f0ae""),\n                (""400"" , ""#00e676""),\n                (""700"" , ""#00c853"")]))]),\n\n        ""lightgreen"" :  OrderedDict([\n            (  ""50"" , ""#f1f8e9""),\n            ( ""100"" , ""#dcedc8""),\n            ( ""200"" , ""#c5e1a5""),\n            ( ""300"" , ""#aed581""),\n            ( ""400"" , ""#9ccc65""),\n            ( ""500"" , ""#8bc34a""),\n            ( ""600"" , ""#7cb342""),\n            ( ""700"" , ""#689f38""),\n            ( ""800"" , ""#558b2f""),\n            ( ""900"" , ""#33691e""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#ccff90""),\n                (""200"" , ""#b2ff59""),\n                (""400"" , ""#76ff03""),\n                (""700"" , ""#64dd17"")]))]),\n\n        ""lime"" : OrderedDict([\n            (  ""50"" , ""#f9fbe7""),\n            ( ""100"" , ""#f0f4c3""),\n            ( ""200"" , ""#e6ee9c""),\n            ( ""300"" , ""#dce775""),\n            ( ""400"" , ""#d4e157""),\n            ( ""500"" , ""#cddc39""),\n            ( ""600"" , ""#c0ca33""),\n            ( ""700"" , ""#afb42b""),\n            ( ""800"" , ""#9e9d24""),\n            ( ""900"" , ""#827717""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#f4ff81""),\n                (""200"" , ""#eeff41""),\n                (""400"" , ""#c6ff00""),\n                (""700"" , ""#aeea00"")]))]),\n\n        ""yellow"" : OrderedDict([\n            (  ""50"" , ""#fffde7""),\n            ( ""100"" , ""#fff9c4""),\n            ( ""200"" , ""#fff59d""),\n            ( ""300"" , ""#fff176""),\n            ( ""400"" , ""#ffee58""),\n            ( ""500"" , ""#ffeb3b""),\n            ( ""600"" , ""#fdd835""),\n            ( ""700"" , ""#fbc02d""),\n            ( ""800"" , ""#f9a825""),\n            ( ""900"" , ""#f57f17""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#ffff8d""),\n                (""200"" , ""#ffff00""),\n                (""400"" , ""#ffea00""),\n                (""700"" , ""#ffd600"")]))]),\n\n        ""amber"" : OrderedDict([\n            (  ""50"" , ""#fff8e1""),\n            ( ""100"" , ""#ffecb3""),\n            ( ""200"" , ""#ffe082""),\n            ( ""300"" , ""#ffd54f""),\n            ( ""400"" , ""#ffca28""),\n            ( ""500"" , ""#ffc107""),\n            ( ""600"" , ""#ffb300""),\n            ( ""700"" , ""#ffa000""),\n            ( ""800"" , ""#ff8f00""),\n            ( ""900"" , ""#ff6f00""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#ffe57f""),\n                (""200"" , ""#ffd740""),\n                (""400"" , ""#ffc400""),\n                (""700"" , ""#ffab00"")]))]),\n\n        ""orange"" : OrderedDict( [\n            (  ""50"" , ""#fff3e0""),\n            ( ""100"" , ""#ffe0b2""),\n            ( ""200"" , ""#ffcc80""),\n            ( ""300"" , ""#ffb74d""),\n            ( ""400"" , ""#ffa726""),\n            ( ""500"" , ""#ff9800""),\n            ( ""600"" , ""#fb8c00""),\n            ( ""700"" , ""#f57c00""),\n            ( ""800"" , ""#ef6c00""),\n            ( ""900"" , ""#e65100""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#ffd180""),\n                (""200"" , ""#ffab40""),\n                (""400"" , ""#ff9100""),\n                (""700"" , ""#ff6d00"")]))]),\n\n        ""deeporange"" : OrderedDict([\n            (  ""50"" , ""#fbe9e7""),\n            ( ""100"" , ""#ffccbc""),\n            ( ""200"" , ""#ffab91""),\n            ( ""300"" , ""#ff8a65""),\n            ( ""400"" , ""#ff7043""),\n            ( ""500"" , ""#ff5722""),\n            ( ""600"" , ""#f4511e""),\n            ( ""700"" , ""#e64a19""),\n            ( ""800"" , ""#d84315""),\n            ( ""900"" , ""#bf360c""),\n            ( ""accent"", OrderedDict([\n                (""100"" , ""#ff9e80""),\n                (""200"" , ""#ff6e40""),\n                (""400"" , ""#ff3d00""),\n                (""700"" , ""#dd2c00"")]))]),\n\n        ""brown"" : OrderedDict([\n            ( ""50"" , ""#efebe9""),\n            (""100"" , ""#d7ccc8""),\n            (""200"" , ""#bcaaa4""),\n            (""300"" , ""#a1887f""),\n            (""400"" , ""#8d6e63""),\n            (""500"" , ""#795548""),\n            (""600"" , ""#6d4c41""),\n            (""700"" , ""#5d4037""),\n            (""800"" , ""#4e342e""),\n            (""900"" , ""#3e2723"")]),\n\n        ""grey"" : OrderedDict( [\n            ("" 50"" , ""#fafafa""),\n            (""100"" , ""#f5f5f5""),\n            (""200"" , ""#eeeeee""),\n            (""300"" , ""#e0e0e0""),\n            (""400"" , ""#bdbdbd""),\n            (""500"" , ""#9e9e9e""),\n            (""600"" , ""#757575""),\n            (""700"" , ""#616161""),\n            (""800"" , ""#424242""),\n            (""900"" , ""#212121"")]),\n\n        ""bluegrey"" : OrderedDict([\n            ("" 50"" , ""#eceff1""),\n            (""100"" , ""#cfd8dc""),\n            (""200"" , ""#b0bec5""),\n            (""300"" , ""#90a4ae""),\n            (""400"" , ""#78909c""),\n            (""500"" , ""#607d8b""),\n            (""600"" , ""#546e7a""),\n            (""700"" , ""#455a64""),\n            (""800"" , ""#37474f""),\n            (""900"" , ""#263238"")]),\n\n        ""black"" : ""#000000"",\n        ""white"" : ""#ffffff"",\n    },\n\n    # Basic color keywords from W3C\n    # http://www.w3.org/TR/css3-color/#html4\n    ""web"" : {\n        ""black"":   ""#000000"",\n        ""silver"":  ""#c0c0c0"",\n        ""gray"":    ""#808080"",\n        ""white"":   ""#ffffff"",\n        ""maroon"":  ""#800000"",\n        ""red"":     ""#ff0000"",\n        ""purple"":  ""#800080"",\n        ""fuchsia"": ""#ff00ff"",\n        ""green"":   ""#008000"",\n        ""lime"":    ""#00ff00"",\n        ""olive"":   ""#808000"",\n        ""yellow"":  ""#ffff00"",\n        ""navy"":    ""#000080"",\n        ""blue"":    ""#0000ff"",\n        ""teal"":    ""#008080"",\n        ""aqua"":    ""#00ffff""\n    },\n\n\n    # SVG color keywords from W3C\n    # http://www.w3.org/TR/css3-color/#svg-color\n    ""svg"" : {\n        ""aliceblue"":            ""#f0f8ff"",\n        ""antiquewhite"":         ""#faebd7"",\n        ""aqua"":                 ""#00ffff"",\n        ""aquamarine"":           ""#7fffd4"",\n        ""azure"":                ""#f0ffff"",\n        ""beige"":                ""#f5f5dc"",\n        ""bisque"":               ""#ffe4c4"",\n        ""black"":                ""#000000"",\n        ""blanchedalmond"":       ""#ffebcd"",\n        ""blue"":                 ""#0000ff"",\n        ""blueviolet"":           ""#8a2be2"",\n        ""brown"":                ""#a52a2a"",\n        ""burlywood"":            ""#deb887"",\n        ""cadetblue"":            ""#5f9ea0"",\n        ""chartreuse"":           ""#7fff00"",\n        ""chocolate"":            ""#d2691e"",\n        ""coral"":                ""#ff7f50"",\n        ""cornflowerblue"":       ""#6495ed"",\n        ""cornsilk"":             ""#fff8dc"",\n        ""crimson"":              ""#dc143c"",\n        ""cyan"":                 ""#00ffff"",\n        ""darkblue"":             ""#00008b"",\n        ""darkcyan"":             ""#008b8b"",\n        ""darkgoldenrod"":        ""#b8860b"",\n        ""darkgray"":             ""#a9a9a9"",\n        ""darkgrey"":             ""#a9a9a9"",\n        ""darkgreen"":            ""#006400"",\n        ""darkkhaki"":            ""#bdb76b"",\n        ""darkmagenta"":          ""#8b008b"",\n        ""darkolivegreen"":       ""#556b2f"",\n        ""darkorange"":           ""#ff8c00"",\n        ""darkorchid"":           ""#9932cc"",\n        ""darkred"":              ""#8b0000"",\n        ""darksalmon"":           ""#e9967a"",\n        ""darkseagreen"":         ""#8fbc8f"",\n        ""darkslateblue"":        ""#483d8b"",\n        ""darkslategray"":        ""#2f4f4f"",\n        ""darkslategrey"":        ""#2f4f4f"",\n        ""darkturquoise"":        ""#00ced1"",\n        ""darkviolet"":           ""#9400d3"",\n        ""deeppink"":             ""#ff1493"",\n        ""deepskyblue"":          ""#00bfff"",\n        ""dimgray"":              ""#696969"",\n        ""dimgrey"":              ""#696969"",\n        ""dodgerblue"":           ""#1e90ff"",\n        ""firebrick"":            ""#b22222"",\n        ""floralwhite"":          ""#fffaf0"",\n        ""forestgreen"":          ""#228b22"",\n        ""fuchsia"":              ""#ff00ff"",\n        ""gainsboro"":            ""#dcdcdc"",\n        ""ghostwhite"":           ""#f8f8ff"",\n        ""gold"":                 ""#ffd700"",\n        ""goldenrod"":            ""#daa520"",\n        ""gray"":                 ""#808080"",\n        ""grey"":                 ""#808080"",\n        ""green"":                ""#008000"",\n        ""greenyellow"":          ""#adff2f"",\n        ""honeydew"":             ""#f0fff0"",\n        ""hotpink"":              ""#ff69b4"",\n        ""indianred"":            ""#cd5c5c"",\n        ""indigo"":               ""#4b0082"",\n        ""ivory"":                ""#fffff0"",\n        ""khaki"":                ""#f0e68c"",\n        ""lavender"":             ""#e6e6fa"",\n        ""lavenderblush"":        ""#fff0f5"",\n        ""lawngreen"":            ""#7cfc00"",\n        ""lemonchiffon"":         ""#fffacd"",\n        ""lightblue"":            ""#add8e6"",\n        ""lightcoral"":           ""#f08080"",\n        ""lightcyan"":            ""#e0ffff"",\n        ""lightgoldenrodyellow"": ""#fafad2"",\n        ""lightgray"":            ""#d3d3d3"",\n        ""lightgrey"":            ""#d3d3d3"",\n        ""lightgreen"":           ""#90ee90"",\n        ""lightpink"":            ""#ffb6c1"",\n        ""lightsalmon"":          ""#ffa07a"",\n        ""lightseagreen"":        ""#20b2aa"",\n        ""lightskyblue"":         ""#87cefa"",\n        ""lightslategray"":       ""#778899"",\n        ""lightslategrey"":       ""#778899"",\n        ""lightsteelblue"":       ""#b0c4de"",\n        ""lightyellow"":          ""#ffffe0"",\n        ""lime"":                 ""#00ff00"",\n        ""limegreen"":            ""#32cd32"",\n        ""linen"":                ""#faf0e6"",\n        ""magenta"":              ""#ff00ff"",\n        ""maroon"":               ""#800000"",\n        ""mediumaquamarine"":     ""#66cdaa"",\n        ""mediumblue"":           ""#0000cd"",\n        ""mediumorchid"":         ""#ba55d3"",\n        ""mediumpurple"":         ""#9370d8"",\n        ""mediumseagreen"":       ""#3cb371"",\n        ""mediumslateblue"":      ""#7b68ee"",\n        ""mediumspringgreen"":    ""#00fa9a"",\n        ""mediumturquoise"":      ""#48d1cc"",\n        ""mediumvioletred"":      ""#c71585"",\n        ""midnightblue"":         ""#191970"",\n        ""mintcream"":            ""#f5fffa"",\n        ""mistyrose"":            ""#ffe4e1"",\n        ""moccasin"":             ""#ffe4b5"",\n        ""navajowhite"":          ""#ffdead"",\n        ""navy"":                 ""#000080"",\n        ""oldlace"":              ""#fdf5e6"",\n        ""olive"":                ""#808000"",\n        ""olivedrab"":            ""#6b8e23"",\n        ""orange"":               ""#ffa500"",\n        ""orangered"":            ""#ff4500"",\n        ""orchid"":               ""#da70d6"",\n        ""palegoldenrod"":        ""#eee8aa"",\n        ""palegreen"":            ""#98fb98"",\n        ""paleturquoise"":        ""#afeeee"",\n        ""palevioletred"":        ""#d87093"",\n        ""papayawhip"":           ""#ffefd5"",\n        ""peachpuff"":            ""#ffdab9"",\n        ""peru"":                 ""#cd853f"",\n        ""pink"":                 ""#ffc0cb"",\n        ""plum"":                 ""#dda0dd"",\n        ""powderblue"":           ""#b0e0e6"",\n        ""purple"":               ""#800080"",\n        ""red"":                  ""#ff0000"",\n        ""rosybrown"":            ""#bc8f8f"",\n        ""royalblue"":            ""#4169e1"",\n        ""saddlebrown"":          ""#8b4513"",\n        ""salmon"":               ""#fa8072"",\n        ""sandybrown"":           ""#f4a460"",\n        ""seagreen"":             ""#2e8b57"",\n        ""seashell"":             ""#fff5ee"",\n        ""sienna"":               ""#a0522d"",\n        ""silver"":               ""#c0c0c0"",\n        ""skyblue"":              ""#87ceeb"",\n        ""slateblue"":            ""#6a5acd"",\n        ""slategray"":            ""#708090"",\n        ""slategrey"":            ""#708090"",\n        ""snow"":                 ""#fffafa"",\n        ""springgreen"":          ""#00ff7f"",\n        ""steelblue"":            ""#4682b4"",\n        ""tan"":                  ""#d2b48c"",\n        ""teal"":                 ""#008080"",\n        ""thistle"":              ""#d8bfd8"",\n        ""tomato"":               ""#ff6347"",\n        ""turquoise"":            ""#40e0d0"",\n        ""violet"":               ""#ee82ee"",\n        ""wheat"":                ""#f5deb3"",\n        ""white"":                ""#ffffff"",\n        ""whitesmoke"":           ""#f5f5f5"",\n        ""yellow"":               ""#ffff00"",\n        ""yellowgreen"":          ""#9acd32""\n    }\n} )\n\n\ndef get(name):\n    """"""\n    get(""white"")\n    get(""svg:white"")\n    get(""material:red:100"")\n    get(""material:red:accent:100"")\n    get(""material:red:*"")\n    """"""\n\n    def flatten(d):\n        values = []\n        if isinstance(d, dict):\n            for value in d.values():\n                values.extend(flatten(value))\n        else:\n            values.append(d)\n        return values\n\n    name = name.lower().strip()\n    name = name.replace(\' \',\'\')\n    name = name.replace(\'-\',\'\')\n\n    items = name.split("":"")\n    if len(items) == 1:\n        domain = colors[\'svg\']\n    elif len(items) == 2:\n        domain = colors[items[0]]\n        name = items[1]\n    elif len(items) == 3:\n        domain = colors[items[0]][items[1]]\n        name = items[2]\n    elif len(items) == 4:\n        domain = colors[items[0]][items[1]][items[2]]\n        name = items[3]\n\n    if name != \'*\':\n        return domain[name]\n    else:\n        return flatten(domain)\n'"
glumpy/graphics/svg/__init__.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom .svg import SVG\nfrom .path import Path\nfrom .base import namespace\nfrom xml.etree import ElementTree\n\ndef Document(filename):\n    tree = ElementTree.parse(filename)\n    root = tree.getroot()\n    if root.tag != namespace + \'svg\':\n        text = \'File ""%s"" does not seem to be a valid SVG file\' % filename\n        raise TypeError(text)\n    return SVG(root)\n'"
glumpy/graphics/svg/base.py,0,"b""# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nnamespace = '{http://www.w3.org/2000/svg}'\ndpi = 90\nunits = {\n    None: 1,           # Default unit (same as pixel)\n    'px': 1,           # px: pixel. Default SVG unit\n    'em': 10,          # 1 em = 10 px FIXME\n    'ex': 5,           # 1 ex =  5 px FIXME\n    'in': dpi,          # 1 in = 96 px\n    'cm': dpi / 2.54,   # 1 cm = 1/2.54 in\n    'mm': dpi / 25.4,   # 1 mm = 1/25.4 in\n    'pt': dpi / 72.0,   # 1 pt = 1/72 in\n    'pc': dpi / 6.0,    # 1 pc = 1/6 in\n    '%' :   1 / 100.0   # 1 percent\n}\n"""
glumpy/graphics/svg/color.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\n\n# See <http://www.w3.org/TR/SVG/types.html#ColorKeywords>\n_keyword_colors = {\n    ""aliceblue"":            (240, 248, 255),\n    ""antiquewhite"":         (250, 235, 215),\n    ""aqua"":                 (  0, 255, 255),\n    ""aquamarine"":           (127, 255, 212),\n    ""azure"":                (240, 255, 255),\n    ""beige"":                (245, 245, 220),\n    ""bisque"":               (255, 228, 196),\n    ""black"":                (  0,   0,   0),\n    ""blanchedalmond"":       (255, 235, 205),\n    ""blue"":                 (  0,   0, 255),\n    ""blueviolet"":           (138,  43, 226),\n    ""brown"":                (165,  42,  42),\n    ""burlywood"":            (222, 184, 135),\n    ""cadetblue"":            ( 95, 158, 160),\n    ""chartreuse"":           (127, 255,   0),\n    ""chocolate"":            (210, 105,  30),\n    ""coral"":                (255, 127,  80),\n    ""cornflowerblue"":       (100, 149, 237),\n    ""cornsilk"":             (255, 248, 220),\n    ""crimson"":              (220,  20,  60),\n    ""cyan"":                 (  0, 255, 255),\n    ""darkblue"":             (  0,   0, 139),\n    ""darkcyan"":             (  0, 139, 139),\n    ""darkgoldenrod"":        (184, 134,  11),\n    ""darkgray"":             (169, 169, 169),\n    ""darkgreen"":            (  0, 100,   0),\n    ""darkgrey"":             (169, 169, 169),\n    ""darkkhaki"":            (189, 183, 107),\n    ""darkmagenta"":          (139,   0, 139),\n    ""darkolivegreen"":       ( 85, 107,  47),\n    ""darkorange"":           (255, 140,   0),\n    ""darkorchid"":           (153,  50, 204),\n    ""darkred"":              (139,   0,   0),\n    ""darksalmon"":           (233, 150, 122),\n    ""darkseagreen"":         (143, 188, 143),\n    ""darkslateblue"":        ( 72,  61, 139),\n    ""darkslategray"":        ( 47,  79,  79),\n    ""darkslategrey"":        ( 47,  79,  79),\n    ""darkturquoise"":        (  0, 206, 209),\n    ""darkviolet"":           (148,   0, 211),\n    ""deeppink"":             (255,  20, 147),\n    ""deepskyblue"":          (  0, 191, 255),\n    ""dimgray"":              (105, 105, 105),\n    ""dimgrey"":              (105, 105, 105),\n    ""dodgerblue"":           ( 30, 144, 255),\n    ""firebrick"":            (178,  34,  34),\n    ""floralwhite"":          (255, 250, 240),\n    ""forestgreen"":          ( 34, 139,  34),\n    ""fuchsia"":              (255,   0, 255),\n    ""gainsboro"":            (220, 220, 220),\n    ""ghostwhite"":           (248, 248, 255),\n    ""gold"":                 (255, 215,   0),\n    ""goldenrod"":            (218, 165,  32),\n    ""gray"":                 (128, 128, 128),\n    ""grey"":                 (128, 128, 128),\n    ""green"":                (  0, 128,   0),\n    ""greenyellow"":          (173, 255,  47),\n    ""honeydew"":             (240, 255, 240),\n    ""hotpink"":              (255, 105, 180),\n    ""indianred"":            (205,  92,  92),\n    ""indigo"":               ( 75,   0, 130),\n    ""ivory"":                (255, 255, 240),\n    ""khaki"":                (240, 230, 140),\n    ""lavender"":             (230, 230, 250),\n    ""lavenderblush"":        (255, 240, 245),\n    ""lawngreen"":            (124, 252,   0),\n    ""lemonchiffon"":         (255, 250, 205),\n    ""lightblue"":            (173, 216, 230),\n    ""lightcoral"":           (240, 128, 128),\n    ""lightcyan"":            (224, 255, 255),\n    ""lightgoldenrodyellow"": (250, 250, 210),\n    ""lightgray"":            (211, 211, 211),\n    ""lightgreen"":           (144, 238, 144),\n    ""lightgrey"":            (211, 211, 211),\n    ""lightpink"":            (255, 182, 193),\n    ""lightsalmon"":          (255, 160, 122),\n    ""lightseagreen"":        ( 32, 178, 170),\n    ""lightskyblue"":         (135, 206, 250),\n    ""lightslategray"":       (119, 136, 153),\n    ""lightslategrey"":       (119, 136, 153),\n    ""lightsteelblue"":       (176, 196, 222),\n    ""lightyellow"":          (255, 255, 224),\n    ""lime"":                 (  0, 255,   0),\n    ""limegreen"":            ( 50, 205,  50),\n    ""linen"":                (250, 240, 230),\n    ""magenta"":              (255,   0, 255),\n    ""maroon"":               (128,   0,   0),\n    ""mediumaquamarine"":     (102, 205, 170),\n    ""mediumblue"":           (  0,   0, 205),\n    ""mediumorchid"":         (186,  85, 211),\n    ""mediumpurple"":         (147, 112, 219),\n    ""mediumseagreen"":       ( 60, 179, 113),\n    ""mediumslateblue"":      (123, 104, 238),\n    ""mediumspringgreen"":    (  0, 250, 154),\n    ""mediumturquoise"":      ( 72, 209, 204),\n    ""mediumvioletred"":      (199,  21, 133),\n    ""midnightblue"":         ( 25,  25, 112),\n    ""mintcream"":            (245, 255, 250),\n    ""mistyrose"":            (255, 228, 225),\n    ""moccasin"":             (255, 228, 181),\n    ""navajowhite"":          (255, 222, 173),\n    ""navy"":                 (  0,   0, 128),\n    ""oldlace"":              (253, 245, 230),\n    ""olive"":                (128, 128,   0),\n    ""olivedrab"":            (107, 142,  35),\n    ""orange"":               (255, 165,   0),\n    ""orangered"":            (255,  69,   0),\n    ""orchid"":               (218, 112, 214),\n    ""palegoldenrod"":        (238, 232, 170),\n    ""palegreen"":            (152, 251, 152),\n    ""paleturquoise"":        (175, 238, 238),\n    ""palevioletred"":        (219, 112, 147),\n    ""papayawhip"":           (255, 239, 213),\n    ""peachpuff"":            (255, 218, 185),\n    ""peru"":                 (205, 133,  63),\n    ""pink"":                 (255, 192, 203),\n    ""plum"":                 (221, 160, 221),\n    ""powderblue"":           (176, 224, 230),\n    ""purple"":               (128,   0, 128),\n    ""red"":                  (255,   0,   0),\n    ""rosybrown"":            (188, 143, 143),\n    ""royalblue"":            ( 65, 105, 225),\n    ""saddlebrown"":          (139,  69,  19),\n    ""salmon"":               (250, 128, 114),\n    ""sandybrown"":           (244, 164,  96),\n    ""seagreen"":             ( 46, 139,  87),\n    ""seashell"":             (255, 245, 238),\n    ""sienna"":               (160,  82,  45),\n    ""silver"":               (192, 192, 192),\n    ""skyblue"":              (135, 206, 235),\n    ""slateblue"":            (106,  90, 205),\n    ""slategray"":            (112, 128, 144),\n    ""slategrey"":            (112, 128, 144),\n    ""snow"":                 (255, 250, 250),\n    ""springgreen"":          (  0, 255, 127),\n    ""steelblue"":            ( 70, 130, 180),\n    ""tan"":                  (210, 180, 140),\n    ""teal"":                 (  0, 128, 128),\n    ""thistle"":              (216, 191, 216),\n    ""tomato"":               (255,  99,  71),\n    ""turquoise"":            ( 64, 224, 208),\n    ""violet"":               (238, 130, 238),\n    ""wheat"":                (245, 222, 179),\n    ""white"":                (255, 255, 255),\n    ""whitesmoke"":           (245, 245, 245),\n    ""yellow"":               (255, 255,   0),\n    ""yellowgreen"":          (154, 205,  50) }\n\n\nclass Color(object):\n\n    def __init__(self, content):\n\n        color = content.strip()\n        if color.startswith(""#""):\n            rgb = color[1:]\n            if len(rgb) == 3:\n                r,g,b = tuple(ord((c+c).decode(\'hex\')) for c in rgb)\n            else:\n                r,g,b = tuple(bytearray.fromhex(rgb))\n        elif color.startswith(""rgb(""):\n            rgb = color[4:-1]\n            r,g,b = [value.strip() for value in rgb.split(\',\')]\n            if    r.endswith(""%""): r = 255*int(r[:-1])//100\n            else: r = int(r)\n            if    g.endswith(""%""): g = 255*int(g[:-1])//100\n            else: g = int(r)\n            if    b.endswith(""%""): b = 255*int(b[:-1])//100\n            else: b = int(r)\n        elif color in _keyword_colors:\n            r,g,b = _keyword_colors[color]\n        else:\n            text = ""Unknown color (%s)"" % color\n            r,g,b = 0, 0, 0\n        self._rgb = r/255.,g/255.,b/255.\n\n\n    @property\n    def rgb(self):\n        r,g,b = self._rgb\n        return rgb\n\n    @property\n    def rgba(self):\n        r,g,b = self._rgb\n        return r,g,b,1\n\n\n    def __repr__(self):\n        r,g,b = self._rgb\n        r,g,b = int(r*255), int(g*255), int(b*255)\n        return ""#%02x%02x%02x"" % (r,g,b)\n'"
glumpy/graphics/svg/element.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport copy\nfrom .style import Style\n\nnamespace = \'{http://www.w3.org/2000/svg}\'\n\nclass Element(object):\n    """""" Generic SVG element """"""\n    def __init__(self, content=None, parent=None):\n        self._parent = parent\n        self._id = hex(id(self))\n        self._style = Style()\n        self._computed_style = Style()\n\n        if isinstance(content, str):\n            return\n\n        self._id = content.get(\'id\', self._id)\n        self._style.update(content.get(""style"",None))\n        self._computed_style = Style()\n        if parent and parent.style:\n            self._computed_style = copy.copy(parent.style)\n            self._computed_style.update(content.get(""style"",None))\n\n\n    @property\n    def root(self):\n        if self._parent:\n            return self._parent.root\n        return self\n\n    @property\n    def parent(self):\n        if self._parent:\n            return self._parent\n        return None\n\n    @property\n    def style(self):\n        return self._computed_style\n\n    @property\n    def viewport(self):\n        if self._parent:\n            return self._parent.viewport\n        return None\n'"
glumpy/graphics/svg/geometry.py,0,"b""# ----------------------------------------------------------------------------\n#  Anti-Grain Geometry (AGG) - Version 2.5\n#  A high quality rendering engine for C++\n#  Copyright (C) 2002-2006 Maxim Shemanarev\n#  Contact: mcseem@antigrain.com\n#           mcseemagg@yahoo.com\n#           http://antigrain.com\n#\n#  AGG is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  AGG is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with AGG; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n#  MA 02110-1301, USA.\n# ----------------------------------------------------------------------------\n#\n# Python translation by Nicolas P. Rougier\n# Copyright (C) 2013 Nicolas P. Rougier. All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY NICOLAS P. ROUGIER ''AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL NICOLAS P. ROUGIER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Nicolas P. Rougier.\n#\n# ----------------------------------------------------------------------------\nimport math\nimport numpy as np\n\ncurve_distance_epsilon        = 1e-30\ncurve_collinearity_epsilon    = 1e-30\ncurve_angle_tolerance_epsilon = 0.01\ncurve_recursion_limit         = 32\nm_cusp_limit                  = 0.0\nm_angle_tolerance             = 10*math.pi/180.0\nm_approximation_scale         = 2.0\nm_distance_tolerance_square   = (0.5 / m_approximation_scale)**2\nepsilon                       = 1e-10\n\n\ndef calc_sq_distance( x1,y1, x2,y2 ):\n    dx = x2-x1\n    dy = y2-y1\n    return dx * dx + dy * dy\n\n\n\ndef quadratic_recursive( points, x1, y1, x2, y2, x3, y3, level = 0 ):\n    if level > curve_recursion_limit:\n        return\n\n    # Calculate all the mid-points of the line segments\n    # -------------------------------------------------\n    x12  = (x1 + x2) / 2.\n    y12  = (y1 + y2) / 2.\n    x23  = (x2 + x3) / 2.\n    y23  = (y2 + y3) / 2.\n    x123 = (x12 + x23) / 2.\n    y123 = (y12 + y23) / 2.\n\n    dx = x3 - x1\n    dy = y3 - y1\n    d = math.fabs((x2-x3)*dy - (y2-y3)*dx)\n\n    if d > curve_collinearity_epsilon:\n        # Regular case\n        # ------------\n        if d*d <= m_distance_tolerance_square * (dx*dx + dy*dy):\n            # If the curvature doesn't exceed the distance_tolerance value\n            # we tend to finish subdivisions.\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append( (x123,y123) )\n                return\n\n            # Angle & Cusp Condition\n            da = math.fabs(math.atan2(y3 - y2, x3 - x2) - math.atan2(y2 - y1, x2 - x1))\n            if da >= math.pi:\n                da = 2*math.pi - da\n\n            if da < m_angle_tolerance:\n                # Finally we can stop the recursion\n                points.append( (x123,y123) )\n                return\n    else:\n        # Collinear case\n        # --------------\n        da = dx*dx + dy*dy\n        if da == 0:\n            d = calc_sq_distance(x1, y1, x2, y2)\n        else:\n            d = ((x2 - x1)*dx + (y2 - y1)*dy) / da\n            if d > 0 and d < 1:\n                # Simple collinear case, 1---2---3, we can leave just two endpoints\n                return\n            if(d <= 0):\n                d = calc_sq_distance(x2, y2, x1, y1)\n            elif d >= 1:\n                d = calc_sq_distance(x2, y2, x3, y3)\n            else:\n               d = calc_sq_distance(x2, y2, x1 + d*dx, y1 + d*dy)\n\n        if d < m_distance_tolerance_square:\n            points.append( (x2,y2) )\n            return\n\n    # Continue subdivision\n    # --------------------\n    quadratic_recursive( points, x1, y1, x12, y12, x123, y123, level + 1 )\n    quadratic_recursive( points, x123, y123, x23, y23, x3, y3, level + 1 )\n\n\n\ndef cubic_recursive( points, x1, y1, x2, y2, x3, y3, x4, y4, level=0):\n    if level > curve_recursion_limit:\n        return\n\n    # Calculate all the mid-points of the line segments\n    # -------------------------------------------------\n    x12   = (x1 + x2) / 2.\n    y12   = (y1 + y2) / 2.\n    x23   = (x2 + x3) / 2.\n    y23   = (y2 + y3) / 2.\n    x34   = (x3 + x4) / 2.\n    y34   = (y3 + y4) / 2.\n    x123  = (x12 + x23) / 2.\n    y123  = (y12 + y23) / 2.\n    x234  = (x23 + x34) / 2.\n    y234  = (y23 + y34) / 2.\n    x1234 = (x123 + x234) / 2.\n    y1234 = (y123 + y234) / 2.\n\n\n    # Try to approximate the full cubic curve by a single straight line\n    # -----------------------------------------------------------------\n    dx = x4 - x1\n    dy = y4 - y1\n    d2 = math.fabs(((x2 - x4) * dy - (y2 - y4) * dx))\n    d3 = math.fabs(((x3 - x4) * dy - (y3 - y4) * dx))\n\n    s =  int((d2 > curve_collinearity_epsilon) << 1) + int(d3 > curve_collinearity_epsilon)\n\n    if s == 0:\n        # All collinear OR p1==p4\n        # ----------------------\n        k = dx*dx + dy*dy\n        if k == 0:\n            d2 = calc_sq_distance(x1, y1, x2, y2)\n            d3 = calc_sq_distance(x4, y4, x3, y3)\n\n        else:\n            k   = 1. / k\n            da1 = x2 - x1\n            da2 = y2 - y1\n            d2  = k * (da1*dx + da2*dy)\n            da1 = x3 - x1\n            da2 = y3 - y1\n            d3  = k * (da1*dx + da2*dy)\n            if d2 > 0 and d2 < 1 and d3 > 0 and d3 < 1:\n                # Simple collinear case, 1---2---3---4\n                # We can leave just two endpoints\n                return\n\n            if d2 <= 0:\n                d2 = calc_sq_distance(x2, y2, x1, y1)\n            elif d2 >= 1:\n                d2 = calc_sq_distance(x2, y2, x4, y4)\n            else:\n                d2 = calc_sq_distance(x2, y2, x1 + d2*dx, y1 + d2*dy)\n\n            if d3 <= 0:\n                d3 = calc_sq_distance(x3, y3, x1, y1)\n            elif d3 >= 1:\n                d3 = calc_sq_distance(x3, y3, x4, y4)\n            else:\n                d3 = calc_sq_distance(x3, y3, x1 + d3*dx, y1 + d3*dy)\n\n        if d2 > d3:\n            if d2 < m_distance_tolerance_square:\n                points.append( (x2, y2) )\n                return\n        else:\n            if d3 < m_distance_tolerance_square:\n                points.append( (x3, y3) )\n                return\n\n    elif s == 1:\n        # p1,p2,p4 are collinear, p3 is significant\n        # -----------------------------------------\n        if d3 * d3 <= m_distance_tolerance_square * (dx*dx + dy*dy):\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x23, y23) )\n                return\n\n            # Angle Condition\n            # ---------------\n            da1 = math.fabs(math.atan2(y4 - y3, x4 - x3) - math.atan2(y3 - y2, x3 - x2))\n            if da1 >= math.pi:\n                da1 = 2*math.pi - da1\n\n            if da1 < m_angle_tolerance:\n                points.extend( [(x2, y2),(x3, y3)] )\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append( (x3, y3) )\n                    return\n\n    elif s == 2:\n        # p1,p3,p4 are collinear, p2 is significant\n        # -----------------------------------------\n        if d2 * d2 <= m_distance_tolerance_square * (dx*dx + dy*dy):\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append( (x23, y23) )\n                return\n\n            # Angle Condition\n            # ---------------\n            da1 = math.fabs(math.atan2(y3 - y2, x3 - x2) - math.atan2(y2 - y1, x2 - x1))\n            if da1 >= math.pi:\n                da1 = 2*math.pi - da1\n\n            if da1 < m_angle_tolerance:\n                points.extend( [(x2, y2),(x3, y3)] )\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append( (x2, y2) )\n                    return\n\n    elif s == 3:\n        # Regular case\n        # ------------\n        if (d2 + d3)*(d2 + d3) <= m_distance_tolerance_square * (dx*dx + dy*dy):\n            # If the curvature doesn't exceed the distance_tolerance value\n            # we tend to finish subdivisions.\n\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append( (x23, y23) )\n                return\n\n            # Angle & Cusp Condition\n            # ----------------------\n            k   = math.atan2(y3 - y2, x3 - x2)\n            da1 = math.fabs(k - math.atan2(y2 - y1, x2 - x1))\n            da2 = math.fabs(math.atan2(y4 - y3, x4 - x3) - k)\n            if da1 >= math.pi:\n                da1 = 2*math.pi - da1\n            if da2 >= math.pi:\n                da2 = 2*math.pi - da2\n\n            if da1 + da2 < m_angle_tolerance:\n                # Finally we can stop the recursion\n                # ---------------------------------\n                points.append( (x23, y23) )\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append( (x2, y2) )\n                    return\n\n                if da2 > m_cusp_limit:\n                    points.append( (x3, y3) )\n                    return\n\n    # Continue subdivision\n    # --------------------\n    cubic_recursive( points, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1 )\n    cubic_recursive( points, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1 )\n\n\n\ndef quadratic( p1, p2, p3 ):\n    x1,y1 = p1\n    x2,y2 = p2\n    x3,y3 = p3\n    points = []\n    quadratic_recursive( points, x1,y1, x2,y2, x3,y3 )\n\n    dx,dy = points[0][0]-x1, points[0][1]-y1\n    if (dx*dx+dy*dy) > epsilon: points.insert(0, (x1,y1) )\n\n    dx,dy = points[-1][0]-x3, points[-1][1]-y3\n    if (dx*dx+dy*dy) > epsilon: points.append( (x3,y3) )\n\n    return points\n\n\n\ndef cubic( p1, p2, p3, p4 ):\n    x1,y1 = p1\n    x2,y2 = p2\n    x3,y3 = p3\n    x4,y4 = p4\n    points = []\n    cubic_recursive( points, x1,y1, x2,y2, x3,y3, x4,y4 )\n\n    dx,dy = points[0][0]-x1, points[0][1]-y1\n    if (dx*dx+dy*dy) > epsilon: points.insert(0, (x1,y1) )\n    dx,dy = points[-1][0]-x4, points[-1][1]-y4\n    if (dx*dx+dy*dy) > epsilon: points.append( (x4,y4) )\n\n    return points\n\n\n\ndef arc(cx, cy, rx, ry, a1, a2, ccw=False):\n    scale = 1.0\n    ra = (abs(rx) + abs(ry)) / 2.0\n    da = math.acos(ra / (ra + 0.125 / scale)) * 2.0\n    if ccw:\n        while a2 < a1:\n            a2 += math.pi * 2.0\n    else:\n        while a1 < a2:\n            a1 += math.pi * 2.0\n        da = -da\n    a_start = a1\n    a_end   = a2\n\n    vertices =[]\n    angle = a_start\n    while (angle < a_end - da/4) == ccw:\n        x = cx + math.cos(angle) * rx\n        y = cy + math.sin(angle) * ry\n        vertices.append( (x,y) )\n        angle += da\n    x = cx + math.cos(a_end) * rx\n    y = cy + math.sin(a_end) * ry\n    vertices.append( (x,y) )\n    return vertices\n\n\ndef elliptical_arc(x0, y0, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2):\n    radii_ok = True\n    cos_a = math.cos(angle)\n    sin_a = math.sin(angle)\n    if rx < 0.0: rx = -rx\n    if ry < 0.0: ry = -rx\n\n    # Calculate the middle point between\n    # the current and the final points\n    # ------------------------\n    dx2 = (x0 - x2) / 2.0\n    dy2 = (y0 - y2) / 2.0\n\n    # Calculate (x1, y1)\n    # ------------------------\n    x1 =  cos_a * dx2 + sin_a * dy2\n    y1 = -sin_a * dx2 + cos_a * dy2\n\n    # Check that radii are large enough\n    # ------------------------\n    prx,pry = rx * rx, ry * ry\n    px1,py1 = x1 * x1, y1 * y1\n\n    radii_check = px1/prx + py1/pry\n    if radii_check > 1.0:\n        rx = math.sqrt(radii_check) * rx\n        ry = math.sqrt(radii_check) * ry\n        prx = rx * rx\n        pry = ry * ry\n        if radii_check > 10.0:\n            radii_ok = False\n\n    # Calculate (cx1, cy1)\n    # ------------------------\n    if large_arc_flag == sweep_flag:\n        sign = -1\n    else:\n        sign = +1\n    sq   = (prx*pry - prx*py1 - pry*px1) / (prx*py1 + pry*px1)\n    coef = sign*math.sqrt( max(sq,0) )\n    cx1  = coef *  ((rx * y1) / ry)\n    cy1  = coef * -((ry * x1) / rx)\n\n    # Calculate (cx, cy) from (cx1, cy1)\n    # ------------------------\n    sx2 = (x0 + x2) / 2.0\n    sy2 = (y0 + y2) / 2.0\n    cx = sx2 + (cos_a * cx1 - sin_a * cy1)\n    cy = sy2 + (sin_a * cx1 + cos_a * cy1)\n\n    # Calculate the start_angle (angle1) and the sweep_angle (dangle)\n    # ------------------------\n    ux =  (x1 - cx1) / rx\n    uy =  (y1 - cy1) / ry\n    vx = (-x1 - cx1) / rx\n    vy = (-y1 - cy1) / ry\n\n    # Calculate the angle start\n    # ------------------------\n    n = math.sqrt(ux*ux + uy*uy)\n    p = ux;\n    if uy < 0:\n        sign = -1.0\n    else:\n        sign = +1.0\n    v = p / n\n    if v < -1.0:\n        v = -1.0\n    if v >  1.0:\n        v =  1.0\n    start_angle = sign * math.acos(v)\n\n    # Calculate the sweep angle\n    # ------------------------\n    n = math.sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy))\n    p = ux * vx + uy * vy\n    if ux * vy - uy * vx < 0:\n        sign = -1.0\n    else:\n        sign = +1.0\n    v = p / n\n    v = min(max(v,-1.0),+1.0)\n    sweep_angle = sign * math.acos(v)\n    if not sweep_flag and sweep_angle > 0:\n        sweep_angle -= math.pi * 2.0\n    elif sweep_flag and sweep_angle < 0:\n        sweep_angle += math.pi * 2.0\n\n    start_angle = math.fmod(start_angle, 2.0 * math.pi)\n    if sweep_angle >=  2.0 * math.pi:\n        sweep_angle =  2.0 * math.pi\n    if sweep_angle <= -2.0 * math.pi:\n        sweep_angle = -2.0 * math.pi\n\n    V = arc( cx, cy, rx, ry, start_angle, start_angle+sweep_angle, sweep_flag )\n    c = math.cos(angle)\n    s = math.sin(angle)\n    X,Y = V[:,0]-cx, V[:,1]-cy\n    V[:,0] = c*X - s*Y + cx\n    V[:,1] = s*X + c*Y + cy\n    return V\n"""
glumpy/graphics/svg/group.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport copy\nfrom glumpy.log import log\nfrom .path import Path\nfrom .style import Style\nfrom .base import namespace\nfrom .element import Element\nfrom .transformable import Transformable\n\n\nclass Group(Transformable):\n\n    def __init__(self, content=None, parent=None):\n        Transformable.__init__(self, content, parent)\n\n        self._items = []\n        for element in content:\n            if not element.tag.startswith(namespace):\n                continue\n            tag = element.tag[len(namespace):]\n            if tag == ""g"":\n                item = Group(element, self)\n            elif tag == ""path"":\n                item = Path(element, self)\n            else:\n                log.warn(""Unhandled SVG tag (%s)"" % tag)\n                continue\n            self._items.append(item)\n\n\n    @property\n    def flatten(self):\n        i = 0\n        L = copy.deepcopy(self._items)\n        while i < len(L):\n            while isinstance(L[i], Group) and len(L[i]._items):\n                L[i:i+1] = L[i]._items\n            i += 1\n        return L\n\n    @property\n    def paths(self):\n        return [item for item in self.flatten if isinstance(item,Path)]\n\n\n    def __repr__(self):\n        s = """"\n        for item in self._items:\n            s += repr(item)\n        return s\n\n    @property\n    def xml(self):\n        return self._xml()\n\n    def _xml(self, prefix=""""):\n        s = prefix+""<g ""\n        s += \'id=""%s"" \' % self._id\n        s += self._transform.xml\n        s += self._style.xml\n        s += "">\\n""\n        for item in self._items:\n            s += item._xml(prefix=prefix+""   "")\n        s += prefix+""</g>\\n""\n        return s\n'"
glumpy/graphics/svg/length.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\nimport math\nfrom .base import units\n\nclass Length(object):\n    def __init__(self, content, mode=\'x\', parent=None):\n\n        if not content:\n            self._unit = None\n            self._value = 0\n            self._computed_value = 0\n            return\n\n        re_number = r\'[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][-+]?\\d+)?\'\n        re_unit= r\'em|ex|px|in|cm|mm|pt|pc|%\'\n        re_length = r\'(?P<value>%s)\\s*(?P<unit>%s)*\' % (re_number, re_unit)\n        match = re.match(re_length, content)\n\n        if match:\n            self._value = float(match.group(""value""))\n            self._unit = match.group(""unit"") or ""px""\n        else:\n            self._value = 0.0\n            self._unit = None\n\n        scale = 1\n        if self._unit == \'%\':\n            if not parent:\n                print(""No parent for computing length using percent"")\n            elif hasattr(parent, \'viewport\'):\n                w, h = parent.viewport\n                if mode == \'x\':\n                    scale = w\n                elif mode == \'y\':\n                    scale = h\n                elif mode == \'xy\':\n                    scale = math.sqrt(w*w+h*h)/math.sqrt(2.0)\n            else:\n                print(""Parent doesn\'t have a viewport"")\n\n        self._computed_value = self._value * units[self._unit] * scale\n\n\n    def __float__(self):\n        return self._computed_value\n\n    @property\n    def value(self):\n        return self._computed_value\n\n\n    def __repr__(self):\n        if self._unit:\n            return ""%g%s"" % (self._value, self._unit)\n        else:\n            return ""%g"" % (self._value)\n\n\nclass XLength(Length):\n    def __init__(self, content, parent=None):\n        Length.__init__(self, content, \'x\', parent)\n\nclass YLength(Length):\n    def __init__(self, content, parent=None):\n        Length.__init__(self, content, \'y\', parent)\n\nclass XYLength(Length):\n    def __init__(self, content, parent=None):\n        Length.__init__(self, content, \'xy\', parent)\n'"
glumpy/graphics/svg/number.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n\nclass Number(object):\n\n    def __init__(self, content):\n        if not content:\n            self._value = 0\n        else:\n            content = content.strip()\n            self._value = float(content)\n\n    def __float__(self):\n        return self._value\n\n    @property\n    def value(self):\n        return self._value\n\n    def __repr__(self):\n        return repr(self._value)\n'"
glumpy/graphics/svg/path.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\nimport math\nimport numpy as np\n\nfrom . import geometry\nfrom .style import Style\nfrom .geometry import epsilon\nfrom .transformable import Transformable\n\n\n# -------------------------------------------------------------------- Command ---\nclass Command(object):\n    def __repr__(self):\n        s = \'%s \' % self._command\n        for arg in self._args:\n            s += ""%.2f "" % arg\n        return s\n\n    def origin(self, current=None, previous=None):\n        relative = self._command in ""mlvhcsqtaz""\n\n        if relative and current:\n            return current\n        else:\n            return 0.0,0.0\n\n\n# -------------------------------------------------------------------- Line ---\nclass Line(Command):\n    def __init__(self, x=0, y=0, relative=True):\n        self._command = \'l\' if relative else \'L\'\n        self._args = [x,y]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x,y = self._args\n        self.previous = x,y\n\n        return (ox+x,oy+y),\n\n\n\n# ------------------------------------------------------------------- VLine ---\nclass VLine(Command):\n    def __init__(self, y=0, relative=True):\n        self._command = \'v\' if relative else \'V\'\n        self._args = [y]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        y = self._args[0]\n        self.previous = ox,oy+y\n\n        return (ox,oy+y),\n\n\n# ------------------------------------------------------------------- HLine ---\nclass HLine(Command):\n    def __init__(self, x=0, relative=True):\n        self._command = \'h\' if relative else \'H\'\n        self._args = [x]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x = self._args[0]\n        self.previous = ox+x,oy\n\n        return (ox+x,oy),\n\n\n# -------------------------------------------------------------------- Move ---\nclass Move(Command):\n    def __init__(self, x=0, y=0, relative=True):\n        self._command = \'m\' if relative else \'M\'\n        self._args = [x,y]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x,y = self._args\n        x,y = x + ox, y + oy\n        self.previous = x,y\n        return (x,y),\n\n\n# ------------------------------------------------------------------- Close ---\nclass Close(Command):\n    def __init__(self, relative=True):\n        self._command = \'z\' if relative else \'Z\'\n        self._args = []\n\n    def vertices(self, current, previous=None):\n        self.previous = current\n        return [ ]\n\n\n# --------------------------------------------------------------------- Arc ---\nclass Arc(Command):\n    def __init__(self, r1=1, r2=1, angle=2*math.pi, large=True, sweep=True,\n                 x=0, y=0, relative=True):\n        self._command = \'a\' if relative else \'A\'\n        self._args = [r1,r2,angle,large,sweep,x,y]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        r1,r2,angle,large,sweep,x,y = self._args\n        x,y = x + ox, y + oy\n        x0,y0 = current\n        self.previous = x,y\n        vertices = geometry.elliptical_arc(x0,y0, rx,ry, angle, large, sweep_flag, x, y)\n        return vertices[1:]\n\n\n# ------------------------------------------------------------------- Cubic ---\nclass Cubic(Command):\n    def __init__(self, x1=0, y1=0, x2=0, y2=0, x3=0, y3=0, relative=True):\n        self._command = \'c\' if relative else \'C\'\n        self._args = [x1,y1,x2,y2,x3,y3]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x0,y0 = current\n        x1,y1,x2,y2,x3,y3 = self._args\n        x1,y1 = x1+ox, y1+oy\n        x2,y2 = x2+ox, y2+oy\n        x3,y3 = x3+ox, y3+oy\n        self.previous = x2,y2\n        vertices = geometry.cubic((x0,y0), (x1,y1), (x2,y2), (x3,y3))\n        return vertices[1:]\n\n\n# --------------------------------------------------------------- Quadratic ---\nclass Quadratic(Command):\n    def __init__(self, x1=0, y1=0, x2=0, y2=0, relative=True):\n        self._command = \'q\' if relative else \'Q\'\n        self._args = [x1,y1,x2,y2]\n\n    def vertices(self, current, last_control_point=None):\n        ox, oy = self.origin(current)\n        x1,y1,x2,y2 = self._args\n        x0,y0 = current\n        x1,y1 = x1+ox, y1+oy\n        x2,y2 = x2+ox, y2+oy\n        self.previous = x1,y1\n        vertices = geometry.quadratic((x0,y0), (x1,y1), (x2,y2))\n\n        return vertices[1:]\n\n\n\n# ------------------------------------------------------------- SmoothCubic ---\nclass SmoothCubic(Command):\n    def __init__(self, x2=0, y2=0, x3=0, y3=0, relative=True):\n        self._command = \'s\' if relative else \'S\'\n        self._args = [x2,y2,x3,y3]\n\n    def vertices(self, current, previous):\n        ox, oy = self.origin(current)\n        x0,y0 = current\n        x2,y2,x3,y3 = self._args\n        x2,y2 = x2+ox, y2+oy\n        x3,y3 = x3+ox, y3+oy\n        x1,y1 = 2*x0 - previous[0], 2*y0 - previous[1]\n        self.previous = x2,y2\n        vertices = geometry.cubic((x0,y0), (x1,y1), (x2,y2), (x3,y3))\n\n        return vertices[1:]\n\n\n# --------------------------------------------------------- SmoothQuadratic ---\nclass SmoothQuadratic(Command):\n    def __init__(self, x2=0, y2=0, relative=True):\n        self._command = \'t\' if relative else \'T\'\n        self._args = [x2,y2]\n\n    def vertices(self, current, previous):\n        ox, oy = self.origin(current)\n        x2,y2 = self._args\n        x0, y0 = current\n        x1,y1 = 2*x0 - previous[0], 2*y0 - previous[1]\n        x2, y2 = x2+ox, y2+oy\n        self.previous = x1,y1\n        vertices = geometry.quadratic( (x0,y0), (x1,y1), (x2,y2) )\n\n        return vertices[1:]\n\n\n\n# -------------------------------------------------------------------- Path ---\nclass Path(Transformable):\n\n    def __init__(self, content=None, parent=None):\n        Transformable.__init__(self, content, parent)\n        self._paths = []\n\n        if not isinstance(content, str):\n            content = content.get(""d"", """")\n\n        commands = re.compile(\n            ""(?P<command>[MLVHCSQTAZmlvhcsqtaz])(?P<points>[+\\-0-9.e, \\n\\t]*)"")\n\n        path = []\n        for match in re.finditer(commands, content):\n            command = match.group(""command"")\n            points = match.group(""points"").replace(\',\', \' \')\n            points = [float(v) for v in points.split()]\n            relative = command in ""mlvhcsqtaz""\n            command = command.upper()\n\n            while len(points) or command == \'Z\':\n                if command == \'M\':\n                    if len(path):\n                        self._paths.append(path)\n                    path = []\n                    path.append( Move(*points[:2], relative=relative) )\n                    points = points[2:]\n                elif command == \'L\':\n                    path.append( Line(*points[:2], relative=relative) )\n                    points = points[2:]\n                elif command == \'V\':\n                    path.append( VLine(*points[:1], relative=relative) )\n                    points = points[1:]\n                elif command == \'H\':\n                    path.append( HLine(*points[:1], relative=relative) )\n                    points = points[1:]\n                elif command == \'C\':\n                    path.append( Cubic(*points[:6], relative=relative) )\n                    points = points[6:]\n                elif command == \'S\':\n                    path.append( SmoothCubic(*points[:4], relative=relative) )\n                    points = points[4:]\n                elif command == \'Q\':\n                    path.append( Quadratic(*points[:4], relative=relative) )\n                    points = points[4:]\n                elif command == \'T\':\n                    path.append( SmoothQuadratic(*points[2:], relative=relative) )\n                    points = points[2:]\n                elif command == \'A\':\n                    path.append( Arc(*points[:7], relative=relative) )\n                    points = points[7:]\n                elif command == \'Z\':\n                    path.append( Close(relative=relative) )\n                    self._paths.append(path)\n                    path = []\n                    break\n                else:\n                    raise RuntimeError(""Unknown SVG path command(%s)"" % command)\n\n        if len(path):\n            self._paths.append(path)\n\n\n    def __repr__(self):\n        s = """"\n        for path in self._paths:\n            for item in path:\n                s += repr(item)\n        return s\n\n    @property\n    def xml(self):\n        return self._xml()\n\n    def _xml(self, prefix=""""):\n        s = prefix+ ""<path ""\n        s += \'id=""%s"" \' % self._id\n        s += self._style.xml\n        s += \'\\n\'\n        t = \'     \' + prefix+\' d=""\'\n        s += t\n        prefix = \' \'*len(t)\n        first = True\n        for i,path in enumerate(self._paths):\n            for j,item in enumerate(path):\n                if first:\n                    s += repr(item)\n                    first = False\n                else:\n                    s += prefix+repr(item)\n                if i < len(self._paths)-1 or j < len(path)-1:\n                    s += \'\\n\'\n        s += \'""/>\\n\'\n        return s\n\n\n    @property\n    def vertices(self):\n        self._vertices = []\n        current = 0,0\n        previous = 0,0\n        transform = self.transform\n\n        for path in self._paths:\n            vertices = []\n            for command in path:\n                V = command.vertices(current, previous)\n                previous = command.previous\n                vertices.extend( V )\n                if len(V) > 0:\n                    current = V[-1]\n                else:\n                    current = 0,0\n\n            closed = False\n            if isinstance(command, Close):\n                closed = True\n                if len(vertices) > 2:\n                    d = geometry.calc_sq_distance(vertices[-1][0], vertices[-1][1],\n                                                  vertices[0][0],  vertices[0][1])\n                    if d < epsilon:\n                        vertices = vertices[:-1]\n\n            # Apply transformation\n            V = np.ones((len(vertices),3))\n            V[:,:2] = vertices\n            V = np.dot(V,self.transform.matrix.T)\n            V[:,2] = 0\n            self._vertices.append( (V,closed) )\n\n        return self._vertices\n'"
glumpy/graphics/svg/shapes.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\n\n\nclass Rect(object):\n    def __init__(self, x=0, y=0, width=1, height=1, rx=0, ry=0):\n        self.x = x\n        self.y = y\n        self.width = width\n        self.height = height\n        self.rx = rx\n        self.ry = ry\n\n    def parse(self, expression):\n        """""" """"""\n\n\n\n\n\nclass Line(object):\n    def __init__(self, x1=0, y1=0, x2=0, y2=0):\n        self.x1 = x2\n        self.y1 = y2\n        self.x2 = x2\n        self.y2 = y2\n\n\nclass Circle(object):\n    def __init__(self, cx=0, cy=0, r=1):\n        self.cx = cx\n        self.cy = cy\n        self.r = r\n\n\nclass Ellipse(object):\n    def __init__(self, cx=0, cy=0, rx=1, ry=1):\n        self.cx = cx\n        self.cy = cy\n        self.rx = rx\n        self.ry = ry\n\nclass Polygon(object):\n    def __init__(self, points=[]):\n        self.points = points\n\n\nclass Polyline(object):\n    def __init__(self, points=[]):\n        self.points = points\n'"
glumpy/graphics/svg/style.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom .color import Color\nfrom .number import Number\nfrom .length import Length\n\n_converters = {\n    ""fill"":              Color,\n    ""fill-opacity"":      Number,\n    ""stroke"":            Color,\n    ""stroke-opacity"":    Number,\n    ""opacity"":           Number,\n    ""stroke-width"":      Length,\n#    ""stroke-miterlimit"": Number,\n#    ""stroke-dasharray"":  Lengths,\n#    ""stroke-dashoffset"": Length,\n}\n\nclass Style(object):\n    def __init__(self):\n        self._unset = True\n        for key in _converters.keys():\n            key_ = key.replace(""-"",""_"")\n            self.__setattr__(key_, None)\n\n    def update(self, content):\n        if not content:\n            return\n\n        self._unset = False\n        items = content.strip().split("";"")\n        attributes = dict([item.strip().split("":"") for item in items if item])\n        for key,value in attributes.items():\n            if key in _converters:\n                key_ = key.replace(""-"",""_"")\n                self.__setattr__(key_, _converters[key](value))\n\n    @property\n    def xml(self):\n        return self._xml()\n\n\n    def _xml(self, prefix=""""):\n        if self._unset:\n            return """"\n\n        s = \'style=""\'\n        for key in _converters.keys():\n            key_ = key.replace(""-"",""_"")\n            value = self.__getattribute__(key_)\n            if value is not None:\n                s += \'%s:%s \' % (key, value)\n        s+= \'""\'\n        return s\n'"
glumpy/graphics/svg/svg.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom .group import Group\nfrom .base import namespace\nfrom .viewport import Viewport\n\nclass SVG(Group):\n\n    def __init__(self, content=None, parent=None):\n        Group.__init__(self, content, parent)\n        self._viewport = Viewport(content)\n\n\n    @property\n    def viewport(self):\n        return self._viewport\n\n\n    def __repr__(self):\n        s = """"\n        for item in self._items:\n            s += repr(item) + ""\\n""\n        return s\n\n    @property\n    def xml(self):\n        return self._xml()\n\n    def _xml(self, prefix=""""):\n        s = ""<svg ""\n        s += \'id=""%s"" \' % self._id\n        s += self._viewport.xml\n        s += self._transform.xml\n        s += ""\\n""\n        for item in self._items:\n            s += item._xml(prefix=prefix+""    "") + ""\\n""\n        s += ""</svg>\\n""\n        return s\n'"
glumpy/graphics/svg/transform.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport re\nimport math\nimport numpy as np\n\n# ------------------------------------------------------------------ Matrix ---\nclass Matrix(object):\n    def __init__(self, a=1, b=0, c=0, d=1, e=0, f=0):\n        self._matrix = np.array([[ a, c, e],\n                                 [ b, d, f],\n                                 [ 0, 0, 1]], dtype=float)\n\n    @property\n    def matrix(self):\n        return self._matrix\n\n    def __array__(self, *args):\n        return self._matrix\n\n    def __repr__(self):\n        a,c,e = self._matrix[0]\n        b,d,f = self._matrix[1]\n        return ""Matrix(%g,%g,%g,%g,%g,%g)"" % (a,b,c,d,e,f)\n\n\n# ---------------------------------------------------------------- Identity ---\nclass Identity(Matrix):\n    def __init__(self):\n        Matrix.__init__(self)\n        self._matrix[...] = ([[ 1, 0, 0],\n                              [ 0, 1, 0],\n                              [ 0, 0, 1]])\n\n    def __repr__(self):\n        return ""Identity()""\n\n\n\n# --------------------------------------------------------------- Translate ---\nclass Translate(Matrix):\n    """"""\n    Translation is equivalent to the matrix [1 0 0 1 tx ty], where tx and ty\n    are the distances to translate coordinates in X and Y, respectively.\n    """"""\n\n    def __init__(self, x, y=0):\n        Matrix.__init__(self)\n        self._x, self._y = x, y\n        self._matrix[...] = ([[ 1, 0, x],\n                              [ 0, 1, y],\n                              [ 0, 0, 1]])\n\n    def __repr__(self):\n        return ""Translate(%g,%g)"" % (self._x, self._y)\n\n\n\n# ------------------------------------------------------------------- Scale ---\nclass Scale(Matrix):\n    """"""\n    Scaling is equivalent to the matrix [sx 0 0 sy 0 0]. One unit in the X and\n    Y directions in the new coordinate system equals sx and sy units in the\n    previous coordinate system, respectively.\n    """"""\n\n    def __init__(self, x, y=0):\n        Matrix.__init__(self)\n        self._x = x\n        self._y = y or x\n        self._matrix[...] = ([[ x, 0, 0],\n                              [ 0, y, 0],\n                              [ 0, 0, 1]])\n\n    def __repr__(self):\n        return ""Scale(%g,%g)"" % (self._x, self._y)\n\n\n\n# ------------------------------------------------------------------- Scale ---\nclass Rotate(Matrix):\n    """"""\n    Rotation about the origin is equivalent to the matrix [cos(a) sin(a)\n    -sin(a) cos(a) 0 0], which has the effect of rotating the coordinate system\n    axes by angle a.\n    """"""\n\n    def __init__(self, angle, x=0, y=0):\n        Matrix.__init__(self)\n        self._angle = angle\n        self._x = x\n        self._y = y\n\n        angle = math.pi*angle/180.0\n        rotate = np.array([[math.cos(angle), -math.sin(angle), 0],\n                           [math.sin(angle),  math.cos(angle), 0],\n                           [ 0, 0, 1]], dtype=float)\n        forward = np.array([[ 1, 0, x],\n                            [ 0, 1, y],\n                            [ 0, 0, 1]], dtype=float)\n        inverse = np.array([[ 1, 0, -x],\n                            [ 0, 1, -y],\n                            [ 0, 0, 1]], dtype=float)\n        self._matrix = np.dot(inverse,np.dot(rotate,forward))\n\n\n    def __repr__(self):\n        return ""Rotate(%g,%g,%g)"" % (self._angle, self._x, self._y)\n\n\n\n# ------------------------------------------------------------------- SkewX ---\nclass SkewX(Matrix):\n    """"""\n    A skew transformation along the x-axis is equivalent to the matrix [1 0\n    tan(a) 1 0 0], which has the effect of skewing X coordinates by angle a.\n    """"""\n\n    def __init__(self, angle):\n        Matrix.__init__(self)\n        self._angle = angle\n        angle = math.pi*angle/180.0\n        self._matrix[...] = ([[ 1, math.tan(angle), 0],\n                              [ 0, 1, 0],\n                              [ 0, 0, 1]])\n\n    def __repr__(self):\n        return ""SkewX(%g)"" % (self._angle)\n\n\n\n# ------------------------------------------------------------------- SkewY ---\nclass SkewY(Matrix):\n    """"""\n    A skew transformation along the y-axis is equivalent to the matrix [1\n    tan(a) 0 1 0 0], which has the effect of skewing Y coordinates by angle a.\n    """"""\n\n    def __init__(self, angle):\n        Matrix.__init__(self)\n        self._angle = angle\n        angle = math.pi*angle/180.0\n        self._matrix[...] = ([[ 1, 0, 0],\n                              [ math.tan(angle), 1, 0],\n                              [ 0, 0, 1]])\n\n    def __repr__(self):\n        return ""SkewY(%g)"" % (self._angle)\n\n\n\n\n\n# --------------------------------------------------------------- Transform ---\nclass Transform:\n    """"""\n    A Transform is defined as a list of transform definitions, which are\n    applied in the order provided. The individual transform definitions are\n    separated by whitespace and/or a comma.\n    """"""\n\n    def __init__(self, content=""""):\n        self._transforms = []\n        if not content:\n            return\n\n        converters = { ""matrix"":    Matrix,\n                       ""scale"":     Scale,\n                       ""rotate"":    Rotate,\n                       ""translate"": Translate,\n                       ""skewx"":     SkewX,\n                       ""skewy"":     SkewY }\n        keys = ""|"".join(converters.keys())\n        pattern = ""(?P<name>%s)\\s*\\((?P<args>[^)]*)\\)"" % keys\n\n        for match in re.finditer(pattern, content):\n            name = match.group(""name"").strip()\n            args = match.group(""args"").strip().replace(\',\', \' \')\n            args = [float(value) for value in args.split()]\n            transform = converters[name](*args)\n            self._transforms.append(transform)\n\n    def __add__(self, other):\n        T = Transform()\n        T._transforms.extend(self._transforms)\n        T._transforms.extend(other._transforms)\n        return T\n\n    def __radd__(self, other):\n        self._transforms.extend(other._transforms)\n        return self\n\n    @property\n    def matrix(self):\n        M = np.eye(3)\n        for transform in self._transforms:\n            M = np.dot(M,transform)\n        return M\n\n\n    def __array__(self, *args):\n        return self._matrix\n\n    def __repr__(self):\n        s = """"\n        for i in range(len(self._transforms)):\n            s += repr(self._transforms[i])\n            if i < len(self._transforms) - 1:\n                s+= "", ""\n        return s\n\n\n    @property\n    def xml(self):\n        return self._xml()\n\n    def _xml(self, prefix=""""):\n\n        identity = True\n        for transform in self._transforms:\n            if not isinstance(transform, Identity):\n                identity = False\n                break\n        if identity:\n            return """"\n\n        return \'transform=""%s"" \' % repr(self)\n\n\n# -----------------------------------------------------------------------------\nif __name__ == \'__main__\':\n    transform = Transform(""translate(50,90), rotate(-45), translate(130,160)"")\n    print(transform)\n    print(transform.matrix)\n    print()\n\n    transform = (Transform(""translate(50,90)"") +\n                 Transform(""rotate(-45)"") +\n                 Transform(""translate(130,160)""))\n    print(transform)\n    print(transform.matrix)\n    print()\n\n    transform = Transform(""translate(50,90)"")\n    transform += Transform(""rotate(-45)"")\n    transform += Transform(""translate(130,160)"")\n    print(transform)\n    print(transform.matrix)\n\n\n    transform = Transform(""matrix(1.45784,0,0,1.37381,274.45,224.684)"")\n    print(transform.matrix)\n'"
glumpy/graphics/svg/transformable.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom .base import namespace\nfrom .element import Element\nfrom .transform import Transform\n\n\nclass Transformable(Element):\n    """""" Transformable SVG element """"""\n\n    def __init__(self, content=None, parent=None):\n        Element.__init__(self, content, parent)\n\n        if isinstance(content, str):\n            self._transform = Transform()\n            self._computed_transform = self._transform\n        else:\n            self._transform = Transform(content.get(""transform"",None))\n            self._computed_transform = self._transform\n            if parent:\n                self._computed_transform = self._transform + self.parent.transform\n\n    @property\n    def transform(self):\n        return self._computed_transform\n'"
glumpy/graphics/svg/viewport.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom .length import XLength, YLength\n\n\nclass Viewport(object):\n    def __init__(self, content=None, parent=None):\n\n        self._x = None\n        self._computed_x = 0\n        if content.get(\'x\'):\n            self._x = XLength(content.get(\'x\'), parent)\n            self._computed_x = float(self._x)\n\n        self._y = None\n        self._computed_y = 0\n        if content.get(\'y\'):\n            self._y = XLength(content.get(\'y\'), parent)\n            self._computed_y = float(self._y)\n\n\n        self._width = None\n        self._computed_width = 800\n        if content.get(\'width\'):\n            self._width = XLength(content.get(\'width\'), parent)\n            self._computed_width = float(self._width)\n\n        self._height = None\n        self._computed_height = 800\n        if content.get(\'height\'):\n            self._height = YLength(content.get(\'height\'), parent)\n            self._computed_height = float(self._height)\n\n\n    @property\n    def x(self):\n        return self._computed_x\n\n    @property\n    def y(self):\n        return self._computed_y\n\n    @property\n    def width(self):\n        return self._computed_width\n\n    @property\n    def height(self):\n        return self._computed_height\n\n    def __repr__(self):\n        s = repr( (self._x, self._y, self._width, self._height) )\n        return s\n\n    @property\n    def xml(self):\n        return self._xml\n\n    @property\n    def _xml(self, prefix=""""):\n        s = """"\n        if self._x:      s += \'x=""%s"" \' % repr(self._x)\n        if self._y:      s += \'y=""%s"" \' % repr(self._y)\n        if self._width:  s += \'width=""%s"" \' % repr(self._width)\n        if self._height: s += \'height=""%s"" \' % repr(self._height)\n        return s\n'"
glumpy/graphics/text/__init__.py,0,b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nfrom . font_manager import FontManager\n'
glumpy/graphics/text/agg_font.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom . font import Glyph\nfrom glumpy.ext import freetype\n\n\n\nclass AggFont(object):\n\n    def __init__(self, filename, size, atlas):\n\n        self.filename = filename\n        self.atlas = atlas\n        self.size = size\n        self.glyphs = {}\n        face = freetype.Face(self.filename)\n        face.set_char_size( int(size*64) )\n        metrics = face.size\n        self.ascender  = metrics.ascender/64.0\n        self.descender = metrics.descender/64.0\n        self.height    = metrics.height/64.0\n        self.linegap   = (self.height - self.ascender + self.descender)\n\n        try:\n            freetype.set_lcd_filter(freetype.FT_LCD_FILTER_LIGHT)\n        except:\n            pass\n\n\n    def __getitem__(self, charcode):\n        if charcode not in self.glyphs.keys():\n            self.load(\'%c\' % charcode)\n        return self.glyphs[charcode]\n\n\n    def load(self, charcodes = \'\'):\n        \'\'\'\n        Build glyphs corresponding to individual characters in charcodes.\n\n        Parameters:\n        -----------\n\n        charcodes: [str | unicode]\n            Set of characters to be represented\n        \'\'\'\n        face = freetype.Face( self.filename )\n        pen = freetype.Vector(0,0)\n        hres = 100*72\n        hscale = 1.0/100\n\n\n        for charcode in charcodes:\n            face.set_char_size( int(self.size * 64), 0, hres, 72 )\n            matrix = freetype.Matrix( int((hscale) * 0x10000), int((0.0) * 0x10000),\n                                      int((0.0)    * 0x10000), int((1.0) * 0x10000) )\n            face.set_transform( matrix, pen )\n            if charcode in self.glyphs.keys():\n                continue\n\n            flags = freetype.FT_LOAD_RENDER | freetype.FT_LOAD_FORCE_AUTOHINT\n            flags |= freetype.FT_LOAD_TARGET_LCD\n\n            face.load_char( charcode, flags )\n            bitmap = face.glyph.bitmap\n            left   = face.glyph.bitmap_left\n            top    = face.glyph.bitmap_top\n            width  = face.glyph.bitmap.width\n            rows   = face.glyph.bitmap.rows\n            pitch  = face.glyph.bitmap.pitch\n\n            w = int(width//3)\n            h = rows\n            # h+1,w+1 to have a black border\n            region = self.atlas.allocate( (h+1,w+1) )\n            if region is None:\n                log.warn(""Cannot store glyph \'%c\'"" % charcode)\n                continue\n\n            x,y,_,_ = region\n            # sould be y+h+1,x+w+1 but we skip the black border\n\n            texture = self.atlas[y:y+h,x:x+w]\n            data = []\n            for i in range(rows):\n                data.extend(bitmap.buffer[i*pitch:i*pitch+width])\n            data = np.array(data,dtype=np.ubyte).reshape(h,w,3)\n            texture[...] = data\n\n            # Build glyph\n            size   = w,h\n            offset = left, top\n            advance= face.glyph.advance.x, face.glyph.advance.y\n\n            u0     = (x +     0.0)/float(self.atlas.width)\n            v0     = (y +     0.0)/float(self.atlas.height)\n            u1     = (x + w - 0.0)/float(self.atlas.width)\n            v1     = (y + h - 0.0)/float(self.atlas.height)\n            texcoords = (u0,v0,u1,v1)\n            glyph = Glyph(charcode, size, offset, advance, texcoords)\n            self.glyphs[charcode] = glyph\n\n            # Generate kerning\n            for g in self.glyphs.values():\n                # 64 * 64 because of 26.6 encoding AND the transform matrix used\n                # in texture_font_load_face (hres = 64)\n                kerning = face.get_kerning(g.charcode, charcode,\n                                           mode=freetype.FT_KERNING_UNFITTED)\n                if kerning.x != 0:\n                    glyph.kerning[g.charcode] = kerning.x/(64.0*64.0)\n                kerning = face.get_kerning(charcode, g.charcode,\n                                           mode=freetype.FT_KERNING_UNFITTED)\n                if kerning.x != 0:\n                    g.kerning[charcode] = kerning.x/(64.0*64.0)\n\n            # High resolution advance.x calculation\n            # gindex = face.get_char_index( charcode )\n            # a = face.get_advance(gindex, FT_LOAD_RENDER | FT_LOAD_TARGET_LCD)/(64*72)\n            # glyph.advance = a, glyph.advance[1]\n'"
glumpy/graphics/text/font.py,0,"b""# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n\nclass Glyph(object):\n    '''\n    A glyph gathers information relative to the size/offset/advance and texture\n    coordinates of a single character. It is generally built automatically by a\n    Font.\n    '''\n\n    def __init__(self, charcode, shape, offset, advance, texcoords):\n        '''\n        Build a new texture glyph\n\n        Parameter:\n        ----------\n\n        charcode : char\n            Represented character\n\n        size: tuple of 2 ints\n            Glyph size in pixels\n\n        offset: tuple of 2 floats\n            Glyph offset relatively to anchor point\n\n        advance: tuple of 2 floats\n            Glyph advance\n\n        texcoords: tuple of 4 floats\n            Texture coordinates of bottom-left and top-right corner\n        '''\n        self.charcode = charcode\n        self.shape = shape\n        self.offset = offset\n        self.advance = advance\n        self.texcoords = texcoords\n        self.kerning = {}\n\n\n    def get_kerning(self, charcode):\n        ''' Get kerning information\n\n        Parameters:\n        -----------\n\n        charcode: char\n            Character preceding this glyph\n        '''\n        if charcode in self.kerning.keys():\n            return self.kerning[charcode]\n        else:\n            return 0\n"""
glumpy/graphics/text/font_manager.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n"""""" Font Manager """"""\nimport os\nimport numpy as np\nfrom glumpy import data\nfrom glumpy.log import log\nfrom glumpy.gloo.atlas import Atlas\nfrom . sdf_font import SDFFont\nfrom . agg_font import AggFont\n\n\n\nclass FontManager(object):\n    """"""\n    Font Manager\n\n    The Font manager takes care of caching already loaded font. Currently, the only\n    way to get a font is to get it via its filename. If the font is not available\n    on the local data directory, it will be fetched from the font server which\n    lives at https://github.com/glumpy/glumpy-font/.\n    """"""\n\n    # Default atlas\n    _atlas_sdf = None\n    _atlas_agg = None\n\n    # Font cache\n    _cache_sdf = {}\n    _cache_agg = {}\n\n    # The singleton instance\n    _instance = None\n\n\n    def __new__(cls, *args, **kwargs):\n        if not cls._instance:\n            cls._instance = object.__new__(cls, *args, **kwargs)\n        return cls._instance\n\n    @classmethod\n    def get(cls, filename, size=12, mode=\'sdf\'):\n        """"""\n        Get a font from the cache, the local data directory or the distant server\n        (in that order).\n        """"""\n\n        filename = data.get(filename)\n        dirname  = os.path.dirname(filename)\n        basename = os.path.basename(filename)\n\n        if mode == \'sdf\':\n            key = \'%s\' % (basename)\n            if FontManager._atlas_sdf is None:\n                FontManager._atlas_sdf = np.zeros((1024,1024),np.float32).view(Atlas)\n            atlas = FontManager._atlas_sdf\n            cache = FontManager._cache_sdf\n\n            if key not in cache.keys():\n                cache[key] = SDFFont(filename, atlas)\n            return cache[key]\n\n        else: # mode == \'agg\':\n            key = \'%s-%d\' % (basename,size)\n            if FontManager._atlas_agg is None:\n                FontManager._atlas_agg = np.zeros((1024,1024,3),np.ubyte).view(Atlas)\n\n            atlas = FontManager._atlas_agg\n            cache = FontManager._cache_agg\n            if key not in cache.keys():\n                cache[key] = AggFont(filename, size, atlas)\n            return cache[key]\n\n    @property\n    def atlas_sdf(self):\n        if FontManager._atlas_sdf is None:\n            FontManager._atlas_sdf = np.zeros((1024,1024),np.float32).view(Atlas)\n        return FontManager._atlas_sdf\n\n\n    @property\n    def atlas_agg(self):\n        if FontManager._atlas_agg is None:\n            FontManager._atlas_agg = np.zeros((1024,1024,3),np.ubyte).view(Atlas)\n        return FontManager._atlas_agg\n'"
glumpy/graphics/text/sdf_font.py,13,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom . font import Glyph\nfrom glumpy.ext import freetype\n# Lazy import to avoid problem on readthedocs.org\n# from glumpy.ext.sdf import compute_sdf\n\n\ndef bilinear_interpolate(im, x, y):\n    """""" By Alex Flint on StackOverflow """"""\n\n    x = np.asarray(x)\n    y = np.asarray(y)\n\n    x0 = np.floor(x).astype(int)\n    x1 = x0 + 1\n    y0 = np.floor(y).astype(int)\n    y1 = y0 + 1\n\n    x0 = np.clip(x0, 0, im.shape[1]-1);\n    x1 = np.clip(x1, 0, im.shape[1]-1);\n    y0 = np.clip(y0, 0, im.shape[0]-1);\n    y1 = np.clip(y1, 0, im.shape[0]-1);\n\n    Ia = im[ y0, x0 ]\n    Ib = im[ y1, x0 ]\n    Ic = im[ y0, x1 ]\n    Id = im[ y1, x1 ]\n\n    wa = (x1-x) * (y1-y)\n    wb = (x1-x) * (y-y0)\n    wc = (x-x0) * (y1-y)\n    wd = (x-x0) * (y-y0)\n\n    return wa*Ia + wb*Ib + wc*Ic + wd*Id\n\n\ndef zoom(Z, ratio):\n    """""" Bilinear image zoom """"""\n\n    nrows, ncols = Z.shape\n    x,y = np.meshgrid(np.linspace(0, ncols, (ratio*ncols), endpoint=False),\n                      np.linspace(0, nrows, (ratio*nrows), endpoint=False))\n    return bilinear_interpolate(Z, x, y)\n\n\n\nclass SDFFont(object):\n\n    def __init__(self, filename, atlas):\n\n        self._hires_size = 256\n        self._lowres_size = 48\n        self._padding = 0.125\n\n\n        self.filename = filename\n        self.atlas = atlas\n\n        self.glyphs = {}\n        face = freetype.Face(self.filename)\n        face.set_char_size(self._lowres_size*64)\n        metrics = face.size\n        self.ascender  = metrics.ascender/64.0\n        self.descender = metrics.descender/64.0\n        self.height    = metrics.height/64.0\n        self.linegap   = (self.height - self.ascender + self.descender)\n\n\n    def __getitem__(self, charcode):\n        if charcode not in self.glyphs.keys():\n            self.load(\'%c\' % charcode)\n        return self.glyphs[charcode]\n\n\n    def load_glyph(self, face, charcode):\n\n        # Lazy import to avoid problem on readthedocs.org\n        from glumpy.ext.sdf import compute_sdf\n\n        face.set_char_size( self._hires_size*64 )\n        face.load_char(charcode, freetype.FT_LOAD_RENDER |\n                                 freetype.FT_LOAD_NO_HINTING |\n                                 freetype.FT_LOAD_NO_AUTOHINT)\n\n        bitmap = face.glyph.bitmap\n        width  = face.glyph.bitmap.width\n        height = face.glyph.bitmap.rows\n        pitch  = face.glyph.bitmap.pitch\n\n        # Get glyph into a numpy array\n        G = np.array(bitmap.buffer).reshape(height,pitch)\n        G = G[:,:width].astype(np.ubyte)\n\n        # Pad high resolution glyph with a blank border and normalize values\n        # between 0 and 1\n        hires_width  = int((1+2*self._padding)*width)\n        hires_height = int((1+2*self._padding)*height)\n        hires_data = np.zeros( (hires_height,hires_width), np.double)\n        ox,oy = int(self._padding*width), int(self._padding*height)\n        hires_data[oy:oy+height, ox:ox+width] = G/255.0\n\n       # Compute distance field at high resolution\n        compute_sdf(hires_data)\n\n       # Scale down glyph to low resolution size\n        ratio = self._lowres_size/float(self._hires_size)\n        # lowres_data = 1 - zoom(hires_data, ratio, cval=1.0)\n        lowres_data = 1 - zoom(hires_data, ratio)\n\n       # Compute information at low resolution size\n        # size   = ( lowres_data.shape[1], lowres_data.shape[0] )\n        offset = ( (face.glyph.bitmap_left - self._padding*width) * ratio,\n                   (face.glyph.bitmap_top + self._padding*height) * ratio )\n        advance = ( (face.glyph.advance.x/64.0)*ratio,\n                    (face.glyph.advance.y/64.0)*ratio )\n        return lowres_data, offset, advance\n\n\n    def load(self, charcodes = \'\'):\n        face = freetype.Face( self.filename )\n\n        for charcode in charcodes:\n            if charcode in self.glyphs.keys():\n                continue\n\n            data,offset,advance = self.load_glyph(face, charcode)\n\n            h,w = data.shape\n            region = self.atlas.allocate( (h+2,w+2) )\n            if region is None:\n                log.warn(""Cannot store glyph \'%c\'"" % charcode)\n                continue\n            x,y,_,_ = region\n            x,y = x+1, y+1\n            self.atlas[y:y+h,x:x+w] = data.reshape(h,w,1)\n\n            u0     = (x +     0.0)/float(self.atlas.width)\n            v0     = (y +     0.0)/float(self.atlas.height)\n            u1     = (x + w - 0.0)/float(self.atlas.width)\n            v1     = (y + h - 0.0)/float(self.atlas.height)\n            texcoords = (u0,v0,u1,v1)\n            glyph = Glyph(charcode, data.shape, offset, advance, texcoords)\n            self.glyphs[charcode] = glyph\n\n            # Generate kerning (for reference size)\n            face.set_char_size( self._lowres_size*64 )\n            for g in self.glyphs.values():\n                kerning = face.get_kerning(g.charcode, charcode,\n                                           mode=freetype.FT_KERNING_UNFITTED)\n                if kerning.x != 0:\n                    glyph.kerning[g.charcode] = kerning.x/64.0\n                kerning = face.get_kerning(charcode, g.charcode,\n                                           mode=freetype.FT_KERNING_UNFITTED)\n                if kerning.x != 0:\n                    g.kerning[charcode] = kerning.x/64.0\n'"
glumpy/library/antialias/__init__.py,0,b''
glumpy/library/arrows/__init__.py,0,b''
glumpy/library/colormaps/__init__.py,0,b''
glumpy/library/colormaps/parse.py,0,"b'import os\nimport re\n\n\ndef get(filename):\n\n    for path in ["".."", "".""]:\n        filepath = os.path.join(path, filename)\n        if os.path.exists(filepath):\n            with open(filepath) as infile:\n                code = infile.read()\n                # comment = \'#line 0 // Start of ""%s""\\n\' % filename\n                comment = \'// --- start of ""%s"" ---\\n\' % filename\n            return comment + code\n    return \'#error ""%s"" not found !\\n\' % filename\n\ncode = """"""\n#include ""colormap/colormaps.glsl""\n""""""\n\nre_include = re.compile(\'\\#include\\s*""(?P<filename>[a-zA-Z0-9\\-\\.\\/]+)""\')\n\nincludes = []\ndef replace(match):\n    filename = match.group(""filename"")\n    if filename not in includes:\n        includes.append(filename)\n        text = get(filename)\n        # lineno = code.count(""\\n"",0,match.start())+1\n        # text += \'\\n#line %d // End of ""%s""\' % (lineno, filename)\n        text += \'// --- end of ""%s"" ---\\n\' % filename\n        return text\n    return \'\'\n\nwhile re.search(re_include, code):\n    code = re.sub(re_include, replace, code)\nprint(code)\n'"
glumpy/library/markers/__init__.py,0,b''
glumpy/library/math/__init__.py,0,b''
glumpy/library/misc/__init__.py,0,b''
glumpy/app/window/backends/__init__.py,0,"b""# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n__backends__ = ('glfw',\n                'pyglet',\n                'sdl',\n                'sdl2',\n                'osxglut',\n                'freeglut',\n                'qt5',\n                'pyside',\n                'pyside2')\n"""
glumpy/app/window/backends/backend_freeglut.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n`FreeGLUT <http://freeglut.sourceforge.net>`_ is a free-software/open-source\nalternative to the OpenGL Utility Toolkit (GLUT) library. GLUT was originally\nwritten by Mark Kilgard to support the sample programs in the second edition\nOpenGL RedBook. Since then, GLUT has been used in a wide variety of practical\napplications because it is simple, widely available and highly portable.\n\n**Usage**\n\n  .. code:: python\n\n     from glumpy import app\n\n     app.use(""freeglut"")\n     window = app.Window()\n\n\n**Capability**\n\n========================== ======== ======================== ========\nMultiple windows              \xe2\x9c\x98     Set GL API                  \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nNon-decorated windows         \xe2\x9c\x93     Set GL Profile              \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nResize windows                \xe2\x9c\x93     Share GL Context            \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nMove windows                  \xe2\x9c\x93     Unicode handling            \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nFullscreen                    \xe2\x9c\x93     Scroll event                \xe2\x9c\x93\n========================== ======== ======================== ========\n""""""\nimport sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""FreeGLUT""\n\n# Backend version (if available)\n__version__ = """"\n\n# Backend availability\n__availability__ = False\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Active windows\n__windows__ = []\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    if not __initialized__:\n        glut.glutInit(sys.argv)\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    # Not an error, we cannot really terminate glut\n    __initialized__ = True\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    import sys\n    import OpenGL.GLUT as glut\n    if sys.platform == \'darwin\':\n        import OpenGL.platform as platform\n        try:\n            glutCheckLoop = platform.createBaseFunction(\n                \'glutCheckLoop\', dll=platform.GLUT, resultType=None,\n                argTypes=[], doc=\'glutCheckLoop( ) -> None\', argNames=(), )\n        except AttributeError:\n            __availability__ = False\n            __version__ = None\n        __availability__ = True\n        __version__ = ""%d"" % glut.GLUT_API_VERSION\n        __init__()\n\n        __mouse_map__ = { glut.GLUT_LEFT_BUTTON:   window.mouse.LEFT,\n                          glut.GLUT_MIDDLE_BUTTON: window.mouse.MIDDLE,\n                          glut.GLUT_RIGHT_BUTTON:  window.mouse.RIGHT }\n\n        __key_map__   = { 0x008:                   window.key.BACKSPACE,\n                          0x009:                   window.key.TAB,\n                          0x00A:                   window.key.LINEFEED,\n                          0x00C:                   window.key.CLEAR,\n                          0x00D:                   window.key.RETURN,\n                          0x018:                   window.key.CANCEL,\n                          0x01B:                   window.key.ESCAPE,\n                          glut.GLUT_KEY_F1:        window.key.F1,\n                          glut.GLUT_KEY_F2:        window.key.F2,\n                          glut.GLUT_KEY_F3:        window.key.F3,\n                          glut.GLUT_KEY_F4:        window.key.F4,\n                          glut.GLUT_KEY_F5:        window.key.F5,\n                          glut.GLUT_KEY_F6:        window.key.F6,\n                          glut.GLUT_KEY_F7:        window.key.F7,\n                          glut.GLUT_KEY_F8:        window.key.F8,\n                          glut.GLUT_KEY_F9:        window.key.F9,\n                          glut.GLUT_KEY_F10:       window.key.F10,\n                          glut.GLUT_KEY_F11:       window.key.F11,\n                          glut.GLUT_KEY_F12:       window.key.F12,\n                          glut.GLUT_KEY_LEFT:      window.key.LEFT,\n                          glut.GLUT_KEY_UP:        window.key.UP,\n                          glut.GLUT_KEY_RIGHT:     window.key.RIGHT,\n                          glut.GLUT_KEY_DOWN:      window.key.DOWN,\n                          glut.GLUT_KEY_PAGE_UP:   window.key.PAGEUP,\n                          glut.GLUT_KEY_PAGE_DOWN: window.key.PAGEDOWN,\n                          glut.GLUT_KEY_HOME:      window.key.HOME,\n                          glut.GLUT_KEY_END:       window.key.END,\n                          glut.GLUT_KEY_INSERT:    window.key.INSERT }\n    else:\n        __availability__ = False\n        __version__ = None\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : True,\n    ""Window size get/set""     : True,\n    ""Multiple windows""        : False,\n    ""Mouse scroll events""     : False,\n    ""Non-decorated window""    : True,\n    ""Non-sizeable window""     : False,\n    ""Fullscreen mode""         : True,\n    ""Unicode processing""      : False,\n    ""Set GL version""          : False,\n    ""Set GL profile""          : False,\n    ""Share GL context""        : False,\n}\n\n\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(config):\n    """""" Set gl configuration """"""\n\n    s = """"\n    s += ""acca=0 "" # No accum buffer\n    s += ""red>=%d "" % config.red_size\n    s += ""green>=%d "" % config.green_size\n    s += ""blue>=%d "" % config.blue_size\n    s += ""alpha>=%d "" % config.alpha_size\n    s += ""depth>=%d "" % config.depth_size\n    s += ""stencil~%d "" % config.stencil_size\n    if config.double_buffer:\n        s += ""double=1 ""\n    else:\n        s += ""single=1 ""\n    s += ""stereo=%d "" % config.stereo\n    s += ""samples~%d "" % config.samples\n\n    glut.glutInitDisplayString(s)\n\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n\n    def __init__( self, width=256, height=256, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n\n        if vsync:\n            log.warn(\'vsync not implemented for freeglut backend\')\n\n        if len(__windows__) > 0:\n            log.critical(\n                """"""OSXGLUT backend is unstable with more than one window.\\n""""""\n                """"""Exiting..."""""")\n            sys.exit(0)\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        if config is None:\n            config = configuration.Configuration()\n        set_configuration(config)\n\n        self._native_window = glut.glutCreateWindow( self._title )\n        if bool(glut.glutSetOption):\n            glut.glutSetOption(glut.GLUT_ACTION_ON_WINDOW_CLOSE,\n                               glut.GLUT_ACTION_CONTINUE_EXECUTION)\n            glut.glutSetOption(glut.GLUT_ACTION_GLUTMAINLOOP_RETURNS,\n                               glut.GLUT_ACTION_CONTINUE_EXECUTION)\n        glut.glutWMCloseFunc( self._close )\n        glut.glutDisplayFunc( self._display )\n        glut.glutReshapeFunc( self._reshape )\n        glut.glutKeyboardFunc( self._keyboard )\n        glut.glutKeyboardUpFunc( self._keyboard_up )\n        glut.glutMouseFunc( self._mouse )\n        glut.glutMotionFunc( self._motion )\n        glut.glutPassiveMotionFunc( self._passive_motion )\n        glut.glutVisibilityFunc( self._visibility )\n        glut.glutEntryFunc( self._entry )\n        glut.glutSpecialFunc( self._special )\n        glut.glutSpecialUpFunc( self._special_up )\n        glut.glutReshapeWindow( self._width, self._height )\n        if visible:\n            glut.glutShowWindow()\n        else:\n            glut.glutHideWindow()\n\n        # This ensures glutCheckLoop never blocks\n        def on_idle(): pass\n        glut.glutIdleFunc(on_idle)\n\n        __windows__.append(self)\n\n\n    def _keyboard( self, code, x, y ):\n        symbol = self._keyboard_translate(code)\n        modifiers = glut.glutGetModifiers()\n        modifiers = self._modifiers_translate(modifiers)\n        self.dispatch_event(\'on_key_press\', symbol, modifiers)\n\n    def _keyboard_up( self, code, x, y ):\n        modifiers = glut.glutGetModifiers()\n        self.dispatch_event(\'on_key_release\',\n                            self._keyboard_translate(code),\n                            self._modifiers_translate(modifiers))\n\n    def _special( self, code, x, y ):\n        modifiers = glut.glutGetModifiers()\n        self.dispatch_event(\'on_key_press\',\n                            self._keyboard_translate(code),\n                            self._modifiers_translate(modifiers))\n\n    def _special_up( self, code, x, y ):\n        modifiers = glut.glutGetModifiers()\n        self.dispatch_event(\'on_key_release\',\n                            self._keyboard_translate(code),\n                            self._modifiers_translate(modifiers))\n\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if modifiers & glut.GLUT_ACTIVE_SHIFT:\n            _modifiers |=  window.key.MOD_SHIFT\n        if modifiers & glut.GLUT_ACTIVE_CTRL:\n            _modifiers |=  window.key.MOD_CTRL\n        if modifiers & glut.GLUT_ACTIVE_ALT:\n            _modifiers |=  window.key.MOD_ALT\n        return _modifiers\n\n\n    def _keyboard_translate( self, code ):\n        ascii = ord(code.lower())\n        if (0x020 <= ascii <= 0x040) or (0x05b <= ascii <= 0x07e):\n            return ascii\n        elif ascii <= 0x020:\n            code = ascii\n        return __key_map__.get(code, window.key.UNKNOWN)\n\n\n    def _display( self ):\n        pass\n\n    def _close( self ):\n        __windows__.remove(self)\n        # WARNING: This does not work on OSX 10.9 (seg fault or bus error)\n        # glut.glutDestroyWindow(self._native_window)\n        glut.glutSetWindow(self._native_window)\n        glut.glutHideWindow()\n        for i in range(len(self._timer_stack)):\n            handler, interval = self._timer_stack[i]\n            self._clock.unschedule(handler)\n        self.dispatch_event(\'on_close\')\n\n    def _reshape(self, width, height):\n        self._width  = glut.glutGet(glut.GLUT_WINDOW_WIDTH)\n        self._height = glut.glutGet(glut.GLUT_WINDOW_HEIGHT)\n        self.dispatch_event(\'on_resize\', self._width, self._height)\n\n    def _visibility(self, state):\n        if state == glut.GLUT_VISIBLE:\n            self.dispatch_event(\'on_show\')\n        elif state == glut.GLUT_NOT_VISIBLE:\n            self.dispatch_event(\'on_hide\')\n\n    def _entry(self, state):\n        if state == glut.GLUT_ENTERED:\n            self.dispatch_event(\'on_enter\')\n        elif state == glut.GLUT_LEFT:\n            self.dispatch_event(\'on_leave\')\n\n\n    def _mouse(self, button, state, x, y):\n        button = __mouse_map__.get(button, window.mouse.UNKNOWN)\n        if state == glut.GLUT_UP:\n            self._button = 0\n            self._mouse_x = x\n            self._mouse_y = y\n            self.dispatch_event(\'on_mouse_release\', x, y, button)\n        elif state == glut.GLUT_DOWN:\n            self._button = button\n            self._mouse_x = x\n            self._mouse_y = y\n            if button == 3:\n                self._button = 0\n                self.dispatch_event(\'on_mouse_scroll\', x, y, 0, 1)\n            elif button == 4:\n                self._button = 0\n                self.dispatch_event(\'on_mouse_scroll\', x, y, 0, -1)\n            else:\n                self.dispatch_event(\'on_mouse_press\', x, y, button)\n\n    def _motion(self, x, y):\n        dx = x - self._mouse_x\n        dy = y - self._mouse_y\n        self._mouse_x = x\n        self._mouse_y = y\n        self.dispatch_event(\'on_mouse_drag\', x, y, dx, dy, self._button)\n\n\n    def _passive_motion(self, x, y):\n        dx = x - self._mouse_x\n        dy = y - self._mouse_y\n        self._mouse_x = x\n        self._mouse_y = y\n        self.dispatch_event(\'on_mouse_motion\', x, y, dx, dy)\n\n\n    def close(self):\n        self._close()\n\n    def show(self):\n        self.activate()\n        glut.glutShowWindow()\n        self.dispatch_event(\'on_show\')\n\n\n    def hide(self):\n        self.activate()\n        glut.glutHideWindow()\n        self.dispatch_event(\'on_hide\')\n\n\n    def set_title(self, title):\n        self.activate()\n        glut.glutSetWindowTitle( title )\n        self._title = title\n\n    def get_title(self, title):\n        return self._title\n\n    def set_size(self, width, height):\n        self.activate()\n        glut.glutReshapeWindow(width, height)\n\n    def get_size(self):\n        self.activate()\n        self._width  = glut.glutGet( glut.GLUT_WINDOW_WIDTH )\n        self._height = glut.glutGet( glut.GLUT_WINDOW_HEIGHT )\n        return self._width, self._height\n\n    def set_position(self, x, y):\n        glut.glutPositionWindow( x, y )\n\n\n    def get_position(self):\n        glut.glutSetWindow( self._native_window )\n        self._x = glut.glutGet( glut.GLUT_WINDOW_W )\n        self._y = glut.glutGet( glut.GLUT_WINDOW_Y )\n        return self._x, self._y\n\n    def swap(self):\n        glut.glutSwapBuffers()\n\n    def activate(self):\n        glut.glutSetWindow(self._native_window)\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n\n    # Poll for and process events\n    glut.glutMainLoopEvent()\n\n    for window in __windows__:\n        window.activate()\n\n        # Dispatch the main draw event\n        window.dispatch_event(\'on_draw\', dt)\n\n        # Dispatch the idle event\n        window.dispatch_event(\'on_idle\', dt)\n\n        # Swap buffers\n        window.swap()\n\n    return len(__windows__)\n'"
glumpy/app/window/backends/backend_glfw.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n`GLFW <http://www.glfw.org>`_ is an Open Source, multi-platform library for\ncreating windows with OpenGL contexts and receiving input and events. It is\neasy to integrate into existing applications and does not lay claim to the main\nloop.\n\n**Usage**\n\n  .. code:: python\n\n     from glumpy import app\n\n     app.use(""glfw"")\n     window = app.Window()\n\n\n**Capability**\n\n========================== ======== ======================== ========\nMultiple windows              \xe2\x9c\x93     Set GL API                  \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nNon-decorated windows         \xe2\x9c\x93     Set GL Profile              \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nResize windows                \xe2\x9c\x93     Share GL Context            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nMove windows                  \xe2\x9c\x93     Unicode handling            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nFullscreen                    \xe2\x9c\x93     Scroll event                \xe2\x9c\x93\n========================== ======== ======================== ========\n""""""\nimport os, sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""GLFW""\n\n# Backend version (if available)\n__version__ = """"\n\n# Backend availability\n__availability__ = False\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Active windows\n__windows__ = []\n\n# Windows scheduled to be destroyed\n__windows_to_remove__ = []\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    if not __initialized__:\n        # glfw might change dir on initialization (feature, not a bug)\n        cwd = os.getcwd()\n        glfw.glfwInit()\n        os.chdir(cwd)\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    glfw.glfwTerminate()\n    __initialized__ = False\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    from glumpy.ext import glfw\n    __availability__ = True\n    __version__ = (""%d.%d.%d"") % glfw.version\n    __init__()\n\n    __mouse_map__ = { glfw.GLFW_MOUSE_BUTTON_LEFT:   window.mouse.LEFT,\n                      glfw.GLFW_MOUSE_BUTTON_MIDDLE: window.mouse.MIDDLE,\n                      glfw.GLFW_MOUSE_BUTTON_RIGHT:  window.mouse.RIGHT }\n\n    __key_map__   = { glfw.GLFW_KEY_ESCAPE:        window.key.ESCAPE,\n                      glfw.GLFW_KEY_ENTER:         window.key.ENTER,\n                      glfw.GLFW_KEY_TAB:           window.key.TAB,\n                      glfw.GLFW_KEY_BACKSPACE:     window.key.BACKSPACE,\n                      glfw.GLFW_KEY_INSERT:        window.key.INSERT,\n                      glfw.GLFW_KEY_DELETE:        window.key.DELETE,\n                      glfw.GLFW_KEY_RIGHT:         window.key.RIGHT,\n                      glfw.GLFW_KEY_LEFT:          window.key.LEFT,\n                      glfw.GLFW_KEY_DOWN:          window.key.DOWN,\n                      glfw.GLFW_KEY_UP:            window.key.UP,\n                      glfw.GLFW_KEY_PAGE_UP:       window.key.PAGEUP,\n                      glfw.GLFW_KEY_PAGE_DOWN:     window.key.PAGEDOWN,\n                      glfw.GLFW_KEY_HOME:          window.key.HOME,\n                      glfw.GLFW_KEY_END:           window.key.END,\n                      glfw.GLFW_KEY_CAPS_LOCK:     window.key.CAPSLOCK,\n                      glfw.GLFW_KEY_PRINT_SCREEN:  window.key.PRINT,\n                      glfw.GLFW_KEY_PAUSE:         window.key.PAUSE,\n                      glfw.GLFW_KEY_F1:            window.key.F1,\n                      glfw.GLFW_KEY_F2:            window.key.F2,\n                      glfw.GLFW_KEY_F3:            window.key.F3,\n                      glfw.GLFW_KEY_F4:            window.key.F4,\n                      glfw.GLFW_KEY_F5:            window.key.F5,\n                      glfw.GLFW_KEY_F6:            window.key.F6,\n                      glfw.GLFW_KEY_F7:            window.key.F7,\n                      glfw.GLFW_KEY_F8:            window.key.F8,\n                      glfw.GLFW_KEY_F9:            window.key.F9,\n                      glfw.GLFW_KEY_F10:           window.key.F10,\n                      glfw.GLFW_KEY_F11:           window.key.F11,\n                      glfw.GLFW_KEY_F12:           window.key.F12 }\n\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : True,\n    ""Window size get/set""     : True,\n    ""Multiple windows""        : True,\n    ""Mouse scroll events""     : True,\n    ""Non-decorated window""    : True,\n    ""Non-sizeable window""     : True,\n    ""Fullscreen mode""         : True,\n    ""Unicode processing""      : True,\n    ""Set GL version""          : True,\n    ""Set GL profile""          : True,\n    ""Share GL context""        : True,\n}\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(config):\n    """""" Set gl configuration for GLFW """"""\n\n    glfw.glfwWindowHint( glfw.GLFW_REFRESH_RATE, 0 )\n\n    glfw.glfwWindowHint(glfw.GLFW_RED_BITS, config.red_size)\n    glfw.glfwWindowHint(glfw.GLFW_GREEN_BITS, config.green_size)\n    glfw.glfwWindowHint(glfw.GLFW_BLUE_BITS, config.blue_size)\n    glfw.glfwWindowHint(glfw.GLFW_ALPHA_BITS, config.alpha_size)\n\n    glfw.glfwWindowHint(glfw.GLFW_ACCUM_RED_BITS, 0)\n    glfw.glfwWindowHint(glfw.GLFW_ACCUM_GREEN_BITS, 0)\n    glfw.glfwWindowHint(glfw.GLFW_ACCUM_BLUE_BITS, 0)\n    glfw.glfwWindowHint(glfw.GLFW_ACCUM_ALPHA_BITS, 0)\n\n    glfw.glfwWindowHint(glfw.GLFW_DEPTH_BITS, config.depth_size)\n    glfw.glfwWindowHint(glfw.GLFW_STENCIL_BITS, config.stencil_size)\n    glfw.glfwWindowHint(glfw.GLFW_SRGB_CAPABLE, config.srgb)\n    glfw.glfwWindowHint(glfw.GLFW_SAMPLES, config.samples)\n    glfw.glfwWindowHint(glfw.GLFW_STEREO, config.stereo)\n\n    if config.api in (""ES"", ""es""):\n        glfw.glfwWindowHint(glfw.GLFW_CLIENT_API,\n                            glfw.GLFW_OPENGL_ES_API)\n    else:\n        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR,\n                            config.major_version)\n        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR,\n                            config.minor_version)\n\n        if config.major_version >= 3 and config.profile == ""core"":\n            glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,\n                                glfw.GLFW_OPENGL_CORE_PROFILE)\n            glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, True)\n        elif config.major_version >= 3 and config.profile == ""compatibility"":\n            glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,\n                                glfw.GLFW_OPENGL_COMPAT_PROFILE)\n        else:\n            glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,\n                                glfw.GLFW_OPENGL_ANY_PROFILE)\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n\n    def __init__( self, width=512, height=512, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        # Whether hidpi is active\n        self._hidpi = False\n\n        def on_error(error, message):\n            log.warning(message)\n        glfw.glfwSetErrorCallback(on_error)\n\n        glfw.glfwWindowHint(glfw.GLFW_RESIZABLE, True)\n        glfw.glfwWindowHint(glfw.GLFW_DECORATED, True)\n        glfw.glfwWindowHint(glfw.GLFW_VISIBLE, True)\n        if not decoration:\n            glfw.glfwWindowHint(glfw.GLFW_DECORATED, False)\n        if not visible:\n            glfw.glfwWindowHint(glfw.GLFW_VISIBLE, False)\n\n        if config is None:\n            config = configuration.Configuration()\n        set_configuration(config)\n\n        monitor = glfw.glfwGetMonitors()[0] if fullscreen else None\n        self._native_window = glfw.glfwCreateWindow( self._width, self._height,\n                                                     self._title, monitor, None)\n\n        if not self._native_window:\n            log.critical(""Window creation failed"")\n            __exit__()\n            sys.exit()\n\n        glfw.glfwMakeContextCurrent(self._native_window)\n        glfw.glfwSwapInterval(1 if vsync else 0)\n\n        # OSX: check framebuffer size / window size. On retina display, they\n        #      can be different so we try to correct window size such as having\n        #      the framebuffer size of the right size\n        w,h = glfw.glfwGetFramebufferSize(self._native_window)\n        if w != width or h!= height:\n            width, height  = width//2, height//2\n            glfw.glfwSetWindowSize(self._native_window, width, height)\n            log.info(""HiDPI detected, fixing window size"")\n            self._hidpi = True\n\n\n        def on_framebuffer_resize(win, width, height):\n            self._width, self._height = width, height\n            self.dispatch_event(\'on_resize\', width, height)\n        glfw.glfwSetFramebufferSizeCallback(self._native_window, on_framebuffer_resize)\n        # def on_resize(win, width, height):\n        #     self._width, self._height = width, height\n        #     self.dispatch_event(\'on_resize\', width, height)\n        # glfw.glfwSetWindowSizeCallback(self._native_window, on_resize)\n\n\n        def on_cursor_enter(win, entered):\n            if entered:\n                self.dispatch_event(\'on_enter\')\n            else:\n                self.dispatch_event(\'on_leave\')\n        glfw.glfwSetCursorEnterCallback(self._native_window, on_cursor_enter)\n\n\n        def on_window_close(win):\n            self.close()\n        glfw.glfwSetWindowCloseCallback(self._native_window, on_window_close)\n\n\n        def on_keyboard(win, key, scancode, action, mods):\n            symbol = self._keyboard_translate(key)\n            modifiers = self._modifiers_translate(mods)\n            if action in[glfw.GLFW_PRESS,glfw.GLFW_REPEAT]:\n                self.dispatch_event(\'on_key_press\', symbol, modifiers)\n            else:\n                self.dispatch_event(\'on_key_release\', symbol, modifiers)\n        glfw.glfwSetKeyCallback(self._native_window, on_keyboard)\n\n\n        def on_character(win, character):\n            self.dispatch_event(\'on_character\', u""%c"" % character)\n        glfw.glfwSetCharCallback(self._native_window, on_character)\n\n\n        def on_mouse_button(win, button, action, mods):\n            x,y = glfw.glfwGetCursorPos(win)\n            if self._hidpi:\n                x, y = 2*x, 2*y\n\n            button = __mouse_map__.get(button, window.mouse.UNKNOWN)\n            if action == glfw.GLFW_RELEASE:\n                self._button = window.mouse.NONE\n                self._mouse_x = x\n                self._mouse_y = y\n                self.dispatch_event(\'on_mouse_release\', x, y, button)\n            elif action == glfw.GLFW_PRESS:\n                self._button = button\n                self._mouse_x = x\n                self._mouse_y = y\n                self.dispatch_event(\'on_mouse_press\', x, y, button)\n        glfw.glfwSetMouseButtonCallback(self._native_window, on_mouse_button)\n\n\n        def on_mouse_motion(win, x, y):\n            if self._hidpi:\n                x, y = 2*x, 2*y\n            dx = x - self._mouse_x\n            dy = y - self._mouse_y\n            self._mouse_x = x\n            self._mouse_y = y\n            if self._button != window.mouse.NONE:\n                self.dispatch_event(\'on_mouse_drag\', x, y, dx, dy, self._button)\n            else:\n                self.dispatch_event(\'on_mouse_motion\', x, y, dx, dy)\n        glfw.glfwSetCursorPosCallback(self._native_window, on_mouse_motion)\n\n\n        def on_scroll(win, xoffset, yoffset):\n            x,y = glfw.glfwGetCursorPos(win)\n            if self._hidpi:\n                x, y = 2*x, 2*y\n            self.dispatch_event(\'on_mouse_scroll\', x, y, xoffset, yoffset)\n        glfw.glfwSetScrollCallback( self._native_window, on_scroll )\n\n        self._width, self._height = self.get_size()\n        __windows__.append(self)\n\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if modifiers & glfw.GLFW_MOD_SHIFT:\n            _modifiers |=  window.key.MOD_SHIFT\n        if modifiers & glfw.GLFW_MOD_CONTROL:\n            _modifiers |=  window.key.MOD_CTRL\n        if modifiers & glfw.GLFW_MOD_ALT:\n            _modifiers |=  window.key.MOD_ALT\n        if modifiers & glfw.GLFW_MOD_SUPER:\n            _modifiers |=  window.key.MOD_COMMAND\n        self._modifiers = modifiers\n        return _modifiers\n\n    def _keyboard_translate( self, code ):\n        if (32 <= code <= 96) or code in [161,162]:\n            return code\n        return __key_map__.get(code, window.key.UNKNOWN)\n\n\n    def show(self):\n        glfw.glfwShowWindow( self._native_window )\n        self.dispatch_event(\'on_show\')\n\n    def hide(self):\n        glfw.glfwHideWindow( self._native_window )\n        self.dispatch_event(\'on_hide\')\n\n    def close(self):\n        glfw.glfwSetWindowShouldClose(self._native_window, True)\n        __windows__.remove(self)\n        __windows_to_remove__.append(self)\n        for i in range(len(self._timer_stack)):\n            handler, interval = self._timer_stack[i]\n            self._clock.unschedule(handler)\n        self.dispatch_event(\'on_close\')\n\n    def destroy(self):\n        glfw.glfwDestroyWindow(self._native_window)\n\n    def set_title(self, title):\n        glfw.glfwSetWindowTitle( self._native_window, title)\n        self._title = title\n\n    def get_title(self, title):\n        return self._title\n\n    def set_size(self, width, height):\n        glfw.glfwSetWindowSize(self._native_window, width, height)\n        self._width, self._height = glfw.glfwGetFramebufferSize(self._native_window)\n\n    def get_size(self):\n        # self._width, self._height = glfw.glfwGetWindowSize(self._native_window)\n        self._width, self._height = glfw.glfwGetFramebufferSize(self._native_window)\n        return self._width, self._height\n\n    def set_position(self, x, y):\n        glfw.glfwSetWindowPos(self._native_window, x, y)\n        self._x, self._y = glfw.glfwGetWindowPos(self._native_window)\n\n    def get_position(self):\n        self._x, self._y = glfw.glfwGetWindowPos(self._native_window)\n        return self._x, self._y\n\n    def swap(self):\n        glfw.glfwSwapBuffers(self._native_window)\n\n    def activate(self):\n        glfw.glfwMakeContextCurrent(self._native_window)\n\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n\n    # Poll for and process events\n    glfw.glfwPollEvents()\n\n    for window in __windows__:\n        # Make window active\n        window.activate()\n\n        # Dispatch the main draw event\n        window.dispatch_event(\'on_draw\', dt)\n\n        # Dispatch the idle event\n        window.dispatch_event(\'on_idle\', dt)\n\n        # Swap buffers\n        window.swap()\n\n    for window in __windows_to_remove__:\n        window.destroy()\n        __windows_to_remove__.remove(window)\n\n    return len(__windows__)\n'"
glumpy/app/window/backends/backend_osxglut.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nThe OSX GLUT backend is only available Apple machine and differs a bit from\nthe original glut implementation. It is very limited, deprecated and does not\nsupport the mouse scroll event. After OSX El Capitan, it will most likely\nbecome unavailable.\n\n**Usage**\n\n  .. code:: python\n\n     from glumpy import app\n\n     app.use(""osxglut"")\n     window = app.Window()\n\n\n**Capability**\n\n========================== ======== ======================== ========\nMultiple windows              \xe2\x9c\x98     Set GL API                  \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nNon-decorated windows         \xe2\x9c\x93     Set GL Profile              \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nResize windows                \xe2\x9c\x93     Share GL Context            \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nMove windows                  \xe2\x9c\x93     Unicode handling            \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nFullscreen                    \xe2\x9c\x93     Scroll event                \xe2\x9c\x98\n========================== ======== ======================== ========\n""""""\nimport sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""OSX GLUT""\n\n# Backend version (if available)\n__version__ = """"\n\n# Backend availability\n__availability__ = False\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Active windows\n__windows__ = []\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    if not __initialized__:\n        glut.glutInit(sys.argv)\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    # Not an error, we cannot really terminate glut\n    __initialized__ = True\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    import sys\n    import OpenGL.GLUT as glut\n    if sys.platform == \'darwin\':\n        import OpenGL.platform as platform\n        try:\n            glutCheckLoop = platform.createBaseFunction(\n                \'glutCheckLoop\', dll=platform.GLUT, resultType=None,\n                argTypes=[], doc=\'glutCheckLoop( ) -> None\', argNames=(), )\n        except AttributeError:\n            __availability__ = False\n            __version__ = None\n        __availability__ = True\n        __version__ = ""%d"" % glut.GLUT_API_VERSION\n        __init__()\n\n        __mouse_map__ = { glut.GLUT_LEFT_BUTTON:   window.mouse.LEFT,\n                          glut.GLUT_MIDDLE_BUTTON: window.mouse.MIDDLE,\n                          glut.GLUT_RIGHT_BUTTON:  window.mouse.RIGHT }\n\n        __key_map__   = { 0x008:                   window.key.BACKSPACE,\n                          0x009:                   window.key.TAB,\n                          0x00A:                   window.key.LINEFEED,\n                          0x00C:                   window.key.CLEAR,\n                          0x00D:                   window.key.RETURN,\n                          0x018:                   window.key.CANCEL,\n                          0x01B:                   window.key.ESCAPE,\n                          glut.GLUT_KEY_F1:        window.key.F1,\n                          glut.GLUT_KEY_F2:        window.key.F2,\n                          glut.GLUT_KEY_F3:        window.key.F3,\n                          glut.GLUT_KEY_F4:        window.key.F4,\n                          glut.GLUT_KEY_F5:        window.key.F5,\n                          glut.GLUT_KEY_F6:        window.key.F6,\n                          glut.GLUT_KEY_F7:        window.key.F7,\n                          glut.GLUT_KEY_F8:        window.key.F8,\n                          glut.GLUT_KEY_F9:        window.key.F9,\n                          glut.GLUT_KEY_F10:       window.key.F10,\n                          glut.GLUT_KEY_F11:       window.key.F11,\n                          glut.GLUT_KEY_F12:       window.key.F12,\n                          glut.GLUT_KEY_LEFT:      window.key.LEFT,\n                          glut.GLUT_KEY_UP:        window.key.UP,\n                          glut.GLUT_KEY_RIGHT:     window.key.RIGHT,\n                          glut.GLUT_KEY_DOWN:      window.key.DOWN,\n                          glut.GLUT_KEY_PAGE_UP:   window.key.PAGEUP,\n                          glut.GLUT_KEY_PAGE_DOWN: window.key.PAGEDOWN,\n                          glut.GLUT_KEY_HOME:      window.key.HOME,\n                          glut.GLUT_KEY_END:       window.key.END,\n                          glut.GLUT_KEY_INSERT:    window.key.INSERT }\n    else:\n        __availability__ = False\n        __version__ = None\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : True,\n    ""Window size get/set""     : True,\n    ""Multiple windows""        : False,\n    ""Mouse scroll events""     : False,\n    ""Non-decorated window""    : True,\n    ""Non-sizeable window""     : False,\n    ""Fullscreen mode""         : True,\n    ""Unicode processing""      : False,\n    ""Set GL version""          : False,\n    ""Set GL profile""          : False,\n    ""Share GL context""        : False,\n}\n\n\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(config):\n    """""" Set gl configuration """"""\n\n    s = """"\n    s += ""acca=0 "" # No accum buffer\n    s += ""red>=%d "" % config.red_size\n    s += ""green>=%d "" % config.green_size\n    s += ""blue>=%d "" % config.blue_size\n    s += ""alpha>=%d "" % config.alpha_size\n    s += ""depth>=%d "" % config.depth_size\n    s += ""stencil~%d "" % config.stencil_size\n    if config.double_buffer:\n        s += ""double=1 ""\n    else:\n        s += ""single=1 ""\n    s += ""stereo=%d "" % config.stereo\n    s += ""samples~%d "" % config.samples\n\n    glut.glutInitDisplayString(s)\n\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n\n    def __init__( self, width=256, height=256, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n\n        if vsync:\n            log.warn(\'vsync not implemented for osxglut backend\')\n\n        if len(__windows__) > 0:\n            log.critical(\n                """"""OSXGLUT backend is unstable with more than one window.\\n""""""\n                """"""Exiting..."""""")\n            sys.exit(0)\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        if config is None:\n            config = configuration.Configuration()\n        set_configuration(config)\n\n        self._native_window = glut.glutCreateWindow( self._title )\n        if bool(glut.glutSetOption):\n            glut.glutSetOption(glut.GLUT_ACTION_ON_WINDOW_CLOSE,\n                               glut.GLUT_ACTION_CONTINUE_EXECUTION)\n            glut.glutSetOption(glut.GLUT_ACTION_GLUTMAINLOOP_RETURNS,\n                               glut.GLUT_ACTION_CONTINUE_EXECUTION)\n        glut.glutWMCloseFunc( self._close )\n        glut.glutDisplayFunc( self._display )\n        glut.glutReshapeFunc( self._reshape )\n        glut.glutKeyboardFunc( self._keyboard )\n        glut.glutKeyboardUpFunc( self._keyboard_up )\n        glut.glutMouseFunc( self._mouse )\n        glut.glutMotionFunc( self._motion )\n        glut.glutPassiveMotionFunc( self._passive_motion )\n        glut.glutVisibilityFunc( self._visibility )\n        glut.glutEntryFunc( self._entry )\n        glut.glutSpecialFunc( self._special )\n        glut.glutSpecialUpFunc( self._special_up )\n        glut.glutReshapeWindow( self._width, self._height )\n        if visible:\n            glut.glutShowWindow()\n        else:\n            glut.glutHideWindow()\n\n        # This ensures glutCheckLoop never blocks\n        def on_idle(): pass\n        glut.glutIdleFunc(on_idle)\n\n        __windows__.append(self)\n\n\n    def _keyboard( self, code, x, y ):\n        symbol = self._keyboard_translate(code)\n        modifiers = glut.glutGetModifiers()\n        modifiers = self._modifiers_translate(modifiers)\n        self.dispatch_event(\'on_key_press\', symbol, modifiers)\n\n    def _keyboard_up( self, code, x, y ):\n        modifiers = glut.glutGetModifiers()\n        self.dispatch_event(\'on_key_release\',\n                            self._keyboard_translate(code),\n                            self._modifiers_translate(modifiers))\n\n    def _special( self, code, x, y ):\n        modifiers = glut.glutGetModifiers()\n        self.dispatch_event(\'on_key_press\',\n                            self._keyboard_translate(code),\n                            self._modifiers_translate(modifiers))\n\n    def _special_up( self, code, x, y ):\n        modifiers = glut.glutGetModifiers()\n        self.dispatch_event(\'on_key_release\',\n                            self._keyboard_translate(code),\n                            self._modifiers_translate(modifiers))\n\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if modifiers & glut.GLUT_ACTIVE_SHIFT:\n            _modifiers |=  window.key.MOD_SHIFT\n        if modifiers & glut.GLUT_ACTIVE_CTRL:\n            _modifiers |=  window.key.MOD_CTRL\n        if modifiers & glut.GLUT_ACTIVE_ALT:\n            _modifiers |=  window.key.MOD_ALT\n        return _modifiers\n\n\n    def _keyboard_translate( self, code ):\n        ascii = ord(code.lower())\n        if (0x020 <= ascii <= 0x040) or (0x05b <= ascii <= 0x07e):\n            return ascii\n        elif ascii <= 0x020:\n            code = ascii\n        return __key_map__.get(code, window.key.UNKNOWN)\n\n\n    def _display( self ):\n        pass\n\n    def _close( self ):\n        __windows__.remove(self)\n        # WARNING: This does not work on OSX 10.9 (seg fault or bus error)\n        # glut.glutDestroyWindow(self._native_window)\n        glut.glutSetWindow(self._native_window)\n        glut.glutHideWindow()\n        for i in range(len(self._timer_stack)):\n            handler, interval = self._timer_stack[i]\n            self._clock.unschedule(handler)\n        self.dispatch_event(\'on_close\')\n\n    def _reshape(self, width, height):\n        self._width  = glut.glutGet(glut.GLUT_WINDOW_WIDTH)\n        self._height = glut.glutGet(glut.GLUT_WINDOW_HEIGHT)\n        self.dispatch_event(\'on_resize\', self._width, self._height)\n\n    def _visibility(self, state):\n        if state == glut.GLUT_VISIBLE:\n            self.dispatch_event(\'on_show\')\n        elif state == glut.GLUT_NOT_VISIBLE:\n            self.dispatch_event(\'on_hide\')\n\n    def _entry(self, state):\n        if state == glut.GLUT_ENTERED:\n            self.dispatch_event(\'on_enter\')\n        elif state == glut.GLUT_LEFT:\n            self.dispatch_event(\'on_leave\')\n\n\n    def _mouse(self, button, state, x, y):\n        button = __mouse_map__.get(button, window.mouse.UNKNOWN)\n        if state == glut.GLUT_UP:\n            self._button = 0\n            self._mouse_x = x\n            self._mouse_y = y\n            self.dispatch_event(\'on_mouse_release\', x, y, button)\n        elif state == glut.GLUT_DOWN:\n            self._button = button\n            self._mouse_x = x\n            self._mouse_y = y\n            if button == 3:\n                self._button = 0\n                self.dispatch_event(\'on_mouse_scroll\', x, y, 0, 1)\n            elif button == 4:\n                self._button = 0\n                self.dispatch_event(\'on_mouse_scroll\', x, y, 0, -1)\n            else:\n                self.dispatch_event(\'on_mouse_press\', x, y, button)\n\n    def _motion(self, x, y):\n        dx = x - self._mouse_x\n        dy = y - self._mouse_y\n        self._mouse_x = x\n        self._mouse_y = y\n        self.dispatch_event(\'on_mouse_drag\', x, y, dx, dy, self._button)\n\n\n    def _passive_motion(self, x, y):\n        dx = x - self._mouse_x\n        dy = y - self._mouse_y\n        self._mouse_x = x\n        self._mouse_y = y\n        self.dispatch_event(\'on_mouse_motion\', x, y, dx, dy)\n\n\n    def close(self):\n        self._close()\n\n    def show(self):\n        self.activate()\n        glut.glutShowWindow()\n        self.dispatch_event(\'on_show\')\n\n\n    def hide(self):\n        self.activate()\n        glut.glutHideWindow()\n        self.dispatch_event(\'on_hide\')\n\n\n    def set_title(self, title):\n        self.activate()\n        glut.glutSetWindowTitle( title )\n        self._title = title\n\n    def get_title(self, title):\n        return self._title\n\n    def set_size(self, width, height):\n        self.activate()\n        glut.glutReshapeWindow(width, height)\n\n    def get_size(self):\n        self.activate()\n        self._width  = glut.glutGet( glut.GLUT_WINDOW_WIDTH )\n        self._height = glut.glutGet( glut.GLUT_WINDOW_HEIGHT )\n        return self._width, self._height\n\n    def set_position(self, x, y):\n        glut.glutPositionWindow( x, y )\n\n\n    def get_position(self):\n        glut.glutSetWindow( self._native_window )\n        self._x = glut.glutGet( glut.GLUT_WINDOW_W )\n        self._y = glut.glutGet( glut.GLUT_WINDOW_Y )\n        return self._x, self._y\n\n    def swap(self):\n        glut.glutSwapBuffers()\n\n    def activate(self):\n        glut.glutSetWindow(self._native_window)\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n\n    # Poll for and process events\n    glut.glutCheckLoop()\n\n    for window in __windows__:\n        window.activate()\n\n        # Dispatch the main draw event\n        window.dispatch_event(\'on_draw\', dt)\n\n        # Dispatch the idle event\n        window.dispatch_event(\'on_idle\', dt)\n\n        # Swap buffers\n        window.swap()\n\n    return len(__windows__)\n'"
glumpy/app/window/backends/backend_pyglet.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n`Pyglet <www.pyglet.org>`_ is a pure python cross-platform application\nframework intended for game development. It supports windowing, user interface\nevent handling, OpenGL graphics, loading images and videos and playing sounds\nand music. It works on Windows, OS X and Linux.\n\n**Usage**\n\n  .. code:: python\n\n     from glumpy import app\n\n     app.use(""pyglet"")\n     window = app.Window()\n\n\n**Capability**\n\n========================== ======== ======================== ========\nMultiple windows              \xe2\x9c\x93     Set GL API                  \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nNon-decorated windows         \xe2\x9c\x93     Set GL Profile              \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nResize windows                \xe2\x9c\x93     Share GL Context            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nMove windows                  \xe2\x9c\x93     Unicode handling            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nFullscreen                    \xe2\x9c\x93     Scroll event                \xe2\x9c\x93\n========================== ======== ======================== ========\n""""""\nimport sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""Pyglet""\n\n# Backend version (if available)\n__version__ = """"\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Backend availability\n__availability__ = False\n\n# Active windows\n__windows__ = []\n\n# Default configuration\n__configuration__ = None\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    # Not an error, we cannot really terminate pyglet\n    __initialized__ = True\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    import pyglet\n    # prevent pyglet from failing if sphinx is loaded\n    if hasattr(sys, \'is_pyglet_docgen\'):\n        sys.is_pyglet_docgen = False\n    if hasattr(sys, \'is_epydoc\'):\n        sys.is_epydoc = False\n    __availability__ = True\n    __version__ = pyglet.version\n    __init__()\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : True,\n    ""Window size get/set""     : True,\n    ""Multiple windows""        : True,\n    ""Mouse scroll events""     : True,\n    ""Non-decorated window""    : True,\n    ""Non-sizeable window""     : True,\n    ""Fullscreen mode""         : True,\n    ""Unicode processing""      : True,\n    ""Set GL version""          : False,\n    ""Set GL profile""          : False,\n    ""Share GL context""        : True,\n}\n\n\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(config):\n    """""" Set gl configuration """"""\n\n    global __configuration__\n\n    __configuration__ = pyglet.gl.Config()\n\n    __configuration__.red_size = config.red_size\n    __configuration__.green_size = config.green_size\n    __configuration__.blue_size = config.blue_size\n    __configuration__.alpha_size = config.alpha_size\n\n    __configuration__.accum_red_size = 0\n    __configuration__.accum_green_size = 0\n    __configuration__.accum_blue_size = 0\n    __configuration__.accum_alpha_size = 0\n\n    __configuration__.depth_size = config.depth_size\n    __configuration__.stencil_size = config.stencil_size\n    __configuration__.double_buffer = config.double_buffer\n    __configuration__.stereo = config.stereo\n    __configuration__.samples = config.samples\n\n\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n\n\n    def __init__( self, width=256, height=256, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        if config is None:\n            config = configuration.Configuration()\n        set_configuration(config)\n\n        self._native_window = pyglet.window.Window(\n            width=self._width, height=self._height, caption=title,\n            resizable=True, vsync=vsync, config=__configuration__)\n\n        def on_mouse_drag(x, y, dx, dy, button, modifiers):\n            # BUGFIX\n            self.dispatch_event(""on_mouse_drag"", x, y, dx, -dy, button)\n        self._native_window.on_mouse_drag = on_mouse_drag\n\n        def on_mouse_enter(x, y):\n            y = self.height-y\n            self.dispatch_event(""on_enter"", x, y)\n        self._native_window.on_mouse_enter = on_mouse_enter\n\n        def on_mouse_leave(x, y):\n            y = self.height-y\n            self.dispatch_event(""on_leave"", x, y)\n        self._native_window.on_mouse_leave = on_mouse_leave\n\n        def on_mouse_motion(x, y, dx, dy):\n            self.dispatch_event(""on_mouse_motion"", x, y, dx, -dy)\n        self._native_window.on_mouse_motion = on_mouse_motion\n\n        def on_mouse_press(x, y, button, modifiers):\n            self.dispatch_event(""on_mouse_press"", x, y, button)\n        self._native_window.on_mouse_press = on_mouse_press\n\n        def on_mouse_release(x, y, button, modifiers):\n            self.dispatch_event(""on_mouse_release"", x, y, button)\n        self._native_window.on_mouse_release = on_mouse_release\n\n        def on_mouse_scroll(x, y, scroll_x, scroll_y):\n            # BUGFIX\n            y = self.height-y\n            self.dispatch_event(""on_mouse_scroll"", x, y, scroll_x, -scroll_y)\n        self._native_window.on_mouse_scroll = on_mouse_scroll\n\n        def on_resize(width, height):\n            self.dispatch_event(""on_resize"", width, height)\n        self._native_window.on_resize = on_resize\n\n        def on_show():\n            self.dispatch_event(""on_show"")\n        self._native_window.on_show = on_show\n\n        def on_hide():\n            self.dispatch_event(""on_hide"")\n        self._native_window.on_hide = on_hide\n\n        def on_close():\n            self.close()\n        self._native_window.on_close = on_close\n\n        def on_key_press(symbol, modifiers):\n            self.dispatch_event(""on_key_press"", symbol, modifiers)\n        self._native_window.on_key_press = on_key_press\n\n        def on_key_release(symbol, modifiers):\n            self.dispatch_event(""on_key_release"", symbol, modifiers)\n        self._native_window.on_key_release = on_key_release\n\n        def on_draw():\n            self.dispatch_event(""on_draw"")\n        self._native_window.on_draw = on_draw\n\n        __windows__.append(self)\n\n\n    def close(self):\n        self._native_window.close()\n        __windows__.remove(self)\n        for i in range(len(self._timer_stack)):\n            handler, interval = self._timer_stack[i]\n            self._clock.unschedule(handler)\n        self.dispatch_event(""on_close"")\n\n    def show(self):\n        self._native_window.set_visible(True)\n\n    def hide(self):\n        self._native_window.set_visible(False)\n\n    def set_fullscreen(self, state):\n        self._native_window.set_fullscreen(state)\n\n    def set_title(self, title):\n        self._native_window.set_caption(title)\n        self._title = title\n\n    def get_title(self, title):\n        return self._title\n\n    def set_size(self, width, height):\n        self._window.set_size(width, height)\n        self._width  = self._native_window.width\n        self._height = self._native_window.height\n\n    def get_size(self):\n        self._width  = self._native_window.width\n        self._height = self._native_window.height\n        return self._width, self._height\n\n    def set_position(self, x, y):\n        self._native_window.set_location(x,y)\n        self._x, self._y = self._native_window.get_location()\n\n    def get_position(self):\n        self._x, self._y = self._native_window.get_location()\n        return self._x, self._y\n\n    def swap(self):\n        self._native_window.flip()\n\n    def activate(self):\n        self._native_window.switch_to()\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n\n    for window in __windows__:\n\n        # Activate window\n        window.activate()\n\n        # Dispatch any pending event\n        window._native_window.dispatch_events()\n\n        # Dispatch the main draw event\n        window.dispatch_event(\'on_draw\', dt)\n\n        # Dispatch the idle event\n        window.dispatch_event(\'on_idle\', dt)\n\n        # Swap buffers\n        window.swap()\n\n    return len(__windows__)\n'"
glumpy/app/window/backends/backend_pyside.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n`PySide <http://pyside.github.io/docs/pyside/>`_ is the Python Qt bindings\nproject, providing access the complete Qt 4.8 framework as well as to generator\ntools for rapidly generating bindings for any C++ libraries.\n\n**Usage**\n\n  .. code:: python\n\n     from glumpy import app\n\n     app.use(""pyside"")\n     window = app.Window()\n\n\n**Capability**\n\n========================== ======== ======================== ========\nMultiple windows              \xe2\x9c\x93     Set GL API                  \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nNon-decorated windows         \xe2\x9c\x93     Set GL Profile              \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nResize windows                \xe2\x9c\x93     Share GL Context            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nMove windows                  \xe2\x9c\x93     Unicode handling            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nFullscreen                    \xe2\x9c\x93     Scroll event                \xe2\x9c\x93\n========================== ======== ======================== ========\n""""""\n\nimport os, sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""PySide""\n\n# Backend version (if available)\n__version__ = """"\n\n# Backend availability\n__availability__ = False\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Active windows\n__windows__ = []\n\n# GL Format\n__glformat__ = None\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    __app__ = QtGui.QApplication.instance()\n    if __app__ is None:\n        __app__ = QtGui.QApplication(sys.argv)\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    __initialized__ = False\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    from PySide import QtGui, QtCore, QtOpenGL\n    if not __initialized__:\n        __init__()\n    __availability__ = True\n    __version__ = QtCore.__version__\n\n    __mouse_map__ = { 0: window.mouse.LEFT,\n                      1: window.mouse.MIDDLE,\n                      2: window.mouse.RIGHT }\n\n    __key_map__ = { QtCore.Qt.Key_Left:      window.key.LEFT,\n                    QtCore.Qt.Key_Up:        window.key.UP,\n                    QtCore.Qt.Key_Right:     window.key.RIGHT,\n                    QtCore.Qt.Key_Down:      window.key.DOWN,\n                    QtCore.Qt.Key_PageUp:    window.key.PAGEUP,\n                    QtCore.Qt.Key_PageDown:  window.key.PAGEDOWN,\n                    QtCore.Qt.Key_Insert:    window.key.INSERT,\n                    QtCore.Qt.Key_Delete:    window.key.DELETE,\n                    QtCore.Qt.Key_Home:      window.key.HOME,\n                    QtCore.Qt.Key_End:       window.key.END,\n                    QtCore.Qt.Key_Escape:    window.key.ESCAPE,\n                    QtCore.Qt.Key_Backspace: window.key.BACKSPACE,\n                    QtCore.Qt.Key_F1:        window.key.F1,\n                    QtCore.Qt.Key_F2:        window.key.F2,\n                    QtCore.Qt.Key_F3:        window.key.F3,\n                    QtCore.Qt.Key_F4:        window.key.F4,\n                    QtCore.Qt.Key_F5:        window.key.F5,\n                    QtCore.Qt.Key_F6:        window.key.F6,\n                    QtCore.Qt.Key_F7:        window.key.F7,\n                    QtCore.Qt.Key_F8:        window.key.F8,\n                    QtCore.Qt.Key_F9:        window.key.F9,\n                    QtCore.Qt.Key_F10:       window.key.F10,\n                    QtCore.Qt.Key_F11:       window.key.F11,\n                    QtCore.Qt.Key_F12:       window.key.F12,\n                    QtCore.Qt.Key_Space:     window.key.SPACE,\n                    QtCore.Qt.Key_Enter:     window.key.ENTER,\n                    QtCore.Qt.Key_Return:    window.key.ENTER,\n                    QtCore.Qt.Key_Tab:       window.key.TAB }\n\n\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : True,\n    ""Window size get/set""     : True,\n    ""Multiple windows""        : True,\n    ""Mouse scroll events""     : True,\n    ""Non-decorated window""    : True,\n    ""Non-sizeable window""     : True,\n    ""Fullscreen mode""         : True,\n    ""Unicode processing""      : True,\n    ""Set GL version""          : True,\n    ""Set GL profile""          : True,\n    ""Share GL context""        : True,\n}\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(config):\n    global __glformat__\n\n    # WARNING: does not work on osx\n    # http://stackoverflow.com/questions/...\n    # ...7868882/enabling-opengl-core-profile-in-qt4-on-os-x\n\n    __glformat__ = QtOpenGL.QGLFormat()\n    __glformat__.setRedBufferSize(config.red_size)\n    __glformat__.setGreenBufferSize(config.green_size)\n    __glformat__.setBlueBufferSize(config.blue_size)\n    __glformat__.setAlphaBufferSize(config.alpha_size)\n    __glformat__.setAccum(False)\n    __glformat__.setRgba(True)\n\n    if config.double_buffer:\n        __glformat__.setDoubleBuffer(True)\n    else:\n        __glformat__.setDoubleBuffer(False)\n\n    if config.depth_size:\n        __glformat__.setDepth(True)\n        __glformat__.setDepthBufferSize(config.depth_size)\n    else:\n        __glformat__.setDepth(False)\n        __glformat__.setDepthBufferSize(0)\n\n    if config.stencil_size:\n        __glformat__.setStencil(True)\n        __glformat__.setStencilBufferSize(config.stencil_size)\n    else:\n        __glformat__.setStencil(False)\n        __glformat__.setStencilBufferSize(0)\n\n    if config.samples:\n        __glformat__.setSampleBuffers(True)\n        __glformat__.setSamples(config.samples)\n    else:\n        __glformat__.setSampleBuffers(False)\n        __glformat__.setSamples(0)\n    __glformat__.setStereo(config.stereo)\n\n    __glformat__.setVersion(config.major_version, config.minor_version)\n    if config.major_version >= 3 and config.profile == ""core"":\n        __glformat__.setProfile(__glformat__.CoreProfile)\n    elif config.major_version >= 3 and config.profile == ""compatibility"":\n        __glformat__.setProfile(__glformat__.CompatibilityProfile)\n    else:\n        __glformat__.setProfile(__glformat__.NoProfile)\n\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n    def __init__( self, width=256, height=256, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        if config is None:\n            config = configuration.Configuration()\n        set_configuration(config)\n\n        __glformat__.setSwapInterval(1 if vsync else 0)\n\n        self._native_app = QtGui.QApplication.instance()\n        if self._native_app is None:\n            self._native_app = QtGui.QApplication(sys.argv)\n\n        context = QtOpenGL.QGLContext(__glformat__)\n        if context.isValid():\n            self._native_window = QtOpenGL.QGLWidget(context)\n        else:\n            self._native_window = QtOpenGL.QGLWidget(__glformat__)\n\n        self._native_window.resize(width, height)\n        self._native_window.makeCurrent()\n        self._native_window.setAutoBufferSwap(False)\n        self._native_window.setMouseTracking(True)\n        self._native_window.setWindowTitle(self._title)\n        self._native_window.show()\n\n        def paint_gl():\n            self.dispatch_event(""on_draw"", 0.0)\n        self._native_window.paintGL = paint_gl\n\n        def resize_gl(width, height):\n            self.dispatch_event(""on_resize"", width, height)\n        self._native_window.resizeGL = resize_gl\n\n        def close_event(event):\n            __windows__.remove(self)\n            for i in range(len(self._timer_stack)):\n                handler, interval = self._timer_stack[i]\n                self._clock.unschedule(handler)\n            self.dispatch_event(""on_close"")\n        self._native_window.closeEvent = close_event\n\n        def mouse_press_event(event):\n            x = event.pos().x()\n            y = event.pos().y()\n            button = __mouse_map__.get(event.button(), window.mouse.UNKNOWN)\n            self._button = button\n            self._mouse_x = x\n            self._mouse_y = y\n            self.dispatch_event(""on_mouse_press"", x, y, button)\n        self._native_window.mousePressEvent = mouse_press_event\n\n        def mouse_release_event(event):\n            x = event.pos().x()\n            y = event.pos().y()\n            button = __mouse_map__.get(event.button(), window.mouse.UNKNOWN)\n            self._button = window.mouse.NONE\n            self._mouse_x = x\n            self._mouse_y = y\n            self.dispatch_event(""on_mouse_release"", x, y, button)\n        self._native_window.mouseReleaseEvent = mouse_release_event\n\n        def mouse_move_event(event):\n            x = event.pos().x()\n            y = event.pos().y()\n            dx = x - self._mouse_x\n            dy = y - self._mouse_y\n            self._mouse_x = x\n            self._mouse_y = y\n            if self._button is not window.mouse.NONE:\n                self.dispatch_event(\'on_mouse_drag\', x, y, dx, dy, self._button)\n            else:\n                self.dispatch_event(\'on_mouse_motion\', x, y, dx, dy)\n        self._native_window.mouseMoveEvent = mouse_move_event\n\n        def wheel_event(event):\n            if event.orientation == QtCore.Qt.Horizontal:\n                offset_x = event.delta()\n                offset_y = 0\n            else:\n                offset_x = 0\n                offset_y = event.delta()\n            x = event.pos().x()\n            y = event.pos().y()\n            self.dispatch_event(""on_mouse_scroll"", x, y, offset_x/10.0, offset_y/10.0)\n        self._native_window.wheelEvent = wheel_event\n\n        def key_press_event(event):\n            code = self._keyboard_translate(event.key())\n            modifiers = self._modifiers_translate(event.modifiers())\n            self.dispatch_event(""on_key_press"", code, modifiers)\n            self.dispatch_event(""on_character"", event.text())\n        self._native_window.keyPressEvent = key_press_event\n\n        def key_release_event(event):\n            code = self._keyboard_translate(event.key())\n            modifiers = self._modifiers_translate(event.modifiers())\n            self.dispatch_event(""on_key_release"", code, modifiers)\n        self._native_window.keyReleaseEvent = key_release_event\n\n        __windows__.append(self)\n\n\n    def _keyboard_translate( self, code ):\n        if code in __key_map__:\n            return __key_map__[code]\n        if 32 <= code <= 96 or code in [161,162]:\n            return code\n        return window.key.UNKNOWN\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if QtCore.Qt.ShiftModifier & modifiers:\n            _modifiers |= window.key.MOD_SHIFT\n        if QtCore.Qt.ControlModifier & modifiers:\n            _modifiers |= window.key.MOD_CONTROL\n        if QtCore.Qt.AltModifier & modifiers:\n            _modifiers |= window.key.MOD_ALT\n        if QtCore.Qt.MetaModifier & modifiers:\n            _modifiers |= window.key.MOD_META\n        return _modifiers\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if QtCore.Qt.ShiftModifier & modifiers:\n            _modifiers |= window.key.MOD_SHIFT\n        if QtCore.Qt.ControlModifier & modifiers:\n            _modifiers |= window.key.MOD_CONTROL\n        if QtCore.Qt.AltModifier & modifiers:\n            _modifiers |= window.key.MOD_ALT\n        if QtCore.Qt.MetaModifier & modifiers:\n            _modifiers |= window.key.MOD_META\n        return _modifiers\n\n    def close(self):\n        self._native_window.close()\n\n    def show(self):\n        self._native_window.show()\n        self.dispatch_event(\'on_show\')\n\n    def hide(self):\n        self._native_window.hide()\n        self.dispatch_event(\'on_hide\')\n\n    def set_title(self, title):\n        self._native_window.setWindowTitle(self._title)\n        self._title = title\n\n    def get_title(self, title):\n        return self._title\n\n    def set_size(self, width, height):\n        self._native_window.resize(width, height)\n        self._width = self._native_window.geometry().width()\n        self._height = self._native_window.geometry().height()\n\n    def get_size(self):\n        self._width = self._native_window.geometry().width()\n        self._height = self._native_window.geometry().height()\n        return self._width, self._height\n\n    def set_position(self, x, y):\n        self._native_window.move(x,y)\n        self._x = self._native_window.geometry().x()\n        self._y = self._native_window.geometry().y()\n\n    def get_position(self):\n        self._x = self._native_window.geometry().x()\n        self._y = self._native_window.geometry().y()\n        return self._x, self._y\n\n    def swap(self):\n        self._native_window.swapBuffers()\n\n    def activate(self):\n        self._native_window.makeCurrent()\n\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n\n    for window in __windows__:\n        # Poll for and process events\n        window._native_app.processEvents()\n        # window._native_app.flush()\n\n    for window in __windows__:\n        # Make window active\n        window.activate()\n\n        # Dispatch the main draw event\n        window.dispatch_event(\'on_draw\', dt)\n\n        # Dispatch the idle event\n        window.dispatch_event(\'on_idle\', dt)\n\n        # Swap buffers\n        window.swap()\n\n\n    return len(__windows__)\n'"
glumpy/app/window/backends/backend_pyside2.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nPySide2 is the official Python module from the Qt for Python project, which provides access to the complete Qt 5.12+ framework.\n\n**Usage**\n\n  .. code:: python\n\n     from glumpy import app\n\n     app.use(""pyside2"")\n     window = app.Window()\n\n\n**Capability**\n\n========================== ======== ======================== ========\nMultiple windows              \xe2\x9c\x93     Set GL API                  \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nNon-decorated windows         \xe2\x9c\x93     Set GL Profile              \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nResize windows                \xe2\x9c\x93     Share GL Context            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nMove windows                  \xe2\x9c\x93     Unicode handling            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nFullscreen                    \xe2\x9c\x93     Scroll event                \xe2\x9c\x93\n========================== ======== ======================== ========\n""""""\n\nimport os, sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""PySide2""\n\n# Backend version (if available)\n__version__ = """"\n\n# Backend availability\n__availability__ = False\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Active windows\n__windows__ = []\n\n# GL Format\n__glformat__ = None\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    __app__ = QtWidgets.QApplication.instance()\n    if __app__ is None:\n        __app__ = QtWidgets.QApplication(sys.argv)\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    __initialized__ = False\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    from PySide2 import QtCore, QtOpenGL,QtWidgets\n    if not __initialized__:\n        __init__()\n    __availability__ = True\n    __version__ = QtCore.__version__\n\n    __mouse_map__ = { 0: window.mouse.LEFT,\n                      1: window.mouse.MIDDLE,\n                      2: window.mouse.RIGHT }\n\n    __key_map__ = { QtCore.Qt.Key_Left:      window.key.LEFT,\n                    QtCore.Qt.Key_Up:        window.key.UP,\n                    QtCore.Qt.Key_Right:     window.key.RIGHT,\n                    QtCore.Qt.Key_Down:      window.key.DOWN,\n                    QtCore.Qt.Key_PageUp:    window.key.PAGEUP,\n                    QtCore.Qt.Key_PageDown:  window.key.PAGEDOWN,\n                    QtCore.Qt.Key_Insert:    window.key.INSERT,\n                    QtCore.Qt.Key_Delete:    window.key.DELETE,\n                    QtCore.Qt.Key_Home:      window.key.HOME,\n                    QtCore.Qt.Key_End:       window.key.END,\n                    QtCore.Qt.Key_Escape:    window.key.ESCAPE,\n                    QtCore.Qt.Key_Backspace: window.key.BACKSPACE,\n                    QtCore.Qt.Key_F1:        window.key.F1,\n                    QtCore.Qt.Key_F2:        window.key.F2,\n                    QtCore.Qt.Key_F3:        window.key.F3,\n                    QtCore.Qt.Key_F4:        window.key.F4,\n                    QtCore.Qt.Key_F5:        window.key.F5,\n                    QtCore.Qt.Key_F6:        window.key.F6,\n                    QtCore.Qt.Key_F7:        window.key.F7,\n                    QtCore.Qt.Key_F8:        window.key.F8,\n                    QtCore.Qt.Key_F9:        window.key.F9,\n                    QtCore.Qt.Key_F10:       window.key.F10,\n                    QtCore.Qt.Key_F11:       window.key.F11,\n                    QtCore.Qt.Key_F12:       window.key.F12,\n                    QtCore.Qt.Key_Space:     window.key.SPACE,\n                    QtCore.Qt.Key_Enter:     window.key.ENTER,\n                    QtCore.Qt.Key_Return:    window.key.ENTER,\n                    QtCore.Qt.Key_Tab:       window.key.TAB }\n\n\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : True,\n    ""Window size get/set""     : True,\n    ""Multiple windows""        : True,\n    ""Mouse scroll events""     : True,\n    ""Non-decorated window""    : True,\n    ""Non-sizeable window""     : True,\n    ""Fullscreen mode""         : True,\n    ""Unicode processing""      : True,\n    ""Set GL version""          : True,\n    ""Set GL profile""          : True,\n    ""Share GL context""        : True,\n}\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(config):\n    global __glformat__\n\n    # WARNING: does not work on osx\n    # http://stackoverflow.com/questions/...\n    # ...7868882/enabling-opengl-core-profile-in-qt4-on-os-x\n\n    __glformat__ = QtOpenGL.QGLFormat()\n    __glformat__.setRedBufferSize(config.red_size)\n    __glformat__.setGreenBufferSize(config.green_size)\n    __glformat__.setBlueBufferSize(config.blue_size)\n    __glformat__.setAlphaBufferSize(config.alpha_size)\n    __glformat__.setAccum(False)\n    __glformat__.setRgba(True)\n\n    if config.double_buffer:\n        __glformat__.setDoubleBuffer(True)\n    else:\n        __glformat__.setDoubleBuffer(False)\n\n    if config.depth_size:\n        __glformat__.setDepth(True)\n        __glformat__.setDepthBufferSize(config.depth_size)\n    else:\n        __glformat__.setDepth(False)\n        __glformat__.setDepthBufferSize(0)\n\n    if config.stencil_size:\n        __glformat__.setStencil(True)\n        __glformat__.setStencilBufferSize(config.stencil_size)\n    else:\n        __glformat__.setStencil(False)\n        __glformat__.setStencilBufferSize(0)\n\n    if config.samples:\n        __glformat__.setSampleBuffers(True)\n        __glformat__.setSamples(config.samples)\n    else:\n        __glformat__.setSampleBuffers(False)\n        __glformat__.setSamples(0)\n    __glformat__.setStereo(config.stereo)\n\n    __glformat__.setVersion(config.major_version, config.minor_version)\n    if config.major_version >= 3 and config.profile == ""core"":\n        __glformat__.setProfile(__glformat__.CoreProfile)\n    elif config.major_version >= 3 and config.profile == ""compatibility"":\n        __glformat__.setProfile(__glformat__.CompatibilityProfile)\n    else:\n        __glformat__.setProfile(__glformat__.NoProfile)\n\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n    def __init__( self, width=256, height=256, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        if config is None:\n            config = configuration.Configuration()\n        set_configuration(config)\n\n        __glformat__.setSwapInterval(1 if vsync else 0)\n\n        self._native_app = QtWidgets.QApplication.instance()\n        if self._native_app is None:\n            self._native_app = QtWidgets.QApplication(sys.argv)\n\n        context = QtOpenGL.QGLContext(__glformat__)\n        if context.isValid():\n            self._native_window = QtOpenGL.QGLWidget(context)\n        else:\n            self._native_window = QtOpenGL.QGLWidget(__glformat__)\n\n        self._native_window.resize(width, height)\n        self._native_window.makeCurrent()\n        self._native_window.setAutoBufferSwap(False)\n        self._native_window.setMouseTracking(True)\n        self._native_window.setWindowTitle(self._title)\n        #self._native_window.show()\n\n        def paint_gl():\n            self.dispatch_event(""on_draw"", 0.0)\n        self._native_window.paintGL = paint_gl\n\n        def resize_gl(width, height):\n            self.dispatch_event(""on_resize"", width, height)\n        self._native_window.resizeGL = resize_gl\n\n        def close_event(event):\n            __windows__.remove(self)\n            for i in range(len(self._timer_stack)):\n                handler, interval = self._timer_stack[i]\n                self._clock.unschedule(handler)\n            self.dispatch_event(""on_close"")\n        self._native_window.closeEvent = close_event\n\n        def mouse_press_event(event):\n            x = event.pos().x()\n            y = event.pos().y()\n            button = __mouse_map__.get(event.button(), window.mouse.UNKNOWN)\n            self._button = button\n            self._mouse_x = x\n            self._mouse_y = y\n            self.dispatch_event(""on_mouse_press"", x, y, button)\n        self._native_window.mousePressEvent = mouse_press_event\n\n        def mouse_release_event(event):\n            x = event.pos().x()\n            y = event.pos().y()\n            button = __mouse_map__.get(event.button(), window.mouse.UNKNOWN)\n            self._button = window.mouse.NONE\n            self._mouse_x = x\n            self._mouse_y = y\n            self.dispatch_event(""on_mouse_release"", x, y, button)\n        self._native_window.mouseReleaseEvent = mouse_release_event\n\n        def mouse_move_event(event):\n            x = event.pos().x()\n            y = event.pos().y()\n            dx = x - self._mouse_x\n            dy = y - self._mouse_y\n            self._mouse_x = x\n            self._mouse_y = y\n            if self._button is not window.mouse.NONE:\n                self.dispatch_event(\'on_mouse_drag\', x, y, dx, dy, self._button)\n            else:\n                self.dispatch_event(\'on_mouse_motion\', x, y, dx, dy)\n        self._native_window.mouseMoveEvent = mouse_move_event\n\n        def wheel_event(event):\n            if event.orientation == QtCore.Qt.Horizontal:\n                offset_x = event.delta()\n                offset_y = 0\n            else:\n                offset_x = 0\n                offset_y = event.delta()\n            x = event.pos().x()\n            y = event.pos().y()\n            self.dispatch_event(""on_mouse_scroll"", x, y, offset_x/10.0, offset_y/10.0)\n        self._native_window.wheelEvent = wheel_event\n\n        def key_press_event(event):\n            code = self._keyboard_translate(event.key())\n            modifiers = self._modifiers_translate(event.modifiers())\n            self.dispatch_event(""on_key_press"", code, modifiers)\n            self.dispatch_event(""on_character"", event.text())\n        self._native_window.keyPressEvent = key_press_event\n\n        def key_release_event(event):\n            code = self._keyboard_translate(event.key())\n            modifiers = self._modifiers_translate(event.modifiers())\n            self.dispatch_event(""on_key_release"", code, modifiers)\n        self._native_window.keyReleaseEvent = key_release_event\n\n        __windows__.append(self)\n\n\n    def _keyboard_translate( self, code ):\n        if code in __key_map__:\n            return __key_map__[code]\n        if 32 <= code <= 96 or code in [161,162]:\n            return code\n        return window.key.UNKNOWN\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if QtCore.Qt.ShiftModifier & modifiers:\n            _modifiers |= window.key.MOD_SHIFT\n        if QtCore.Qt.ControlModifier & modifiers:\n            _modifiers |= window.key.MOD_CONTROL\n        if QtCore.Qt.AltModifier & modifiers:\n            _modifiers |= window.key.MOD_ALT\n        if QtCore.Qt.MetaModifier & modifiers:\n            _modifiers |= window.key.MOD_META\n        return _modifiers\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if QtCore.Qt.ShiftModifier & modifiers:\n            _modifiers |= window.key.MOD_SHIFT\n        if QtCore.Qt.ControlModifier & modifiers:\n            _modifiers |= window.key.MOD_CONTROL\n        if QtCore.Qt.AltModifier & modifiers:\n            _modifiers |= window.key.MOD_ALT\n        if QtCore.Qt.MetaModifier & modifiers:\n            _modifiers |= window.key.MOD_META\n        return _modifiers\n\n    def close(self):\n        self._native_window.close()\n\n    def show(self):\n        self._native_window.show()\n        self.dispatch_event(\'on_show\')\n\n    def hide(self):\n        self._native_window.hide()\n        self.dispatch_event(\'on_hide\')\n\n    def set_title(self, title):\n        self._native_window.setWindowTitle(self._title)\n        self._title = title\n\n    def get_title(self, title):\n        return self._title\n\n    def set_size(self, width, height):\n        self._native_window.resize(width, height)\n        self._width = self._native_window.geometry().width()\n        self._height = self._native_window.geometry().height()\n\n    def get_size(self):\n        self._width = self._native_window.geometry().width()\n        self._height = self._native_window.geometry().height()\n        return self._width, self._height\n\n    def set_position(self, x, y):\n        self._native_window.move(x,y)\n        self._x = self._native_window.geometry().x()\n        self._y = self._native_window.geometry().y()\n\n    def get_position(self):\n        self._x = self._native_window.geometry().x()\n        self._y = self._native_window.geometry().y()\n        return self._x, self._y\n\n    def swap(self):\n        self._native_window.swapBuffers()\n\n    def activate(self):\n        self._native_window.makeCurrent()\n\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n\n    for window in __windows__:\n        # Poll for and process events\n        window._native_app.processEvents()\n        # window._native_app.flush()\n\n    for window in __windows__:\n        # Make window active\n        window.activate()\n\n        # Dispatch the main draw event\n        window.dispatch_event(\'on_draw\', dt)\n\n        # Dispatch the idle event\n        window.dispatch_event(\'on_idle\', dt)\n\n        # Swap buffers\n        window.swap()\n\n\n    return len(__windows__)\n'"
glumpy/app/window/backends/backend_qt5.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n`PyQt <https://riverbankcomputing.com/software/pyqt/intro/>`_ is a set of\nPython v2 and v3 bindings for The Qt Company\'s Qt application framework and\nruns on all platforms supported by Qt including Windows, MacOS/X and\nLinux. PyQt5 supports Qt v5. PyQt4 supports Qt v4 and will build against Qt\nv5. The bindings are implemented as a set of Python modules and contain over\n1,000 classes.\n\n**Usage**\n\n  .. code:: python\n\n     from glumpy import app\n\n     app.use(""qt5"")\n     window = app.Window()\n\n\n**Capability**\n\n========================== ======== ======================== ========\nMultiple windows              \xe2\x9c\x93     Set GL API                  \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nNon-decorated windows         \xe2\x9c\x93     Set GL Profile              \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nResize windows                \xe2\x9c\x93     Share GL Context            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nMove windows                  \xe2\x9c\x93     Unicode handling            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nFullscreen                    \xe2\x9c\x93     Scroll event                \xe2\x9c\x93\n========================== ======== ======================== ========\n""""""\n\nimport os, sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""Qt5""\n\n# Backend version (if available)\n__version__ = """"\n\n# Backend availability\n__availability__ = False\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Active windows\n__windows__ = []\n\n# GL Format\n__glformat__ = None\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    __app__ = QtWidgets.QApplication.instance()\n    if __app__ is None:\n        __app__ = QtWidgets.QApplication(sys.argv)\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    __initialized__ = False\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    from PyQt5 import QtGui, QtCore, QtOpenGL, QtWidgets\n    if not __initialized__:\n        __init__()\n    __availability__ = True\n    __version__ = QtCore.QT_VERSION_STR\n    # __version__ = QtCore.__version__\n\n    __mouse_map__ = { 0: window.mouse.LEFT,\n                      1: window.mouse.MIDDLE,\n                      2: window.mouse.RIGHT }\n\n    __key_map__ = { QtCore.Qt.Key_Left:      window.key.LEFT,\n                    QtCore.Qt.Key_Up:        window.key.UP,\n                    QtCore.Qt.Key_Right:     window.key.RIGHT,\n                    QtCore.Qt.Key_Down:      window.key.DOWN,\n                    QtCore.Qt.Key_PageUp:    window.key.PAGEUP,\n                    QtCore.Qt.Key_PageDown:  window.key.PAGEDOWN,\n                    QtCore.Qt.Key_Insert:    window.key.INSERT,\n                    QtCore.Qt.Key_Delete:    window.key.DELETE,\n                    QtCore.Qt.Key_Home:      window.key.HOME,\n                    QtCore.Qt.Key_End:       window.key.END,\n                    QtCore.Qt.Key_Escape:    window.key.ESCAPE,\n                    QtCore.Qt.Key_Backspace: window.key.BACKSPACE,\n                    QtCore.Qt.Key_F1:        window.key.F1,\n                    QtCore.Qt.Key_F2:        window.key.F2,\n                    QtCore.Qt.Key_F3:        window.key.F3,\n                    QtCore.Qt.Key_F4:        window.key.F4,\n                    QtCore.Qt.Key_F5:        window.key.F5,\n                    QtCore.Qt.Key_F6:        window.key.F6,\n                    QtCore.Qt.Key_F7:        window.key.F7,\n                    QtCore.Qt.Key_F8:        window.key.F8,\n                    QtCore.Qt.Key_F9:        window.key.F9,\n                    QtCore.Qt.Key_F10:       window.key.F10,\n                    QtCore.Qt.Key_F11:       window.key.F11,\n                    QtCore.Qt.Key_F12:       window.key.F12,\n                    QtCore.Qt.Key_Space:     window.key.SPACE,\n                    QtCore.Qt.Key_Enter:     window.key.ENTER,\n                    QtCore.Qt.Key_Return:    window.key.ENTER,\n                    QtCore.Qt.Key_Tab:       window.key.TAB }\n\n\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : True,\n    ""Window size get/set""     : True,\n    ""Multiple windows""        : True,\n    ""Mouse scroll events""     : True,\n    ""Non-decorated window""    : True,\n    ""Non-sizeable window""     : True,\n    ""Fullscreen mode""         : True,\n    ""Unicode processing""      : True,\n    ""Set GL version""          : True,\n    ""Set GL profile""          : True,\n    ""Share GL context""        : True,\n}\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(config):\n    global __glformat__\n\n    # WARNING: does not work on osx\n    # http://stackoverflow.com/questions/...\n    # ...7868882/enabling-opengl-core-profile-in-qt4-on-os-x\n\n    __glformat__ = QtOpenGL.QGLFormat()\n    __glformat__.setRedBufferSize(config.red_size)\n    __glformat__.setGreenBufferSize(config.green_size)\n    __glformat__.setBlueBufferSize(config.blue_size)\n    __glformat__.setAlphaBufferSize(config.alpha_size)\n    __glformat__.setAccum(False)\n    __glformat__.setRgba(True)\n\n    if config.double_buffer:\n        __glformat__.setDoubleBuffer(True)\n    else:\n        __glformat__.setDoubleBuffer(False)\n\n    if config.depth_size:\n        __glformat__.setDepth(True)\n        __glformat__.setDepthBufferSize(config.depth_size)\n    else:\n        __glformat__.setDepth(False)\n        __glformat__.setDepthBufferSize(0)\n\n    if config.stencil_size:\n        __glformat__.setStencil(True)\n        __glformat__.setStencilBufferSize(config.stencil_size)\n    else:\n        __glformat__.setStencil(False)\n        __glformat__.setStencilBufferSize(0)\n\n    if config.samples:\n        __glformat__.setSampleBuffers(True)\n        __glformat__.setSamples(config.samples)\n    else:\n        __glformat__.setSampleBuffers(False)\n        __glformat__.setSamples(0)\n    __glformat__.setStereo(config.stereo)\n\n    __glformat__.setVersion(config.major_version, config.minor_version)\n    if config.major_version >= 3 and config.profile == ""core"":\n        __glformat__.setProfile(__glformat__.CoreProfile)\n    elif config.major_version >= 3 and config.profile == ""compatibility"":\n        __glformat__.setProfile(__glformat__.CompatibilityProfile)\n    else:\n        __glformat__.setProfile(__glformat__.NoProfile)\n\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n    def __init__( self, width=256, height=256, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        if config is None:\n            config = configuration.Configuration()\n        set_configuration(config)\n\n        __glformat__.setSwapInterval(1 if vsync else 0)\n\n        self._native_app = QtWidgets.QApplication.instance()\n        if self._native_app is None:\n            self._native_app = QtWidgets.QApplication(sys.argv)\n\n        context = QtOpenGL.QGLContext(__glformat__)\n        if context.isValid():\n            self._native_window = QtOpenGL.QGLWidget(context)\n        else:\n            self._native_window = QtOpenGL.QGLWidget(__glformat__)\n\n        self._native_window.resize(width, height)\n        self._native_window.makeCurrent()\n        self._native_window.setAutoBufferSwap(False)\n        self._native_window.setMouseTracking(True)\n        self._native_window.setWindowTitle(self._title)\n\n        def paint_gl():\n            self.dispatch_event(""on_draw"", 0.0)\n        self._native_window.paintGL = paint_gl\n\n        def resize_gl(width, height):\n            self.dispatch_event(""on_resize"", width, height)\n        self._native_window.resizeGL = resize_gl\n\n        def close_event(event):\n            __windows__.remove(self)\n            for i in range(len(self._timer_stack)):\n                handler, interval = self._timer_stack[i]\n                self._clock.unschedule(handler)\n            self.dispatch_event(""on_close"")\n        self._native_window.closeEvent = close_event\n\n        def mouse_press_event(event):\n            x = event.pos().x()\n            y = event.pos().y()\n            button = __mouse_map__.get(event.button(), window.mouse.UNKNOWN)\n            self._button = button\n            self._mouse_x = x\n            self._mouse_y = y\n            self.dispatch_event(""on_mouse_press"", x, y, button)\n        self._native_window.mousePressEvent = mouse_press_event\n\n        def mouse_release_event(event):\n            x = event.pos().x()\n            y = event.pos().y()\n            button = __mouse_map__.get(event.button(), window.mouse.UNKNOWN)\n            self._button = window.mouse.NONE\n            self._mouse_x = x\n            self._mouse_y = y\n            self.dispatch_event(""on_mouse_release"", x, y, button)\n        self._native_window.mouseReleaseEvent = mouse_release_event\n\n        def mouse_move_event(event):\n            x = event.pos().x()\n            y = event.pos().y()\n            dx = x - self._mouse_x\n            dy = y - self._mouse_y\n            self._mouse_x = x\n            self._mouse_y = y\n            if self._button is not window.mouse.NONE:\n                self.dispatch_event(\'on_mouse_drag\', x, y, dx, dy, self._button)\n            else:\n                self.dispatch_event(\'on_mouse_motion\', x, y, dx, dy)\n        self._native_window.mouseMoveEvent = mouse_move_event\n\n        def wheel_event(event):\n            offset_x = event.angleDelta().x()\n            offset_y = event.angleDelta().y()\n            x = event.pos().x()\n            y = event.pos().y()\n            self.dispatch_event(""on_mouse_scroll"", x, y, offset_x/10.0, offset_y/10.0)\n        self._native_window.wheelEvent = wheel_event\n\n        def key_press_event(event):\n            code = self._keyboard_translate(event.key())\n            modifiers = self._modifiers_translate(event.modifiers())\n            self.dispatch_event(""on_key_press"", code, modifiers)\n            self.dispatch_event(""on_character"", event.text())\n        self._native_window.keyPressEvent = key_press_event\n\n        def key_release_event(event):\n            code = self._keyboard_translate(event.key())\n            modifiers = self._modifiers_translate(QtWidgets.QApplication.keyboardModifiers())\n            self.dispatch_event(""on_key_release"", code, modifiers)\n        self._native_window.keyReleaseEvent = key_release_event\n\n        self._native_window.show()\n\n        __windows__.append(self)\n\n\n    def _keyboard_translate( self, code ):\n        if code in __key_map__:\n            return __key_map__[code]\n        if 32 <= code <= 96 or code in [161,162]:\n            return code\n        return window.key.UNKNOWN\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if QtCore.Qt.ShiftModifier & modifiers:\n            _modifiers |= window.key.MOD_SHIFT\n        if QtCore.Qt.ControlModifier & modifiers:\n            _modifiers |= window.key.MOD_CTRL\n        if QtCore.Qt.AltModifier & modifiers:\n            _modifiers |= window.key.MOD_ALT\n        if QtCore.Qt.MetaModifier & modifiers:\n            _modifiers |= window.key.MOD_META\n        return _modifiers\n\n    def close(self):\n        self._native_window.close()\n\n    def show(self):\n        self._native_window.show()\n        self.dispatch_event(\'on_show\')\n\n    def hide(self):\n        self._native_window.hide()\n        self.dispatch_event(\'on_hide\')\n\n    def set_title(self, title):\n        self._native_window.setWindowTitle(self._title)\n        self._title = title\n\n    def get_title(self, title):\n        return self._title\n\n    def set_size(self, width, height):\n        self._native_window.resize(width, height)\n        self._width = self._native_window.geometry().width()\n        self._height = self._native_window.geometry().height()\n\n    def get_size(self):\n        self._width = self._native_window.geometry().width()\n        self._height = self._native_window.geometry().height()\n        return self._width, self._height\n\n    def set_position(self, x, y):\n        self._native_window.move(x,y)\n        self._x = self._native_window.geometry().x()\n        self._y = self._native_window.geometry().y()\n\n    def get_position(self):\n        self._x = self._native_window.geometry().x()\n        self._y = self._native_window.geometry().y()\n        return self._x, self._y\n\n    def swap(self):\n        self._native_window.swapBuffers()\n\n    def activate(self):\n        self._native_window.makeCurrent()\n\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n\n    for window in __windows__:\n        # Poll for and process events\n        window._native_app.processEvents()\n        # window._native_app.flush()\n\n    for window in __windows__:\n        # Make window active\n        window.activate()\n\n        # Dispatch the main draw event\n        window.dispatch_event(\'on_draw\', dt)\n\n        # Dispatch the idle event\n        window.dispatch_event(\'on_idle\', dt)\n\n        # Swap buffers\n        window.swap()\n\n\n    return len(__windows__)\n'"
glumpy/app/window/backends/backend_sdl.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n`Pygame <http://www.pygame.org/>`_ is a set of Python modules designed for\nwriting games. Pygame adds functionality on top of the excellent SDL\nlibrary. This allows you to create fully featured games and multimedia programs\nin the python language.\n\n**Usage**\n\n  .. code:: python\n\n     from glumpy import app\n\n     app.use(""sdl"")\n     window = app.Window()\n\n\n**Capability**\n\n========================== ======== ======================== ========\nMultiple windows              \xe2\x9c\x98     Set GL API                  \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nNon-decorated windows         \xe2\x9c\x93     Set GL Profile              \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nResize windows                \xe2\x9c\x98     Share GL Context            \xe2\x9c\x98\n-------------------------- -------- ------------------------ --------\nMove windows                  \xe2\x9c\x98     Unicode handling            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nFullscreen                    \xe2\x9c\x93     Scroll event                \xe2\x9c\x98\n========================== ======== ======================== ========\n""""""\nimport os, sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""SDL""\n\n# Backend version (if available)\n__version__ = """"\n\n# Backend availability\n__availability__ = False\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Active windows\n__windows__ = []\n\n# Configuration flags\n__flags__ = None\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    if not __initialized__:\n        os.environ[\'SDL_VIDEO_WINDOW_POS\'] = ""0,0""\n        pygame.init()\n\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    pygame.quit()\n    __initialized__ = False\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    import pygame\n    if not __initialized__:\n        __init__()\n    __availability__ = True\n    __version__ = (""%d.%d.%d"") % pygame.version.vernum\n\n    __mouse_map__ = { 0:                  window.mouse.LEFT,\n                      1:                  window.mouse.MIDDLE,\n                      2:                  window.mouse.RIGHT }\n\n    __key_map__   = { 0x008:              window.key.BACKSPACE,\n                      0x009:              window.key.TAB,\n                      0x00A:              window.key.LINEFEED,\n                      0x00C:              window.key.CLEAR,\n                      0x00D:              window.key.RETURN,\n                      0x018:              window.key.CANCEL,\n                      0x01B:              window.key.ESCAPE,\n                      pygame.K_F1:        window.key.F1,\n                      pygame.K_F2:        window.key.F2,\n                      pygame.K_F3:        window.key.F3,\n                      pygame.K_F4:        window.key.F4,\n                      pygame.K_F5:        window.key.F5,\n                      pygame.K_F6:        window.key.F6,\n                      pygame.K_F7:        window.key.F7,\n                      pygame.K_F8:        window.key.F8,\n                      pygame.K_F9:        window.key.F9,\n                      pygame.K_F10:       window.key.F10,\n                      pygame.K_F11:       window.key.F11,\n                      pygame.K_F12:       window.key.F12,\n                      pygame.K_LEFT:      window.key.LEFT,\n                      pygame.K_UP:        window.key.UP,\n                      pygame.K_RIGHT:     window.key.RIGHT,\n                      pygame.K_DOWN:      window.key.DOWN,\n                      pygame.K_PAGEUP:    window.key.PAGEUP,\n                      pygame.K_PAGEDOWN:  window.key.PAGEDOWN,\n                      pygame.K_HOME:      window.key.HOME,\n                      pygame.K_END:       window.key.END,\n                      pygame.K_INSERT:    window.key.INSERT }\n\n\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : False,\n    ""Window size get/set""     : False,\n    ""Multiple windows""        : False,\n    ""Mouse scroll events""     : False,\n    ""Non-decorated window""    : True,\n    ""Non-sizeable window""     : True,\n    ""Fullscreen mode""         : True,\n    ""Unicode processing""      : False,\n    ""Set GL version""          : False,\n    ""Set GL profile""          : False,\n    ""Share GL context""        : False,\n}\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(configuration):\n    """""" Set gl configuration """"""\n\n    global __flags__\n    pygame.display.gl_set_attribute( pygame.GL_RED_SIZE, configuration.red_size)\n    pygame.display.gl_set_attribute( pygame.GL_GREEN_SIZE, configuration.green_size)\n    pygame.display.gl_set_attribute( pygame.GL_BLUE_SIZE, configuration.blue_size)\n    pygame.display.gl_set_attribute( pygame.GL_ALPHA_SIZE, configuration.alpha_size)\n    pygame.display.gl_set_attribute( pygame.GL_DEPTH_SIZE, configuration.depth_size)\n    pygame.display.gl_set_attribute( pygame.GL_STENCIL_SIZE, configuration.stencil_size)\n    if configuration.samples:\n        pygame.display.gl_set_attribute( pygame.GL_MULTISAMPLEBUFFERS, 1)\n        pygame.display.gl_set_attribute( pygame.GL_MULTISAMPLESAMPLES, configuration.samples)\n    else:\n        pygame.display.gl_set_attribute( pygame.GL_MULTISAMPLEBUFFERS, 0)\n        pygame.display.gl_set_attribute( pygame.GL_MULTISAMPLESAMPLES, 0)\n    pygame.display.gl_set_attribute( pygame.GL_STEREO, configuration.stereo)\n    if configuration.double_buffer:\n        __flags__ = pygame.HWSURFACE | pygame.OPENGL | pygame.DOUBLEBUF\n    else:\n        __flags__ = pygame.HWSURFACE | pygame.OPENGL\n\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n    \'\'\' \'\'\'\n\n    def __init__( self, width=256, height=256, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n\n        if len(__windows__) > 0:\n            log.critical(\n                """"""SDL backend cannot have more than one window.\\n""""""\n                """"""Exiting..."""""")\n            sys.exit(0)\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        if config is None:\n            config = configuration.Configuration()\n        set_configuration(config)\n\n        pygame.display.gl_set_attribute( pygame.GL_SWAP_CONTROL, 1 if vsync else 0)\n\n\n        flags = __flags__\n        if self._decoration == False:\n            flags = __flags__ | pygame.NOFRAME\n\n        pygame.display.set_mode((width, height), flags)\n        pygame.display.set_caption(self._title)\n        __windows__.append(self)\n\n\n    def process_event(self, event):\n\n        if event.type == pygame.VIDEORESIZE:\n            width, height = event.w, event.h\n            self.dispatch_event(""on_resize"", width, height)\n\n        elif event.type == pygame.QUIT:\n            self.close()\n\n        elif event.type == pygame.MOUSEMOTION:\n            x,y = pygame.mouse.get_pos()\n            buttons = pygame.mouse.get_pressed()\n            dx = x - self._mouse_x\n            dy = y - self._mouse_y\n            self._mouse_x = x\n            self._mouse_y = y\n            if buttons[0]:\n                self.dispatch_event(""on_mouse_drag"", x, y, dx, dy, window.mouse.LEFT)\n            elif buttons[1]:\n                self.dispatch_event(""on_mouse_drag"", x, y, dx, dy, window.mouse.MIDDLE)\n            elif buttons[2]:\n                self.dispatch_event(""on_mouse_drag"", x, y, dx, dy, window.mouse.RIGHT)\n            else:\n                self.dispatch_event(""on_mouse_motion"", x, y, dx, dy)\n\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            x,y = pygame.mouse.get_pos()\n            self._mouse_x = x\n            self._mouse_y = y\n            button = __mouse_map__.get(event.button, window.mouse.UNKNOWN)\n            self.dispatch_event(""on_mouse_press"", x, y, button)\n\n        elif event.type == pygame.MOUSEBUTTONUP:\n            x,y = pygame.mouse.get_pos()\n            self._mouse_x = x\n            self._mouse_y = y\n            button = __mouse_map__.get(event.button, window.mouse.UNKNOWN)\n            self.dispatch_event(""on_mouse_release"", x, y, button)\n\n        elif event.type == pygame.KEYUP:\n            modifiers = self._modifiers_translate(event.mod)\n            symbol = self._keyboard_translate(event.key)\n            self.dispatch_event(""on_key_press"", symbol, modifiers)\n\n        elif event.type == pygame.KEYDOWN:\n            modifiers = self._modifiers_translate(event.mod)\n            symbol = self._keyboard_translate(event.key)\n            self.dispatch_event(""on_key_release"", symbol, modifiers)\n\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if modifiers & (pygame.K_LSHIFT | pygame.K_RSHIFT):\n            _modifiers |=  window.key.MOD_SHIFT\n        if modifiers & (pygame.K_LCTRL | pygame.K_RCTRL):\n            _modifiers |=  window.key.MOD_CTRL\n        if modifiers & (pygame.K_LALT | pygame.K_RALT):\n            _modifiers |=  window.key.MOD_ALT\n        return _modifiers\n\n    def _keyboard_translate(self, code):\n        ascii = code\n        if (0x020 <= ascii <= 0x040) or (0x05b <= ascii <= 0x07e):\n            return ascii\n        elif ascii <= 0x020:\n            code = ascii\n        return __key_map__.get(code, window.key.UNKNOWN)\n\n    def close(self):\n        __windows__.remove(self)\n        self.dispatch_event(""on_close"")\n\n    def swap(self):\n        pygame.display.flip()\n\n    def activate(self):\n        pass\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n\n    if not len(__windows__):\n        return 0\n\n    window = __windows__[0]\n\n    # Poll for and process events\n    for event in pygame.event.get():\n        window.process_event(event)\n\n    # Activate window\n    window.activate()\n\n    # Dispatch the main draw event\n    window.dispatch_event(\'on_draw\', dt)\n\n    # Dispatch the idle event\n    window.dispatch_event(\'on_idle\', dt)\n\n    # Swap buffers\n    window.swap()\n\n    return 1\n'"
glumpy/app/window/backends/backend_sdl2.py,0,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\n`PySDL2 <http://pysdl2.readthedocs.org/en/latest/index.html>`_ is a wrapper\naround the SDL2 library and as such similar to the discontinued PySDL\nproject. In contrast to PySDL, it has no licensing restrictions, nor does it\nrely on C code, but uses ctypes instead.\n\n**Usage**\n\n  .. code:: python\n\n     from glumpy import app\n\n     app.use(""sdl2"")\n     window = app.Window()\n\n**Capability**\n\n========================== ======== ======================== ========\nMultiple windows              \xe2\x9c\x93     Set GL API                  \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nNon-decorated windows         \xe2\x9c\x93     Set GL Profile              \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nResize windows                \xe2\x9c\x93     Share GL Context            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nMove windows                  \xe2\x9c\x93     Unicode handling            \xe2\x9c\x93\n-------------------------- -------- ------------------------ --------\nFullscreen                    \xe2\x9c\x93     Scroll event                \xe2\x9c\x93\n========================== ======== ======================== ========\n""""""\nimport sys, ctypes\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""SDL2""\n\n# Backend version (if available)\n__version__ = """"\n\n# Backend availability\n__availability__ = False\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Active windows\n__windows__ = {}\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    if not __initialized__:\n        sdl2.SDL_Init(sdl2.SDL_INIT_VIDEO)\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    sdl2.SDL_Quit()\n    __initialized__ = False\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    import sdl2\n    if not __initialized__:\n        __init__()\n    __availability__ = True\n    __version__ = (""%d.%d.%d"") % sdl2.version_info[:3]\n\n\n    __mouse_map__ = {sdl2.SDL_BUTTON_LEFT: window.mouse.LEFT,\n                     sdl2.SDL_BUTTON_MIDDLE: window.mouse.MIDDLE,\n                     sdl2.SDL_BUTTON_RIGHT: window.mouse.RIGHT }\n    __key_map__ = {\n        # sdl2.SDLK_LSHIFT:    window.key.SHIFT,\n        # sdl2.SDLK_RSHIFT:    window.key.SHIFT,\n        # sdl2.SDLK_LCTRL:     window.key.CONTROL,\n        # sdl2.SDLK_RCTRL:     window.key.CONTROL,\n        # sdl2.SDLK_LALT:      window.key.ALT,\n        # sdl2.SDLK_RALT:      window.key.ALT,\n        # sdl2.SDLK_LGUI:      window.key.META,\n        # sdl2.SDLK_RGUI:      window.key.META,\n\n        sdl2.SDLK_LEFT:      window.key.LEFT,\n        sdl2.SDLK_UP:        window.key.UP,\n        sdl2.SDLK_RIGHT:     window.key.RIGHT,\n        sdl2.SDLK_DOWN:      window.key.DOWN,\n        sdl2.SDLK_PAGEUP:    window.key.PAGEUP,\n        sdl2.SDLK_PAGEDOWN:  window.key.PAGEDOWN,\n\n        sdl2.SDLK_INSERT:    window.key.INSERT,\n        sdl2.SDLK_DELETE:    window.key.DELETE,\n        sdl2.SDLK_HOME:      window.key.HOME,\n        sdl2.SDLK_END:       window.key.END,\n\n        sdl2.SDLK_ESCAPE:    window.key.ESCAPE,\n        sdl2.SDLK_BACKSPACE: window.key.BACKSPACE,\n\n        sdl2.SDLK_F1:         window.key.F1,\n        sdl2.SDLK_F2:         window.key.F2,\n        sdl2.SDLK_F3:         window.key.F3,\n        sdl2.SDLK_F4:         window.key.F4,\n        sdl2.SDLK_F5:         window.key.F5,\n        sdl2.SDLK_F6:         window.key.F6,\n        sdl2.SDLK_F7:         window.key.F7,\n        sdl2.SDLK_F8:         window.key.F8,\n        sdl2.SDLK_F9:         window.key.F9,\n        sdl2.SDLK_F10:        window.key.F10,\n        sdl2.SDLK_F11:        window.key.F11,\n        sdl2.SDLK_F12:        window.key.F12,\n\n        sdl2.SDLK_SPACE:      window.key.SPACE,\n        sdl2.SDLK_RETURN:     window.key.ENTER,\n        sdl2.SDLK_TAB:        window.key.TAB }\n\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : True,\n    ""Window size get/set""     : True,\n    ""Multiple windows""        : True,\n    ""Mouse scroll events""     : True,\n    ""Non-decorated window""    : True,\n    ""Non-sizeable window""     : True,\n    ""Fullscreen mode""         : True,\n    ""Unicode processing""      : True,\n    ""Set GL version""          : True,\n    ""Set GL profile""          : True,\n    ""Share GL context""        : True,\n}\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(config):\n    """""" Set gl configuration """"""\n\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_RED_SIZE, config.red_size)\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_GREEN_SIZE, config.green_size)\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_BLUE_SIZE, config.blue_size)\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_ALPHA_SIZE, config.alpha_size)\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_DEPTH_SIZE, config.depth_size)\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_STENCIL_SIZE, config.stencil_size)\n    if config.samples:\n        sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_MULTISAMPLEBUFFERS, 1)\n        sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_MULTISAMPLESAMPLES, config.samples)\n    else:\n        sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_MULTISAMPLEBUFFERS, 0)\n        sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_MULTISAMPLESAMPLES, 0)\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_STEREO, config.stereo)\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_FRAMEBUFFER_SRGB_CAPABLE, config.srgb)\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_CONTEXT_MAJOR_VERSION,\n                              config.major_version)\n    sdl2.SDL_GL_SetAttribute( sdl2.SDL_GL_CONTEXT_MINOR_VERSION,\n                              config.minor_version)\n    if config.profile == ""core"":\n        sdl2.SDL_GL_SetAttribute(sdl2.SDL_GL_CONTEXT_PROFILE_MASK,\n                                 sdl2.SDL_GL_CONTEXT_PROFILE_CORE)\n    elif config.profile == ""compatibility"":\n        sdl2.SDL_GL_SetAttribute(sdl2.SDL_GL_CONTEXT_PROFILE_MASK,\n                                 sdl2.SDL_GL_CONTEXT_PROFILE_COMPATIBILITY)\n#    elif configuration.profile == ""es"":\n#        sdl2.SDL_GL_SetAttribute(sdl2.SDL_GL_CONFIGURATION_PROFILE_MASK,\n#                                 sdl2.SDL_GL_CONFIGURATION_PROFILE_ES)\n\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n    """""" """"""\n\n    def __init__( self, width=256, height=256, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n        """""" """"""\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        if config is None:\n            config = configuration.Configuration()\n        set_configuration(config)\n\n        flags  = sdl2.SDL_WINDOW_SHOWN\n        # flags |= sdl2.SDL_WINDOW_ALLOW_HIGHDPI\n        flags |= sdl2.SDL_WINDOW_RESIZABLE\n        flags |= sdl2.SDL_WINDOW_OPENGL\n        if visible:\n            flags |= sdl2.SDL_WINDOW_SHOWN\n        else:\n            flags |= sdl2.SDL_WINDOW_HIDDEN\n        if not decoration:\n            flags |= sdl2.SDL_WINDOW_BORDERLESS\n\n        self._native_window = sdl2.SDL_CreateWindow(self._title,\n                                                    sdl2.SDL_WINDOWPOS_UNDEFINED,\n                                                    sdl2.SDL_WINDOWPOS_UNDEFINED,\n                                                    width, height, flags)\n        self._native_context = sdl2.SDL_GL_CreateContext(self._native_window)\n        self._native_id = sdl2.SDL_GetWindowID(self._native_window)\n        sdl2.SDL_GL_SetSwapInterval(1 if vsync else 0)\n\n        # OSX: check framebuffer size / window size. On retina display, they\n        #      can be different so we try to correct window size such as having\n        #      the framebuffer size of the right size\n        # w,h = ctypes.c_int(),ctypes.c_int()\n        # sdl2.SDL_GL_GetDrawableSize(self._native_window, w, h)\n        # w,h = w.value(), h.value()\n        # if w != width or h!= height:\n        #     width = width/2\n        #     height= height/2\n        #     sdl2.SDL_SetWindowSize(self._native_window, int(width), int(height))\n\n        self._height = height\n        self._width = width\n        __windows__[self._native_id] = self\n\n\n    def process_event(self, event):\n\n        if event.type == sdl2.SDL_WINDOWEVENT:\n\n            if event.window.event == sdl2.SDL_WINDOWEVENT_RESIZED:\n                width = event.window.data1\n                height = event.window.data2\n                self.dispatch_event(\'on_resize\', width, height)\n            elif event.window.event == sdl2.SDL_WINDOWEVENT_SHOWN:\n                self.dispatch_event(\'on_show\')\n            elif event.window.event == sdl2.SDL_WINDOWEVENT_HIDDEN:\n                self.dispatch_event(\'on_hide\')\n            elif event.window.event == sdl2.SDL_WINDOWEVENT_ENTER:\n                self.dispatch_event(\'on_enter\')\n            elif event.window.event == sdl2.SDL_WINDOWEVENT_LEAVE:\n                self.dispatch_event(\'on_leave\')\n            #elif event.window.event == sdl2.SDL_WINDOWEVENT_MOVED:\n            #    self.dispatch_event(\'on_move\')\n            elif event.window.event == sdl2.SDL_WINDOWEVENT_CLOSE:\n                self.close()\n\n        elif event.type == sdl2.SDL_QUIT:\n            self.close()\n\n        elif event.type == sdl2.SDL_MOUSEMOTION:\n            x = event.motion.x\n            y = event.motion.y\n            buttons = event.motion.state\n            dx = x - self._mouse_x\n            dy = y - self._mouse_y\n            self._mouse_x = x\n            self._mouse_y = y\n            if buttons & sdl2.SDL_BUTTON_LMASK:\n                self.dispatch_event(""on_mouse_drag"", x, y, dx, dy, window.mouse.LEFT)\n            elif buttons & sdl2.SDL_BUTTON_MMASK:\n                self.dispatch_event(""on_mouse_drag"", x, y, dx, dy, window.mouse.MIDDLE)\n            elif buttons & sdl2.SDL_BUTTON_RMASK:\n                self.dispatch_event(""on_mouse_drag"", x, y, dx, dy, window.mouse.RIGHT)\n            else:\n                self.dispatch_event(""on_mouse_motion"", x, y, dx, dy)\n\n        elif event.type == sdl2.SDL_MOUSEBUTTONDOWN:\n            x = event.button.x\n            y = event.button.y\n            button = event.button.button\n            self._mouse_x = x\n            self._mouse_y = y\n            if button == sdl2.SDL_BUTTON_LEFT:\n                self.dispatch_event(""on_mouse_press"", x, y, window.mouse.LEFT)\n            elif button == sdl2.SDL_BUTTON_MIDDLE:\n                self.dispatch_event(""on_mouse_press"", x, y, window.mouse.MIDDLE)\n            elif button == sdl2.SDL_BUTTON_RIGHT:\n                self.dispatch_event(""on_mouse_press"", x, y, window.mouse.RIGHT)\n\n        elif event.type == sdl2.SDL_MOUSEBUTTONUP:\n            x = event.button.x\n            y = event.button.y\n            button = event.button.button\n            self._mouse_x = x\n            self._mouse_y = y\n            if button == sdl2.SDL_BUTTON_LEFT:\n                self.dispatch_event(""on_mouse_release"", x, y, window.mouse.LEFT)\n            elif button == sdl2.SDL_BUTTON_MIDDLE:\n                self.dispatch_event(""on_mouse_release"", x, y, window.mouse.MIDDLE)\n            elif button == sdl2.SDL_BUTTON_RIGHT:\n                self.dispatch_event(""on_mouse_release"", x, y, window.mouse.RIGHT)\n\n        elif event.type == sdl2.SDL_MOUSEWHEEL:\n            offset_x = event.wheel.x\n            offset_y = event.wheel.y\n            self.dispatch_event(""on_mouse_scroll"",\n                                self._mouse_x, self._mouse_y, offset_x, offset_y)\n\n        elif event.type == sdl2.SDL_KEYUP:\n            keysym = event.key.keysym\n            modifiers = self._modifiers_translate(keysym.mod)\n            symbol = self._keyboard_translate(keysym.sym)\n            self.dispatch_event(""on_key_press"", symbol, modifiers)\n\n        elif event.type == sdl2.SDL_KEYDOWN:\n            keysym = event.key.keysym\n            modifiers = self._modifiers_translate(keysym.mod)\n            symbol = self._keyboard_translate(keysym.sym)\n            self.dispatch_event(""on_key_release"", symbol, modifiers)\n\n\n    def _modifiers_translate( self, modifiers ):\n        _modifiers = 0\n        if modifiers & (sdl2.SDLK_LSHIFT | sdl2.SDLK_RSHIFT):\n            _modifiers |= window.key.MOD_SHIFT\n        if modifiers & (sdl2.SDLK_LCTRL | sdl2.SDLK_RCTRL):\n            _modifiers |= window.key.MOD_CTRL\n        if modifiers & (sdl2.SDLK_LALT | sdl2.SDLK_RALT):\n            _modifiers |= window.key.MOD_ALT\n        return _modifiers\n\n    def _keyboard_translate(self, code):\n        ascii = code\n        if (0x020 <= ascii <= 0x040) or (0x05b <= ascii <= 0x07e):\n            return ascii\n        elif ascii <= 0x020:\n            code = ascii\n        return __key_map__.get(code, window.key.UNKNOWN)\n\n\n    def show(self):\n        sdl2.SDL_ShowWindow(self._native_window)\n        self.dispatch_event(\'on_show\')\n\n    def hide(self):\n        sdl2.SDL_HideWindow(self._native_window)\n        self.dispatch_event(\'on_hide\')\n\n    def close(self):\n        sdl2.SDL_DestroyWindow(self._native_window)\n        del __windows__[self._native_id]\n        for i in range(len(self._timer_stack)):\n            handler, interval = self._timer_stack[i]\n            self._clock.unschedule(handler)\n        self.dispatch_event(\'on_close\')\n\n    def set_title(self, title):\n        log.warn(\'%s backend cannot set window title\' % __name__)\n\n    def get_title(self):\n        log.warn(\'%s backend cannot get window title\' % __name__)\n\n    def set_size(self, width, height):\n        log.warn(\'%s backend cannot set window size\' % __name__)\n\n    def get_size(self):\n        log.warn(\'%s backend cannot get window size\' % __name__)\n\n    def set_position(self, x, y):\n        log.warn(\'%s backend cannot set window position\' % __name__)\n\n    def get_position(self):\n        log.warn(\'%s backend cannot get position\' % __name__)\n\n    def swap(self):\n        sdl2.SDL_GL_SwapWindow(self._native_window)\n\n    def activate(self):\n        sdl2.SDL_GL_MakeCurrent(self._native_window, self._native_context)\n\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__.values()\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n\n    # Poll for and process events\n    event = sdl2.SDL_Event()\n    while sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n        win_id = event.window.windowID\n        if win_id in __windows__.keys():\n            win = __windows__[win_id]\n            win.process_event(event)\n\n    for window in windows():\n        # Make window active\n        window.activate()\n\n        # Dispatch the main draw event\n        window.dispatch_event(\'on_draw\', dt)\n\n        # Dispatch the idle event\n        window.dispatch_event(\'on_idle\', dt)\n\n        # Swap buffers\n        window.swap()\n\n    return len(__windows__.values())\n'"
glumpy/app/window/backends/backend_template.py,0,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nTemplate backend for writing a new backend.\n""""""\nimport os, sys\nfrom glumpy import gl\nfrom glumpy.log import log\nfrom glumpy.app import configuration\nfrom glumpy.app.window import window\n\n\n# Backend name\n__name__ = ""Template""\n\n# Backend version (if available)\n__version__ = """"\n\n# Backend availability\n__availability__ = False\n\n# Whether the framework has been initialized\n__initialized__ = False\n\n# Active windows\n__windows__ = []\n\n\n# ---------------------------------------------------- convenient functions ---\ndef name():      return __name__\ndef version():   return __version__\ndef available(): return __availability__\n\n\n# --------------------------------------------------------------- init/exit ---\ndef __init__():\n    global __initialized__\n    __initialized__ = True\n\ndef __exit__():\n    global __initialized__\n    __initialized__ = False\n\n\n# ------------------------------------------------------------ availability ---\ntry:\n    import ToolKit # Replace with actual toolkit\n    __availability__ = True\n    __version__ = """"\n    __key_map__   = { }\n    __mouse_map__ = { }\n\nexcept ImportError:\n    __availability__ = False\n    __version__ = None\n\n\n# -------------------------------------------------------------- capability ---\ncapability = {\n    ""Window position get/set"" : False,\n    ""Window size get/set""     : False,\n    ""Multiple windows""        : False,\n    ""Mouse scroll events""     : False,\n    ""Non-decorated window""    : False,\n    ""Non-sizeable window""     : False,\n    ""Fullscreen mode""         : False,\n    ""Unicode processing""      : False,\n    ""Set GL version""          : False,\n    ""Set GL profile""          : False,\n    ""Share GL context""        : False,\n}\n\n\n\n# ------------------------------------------------------- set_configuration ---\ndef set_configuration(configuration):\n    """""" Set GL initialization here (depth buffer size, etc.) """"""\n    pass\n\n\n\n# ------------------------------------------------------------------ Window ---\nclass Window(window.Window):\n    """"""\n    Generic template for writing a new backend.\n    """"""\n\n    def __init__( self, width=512, height=512, title=None, visible=True, aspect=None,\n                  decoration=True, fullscreen=False, config=None, context=None, color=(0,0,0,1), vsync=False):\n\n        window.Window.__init__(self, width=width,\n                                     height=height,\n                                     title=title,\n                                     visible=visible,\n                                     aspect=aspect,\n                                     decoration=decoration,\n                                     fullscreen=fullscreen,\n                                     config=config,\n                                     context=context,\n                                     color=color)\n\n        # Create the native window here\n        pass\n\n        # Each on the events below must be called at some point This means you\n        # have to connect to key and mouse events using toolkit native methods\n        # and dispatch the event to glumpy event stack.\n\n        # self.dispatch_event(\'on_show\')\n        # self.dispatch_event(\'on_hide\')\n        # self.dispatch_event(\'on_close\')\n        # self.dispatch_event(\'on_resize\', width, height)\n        # self.dispatch_event(\'on_mouse_release\', x, y, button)\n        # self.dispatch_event(\'on_mouse_press\', x, y, button)\n        # self.dispatch_event(\'on_mouse_motion\', x, y, dx, dy)\n        # self.dispatch_event(\'on_mouse_drag\', x, y, dx, dy, button)\n        # self.dispatch_event(\'on_mouse_scroll\', x, y, xoffset, yoffset)\n        # self.dispatch_event(\'on_key_press\', symbol, modifiers)\n        # self.dispatch_event(\'on_key_release\', symbol, modifiers)\n        # self.dispatch_event(\'on_character\', u""%c"" % character)\n\n    def show(self):\n        glfw.glfwShowWindow( self._native_window )\n        self.dispatch_event(\'on_show\')\n\n    def hide(self):\n        glfw.glfwHideWindow( self._native_window )\n        self.dispatch_event(\'on_hide\')\n\n    def close(self):\n        glfw.glfwSetWindowShouldClose(self._native_window, True)\n        glfw.glfwDestroyWindow(self._native_window)\n        __windows__.remove(self)\n        for i in range(len(self._timer_stack)):\n            handler, interval = self._timer_stack[i]\n            self._clock.unschedule(handler)\n        self.dispatch_event(\'on_close\')\n\n    def set_title(self, title):\n        """""" Set window title """"""\n        raise(NotImplemented)\n\n    def get_title(self, title):\n        """""" Get window title """"""\n        raise(NotImplemented)\n\n    def set_size(self, width, height):\n        """""" Set window size """"""\n        raise(NotImplemented)\n\n    def get_size(self):\n        """""" Get window size """"""\n        raise(NotImplemented)\n\n    def set_position(self, x, y):\n        """""" Set window position """"""\n        raise(NotImplemented)\n\n    def get_position(self):\n        """""" Get window position """"""\n        raise(NotImplemented)\n\n    def swap(self):\n        """""" Swap GL bufffers """"""\n        raise(NotImplemented)\n\n    def activate(self):\n        """""" Make this window the (GL) active window """"""\n        raise(NotImplemented)\n\n\n\n# ----------------------------------------------------------------- windows ---\ndef windows():\n    return __windows__\n\n\n# ----------------------------------------------------------------- process ---\ndef process(dt):\n    """""" Process events for all windows. Non blocking. """"""\n\n    # Poll for and process events\n    # -> Add toolkit specific code here to process events\n    # -> Must return (non bloking)\n\n    for window in __windows__:\n        # Make window active\n        window.activate()\n\n        # Clear window using window clear flags\n        gl.glClear(window._clearflags)\n\n        # Dispatch the main draw event\n        window.dispatch_event(\'on_draw\', dt)\n\n        # Dispatch the idle event\n        window.dispatch_event(\'on_idle\', dt)\n\n        # Swap buffers\n        window.swap()\n\n    return len(__windows__)\n'"
glumpy/ext/freetype/ft_enums/__init__.py,0,"b""#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n'''\nFreetype enum types\n-------------------\n\nFT_PIXEL_MODES: An enumeration type used to describe the format of pixels in a\n                given bitmap. Note that additional formats may be added in the\n                future.\n\nFT_GLYPH_BBOX_MODES: The mode how the values of FT_Glyph_Get_CBox are returned.\n\nFT_GLYPH_FORMATS: An enumeration type used to describe the format of a given\n                  glyph image. Note that this version of FreeType only supports\n                  two image formats, even though future font drivers will be\n                  able to register their own format.\n\nFT_ENCODINGS: An enumeration used to specify character sets supported by\n              charmaps. Used in the FT_Select_Charmap API function.\n\nFT_RENDER_MODES: An enumeration type that lists the render modes supported by\n                 FreeType 2. Each mode corresponds to a specific type of\n                 scanline conversion performed on the outline.\n\nFT_LOAD_TARGETS: A list of values that are used to select a specific hinting\n                 algorithm to use by the hinter. You should OR one of these\n                 values to your 'load_flags' when calling FT_Load_Glyph.\n\nFT_LOAD_FLAGS: A list of bit-field constants used with FT_Load_Glyph to\n               indicate what kind of operations to perform during glyph\n               loading.\n\nFT_STYLE_FLAGS: A list of bit-flags used to indicate the style of a given\n                face. These are used in the 'style_flags' field of FT_FaceRec.\n\nFT_FSTYPES: A list of bit flags that inform client applications of embedding\n            and subsetting restrictions associated with a font.\n\nFT_FACE_FLAGS: A list of bit flags used in the 'face_flags' field of the\n               FT_FaceRec structure. They inform client applications of\n               properties of the corresponding face.\n\nFT_OUTLINE_FLAGS: A list of bit-field constants use for the flags in an\n                  outline's 'flags' field.\n\nFT_OPEN_MODES: A list of bit-field constants used within the 'flags' field of\n               the FT_Open_Args structure.\n\nFT_KERNING_MODES: An enumeration used to specify which kerning values to return\n                  in FT_Get_Kerning.\n\nFT_STROKER_LINEJOINS: These values determine how two joining lines are rendered\n                      in a stroker.\n\nFT_STROKER_LINECAPS: These values determine how the end of opened sub-paths are\n                     rendered in a stroke.\n\nFT_STROKER_BORDERS: These values are used to select a given stroke border in\n                    FT_Stroker_GetBorderCounts and FT_Stroker_ExportBorder.\n\nFT_LCD_FILTERS: A list of values to identify various types of LCD filters.\n\nTT_PLATFORMS: A list of valid values for the 'platform_id' identifier code in\n              FT_CharMapRec and FT_SfntName structures.\n\nTT_APPLE_IDS: A list of valid values for the 'encoding_id' for\n              TT_PLATFORM_APPLE_UNICODE charmaps and name entries.\n \nTT_MAC_IDS: A list of valid values for the 'encoding_id' for\n            TT_PLATFORM_MACINTOSH charmaps and name entries.\n\nTT_MS_IDS: A list of valid values for the 'encoding_id' for\n           TT_PLATFORM_MICROSOFT charmaps and name entries.\n\nTT_ADOBE_IDS: A list of valid values for the 'encoding_id' for\n              TT_PLATFORM_ADOBE charmaps. This is a FreeType-specific\n              extension!\n\nTT_MAC_LANGIDS: Possible values of the language identifier field in the name\n                records of the TTF `name' table if the `platform' identifier\n                code is TT_PLATFORM_MACINTOSH.\n\nTT_MS_LANGIDS: Possible values of the language identifier field in the name\n               records of the TTF `name' table if the `platform' identifier\n               code is TT_PLATFORM_MICROSOFT.\n\nTT_NAME_IDS: Possible values of the `name' identifier field in the name\n             records of the TTF `name' table.  These values are platform\n             independent.\n'''\nfrom .ft_fstypes import *\nfrom .ft_face_flags import *\nfrom .ft_encodings import *\nfrom .ft_glyph_bbox_modes import *\nfrom .ft_glyph_formats import *\nfrom .ft_kerning_modes import *\nfrom .ft_lcd_filters import *\nfrom .ft_load_flags import *\nfrom .ft_load_targets import *\nfrom .ft_open_modes import *\nfrom .ft_outline_flags import *\nfrom .ft_pixel_modes import *\nfrom .ft_render_modes import *\nfrom .ft_stroker_borders import *\nfrom .ft_stroker_linecaps import *\nfrom .ft_stroker_linejoins import *\nfrom .ft_style_flags import *\nfrom .tt_adobe_ids import *\nfrom .tt_apple_ids import *\nfrom .tt_mac_ids import *\nfrom .tt_ms_ids import *\nfrom .tt_ms_langids import *\nfrom .tt_mac_langids import *\nfrom .tt_name_ids import *\nfrom .tt_platforms import *\n"""
glumpy/ext/freetype/ft_enums/ft_encodings.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nAn enumeration used to specify character sets supported by charmaps. Used in\nthe FT_Select_Charmap API function.\n\nFT_ENCODING_NONE\t\n\n  The encoding value 0 is reserved.\n\nFT_ENCODING_UNICODE\t\n\n  Corresponds to the Unicode character set. This value covers all versions of\n  the Unicode repertoire, including ASCII and Latin-1. Most fonts include a\n  Unicode charmap, but not all of them.\n\n  For example, if you want to access Unicode value U+1F028 (and the font\n  contains it), use value 0x1F028 as the input value for FT_Get_Char_Index.\n\nFT_ENCODING_MS_SYMBOL\t\n\n  Corresponds to the Microsoft Symbol encoding, used to encode mathematical\n  symbols in the 32..255 character code range. For more information, see\n  \'http://www.ceviz.net/symbol.htm\'.\n\nFT_ENCODING_SJIS\t\n\n  Corresponds to Japanese SJIS encoding. More info at at\n  \'http://langsupport.japanreference.com/encoding.shtml\'. See note on\n  multi-byte encodings below.\n\nFT_ENCODING_GB2312\t\n\n  Corresponds to an encoding system for Simplified Chinese as used used in\n  mainland China.\n\nFT_ENCODING_BIG5\t\n\n  Corresponds to an encoding system for Traditional Chinese as used in Taiwan\n  and Hong Kong.\n\nFT_ENCODING_WANSUNG\t\n\n  Corresponds to the Korean encoding system known as Wansung. For more\n  information see \'http://www.microsoft.com/typography/unicode/949.txt\'.\n\nFT_ENCODING_JOHAB\t\n\n  The Korean standard character set (KS C 5601-1992), which corresponds to MS\n  Windows code page 1361. This character set includes all possible Hangeul\n  character combinations.\n\nFT_ENCODING_ADOBE_LATIN_1\n\n  Corresponds to a Latin-1 encoding as defined in a Type 1 PostScript font. It\n  is limited to 256 character codes.\n\nFT_ENCODING_ADOBE_STANDARD\n\n  Corresponds to the Adobe Standard encoding, as found in Type 1, CFF, and\n  OpenType/CFF fonts. It is limited to 256 character codes.\n\nFT_ENCODING_ADOBE_EXPERT\n\n  Corresponds to the Adobe Expert encoding, as found in Type 1, CFF, and\n  OpenType/CFF fonts. It is limited to 256 character codes.\n\nFT_ENCODING_ADOBE_CUSTOM\n\n  Corresponds to a custom encoding, as found in Type 1, CFF, and OpenType/CFF\n  fonts. It is limited to 256 character codes.\n\nFT_ENCODING_APPLE_ROMAN\n\n  Corresponds to the 8-bit Apple roman encoding. Many TrueType and OpenType\n  fonts contain a charmap for this encoding, since older versions of Mac OS are\n  able to use it.\n\nFT_ENCODING_OLD_LATIN_2\n\n  This value is deprecated and was never used nor reported by FreeType. Don\'t\n  use or test for it.\n""""""\n\ndef _FT_ENC_TAG(a,b,c,d):\n    return ( ord(a) << 24 | ord(b) << 16 | ord(c) << 8 | ord(d) )\n\nFT_ENCODINGS = {\'FT_ENCODING_NONE\'           : _FT_ENC_TAG(\'\\0\',\'\\0\',\'\\0\',\'\\0\'),\n                \'FT_ENCODING_MS_SYMBOL\'      : _FT_ENC_TAG( \'s\',\'y\',\'m\',\'b\' ),\n                \'FT_ENCODING_UNICODE\'        : _FT_ENC_TAG( \'u\',\'n\',\'i\',\'c\' ),\n                \'FT_ENCODING_SJIS\'           : _FT_ENC_TAG( \'s\',\'j\',\'i\',\'s\' ),\n                \'FT_ENCODING_GB2312\'         : _FT_ENC_TAG( \'g\',\'b\',\' \',\' \' ),\n                \'FT_ENCODING_BIG5\'           : _FT_ENC_TAG( \'b\',\'i\',\'g\',\'5\' ),\n                \'FT_ENCODING_WANSUNG\'        : _FT_ENC_TAG( \'w\',\'a\',\'n\',\'s\' ),\n                \'FT_ENCODING_JOHAB\'          : _FT_ENC_TAG( \'j\',\'o\',\'h\',\'a\' ),\n                \'FT_ENCODING_ADOBE_STANDARD\' : _FT_ENC_TAG( \'A\',\'D\',\'O\',\'B\' ),\n                \'FT_ENCODING_ADOBE_EXPERT\'   : _FT_ENC_TAG( \'A\',\'D\',\'B\',\'E\' ),\n                \'FT_ENCODING_ADOBE_CUSTOM\'   : _FT_ENC_TAG( \'A\',\'D\',\'B\',\'C\' ),\n                \'FT_ENCODING_ADOBE_LATIN1\'   : _FT_ENC_TAG( \'l\',\'a\',\'t\',\'1\' ),\n                \'FT_ENCODING_OLD_LATIN2\'     : _FT_ENC_TAG( \'l\',\'a\',\'t\',\'2\' ),\n                \'FT_ENCODING_APPLE_ROMAN\'    : _FT_ENC_TAG( \'a\',\'r\',\'m\',\'n\' ) }\nglobals().update(FT_ENCODINGS)\n'"
glumpy/ext/freetype/ft_enums/ft_face_flags.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of bit flags used in the \'face_flags\' field of the FT_FaceRec\nstructure. They inform client applications of properties of the corresponding\nface.\n\n\nFT_FACE_FLAG_SCALABLE\t\n\n  Indicates that the face contains outline glyphs. This doesn\'t prevent bitmap\n  strikes, i.e., a face can have both this and and FT_FACE_FLAG_FIXED_SIZES\n  set.\n\n\nFT_FACE_FLAG_FIXED_SIZES\n\n  Indicates that the face contains bitmap strikes. See also the\n  \'num_fixed_sizes\' and \'available_sizes\' fields of FT_FaceRec.\n\n\nFT_FACE_FLAG_FIXED_WIDTH\n\n  Indicates that the face contains fixed-width characters (like Courier,\n  Lucido, MonoType, etc.).\n\n\nFT_FACE_FLAG_SFNT\t\n\n  Indicates that the face uses the \'sfnt\' storage scheme. For now, this means\n  TrueType and OpenType.\n\n\nFT_FACE_FLAG_HORIZONTAL\n\n  Indicates that the face contains horizontal glyph metrics. This should be set\n  for all common formats.\n\n\nFT_FACE_FLAG_VERTICAL\t\n\n  Indicates that the face contains vertical glyph metrics. This is only\n  available in some formats, not all of them.\n\n\nFT_FACE_FLAG_KERNING\t\n\n  Indicates that the face contains kerning information. If set, the kerning\n  distance can be retrieved through the function FT_Get_Kerning. Otherwise the\n  function always return the vector (0,0). Note that FreeType doesn\'t handle\n  kerning data from the \'GPOS\' table (as present in some OpenType fonts).\n\n\nFT_FACE_FLAG_MULTIPLE_MASTERS\n\n  Indicates that the font contains multiple masters and is capable of\n  interpolating between them. See the multiple-masters specific API for\n  details.\n\n\nFT_FACE_FLAG_GLYPH_NAMES\n\n  Indicates that the font contains glyph names that can be retrieved through\n  FT_Get_Glyph_Name. Note that some TrueType fonts contain broken glyph name\n  tables. Use the function FT_Has_PS_Glyph_Names when needed.\n\n\nFT_FACE_FLAG_EXTERNAL_STREAM\n\n  Used internally by FreeType to indicate that a face\'s stream was provided by\n  the client application and should not be destroyed when FT_Done_Face is\n  called. Don\'t read or test this flag.\n\n\nFT_FACE_FLAG_HINTER\t\n\n  Set if the font driver has a hinting machine of its own. For example, with\n  TrueType fonts, it makes sense to use data from the SFNT \'gasp\' table only if\n  the native TrueType hinting engine (with the bytecode interpreter) is\n  available and active.\n\n\nFT_FACE_FLAG_CID_KEYED\t\n\n  Set if the font is CID-keyed. In that case, the font is not accessed by glyph\n  indices but by CID values. For subsetted CID-keyed fonts this has the\n  consequence that not all index values are a valid argument to\n  FT_Load_Glyph. Only the CID values for which corresponding glyphs in the\n  subsetted font exist make FT_Load_Glyph return successfully; in all other\n  cases you get an \'FT_Err_Invalid_Argument\' error.\n\n  Note that CID-keyed fonts which are in an SFNT wrapper don\'t have this flag\n  set since the glyphs are accessed in the normal way (using contiguous\n  indices); the \'CID-ness\' isn\'t visible to the application.\n\n\nFT_FACE_FLAG_TRICKY\t\n\n  Set if the font is \'tricky\', this is, it always needs the font format\'s\n  native hinting engine to get a reasonable result. A typical example is the\n  Chinese font \'mingli.ttf\' which uses TrueType bytecode instructions to move\n  and scale all of its subglyphs.\n\n  It is not possible to autohint such fonts using FT_LOAD_FORCE_AUTOHINT; it\n  will also ignore FT_LOAD_NO_HINTING. You have to set both FT_LOAD_NO_HINTING\n  and FT_LOAD_NO_AUTOHINT to really disable hinting; however, you probably\n  never want this except for demonstration purposes.\n\n  Currently, there are six TrueType fonts in the list of tricky fonts; they are\n  hard-coded in file \'ttobjs.c\'.\n""""""\nFT_FACE_FLAGS = { \'FT_FACE_FLAG_SCALABLE\'          : 1 <<  0,\n                  \'FT_FACE_FLAG_FIXED_SIZES\'       : 1 <<  1,\n                  \'FT_FACE_FLAG_FIXED_WIDTH\'       : 1 <<  2,\n                  \'FT_FACE_FLAG_SFNT\'              : 1 <<  3,\n                  \'FT_FACE_FLAG_HORIZONTAL\'        : 1 <<  4,\n                  \'FT_FACE_FLAG_VERTICAL\'          : 1 <<  5,\n                  \'FT_FACE_FLAG_KERNING\'           : 1 <<  6,\n                  \'FT_FACE_FLAG_FAST_GLYPHS\'       : 1 <<  7,\n                  \'FT_FACE_FLAG_MULTIPLE_MASTERS\'  : 1 <<  8,\n                  \'FT_FACE_FLAG_GLYPH_NAMES\'       : 1 <<  9,\n                  \'FT_FACE_FLAG_EXTERNAL_STREAM\'   : 1 << 10,\n                  \'FT_FACE_FLAG_HINTER\'            : 1 << 11,\n                  \'FT_FACE_FLAG_CID_KEYED\'         : 1 << 12,\n                  \'FT_FACE_FLAG_TRICKY\'            : 1 << 13\n}\nglobals().update(FT_FACE_FLAGS)\n\n'"
glumpy/ext/freetype/ft_enums/ft_fstypes.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of bit flags that inform client applications of embedding and\nsubsetting restrictions associated with a font.\n\nFT_FSTYPE_INSTALLABLE_EMBEDDING\n\n  Fonts with no fsType bit set may be embedded and permanently installed on\n  the remote system by an application.\n\n\nFT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING\n\n  Fonts that have only this bit set must not be modified, embedded or exchanged\n  in any manner without first obtaining permission of the font software\n  copyright owner.\n\n\nFT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING\n\n  If this bit is set, the font may be embedded and temporarily loaded on the\n  remote system. Documents containing Preview & Print fonts must be opened\n  \'read-only\'; no edits can be applied to the document.\n\n\nFT_FSTYPE_EDITABLE_EMBEDDING\n\n  If this bit is set, the font may be embedded but must only be installed\n  temporarily on other systems. In contrast to Preview & Print fonts,\n  documents containing editable fonts may be opened for reading, editing is\n  permitted, and changes may be saved.\n\n\nFT_FSTYPE_NO_SUBSETTING\n\n  If this bit is set, the font may not be subsetted prior to embedding.\n\n\nFT_FSTYPE_BITMAP_EMBEDDING_ONLY\n\n  If this bit is set, only bitmaps contained in the font may be embedded; no\n  outline data may be embedded. If there are no bitmaps available in the font,\n  then the font is unembeddable.\n""""""\n\nFT_FSTYPES = {\'FT_FSTYPE_INSTALLABLE_EMBEDDING\'        : 0x0000,\n              \'FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING\' : 0x0002,\n              \'FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING\'  : 0x0004,\n              \'FT_FSTYPE_EDITABLE_EMBEDDING\'           : 0x0008,\n              \'FT_FSTYPE_NO_SUBSETTING\'                : 0x0100,\n              \'FT_FSTYPE_BITMAP_EMBEDDING_ONLY\'        : 0x0200,}\nglobals().update(FT_FSTYPES)\nft_fstype_installable_embedding  = FT_FSTYPE_INSTALLABLE_EMBEDDING\nft_fstype_restricted_license_embedding = FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING\nft_fstype_preview_and_print_embedding = FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING\nft_fstype_editable_embedding = FT_FSTYPE_EDITABLE_EMBEDDING\nft_fstype_no_subsetting = FT_FSTYPE_NO_SUBSETTING\nft_fstype_bitmap_embedding_only = FT_FSTYPE_BITMAP_EMBEDDING_ONLY\n'"
glumpy/ext/freetype/ft_enums/ft_glyph_bbox_modes.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nThe mode how the values of FT_Glyph_Get_CBox are returned.\n\nFT_GLYPH_BBOX_UNSCALED\t\n\n  Return unscaled font units.\n\nFT_GLYPH_BBOX_SUBPIXELS\n\n  Return unfitted 26.6 coordinates.\n\nFT_GLYPH_BBOX_GRIDFIT\t\n\n  Return grid-fitted 26.6 coordinates.\n\nFT_GLYPH_BBOX_TRUNCATE\t\n\n  Return coordinates in integer pixels.\n\nFT_GLYPH_BBOX_PIXELS\t\n\n  Return grid-fitted pixel coordinates.\n""""""\nFT_GLYPH_BBOX_MODES = {\'FT_GLYPH_BBOX_UNSCALED\'  : 0,\n                       \'FT_GLYPH_BBOX_SUBPIXELS\' : 0,\n                       \'FT_GLYPH_BBOX_GRIDFIT\'   : 1,\n                       \'FT_GLYPH_BBOX_TRUNCATE\'  : 2,\n                       \'FT_GLYPH_BBOX_PIXELS\'    : 3}\nglobals().update(FT_GLYPH_BBOX_MODES)\n'"
glumpy/ext/freetype/ft_enums/ft_glyph_formats.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nAn enumeration type used to describe the format of a given glyph image. Note\nthat this version of FreeType only supports two image formats, even though\nfuture font drivers will be able to register their own format.\n\nFT_GLYPH_FORMAT_NONE\t\n\n  The value 0 is reserved.\n\nFT_GLYPH_FORMAT_COMPOSITE\n\n  The glyph image is a composite of several other images. This format is only\n  used with FT_LOAD_NO_RECURSE, and is used to report compound glyphs (like\n  accented characters).\n\nFT_GLYPH_FORMAT_BITMAP\t\n\n  The glyph image is a bitmap, and can be described as an FT_Bitmap. You\n  generally need to access the \'bitmap\' field of the FT_GlyphSlotRec structure\n  to read it.\n\nFT_GLYPH_FORMAT_OUTLINE\n\n  The glyph image is a vectorial outline made of line segments and Bezier arcs;\n  it can be described as an FT_Outline; you generally want to access the\n  \'outline\' field of the FT_GlyphSlotRec structure to read it.\n\nFT_GLYPH_FORMAT_PLOTTER\n\n  The glyph image is a vectorial path with no inside and outside contours. Some\n  Type 1 fonts, like those in the Hershey family, contain glyphs in this\n  format. These are described as FT_Outline, but FreeType isn\'t currently\n  capable of rendering them correctly.\n""""""\n\ndef _FT_IMAGE_TAG(a,b,c,d):\n    return ( ord(a) << 24 | ord(b) << 16 | ord(c) << 8 | ord(d) )\n\nFT_GLYPH_FORMATS = {\n    \'FT_GLYPH_FORMAT_NONE\'      : _FT_IMAGE_TAG( \'\\0\',\'\\0\',\'\\0\',\'\\0\' ),\n    \'FT_GLYPH_FORMAT_COMPOSITE\' : _FT_IMAGE_TAG( \'c\',\'o\',\'m\',\'p\' ),\n    \'FT_GLYPH_FORMAT_BITMAP\'    : _FT_IMAGE_TAG( \'b\',\'i\',\'t\',\'s\' ),\n    \'FT_GLYPH_FORMAT_OUTLINE\'   : _FT_IMAGE_TAG( \'o\',\'u\',\'t\',\'l\' ),\n    \'FT_GLYPH_FORMAT_PLOTTER\'   : _FT_IMAGE_TAG( \'p\',\'l\',\'o\',\'t\' )}\nglobals().update(FT_GLYPH_FORMATS)\nft_glyph_format_none      = FT_GLYPH_FORMAT_NONE\nft_glyph_format_composite = FT_GLYPH_FORMAT_COMPOSITE\nft_glyph_format_bitmap    = FT_GLYPH_FORMAT_BITMAP\nft_glyph_format_outline   = FT_GLYPH_FORMAT_OUTLINE\nft_glyph_format_plotter   = FT_GLYPH_FORMAT_PLOTTER\n'"
glumpy/ext/freetype/ft_enums/ft_kerning_modes.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nAn enumeration used to specify which kerning values to return in\nFT_Get_Kerning.\n\n\nFT_KERNING_DEFAULT\t\n\n  Return scaled and grid-fitted kerning distances (value is 0).\n\n\nFT_KERNING_UNFITTED\t\n\n  Return scaled but un-grid-fitted kerning distances.\n\n\nFT_KERNING_UNSCALED\t\n\n  Return the kerning vector in original font units.\n""""""\nFT_KERNING_MODES = { \'FT_KERNING_DEFAULT\'  : 0,\n                     \'FT_KERNING_UNFITTED\' : 1,\n                     \'FT_KERNING_UNSCALED\' : 2 }\nglobals().update(FT_KERNING_MODES)\n'"
glumpy/ext/freetype/ft_enums/ft_lcd_filters.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n\n""""""\nA list of values to identify various types of LCD filters.\n\n\nFT_LCD_FILTER_NONE\t\n\n  Do not perform filtering. When used with subpixel rendering, this results in\n  sometimes severe color fringes.\n\n\nFT_LCD_FILTER_DEFAULT\t\n\n  The default filter reduces color fringes considerably, at the cost of a\n  slight blurriness in the output.\n\n\nFT_LCD_FILTER_LIGHT\t\n\n  The light filter is a variant that produces less blurriness at the cost of\n  slightly more color fringes than the default one. It might be better,\n  depending on taste, your monitor, or your personal vision.\n\n\nFT_LCD_FILTER_LEGACY\t\n\n  This filter corresponds to the original libXft color filter. It provides high\n  contrast output but can exhibit really bad color fringes if glyphs are not\n  extremely well hinted to the pixel grid. In other words, it only works well\n  if the TrueType bytecode interpreter is enabled and high-quality hinted fonts\n  are used.\n\n  This filter is only provided for comparison purposes, and might be disabled\n  or stay unsupported in the future.\n""""""\n\nFT_LCD_FILTERS = {\'FT_LCD_FILTER_NONE\'    : 0,\n                  \'FT_LCD_FILTER_DEFAULT\' : 1,\n                  \'FT_LCD_FILTER_LIGHT\'   : 2,\n                  \'FT_LCD_FILTER_LEGACY\'  : 16}\nglobals().update(FT_LCD_FILTERS)\n\n\n'"
glumpy/ext/freetype/ft_enums/ft_load_flags.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of bit-field constants used with FT_Load_Glyph to indicate what kind\nof operations to perform during glyph loading.\n\n\nFT_LOAD_DEFAULT\t\n\n  Corresponding to 0, this value is used as the default glyph load\n  operation. In this case, the following happens:\n\n  1. FreeType looks for a bitmap for the glyph corresponding to the face\'s\n     current size. If one is found, the function returns. The bitmap data can\n     be accessed from the glyph slot (see note below).\n \n  2. If no embedded bitmap is searched or found, FreeType looks for a scalable\n     outline. If one is found, it is loaded from the font file, scaled to\n     device pixels, then \'hinted\' to the pixel grid in order to optimize\n     it. The outline data can be accessed from the glyph slot (see note below).\n\n  Note that by default, the glyph loader doesn\'t render outlines into\n  bitmaps. The following flags are used to modify this default behaviour to\n  more specific and useful cases.\n\n\nFT_LOAD_NO_SCALE\n\n  Don\'t scale the outline glyph loaded, but keep it in font units.\n\n  This flag implies FT_LOAD_NO_HINTING and FT_LOAD_NO_BITMAP, and unsets\n  FT_LOAD_RENDER.\n\n\nFT_LOAD_NO_HINTING\t\n\n  Disable hinting. This generally generates \'blurrier\' bitmap glyph when the\n  glyph is rendered in any of the anti-aliased modes. See also the note below.\n\n  This flag is implied by FT_LOAD_NO_SCALE.\n\n\nFT_LOAD_RENDER\t\n\n  Call FT_Render_Glyph after the glyph is loaded. By default, the glyph is\n  rendered in FT_RENDER_MODE_NORMAL mode. This can be overridden by\n  FT_LOAD_TARGET_XXX or FT_LOAD_MONOCHROME.\n\n  This flag is unset by FT_LOAD_NO_SCALE.\n\n\nFT_LOAD_NO_BITMAP\t\n\n  Ignore bitmap strikes when loading. Bitmap-only fonts ignore this flag.\n\n  FT_LOAD_NO_SCALE always sets this flag.\n\n\nFT_LOAD_VERTICAL_LAYOUT\n\n  Load the glyph for vertical text layout. Don\'t use it as it is problematic\n  currently.\n\n\nFT_LOAD_FORCE_AUTOHINT\t\n\n  Indicates that the auto-hinter is preferred over the font\'s native\n  hinter. See also the note below.\n\n\nFT_LOAD_CROP_BITMAP\t\n\n  Indicates that the font driver should crop the loaded bitmap glyph (i.e.,\n  remove all space around its black bits). Not all drivers implement this.\n\n\nFT_LOAD_PEDANTIC\t\n\n  Indicates that the font driver should perform pedantic verifications during\n  glyph loading. This is mostly used to detect broken glyphs in fonts. By\n  default, FreeType tries to handle broken fonts also.\n\n\nFT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH\n\n  Indicates that the font driver should ignore the global advance width defined\n  in the font. By default, that value is used as the advance width for all\n  glyphs when the face has FT_FACE_FLAG_FIXED_WIDTH set.\n\n  This flag exists for historical reasons (to support buggy CJK fonts).\n\n\nFT_LOAD_NO_RECURSE\t\n\n  This flag is only used internally. It merely indicates that the font driver\n  should not load composite glyphs recursively. Instead, it should set the\n  \'num_subglyph\' and \'subglyphs\' values of the glyph slot accordingly, and set\n  \'glyph->format\' to FT_GLYPH_FORMAT_COMPOSITE.\n\n  The description of sub-glyphs is not available to client applications for now.\n\n  This flag implies FT_LOAD_NO_SCALE and FT_LOAD_IGNORE_TRANSFORM.\n\n\nFT_LOAD_IGNORE_TRANSFORM\n\n  Indicates that the transform matrix set by FT_Set_Transform should be ignored.\n\n\nFT_LOAD_MONOCHROME\t\n\n  This flag is used with FT_LOAD_RENDER to indicate that you want to render an\n  outline glyph to a 1-bit monochrome bitmap glyph, with 8 pixels packed into\n  each byte of the bitmap data.\n\n  Note that this has no effect on the hinting algorithm used. You should rather\n  use FT_LOAD_TARGET_MONO so that the monochrome-optimized hinting algorithm is\n  used.\n\n\nFT_LOAD_LINEAR_DESIGN\t\n\n  Indicates that the \'linearHoriAdvance\' and \'linearVertAdvance\' fields of\n  FT_GlyphSlotRec should be kept in font units. See FT_GlyphSlotRec for\n  details.\n\n\nFT_LOAD_NO_AUTOHINT\t\n\n  Disable auto-hinter. See also the note below.\n""""""\n\nFT_LOAD_FLAGS = { \'FT_LOAD_DEFAULT\'                      : 0x0,\n                  \'FT_LOAD_NO_SCALE\'                     : 0x1,\n                  \'FT_LOAD_NO_HINTING\'                   : 0x2,\n                  \'FT_LOAD_RENDER\'                       : 0x4,\n                  \'FT_LOAD_NO_BITMAP\'                    : 0x8,\n                  \'FT_LOAD_VERTICAL_LAYOUT\'              : 0x10,\n                  \'FT_LOAD_FORCE_AUTOHINT\'               : 0x20,\n                  \'FT_LOAD_CROP_BITMAP\'                  : 0x40,\n                  \'FT_LOAD_PEDANTIC\'                     : 0x80,\n                  \'FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH\'  : 0x200,\n                  \'FT_LOAD_NO_RECURSE\'                   : 0x400,\n                  \'FT_LOAD_IGNORE_TRANSFORM\'             : 0x800,\n                  \'FT_LOAD_MONOCHROME\'                   : 0x1000,\n                  \'FT_LOAD_LINEAR_DESIGN\'                : 0x2000,\n                  \'FT_LOAD_NO_AUTOHINT\'                  : 0x8000 }\nglobals().update(FT_LOAD_FLAGS)\n'"
glumpy/ext/freetype/ft_enums/ft_load_targets.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of values that are used to select a specific hinting algorithm to use\nby the hinter. You should OR one of these values to your \'load_flags\' when\ncalling FT_Load_Glyph.\n\nNote that font\'s native hinters may ignore the hinting algorithm you have\nspecified (e.g., the TrueType bytecode interpreter). You can set\nFT_LOAD_FORCE_AUTOHINT to ensure that the auto-hinter is used.\n\nAlso note that FT_LOAD_TARGET_LIGHT is an exception, in that it always\nimplies FT_LOAD_FORCE_AUTOHINT.\n\n\nFT_LOAD_TARGET_NORMAL\t\n\n  This corresponds to the default hinting algorithm, optimized for standard\n  gray-level rendering. For monochrome output, use FT_LOAD_TARGET_MONO instead.\n\n\nFT_LOAD_TARGET_LIGHT\t\n\n  A lighter hinting algorithm for non-monochrome modes. Many generated glyphs\n  are more fuzzy but better resemble its original shape. A bit like rendering\n  on Mac OS X.\n\n  As a special exception, this target implies FT_LOAD_FORCE_AUTOHINT.\n\n\nFT_LOAD_TARGET_MONO\t\n\n  Strong hinting algorithm that should only be used for monochrome output. The\n  result is probably unpleasant if the glyph is rendered in non-monochrome\n  modes.\n\n\nFT_LOAD_TARGET_LCD\t\n\n  A variant of FT_LOAD_TARGET_NORMAL optimized for horizontally decimated LCD\n  displays.\n\n\nFT_LOAD_TARGET_LCD_V\t\n\n  A variant of FT_LOAD_TARGET_NORMAL optimized for vertically decimated LCD\n  displays.\n""""""\n\nfrom .ft_render_modes import *\n\n\ndef _FT_LOAD_TARGET_(x):\n    return (x & 15) << 16\nFT_LOAD_TARGETS = {\n    \'FT_LOAD_TARGET_NORMAL\' : _FT_LOAD_TARGET_(FT_RENDER_MODE_NORMAL),\n    \'FT_LOAD_TARGET_LIGHT\'  : _FT_LOAD_TARGET_(FT_RENDER_MODE_LIGHT),\n    \'FT_LOAD_TARGET_MONO\'   : _FT_LOAD_TARGET_(FT_RENDER_MODE_MONO),\n    \'FT_LOAD_TARGET_LCD\'    : _FT_LOAD_TARGET_(FT_RENDER_MODE_LCD),\n    \'FT_LOAD_TARGET_LCD_V\'  : _FT_LOAD_TARGET_(FT_RENDER_MODE_LCD_V) }\nglobals().update(FT_LOAD_TARGETS)\n#def FT_LOAD_TARGET_MODE(x):\n#    return (x >> 16) & 15\n\n'"
glumpy/ext/freetype/ft_enums/ft_open_modes.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of bit-field constants used within the \'flags\' field of the\nFT_Open_Args structure.\n \n\nFT_OPEN_MEMORY\t\n\n  This is a memory-based stream.\n\n\nFT_OPEN_STREAM\t\n\n  Copy the stream from the \'stream\' field.\n\n\nFT_OPEN_PATHNAME\t\n\n  Create a new input stream from a C path name.\n\n\nFT_OPEN_DRIVER\t\n\n  Use the \'driver\' field.\n\n\nFT_OPEN_PARAMS\t\n\n  Use the \'num_params\' and \'params\' fields.\n""""""\nFT_OPEN_MODES = {\'FT_OPEN_MEMORY\':   0x1,\n                 \'FT_OPEN_STREAM\':   0x2,\n                 \'FT_OPEN_PATHNAME\': 0x4,\n                 \'FT_OPEN_DRIVER\':   0x8,\n                 \'FT_OPEN_PARAMS\':   0x10 }\nglobals().update(FT_OPEN_MODES)\n\n\n'"
glumpy/ext/freetype/ft_enums/ft_outline_flags.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of bit-field constants use for the flags in an outline\'s \'flags\'\nfield.\n\n\nFT_OUTLINE_NONE\t\n\n  Value 0 is reserved.\n\n\nFT_OUTLINE_OWNER\t\n\n  If set, this flag indicates that the outline\'s field arrays (i.e., \'points\',\n  \'flags\', and \'contours\') are \'owned\' by the outline object, and should thus\n  be freed when it is destroyed.\n\n\nFT_OUTLINE_EVEN_ODD_FILL\n\n  By default, outlines are filled using the non-zero winding rule. If set to 1,\n  the outline will be filled using the even-odd fill rule (only works with the\n  smooth rasterizer).\n\n\nFT_OUTLINE_REVERSE_FILL\n\n  By default, outside contours of an outline are oriented in clock-wise\n  direction, as defined in the TrueType specification. This flag is set if the\n  outline uses the opposite direction (typically for Type 1 fonts). This flag\n  is ignored by the scan converter.\n\n\nFT_OUTLINE_IGNORE_DROPOUTS\n\n  By default, the scan converter will try to detect drop-outs in an outline and\n  correct the glyph bitmap to ensure consistent shape continuity. If set, this\n  flag hints the scan-line converter to ignore such cases. See below for more\n  information.\n\n\nFT_OUTLINE_SMART_DROPOUTS\n\n  Select smart dropout control. If unset, use simple dropout control. Ignored\n  if FT_OUTLINE_IGNORE_DROPOUTS is set. See below for more information.\n\n\nFT_OUTLINE_INCLUDE_STUBS\n\n  If set, turn pixels on for \'stubs\', otherwise exclude them. Ignored if\n  FT_OUTLINE_IGNORE_DROPOUTS is set. See below for more information.\n\n\nFT_OUTLINE_HIGH_PRECISION\n \n  This flag indicates that the scan-line converter should try to convert this\n  outline to bitmaps with the highest possible quality. It is typically set for\n  small character sizes. Note that this is only a hint that might be completely\n  ignored by a given scan-converter.\n\n\nFT_OUTLINE_SINGLE_PASS\t\n\n  This flag is set to force a given scan-converter to only use a single pass\n  over the outline to render a bitmap glyph image. Normally, it is set for very\n  large character sizes. It is only a hint that might be completely ignored by\n  a given scan-converter.\n""""""\nFT_OUTLINE_FLAGS = { \'FT_OUTLINE_NONE\'            : 0x0,\n                     \'FT_OUTLINE_OWNER\'           : 0x1,\n                     \'FT_OUTLINE_EVEN_ODD_FILL\'   : 0x2,\n                     \'FT_OUTLINE_REVERSE_FILL\'    : 0x4,\n                     \'FT_OUTLINE_IGNORE_DROPOUTS\' : 0x8,\n                     \'FT_OUTLINE_SMART_DROPOUTS\'  : 0x10,\n                     \'FT_OUTLINE_INCLUDE_STUBS\'   : 0x20,\n                     \'FT_OUTLINE_HIGH_PRECISION\'  : 0x100,\n                     \'FT_OUTLINE_SINGLE_PASS\'     : 0x200 }\nglobals().update(FT_OUTLINE_FLAGS)\n\n\n'"
glumpy/ext/freetype/ft_enums/ft_pixel_modes.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nAn enumeration type that lists the render modes supported by FreeType 2. Each\nmode corresponds to a specific type of scanline conversion performed on the\noutline.\n\n\nFT_PIXEL_MODE_NONE\n\n  Value 0 is reserved.\n\n\nFT_PIXEL_MODE_MONO\n\n  A monochrome bitmap, using 1 bit per pixel. Note that pixels are stored in\n  most-significant order (MSB), which means that the left-most pixel in a byte\n  has value 128.\n\n\nFT_PIXEL_MODE_GRAY\t\n\n  An 8-bit bitmap, generally used to represent anti-aliased glyph images. Each\n  pixel is stored in one byte. Note that the number of \'gray\' levels is stored\n  in the \'num_grays\' field of the FT_Bitmap structure (it generally is 256).\n\n\nFT_PIXEL_MODE_GRAY2   \n\n  A 2-bit per pixel bitmap, used to represent embedded anti-aliased bitmaps in\n  font files according to the OpenType specification. We haven\'t found a single\n  font using this format, however.\n\n\nFT_PIXEL_MODE_GRAY4   \n\n  A 4-bit per pixel bitmap, representing embedded anti-aliased bitmaps in font\n  files according to the OpenType specification. We haven\'t found a single font\n  using this format, however.\n\n\nFT_PIXEL_MODE_LCD     \n\n  An 8-bit bitmap, representing RGB or BGR decimated glyph images used for\n  display on LCD displays; the bitmap is three times wider than the original\n  glyph image. See also FT_RENDER_MODE_LCD.\n\n\nFT_PIXEL_MODE_LCD_V   \n\n  An 8-bit bitmap, representing RGB or BGR decimated glyph images used for\n  display on rotated LCD displays; the bitmap is three times taller than the\n  original glyph image. See also FT_RENDER_MODE_LCD_V.\n\n""""""\n\nFT_PIXEL_MODES = {\'FT_PIXEL_MODE_NONE\' : 0,\n                  \'FT_PIXEL_MODE_MONO\' : 1,\n                  \'FT_PIXEL_MODE_GRAY\' : 2,\n                  \'FT_PIXEL_MODE_GRAY2\': 3,\n                  \'FT_PIXEL_MODE_GRAY4\': 4,\n                  \'FT_PIXEL_MODE_LCD\'  : 5,\n                  \'FT_PIXEL_MODE_LCD_V\': 6,\n                  \'FT_PIXEL_MODE_MAX\'  : 7}\nglobals().update(FT_PIXEL_MODES)\nft_pixel_mode_none  = FT_PIXEL_MODE_NONE\nft_pixel_mode_mono  = FT_PIXEL_MODE_MONO\nft_pixel_mode_grays = FT_PIXEL_MODE_GRAY\nft_pixel_mode_pal2  = FT_PIXEL_MODE_GRAY2\nft_pixel_mode_pal4  = FT_PIXEL_MODE_GRAY4\n\n'"
glumpy/ext/freetype/ft_enums/ft_render_modes.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nAn enumeration type that lists the render modes supported by FreeType 2. Each\nmode corresponds to a specific type of scanline conversion performed on the\noutline.\n\nFor bitmap fonts and embedded bitmaps the \'bitmap->pixel_mode\' field in the\nFT_GlyphSlotRec structure gives the format of the returned bitmap.\n\nAll modes except FT_RENDER_MODE_MONO use 256 levels of opacity.\n\n\nFT_RENDER_MODE_NORMAL\t\n\n  This is the default render mode; it corresponds to 8-bit anti-aliased\n  bitmaps.\n\n\nFT_RENDER_MODE_LIGHT\t\n\n  This is equivalent to FT_RENDER_MODE_NORMAL. It is only defined as a separate\n  value because render modes are also used indirectly to define hinting\n  algorithm selectors. See FT_LOAD_TARGET_XXX for details.\n\n\nFT_RENDER_MODE_MONO\t\n\n  This mode corresponds to 1-bit bitmaps (with 2 levels of opacity).\n\n\nFT_RENDER_MODE_LCD\t\n\n  This mode corresponds to horizontal RGB and BGR sub-pixel displays like LCD\n  screens. It produces 8-bit bitmaps that are 3 times the width of the original\n  glyph outline in pixels, and which use the FT_PIXEL_MODE_LCD mode.\n\n\nFT_RENDER_MODE_LCD_V\t\n\n  This mode corresponds to vertical RGB and BGR sub-pixel displays (like PDA\n  screens, rotated LCD displays, etc.). It produces 8-bit bitmaps that are 3\n  times the height of the original glyph outline in pixels and use the\n  FT_PIXEL_MODE_LCD_V mode.\n""""""\nFT_RENDER_MODES = { \'FT_RENDER_MODE_NORMAL\' : 0,\n                    \'FT_RENDER_MODE_LIGHT\'  : 1,\n                    \'FT_RENDER_MODE_MONO\'   : 2,\n                    \'FT_RENDER_MODE_LCD\'    : 3,\n                    \'FT_RENDER_MODE_LCD_V\'  : 4 }\nglobals().update(FT_RENDER_MODES)\n'"
glumpy/ext/freetype/ft_enums/ft_stroker_borders.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nThese values are used to select a given stroke border in\nFT_Stroker_GetBorderCounts and FT_Stroker_ExportBorder.\n\n\nFT_STROKER_BORDER_LEFT\t\n\n  Select the left border, relative to the drawing direction.\n\n\nFT_STROKER_BORDER_RIGHT\n\n  Select the right border, relative to the drawing direction.\n\n\nNote\n\n  Applications are generally interested in the \'inside\' and \'outside\'\n  borders. However, there is no direct mapping between these and the \'left\' and\n  \'right\' ones, since this really depends on the glyph\'s drawing orientation,\n  which varies between font formats.\n\n  You can however use FT_Outline_GetInsideBorder and\n  FT_Outline_GetOutsideBorder to get these.\n""""""\nFT_STROKER_BORDERS = { \'FT_STROKER_BORDER_LEFT\'  : 0,\n                       \'FT_STROKER_BORDER_RIGHT\' : 1}\nglobals().update(FT_STROKER_BORDERS)\n\n\n'"
glumpy/ext/freetype/ft_enums/ft_stroker_linecaps.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nThese values determine how the end of opened sub-paths are rendered in a\nstroke.\n\n\nFT_STROKER_LINECAP_BUTT\n\n  The end of lines is rendered as a full stop on the last point itself.\n\n\nFT_STROKER_LINECAP_ROUND\n\n  The end of lines is rendered as a half-circle around the last point.\n\n\nFT_STROKER_LINECAP_SQUARE\n\n  The end of lines is rendered as a square around the last point.\n""""""\n\nFT_STROKER_LINECAPS = { \'FT_STROKER_LINECAP_BUTT\'   : 0,\n                        \'FT_STROKER_LINECAP_ROUND\'  : 1,\n                        \'FT_STROKER_LINECAP_SQUARE\' : 2}\nglobals().update(FT_STROKER_LINECAPS)\n\n\n'"
glumpy/ext/freetype/ft_enums/ft_stroker_linejoins.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nThese values determine how two joining lines are rendered in a stroker.\n\n\nFT_STROKER_LINEJOIN_ROUND\n\n  Used to render rounded line joins. Circular arcs are used to join two lines\n  smoothly.\n\n\nFT_STROKER_LINEJOIN_BEVEL\n\n  Used to render beveled line joins; i.e., the two joining lines are extended\n  until they intersect.\n\n\nFT_STROKER_LINEJOIN_MITER\n\n  Same as beveled rendering, except that an additional line break is added if\n  the angle between the two joining lines is too closed (this is useful to\n  avoid unpleasant spikes in beveled rendering).\n""""""\nFT_STROKER_LINEJOINS = { \'FT_STROKER_LINEJOIN_ROUND\' : 0,\n                         \'FT_STROKER_LINEJOIN_BEVEL\' : 1,\n                         \'FT_STROKER_LINEJOIN_MITER\' : 2}\nglobals().update(FT_STROKER_LINEJOINS)\n\n\n'"
glumpy/ext/freetype/ft_enums/ft_style_flags.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of bit-flags used to indicate the style of a given face. These are\nused in the \'style_flags\' field of FT_FaceRec.\n\n\nFT_STYLE_FLAG_ITALIC\t\n\n  Indicates that a given face style is italic or oblique.\n\n\nFT_STYLE_FLAG_BOLD\t\n\n  Indicates that a given face is bold.\n""""""\nFT_STYLE_FLAGS = {\'FT_STYLE_FLAG_ITALIC\' : 1,\n                   \'FT_STYLE_FLAG_BOLD\'   : 2 }\nglobals().update(FT_STYLE_FLAGS)\n\n\n\n'"
glumpy/ext/freetype/ft_enums/tt_adobe_ids.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of valid values for the \'encoding_id\' for TT_PLATFORM_ADOBE\ncharmaps. This is a FreeType-specific extension!\n\nTT_ADOBE_ID_STANDARD\t\n\n  Adobe standard encoding.\n\n\nTT_ADOBE_ID_EXPERT\t\n\n  Adobe expert encoding.\n\n\nTT_ADOBE_ID_CUSTOM\t\n\n  Adobe custom encoding.\n\n\nTT_ADOBE_ID_LATIN_1\t\n\n  Adobe Latin 1 encoding.\n""""""\n\nTT_ADOBE_IDS = {\n    \'TT_ADOBE_ID_STANDARD\' : 0,\n    \'TT_ADOBE_ID_EXPERT\'   : 1,\n    \'TT_ADOBE_ID_CUSTOM\'   : 2,\n    \'TT_ADOBE_ID_LATIN_1\'  : 3 }\nglobals().update(TT_ADOBE_IDS)\n'"
glumpy/ext/freetype/ft_enums/tt_apple_ids.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of valid values for the \'encoding_id\' for TT_PLATFORM_APPLE_UNICODE\ncharmaps and name entries.\n\n\nTT_APPLE_ID_DEFAULT\t\n\n  Unicode version 1.0.\n\n\nTT_APPLE_ID_UNICODE_1_1\n\n  Unicode 1.1; specifies Hangul characters starting at U+34xx.\n\n\nTT_APPLE_ID_ISO_10646\t\n\n  Deprecated (identical to preceding).\n\n\nTT_APPLE_ID_UNICODE_2_0\n\n  Unicode 2.0 and beyond (UTF-16 BMP only).\n\n\nTT_APPLE_ID_UNICODE_32\t\n\n  Unicode 3.1 and beyond, using UTF-32.\n\n\nTT_APPLE_ID_VARIANT_SELECTOR\n\n  From Adobe, not Apple. Not a normal cmap. Specifies variations on a real\n  cmap.\n""""""\nTT_APPLE_IDS = {\n    \'TT_APPLE_ID_DEFAULT\'          : 0,\n    \'TT_APPLE_ID_UNICODE_1_1\'      : 1,\n    \'TT_APPLE_ID_ISO_10646\'        : 2,\n    \'TT_APPLE_ID_UNICODE_2_0\'      : 3,\n    \'TT_APPLE_ID_UNICODE_32\'       : 4,\n    \'TT_APPLE_ID_VARIANT_SELECTOR\' : 5 }\nglobals().update(TT_APPLE_IDS)\n\n\n'"
glumpy/ext/freetype/ft_enums/tt_mac_ids.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of valid values for the \'encoding_id\' for TT_PLATFORM_MACINTOSH\ncharmaps and name entries.\n\nTT_MAC_ID_ROMAN\n\nTT_MAC_ID_TELUGU\n\nTT_MAC_ID_GURMUKHI\n\nTT_MAC_ID_TIBETAN\n\nTT_MAC_ID_SIMPLIFIED_CHINESE\n\nTT_MAC_ID_SINDHI\n\nTT_MAC_ID_SINHALESE\n\nTT_MAC_ID_RUSSIAN\n\nTT_MAC_ID_KANNADA\n\nTT_MAC_ID_VIETNAMESE\n\nTT_MAC_ID_MONGOLIAN\n\nTT_MAC_ID_DEVANAGARI\n\nTT_MAC_ID_HEBREW\n\nTT_MAC_ID_TAMIL\n\nTT_MAC_ID_THAI\n\nTT_MAC_ID_BURMESE\n\nTT_MAC_ID_MALDIVIAN\n\nTT_MAC_ID_TRADITIONAL_CHINESE\n\nTT_MAC_ID_JAPANESE\n\nTT_MAC_ID_GREEK\n\nTT_MAC_ID_LAOTIAN\n\nTT_MAC_ID_KHMER\n\nTT_MAC_ID_UNINTERP\n\nTT_MAC_ID_ORIYA\n\nTT_MAC_ID_RSYMBOL\n\nTT_MAC_ID_MALAYALAM\n\nTT_MAC_ID_GEEZ\n\nTT_MAC_ID_KOREAN\n\nTT_MAC_ID_GUJARATI\n\nTT_MAC_ID_BENGALI\n\nTT_MAC_ID_ARABIC\n\nTT_MAC_ID_GEORGIAN\n\nTT_MAC_ID_ARMENIAN\n\nTT_MAC_ID_SLAVIC\n""""""\n\nTT_MAC_IDS = {\n    \'TT_MAC_ID_ROMAN\'               :  0,\n    \'TT_MAC_ID_JAPANESE\'            :  1,\n    \'TT_MAC_ID_TRADITIONAL_CHINESE\' :  2,\n    \'TT_MAC_ID_KOREAN\'              :  3,\n    \'TT_MAC_ID_ARABIC\'              :  4,\n    \'TT_MAC_ID_HEBREW\'              :  5,\n    \'TT_MAC_ID_GREEK\'               :  6,\n    \'TT_MAC_ID_RUSSIAN\'             :  7,\n    \'TT_MAC_ID_RSYMBOL\'             :  8,\n    \'TT_MAC_ID_DEVANAGARI\'          :  9,\n    \'TT_MAC_ID_GURMUKHI\'            : 10,\n    \'TT_MAC_ID_GUJARATI\'            : 11,\n    \'TT_MAC_ID_ORIYA\'               : 12,\n    \'TT_MAC_ID_BENGALI\'             : 13,\n    \'TT_MAC_ID_TAMIL\'               : 14,\n    \'TT_MAC_ID_TELUGU\'              : 15,\n    \'TT_MAC_ID_KANNADA\'             : 16,\n    \'TT_MAC_ID_MALAYALAM\'           : 17,\n    \'TT_MAC_ID_SINHALESE\'           : 18,\n    \'TT_MAC_ID_BURMESE\'             : 19,\n    \'TT_MAC_ID_KHMER\'               : 20,\n    \'TT_MAC_ID_THAI\'                : 21,\n    \'TT_MAC_ID_LAOTIAN\'             : 22,\n    \'TT_MAC_ID_GEORGIAN\'            : 23,\n    \'TT_MAC_ID_ARMENIAN\'            : 24,\n    \'TT_MAC_ID_MALDIVIAN\'           : 25,\n    \'TT_MAC_ID_SIMPLIFIED_CHINESE\'  : 25,\n    \'TT_MAC_ID_TIBETAN\'             : 26,\n    \'TT_MAC_ID_MONGOLIAN\'           : 27,\n    \'TT_MAC_ID_GEEZ\'                : 28,\n    \'TT_MAC_ID_SLAVIC\'              : 29,\n    \'TT_MAC_ID_VIETNAMESE\'          : 30,\n    \'TT_MAC_ID_SINDHI\'              : 31,\n    \'TT_MAC_ID_UNINTERP\'            : 32}\nglobals().update(TT_MAC_IDS)\n'"
glumpy/ext/freetype/ft_enums/tt_mac_langids.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nPossible values of the language identifier field in the name records of the\nTTF \'name\' table if the \'platform\' identifier code is TT_PLATFORM_MACINTOSH.\n\nTT_MAC_LANGID_LATIN\n\nTT_MAC_LANGID_MALAY_ARABIC_SCRIPT\n\nTT_MAC_LANGID_HINDI\n\nTT_MAC_LANGID_CATALAN\n\nTT_MAC_LANGID_MARATHI\n\nTT_MAC_LANGID_ICELANDIC\n\nTT_MAC_LANGID_ARABIC\n\nTT_MAC_LANGID_SWAHILI\n\nTT_MAC_LANGID_KHMER\n\nTT_MAC_LANGID_UKRAINIAN\n\nTT_MAC_LANGID_FINNISH\n\nTT_MAC_LANGID_POLISH\n\nTT_MAC_LANGID_NEPALI\n\nTT_MAC_LANGID_UZBEK\n\nTT_MAC_LANGID_TELUGU\n\nTT_MAC_LANGID_MALTESE\n\nTT_MAC_LANGID_AFRIKAANS\n\nTT_MAC_LANGID_CHEWA\n\nTT_MAC_LANGID_BASQUE\n\nTT_MAC_LANGID_CZECH\n\nTT_MAC_LANGID_ROMANIAN\n\nTT_MAC_LANGID_QUECHUA\n\nTT_MAC_LANGID_TAGALOG\n\nTT_MAC_LANGID_HUNGARIAN\n\nTT_MAC_LANGID_AZERBAIJANI_CYRILLIC_SCRIPT\n\nTT_MAC_LANGID_TONGAN\n\nTT_MAC_LANGID_SUNDANESE\n\nTT_MAC_LANGID_JAPANESE\n\nTT_MAC_LANGID_MONGOLIAN\n\nTT_MAC_LANGID_ALBANIAN\n\nTT_MAC_LANGID_NORWEGIAN\n\nTT_MAC_LANGID_SLOVAK\n\nTT_MAC_LANGID_MALAGASY\n\nTT_MAC_LANGID_DZONGKHA\n\nTT_MAC_LANGID_DUTCH\n\nTT_MAC_LANGID_MALAY_ROMAN_SCRIPT\n\nTT_MAC_LANGID_SERBIAN\n\nTT_MAC_LANGID_GERMAN\n\nTT_MAC_LANGID_SOMALI\n\nTT_MAC_LANGID_KOREAN\n\nTT_MAC_LANGID_MONGOLIAN_MONGOLIAN_SCRIPT\n\nTT_MAC_LANGID_CROATIAN\n\nTT_MAC_LANGID_TURKISH\n\nTT_MAC_LANGID_MOLDAVIAN\n\nTT_MAC_LANGID_LAO\n\nTT_MAC_LANGID_ORIYA\n\nTT_MAC_LANGID_BRETON\n\nTT_MAC_LANGID_PASHTO\n\nTT_MAC_LANGID_GUARANI\n\nTT_MAC_LANGID_HEBREW\n\nTT_MAC_LANGID_SLOVENIAN\n\nTT_MAC_LANGID_ESTONIAN\n\nTT_MAC_LANGID_RUNDI\n\nTT_MAC_LANGID_URDU\n\nTT_MAC_LANGID_CHINESE_TRADITIONAL\n\nTT_MAC_LANGID_TATAR\n\nTT_MAC_LANGID_CHINESE_SIMPLIFIED\n\nTT_MAC_LANGID_AZERBAIJANI_ARABIC_SCRIPT\n\nTT_MAC_LANGID_SANSKRIT\n\nTT_MAC_LANGID_KURDISH\n\nTT_MAC_LANGID_FAEROESE\n\nTT_MAC_LANGID_MONGOLIAN_CYRILLIC_SCRIPT\n\nTT_MAC_LANGID_TIGRINYA\n\nTT_MAC_LANGID_THAI\n\nTT_MAC_LANGID_DANISH\n\nTT_MAC_LANGID_KAZAKH\n\nTT_MAC_LANGID_YIDDISH\n\nTT_MAC_LANGID_ESPERANTO\n\nTT_MAC_LANGID_LITHUANIAN\n\nTT_MAC_LANGID_FARSI\n\nTT_MAC_LANGID_LETTISH\n\nTT_MAC_LANGID_VIETNAMESE\n\nTT_MAC_LANGID_PORTUGUESE\n\nTT_MAC_LANGID_IRISH\n\nTT_MAC_LANGID_WELSH\n\nTT_MAC_LANGID_PUNJABI\n\nTT_MAC_LANGID_GREEK\n\nTT_MAC_LANGID_INUKTITUT\n\nTT_MAC_LANGID_FRENCH\n\nTT_MAC_LANGID_GREEK_POLYTONIC\n\nTT_MAC_LANGID_AZERBAIJANI\n\nTT_MAC_LANGID_JAVANESE\n\nTT_MAC_LANGID_SWEDISH\n\nTT_MAC_LANGID_UIGHUR\n\nTT_MAC_LANGID_BENGALI\n\nTT_MAC_LANGID_RUANDA\n\nTT_MAC_LANGID_SINDHI\n\nTT_MAC_LANGID_TIBETAN\n\nTT_MAC_LANGID_ENGLISH\n\nTT_MAC_LANGID_SAAMISK\n\nTT_MAC_LANGID_INDONESIAN\n\nTT_MAC_LANGID_MANX_GAELIC\n\nTT_MAC_LANGID_BYELORUSSIAN\n\nTT_MAC_LANGID_BULGARIAN\n\nTT_MAC_LANGID_GEORGIAN\n\nTT_MAC_LANGID_AZERBAIJANI_ROMAN_SCRIPT\n\nTT_MAC_LANGID_ITALIAN\n\nTT_MAC_LANGID_SCOTTISH_GAELIC\n\nTT_MAC_LANGID_ARMENIAN\n\nTT_MAC_LANGID_GALLA\n\nTT_MAC_LANGID_MACEDONIAN\n\nTT_MAC_LANGID_IRISH_GAELIC\n\nTT_MAC_LANGID_KIRGHIZ\n\nTT_MAC_LANGID_TAMIL\n\nTT_MAC_LANGID_SPANISH\n\nTT_MAC_LANGID_BURMESE\n\nTT_MAC_LANGID_KANNADA\n\nTT_MAC_LANGID_GALICIAN\n\nTT_MAC_LANGID_FLEMISH\n\nTT_MAC_LANGID_TAJIKI\n\nTT_MAC_LANGID_ASSAMESE\n\nTT_MAC_LANGID_SINHALESE\n\nTT_MAC_LANGID_GREELANDIC\n\nTT_MAC_LANGID_AMHARIC\n\nTT_MAC_LANGID_KASHMIRI\n\nTT_MAC_LANGID_AYMARA\n\nTT_MAC_LANGID_GUJARATI\n\nTT_MAC_LANGID_RUSSIAN\n\nTT_MAC_LANGID_TURKMEN\n\nTT_MAC_LANGID_MALAYALAM\n""""""\nTT_MAC_LANGIDS = {\n    \'TT_MAC_LANGID_ENGLISH\'                    :   0,\n    \'TT_MAC_LANGID_FRENCH\'                     :   1,\n    \'TT_MAC_LANGID_GERMAN\'                     :   2,\n    \'TT_MAC_LANGID_ITALIAN\'                    :   3,\n    \'TT_MAC_LANGID_DUTCH\'                      :   4,\n    \'TT_MAC_LANGID_SWEDISH\'                    :   5,\n    \'TT_MAC_LANGID_SPANISH\'                    :   6,\n    \'TT_MAC_LANGID_DANISH\'                     :   7,\n    \'TT_MAC_LANGID_PORTUGUESE\'                 :   8,\n    \'TT_MAC_LANGID_NORWEGIAN\'                  :   9,\n    \'TT_MAC_LANGID_HEBREW\'                     :  10,\n    \'TT_MAC_LANGID_JAPANESE\'                   :  11,\n    \'TT_MAC_LANGID_ARABIC\'                     :  12,\n    \'TT_MAC_LANGID_FINNISH\'                    :  13,\n    \'TT_MAC_LANGID_GREEK\'                      :  14,\n    \'TT_MAC_LANGID_ICELANDIC\'                  :  15,\n    \'TT_MAC_LANGID_MALTESE\'                    :  16,\n    \'TT_MAC_LANGID_TURKISH\'                    :  17,\n    \'TT_MAC_LANGID_CROATIAN\'                   :  18,\n    \'TT_MAC_LANGID_CHINESE_TRADITIONAL\'        :  19,\n    \'TT_MAC_LANGID_URDU\'                       :  20,\n    \'TT_MAC_LANGID_HINDI\'                      :  21,\n    \'TT_MAC_LANGID_THAI\'                       :  22,\n    \'TT_MAC_LANGID_KOREAN\'                     :  23,\n    \'TT_MAC_LANGID_LITHUANIAN\'                 :  24,\n    \'TT_MAC_LANGID_POLISH\'                     :  25,\n    \'TT_MAC_LANGID_HUNGARIAN\'                  :  26,\n    \'TT_MAC_LANGID_ESTONIAN\'                   :  27,\n    \'TT_MAC_LANGID_LETTISH\'                    :  28,\n    \'TT_MAC_LANGID_SAAMISK\'                    :  29,\n    \'TT_MAC_LANGID_FAEROESE\'                   :  30,\n    \'TT_MAC_LANGID_FARSI\'                      :  31,\n    \'TT_MAC_LANGID_RUSSIAN\'                    :  32,\n    \'TT_MAC_LANGID_CHINESE_SIMPLIFIED\'         :  33,\n    \'TT_MAC_LANGID_FLEMISH\'                    :  34,\n    \'TT_MAC_LANGID_IRISH\'                      :  35,\n    \'TT_MAC_LANGID_ALBANIAN\'                   :  36,\n    \'TT_MAC_LANGID_ROMANIAN\'                   :  37,\n    \'TT_MAC_LANGID_CZECH\'                      :  38,\n    \'TT_MAC_LANGID_SLOVAK\'                     :  39,\n    \'TT_MAC_LANGID_SLOVENIAN\'                  :  40,\n    \'TT_MAC_LANGID_YIDDISH\'                    :  41,\n    \'TT_MAC_LANGID_SERBIAN\'                    :  42,\n    \'TT_MAC_LANGID_MACEDONIAN\'                 :  43,\n    \'TT_MAC_LANGID_BULGARIAN\'                  :  44,\n    \'TT_MAC_LANGID_UKRAINIAN\'                  :  45,\n    \'TT_MAC_LANGID_BYELORUSSIAN\'               :  46,\n    \'TT_MAC_LANGID_UZBEK\'                      :  47,\n    \'TT_MAC_LANGID_KAZAKH\'                     :  48,\n    \'TT_MAC_LANGID_AZERBAIJANI\'                :  49,\n    \'TT_MAC_LANGID_AZERBAIJANI_CYRILLIC_SCRIPT\':  49,\n    \'TT_MAC_LANGID_AZERBAIJANI_ARABIC_SCRIPT\'  :  50,\n    \'TT_MAC_LANGID_ARMENIAN\'                   :  51,\n    \'TT_MAC_LANGID_GEORGIAN\'                   :  52,\n    \'TT_MAC_LANGID_MOLDAVIAN\'                  :  53,\n    \'TT_MAC_LANGID_KIRGHIZ\'                    :  54,\n    \'TT_MAC_LANGID_TAJIKI\'                     :  55,\n    \'TT_MAC_LANGID_TURKMEN\'                    :  56,\n    \'TT_MAC_LANGID_MONGOLIAN\'                  :  57,\n    \'TT_MAC_LANGID_MONGOLIAN_MONGOLIAN_SCRIPT\' :  57,\n    \'TT_MAC_LANGID_MONGOLIAN_CYRILLIC_SCRIPT\'  :  58,\n    \'TT_MAC_LANGID_PASHTO\'                     :  59,\n    \'TT_MAC_LANGID_KURDISH\'                    :  60,\n    \'TT_MAC_LANGID_KASHMIRI\'                   :  61,\n    \'TT_MAC_LANGID_SINDHI\'                     :  62,\n    \'TT_MAC_LANGID_TIBETAN\'                    :  63,\n    \'TT_MAC_LANGID_NEPALI\'                     :  64,\n    \'TT_MAC_LANGID_SANSKRIT\'                   :  65,\n    \'TT_MAC_LANGID_MARATHI\'                    :  66,\n    \'TT_MAC_LANGID_BENGALI\'                    :  67,\n    \'TT_MAC_LANGID_ASSAMESE\'                   :  68,\n    \'TT_MAC_LANGID_GUJARATI\'                   :  69,\n    \'TT_MAC_LANGID_PUNJABI\'                    :  70,\n    \'TT_MAC_LANGID_ORIYA\'                      :  71,\n    \'TT_MAC_LANGID_MALAYALAM\'                  :  72,\n    \'TT_MAC_LANGID_KANNADA\'                    :  73,\n    \'TT_MAC_LANGID_TAMIL\'                      :  74,\n    \'TT_MAC_LANGID_TELUGU\'                     :  75,\n    \'TT_MAC_LANGID_SINHALESE\'                  :  76,\n    \'TT_MAC_LANGID_BURMESE\'                    :  77,\n    \'TT_MAC_LANGID_KHMER\'                      :  78,\n    \'TT_MAC_LANGID_LAO\'                        :  79,\n    \'TT_MAC_LANGID_VIETNAMESE\'                 :  80,\n    \'TT_MAC_LANGID_INDONESIAN\'                 :  81,\n    \'TT_MAC_LANGID_TAGALOG\'                    :  82,\n    \'TT_MAC_LANGID_MALAY_ROMAN_SCRIPT\'         :  83,\n    \'TT_MAC_LANGID_MALAY_ARABIC_SCRIPT\'        :  84,\n    \'TT_MAC_LANGID_AMHARIC\'                    :  85,\n    \'TT_MAC_LANGID_TIGRINYA\'                   :  86,\n    \'TT_MAC_LANGID_GALLA\'                      :  87,\n    \'TT_MAC_LANGID_SOMALI\'                     :  88,\n    \'TT_MAC_LANGID_SWAHILI\'                    :  89,\n    \'TT_MAC_LANGID_RUANDA\'                     :  90,\n    \'TT_MAC_LANGID_RUNDI\'                      :  91,\n    \'TT_MAC_LANGID_CHEWA\'                      :  92,\n    \'TT_MAC_LANGID_MALAGASY\'                   :  93,\n    \'TT_MAC_LANGID_ESPERANTO\'                  :  94,\n    \'TT_MAC_LANGID_WELSH\'                      : 128,\n    \'TT_MAC_LANGID_BASQUE\'                     : 129,\n    \'TT_MAC_LANGID_CATALAN\'                    : 130,\n    \'TT_MAC_LANGID_LATIN\'                      : 131,\n    \'TT_MAC_LANGID_QUECHUA\'                    : 132,\n    \'TT_MAC_LANGID_GUARANI\'                    : 133,\n    \'TT_MAC_LANGID_AYMARA\'                     : 134,\n    \'TT_MAC_LANGID_TATAR\'                      : 135,\n    \'TT_MAC_LANGID_UIGHUR\'                     : 136,\n    \'TT_MAC_LANGID_DZONGKHA\'                   : 137,\n    \'TT_MAC_LANGID_JAVANESE\'                   : 138,\n    \'TT_MAC_LANGID_SUNDANESE\'                  : 139,\n    \'TT_MAC_LANGID_GALICIAN\'                   : 140,\n    \'TT_MAC_LANGID_AFRIKAANS\'                  : 141,\n    \'TT_MAC_LANGID_BRETON\'                     : 142,\n    \'TT_MAC_LANGID_INUKTITUT\'                  : 143,\n    \'TT_MAC_LANGID_SCOTTISH_GAELIC\'            : 144,\n    \'TT_MAC_LANGID_MANX_GAELIC\'                : 145,\n    \'TT_MAC_LANGID_IRISH_GAELIC\'               : 146,\n    \'TT_MAC_LANGID_TONGAN\'                     : 147,\n    \'TT_MAC_LANGID_GREEK_POLYTONIC\'            : 148,\n    \'TT_MAC_LANGID_GREELANDIC\'                 : 149,\n    \'TT_MAC_LANGID_AZERBAIJANI_ROMAN_SCRIPT\'   : 150 }\nglobals().update(TT_MAC_LANGIDS)\n\n\n'"
glumpy/ext/freetype/ft_enums/tt_ms_ids.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of valid values for the \'encoding_id\' for TT_PLATFORM_MICROSOFT\ncharmaps and name entries.\n\n\nTT_MS_ID_SYMBOL_CS\t\n\n  Corresponds to Microsoft symbol encoding. See FT_ENCODING_MS_SYMBOL.\n\n\nTT_MS_ID_UNICODE_CS\t\n\n  Corresponds to a Microsoft WGL4 charmap, matching Unicode. See\n  FT_ENCODING_UNICODE.\n\n\nTT_MS_ID_SJIS\t\n\n  Corresponds to SJIS Japanese encoding. See FT_ENCODING_SJIS.\n\n\nTT_MS_ID_GB2312\t\n\n  Corresponds to Simplified Chinese as used in Mainland China. See\n  FT_ENCODING_GB2312.\n\n\nTT_MS_ID_BIG_5\t\n\n  Corresponds to Traditional Chinese as used in Taiwan and Hong Kong. See\n  FT_ENCODING_BIG5.\n\n\nTT_MS_ID_WANSUNG\t\n\n  Corresponds to Korean Wansung encoding. See FT_ENCODING_WANSUNG.\n\nTT_MS_ID_JOHAB\t\n\n  Corresponds to Johab encoding. See FT_ENCODING_JOHAB.\n\n\nTT_MS_ID_UCS_4\t\n\n  Corresponds to UCS-4 or UTF-32 charmaps. This has been added to the OpenType\n  specification version 1.4 (mid-2001.)\n""""""\n\nTT_MS_IDS = {\n    \'TT_MS_ID_SYMBOL_CS\'  :  0,\n    \'TT_MS_ID_UNICODE_CS\' :  1,\n    \'TT_MS_ID_SJIS\'       :  2,\n    \'TT_MS_ID_GB2312\'     :  3,\n    \'TT_MS_ID_BIG_5\'      :  4,\n    \'TT_MS_ID_WANSUNG\'    :  5,\n    \'TT_MS_ID_JOHAB\'      :  6,\n    \'TT_MS_ID_UCS_4\'      : 10 }\nglobals().update(TT_MS_IDS)\n\n\n'"
glumpy/ext/freetype/ft_enums/tt_ms_langids.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nPossible values of the language identifier field in the name records of the\nTTF \'name\' table if the \'platform\' identifier code is TT_PLATFORM_MICROSOFT.\n\nTT_MS_LANGID_SANSKRIT_INDIA\n\nTT_MS_LANGID_ENGLISH_UNITED_KINGDOM\n\nTT_MS_LANGID_ENGLISH_BELIZE\n\nTT_MS_LANGID_ARABIC_LEBANON\n\nTT_MS_LANGID_MOLDAVIAN_MOLDAVIA\n\nTT_MS_LANGID_TURKISH_TURKEY\n\nTT_MS_LANGID_WELSH_WALES\n\nTT_MS_LANGID_GERMAN_AUSTRIA\n\nTT_MS_LANGID_DUTCH_BELGIUM\n\nTT_MS_LANGID_YI_CHINA\n\nTT_MS_LANGID_QUECHUA_ECUADOR\n\nTT_MS_LANGID_SPANISH_EL_SALVADOR\n\nTT_MS_LANGID_SWAHILI_KENYA\n\nTT_MS_LANGID_QUECHUA_BOLIVIA\n\nTT_MS_LANGID_SLOVENE_SLOVENIA\n\nTT_MS_LANGID_ORIYA_INDIA\n\nTT_MS_LANGID_FARSI_IRAN\n\nTT_MS_LANGID_ENGLISH_CANADA\n\nTT_MS_LANGID_NEPALI_NEPAL\n\nTT_MS_LANGID_DHIVEHI_MALDIVES\n\nTT_MS_LANGID_GERMAN_LIECHTENSTEI\n\nTT_MS_LANGID_TAMIL_INDIA\n\nTT_MS_LANGID_ARABIC_UAE\n\nTT_MS_LANGID_JAPANESE_JAPAN\n\nTT_MS_LANGID_TAMAZIGHT_MOROCCO\n\nTT_MS_LANGID_FRENCH_FRANCE\n\nTT_MS_LANGID_CHINESE_MACAU\n\nTT_MS_LANGID_VIETNAMESE_VIET_NAM\n\nTT_MS_LANGID_HEBREW_ISRAEL\n\nTT_MS_LANGID_SAMI_NORTHERN_SWEDEN\n\nTT_MS_LANGID_PUNJABI_ARABIC_PAKISTAN\n\nTT_MS_LANGID_SWEDISH_SWEDEN\n\nTT_MS_LANGID_FRENCH_REUNION\n\nTT_MS_LANGID_ARABIC_BAHRAIN\n\nTT_MS_LANGID_ENGLISH_INDIA\n\nTT_MS_LANGID_NEPALI_INDIA\n\nTT_MS_LANGID_THAI_THAILAND\n\nTT_MS_LANGID_ENGLISH_GENERAL\n\nTT_MS_LANGID_SAMI_LULE_NORWAY\n\nTT_MS_LANGID_ARABIC_OMAN\n\nTT_MS_LANGID_SPANISH_HONDURAS\n\nTT_MS_LANGID_ENGLISH_JAMAICA\n\nTT_MS_LANGID_ESTONIAN_ESTONIA\n\nTT_MS_LANGID_FRISIAN_NETHERLANDS\n\nTT_MS_LANGID_LATIN\n\nTT_MS_LANGID_ENGLISH_INDONESIA\n\nTT_MS_LANGID_ENGLISH_IRELAND\n\nTT_MS_LANGID_TIBETAN_CHINA\n\nTT_MS_LANGID_PUNJABI_INDIA\n\nTT_MS_LANGID_FRENCH_MALI\n\nTT_MS_LANGID_GERMAN_LUXEMBOURG\n\nTT_MS_LANGID_SUTU_SOUTH_AFRICA\n\nTT_MS_LANGID_FRENCH_CAMEROON\n\nTT_MS_LANGID_FRENCH_CONGO\n\nTT_MS_LANGID_CLASSIC_LITHUANIAN_LITHUANIA\n\nTT_MS_LANGID_MALAYALAM_INDIA\n\nTT_MS_LANGID_SAMI_SOUTHERN_SWEDEN\n\nTT_MS_LANGID_CHEROKEE_UNITED_STATES\n\nTT_MS_LANGID_SPANISH_GUATEMALA\n\nTT_MS_LANGID_CZECH_CZECH_REPUBLIC\n\nTT_MS_LANGID_MANIPURI_INDIA\n\nTT_MS_LANGID_ENGLISH_AUSTRALIA\n\nTT_MS_LANGID_SPANISH_DOMINICAN_REPUBLIC\n\nTT_MS_LANGID_ARABIC_LIBYA\n\nTT_MS_LANGID_FRENCH_WEST_INDIES\n\nTT_MS_LANGID_ENGLISH_TRINIDAD\n\nTT_MS_LANGID_ARABIC_QATAR\n\nTT_MS_LANGID_SPANISH_COLOMBIA\n\nTT_MS_LANGID_GUARANI_PARAGUAY\n\nTT_MS_LANGID_EDO_NIGERIA\n\nTT_MS_LANGID_SEPEDI_SOUTH_AFRICA\n\nTT_MS_LANGID_ENGLISH_HONG_KONG\n\nTT_MS_LANGID_KOREAN_EXTENDED_WANSUNG_KOREA\n\nTT_MS_LANGID_TATAR_TATARSTAN\n\nTT_MS_LANGID_PASHTO_AFGHANISTAN\n\nTT_MS_LANGID_KASHMIRI_PAKISTAN\n\nTT_MS_LANGID_GALICIAN_SPAIN\n\nTT_MS_LANGID_TAJIK_TAJIKISTAN\n\nTT_MS_LANGID_SAMI_INARI_FINLAND\n\nTT_MS_LANGID_KASHMIRI_SASIA\n\nTT_MS_LANGID_SPANISH_ARGENTINA\n\nTT_MS_LANGID_SAMI_SOUTHERN_NORWAY\n\nTT_MS_LANGID_CROATIAN_CROATIA\n\nTT_MS_LANGID_GUJARATI_INDIA\n\nTT_MS_LANGID_TIBETAN_BHUTAN\n\nTT_MS_LANGID_TIGRIGNA_ETHIOPIA\n\nTT_MS_LANGID_FINNISH_FINLAND\n\nTT_MS_LANGID_ENGLISH_UNITED_STATES\n\nTT_MS_LANGID_ITALIAN_SWITZERLAND\n\nTT_MS_LANGID_ARABIC_EGYPT\n\nTT_MS_LANGID_SPANISH_LATIN_AMERICA\n\nTT_MS_LANGID_LITHUANIAN_LITHUANIA\n\nTT_MS_LANGID_ARABIC_ALGERIA\n\nTT_MS_LANGID_MALAY_MALAYSIA\n\nTT_MS_LANGID_ARABIC_GENERAL\n\nTT_MS_LANGID_CHINESE_PRC\n\nTT_MS_LANGID_BENGALI_BANGLADESH\n\nTT_MS_LANGID_SPANISH_PERU\n\nTT_MS_LANGID_SPANISH_SPAIN_INTERNATIONAL_SORT\n\nTT_MS_LANGID_DIVEHI_MALDIVES\n\nTT_MS_LANGID_LATVIAN_LATVIA\n\nTT_MS_LANGID_TURKMEN_TURKMENISTAN\n\nTT_MS_LANGID_XHOSA_SOUTH_AFRICA\n\nTT_MS_LANGID_KHMER_CAMBODIA\n\nTT_MS_LANGID_NORWEGIAN_NORWAY_NYNORSK\n\nTT_MS_LANGID_ARABIC_MOROCCO\n\nTT_MS_LANGID_FRENCH_SENEGAL\n\nTT_MS_LANGID_YORUBA_NIGERIA\n\nTT_MS_LANGID_CATALAN_SPAIN\n\nTT_MS_LANGID_AFRIKAANS_SOUTH_AFRICA\n\nTT_MS_LANGID_ZULU_SOUTH_AFRICA\n\nTT_MS_LANGID_SPANISH_URUGUAY\n\nTT_MS_LANGID_SPANISH_ECUADOR\n\nTT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA\n\nTT_MS_LANGID_CHINESE_GENERAL\n\nTT_MS_LANGID_SPANISH_PARAGUAY\n\nTT_MS_LANGID_HINDI_INDIA\n\nTT_MS_LANGID_FRENCH_LUXEMBOURG\n\nTT_MS_LANGID_TSWANA_SOUTH_AFRICA\n\nTT_MS_LANGID_HUNGARIAN_HUNGARY\n\nTT_MS_LANGID_CROATIAN_BOSNIA_HERZEGOVINA\n\nTT_MS_LANGID_ENGLISH_SINGAPORE\n\nTT_MS_LANGID_MALTESE_MALTA\n\nTT_MS_LANGID_SAMI_NORTHERN_FINLAND\n\nTT_MS_LANGID_FRENCH_CANADA\n\nTT_MS_LANGID_SAMI_LULE_SWEDEN\n\nTT_MS_LANGID_KANURI_NIGERIA\n\nTT_MS_LANGID_IRISH_GAELIC_IRELAND\n\nTT_MS_LANGID_ARABIC_SAUDI_ARABIA\n\nTT_MS_LANGID_FRENCH_HAITI\n\nTT_MS_LANGID_SPANISH_PUERTO_RICO\n\nTT_MS_LANGID_BURMESE_MYANMAR\n\nTT_MS_LANGID_POLISH_POLAND\n\nTT_MS_LANGID_PORTUGUESE_PORTUGAL\n\nTT_MS_LANGID_ENGLISH_CARIBBEAN\n\nTT_MS_LANGID_KIRGHIZ_KIRGHIZ_REPUBLIC\n\nTT_MS_LANGID_ICELANDIC_ICELAND\n\nTT_MS_LANGID_BENGALI_INDIA\n\nTT_MS_LANGID_HAUSA_NIGERIA\n\nTT_MS_LANGID_BASQUE_SPAIN\n\nTT_MS_LANGID_UIGHUR_CHINA\n\nTT_MS_LANGID_ENGLISH_MALAYSIA\n\nTT_MS_LANGID_FRENCH_MONACO\n\nTT_MS_LANGID_SPANISH_BOLIVIA\n\nTT_MS_LANGID_SORBIAN_GERMANY\n\nTT_MS_LANGID_SINDHI_INDIA\n\nTT_MS_LANGID_CHINESE_SINGAPORE\n\nTT_MS_LANGID_FRENCH_COTE_D_IVOIRE\n\nTT_MS_LANGID_SPANISH_SPAIN_TRADITIONAL_SORT\n\nTT_MS_LANGID_SERBIAN_SERBIA_CYRILLIC\n\nTT_MS_LANGID_SAMI_SKOLT_FINLAND\n\nTT_MS_LANGID_SERBIAN_BOSNIA_HERZ_CYRILLIC\n\nTT_MS_LANGID_MALAY_BRUNEI_DARUSSALAM\n\nTT_MS_LANGID_ARABIC_JORDAN\n\nTT_MS_LANGID_MONGOLIAN_MONGOLIA_MONGOLIAN\n\nTT_MS_LANGID_SERBIAN_SERBIA_LATIN\n\nTT_MS_LANGID_RUSSIAN_RUSSIA\n\nTT_MS_LANGID_ROMANIAN_ROMANIA\n\nTT_MS_LANGID_FRENCH_NORTH_AFRICA\n\nTT_MS_LANGID_MONGOLIAN_MONGOLIA\n\nTT_MS_LANGID_TSONGA_SOUTH_AFRICA\n\nTT_MS_LANGID_SOMALI_SOMALIA\n\nTT_MS_LANGID_SAAMI_LAPONIA\n\nTT_MS_LANGID_SPANISH_COSTA_RICA\n\nTT_MS_LANGID_ARABIC_SYRIA\n\nTT_MS_LANGID_SPANISH_PANAMA\n\nTT_MS_LANGID_PAPIAMENTU_NETHERLANDS_ANTILLES\n\nTT_MS_LANGID_ASSAMESE_INDIA\n\nTT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM\n\nTT_MS_LANGID_DUTCH_NETHERLANDS\n\nTT_MS_LANGID_SINDHI_PAKISTAN\n\nTT_MS_LANGID_MACEDONIAN_MACEDONIA\n\nTT_MS_LANGID_KAZAK_KAZAKSTAN\n\nTT_MS_LANGID_AZERI_AZERBAIJAN_LATIN\n\nTT_MS_LANGID_BELARUSIAN_BELARUS\n\nTT_MS_LANGID_FRENCH_MOROCCO\n\nTT_MS_LANGID_SERBIAN_BOSNIA_HERZ_LATIN\n\nTT_MS_LANGID_ALBANIAN_ALBANIA\n\nTT_MS_LANGID_SINHALESE_SRI_LANKA\n\nTT_MS_LANGID_SPANISH_MEXICO\n\nTT_MS_LANGID_ENGLISH_ZIMBABWE\n\nTT_MS_LANGID_OROMO_ETHIOPIA\n\nTT_MS_LANGID_INDONESIAN_INDONESIA\n\nTT_MS_LANGID_SAMI_NORTHERN_NORWAY\n\nTT_MS_LANGID_UZBEK_UZBEKISTAN_LATIN\n\nTT_MS_LANGID_SLOVAK_SLOVAKIA\n\nTT_MS_LANGID_KASHMIRI_INDIA\n\nTT_MS_LANGID_GERMAN_SWITZERLAND\n\nTT_MS_LANGID_URDU_INDIA\n\nTT_MS_LANGID_FAEROESE_FAEROE_ISLANDS\n\nTT_MS_LANGID_SYRIAC_SYRIA\n\nTT_MS_LANGID_SPANISH_CHILE\n\nTT_MS_LANGID_FILIPINO_PHILIPPINES\n\nTT_MS_LANGID_ARABIC_YEMEN\n\nTT_MS_LANGID_KONKANI_INDIA\n\nTT_MS_LANGID_AMHARIC_ETHIOPIA\n\nTT_MS_LANGID_ENGLISH_NEW_ZEALAND\n\nTT_MS_LANGID_RHAETO_ROMANIC_SWITZERLAND\n\nTT_MS_LANGID_ARABIC_TUNISIA\n\nTT_MS_LANGID_SOTHO_SOUTHERN_SOUTH_AFRICA\n\nTT_MS_LANGID_QUECHUA_PERU\n\nTT_MS_LANGID_DANISH_DENMARK\n\nTT_MS_LANGID_ENGLISH_PHILIPPINES\n\nTT_MS_LANGID_SPANISH_NICARAGUA\n\nTT_MS_LANGID_INUKTITUT_CANADA\n\nTT_MS_LANGID_UKRAINIAN_UKRAINE\n\nTT_MS_LANGID_NORWEGIAN_NORWAY_BOKMAL\n\nTT_MS_LANGID_UZBEK_UZBEKISTAN_CYRILLIC\n\nTT_MS_LANGID_FRENCH_BELGIUM\n\nTT_MS_LANGID_ENGLISH_SOUTH_AFRICA\n\nTT_MS_LANGID_HAWAIIAN_UNITED_STATES\n\nTT_MS_LANGID_ARABIC_IRAQ\n\nTT_MS_LANGID_KANNADA_INDIA\n\nTT_MS_LANGID_DZONGHKA_BHUTAN\n\nTT_MS_LANGID_CHINESE_TAIWAN\n\nTT_MS_LANGID_SPANISH_UNITED_STATES\n\nTT_MS_LANGID_ARMENIAN_ARMENIA\n\nTT_MS_LANGID_LAO_LAOS\n\nTT_MS_LANGID_TIGRIGNA_ERYTREA\n\nTT_MS_LANGID_MARATHI_INDIA\n\nTT_MS_LANGID_ARABIC_KUWAIT\n\nTT_MS_LANGID_TAMAZIGHT_MOROCCO_LATIN\n\nTT_MS_LANGID_PORTUGUESE_BRAZIL\n\nTT_MS_LANGID_TIGRIGNA_ERYTHREA\n\nTT_MS_LANGID_GREEK_GREECE\n\nTT_MS_LANGID_URDU_PAKISTAN\n\nTT_MS_LANGID_KIRGHIZ_KIRGHIZSTAN\n\nTT_MS_LANGID_YIDDISH_GERMANY\n\nTT_MS_LANGID_GERMAN_GERMANY\n\nTT_MS_LANGID_TELUGU_INDIA\n\nTT_MS_LANGID_AZERI_AZERBAIJAN_CYRILLIC\n\nTT_MS_LANGID_KOREAN_JOHAB_KOREA\n\nTT_MS_LANGID_ITALIAN_ITALY\n\nTT_MS_LANGID_MAORI_NEW_ZEALAND\n\nTT_MS_LANGID_SPANISH_VENEZUELA\n\nTT_MS_LANGID_IGBO_NIGERIA\n\nTT_MS_LANGID_IBIBIO_NIGERIA\n\nTT_MS_LANGID_CHINESE_HONG_KONG\n\nTT_MS_LANGID_FRENCH_SWITZERLAND\n\nTT_MS_LANGID_BULGARIAN_BULGARIA\n\nTT_MS_LANGID_FULFULDE_NIGERIA\n\nTT_MS_LANGID_RUSSIAN_MOLDAVIA\n\nTT_MS_LANGID_VENDA_SOUTH_AFRICA\n\nTT_MS_LANGID_GEORGIAN_GEORGIA\n\nTT_MS_LANGID_SWEDISH_FINLAND\n""""""\n\nTT_MS_LANGIDS = {\n    \'TT_MS_LANGID_ARABIC_GENERAL\'                    : 0x0001,\n    \'TT_MS_LANGID_ARABIC_SAUDI_ARABIA\'               : 0x0401,\n    \'TT_MS_LANGID_ARABIC_IRAQ\'                       : 0x0801,\n    \'TT_MS_LANGID_ARABIC_EGYPT\'                      : 0x0c01,\n    \'TT_MS_LANGID_ARABIC_LIBYA\'                      : 0x1001,\n    \'TT_MS_LANGID_ARABIC_ALGERIA\'                    : 0x1401,\n    \'TT_MS_LANGID_ARABIC_MOROCCO\'                    : 0x1801,\n    \'TT_MS_LANGID_ARABIC_TUNISIA\'                    : 0x1c01,\n    \'TT_MS_LANGID_ARABIC_OMAN\'                       : 0x2001,\n    \'TT_MS_LANGID_ARABIC_YEMEN\'                      : 0x2401,\n    \'TT_MS_LANGID_ARABIC_SYRIA\'                      : 0x2801,\n    \'TT_MS_LANGID_ARABIC_JORDAN\'                     : 0x2c01,\n    \'TT_MS_LANGID_ARABIC_LEBANON\'                    : 0x3001,\n    \'TT_MS_LANGID_ARABIC_KUWAIT\'                     : 0x3401,\n    \'TT_MS_LANGID_ARABIC_UAE\'                        : 0x3801,\n    \'TT_MS_LANGID_ARABIC_BAHRAIN\'                    : 0x3c01,\n    \'TT_MS_LANGID_ARABIC_QATAR\'                      : 0x4001,\n    \'TT_MS_LANGID_BULGARIAN_BULGARIA\'                : 0x0402,\n    \'TT_MS_LANGID_CATALAN_SPAIN\'                     : 0x0403,\n    \'TT_MS_LANGID_CHINESE_GENERAL\'                   : 0x0004,\n    \'TT_MS_LANGID_CHINESE_TAIWAN\'                    : 0x0404,\n    \'TT_MS_LANGID_CHINESE_PRC\'                       : 0x0804,\n    \'TT_MS_LANGID_CHINESE_HONG_KONG\'                 : 0x0c04,\n    \'TT_MS_LANGID_CHINESE_SINGAPORE\'                 : 0x1004,\n    \'TT_MS_LANGID_CHINESE_MACAU\'                     : 0x1404,\n    \'TT_MS_LANGID_CZECH_CZECH_REPUBLIC\'              : 0x0405,\n    \'TT_MS_LANGID_DANISH_DENMARK\'                    : 0x0406,\n    \'TT_MS_LANGID_GERMAN_GERMANY\'                    : 0x0407,\n    \'TT_MS_LANGID_GERMAN_SWITZERLAND\'                : 0x0807,\n    \'TT_MS_LANGID_GERMAN_AUSTRIA\'                    : 0x0c07,\n    \'TT_MS_LANGID_GERMAN_LUXEMBOURG\'                 : 0x1007,\n    \'TT_MS_LANGID_GERMAN_LIECHTENSTEI\'               : 0x1407,\n    \'TT_MS_LANGID_GREEK_GREECE\'                      : 0x0408,\n    \'TT_MS_LANGID_ENGLISH_GENERAL\'                   : 0x0009,\n    \'TT_MS_LANGID_ENGLISH_UNITED_STATES\'             : 0x0409,\n    \'TT_MS_LANGID_ENGLISH_UNITED_KINGDOM\'            : 0x0809,\n    \'TT_MS_LANGID_ENGLISH_AUSTRALIA\'                 : 0x0c09,\n    \'TT_MS_LANGID_ENGLISH_CANADA\'                    : 0x1009,\n    \'TT_MS_LANGID_ENGLISH_NEW_ZEALAND\'               : 0x1409,\n    \'TT_MS_LANGID_ENGLISH_IRELAND\'                   : 0x1809,\n    \'TT_MS_LANGID_ENGLISH_SOUTH_AFRICA\'              : 0x1c09,\n    \'TT_MS_LANGID_ENGLISH_JAMAICA\'                   : 0x2009,\n    \'TT_MS_LANGID_ENGLISH_CARIBBEAN\'                 : 0x2409,\n    \'TT_MS_LANGID_ENGLISH_BELIZE\'                    : 0x2809,\n    \'TT_MS_LANGID_ENGLISH_TRINIDAD\'                  : 0x2c09,\n    \'TT_MS_LANGID_ENGLISH_ZIMBABWE\'                  : 0x3009,\n    \'TT_MS_LANGID_ENGLISH_PHILIPPINES\'               : 0x3409,\n    \'TT_MS_LANGID_ENGLISH_INDONESIA\'                 : 0x3809,\n    \'TT_MS_LANGID_ENGLISH_HONG_KONG\'                 : 0x3c09,\n    \'TT_MS_LANGID_ENGLISH_INDIA\'                     : 0x4009,\n    \'TT_MS_LANGID_ENGLISH_MALAYSIA\'                  : 0x4409,\n    \'TT_MS_LANGID_ENGLISH_SINGAPORE\'                 : 0x4809,\n    \'TT_MS_LANGID_SPANISH_SPAIN_TRADITIONAL_SORT\'    : 0x040a,\n    \'TT_MS_LANGID_SPANISH_MEXICO\'                    : 0x080a,\n    \'TT_MS_LANGID_SPANISH_SPAIN_INTERNATIONAL_SORT\'  : 0x0c0a,\n    \'TT_MS_LANGID_SPANISH_GUATEMALA\'                 : 0x100a,\n    \'TT_MS_LANGID_SPANISH_COSTA_RICA\'                : 0x140a,\n    \'TT_MS_LANGID_SPANISH_PANAMA\'                    : 0x180a,\n    \'TT_MS_LANGID_SPANISH_DOMINICAN_REPUBLIC\'        : 0x1c0a,\n    \'TT_MS_LANGID_SPANISH_VENEZUELA\'                 : 0x200a,\n    \'TT_MS_LANGID_SPANISH_COLOMBIA\'                  : 0x240a,\n    \'TT_MS_LANGID_SPANISH_PERU\'                      : 0x280a,\n    \'TT_MS_LANGID_SPANISH_ARGENTINA\'                 : 0x2c0a,\n    \'TT_MS_LANGID_SPANISH_ECUADOR\'                   : 0x300a,\n    \'TT_MS_LANGID_SPANISH_CHILE\'                     : 0x340a,\n    \'TT_MS_LANGID_SPANISH_URUGUAY\'                   : 0x380a,\n    \'TT_MS_LANGID_SPANISH_PARAGUAY\'                  : 0x3c0a,\n    \'TT_MS_LANGID_SPANISH_BOLIVIA\'                   : 0x400a,\n    \'TT_MS_LANGID_SPANISH_EL_SALVADOR\'               : 0x440a,\n    \'TT_MS_LANGID_SPANISH_HONDURAS\'                  : 0x480a,\n    \'TT_MS_LANGID_SPANISH_NICARAGUA\'                 : 0x4c0a,\n    \'TT_MS_LANGID_SPANISH_PUERTO_RICO\'               : 0x500a,\n    \'TT_MS_LANGID_SPANISH_UNITED_STATES\'             : 0x540a,\n    \'TT_MS_LANGID_SPANISH_LATIN_AMERICA\'             : 0xE40a,\n    \'TT_MS_LANGID_FINNISH_FINLAND\'                   : 0x040b,\n    \'TT_MS_LANGID_FRENCH_FRANCE\'                     : 0x040c,\n    \'TT_MS_LANGID_FRENCH_BELGIUM\'                    : 0x080c,\n    \'TT_MS_LANGID_FRENCH_CANADA\'                     : 0x0c0c,\n    \'TT_MS_LANGID_FRENCH_SWITZERLAND\'                : 0x100c,\n    \'TT_MS_LANGID_FRENCH_LUXEMBOURG\'                 : 0x140c,\n    \'TT_MS_LANGID_FRENCH_MONACO\'                     : 0x180c,\n    \'TT_MS_LANGID_FRENCH_WEST_INDIES\'                : 0x1c0c,\n    \'TT_MS_LANGID_FRENCH_REUNION\'                    : 0x200c,\n    \'TT_MS_LANGID_FRENCH_CONGO\'                      : 0x240c,\n    \'TT_MS_LANGID_FRENCH_SENEGAL\'                    : 0x280c,\n    \'TT_MS_LANGID_FRENCH_CAMEROON\'                   : 0x2c0c,\n    \'TT_MS_LANGID_FRENCH_COTE_D_IVOIRE\'              : 0x300c,\n    \'TT_MS_LANGID_FRENCH_MALI\'                       : 0x340c,\n    \'TT_MS_LANGID_FRENCH_MOROCCO\'                    : 0x380c,\n    \'TT_MS_LANGID_FRENCH_HAITI\'                      : 0x3c0c,\n    \'TT_MS_LANGID_FRENCH_NORTH_AFRICA\'               : 0xE40c,\n    \'TT_MS_LANGID_HEBREW_ISRAEL\'                     : 0x040d,\n    \'TT_MS_LANGID_HUNGARIAN_HUNGARY\'                 : 0x040e,\n    \'TT_MS_LANGID_ICELANDIC_ICELAND\'                 : 0x040f,\n    \'TT_MS_LANGID_ITALIAN_ITALY\'                     : 0x0410,\n    \'TT_MS_LANGID_ITALIAN_SWITZERLAND\'               : 0x0810,\n    \'TT_MS_LANGID_JAPANESE_JAPAN\'                    : 0x0411,\n    \'TT_MS_LANGID_KOREAN_EXTENDED_WANSUNG_KOREA\'     : 0x0412,\n    \'TT_MS_LANGID_KOREAN_JOHAB_KOREA\'                : 0x0812,\n    \'TT_MS_LANGID_DUTCH_NETHERLANDS\'                 : 0x0413,\n    \'TT_MS_LANGID_DUTCH_BELGIUM\'                     : 0x0813,\n    \'TT_MS_LANGID_NORWEGIAN_NORWAY_BOKMAL\'           : 0x0414,\n    \'TT_MS_LANGID_NORWEGIAN_NORWAY_NYNORSK\'          : 0x0814,\n    \'TT_MS_LANGID_POLISH_POLAND\'                     : 0x0415,\n    \'TT_MS_LANGID_PORTUGUESE_BRAZIL\'                 : 0x0416,\n    \'TT_MS_LANGID_PORTUGUESE_PORTUGAL\'               : 0x0816,\n    \'TT_MS_LANGID_RHAETO_ROMANIC_SWITZERLAND\'        : 0x0417,\n    \'TT_MS_LANGID_ROMANIAN_ROMANIA\'                  : 0x0418,\n    \'TT_MS_LANGID_MOLDAVIAN_MOLDAVIA\'                : 0x0818,\n    \'TT_MS_LANGID_RUSSIAN_RUSSIA\'                    : 0x0419,\n    \'TT_MS_LANGID_RUSSIAN_MOLDAVIA\'                  : 0x0819,\n    \'TT_MS_LANGID_CROATIAN_CROATIA\'                  : 0x041a,\n    \'TT_MS_LANGID_SERBIAN_SERBIA_LATIN\'              : 0x081a,\n    \'TT_MS_LANGID_SERBIAN_SERBIA_CYRILLIC\'           : 0x0c1a,\n    \'TT_MS_LANGID_CROATIAN_BOSNIA_HERZEGOVINA\'       : 0x101a,\n    \'TT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA\'        : 0x141a,\n    \'TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_LATIN\'         : 0x181a,\n    \'TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_CYRILLIC\'      : 0x181a,\n    \'TT_MS_LANGID_SLOVAK_SLOVAKIA\'                   : 0x041b,\n    \'TT_MS_LANGID_ALBANIAN_ALBANIA\'                  : 0x041c,\n    \'TT_MS_LANGID_SWEDISH_SWEDEN\'                    : 0x041d,\n    \'TT_MS_LANGID_SWEDISH_FINLAND\'                   : 0x081d,\n    \'TT_MS_LANGID_THAI_THAILAND\'                     : 0x041e,\n    \'TT_MS_LANGID_TURKISH_TURKEY\'                    : 0x041f,\n    \'TT_MS_LANGID_URDU_PAKISTAN\'                     : 0x0420,\n    \'TT_MS_LANGID_URDU_INDIA\'                        : 0x0820,\n    \'TT_MS_LANGID_INDONESIAN_INDONESIA\'              : 0x0421,\n    \'TT_MS_LANGID_UKRAINIAN_UKRAINE\'                 : 0x0422,\n    \'TT_MS_LANGID_BELARUSIAN_BELARUS\'                : 0x0423,\n    \'TT_MS_LANGID_SLOVENE_SLOVENIA\'                  : 0x0424,\n    \'TT_MS_LANGID_ESTONIAN_ESTONIA\'                  : 0x0425,\n    \'TT_MS_LANGID_LATVIAN_LATVIA\'                    : 0x0426,\n    \'TT_MS_LANGID_LITHUANIAN_LITHUANIA\'              : 0x0427,\n    \'TT_MS_LANGID_CLASSIC_LITHUANIAN_LITHUANIA\'      : 0x0827,\n    \'TT_MS_LANGID_TAJIK_TAJIKISTAN\'                  : 0x0428,\n    \'TT_MS_LANGID_FARSI_IRAN\'                        : 0x0429,\n    \'TT_MS_LANGID_VIETNAMESE_VIET_NAM\'               : 0x042a,\n    \'TT_MS_LANGID_ARMENIAN_ARMENIA\'                  : 0x042b,\n    \'TT_MS_LANGID_AZERI_AZERBAIJAN_LATIN\'            : 0x042c,\n    \'TT_MS_LANGID_AZERI_AZERBAIJAN_CYRILLIC\'         : 0x082c,\n    \'TT_MS_LANGID_BASQUE_SPAIN\'                      : 0x042d,\n    \'TT_MS_LANGID_SORBIAN_GERMANY\'                   : 0x042e,\n    \'TT_MS_LANGID_MACEDONIAN_MACEDONIA\'              : 0x042f,\n    \'TT_MS_LANGID_SUTU_SOUTH_AFRICA\'                 : 0x0430,\n    \'TT_MS_LANGID_TSONGA_SOUTH_AFRICA\'               : 0x0431,\n    \'TT_MS_LANGID_TSWANA_SOUTH_AFRICA\'               : 0x0432,\n    \'TT_MS_LANGID_VENDA_SOUTH_AFRICA\'                : 0x0433,\n    \'TT_MS_LANGID_XHOSA_SOUTH_AFRICA\'                : 0x0434,\n    \'TT_MS_LANGID_ZULU_SOUTH_AFRICA\'                 : 0x0435,\n    \'TT_MS_LANGID_AFRIKAANS_SOUTH_AFRICA\'            : 0x0436,\n    \'TT_MS_LANGID_GEORGIAN_GEORGIA\'                  : 0x0437,\n    \'TT_MS_LANGID_FAEROESE_FAEROE_ISLANDS\'           : 0x0438,\n    \'TT_MS_LANGID_HINDI_INDIA\'                       : 0x0439,\n    \'TT_MS_LANGID_MALTESE_MALTA\'                     : 0x043a,\n    \'TT_MS_LANGID_SAMI_NORTHERN_NORWAY\'              : 0x043b,\n    \'TT_MS_LANGID_SAMI_NORTHERN_SWEDEN\'              : 0x083b,\n    \'TT_MS_LANGID_SAMI_NORTHERN_FINLAND\'             : 0x0C3b,\n    \'TT_MS_LANGID_SAMI_LULE_NORWAY\'                  : 0x103b,\n    \'TT_MS_LANGID_SAMI_LULE_SWEDEN\'                  : 0x143b,\n    \'TT_MS_LANGID_SAMI_SOUTHERN_NORWAY\'              : 0x183b,\n    \'TT_MS_LANGID_SAMI_SOUTHERN_SWEDEN\'              : 0x1C3b,\n    \'TT_MS_LANGID_SAMI_SKOLT_FINLAND\'                : 0x203b,\n    \'TT_MS_LANGID_SAMI_INARI_FINLAND\'                : 0x243b,\n    \'TT_MS_LANGID_SAAMI_LAPONIA\'                     : 0x043b,\n    \'TT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM\'    : 0x083c,\n    \'TT_MS_LANGID_IRISH_GAELIC_IRELAND\'              : 0x043c,\n    \'TT_MS_LANGID_YIDDISH_GERMANY\'                   : 0x043d,\n    \'TT_MS_LANGID_MALAY_MALAYSIA\'                    : 0x043e,\n    \'TT_MS_LANGID_MALAY_BRUNEI_DARUSSALAM\'           : 0x083e,\n    \'TT_MS_LANGID_KAZAK_KAZAKSTAN\'                   : 0x043f,\n    \'TT_MS_LANGID_KIRGHIZ_KIRGHIZSTAN\'               : 0x0440,\n    \'TT_MS_LANGID_KIRGHIZ_KIRGHIZ_REPUBLIC\'          : 0x0440,\n    \'TT_MS_LANGID_SWAHILI_KENYA\'                     : 0x0441,\n    \'TT_MS_LANGID_TURKMEN_TURKMENISTAN\'              : 0x0442,\n    \'TT_MS_LANGID_UZBEK_UZBEKISTAN_LATIN\'            : 0x0443,\n    \'TT_MS_LANGID_UZBEK_UZBEKISTAN_CYRILLIC\'         : 0x0843,\n    \'TT_MS_LANGID_TATAR_TATARSTAN\'                   : 0x0444,\n    \'TT_MS_LANGID_BENGALI_INDIA\'                     : 0x0445,\n    \'TT_MS_LANGID_BENGALI_BANGLADESH\'                : 0x0845,\n    \'TT_MS_LANGID_PUNJABI_INDIA\'                     : 0x0446,\n    \'TT_MS_LANGID_PUNJABI_ARABIC_PAKISTAN\'           : 0x0846,\n    \'TT_MS_LANGID_GUJARATI_INDIA\'                    : 0x0447,\n    \'TT_MS_LANGID_ORIYA_INDIA\'                       : 0x0448,\n    \'TT_MS_LANGID_TAMIL_INDIA\'                       : 0x0449,\n    \'TT_MS_LANGID_TELUGU_INDIA\'                      : 0x044a,\n    \'TT_MS_LANGID_KANNADA_INDIA\'                     : 0x044b,\n    \'TT_MS_LANGID_MALAYALAM_INDIA\'                   : 0x044c,\n    \'TT_MS_LANGID_ASSAMESE_INDIA\'                    : 0x044d,\n    \'TT_MS_LANGID_MARATHI_INDIA\'                     : 0x044e,\n    \'TT_MS_LANGID_SANSKRIT_INDIA\'                    : 0x044f,\n    \'TT_MS_LANGID_MONGOLIAN_MONGOLIA\'                : 0x0450,\n    \'TT_MS_LANGID_MONGOLIAN_MONGOLIA_MONGOLIAN\'      : 0x0850,\n    \'TT_MS_LANGID_TIBETAN_CHINA\'                     : 0x0451,\n    \'TT_MS_LANGID_DZONGHKA_BHUTAN\'                   : 0x0851,\n    \'TT_MS_LANGID_TIBETAN_BHUTAN\'                    : 0x0851,\n    \'TT_MS_LANGID_WELSH_WALES\'                       : 0x0452,\n    \'TT_MS_LANGID_KHMER_CAMBODIA\'                    : 0x0453,\n    \'TT_MS_LANGID_LAO_LAOS\'                          : 0x0454,\n    \'TT_MS_LANGID_BURMESE_MYANMAR\'                   : 0x0455,\n    \'TT_MS_LANGID_GALICIAN_SPAIN\'                    : 0x0456,\n    \'TT_MS_LANGID_KONKANI_INDIA\'                     : 0x0457,\n    \'TT_MS_LANGID_MANIPURI_INDIA\'                    : 0x0458,\n    \'TT_MS_LANGID_SINDHI_INDIA\'                      : 0x0459,\n    \'TT_MS_LANGID_SINDHI_PAKISTAN\'                   : 0x0859,\n    \'TT_MS_LANGID_SYRIAC_SYRIA\'                      : 0x045a,\n    \'TT_MS_LANGID_SINHALESE_SRI_LANKA\'               : 0x045b,\n    \'TT_MS_LANGID_CHEROKEE_UNITED_STATES\'            : 0x045c,\n    \'TT_MS_LANGID_INUKTITUT_CANADA\'                  : 0x045d,\n    \'TT_MS_LANGID_AMHARIC_ETHIOPIA\'                  : 0x045e,\n    \'TT_MS_LANGID_TAMAZIGHT_MOROCCO\'                 : 0x045f,\n    \'TT_MS_LANGID_TAMAZIGHT_MOROCCO_LATIN\'           : 0x085f,\n    \'TT_MS_LANGID_KASHMIRI_PAKISTAN\'                 : 0x0460,\n    \'TT_MS_LANGID_KASHMIRI_SASIA\'                    : 0x0860,\n    \'TT_MS_LANGID_KASHMIRI_INDIA\'                    : 0x0860,\n    \'TT_MS_LANGID_NEPALI_NEPAL\'                      : 0x0461,\n    \'TT_MS_LANGID_NEPALI_INDIA\'                      : 0x0861,\n    \'TT_MS_LANGID_FRISIAN_NETHERLANDS\'               : 0x0462,\n    \'TT_MS_LANGID_PASHTO_AFGHANISTAN\'                : 0x0463,\n    \'TT_MS_LANGID_FILIPINO_PHILIPPINES\'              : 0x0464,\n    \'TT_MS_LANGID_DHIVEHI_MALDIVES\'                  : 0x0465,\n    \'TT_MS_LANGID_DIVEHI_MALDIVES\'                   : 0x0465,\n    \'TT_MS_LANGID_EDO_NIGERIA\'                       : 0x0466,\n    \'TT_MS_LANGID_FULFULDE_NIGERIA\'                  : 0x0467,\n    \'TT_MS_LANGID_HAUSA_NIGERIA\'                     : 0x0468,\n    \'TT_MS_LANGID_IBIBIO_NIGERIA\'                    : 0x0469,\n    \'TT_MS_LANGID_YORUBA_NIGERIA\'                    : 0x046a,\n    \'TT_MS_LANGID_QUECHUA_BOLIVIA\'                   : 0x046b,\n    \'TT_MS_LANGID_QUECHUA_ECUADOR\'                   : 0x086b,\n    \'TT_MS_LANGID_QUECHUA_PERU\'                      : 0x0c6b,\n    \'TT_MS_LANGID_SEPEDI_SOUTH_AFRICA\'               : 0x046c,\n    \'TT_MS_LANGID_SOTHO_SOUTHERN_SOUTH_AFRICA\'       : 0x046c,\n    \'TT_MS_LANGID_IGBO_NIGERIA\'                      : 0x0470,\n    \'TT_MS_LANGID_KANURI_NIGERIA\'                    : 0x0471,\n    \'TT_MS_LANGID_OROMO_ETHIOPIA\'                    : 0x0472,\n    \'TT_MS_LANGID_TIGRIGNA_ETHIOPIA\'                 : 0x0473,\n    \'TT_MS_LANGID_TIGRIGNA_ERYTHREA\'                 : 0x0873,\n    \'TT_MS_LANGID_TIGRIGNA_ERYTREA\'                  : 0x0873,\n    \'TT_MS_LANGID_GUARANI_PARAGUAY\'                  : 0x0474,\n    \'TT_MS_LANGID_HAWAIIAN_UNITED_STATES\'            : 0x0475,\n    \'TT_MS_LANGID_LATIN\'                             : 0x0476,\n    \'TT_MS_LANGID_SOMALI_SOMALIA\'                    : 0x0477,\n    \'TT_MS_LANGID_YI_CHINA\'                          : 0x0478,\n    \'TT_MS_LANGID_PAPIAMENTU_NETHERLANDS_ANTILLES\'   : 0x0479,\n    \'TT_MS_LANGID_UIGHUR_CHINA\'                      : 0x0480,\n    \'TT_MS_LANGID_MAORI_NEW_ZEALAND\'                 : 0x0481 }\nglobals().update(TT_MS_LANGIDS)\n\n'"
glumpy/ext/freetype/ft_enums/tt_name_ids.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n\n""""""\nPossible values of the \'name\' identifier field in the name records of the TTF\n\'name\' table. These values are platform independent.\n\nTT_NAME_ID_COPYRIGHT\n\nTT_NAME_ID_FONT_FAMILY\n\nTT_NAME_ID_FONT_SUBFAMILY\n\nTT_NAME_ID_UNIQUE_ID\n\nTT_NAME_ID_FULL_NAME\n\nTT_NAME_ID_VERSION_STRING\n\nTT_NAME_ID_PS_NAME\n\nTT_NAME_ID_TRADEMARK\n\nTT_NAME_ID_MANUFACTURER\n\nTT_NAME_ID_DESIGNER\n\nTT_NAME_ID_DESCRIPTION\n\nTT_NAME_ID_VENDOR_URL\n\nTT_NAME_ID_DESIGNER_URL\n\nTT_NAME_ID_LICENSE\n\nTT_NAME_ID_LICENSE_URL\n\nTT_NAME_ID_PREFERRED_FAMILY\n\nTT_NAME_ID_PREFERRED_SUBFAMILY\n\nTT_NAME_ID_MAC_FULL_NAME\n\nTT_NAME_ID_SAMPLE_TEXT\n\nTT_NAME_ID_CID_FINDFONT_NAME\n\nTT_NAME_ID_WWS_FAMILY\n\nTT_NAME_ID_WWS_SUBFAMILY\n""""""\n\n\nTT_NAME_IDS = {                                                                       \n    \'TT_NAME_ID_COPYRIGHT\'            :  0,\n    \'TT_NAME_ID_FONT_FAMILY\'          :  1,\n    \'TT_NAME_ID_FONT_SUBFAMILY\'       :  2,\n    \'TT_NAME_ID_UNIQUE_ID\'            :  3,\n    \'TT_NAME_ID_FULL_NAME\'            :  4,\n    \'TT_NAME_ID_VERSION_STRING\'       :  5,\n    \'TT_NAME_ID_PS_NAME\'              :  6,\n    \'TT_NAME_ID_TRADEMARK\'            :  7,\n\n    # the following values are from the OpenType spec \n    \'TT_NAME_ID_MANUFACTURER\'         :  8,\n    \'TT_NAME_ID_DESIGNER\'             :  9,\n    \'TT_NAME_ID_DESCRIPTION\'          : 10,\n    \'TT_NAME_ID_VENDOR_URL\'           : 11,\n    \'TT_NAME_ID_DESIGNER_URL\'         : 12,\n    \'TT_NAME_ID_LICENSE\'              : 13,\n    \'TT_NAME_ID_LICENSE_URL\'          : 14,\n    # number 15 is reserved \n    \'TT_NAME_ID_PREFERRED_FAMILY\'     : 16,\n    \'TT_NAME_ID_PREFERRED_SUBFAMILY\'  : 17,\n    \'TT_NAME_ID_MAC_FULL_NAME\'        : 18,\n\n    # The following code is new as of 2000-01-21\n    \'TT_NAME_ID_SAMPLE_TEXT\'          : 19,\n\n    # This is new in OpenType 1.3 \n    \'TT_NAME_ID_CID_FINDFONT_NAME\'    : 20,\n\n    # This is new in OpenType 1.5 \n    \'TT_NAME_ID_WWS_FAMILY\'           : 21,\n    \'TT_NAME_ID_WWS_SUBFAMILY\'        : 22 }\nglobals().update(TT_NAME_IDS)\n\n'"
glumpy/ext/freetype/ft_enums/tt_platforms.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n#\n#  FreeType high-level python API - Copyright 2011-2012 Nicolas P. Rougier\n#  Distributed under the terms of the new BSD license.\n#\n# -----------------------------------------------------------------------------\n""""""\nA list of valid values for the \'platform_id\' identifier code in FT_CharMapRec\nand FT_SfntName structures.\n\n\nTT_PLATFORM_APPLE_UNICODE\n\n  Used by Apple to indicate a Unicode character map and/or name entry. See\n  TT_APPLE_ID_XXX for corresponding \'encoding_id\' values. Note that name\n  entries in this format are coded as big-endian UCS-2 character codes only.\n\n\nTT_PLATFORM_MACINTOSH\t\n\n  Used by Apple to indicate a MacOS-specific charmap and/or name entry. See\n  TT_MAC_ID_XXX for corresponding \'encoding_id\' values. Note that most TrueType\n  fonts contain an Apple roman charmap to be usable on MacOS systems (even if\n  they contain a Microsoft charmap as well).\n\n\nTT_PLATFORM_ISO\t\n\n  This value was used to specify ISO/IEC 10646 charmaps. It is however now\n  deprecated. See TT_ISO_ID_XXX for a list of corresponding \'encoding_id\'\n  values.\n\n\nTT_PLATFORM_MICROSOFT\t\n\n  Used by Microsoft to indicate Windows-specific charmaps. See TT_MS_ID_XXX for\n  a list of corresponding \'encoding_id\' values. Note that most fonts contain a\n  Unicode charmap using (TT_PLATFORM_MICROSOFT, TT_MS_ID_UNICODE_CS).\n\n\nTT_PLATFORM_CUSTOM\t\n\n  Used to indicate application-specific charmaps.\n\n\nTT_PLATFORM_ADOBE\t\n\n  This value isn\'t part of any font format specification, but is used by\n  FreeType to report Adobe-specific charmaps in an FT_CharMapRec structure. See\n  TT_ADOBE_ID_XXX.\n""""""\n\nTT_PLATFORMS = {\n    \'TT_PLATFORM_APPLE_UNICODE\' : 0,\n    \'TT_PLATFORM_MACINTOSH\'     : 1,\n    \'TT_PLATFORM_ISO\'           : 2, # deprecated\n    \'TT_PLATFORM_MICROSOFT\'     : 3,\n    \'TT_PLATFORM_CUSTOM\'        : 4,\n    \'TT_PLATFORM_ADOBE\'         : 7} # artificial\nglobals().update(TT_PLATFORMS)\n\n'"
