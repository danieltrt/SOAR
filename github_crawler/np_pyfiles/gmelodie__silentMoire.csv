file_path,api_count,code
silent.py,3,"b'\nimport numpy as np\nimport src.noises, src.filters\nfrom scipy.fftpack import fftn, ifftn, fftshift\nimport imageio\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\nimport sys\n\n\n\ndef rgb2gray(rgb):      # pass image from RGB to gray levels\n    return np.dot(rgb[...,:3], [0.2989, 0.5870, 0.1140])\n\n\ndef noise_menu():\n    print(""Choose up to three options (e.g. 3 2):"")\n    print(""(1) Horizontal noise"")\n    print(""(2) Vertical noise"")\n    print(""(3) Diagonal noise"")\n\n    options = [int(opt) for opt in input().split()]\n\n    return options\n\n\ndef filter_menu():\n    print("" Choose up to three filter options (e.g. 2 1)"")\n    print(""(1) Median filter"")\n    print(""(2) Cut filter"")\n    print(""(3) Low pass filter"")\n    print(""(4) Band stop filter"")\n\n    options = [int(opt) for opt in input().split()]\n\n    return options\n\n\nif __name__ == \'__main__\':\n\n    if len(sys.argv) != 2:\n        print(\'usage: python silent.py <INPUT IMAGE>\')\n        exit(0)\n\n    img_orig = imageio.imread(sys.argv[1])\n\n    # Convert image to gray levels\n    img_gray = rgb2gray(img_orig)\n\n    print(\'Image dimensions:\')\n    print(img_gray.shape)\n\n    # Show original grayscale image\n    plt.imshow(img_gray, cmap=\'gray\')\n    plt.show()\n\n    # Choose and apply noise functions\n    noise_options = noise_menu()\n\n    noises = {\n        1: src.noises.horizontal,\n        2: src.noises.vertical,\n        3: src.noises.diagonal,\n    }\n\n    # Choose and apply filter functions\n    filter_options = filter_menu()\n\n    filters = {\n        1: src.filters.median,\n        2: src.filters.cut,\n        3: src.filters.low_pass,\n        4: src.filters.bandstop,\n    }\n\n    # Apply chosen noises\n    img_gray_noisy = np.copy(img_gray)\n    for noise_opt in noise_options:\n        img_gray_noisy = noises[noise_opt](img_gray_noisy, 3)\n        plt.imshow(img_gray_noisy, cmap=\'gray\')\n        plt.show()\n\n    # Apply chosen filters\n    img_gray_filtered = np.copy(img_gray_noisy)\n    for filter_opt in filter_options:\n        img_gray_filtered = filters[filter_opt](img_gray_filtered)\n        plt.imshow(img_gray_filtered, cmap=\'gray\')\n        plt.show()\n'"
src/filters.py,18,"b'import numpy as np\nfrom scipy.fftpack import fftn, ifftn, fftshift\nfrom scipy.spatial.distance import euclidean\nimport imageio\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\n\n\ndef _low_pass_filter(radius, final_shape):\n    filt = np.zeros((radius, radius))\n\n    # Create circle mask (pad later)\n    for x in range(radius):\n        for y in range(radius):\n            if (radius//2 - x)**2 + (radius//2 - y)**2 < (radius//2)**2:\n                filt[x][y] = 1\n\n    print(filt.shape)\n    plt.imshow(filt, cmap=\'gray\')\n    plt.show()\n\n    # Calculate padding shape (rows)\n    aux1 = final_shape[0] - filt.shape[0]\n    if(aux1 % 2 == 0): # even vs odd problem\n        pad_cols = ( (final_shape[0] - filt.shape[0])//2, \\\n                    (final_shape[0] - filt.shape[0])//2)\n    else:\n        pad_rows = ( (final_shape[0] - filt.shape[0])//2+1, \\\n                     (final_shape[0] - filt.shape[0])//2+1 )\n\n    # Calculate padding shape (cols)\n    aux2 = final_shape[1] - filt.shape[1]\n    if(aux2 % 2 == 0):\n        pad_cols = ( (final_shape[1] - filt.shape[1])//2, \\\n                     (final_shape[1] - filt.shape[1])//2)\n    else:\n        pad_cols = ( (final_shape[1] - filt.shape[1])//2+1, \\\n                     (final_shape[1] - filt.shape[1])//2+1)\n\n    pad_shape = (pad_rows, pad_cols)\n\n    # Apply padding\n    filt = np.pad(filt, pad_shape, \'constant\', constant_values=0)\n    if(aux1 % 2 != 0 and aux2 % 2 != 0):\n        filt = filt[0:filt.shape[0]-1, 0:filt.shape[1]-1]\n    elif(aux1 % 2 != 0 and aux2 % 2 == 0):\n        filt = filt[0:filt.shape[0]-1, 0:filt.shape[1]]\n    elif(aux1 % 2 == 0 and aux2 % 2 != 0):\n        filt = filt[0:filt.shape[0], 0:filt.shape[1]-1]\n\n    print(filt.shape)\n    plt.imshow(filt, cmap=\'gray\')\n    plt.show()\n\n    return filt\n\n\ndef low_pass(img, radius=501, debug=False):\n    """"""\n    Filters image using low pass filter in Fourier domain\n    Returns filtered image\n    """"""\n\n    img_fft = fftn(img)\n    img_fft_shift = fftshift(img_fft)\n\n    # Print spectrum before filtering\n    plt.imshow(np.abs(img_fft_shift), cmap=\'gray\', norm=LogNorm(vmin=5))\n    plt.show()\n\n    filter_mask = _low_pass_filter(radius, img.shape)\n\n    img_fft_shift_filtered = img_fft_shift * filter_mask\n\n    # Print spectrum after filtering\n    plt.imshow(np.abs(img_fft_shift_filtered), cmap=\'gray\', norm=LogNorm(vmin=5))\n    plt.show()\n\n    # Generate result image\n    return np.abs(ifftn(fftshift(img_fft_shift_filtered)))\n\n\ndef _local_median(img, x, y, k):\n    """"""\n    Computes median for k-neighborhood of img[x,y]\n    """"""\n    flat = img[x-k : x+k+1, y-k : y+k+1].flatten()\n    flat.sort()\n    return flat[len(flat)//2]\n\n\ndef median(img, k=3):\n    """"""\n    Changes every pixel to the median of its neighboors\n    """"""\n    res = np.copy(img)\n\n    for x in range(img.shape[0]):\n        for y in range(img.shape[1]):\n            if (x-k >= 0 and x+k < img.shape[0]) and \\\n                    (y-k >= 0 and y+k < img.shape[1]):\n                res[x, y] = _local_median(img, x, y, k)\n\n    return res\n\n\ndef cut(img):\n    """"""\n    Applies central horizontal threshold in Fourier spectrum\n    """"""\n\n    # Apply fourier transform and shift\n    img_fft = fftn(img)\n    img_fft_shift = fftshift(img_fft)\n\n    # Print spectrum before\n    plt.imshow(np.abs(img_fft_shift), cmap=\'gray\', norm=LogNorm(vmin=5))\n    plt.show()\n\n    # Filter image: remove upper and lower horizontal thirds (1/3)\n    img_fft_shift_filtered = np.copy(img_fft_shift)\n    for x in range(img.shape[0]):\n        for y in range(img.shape[1]):\n            if((x < img.shape[0]//2 - img.shape[0]//30 or \\\n               x > img.shape[0]//2 + img.shape[0]//30) and\\\n               (y < img.shape[1]//2 - img.shape[1]//30 or \\\n               y > img.shape[1]//2 + img.shape[1]//30)):\n                img_fft_shift_filtered[x,y] = 0\n            if((x < img.shape[0]//3 or \\\n                x > img.shape[0]*2//3) or \\\n               (y < img.shape[1]//3 or \\\n                y > img.shape[1]*2//3)):\n                img_fft_shift_filtered[x, y] = 0\n\n    # Print spectrum after\n    plt.imshow(np.abs(img_fft_shift_filtered), cmap=\'gray\', norm=LogNorm(vmin=5))\n    plt.show()\n\n    # Return to space domain result image using inverse\n    return np.abs(ifftn(fftshift(img_fft_shift_filtered)))\n\ndef bandstop(img, threshold=0.0001):\n    """"""\n    Apply bandstop filter on Fourier spectrum\n    """"""\n\n    img_fft = fftn(img)\n\n    #chose ther borders values\n    borders = [\n        img_fft[0, 0],\n        img_fft[0, img.shape[1]-1],\n        img_fft[img.shape[0]-1, 0],\n        img_fft[img.shape[0]-1, img.shape[1]-1]\n    ]\n\n    #select the max value and create the treshold\n    borders = np.array(borders)\n    max_value = np.max(borders)\n    T = threshold * np.abs(max_value)\n    print(""Max: "", np.max(img_fft))\n    print(""Min: "", np.min(img_fft))\n    print(""Threshold: "", T)\n    img_fft_shifted = fftshift(img_fft)\n\n    center_x = img_fft_shifted.shape[0]//2\n    center_y = img_fft_shifted.shape[1]//2\n    radius = img_fft_shifted.shape[0] // 6 \n    \n    # Apply the threshold out of the center of image\n    for x in range(img_fft_shifted.shape[0]):\n        for y in range(img_fft_shifted.shape[1]):\n            if (center_x - x)**2 + (center_y - y)**2 > (radius)**2 and np.abs(img_fft_shifted[x, y]) > T :\n                img_fft_shifted[x, y] = 0\n    \n    # Print spectrum after filtering\n    plt.imshow(np.abs(img_fft_shifted), cmap=\'gray\', norm=LogNorm(vmin=5))\n    plt.show()\n\n    return np.abs(ifftn(fftshift(img_fft_shifted)))'"
src/noises.py,3,"b'#\n#\n#\n#  NOISE GENERATION FUNCTIONS\n#\n# take image, return image with noise\n#\nimport numpy as np\nfrom scipy.fftpack import fft2, ifft2, fftshift\nimport imageio, math\nimport matplotlib.pyplot as plt\n#from skimage.util import random_noise\nfrom matplotlib.colors import LogNorm\n\n\ndef diagonal(img, gap):\n    """"""\n    Create lines for diagonal moir\xc3\xa9 pattern\n\n    gap: number of pixels between black pixels\n    """"""\n    img_noise = np.copy(img)\n\n    for x in range(img_noise.shape[0]):\n        for y in range(0, img_noise.shape[1], gap):\n            img_noise[x,(y+x) % img_noise.shape[1]] = 0\n\n    return img_noise\n\n\ndef horizontal(img, gap):\n    """"""\n    Create black lines for horizontal moir\xc3\xa9 pattern\n\n    gap: number of rows between black rows\n    """"""\n    img_noise = np.copy(img)\n\n    # black out a row in every [gap]\n    for x in range(0, img_noise.shape[0], gap):\n        for y in range(img_noise.shape[1]):\n            img_noise[x,y] = 0\n\n    return img_noise\n\n\ndef vertical(img, gap):\n    """"""\n    Create lines for vertical moir\xc3\xa9 pattern\n\n    gap: number of cols between black cols\n    """"""\n    img_noise = np.copy(img)\n\n    # black out a column in every [gap]\n    for x in range(img_noise.shape[0]):\n        for y in range(0, img_noise.shape[1], gap):\n            img_noise[x,y] = 0\n\n    return img_noise\n\n\n\ndef _general(grid_size, inter_grid_angle):\n    pass\n\n\ndef general(img, grid_size=1, inter_grid_angle=4):\n    """"""\n    Interesting grid sizes and angles (respectively)\n    (50, 30)\n    (1, 13)\n    """"""\n\n    lambd = int(math.sqrt(2) * grid_size * \\\n                math.sqrt(1 + math.cos(math.radians(inter_grid_angle))) * \\\n                1/math.sin(math.radians(inter_grid_angle)))\n\n    print(\'lambda = \', lambd)\n\n    noise = img.flatten()\n\n    noise[::lambd] = 0\n\n    return noise.reshape(img.shape)\n'"
