file_path,api_count,code
explore/circadian-efficacy/src/calculate_edge_circa_score.py,15,"b""# created by Yun Hao @GreeneLab2019\n#!/usr/bin/env python\n\nimport numpy as np\nimport pandas as pd\nimport requests\n\n## This function calculates the edge circadian score of a drug-disease pair without returning the score details of each path. It is faster, and requires less memory\ndef calculate_edge_circa_score(query_drug, query_disease, query_tissue, circa_df, query_metapath = 'database', min_path_count = 1, amp_threshold = 0.1, fdr_threshold = 0.05):\n\n\t'''\n\t--Input  \n\tquery_drug: drugbank ID\n\tquery_disease: disease ontology ID\n\tquery_tissue: list of tissue name (must match names used in CircaDB)\n\tcirca_df: dataframe that contains CircaDB data ('data/circa_db_mapped.tsv')\n\tquery_metapath: list of metapaths that will be included in the calculation (default only  includes all metapaths) \n\tmin_path_len: minimum number of paths bewteen query drug and query disease needed to generate a non-negative score (default 5) \n\tamp_threshold: amplitude threshold to define circadian gene (default 0.1)\n\tfdr_threshold: FDR threshold to define circadian gene (default 0.05)\n\t\n\t-- Output:\n\tlist: Edge circadian score\n\tString: reason why score cannot be calculated for query drug-disease pair (if any) \n\tfloat: number of metapaths that contain gene\n\tfloat: number of paths that contain gene in CircaDB\n\t'''\n\n\t# number of query tissues\n\ttissue_len = len(query_tissue)\n\t\n\t# get hetionet ID of the drug and the disease\n\tdrug_search = requests.get('https://search-api.het.io/v1/nodes/?search=' + query_drug).json()\n\tdisease_search = requests.get('https://search-api.het.io/v1/nodes/?search=' + query_disease).json()\n\n\t# check whether the drug and the disease are in hetionet\n\tif len(drug_search['results']) == 0 and len(disease_search['results']) == 0:\n\t\tcirca_edge_ratio = np.tile(float('nan'), tissue_len)\n\t\ttotal_meta_count = total_path_count = float('nan')\n\t\tnote = 'query drug and disease not in hetionet'\n\t\n\telif len(drug_search['results']) == 0:\n\t\tcirca_edge_ratio = np.tile(float('nan'), tissue_len)\n\t\ttotal_meta_count = total_path_count = float('nan')\n\t\tnote = 'query drug not in hetionet'\n    \t\n\telif len(disease_search['results']) == 0:\n\t\tcirca_edge_ratio = np.tile(float('nan'), tissue_len)\n\t\ttotal_meta_count = total_path_count = float('nan')\n\t\tnote = 'query disease not in hetionet'\n\t\n\telse: \n\t\t# get drug ID, disease ID, metapath ID\n\t\tdrug_id = drug_search['results'][0]['id']\n\t\tdisease_id = disease_search['results'][0]['id']\n\t\tgene_metapath = []\n\t\t# use metapaths in the database (sparse)\n\t\tif query_metapath == 'database':\n\t\t\t# get metapaths that connect the drug and the disease\n\t\t\tmeta_search = requests.get('http://search-api.het.io/v1/query-metapaths/?source=' + str(drug_id) + '&target=' + str(disease_id)).json()\n\t\t\tif len(meta_search['path_counts']) > 0:\n\t\t\t\tfor i in range(0, len(meta_search['path_counts'])):\n\t\t\t\t\ti_metapath = meta_search['path_counts'][i]['metapath_abbreviation']\n\t\t\t\t\tif 'G' in i_metapath:\n\t\t\t\t\t\tgene_metapath.append(i_metapath)\n\t\t# use pre-defined metapaths\n\t\telse:\n\t\t\tfor i in range(0, len(query_metapath)):\n\t\t\t\tif 'G' in query_metapath[i]:\n\t\t\t\t\tgene_metapath.append(query_metapath[i])\t\n\t\t\t\t\t\t\n\t\t# check whether drug and disease are connected by genes in hetionet\n\t\tif len(gene_metapath) == 0:\n\t\t\tcirca_edge_ratio = np.tile(float('nan'), tissue_len)\n\t\t\ttotal_meta_count = total_path_count = float('nan')\n\t\t\tnote = 'query drug and disease not connected by genes in hetionet'\n\t\t\t\n\t\telse:\n\t\t\ttotal_edge_score = np.zeros(tissue_len)\n\t\t\tcirca_edge_score = np.zeros(tissue_len)\n\t\t\ttotal_meta_count = 0\n\t\t\ttotal_path_count = 0\t\n\t\t\tquery_amp = [x + '_amp' for x in query_tissue]\n\t\t\tquery_fdr = [x + '_fdr' for x in query_tissue]\n\t\t\tfor j in range(0, len(gene_metapath)):\n\t\t\t\tpath_search = requests.get('http://search-api.het.io/v1/query-paths/?source=' + str(drug_id) + '&target=' + str(disease_id) + '&metapath=' + gene_metapath[j] + '&max-paths=-1').json()\n\t\t\t\tif len(path_search['paths']) == 0:\n\t\t\t\t\tcontinue\n\n\t\t\t\telif path_search['query']['metapath_adjusted_p_value'] == 1:\n\t\t\t\t\tcontinue\n\n\t\t\t\telse:\n\t\t\t\t\ttotal_meta_count = total_meta_count + 1\n\t\t\t\t\t# get max circadian score of the path\n\t\t\t\t\tgene_path_loc = [int(index/2) for index, value in enumerate(gene_metapath[j]) if value == 'G']\n\t\t\t\t\tfor k in range(0, len(path_search['paths'])):\n\n\t\t\t\t\t\t# get circadian score of the gene\n\t\t\t\t\t\tpath_gene_circa_amp = np.zeros(tissue_len)\n\t\t\t\t\t\tpath_gene_circa_fdr = np.zeros(tissue_len) + 1\n\t\t\t\t\t\tpath_gene_circa_count = 0\n\t\t\t\t\t\tfor l in range(0, len(gene_path_loc)):\n\t\t\t\t\t\t\t# get entrez ID of genes in the path\n\t\t\t\t\t\t\tloc_id = gene_path_loc[l]\n\t\t\t\t\t\t\tgene_node_id = path_search['paths'][k]['node_ids'][loc_id]\n\t\t\t\t\t\t\tgene_id = int(path_search['nodes'][str(gene_node_id)]['properties']['identifier'])\n\t\t\t\t\t\t\tgene_circa_amp = circa_df[query_amp][circa_df['gene_id'] == gene_id]\n\t\t\t\t\t\t\tgene_circa_fdr = circa_df[query_fdr][circa_df['gene_id'] == gene_id]\n\n\t\t\t\t\t\t\t# check whether the gene is in circaDB\n\t\t\t\t\t\t\tif len(gene_circa_amp) == 0:\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tpath_gene_circa_count = path_gene_circa_count + 1\n\t\t\t\t\t\t\t\tfor m in range(0, tissue_len):\n\t\t\t\t\t\t\t\t\ttmp_amp = float(gene_circa_amp.iloc[:,m])\n\t\t\t\t\t\t\t\t\tif tmp_amp > path_gene_circa_amp[m]:\n\t\t\t\t\t\t\t\t\t\tpath_gene_circa_amp[m] = tmp_amp\n\t\t\t\t\t\t\t\t\t\tpath_gene_circa_fdr[m] = float(gene_circa_fdr.iloc[:,m])\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif path_gene_circa_count > 0:\n\t\t\t\t\t\t\t# get path importance score\n\t\t\t\t\t\t\ttotal_path_count = total_path_count + 1\n\t\t\t\t\t\t\tpath_score = path_search['paths'][k]['score']\n\t\t\t\t\t\t\ttotal_edge_score = total_edge_score + path_score\n\t\t\t\t\t\t\t# check whether the gene is circadian\n\t\t\t\t\t\t\tfor n in range(0, tissue_len):\n\t\t\t\t\t\t\t\tif path_gene_circa_amp[n] >= amp_threshold and path_gene_circa_fdr[n] < fdr_threshold:\n\t\t\t\t\t\t\t\t\tcirca_edge_score[n] = circa_edge_score[n] + path_score\n\n\t\t\t# calculate proportion of circadian paths\n\t\t\tif total_meta_count == 0:\n\t\t\t\tcirca_edge_ratio = np.tile(float('nan'), tissue_len)\n\t\t\t\ttotal_path_count = float('nan')\n\t\t\t\tnote = 'query drug and disease not connected by genes in hetionet'\n\t\t\telse:\n\t\t\t\tif total_path_count == 0:\n\t\t\t\t\tcirca_edge_ratio = np.tile(float('nan'), tissue_len)\n\t\t\t\t\tnote = 'query drug and disease connected by genes not in CircaDB'\n\t\t\t\telif total_path_count < min_path_count:\n\t\t\t\t\tcirca_edge_ratio = np.tile(float('nan'), tissue_len)\n\t\t\t\t\tnote = 'query drug and disease connected by too few paths'\n\t\t\t\telse:\n\t\t\t\t\tcirca_edge_ratio = circa_edge_score/total_edge_score\n\t\t\t\t\tnote = 'NaN'\n\n\treturn circa_edge_ratio, note, total_meta_count, total_path_count\n\n\n## This function calculates the edge circadian score of a drug-disease pair, and then return the score details of each path. It is slower, and requires more memory\ndef detail_edge_circa_score(query_drug, query_disease, query_tissue, circa_df, query_metapath = 'database', min_path_count = 1, amp_threshold = 0.1, fdr_threshold = 0.05):\n\n\t'''\n\t--Input  \n\tquery_drug: drugbank ID\n\tquery_disease: disease ontology ID\n\tquery_tissue: list of tissue name (must match names used in CircaDB)\n\tcirca_df: dataframe that contains CircaDB data ('data/circa_db_mapped.tsv')\n\tquery_metapath: list of metapaths that will be included in the calculation (default only  includes all metapaths) \n\tmin_path_len: minimum number of paths bewteen query drug and query disease needed to generate a non-negative score (default 5) \n\tamp_threshold: amplitude threshold to define circadian gene (default 0.1)\n\tfdr_threshold: FDR threshold to define circadian gene (default 0.05)\n\t\n\t-- Output\n\tdictionary contains the following item:\n\t\tedge_circa_score\n\t\ttotal_meta_count: number of metapaths that contain gene\n\t\ttotal_path_count: number of paths that contain gene in CircaDB\n\t\tnote: reason why score cannot be calculated for query drug-disease pair (if any) \n\t\tscore_details: a dataframe that contains score details of each path\n\t'''\n\n\t# number of query tissues\n\ttissue_len = len(query_tissue)\n\t\n\t# get hetionet ID of the drug and the disease\n\tdrug_search = requests.get('https://search-api.het.io/v1/nodes/?search=' + query_drug).json()\n\tdisease_search = requests.get('https://search-api.het.io/v1/nodes/?search=' + query_disease).json()\n\tnull_output = {'edge_circa_score': dict((query_tissue[x], float('nan')) for x in range(0, len(query_tissue))),\n\t\t\t'total_meta_count': float('nan'),\n\t\t\t'total_path_count': float('nan'),\n\t\t\t'note': 'NaN',\n\t\t\t'score_details': 'NaN'\n\t\t\t}\n\n\t# check whether the drug and the disease are in hetionet\n\tif len(drug_search['results']) == 0 and len(disease_search['results']) == 0:\n\t\toutput = null_output\n\t\toutput['note'] = 'query drug and disease not in hetionet'\t\t\n\t\n\telif len(drug_search['results']) == 0:\n\t\toutput = null_output\n\t\toutput['note'] = 'query drug not in hetionet'\n\t\n\telif len(disease_search['results']) == 0:\n\t\toutput = null_output\n\t\toutput['note'] = 'query disease not in hetionet'\n\t\n\telse: \n\t\t# get drug ID, disease ID, metapath ID\n\t\tdrug_id = drug_search['results'][0]['id']\n\t\tdisease_id = disease_search['results'][0]['id']\n\t\tgene_metapath = []\n\t\t# use metapaths in the database (sparse)\n\t\tif query_metapath == 'database':\n\t\t\t# get metapaths that connect the drug and the disease\n\t\t\tmeta_search = requests.get('http://search-api.het.io/v1/query-metapaths/?source=' + str(drug_id) + '&target=' + str(disease_id)).json()\n\t\t\tif len(meta_search['path_counts']) > 0:\n\t\t\t\tfor i in range(0, len(meta_search['path_counts'])):\n\t\t\t\t\ti_metapath = meta_search['path_counts'][i]['metapath_abbreviation']\n\t\t\t\t\tif 'G' in i_metapath:\n\t\t\t\t\t\tgene_metapath.append(i_metapath)\n\t\t# use pre-defined metapaths\n\t\telse:\n\t\t\tfor i in range(0, len(query_metapath)):\n\t\t\t\tif 'G' in query_metapath[i]:\n\t\t\t\t\tgene_metapath.append(query_metapath[i])\t\n\t\t\t\t\t\t\n\t\t# check whether drug and disease are connected by genes in hetionet\n\t\tif len(gene_metapath) == 0:\n\t\t\toutput = null_output\n\t\t\toutput['note'] = 'query drug and disease not connected by genes in hetionet'\n\t\t\t\n\t\telse:\n\t\t\ttotal_edge_score = np.zeros(tissue_len)\n\t\t\tcirca_edge_score = np.zeros(tissue_len)\n\t\t\ttotal_meta_count = 0\n\t\t\ttotal_path_count = 0\n\t\t\tscore_details = []\n\t\t\tquery_amp = [x + '_amp' for x in query_tissue]\n\t\t\tquery_fdr = [x + '_fdr' for x in query_tissue]\n\t\t\tfor j in range(0, len(gene_metapath)):\n\t\t\t\tpath_search = requests.get('http://search-api.het.io/v1/query-paths/?source=' + str(drug_id) + '&target=' + str(disease_id) + '&metapath=' + gene_metapath[j] + '&max-paths=-1').json()\n\t\t\t\tif len(path_search['paths']) == 0:\n\t\t\t\t\tcontinue\n\n\t\t\t\telif path_search['query']['metapath_adjusted_p_value'] == 1:\n\t\t\t\t\tcontinue\n\n\t\t\t\telse:\n\t\t\t\t\ttotal_meta_count = total_meta_count + 1\n\t\t\t\t\t# get max circadian score of the path\n\t\t\t\t\tgene_path_loc = [int(index/2) for index, value in enumerate(gene_metapath[j]) if value == 'G']\n\t\t\t\t\tfor k in range(0, len(path_search['paths'])):\n\t\t\t\t\t\n\t\t\t\t\t\t# get circadian score of the gene\n\t\t\t\t\t\tpath_gene_circa_amp = np.zeros(tissue_len)\n\t\t\t\t\t\tpath_gene_circa_fdr = np.zeros(tissue_len) + 1\n\t\t\t\t\t\tpath_gene_circa_count = 0\n\t\t\t\t\t\tpath_gene_name = []\n\t\t\t\t\t\tfor l in range(0, len(gene_path_loc)):\n\t\t\t\t\t\t\t# get entrez ID of genes in the path\n\t\t\t\t\t\t\tloc_id = gene_path_loc[l]\n\t\t\t\t\t\t\tgene_node_id = path_search['paths'][k]['node_ids'][loc_id]\n\t\t\t\t\t\t\tgene_id = int(path_search['nodes'][str(gene_node_id)]['properties']['identifier'])\n\t\t\t\t\t\t\tgene_name = path_search['nodes'][str(gene_node_id)]['properties']['name']\n\t\t\t\t\t\t\tpath_gene_name.append(gene_name)\n\t\t\t\t\t\t\tgene_circa_amp = circa_df[query_amp][circa_df['gene_id'] == gene_id]\n\t\t\t\t\t\t\tgene_circa_fdr = circa_df[query_fdr][circa_df['gene_id'] == gene_id]\n\n\t\t\t\t\t\t\t# check whether the gene is in circaDB\n\t\t\t\t\t\t\tif len(gene_circa_amp) == 0:\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tpath_gene_circa_count = path_gene_circa_count + 1\n\t\t\t\t\t\t\t\tfor m in range(0, tissue_len):\n\t\t\t\t\t\t\t\t\ttmp_amp = float(gene_circa_amp.iloc[:,m])\n\t\t\t\t\t\t\t\t\tif tmp_amp > path_gene_circa_amp[m]:\n\t\t\t\t\t\t\t\t\t\ttmp_tissue = query_tissue[m]\n\t\t\t\t\t\t\t\t\t\tpath_gene_circa_amp[m] = tmp_amp\n\t\t\t\t\t\t\t\t\t\tpath_gene_circa_fdr[m] = float(gene_circa_fdr.iloc[:,m])\n\t\t\t\t\t\t\n\t\t\t\t\t\tcirca_tissues = []\n\t\t\t\t\t\tnon_circa_tissues = []\n\t\t\t\t\t\tif path_gene_circa_count > 0:\n\t\t\t\t\t\t\tgene_in_circa = True\n\t\t\t\t\t\t\t# get path importance score\n\t\t\t\t\t\t\ttotal_path_count = total_path_count + 1\n\t\t\t\t\t\t\tpath_score = path_search['paths'][k]['score']\n\t\t\t\t\t\t\ttotal_edge_score = total_edge_score + path_score\n\t\t\t\t\t\t\t# check whether the gene is circadian\n\t\t\t\t\t\t\tfor n in range(0, tissue_len):\n\t\t\t\t\t\t\t\tif path_gene_circa_amp[n] >= amp_threshold and path_gene_circa_fdr[n] < fdr_threshold:\n\t\t\t\t\t\t\t\t\tcirca_edge_score[n] = circa_edge_score[n] + path_score\n\t\t\t\t\t\t\t\t\tcirca_tissues.append(query_tissue[n])\t\t\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tnon_circa_tissues.append(query_tissue[n])\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tgene_in_circa = False\n\t\t\t\t\t\t\tcirca_tissues = non_circa_tissues = ['NaN']\n\t\t\t\t\t\n\n\t\t\t\t\t\t# fill in score details \n\t\t\t\t\t\tnode_ids = path_search['paths'][k]['node_ids']\n\t\t\t\t\t\tnode_names = []\n\t\t\t\t\t\tfor ni in node_ids:\n\t\t\t\t\t\t\tni_name = str(path_search['nodes'][str(ni)]['properties']['name'])\n\t\t\t\t\t\t\tnode_names.append(ni_name)\n\t\t\t\t\t\trel_ids = path_search['paths'][k]['rel_ids']\n\t\t\t\t\t\trel_types = []\n\t\t\t\t\t\tfor ri in rel_ids:\n\t\t\t\t\t\t\tri_name = str(path_search['relationships'][str(ri)]['rel_type'])\n\t\t\t\t\t\t\trel_types.append(ri_name)\n\t\t\t\t\t\tpath_details = {'source_node': node_names[0],\n\t\t\t\t\t\t\t\t'target_node': node_names[-1],\n\t\t\t\t\t\t\t\t'metapath': gene_metapath[j],\n\t\t\t\t\t\t\t\t'node_ids': ','.join([str(x) for x in node_ids]),\n\t\t\t\t\t\t\t\t'node_names': ','.join(node_names),\n\t\t\t\t\t\t\t\t'rel_ids': ','.join([str(x) for x in rel_ids]),\n\t\t\t\t\t\t\t\t'rel_names': ','.join(rel_types),\n\t\t\t\t\t\t\t\t'gene_symbol': ','.join(str(x) for x in path_gene_name),\n\t\t\t\t\t\t\t\t'whether_in_circadb': gene_in_circa,\n\t\t\t\t\t\t\t\t'circadian_tissue': ','.join(circa_tissues),\n\t\t\t\t\t\t\t\t'non_circadian_tissue': ','.join(non_circa_tissues),\n\t\t\t\t\t\t\t\t'importance_score': path_search['paths'][k]['score']\n                                                                }\n\t\t\t\t\t\tscore_details.append(path_details)\n\t\t\t\t\t\n\t\t\t# calculate proportion of circadian paths\n\t\t\toutput = null_output\n\t\t\toutput['total_meta_count'] = total_meta_count\n\t\t\toutput['total_path_count'] = total_path_count\n\t\t\tif total_meta_count == 0:\n\t\t\t\toutput['note'] = 'query drug and disease not connected by genes in hetionet'\n\t\t\telse:\n\t\t\t\tif total_path_count == 0:\n\t\t\t\t\toutput['note'] = 'query drug and disease connected by genes not in CircaDB' \t\t\n\t\t\t\telif total_path_count < min_path_count:\n\t\t\t\t\toutput['note'] = 'query drug and disease connected by too few paths'\n\t\t\t\telse:\n\t\t\t\t\tedge_circa_score = circa_edge_score/total_edge_score\n\t\t\t\t\toutput['edge_circa_score'] = dict((query_tissue[x], edge_circa_score[x]) for x in range(0, len(query_tissue)))\n\t\t\t\t\tdetail_df = pd.DataFrame(score_details)\n\t\t\t\t\tdetail_cols = ['source_node','target_node','metapath','node_ids','node_names','rel_ids','rel_names','gene_symbol','whether_in_circadb','circadian_tissue','non_circadian_tissue','importance_score']\n\t\t\t\t\toutput['score_details'] = detail_df[detail_cols]\t\n\treturn output\n"""
explore/circadian-efficacy/src/mapping_function.py,0,"b""# !/usr/bin/env python\n# created by Yun Hao @GreeneLab 2019\n\nimport numpy as np\nimport pandas as pd\n\n# map treatments to drugbank ID \ndef map_drugbank_id(query_list, map_db_id, map_drug):\n    # query_list: query treatments list; map_db_id: drugbank ID list; map_drug: drug name list\n\n    for i in range(0,len(map_drug)):\n        map_drug[i] = map_drug[i].lower()\n    \n    query_ids = []\n    for i in range(0,len(query_list)):\n        query_drugs = query_list[i].split(', ')\n        drug_ids = []\n        for j in range(0,len(query_drugs)):\n            if query_drugs[j] in map_drug:\n                drug_id = map_drug.index(query_drugs[j])\n                drug_ids.append(map_db_id[drug_id])\n            else:\n                drug_ids.append('NA')\n        drug_id_string = ', '.join(di for di in drug_ids)\n        query_ids.append(drug_id_string)\n\n    return query_ids\n\n# map therapeutic area to disease ontology ID\ndef map_disease_id(query_list, map_do_id, map_disease):\n    # query_list: query area list; map_do_id: DO ID list; map_disease: disease name\n\n    query_ids = []\n    for i in range(0,len(query_list)):\n        query_id = map_disease.index(query_list[i])\n        query_ids.append(map_do_id[query_id])\n\n    return query_ids\n\n# map genes to GTEx tissue-specific expression value\ndef map_gtex_expression(query_gene_list, query_tissue_list, map_gtex_tissue, map_tissue_name, gtex_exp):\n    # query_gene_list: query gene list; query_tissue_list: query tissue list; map_gtex_tissue: gtex tissue name list; map_tissue_name: circadb tissue name list; gtex_exp: GTEx tissue-specific expression matrix  \n\n    gtex_gene_name = list(gtex_exp.loc[:,'gene_id'])\n    for i in range(0, len(gtex_gene_name)):\n            gtex_gene_name[i] = gtex_gene_name[i].split('.')[0]\n\n    query_gene_id_list = []\n    for i in range(0, len(query_gene_list)):\n        query_gene_id = gtex_gene_name.index(query_gene_list[i])\n        query_gene_id_list.append(query_gene_id)\n\n    exp_array = []\n    for i in range(0, len(query_tissue_list)):\n        query_tissue_id = map_tissue_name.index(query_tissue_list[i])\n        query_tissues = map_gtex_tissue[query_tissue_id].split(', ')\n\n        tissue_exp = gtex_exp.loc[:,query_tissues]\n        gene_tissue_exp = tissue_exp.iloc[query_gene_id_list,:]\n        gene_exp = gene_tissue_exp.mean(axis = 1)\n        exp_array.append(list(gene_exp))\n\n    return exp_array\n"""
