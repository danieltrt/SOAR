file_path,api_count,code
models.py,1,"b'import numpy as np\nfrom scipy.optimize import minimize\n\n\ndef linear_model(x,y,a,b,weights):\n    return (a*x - y + b)**2*weights\n\ndef fit_model(model,init_cond,x_vec,y_vec,weights):\n    J = lambda param: np.sum(model(x_vec,y_vec,param[0],param[1],weights))\n    sol = minimize(J,init_cond)\n    return sol\n'"
robust_lsq.py,13,"b'#####################################\n# Author:   Guru Subramani\n# Date:     April 2nd 2018\n# MIT License\n#####################################\n#TODO Add pythonic documentation elements\n\nimport numpy as np\n\ndef robust_lsq_ransac(model_error_func, model_fit_func, X,\n               iterations=1000, fit_samples=2, fit_with_best_n=None, priors=None,norm_func = np.arctan):\n\n    if priors == None:\n        probabilities = np.ones(len(X))\n    else:\n        probabilities = priors\n\n    probabilities /= np.sum(probabilities)\n    indices = np.array(range(len(X)))\n    current_prob = probabilities.copy()\n    for iter in range(iterations):\n        sampled_indices = np.random.choice(range(len(indices)),\n                                           p=probabilities, size=fit_samples, replace=False)\n\n        X_subset = X[sampled_indices]\n        params = model_fit_func(X_subset)\n        errors = model_error_func(X, params)\n\n        current_prob[:] = 1 / norm_func(1 + errors[:])\n        probabilities *= current_prob\n        probabilities /= np.sum(probabilities)\n\n    if fit_with_best_n == None:\n        return probabilities\n    else:\n        robust_X = X[np.argsort(probabilities)[-fit_with_best_n:]]\n        robust_params = model_fit_func(robust_X)\n        return probabilities, robust_params, model_error_func(robust_X, robust_params)\n\n\ndef robust_lsq_m_estimates(model_error_func, model_fit_func, X,\n                           iterations=1000, priors=None,norm_func = lambda x: 1/(1 + x**0.1)):\n    if priors == None:\n        probabilities = np.ones(len(X))\n    else:\n        probabilities = priors\n\n    probabilities /= np.sum(probabilities)\n    best_errors = 1e100\n    best_param = None\n    current_prob = probabilities.copy()\n    for iter in range(iterations):\n        params = model_fit_func(X, probabilities)\n        errors = model_error_func(X, params, probabilities)\n        if np.sum(errors) < best_errors:\n            best_param = params\n            best_errors = np.sum(errors)\n\n        current_prob[:] = norm_func(errors[:])\n        probabilities *= current_prob\n        probabilities /= np.sum(probabilities)\n    params = model_fit_func(X, probabilities)\n    errors = model_error_func(X, params, probabilities)\n    if np.sum(errors) < best_errors:\n        best_param = params\n    return probabilities, best_param, errors\n\n\n'"
test.py,12,"b'## test out robust fitting\n\nimport matplotlib.pyplot as plt\nfrom models import *\nfrom robust_lsq import *\n\nif __name__ == ""__main__"":\n\n    x_actual = np.random.rand(100)\n    y_actual = x_actual * (-1) + 3\n    y_measured = y_actual + np.random.rand(len(x_actual)) * 0.1 - 0.05\n    x_measured = x_actual + np.random.rand(len(x_actual)) * 0.1 - 0.05\n    x_measured = np.append(x_measured, np.array(range(50)) / 100.0)\n    y_measured = np.append(y_measured, np.zeros(50) + np.random.rand(50) * 10)\n\n    X = np.transpose([x_measured, y_measured])\n    weights = np.ones(len(X))\n    model_fit_func = lambda X: fit_model(linear_model,[1,1],X[:,0],X[:,1],np.ones(len(X))).x\n    model_error_func = lambda X,params: linear_model(X[:,0],X[:,1],params[0],params[1],np.ones(len(X)))\n\n    sol_lsq = fit_model(linear_model, [1, 1], x_measured, y_measured,weights)\n\n    probs,params,errors = robust_lsq_ransac(model_error_func,model_fit_func,X,\n                                 iterations = 100,fit_samples = 10,fit_with_best_n = 100)\n\n    model_fit_weights_func = lambda X, weights: fit_model(linear_model, [1, 1], X[:, 0], X[:, 1], weights).x\n    model_error_weights_func = lambda X, params, weights: linear_model(X[:, 0], X[:, 1], params[0], params[1], weights)\n\n    X = np.transpose([x_measured, y_measured])\n\n    probsMest, paramsMest, errorsMest = robust_lsq_m_estimates(model_error_weights_func, model_fit_weights_func, X,\n                                                   iterations=40, priors=None)\n\n\n    robust_indices = np.where(probs > 0.0002)\n    outlier_indices = np.where(probs < 0.0002)\n\n    robust_fit_x = x_measured[robust_indices]\n    robust_fit_y = y_measured[robust_indices]\n\n    outlier_x = x_measured[outlier_indices]\n    outlier_y = y_measured[outlier_indices]\n\n    plt.subplot(2,1,1)\n    plt.plot(x_actual, y_actual, \'.b\')\n    plt.plot(x_measured, y_measured, \'.g\')\n    plt.plot(x_measured, x_measured * sol_lsq.x[0] + sol_lsq.x[1], \'r\')\n    plt.legend([\'actual data(without outliers)\',\'measured data\',\'Least Squares Fit\'])\n\n    plt.subplot(2,1,2)\n    #plt.plot(x_measured, y_measured, \'.g\')\n    plt.plot(x_measured, x_measured * sol_lsq.x[0] + sol_lsq.x[1], \'r\')\n    plt.plot(x_measured, x_measured * params[0] + params[1], \'-k\')\n    plt.plot(x_measured, x_measured * paramsMest[0] + paramsMest[1], \'--k\')\n    plt.plot(robust_fit_x, robust_fit_y, \'ok\')\n    plt.plot(outlier_x, outlier_y, \'xk\')\n\n    plt.legend([\'Least Squares Fit\',\'RANSAC\',\'M-Estimates\',\'Correct Data\',\'Outliers\'])\n    plt.show()\n\n'"
