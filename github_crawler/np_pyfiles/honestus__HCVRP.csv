file_path,api_count,code
src/instances.py,3,"b'import numpy as np\nimport pandas as pd\nimport random, time, math, os, sys, pickle\n\ndef initParameters():\n    """""" Init the parameters of the distinct useful paths for instances, solver, configuration etc.""""""\n    global instancesFileType,solverFileType, path, originalDataPath, instancesSettingsFile, solverSettingsFile, instancesSavedPath\n    solverFileType=1\n    instancesFileType=2\n    #path= os.path.dirname(os.path.dirname(os.path.abspath(path=sys.argv[0])))\n    pathOld= os.path.dirname(os.getcwd())\n    path = os.path.abspath(os.path.join(os.path.dirname(__file__),""..""))\n    print(path)\n    originalDataPath=path+""/data/""\n    instancesSavedPath=path+""/instances/""\n    instancesSettingsFile=path+""/config/config.txt""\n    solverSettingsFile=path+""/config/solverconf.txt""\n\n\ndef setInstances(instances):\n    """""" Updates the instances to currently solve the problem on """"""\n    global actualInstances\n    actualInstances=instances\n\n\ndef loadSettings(fileName, fileType):\n    """""" Loads all the settings needed to solve the problem """"""\n    if not ""solverFileType"" in globals() or not ""instancesFileType"" in globals():\n        initParameters()\n\n    def isComplete(settings):\n        """""" Checks that the any settings needed for execution is not missing from the ones currently loaded """"""\n        if fileType==instancesFileType:\n            neededVariables = [\'clients\',\'min_avg_req\',\'max_avg_req\',\'capacity\',\'V1_percent\',\'min_num_vehicles\',\n                         \'max_num_vehicles\',\'var\', \'min_req\',\'V1_cost\',\'V2_cost\']\n        elif fileType==solverFileType:\n            neededVariables = [\'solver\', \'maxTime\']\n        else:\n            return False\n\n        if set(settings.keys())>=set(neededVariables):\n            #se settings contiene(come chiavi) ALMENO tutte le variabili necessarie(quelle di neededVariables)...\n            utilSettings = {k: settings[k] for k in neededVariables}\n            if \'\' not in utilSettings.values():\n            # e nessun valore associato alle chiavi \xc3\xa8 \'\', allora restituisce True\n                return True\n        return False #altrimenti restituisce False\n\n    def isValid(settings):\n        """""" Checks that the any settings currently loaded is semantically correct and has feasible values """"""\n        if fileType==instancesFileType:\n            clients = settings[\'clients\']\n            minAvgReq = settings[\'min_avg_req\']\n            maxAvgReq = settings[\'max_avg_req\']\n            capacity = settings[\'capacity\']\n            V1Percent = settings[\'V1_percent\']\n            minNumVehicles = settings[\'min_num_vehicles\']\n            maxNumVehicles = settings[\'max_num_vehicles\']\n            var = settings[\'var\']\n            minReq = settings[\'min_req\']\n            return (type(clients) is int and 0 < clients <= 100 and 0 < minAvgReq <= maxAvgReq <= 1.5 and type(capacity) is int and capacity > 0 and 0 <= V1Percent <= 1 and 1<= minNumVehicles <= maxNumVehicles and var > 0 and 0 < minReq <= 1)\n        elif fileType==solverFileType:\n            solver = settings[\'solver\']\n            maxTime = settings[\'maxTime\']\n            return str(solver).upper()==\'GLPK\' or str(solver).upper()==\'CBC\' and type(maxTime) is int and maxTime > 0\n        else:\n            return False\n\n\n    #dato un file in input, restituisce un dizionario avente un insieme di chiavi-valore\n    settings = {}\n    utilSettings = {}\n    try:\n        f = open (fileName,""r"")\n    except FileNotFoundError:\n        fileName = path+""/config/""+str(fileName)\n    except IsADirectoryError:\n        if fileType==instancesFileType:\n            fileName = str(fileName)+""/""+instancesFileName\n        elif fileType==solverFileType:\n            fileName = str(fileName)+""/""+solverFileName\n    try:\n        f = open(fileName,""r"")\n    except FileNotFoundError:\n        print(""Ooops... Configuration file not found. Please make sure you\'ve inserted the file name correctly"")\n        return False\n    config = f.readlines()   #inserisce nel vettore config un elemento per ogni riga\n    for conf in config:\n        conf = conf.split(""#"")[0]    #eliminiamo i commenti finali del file\n        try:\n            settings[conf.split("": "")[0]] = int(conf.split("": "")[1]) #inserisco nel dizionario le coppie chiave-valore per ogni impostazione\n        except ValueError:\n            try:\n                settings[conf.split("": "")[0]] = float(conf.split("": "")[1])\n            except ValueError:\n                settings[conf.split("": "")[0]] = conf.split("": "")[1].strip()\n        except IndexError: #se ci sono righe vuote o ""mal strutturate"" nel file, salta quelle linee\n            continue\n    f.close()\n\n    try:\n        if isComplete(settings):\n            if isValid(settings):\n                return settings\n            print (""Ops. Some data has incorrect value for the settings in input. Please adjust it and try again"")\n            return False\n        else:\n            print (""It\'s not possible to load the data from the file. Some value is missing."")\n            return False\n    except ValueError as v:\n        print (str(v))\n        return False\n\n\n\ndef chooseFile():\n    """""" Chooses a random file(between the 60 currently in data/ folder) to load the instances from """"""\n    global scelta\n    scelta=0\n    while(scelta<1 or scelta>60):\n        try:\n            scelta = int(input(""Select file (using a number between 1 and 60): ""))\n        except ValueError:\n            print(""Uncorrect input. Please try again."")\n\n\ndef caricaDataframe(fileName=\'random\'):\n    """""" Loads an instances file(whose name is in input) into a pandas DataFrame and removes all the useless features """"""\n    cols = [""stopNR"", ""X"", ""Y"", ""TW1"", ""TW2"", ""TW3"", ""TW4"", ""Demand"", ""Time"", ""Del""]\n    colsToRemove=[""stopNR"", ""TW1"", ""TW2"", ""TW3"", ""TW4"", ""Demand"", ""Time"", ""Del""]\n    #scegliFile()\n    chosenFile = fileName\n    if chosenFile==\'random\':\n        chosenFile=str(random.randrange(1,60)) + ""G3.DAT""\n    elif not chosenFile.endswith(\'G3.DAT\'):\n        chosenFile += ""G3.DAT""\n    try:\n        standardDf = pd.read_fwf(originalDataPath+str(chosenFile),names=cols)\n        return standardDf.drop(colsToRemove,axis=1)\n    except FileNotFoundError:\n        print(""Instances File chosen Not found"")\n        raise\n\n\ndef getRandomClients(nOfClients,dataframe=None):\n    """""" Starting from dataframe, extracts a sample(dataframe) by randomly taking nOfClients(in input) clients from the starting ones """"""\n    if dataframe is None:\n        if not \'instancesDf\' in globals():\n            raise DataframeError(\'No dataframes actually in use\')\n            return\n        else:\n            dataframe=instancesDf\n    clientsIndexes = [0]\n    if not isinstance(dataframe,pd.core.frame.DataFrame):\n        dataframe=caricaDataframe()\n\n    clientsIndexes.extend(random.sample(range(1,len(dataframe)),nOfClients))\n    dataframe=dataframe.iloc[sorted(clientsIndexes)]\n    dataframe.index=range(nOfClients+1)\n    return dataframe\n\n\ndef distances_matrix(dataframe=None):\n    """""" Starting from a dataframe(in input) having x and y features (for each client),\n    generates a distance_matrix for the clients """"""\n    if dataframe is None:\n        if not \'instancesDf\' in globals():\n            raise DataframeError(\'No dataframes actually in use\')\n            return\n        else:\n            dataframe=instancesDf\n    distances = [None] * len(dataframe) #crea un vettore di lunghezza pari al numero di nodi\n\n    for i in dataframe.index:\n        distances[i] = [0] * len(dataframe) #crea a ogni ciclo un vettore all\'interno del vettore distances\n        for j in range(i+1,len(dataframe)):\n            XDiff = dataframe.X[i] - dataframe.X[j]\n            YDiff = dataframe.Y[i] - dataframe.Y[j]\n            distances[i][j] = math.hypot(XDiff,YDiff)\n\n    for i in dataframe.index:\n        for j in range(i+1,len(dataframe)):\n            if(random.randrange(0,9)>2):\n                s = 10 #scostamento massimo 10% in circa 7 su 10\n            else:\n                s = 30 #scostamento massimo 30% in circa 3 su 10\n            scost = distances[i][j]/s #scostamento massimo\n            distances[j][i] = random.uniform((distances[i][j])-scost, (distances[i][j])+scost)\n\n    return distances\n\n\ndef generateDemands(avgRequest,minimumRequest,maximumRequest,varianza,nOfClients=100):\n    """""" Starting from nOfClients and avgRequest(of each client), allocates a demand d to each client\n    (minimumRequest<=d<=maximumRequest) in such a way that the total demand is equal to: nOfClients * avgRequest.\n    Please note that maximumRequest<= V1 capacity + V2 capacity\n    (ie: a client cannot be served from more than two vehicles and from more than a vehicle of each type,\n    thus its max request mustn\'t be higher than the sum of V1 and V2 capacity) """"""\n    minDemand = -1\n    maxDemand = maximumRequest\n    generatedDemands = 0\n    totalDemand = nOfClients * avgRequest\n    tolerance = 1000\n    start = time.time()\n    print (""Generating distinct demands for any client..."")\n    while(minDemand<minimumRequest or maxDemand>maximumRequest or abs(generatedDemands-totalDemand)>(totalDemand/tolerance)):\n        #richiesta di un client non pu\xc3\xb2 essere minore di minimumRequest o maggiore della somma della capacit\xc3\xa0 dei veicoli\n        #d = np.random.dirichlet(np.ones(nOfClients), size=1)[0]\n        demands = np.random.normal(avgRequest,scale=varianza*avgRequest,size=nOfClients)\n        #tempDemands = list(map(lambda x: x*totalDemand, d))\n        minDemand=min(demands)\n        maxDemand=max(demands)\n        generatedDemands = sum(demands)\n        if tolerance==1000 and time.time()-start>60:\n            print(""The generation of the demands is keeping too much time, model relaxed..."")\n            tolerance = 500\n        elif tolerance==500 and time.time()-start>120:\n            tolerance = 200\n        elif time.time()-start>180:\n            print(""The generation of the demands is keeping too much time, trying again relaxing the variance..."")\n            varianza=varianza*.8\n            tolerance=1000\n            start = time.time()\n\n    finalDemands = list([0])\n    finalDemands.extend(demands)\n    print(""Clients demands generated correctly..."")\n    return finalDemands\n    #totalDemand = sum(demands)\n\n\n\n\ndef generateNumVehicles(minimum,maximum,t1Percent=0.5):\n    """""" Random chooses the number V of total vehicles (minimum<=V<=maximum) and returns V,\n    the number V1 of largest vehicles (as V*t1Percent) and the number V2 of smallest vehicles (V - V1).\n    Please note that the minimum in input MUST BE higher than the number of NEEDED\n    vehicles(given by getMinNumberOfVehicles()) to satisfy the clients demand.""""""\n    numVehicles = math.ceil(random.uniform(minimum,maximum+1))\n    T1Vehicles = math.ceil (numVehicles * t1Percent)\n    T2Vehicles = numVehicles - T1Vehicles\n    return numVehicles,T1Vehicles,T2Vehicles\n\n\n\ndef getMinNumberOfVehicles(totalRequests, t1Capacity, t1Percent):\n    """""" Given (in input) the total clients demand, the V1 vehicles capacity (and thus the V2 one, too)\n    and the percentage of V1 vehicles (ie: n\xc2\xb0 of V1_Vehicles / n\xc2\xb0 of total Vehicles),\n    gives the minimum estimated number of vehicles to handle the total demand """"""\n    avgCapacity = t1Percent * t1Capacity + (1-t1Percent) * (t1Capacity/2)\n    return math.ceil(totalRequests / avgCapacity)\n\n\n\n# A partire da: capacit\xc3\xa0 minima e massima per il veicolo grande, e dalla percentuale di veicoli grandi rispetto\n# ai veicoli totali(t1Percent), genera un intero(tra minCapacity e maxCapacity) che indicher\xc3\xa0 la capacit\xc3\xa0\n# dei veicoli grandi.\n# Quindi sceglie la richiesta media di ogni client che si aggirer\xc3\xa0 tra l\'1% ed il 5% (NB: RICHIESTA MEDIA! UN CLIENT\n# PU\xc3\x92 COMUNQUE RICHIEDERE MOLTO MENO O MOLTO PI\xc3\x99!(fino a Capacit\xc3\xa0V1+Capacit\xc3\xa0V2))\n# Infine calcola il numero minimo di veicoli necessari per soddisfare i client, e in base a tale numero minimo\n# sceglie quanti veicoli ""generare"", tra un minimo(che sar\xc3\xa0 il n\xc2\xb0minimo necessario di veicoli, incrementato di un 20%)\n#ed un massimo(il doppio rispetto al minimo necessario)\ndef generateInstances(settings=None): #,minAvgRequest=5,gap=5,maxAvgRequest=20):\n    """""" Starting from the settings in input, generates the instances to solve the problem on\n    More in detail: Starting from minCapacity and maxCapacity for V1(largest vehicle), and from the percentage of V1\n    with respect to the number V of vehicles, generates an integer that states the V1 capacity.\n    Then randomly generates the clients different requests (the higher the variance in input, the higher the variance of the requests).\n    Starting from these data, calculates the min (minV) number of vehicles to satisfy the requests, and finally generates the\n    number of vehicles currently in use(randomly from minV*1.2 to minV*2) """"""\n    if settings is None:\n        if not \'instancesSettings\' in globals():\n            raise settingsError(\'No settings defined to generate new instances\')\n            return False\n        else:\n            global instancesSettings\n            settings = instancesSettings\n    else:\n        instancesSettings=settings\n    def isValid():\n        clients = settings[\'clients\']\n        minAvgReq = settings[\'min_avg_req\']\n        maxAvgReq = settings[\'max_avg_req\']\n        capacity = settings[\'capacity\']\n        V1Percent = settings[\'V1_percent\']\n        minNumVehicles = settings[\'min_num_vehicles\']\n        maxNumVehicles = settings[\'max_num_vehicles\']\n        var = settings[\'var\']\n        minReq = settings[\'min_req\']\n        return (type(clients) is int and 0 < clients <= 100 and 0 < minAvgReq <= maxAvgReq <= 1.5 and type(capacity) is int and capacity > 0 and 0 <= V1Percent <= 1 and 1<= minNumVehicles <= maxNumVehicles and var > 0 and 0 < minReq <= 1)\n    if not isValid():\n        print (""Cannot generate instances using the settings in input. Some setting has incompatible value"")\n        return False\n\n    instances = {}\n    print (""Generating new instances..."")\n    #generaCapacit\xc3\xa0Max(minCapacity,maxCapacity)\n    clients = instances[\'clients\'] = settings[\'clients\']\n    capacit\xc3\xa0V1 = instances[\'capacity\'] = settings[\'capacity\']\n    capacit\xc3\xa0V2 = settings[\'capacity\']/2\n    t1Percent = settings[\'V1_percent\']\n    minAvgRequest = capacit\xc3\xa0V1 * settings[\'min_avg_req\']\n    maxAvgRequest = capacit\xc3\xa0V1 * settings[\'max_avg_req\']\n    var = settings[\'var\']\n    avgRequest = random.uniform(minAvgRequest,maxAvgRequest)\n    demands=generateDemands(avgRequest=avgRequest,minimumRequest=avgRequest*settings[\'min_req\'],maximumRequest=capacit\xc3\xa0V1+capacit\xc3\xa0V2,varianza=var, nOfClients=clients)\n    instancesDf = getRandomClients(clients)\n\n    instancesDf[\'Demand\'] = pd.Series(demands,index=instancesDf.index)\n    minNoOfVehicles = getMinNumberOfVehicles(sum(demands),capacit\xc3\xa0V1,t1Percent)\n    currentVehicles = generateNumVehicles(minimum=minNoOfVehicles*settings[\'min_num_vehicles\'],maximum=minNoOfVehicles*settings[\'max_num_vehicles\'],t1Percent=t1Percent)\n    numVehicles = currentVehicles[0]\n    T1Vehicles = currentVehicles[1]\n    T2Vehicles = currentVehicles[2]\n\n    instances[\'vehicles\']=currentVehicles[0]\n    instances[\'T1Vehicles\']=currentVehicles[1]\n    instances[\'T2Vehicles\']=currentVehicles[2]\n    instances[\'df\']=instancesDf\n    instances[\'distances\'] = distances_matrix(instancesDf)\n    instances[\'V1_cost\'] = settings[\'V1_cost\']\n    instances[\'V2_cost\'] = settings[\'V2_cost\']\n    print (""Instances generation complete!"")\n    setInstances(instances)\n    return instances\n\n\ndef saveInstances(fileName,instances=None):\n    """""" saves the current instances in the specified fileName (in ""instances/"" dir) """"""\n    if instances is None:\n        if not ""actualInstances"" in globals():\n            print (""No instances currently generated to save"")\n            return False\n        else:\n            instances=actualInstances\n    if not fileName.endswith(\'.dat\') or os.path.isfile(instancesSavedPath+fileName):\n        print(""Cannot save using the name chosen. Please use a name ending by \\\'.dat\\\' ""\n                              ""and not already existing for your file to save."")\n        return False\n\n    neededVariables = [\'clients\',\'capacity\',\'vehicles\',\'T1Vehicles\',\'T2Vehicles\', \'distances\', \'df\', \'V1_cost\', \'V2_cost\']\n    if set(instances.keys())>=set(neededVariables):\n        tmpFile = open(instancesSavedPath+fileName, \'wb\')\n        pickle.dump(instances, tmpFile, protocol=3)\n        tmpFile.close()\n        print (\'Instances correctly saved!\')\n    else:\n        print (""Cannot save the instances in input. One or more values to save are missing."")\n        return False\n\n\ndef loadInstances(fileName):\n    """""" Loads instances from file (fileName in input, from ""instances/"" dir) and checks that its values are correct and complete """"""\n    if not os.path.isfile(instancesSavedPath+fileName):\n        if not os.path.isfile(fileName):\n            print (""There are no existing files with the name you\'ve inserted. Please be sure you\'ve written""\n               "" it correctly."")\n            return False\n    else:\n        fileName = instancesSavedPath+fileName\n\n    try:\n        d = pd.read_pickle(path=fileName)\n    except:\n        print(""It\'s not possible to load the instances from the file. The content is different from the expected one."")\n        return False\n\n    neededVariables = [\'clients\',\'capacity\',\'vehicles\',\'T1Vehicles\',\'T2Vehicles\', \'distances\', \'df\', \'V1_cost\', \'V2_cost\']\n    if set(d.keys())>=set(neededVariables):\n        instances = dict(d)\n        setInstances(instances) #aggiorno il valore di ""actualInstances""\n        return instances\n\n    else:\n        print(""It\'s not possible to load the instances from the file. Some value is missing"")\n        d.close()\n        return False\n\n\ndef getInstances(fileName=\'\'):\n    """""" Returns a dataframe of the instances.\n    If fileName is a .txt file, then it will load the instances settings and generate new instances.\n    If fileNames is a .dat file, it will load the previously saved instances.\n    Otherwise, it returns the actualInstances(the ones currently used, if any) """"""\n    global actualInstances\n    if fileName.endswith(\'.txt\'):\n        settings = loadSettings(fileName, instancesFileType)\n        return generateInstances(settings), 0\n\n    elif fileName.endswith(\'.dat\'):\n        return loadInstances(fileName), 1\n    else:\n        if not ""actualInstances"" in globals():\n            return """"\n        return actualInstances\n\n\ndef printInstancesValues(instances=None):\n    """""" Prints out the variables values of the current instances """"""\n    if instances is None:\n        if not ""actualInstances"" in globals():\n            print (""No instances currently generated"")\n            return\n        else:\n            instances=actualInstances\n    print(""These are the current instances generated: \\n\\n"")\n    print(""N\xc2\xb0 of clients:"" , instances[\'clients\'])\n    print(""avg Request: "" , np.mean(instances[\'df\'][\'Demand\'][1:]))\n    print(""min Request: "", min(instances[\'df\'][\'Demand\'][1:]))\n    print(""max Request: "", max(instances[\'df\'][\'Demand\']))\n    print(""V1 Capacity: "" , instances[\'capacity\'])\n    print(""V2 Capacity: "" , instances[\'capacity\']/2)\n    print(""N\xc2\xb0 of vehicles: "" , instances[\'vehicles\'])\n    print(""N\xc2\xb0 of V1 vehicles: "" , instances[\'T1Vehicles\'])\n    print(""N\xc2\xb0 of V2 vehicles: "", instances[\'T2Vehicles\'], ""\\n"")\n    print(instances[\'df\'])\n\n\ndef init():\n    """""" Validates filePath, loads instancesDf randomly from a file in ""data/"",\n    finally loads current instances settings from \'config.txt\' (in ""config/"") """"""\n    global instancesDf,instancesSettings\n    initParameters()\n    instancesDf=caricaDataframe()\n    instancesSettings = loadSettings(instancesSettingsFile,instancesFileType)\n\ninit()\n'"
src/solver.py,0,"b'from instances import *\nimport pulp as plp\nimport sys, os\n\nproblemSavedPath = path+\'/problems/\'\n\ndef makeStandardStructures(instances=None):\n    """""" Generates the data structures needed by PuLP for the instances actually in use """"""\n    if instances is None:\n        if not actualInstances in globals():\n            print (""No instances currently generated"")\n            return\n        else:\n            instances = actualInstances\n    global vehicles, costs, routes\n    vehicles = [i+1 for i in range(instances[\'vehicles\'])] #genero lista di veicoli pari al num di veicoli disponibili per l\'istanza\n    costs = [instances[\'V1_cost\'],instances[\'V2_cost\']]\n    #vehiclesCapacities = {i: (instances[\'capacity\'],instances[\'costoV1\']) if i<=instances[\'T1Vehicles\'] else (instances[\'capacity\']/2,instances[\'costoV2\']) for i in vehicles} #dizionario delle capacit\xc3\xa0, i primi ""instances[\'T1Vehicles\']"" elementi avranno capacit\xc3\xa0 e costo pari a quelli del veicolo grande, gli altri uguale a quelli del veicolo piccolo\n    routes = [(i,j) for i in range(instances[\'clients\']+1) for j in range(instances[\'clients\']+1)] #lista di coppie indicanti tutte le strade possibili (da ogni nodo i a ogni nodo j)\n\ndef setSolverOptions(problem=None, options=None):\n    """""" Sets the solver to be used and its own settings to solve the HCVRP current problem """"""\n\n    def getCorrectedValues():\n        """""" Checks the variables values are actually correct.\n        If they aren\'t, they will be set to default values (solver:\'CBC\', maxTime:900, utilizzo di cuts: \'False\') """"""\n        stdSolver = ""CBC""\n        stdMaxTime= 900\n        stdRelax=False\n        stdGLPKRelaxMethod=""cuts""\n        stdCBCRelaxMethod=""mir""\n        allowableSolvers=[""cbc"",""glpk""]\n        allowableGLPKRelaxMethods = [""cuts"",""gomory"",""mir"",""cover"",""clique""]\n\n        try: #checks solver name has allowed value\n            if str(options[""solver""]).lower() not in allowableSolvers: #controllo che il solver in input sia CBC o GLPK\n                options[""solver""]=stdSolver\n        except KeyError:\n            options[""solver""] = stdSolver\n\n        try: #checks maxTime has allowed value\n            options[""maxTime""]=round(options[""maxTime""])\n            if options[""maxTime""]<=0:\n                options[""maxTime""] = stdMaxTime\n        except TypeError:\n            options[""maxTime""] = stdMaxTime\n        except KeyError:\n            options[""maxTime""] = stdMaxTime\n\n        try: #checks relax and relaxMethod have allowed values\n            if str(options[""relax""]).upper() in [\'TRUE\',1]:\n                options[""relax""] = True\n            else:\n                options[""relax""] = stdRelax\n            if options[""relax""]:\n                if options[""solver""]==""GLPK"":\n                    try:\n                        if type(options[""relaxMethods""]) is str:\n                            options[""relaxMethods""]=options[""relaxMethods""].split(\',\')\n                        options[""relaxMethods""]=[str(method).lower().strip() for method in options[""relaxMethods""] if str(method).lower().strip() in allowableGLPKRelaxMethods]\n                        if len(options[""relaxMethods""]) == 0:\n                            options[""relaxMethods""] = stdGLPKRelaxMethod\n                    except KeyError:\n                        options[""relaxMethods""] = stdGLPKRelaxMethod\n                else:\n                    try:\n                        options[""relaxMethods""]=[method+\'_cuts\' for method in options[""relaxMethods""] if method in allowableCBCRelaxMethods]\n                        if len(options[""relaxMethods""]) == 0:\n                            options[""relaxMethods""] = stdCBCRelaxMethod\n                    except KeyError:\n                        options[""relaxMethods""] = stdCBCRelaxMethod\n\n        except KeyError:\n            options[""relax""]=stdRelax\n\n        return options\n\n\n\n    if problem is None:\n        #if no problem is actually instantiated, generates a new one and sets myProblem to the currently instantiate problem\n        if not \'myProblem\' in globals():\n            print (""No problem actually generated"")\n            return\n        else:\n            problem=myProblem\n    global solverSettings\n    if options is None:\n        if not \'solverSettings\' in globals():\n            options = getCorrectedValues() #if no values for solverSettings, the default ones are used\n            solverSettings = options\n        else:\n            options = solverSettings\n    else:\n        options = getCorrectedValues()\n        solverSettings = options  #update solverSettings with respect to the last execution\n\n    solver = options[\'solver\']\n    maxTime = options[\'maxTime\']\n    relax = options[\'relax\']\n\n    if solver == \'GLPK\':\n        settings = [\'--tmlim\', str(maxTime)]\n        if relax:\n            for relaxMethod in options[\'relaxMethods\']:\n                settings.append(\'--\'+str(relaxMethod))\n        problem.setSolver(plp.GLPK(msg=1, options = settings))#  sets GLPK and its parameters as solver\n    else:\n        problem.setSolver(plp.solvers.PULP_CBC_CMD(msg=1, maxSeconds=maxTime)) #sets CBC and its own parameters\n\n    return problem\n\n\ndef instantiateProblem(instances=None,solverOptions=None):\n    """""" Defines the current HCVRP problem to be solved and its own constraints in PuLP.\n    _param_: solverOptions is a dict containing the solver settings """"""\n\n    if not ""myProblem"" in globals() or not ""actualInstances"" in globals() or not instances is None:\n        global myProblem, actualInstances\n        #se le istanze su cui definire e risolvere il problema sono diverse dalle ultime gi\xc3\xa0 definite:\n        #1) assegno ad actualInstances il valore delle istanze in input\n        #2) quindi rigenero il problema e le strutture utili per generarlo\n        actualInstances = instances\n        makeStandardStructures(instances)\n        myProblem = plp.LpProblem(""HCVRP"",plp.LpMinimize) #dichiarazione della funzione obiettivo da minimizzare.\n\n        # dichiarazione delle decision variables e dei vincoli del modello...\n\n        #supply_Pulp corrisponde agli y_ij_k(quindi ai beni da trasportare da i a j) per ogni nodo i e j\n        supply_Pulp = [plp.LpVariable.dicts(""supply grande"" if k==0 else ""supply picc"",(range(instances[\'clients\']+1),range(instances[\'clients\']+1)),lowBound=0,upBound=instances[\'capacity\']+instances[\'capacity\']/2) for k in range(2)]\n        for supply in supply_Pulp:\n            for i in supply.keys():\n                supply[i][i]=0 #setto a 0 le merci da ""portare"" da un nodo a se stesso\n\n        #route_Pulp corrisponde agli x_ij_k per ogni nodo i e j, per ogni veicolo k\n        #NB: dichiarando lowBound=0 soddisfiamo il vincolo 9!!!\n        route_Pulp = [plp.LpVariable.dicts(""routes veicolo grande"" if k==0 else ""routes veicolo piccolo"",(range(instances[\'clients\']+1),range(instances[\'clients\']+1)),lowBound=0,upBound=instances[\'vehicles\'],cat=\'Integer\') for k in range(2)]\n        for route in route_Pulp:\n            for i in route.keys():\n                route[i][i]=0 #setto a 0 i cammini da un nodo a se stesso\n\n        #demand_Pulp corrisponde ai b_i_k(quindi indica il n\xc2\xb0 di beni da assegnare ad i dal veicolo di tipo k),\n        # per ogni nodo i.\n        #NB: dichiarando lowBound=0 soddisfiamo il vincolo 8!!\n        demand_Pulp = [plp.LpVariable.dicts(""demand grande"" if k==0 else ""demand piccolo"",(range(instances[\'clients\']+1)),lowBound=0,upBound=instances[\'capacity\'] if k==0 else instances[\'capacity\']/2) for k in range(2)]\n        for demand in demand_Pulp:\n            demand[0]=0 #setto a 0 la demand del depot\n\n\n        #vincolo 1\n        for k in range(2):\n            for j in range(1,instances[\'clients\']+1):\n                myProblem += plp.lpSum([route_Pulp[k][i][j] for i in range(instances[\'clients\']+1)]) <= 1\n\n        #vincolo 2\n        for k in range(2):\n            for j in range(1,instances[\'clients\']+1):\n                myProblem += plp.lpSum([route_Pulp[k][i][j] for i in range(instances[\'clients\']+1)]) - plp.lpSum([route_Pulp[k][j][l] for l in range(instances[\'clients\']+1)]) == 0\n\n        #vincolo 3\n        myProblem += plp.lpSum([route_Pulp[k][0][j] for j in range(1,instances[\'clients\']+1)])<=instances[\'T1Vehicles\'] if k==0 else plp.lpSum([route_Pulp[k][0][j] for j in range(1,instances[\'clients\']+1)])<=instances[\'T2Vehicles\'] , ""vincolo 3""\n\n        #vincolo 4\n        for i in range(instances[\'clients\']+1):\n            myProblem += plp.lpSum([demand_Pulp[k][i] for k in range(2)])== instances[\'df\'][\'Demand\'][i], ""vincolo 4, client %s""%i\n\n        #vincolo 5\n        for k in range(2):\n            for j in range(1,instances[\'clients\']+1):\n                myProblem += plp.lpSum([supply_Pulp[k][i][j] for i in range(instances[\'clients\']+1)]) - plp.lpSum([supply_Pulp[k][j][l] for l in range(instances[\'clients\']+1)]) == demand_Pulp[k][j]\n\n        #vincolo 6\n        for (i,j) in routes:\n            for k in range(2):\n                myProblem += supply_Pulp[k][i][j] <= route_Pulp[k][i][j]*instances[\'capacity\'] if k==0 else supply_Pulp[k][i][j] <= route_Pulp[k][i][j]*instances[\'capacity\']/2, ""vincolo 6, arco %s %s, veicolo %s"" %(i,j,k)\n\n        #funzione obiettivo\n        myProblem+=plp.lpSum([route_Pulp[k][i][j]*instances[\'distances\'][i][j]*costs[k] for (i,j) in routes for k in range(2)]), ""objective function""\n\n\n    #infine aggiorno le impostazioni del solver per la risoluzione del problema\n    if solverOptions is None:\n        setSolverOptions(myProblem) #se solverOptions \xc3\xa8 Null, allora utilizzo come impostazioni\n                                    #le impostazioni attualmente salvate (come variabile global ""solverSettings"")\n    else:\n        setSolverOptions(myProblem,solverOptions) #altrimenti uso quelle in input\n    return myProblem\n\n\ndef saveProblem(fileName, problem):\n    """""" saves the problem in input on file(fileName in input; in directory problems/) """"""\n    fileName=problemSavedPath+fileName\n    if os.path.isfile(fileName):\n        print(""Cannot save the problem using the name chosen. Please use a different name."")\n        return False\n    tmpFile = open(fileName, \'wb\')\n    pickle.dump(problem, tmpFile, protocol=3)\n    tmpFile.close()\n    print (""Problem correctly saved!"")\n\n\ndef loadProblem(fileName):\n    """""" loads the problem from file(fileName in input; in directory problems/) """"""\n    #carica istanze dal file in input, verificando che esista e che il contenuto sia corretto e completo\n    if not os.path.isfile(problemSavedPath+fileName):\n        if not os.path.isfile(fileName):\n            print (""There are no existing files with the name you\'ve inserted. Please be sure you\'ve written""\n               "" it correctly."")\n            return False\n    else:\n        fileName = problemSavedPath+fileName\n\n    try:\n        tmpFile = open(fileName, \'rb\')\n        problem = pickle.load(tmpFile)\n        tmpFile.close()\n        return problem\n    except:\n        print(""It\'s not possible to load the problem from the file. The content is different from the expected one."")\n        return False\n#reload object from file\n\n\ndef main(solverConfigFile=solverSettingsFile):\n    try:\n        instancesFile = sys.argv[1]\n    except IndexError:\n        instancesFile = instancesSettingsFile\n    try:\n        savingPath = sys.argv[2]\n    except IndexError:\n        savingPath = \'\'\n\n    # Genera le istanze ""standard"" prendendo le impostazioni nel file di configurazione ""config.txt"".\n    # Quindi ""genera e risolve il problema per tali istanze, utilizzando come parametri per il solver\n    # i valori contenuti nel file di configurazione ""solverconf.txt"".\n    global actualInstances, solverSettings\n    tmp=getInstances(instancesFile)\n    actualInstances = tmp[0]\n    alreadyGenerated = tmp[1]\n    if actualInstances is False:\n        print(\'Error generating/loading the instances. Please try again and be sure to use all settings properly in the configuration file.\')\n        return\n\n    printInstancesValues()\n    print(""\\n\\n**************************************\\nLoading the settings for the solver ..."")\n    solverSettings=loadSettings(solverConfigFile,solverFileType)\n    if solverSettings is False:\n        solverSettings={\'solver\':\'CBC\',\'maxTime\':900,\'relax\':False}\n        print(\'Error loading the solver settings. They have been automatically set to the standard values:\\n\',solverSettings)\n    else:\n        print(""\\nSolver settings correctly loaded."")\n    print(""\\nDefining the problem for the current instances..."")\n\n    instantiateProblem(actualInstances,solverSettings)\n    solver = solverSettings[\'solver\']\n    relax = solverSettings[\'relax\']\n    print(""Problem correctly defined, having. It\'s time to solve it, using solver: "", solver,\' and relaxing the bound using method: \' + str(solverSettings[\'relaxMethods\']) if solverSettings[\'relax\'] else \', not relaxing the bound\')\n\n    start=time.time()\n    myProblem.solve()\n    solutionTime = time.time()-start\n    status = plp.LpStatus[myProblem.status]\n    obj = plp.value(myProblem.objective)\n    print(""\\n Solution ended with the following results. \\n""\n                  +""Tempo utilizzato per la risoluzione: "", solutionTime, ""\\nStatus: "", status,\n                    ""; valore funzione obiettivo: "", obj, ""\\n\\n"")\n    if savingPath!=\'\':\n        while str(savingPath).strip()==\'\':\n            savingPath=input(""Please insert a name for the file to save."")\n        if alreadyGenerated==0:\n            print(\'Saving the current instances...\')\n            while saveInstances(savingPath+\'.dat\') is False:\n                savingPath=input("""")\n        print(\'Saving the current problem...\')\n        while saveProblem(savingPath+\'.prob\',myProblem) is False:\n            savingPath=input("""")\n\n\nmain()\n'"
