file_path,api_count,code
Aula01/demo.py,2,"b""import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import accuracy_score\n\nfrom argparse import ArgumentParser\n\nparser = ArgumentParser()\nparser.add_argument('-i', '--input', help='Arquivo de entrada', required=True)\nparser.add_argument('-k', '--kneighbors', help='Numero de vizinhos', type=int, default=1)\nparser.add_argument('-p', '--plot', help='Se n\xc3\xa3o deve plotar os graficos', action='store_false')\n\nargs = parser.parse_args()\n\ndf = pd.read_csv(args.input)\n\nX_train, X_test, y_train, y_test = train_test_split(df[['x0', 'x1']], df['y'], test_size = 0.2)\n\nclf = KNeighborsClassifier(n_neighbors=args.kneighbors)\nclf.fit(X_train, y_train)\ny_pred = clf.predict(X_test)\n\nprint(f'Acuracia: {accuracy_score(y_test, y_pred)}')\n\nif not args.plot:\n    exit(0)\n\nfig, ax = plt.subplots(1,3,figsize=(18,6))\n\nax[0].scatter(X_train.iloc[:,0], X_train.iloc[:,1], c=y_train, cmap=plt.cm.Spectral)\nax[0].scatter(X_test.iloc[:,0], X_test.iloc[:,1], marker = 'x', s=100)\nax[0].set_xlabel('Atributo 1')\nax[0].set_ylabel('Atributo 2')\nax[0].set_title('Exemplos de teste')\n\nax[1].scatter(X_train.iloc[:,0], X_train.iloc[:,1], c=y_train, cmap=plt.cm.Spectral)\nax[1].scatter(X_test.iloc[:,0], X_test.iloc[:,1], c=y_pred, marker = 'v', s=100, cmap=plt.cm.Spectral)\nax[1].set_xlabel('Atributo 1')\nax[1].set_ylabel('Atributo 2')\nax[1].set_title('Predi\xc3\xa7\xc3\xb5es')\n\n\nx1_min, x1_max = df.iloc[:, 0].min() - 1, df.iloc[:, 0].max() + 1\nx2_min, x2_max = df.iloc[:, 1].min() - 1, df.iloc[:, 1].max() + 1\n\nX1, X2 = np.meshgrid(np.arange(x1_min, x1_max, 0.1), np.arange(x2_min, x2_max, 0.1))\n\nZ = clf.predict(np.c_[X1.ravel(), X2.ravel()])\nZ = Z.reshape(X1.shape)\n    \nax[2].contourf(X1, X2, Z, cmap=plt.cm.Spectral, alpha=0.4)\nax[2].scatter(X_train.iloc[:, 0], X_train.iloc[:, 1], c=y_train, s=40, cmap=plt.cm.Spectral)\nax[2].scatter(X_test.iloc[:, 0], X_test.iloc[:, 1], c=y_test, s=40, marker='v', cmap=plt.cm.Spectral)\nax[2].set_xlabel('Atributo 1')\nax[2].set_ylabel('Atributo 2')\nax[2].set_title('Limites de decis\xc3\xa3o')\n\nplt.show()\n"""
Aula01/knn.py,0,"b'import random\nimport math\nfrom collections import Counter\n\ndef load_data(filename):\n    """"""\n    Carrega os dados de um arquivo passado como parametro\n    """"""\n\n    with open(filename) as f:\n        content = f.readlines()\n    content = [x.strip().split(\',\')for x in content] \n\n    X = []\n    y = []\n\n    for c in content:\n        c = [float(ci) for ci in c]\n        X.append(c[:-1])\n        y.append(c[-1])\n\n    return X, y\n\ndef train_test_split(X, y):\n    """"""\n    Divide os dados entre conjunto de treino e teste (valida\xc3\xa7\xc3\xa3o)\n    """"""\n    all_indexes = list(range(len(X)))\n    train_idx = random.sample(all_indexes, int(0.2 * len(X)))\n    test_idx = [i for i in all_indexes if i not in train_idx]\n\n    X_train = [X[i] for i in train_idx]\n    y_train = [y[i] for i in train_idx]\n    X_test = [X[i] for i in test_idx]\n    y_test = [y[i] for i in test_idx]\n\n    return X_train, y_train, X_test, y_test\n\ndef accuracy(y_test, y_pred):\n    """"""\n    Dadas as predi\xc3\xa7\xc3\xb5es e as respostas esperadas calcula a acur\xc3\xa1cia\n    """"""\n    count = 0\n    for y_test_i, y_pred_i in zip(y_test, y_pred):\n        if y_test_i == y_pred_i:\n            count += 1\n    \n    return count / len(y_test)\n\ndef argsort(vector):\n    """"""\n    Retorna os indices que iria ordenar o vetor\n    (Exemplo: Input [4,1,5,2] -> Retorno [1,3,0,2])\n    """"""\n    return [i for (v, i) in sorted((v, i) for (i, v) in enumerate(vector))]\n\ndef euclidian_distance(point_a, point_b):\n    """"""\n    Calcula a distancia euclidiana entre dois pontos\n    """"""\n    dist = 0\n    for i in range(len(point_a)):\n        dist += (point_a[i] - point_b[i]) ** 2\n\n    dist = math.sqrt(dist)\n    return dist    \n\n\ndef manhattan_distance(point_a, point_b):\n    """"""\n    Calcula a distancia manhattan entre dois pontos\n    """"""\n    dist = 0\n    for i in range(len(point_a)):\n        dist += abs(point_a[i] - point_b[i])\n    return dist\n\ndef knn(X_train, y_train, X_test, k=1, dist_metric=\'euclidian\'):\n    y_pred = []\n    \n    # TODO: Implementar o algoritmo knn\n    # Dicas: A fun\xc3\xa7\xc3\xa3o argsort e a classe Counter ser\xc3\xa3o \xc3\xbateis\n\n    return y_pred\n\nif __name__ == \'__main__\':\n    \n    # Carregando os dados\n    X, y = load_data(\'datasets/linear_hard.data\')\n\n    # Separando no nosso conjunto de valida\xc3\xa7\xc3\xa3o\n    X_train, y_train, X_test, y_test = train_test_split(X, y)\n    \n    # TODO: Chamar a fun\xc3\xa7\xc3\xa3o knn e salvar o seu retorno na variavel y_pred\n    y_pred = None\n\n    #TODO: Verificar a acuracia do modelo passando os valores reais (y_test)\n    # e os valores preditos (y_pred)\n    acc = None\n\n    print(f\'Acuracia: {acc}\')\n\n    #TODO: Exercicio extra - Testar varios valores de k e ver qual funciona melhor\n    # salvar os resulatados para cada k em um vetor e imprimir todas as acuracias obtidas\n    # Dica: Pesquisar sobre grid search\n\n'"
