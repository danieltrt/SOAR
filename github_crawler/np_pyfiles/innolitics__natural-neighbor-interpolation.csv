file_path,api_count,code
setup.py,0,"b'import sys\nfrom distutils.core import setup, Extension\n\nif __name__ == \'__main__\':\n    if ""--force"" in sys.argv:\n        run_build = True\n        sys.argv.remove(\'--force\')\n    else:\n        non_build_actions = [\'--help-commands\', \'egg_info\', \'clean\', \'--version\']\n        if \'--help\' in sys.argv[1:] or sys.argv[1] in non_build_actions:\n            run_build = False\n        else:\n            run_build = True\n\n    metadata = dict(\n        name=\'naturalneighbor\',\n        version=\'0.2.1\',\n        description=\'Fast, discrete natural neighbor interpolation in 3D on a CPU.\',\n        long_description=open(\'README.rst\', \'r\').read(),\n        author=\'Reece Stevens\',\n        author_email=\'rstevens@innolitics.com\',\n        license=\'MIT\',\n        classifiers=[\n            \'Development Status :: 4 - Beta\',\n            \'Intended Audience :: Developers\',\n            \'Intended Audience :: Science/Research\',\n            \'License :: OSI Approved :: MIT License\',\n            \'Programming Language :: Python\',\n            \'Programming Language :: Python :: 3\',\n            \'Programming Language :: Python :: 3.4\',\n            \'Programming Language :: Python :: 3.5\',\n            \'Programming Language :: Python :: 3.6\',\n            \'Programming Language :: Python :: Implementation :: CPython\',\n            \'Topic :: Scientific/Engineering\',\n            \'Topic :: Software Development\',\n        ],\n        keywords=\'interpolation scipy griddata numpy sibson\',\n        install_requires=[\n            \'numpy>=1.13\',\n        ],\n        url=\'https://github.com/innolitics/natural-neighbor-interpolation\',\n        packages=[\'naturalneighbor\'],\n    )\n\n    if run_build:\n        import numpy.distutils.misc_util\n\n        module = Extension(\n            \'cnaturalneighbor\',\n            include_dirs=numpy.distutils.misc_util.get_numpy_include_dirs(),\n            library_dirs=[\'/usr/local/lib\'],\n            extra_compile_args=[\'--std=c++11\', \'-O3\'],\n            sources=[\n                \'naturalneighbor/cnaturalneighbor.cpp\',\n            ],\n        )\n\n        metadata[\'ext_modules\'] = [module]\n\n    setup(**metadata)\n'"
demo/demo.py,14,"b'\'\'\'\nComparison of natural neighbor and linear barycentric interpolation.\n\'\'\'\nimport numpy as np\nimport scipy.interpolate\nimport matplotlib as mpl\nmpl.use(\'Agg\')  # so it can run on Travis without a display\nimport matplotlib.pyplot as plt\n\nimport naturalneighbor\n\n\ndef error_str(errors):\n    numerical_error = errors[~np.isnan(errors)]\n    mean_err = np.mean(numerical_error)\n    std_err = np.std(numerical_error)\n    max_err = np.max(numerical_error)\n    return ""(Mean={:.2f}, Std={:.2f} Max={:.2f})"".format(mean_err, std_err, max_err)\n\n\ndef compare_interp_for_func(func, func_as_string, image_name):\n    coord_max = 60\n    xmax = coord_max\n    ymax = coord_max\n    zmax = coord_max\n    final_shape = (xmax, ymax, zmax)\n    num_known_points = 100\n\n    known_points = np.round(np.random.rand(num_known_points, 3) * np.min([xmax, ymax, zmax]))\n\n    grid_ranges = [\n        [0, xmax, 1],\n        [0, ymax, 1],\n        [0, zmax, 1],\n    ]\n\n    grid = np.mgrid[0:xmax:1, 0:ymax:1, 0:zmax:1]\n\n    known_values = np.array([func(*point) for point in known_points], dtype=np.float64)\n    true_values = np.reshape([func(x, y, z) for x, y, z in zip(*grid)], final_shape)\n\n    linear_interp = scipy.interpolate.griddata(known_points, known_values, tuple(grid), method=\'linear\')\n\n    nn_interp = naturalneighbor.griddata(known_points, known_values, grid_ranges)\n    nn_interp[np.isnan(linear_interp)] = float(\'nan\')\n\n    nn_interp_slice = nn_interp[:, :, 20]\n    linear_interp_slice = linear_interp[:, :, 20]\n    true_values_slice = true_values[:, :, 20]\n\n    nn_interp_err = np.abs(nn_interp_slice - true_values_slice)\n    linear_interp_err = np.abs(linear_interp_slice - true_values_slice)\n\n    fig = plt.figure(figsize=(16, 10))\n\n    ax1 = fig.add_subplot(2, 3, 1)\n    ax1.imshow(true_values_slice)\n    ax1.set_title(""True Values\\n{}"".format(func_as_string))\n\n    ax2 = fig.add_subplot(2, 3, 2)\n    ax2.imshow(nn_interp_err)\n    nn_error_str = error_str(nn_interp_err)\n    ax2.set_title(""Natural Neighbor Abs Error\\n{}"".format(nn_error_str))\n\n    ax3 = fig.add_subplot(2, 3, 3)\n    ax3.imshow(linear_interp_err)\n    linear_error_str = error_str(linear_interp_err)\n    ax3.set_title(""Linear Barycentric Abs Error\\n{}"".format(linear_error_str))\n\n    ax5 = fig.add_subplot(2, 3, 5)\n    ax5.imshow(nn_interp_slice)\n    ax5.set_title(""Natural Neighbor Values"")\n\n    ax6 = fig.add_subplot(2, 3, 6)\n    ax6.imshow(linear_interp_slice)\n    ax6.set_title(""Linear Barycentric Values"")\n\n    plt.savefig(image_name, dpi=100)\n\n\nif __name__ == \'__main__\':\n    np.random.seed(100)\n\n    compare_interp_for_func(\n        (lambda x, y, z: np.sin(y / 10) + np.sin(x / 10)),\n        \'sin(y/10) + sin(x/10)\',\n        \'sin_sin_comparison.png\',\n    )\n\n    compare_interp_for_func(\n        (lambda x, y, z: x + np.sin(x / 10) / 10),\n        \'x + sin(x/10)/10\',\n        \'linear_comparison.png\',\n    )\n'"
naturalneighbor/__init__.py,0,"b""from .naturalneighbor import griddata\n\n__all__ = [\n    'griddata',\n]\n"""
naturalneighbor/naturalneighbor.py,17,"b'import numpy as np\n\nimport cnaturalneighbor\n\n\ndef griddata(known_points, known_values, interp_ranges):\n    if known_points.ndim != 2:\n        raise ValueError(""known_points must be a NxD array with N>0"")\n\n    if known_values.ndim != 1:\n        raise ValueError(""known_values must be a 1D array"")\n\n    num_dimensions = known_points.shape[1]\n\n    if num_dimensions != 3:\n        raise NotImplementedError(""Currently only support D=3"")\n\n    num_known_points = known_points.shape[0]\n    num_known_values = known_values.shape[0]\n\n    if num_known_points != num_known_values:\n        raise ValueError(""Number of known_points != number of known_values"")\n\n    interp_ranges_arr = np.array(interp_ranges)\n\n    if interp_ranges_arr.shape != (num_dimensions, 3):\n        raise ValueError(""Invalid interp_ranges: should be Dx3"")\n\n    starts = np.real(interp_ranges_arr[:, 0])\n    stops = np.real(interp_ranges_arr[:, 1])\n    ranges = stops - starts\n    steps = interp_ranges_arr[:, 2].astype(np.complex)\n\n    real_steps = np.imag(steps) == 0\n    imag_steps = np.imag(steps) != 0\n\n    if np.any(steps[real_steps] <= 0):\n        raise ValueError(""Invalid interp_ranges: real step <= 0"")\n\n    if np.any(steps[imag_steps] == 0):\n        raise ValueError(""Invalid interp_ranges: imag step == 0"")\n\n    if np.any(ranges <= 0):\n        raise ValueError(""Invalid interp_ranges: start < stop"")\n\n    # mimick the somewhat complex behavior of np.mgrid, since usually scipy\n    # user\'s will be using mgrid along with griddata, and we want to make it\n    # easy to switch over\n    output_shape = np.empty(num_dimensions, dtype=np.double)\n    step_sizes = np.empty(num_dimensions, dtype=np.double)\n    for i, (start, stop, step) in enumerate(interp_ranges):\n        temp_grid = np.mgrid[start:stop:step]\n        output_shape[i] = len(temp_grid)\n\n        if output_shape[i] > 1:\n            step_sizes[i] = (temp_grid[-1] - temp_grid[0]) / (output_shape[i] - 1)\n        else:\n            step_sizes[i] = 1\n\n    interp_values_shape = np.floor(output_shape).astype(np.int)\n    interp_values = np.zeros(interp_values_shape, dtype=np.double)\n\n    known_points_ijk = _xyz_to_ijk(known_points, starts, step_sizes)\n    known_points_ijk = np.ascontiguousarray(known_points_ijk, dtype=np.double)\n\n    known_values = np.ascontiguousarray(known_values, dtype=np.double)\n\n    cnaturalneighbor.griddata(\n        known_points_ijk,\n        known_values,\n        interp_values,\n    )\n\n    return interp_values\n\n\ndef _xyz_to_ijk(points_xyz, starts, steps):\n    return (points_xyz - starts) / steps\n'"
tests/test_api.py,3,"b'import scipy.interpolate\nimport numpy as np\nimport pytest\n\nimport naturalneighbor\n\n\n@pytest.mark.parametrize(""grid_ranges"", [\n    [[0, 4, 0.6], [-3, 3, 1.0], [0, 1, 3]],\n    [[0, 2, 1], [0, 2, 1j], [0, 2, 2j]],\n    [[0, 2, 1 + 1j], [0, 2, -10j], [0, 2, 2j]],\n    [[0, 2, 1 + 1j], [0, 2, -0.9j], [0, 2, 2.1j]],\n])\ndef test_output_size_matches_scipy(grid_ranges):\n    points = np.random.rand(10, 3)\n    values = np.random.rand(10)\n\n    mesh_grids = tuple(np.mgrid[\n        grid_ranges[0][0]:grid_ranges[0][1]:grid_ranges[0][2],\n        grid_ranges[1][0]:grid_ranges[1][1]:grid_ranges[1][2],\n        grid_ranges[2][0]:grid_ranges[2][1]:grid_ranges[2][2],\n    ])\n\n    scipy_result = scipy.interpolate.griddata(points, values, mesh_grids)\n    nn_result = naturalneighbor.griddata(points, values, grid_ranges)\n\n    assert scipy_result.shape == nn_result.shape\n'"
tests/test_cube.py,8,"b'import math\n\nimport numpy as np\nfrom numpy.testing import assert_allclose\nimport pytest\n\nfrom naturalneighbor import griddata\n\n\ndef known_cube(side_length=1):\n    return np.array([\n        [0, 0, 0],\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n        [1, 1, 0],\n        [1, 0, 1],\n        [0, 1, 1],\n        [1, 1, 1],\n    ], dtype=np.float) * side_length\n\n\n@pytest.mark.parametrize(""grid_ranges"", [\n    [[0, 1, 2j], [0, 1, 2j], [0, 1, 2j]],\n    [[0, 1, 4j], [0, 1, 7j], [0, 1, 10j]],\n])\ndef test_interp_on_known_points(grid_ranges):\n    known_points = known_cube()\n    known_values = np.random.rand(8)\n\n    actual_interp_values = griddata(\n        known_points,\n        known_values,\n        grid_ranges,\n    )\n\n    for value, point in zip(known_values, known_points):\n        i, j, k = point.astype(int)\n        # we only want to compare the corners of the cube, so we use the fact\n        # we know i, j, and k will each be 0 or 1 (and a well-placed negative sign)\n        # to grab just the corners\n        assert_allclose(actual_interp_values[-i, -j, -k], value, rtol=0, atol=1e-8)\n\n\ndef test_interp_constant_values():\n    known_points = known_cube()\n    known_values = np.ones((8,)) * 7\n\n    interp_grid_ranges = [\n        [0, 1.5, 0.5],\n        [0, 1.5, 0.5],\n        [0, 1.5, 0.5],\n    ]\n\n    actual_interp_values = griddata(\n        known_points,\n        known_values,\n        interp_grid_ranges,\n    )\n\n    expected_interp_values = np.ones_like(actual_interp_values) * 7\n    assert_allclose(actual_interp_values, expected_interp_values, rtol=0, atol=1e-8)\n\n\ndef test_interp_between_cube_edges():\n    known_points = known_cube()\n    known_values = np.array([0, 0, 0, 1, 0, 1, 1, 1])\n\n    num_points = 1001\n    interp_grid_ranges = [\n        [0, 1, 2j],\n        [0, 1, 2j],\n        [0, 1, num_points * 1j],\n    ]\n\n    actual_interp_values = griddata(\n        known_points,\n        known_values,\n        interp_grid_ranges\n    )\n\n    expected_interp_values = np.linspace(0, 1, num_points)\n\n    # note the tolerance is loose, because discrete natural neighbor does\n    # introduce errors into the interpolated values\n    assert_allclose(actual_interp_values[0, 0, :], expected_interp_values, rtol=0, atol=1e-2)\n\n\n@pytest.mark.parametrize(""num_points"", [10, 11])\ndef test_cube_symmetrical(num_points):\n    known_points = known_cube()\n    known_values = np.array([0, 0, 0, 1, 0, 1, 1, 1])\n    interp_grid_ranges = [\n        [0, 1, num_points * 1j],\n        [0, 1, num_points * 1j],\n        [0, 1, num_points * 1j],\n    ]\n\n    interp_values = griddata(known_points, known_values, interp_grid_ranges)\n\n    middle = int(math.floor(num_points / 2))\n    quadrant_1 = interp_values[0:middle, 0:middle, :]\n    quadrant_2 = interp_values[0:middle, :-middle - 1:-1, :]\n    quadrant_3 = interp_values[:-middle - 1:-1, 0:middle, :]\n    quadrant_4 = interp_values[:-middle - 1:-1, :-middle - 1:-1, :]\n\n    assert_allclose(quadrant_1, quadrant_2, rtol=0, atol=1e-9)\n    assert_allclose(quadrant_1, quadrant_3, rtol=0, atol=1e-9)\n    assert_allclose(quadrant_1, quadrant_4, rtol=0, atol=1e-9)\n'"
tests/test_input_validation.py,12,"b'import pytest\nimport numpy as np\n\nfrom naturalneighbor import griddata\n\n\ndef test_invalid_known_points_shape():\n    num_points = 5\n    num_dimensions = 3\n    bad_third_dim = 2\n    known_points = np.random.rand(num_points, num_dimensions, bad_third_dim)\n    known_values = np.random.rand(num_points)\n    interp_ranges = [\n        [0, 1, 1],\n        [0, 1, 1],\n        [0, 1, 1],\n    ]\n\n    with pytest.raises(ValueError):\n        griddata(known_points, known_values, interp_ranges)\n\n\ndef test_different_num_points_and_values():\n    num_points = 5\n    num_dimensions = 3\n    known_points = np.random.rand(num_points, num_dimensions)\n    known_values = np.random.rand(num_points + 1)\n    interp_ranges = [\n        [0, 1, 1],\n        [0, 1, 1],\n        [0, 1, 1],\n    ]\n\n    with pytest.raises(ValueError):\n        griddata(known_points, known_values, interp_ranges)\n\n\ndef test_zero_step_size():\n    num_points = 5\n    num_dimensions = 3\n    known_points = np.random.rand(num_points, num_dimensions)\n    known_values = np.random.rand(num_points)\n    interp_ranges = [\n        [0, 1, 0],\n        [0, 1, 1],\n        [0, 1, 1],\n    ]\n\n    with pytest.raises(ValueError):\n        griddata(known_points, known_values, interp_ranges)\n\n\ndef test_negative_step_size():\n    num_points = 5\n    num_dimensions = 3\n    known_points = np.random.rand(num_points, num_dimensions)\n    known_values = np.random.rand(num_points)\n    interp_ranges = [\n        [0, 1, -1],\n        [0, 1, 1],\n        [0, 1, 1],\n    ]\n\n    with pytest.raises(ValueError):\n        griddata(known_points, known_values, interp_ranges)\n\n\ndef test_step_before_stop():\n    num_points = 5\n    num_dimensions = 3\n    known_points = np.random.rand(num_points, num_dimensions)\n    known_values = np.random.rand(num_points)\n    interp_ranges = [\n        [2, 1, 1],\n        [0, 1, 1],\n        [0, 1, 1],\n    ]\n\n    with pytest.raises(ValueError):\n        griddata(known_points, known_values, interp_ranges)\n\n\ndef test_zero_length_complex_step():\n    num_points = 5\n    num_dimensions = 3\n    known_points = np.random.rand(num_points, num_dimensions)\n    known_values = np.random.rand(num_points)\n    interp_ranges = [\n        [2, 1, 1],\n        [0, 1, 1],\n        [0, 1, 0j],\n    ]\n\n    with pytest.raises(ValueError):\n        griddata(known_points, known_values, interp_ranges)\n'"
tests/test_output_shape.py,2,"b'import numpy as np\n\nfrom naturalneighbor import griddata\n\n\ndef test_output_shape():\n    num_points = 5\n    num_dimensions = 3\n    known_points = np.random.rand(num_points, num_dimensions)\n    known_values = np.random.rand(num_points)\n    interp_ranges = [\n        [0, 2, 1],\n        [0, 1.5, 0.5],\n        [0, 1, 2],\n    ]\n\n    interp_values = griddata(known_points, known_values, interp_ranges)\n    assert interp_values.shape == (2, 3, 1)\n'"
tests/test_xyz_to_ijk.py,11,"b'import numpy as np\nfrom numpy.testing import assert_allclose\n\nfrom naturalneighbor.naturalneighbor import _xyz_to_ijk\n\n\ndef test_identity_3x3():\n    starts = np.array([0, 0, 0])\n    steps = np.array([1, 1, 1])\n    num_dimensions = 3\n    num_points = 10\n    points_xyz = np.random.rand(num_points, num_dimensions)\n    actual_points_ijk = _xyz_to_ijk(points_xyz, starts, steps)\n    expected_points_ijk = points_xyz\n    assert_allclose(actual_points_ijk, expected_points_ijk, rtol=0, atol=1e-10)\n\n\ndef test_shift_3x3():\n    starts = np.array([0, -1, 2])\n    steps = np.array([1, 1, 1])\n    points_xyz = np.array([[0, 0, 0], [1, 1, 1]])\n    actual_points_ijk = _xyz_to_ijk(points_xyz, starts, steps)\n    expected_points_ijk = np.array([[0, 1, -2], [1, 2, -1]])\n    assert_allclose(actual_points_ijk, expected_points_ijk, rtol=0, atol=1e-10)\n\n\ndef test_shift_and_scale_3x3():\n    starts = np.array([0, -1, 2])\n    steps = np.array([1, 0.5, 0.125])\n    points_xyz = np.array([[0, 0, 0], [1, 1, 1]])\n    actual_points_ijk = _xyz_to_ijk(points_xyz, starts, steps)\n    expected_points_ijk = np.array([[0, 2, -16], [1, 4, -8]])\n    assert_allclose(actual_points_ijk, expected_points_ijk, rtol=0, atol=1e-10)\n'"
