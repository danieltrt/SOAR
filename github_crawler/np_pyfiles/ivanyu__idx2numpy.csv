file_path,api_count,code
setup.py,0,"b'# -*- coding: utf-8 -*-\n#!/usr/bin/env python\n""""""\nA Python package which provides tools to convert files from IDX format\n(described at http://yann.lecun.com/exdb/mnist/) into numpy.ndarray.\n""""""\n\nfrom setuptools import setup\nimport os\n\nREADME = open(os.path.join(os.path.dirname(__file__), \'README.md\')).read()\n\n# Allow setup.py to be run from any path.\nos.chdir(os.path.normpath(os.path.join(os.path.abspath(__file__), os.pardir)))\n\nPACKAGE = ""idx2numpy""\nTESTS_PACKAGE = ""idx2numpy.test""\nVERSION_FILE = ""idx2numpy.version""\nNAME = ""idx2numpy""\nDESCRIPTION = (""A Python package which provides tools to convert files ""\n               ""to and from IDX format ""\n               ""(described at http://yann.lecun.com/exdb/mnist/) ""\n               ""into numpy.ndarray."")\nAUTHOR = ""Ivan Yurchenko""\nAUTHOR_EMAIL = ""ivan0yurchenko@gmail.com""\nURL = ""https://github.com/ivanyu/idx2numpy""\n\nexec(open(\'%s/version.py\' % PACKAGE).read())\nVERSION = __version__\n\nMAINTAINER = AUTHOR\nMAINTAINER_EMAIL = AUTHOR_EMAIL\n\nsetup(\n    name=NAME,\n    version=VERSION,\n    description=DESCRIPTION,\n    long_description=README,\n    author=AUTHOR,\n    author_email=AUTHOR_EMAIL,\n    maintainer=MAINTAINER,\n    maintainer_email=MAINTAINER_EMAIL,\n    license=""MIT License"",\n    url=URL,\n    packages = [PACKAGE, TESTS_PACKAGE],\n    classifiers=[\n        ""Development Status :: 5 - Production/Stable"",\n        ""Intended Audience :: Developers"",\n        ""Intended Audience :: Science/Research"",\n        ""License :: OSI Approved :: MIT License"",\n        ""Operating System :: MacOS"",\n        ""Operating System :: Microsoft :: Windows"",\n        ""Operating System :: POSIX"",\n        ""Operating System :: Unix"",\n        ""Programming Language :: Python :: 2.5"",\n        ""Programming Language :: Python :: 2.6"",\n        ""Programming Language :: Python :: 2.7"",\n        ""Programming Language :: Python :: 3.0"",\n        ""Programming Language :: Python :: 3.1"",\n        ""Programming Language :: Python :: 3.2"",\n        ""Programming Language :: Python :: 3.3"",\n        ""Programming Language :: Python :: 3.4"",\n        ""Programming Language :: Python :: 3.5"",\n        ""Programming Language :: Python :: 3.6"",\n        ""Topic :: Software Development :: Libraries :: Python Modules"",\n        ""Topic :: Scientific/Engineering"",\n        ""Topic :: Software Development"",\n    ],\n    zip_safe=False,\n    test_suite=""idx2numpy.test"",\n    keywords=\'mnist numpy\',\n    install_requires=[\n        ""numpy"",\n        ""six""\n    ]\n)\n'"
idx2numpy/FormatError.py,0,"b'# -*- coding: utf-8 -*-\n\nclass FormatError(Exception):\n    """"""\n    Exception of bad IDX file format.\n    """"""\n    pass\n'"
idx2numpy/__init__.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nidx2numpy package provides a tool for converting files from IDX format to\nnumpy.ndarray. You can meet files in IDX format, e.g. when you\'re going\nto read the MNIST database of handwritten digits provided by Yann LeCun at\nhttp://yann.lecun.com/exdb/mnist/\nThe description of IDX format also can be found on this page.\n""""""\n\nfrom __future__ import absolute_import\n\nfrom .converters import convert_from_string\nfrom .converters import convert_from_file\nfrom .converters import convert_to_string\nfrom .converters import convert_to_file\nfrom .FormatError import FormatError\n\nfrom .version import __version__\n\n__all__ = [\'convert_from_string\', \'convert_from_file\', \'FormatError\']\n'"
idx2numpy/converters.py,4,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\nfrom __future__ import with_statement\n\nimport sys\nimport struct\nimport numpy\nimport operator\nimport contextlib\nfrom six import string_types as six_string_types\nfrom six.moves import reduce\n\ntry:\n    from StringIO import StringIO as BytesIO  # for python 2.5\nexcept ImportError:\n    from io import BytesIO\n\nfrom .FormatError import FormatError\n\n# Possible data types.\n\n# Keys are IDX data type codes.\n# Values: (ndarray data type name, name for struct.unpack, size in bytes).\n_DATA_TYPES_IDX = {\n    0x08: (\'ubyte\', \'B\', 1),\n    0x09: (\'byte\', \'b\', 1),\n    0x0B: (\'>i2\', \'h\', 2),\n    0x0C: (\'>i4\', \'i\', 4),\n    0x0D: (\'>f4\', \'f\', 4),\n    0x0E: (\'>f8\', \'d\', 8)\n}\n\n# Keys are ndarray data type name.\n# Values: (IDX data type code, name for struct.pack, size in bytes).\n_DATA_TYPES_NUMPY = {\n    \'uint8\': (0x08, \'B\'),\n    \'int8\': (0x09, \'b\'),\n    \'int16\': (0x0B, \'h\'),\n    \'int32\': (0x0C, \'i\'),\n    \'float32\': (0x0D, \'f\'),\n    \'float64\': (0x0E, \'d\'),\n}\n\n_MAX_IDX_DIMENSIONS = 255\n_MAX_AXIS_LENGTH = pow(2, 32) - 1\n\n\ndef convert_from_file(file):\n    """"""\n    Reads the content of file in IDX format, converts it into numpy.ndarray and\n    returns it.\n    file is a file-like object (with read() method) or a file name.\n    """"""\n    if isinstance(file, six_string_types):\n        with open(file, \'rb\') as f:\n            return _internal_convert(f)\n    else:\n        return _internal_convert(file)\n\n\ndef convert_from_string(idx_string):\n    """"""\n    Converts string which presents file in IDX format into numpy.ndarray and\n    returns it.\n    """"""\n    with contextlib.closing(BytesIO(idx_string)) as sio:\n        return _internal_convert(sio)\n\n\ndef _internal_convert(inp):\n    """"""\n    Converts file in IDX format provided by file-like input into numpy.ndarray\n    and returns it.\n    """"""\n    \'\'\'\n    Converts file in IDX format provided by file-like input into numpy.ndarray\n    and returns it.\n    \'\'\'\n\n    # Read the ""magic number"" - 4 bytes.\n    try:\n        mn = struct.unpack(\'>BBBB\', inp.read(4))\n    except struct.error:\n        raise FormatError(struct.error)\n\n    # First two bytes are always zero, check it.\n    if mn[0] != 0 or mn[1] != 0:\n        msg = (""Incorrect first two bytes of the magic number: "" +\n               ""0x{0:02X} 0x{1:02X}"".format(mn[0], mn[1]))\n        raise FormatError(msg)\n\n    # 3rd byte is the data type code.\n    dtype_code = mn[2]\n    if dtype_code not in _DATA_TYPES_IDX:\n        msg = ""Incorrect data type code: 0x{0:02X}"".format(dtype_code)\n        raise FormatError(msg)\n\n    # 4th byte is the number of dimensions.\n    dims = int(mn[3])\n\n    # See possible data types description.\n    dtype, dtype_s, el_size = _DATA_TYPES_IDX[dtype_code]\n\n    # 4-byte integer for length of each dimension.\n    try:\n        dims_sizes = struct.unpack(\'>\' + \'I\' * dims, inp.read(4 * dims))\n    except struct.error as e:\n        raise FormatError(\'Dims sizes: {0}\'.format(e))\n\n    # Full length of data.\n    full_length = reduce(operator.mul, dims_sizes, 1)\n\n    # Create a numpy array from the data\n    try:\n        result_array = numpy.frombuffer(\n            inp.read(full_length * el_size),\n            dtype=numpy.dtype(dtype)\n        ).reshape(dims_sizes)\n    except ValueError as e:\n        raise FormatError(\'Error creating numpy array: {0}\'.format(e))\n\n    # Check for superfluous data.\n    if len(inp.read(1)) > 0:\n        raise FormatError(\'Superfluous data detected.\')\n\n    return result_array\n\n\ndef convert_to_file(file, ndarr):\n    """"""\n    Writes the contents of the numpy.ndarray ndarr to file in IDX format.\n    file is a file-like object (with write() method) or a file name.\n    """"""\n    if isinstance(file, six_string_types):\n        with open(file, \'wb\') as fp:\n            _internal_write(fp, ndarr)\n    else:\n        _internal_write(file, ndarr)\n\n\ndef convert_to_string(ndarr):\n    """"""\n    Writes the contents of the numpy.ndarray ndarr to bytes in IDX format and\n    returns it.\n    """"""\n    with contextlib.closing(BytesIO()) as bytesio:\n        _internal_write(bytesio, ndarr)\n        return bytesio.getvalue()\n\n\ndef _internal_write(out_stream, arr):\n    """"""\n    Writes numpy.ndarray arr to a file-like object (with write() method) in\n    IDX format.\n    """"""\n\n    if arr.size == 0:\n        raise FormatError(\'Cannot encode empty array.\')\n\n    try:\n        type_byte, struct_lib_type = _DATA_TYPES_NUMPY[str(arr.dtype)]\n    except KeyError:\n        raise FormatError(\'numpy ndarray type not supported by IDX format.\')\n\n    if arr.ndim > _MAX_IDX_DIMENSIONS:\n        raise FormatError(\n            \'IDX format cannot encode array with dimensions > 255\')\n\n    if max(arr.shape) > _MAX_AXIS_LENGTH:\n        raise FormatError(\'IDX format cannot encode array with more than \' +\n                          str(_MAX_AXIS_LENGTH) + \' elements along any axis\')\n\n    # Write magic number\n    out_stream.write(struct.pack(\'BBBB\', 0, 0, type_byte, arr.ndim))\n\n    # Write array dimensions\n    out_stream.write(struct.pack(\'>\' + \'I\' * arr.ndim, *arr.shape))\n\n    # Horrible hack to deal with horrible bug when using struct.pack to encode\n    # unsigned ints in 2.7 and lower, see http://bugs.python.org/issue2263\n    if sys.version_info < (2, 7) and str(arr.dtype) == \'uint8\':\n        arr_as_list = [int(i) for i in arr.reshape(-1)]\n        out_stream.write(struct.pack(\'>\' + struct_lib_type * arr.size,\n                                     *arr_as_list))\n    else:\n        # Write array contents - note that the limit to number of arguments\n        # doesn\'t apply to unrolled arguments\n        out_stream.write(struct.pack(\'>\' + struct_lib_type * arr.size,\n                                     *arr.reshape(-1)))\n'"
idx2numpy/version.py,0,"b'# -*- coding: utf-8 -*-\n\n__version__ = ""1.2.2""\n'"
idx2numpy/test/__init__.py,0,b'# -*- coding: utf-8 -*-\n'
idx2numpy/test/converters_test.py,27,"b""# -*- coding: utf-8 -*-\n\nimport sys\nimport unittest\nimport idx2numpy\nimport contextlib\nimport numpy as np\nimport os\nimport struct\n\ntry:\n    from StringIO import StringIO as BytesIO  # for python 2.5\nexcept ImportError:\n    from io import BytesIO\n\n# unittest in Python 2.6 and lower doesn't have assertSequenceEqual method,\n# so simple alternative is provided.\nif sys.version_info < (2, 7):\n    class TestCaseBase(unittest.TestCase):\n        @staticmethod\n        def _to_list(nd):\n            return [x for x in nd]\n\n        def assertSequenceEqual(self, seq1, seq2):\n            self.assertEquals(list(seq1), list(seq2))\nelse:\n    class TestCaseBase(unittest.TestCase):\n        @staticmethod\n        def _to_list(nd):\n            return [x for x in nd]\n\n\nclass TestConvertFromFile(TestCaseBase):\n    def setUp(self):\n        self.files_dir = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)), 'files')\n\n    def test_empty_file_on_disk(self):\n        file = os.path.join(self.files_dir, 'empty.idx')\n        self.assertRaises(idx2numpy.FormatError,\n                          idx2numpy.convert_from_file, file)\n\n    def test_correct_file_on_disk(self):\n        file = os.path.join(self.files_dir, 'correct.idx')\n        self.assertSequenceEqual(\n            [0x0A, 0x0B, 0x0C],\n            self._to_list(idx2numpy.convert_from_file(file)))\n\n\nclass TestConvertFromString(TestCaseBase):\n    def test_empty_string(self):\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_from_string, b'')\n\n    def test_incorrect_magic_number(self):\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_from_string, b'\\x00\\x00')\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_from_string, b'\\x01\\x00\\x08\\x00')\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_from_string, b'\\x00\\x01\\x08\\x00')\n        # Incorrect type code.\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_from_string, b'\\x00\\x00\\x01\\x00')\n        # Incorrect dimension size.\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_from_string,\n            b'\\x00\\x00\\x08\\x01\\x00\\x00\\x00')\n        # Incorrect data length.\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_from_string,\n            b'\\x00\\x00\\x08\\x01\\x00\\x00\\x00\\x02\\x01')\n        # Superfluous data\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_from_string,\n            b'\\x00\\x00\\x08\\x01\\x00\\x00\\x00\\x02\\x01\\x02\\x03\\x04')\n\n    def test_correct(self):\n        # Unsigned byte.\n        result = idx2numpy.convert_from_string(\n            b'\\x00\\x00\\x08\\x01\\x00\\x00\\x00\\x03' +\n            b'\\x0A' +\n            b'\\x0B' +\n            b'\\xFF')\n        self.assertEqual(np.ndim(result), 1)\n        self.assertEqual(np.shape(result), (3,))\n        self.assertSequenceEqual(\n            self._to_list(result),\n            [0x0A, 0x0B, 0xFF])\n\n        # Signed byte.\n        result = idx2numpy.convert_from_string(\n            b'\\x00\\x00\\x09\\x01\\x00\\x00\\x00\\x04' +\n            b'\\xFE' +\n            b'\\xFF' +\n            b'\\x00' +\n            b'\\xAA')\n        self.assertEqual(np.ndim(result), 1)\n        self.assertEqual(np.shape(result), (4,))\n        self.assertSequenceEqual(\n            self._to_list(result),\n            [-2, -1, 0x00, -86])\n\n        # Short.\n        result = idx2numpy.convert_from_string(\n            b'\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x02' +\n            b'\\xF0\\x05' +\n            b'\\x00\\xFF')\n        self.assertEqual(np.ndim(result), 1)\n        self.assertEqual(np.shape(result), (2,))\n        self.assertSequenceEqual(\n            self._to_list(result),\n            [-4091, 255])\n\n        # Integer.\n        result = idx2numpy.convert_from_string(\n            b'\\x00\\x00\\x0C\\x01\\x00\\x00\\x00\\x03' +\n            b'\\x00\\xFF\\x00\\xFF' +\n            b'\\x80\\x00\\x00\\x00' +\n            b'\\x00\\x00\\x00\\x00')\n        self.assertEqual(np.ndim(result), 1)\n        self.assertEqual(np.shape(result), (3,))\n        self.assertSequenceEqual(\n            self._to_list(result),\n            [0x00FF00FF, -0x80000000, 0x00])\n\n        # Float.\n        # So fat, no tests.\n\n        # Double.\n        result = idx2numpy.convert_from_string(\n            b'\\x00\\x00\\x0E\\x01\\x00\\x00\\x00\\x05' +\n            b'\\x3F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00' +\n            b'\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00' +\n            b'\\xC0\\x00\\x00\\x00\\x00\\x00\\x00\\x00' +\n            b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' +\n            b'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        self.assertEqual(np.ndim(result), 1)\n        self.assertEqual(np.shape(result), (5,))\n        self.assertSequenceEqual(\n            self._to_list(result),\n            [1.0, 2.0, -2.0, 0.0, -0.0])\n\n\nclass TestConvertToString(TestCaseBase):\n    def test_empty_array(self):\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string, np.array([]))\n\n    def test_unsupported_ndarray_formats(self):\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string,\n            np.array([True, False], dtype='bool_'))\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string,\n            np.array([1], dtype='int64'))\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string,\n            np.array([1], dtype='uint16'))\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string,\n            np.array([1], dtype='uint32'))\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string,\n            np.array([1], dtype='uint64'))\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string,\n            np.array([1], dtype='float16'))\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string,\n            np.array([1], dtype='complex64'))\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string,\n            np.array([1], dtype='complex128'))\n\n    def test_very_high_dimensional_ndarray(self):\n        HIGH_DIMENSIONS = 256\n\n        # Generate a high dimensional array containing 1 element\n        high_dim_arr = 1\n        for i in range(HIGH_DIMENSIONS):\n            high_dim_arr = [high_dim_arr]\n\n        self.assertRaises(\n            idx2numpy.FormatError,\n            idx2numpy.convert_to_string, np.array(high_dim_arr))\n\n    def test_correct(self):\n        # Unsigned byte.\n        result = idx2numpy.convert_to_string(\n            np.array([0x0A, 0x0B, 0xFF], dtype='uint8'))\n        self.assertEqual(result,\n                         b'\\x00\\x00\\x08\\x01\\x00\\x00\\x00\\x03' +\n                         b'\\x0A' +\n                         b'\\x0B' +\n                         b'\\xFF')\n\n        # Signed byte.\n        result = idx2numpy.convert_to_string(\n            np.array([-2, -1, 0x00, -86], dtype='int8'))\n        self.assertEqual(result,\n                         b'\\x00\\x00\\x09\\x01\\x00\\x00\\x00\\x04' +\n                         b'\\xFE' +\n                         b'\\xFF' +\n                         b'\\x00' +\n                         b'\\xAA')\n\n        # Short.\n        result = idx2numpy.convert_to_string(\n            np.array([-4091, 255], dtype='int16'))\n        self.assertEqual(result,\n                         b'\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x02' +\n                         b'\\xF0\\x05' +\n                         b'\\x00\\xFF')\n\n        # Integer.\n        result = idx2numpy.convert_to_string(\n            np.array([0x00FF00FF, -0x80000000, 0x00], dtype='int32'))\n        self.assertEqual(result,\n                         b'\\x00\\x00\\x0C\\x01\\x00\\x00\\x00\\x03' +\n                         b'\\x00\\xFF\\x00\\xFF' +\n                         b'\\x80\\x00\\x00\\x00' +\n                         b'\\x00\\x00\\x00\\x00')\n\n        # Float.\n        # No less fat, still no tests.\n\n        # Double.\n        result = idx2numpy.convert_to_string(\n            np.array([1.0, 2.0, -2.0, 0.0, -0.0], dtype='float64'))\n        self.assertEqual(result,\n                         b'\\x00\\x00\\x0E\\x01\\x00\\x00\\x00\\x05' +\n                         b'\\x3F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00' +\n                         b'\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00' +\n                         b'\\xC0\\x00\\x00\\x00\\x00\\x00\\x00\\x00' +\n                         b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' +\n                         b'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n\n        # Large array\n        large_length_bytes = b'\\x00\\x01\\x00\\x00'\n        large_length = struct.unpack('>I', large_length_bytes)[0]\n        result = idx2numpy.convert_to_string(\n            np.zeros(large_length, dtype='uint8'))\n        self.assertEqual(result,\n                         b'\\x00\\x00\\x08\\x01' + large_length_bytes +\n                         b'\\x00' * large_length)\n\n\nclass TestConvertToFile(TestCaseBase):\n    def setUp(self):\n        self._test_output_file = '.test'\n\n        # Unsigned byte.\n        self._ndarr_to_convert = np.array([0x0A, 0x0B, 0xFF], dtype='uint8')\n        self._expected = (b'\\x00\\x00\\x08\\x01\\x00\\x00\\x00\\x03' +\n                          b'\\x0A' +\n                          b'\\x0B' +\n                          b'\\xFF')\n\n    def tearDown(self):\n        try:\n            os.remove(self._test_output_file)\n        except:\n            pass\n\n    def test_correct(self):\n        with contextlib.closing(BytesIO()) as bytesio:\n            idx2numpy.convert_to_file(bytesio, self._ndarr_to_convert)\n            self.assertEqual(bytesio.getvalue(), self._expected)\n\n    def test_correct_with_filename_argument(self):\n        idx2numpy.convert_to_file(self._test_output_file, self._ndarr_to_convert)\n\n        with open(self._test_output_file, 'rb') as fp:\n            read_bytes = fp.read()\n            self.assertEqual(read_bytes, self._expected)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
