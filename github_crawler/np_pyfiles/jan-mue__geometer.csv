file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport io\nimport os\nimport sys\nfrom shutil import rmtree\n\nfrom setuptools import find_packages, setup, Command\n\n# Package meta-data.\nNAME = \'geometer\'\nDESCRIPTION = \'Python geometry package based on projective geometry and numpy.\'\nURL = \'https://github.com/jan-mue/geometer\'\nEMAIL = \'\'\nAUTHOR = \'Jan M\xc3\xbcller\'\nREQUIRES_PYTHON = \'>=3.5.0\'\nVERSION = None\n\n# What packages are required for this module to be executed?\nREQUIRED = [\n    \'numpy>=1.15,<1.20\'\n]\n\n# What packages are optional?\nEXTRAS = {\n    # \'fancy feature\': [\'django\'],\n}\n\n# The rest you shouldn\'t have to touch too much :)\n# ------------------------------------------------\n# Except, perhaps the License and Trove Classifiers!\n# If you do change the License, remember to change the Trove Classifier for that!\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n# Import the README and use it as the long-description.\n# Note: this will only work if \'README.md\' is present in your MANIFEST.in file!\ntry:\n    with io.open(os.path.join(here, \'README.md\'), encoding=\'utf-8\') as f:\n        long_description = \'\\n\' + f.read()\nexcept FileNotFoundError:\n    long_description = DESCRIPTION\n\n# Load the package\'s __version__.py module as a dictionary.\nabout = {}\nif not VERSION:\n    with open(os.path.join(here, NAME, \'__version__.py\')) as f:\n        exec(f.read(), about)\nelse:\n    about[\'__version__\'] = VERSION\n\n\nclass UploadCommand(Command):\n    """"""Support setup.py upload.""""""\n\n    description = \'Build and publish the package.\'\n    user_options = []\n\n    @staticmethod\n    def status(s):\n        """"""Prints things in bold.""""""\n        print(\'\\033[1m{0}\\033[0m\'.format(s))\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        try:\n            self.status(\'Removing previous builds\xe2\x80\xa6\')\n            rmtree(os.path.join(here, \'dist\'))\n        except OSError:\n            pass\n\n        self.status(\'Building Source and Wheel (universal) distribution\xe2\x80\xa6\')\n        os.system(\'{0} setup.py sdist bdist_wheel\'.format(sys.executable))\n\n        self.status(\'Uploading the package to PyPI via Twine\xe2\x80\xa6\')\n        os.system(\'twine upload dist/*\')\n\n        self.status(\'Pushing git tags\xe2\x80\xa6\')\n        os.system(\'git tag v{0}\'.format(about[\'__version__\']))\n        os.system(\'git push --tags\')\n\n        sys.exit()\n\n\n# Where the magic happens:\nsetup(\n    name=NAME,\n    version=about[\'__version__\'],\n    description=DESCRIPTION,\n    long_description=long_description,\n    long_description_content_type=\'text/markdown\',\n    author=AUTHOR,\n    author_email=EMAIL,\n    python_requires=REQUIRES_PYTHON,\n    url=URL,\n    packages=find_packages(exclude=(\'tests\',)),\n    # If your package is a single module, use this instead of \'packages\':\n    # py_modules=[\'mypackage\'],\n\n    # entry_points={\n    #     \'console_scripts\': [\'mycli=mymodule:cli\'],\n    # },\n    install_requires=REQUIRED,\n    extras_require=EXTRAS,\n    include_package_data=True,\n    license=\'MIT\',\n    classifiers=[\n        # Trove classifiers\n        # Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers\n        \'License :: OSI Approved :: MIT License\',\n        \'Programming Language :: Python\',\n        \'Programming Language :: Python :: 3\',\n        \'Programming Language :: Python :: Implementation :: CPython\',\n        \'Programming Language :: Python :: Implementation :: PyPy\'\n    ],\n    # $ setup.py publish support.\n    cmdclass={\n        \'upload\': UploadCommand,\n    },\n)\n'"
docs/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath(\'.\'))\n\n\n# -- Project information -----------------------------------------------------\n\nimport geometer\nimport sys\nimport inspect\nfrom os.path import relpath, dirname\n\nproject = \'geometer\'\ncopyright = \'2019, Jan M\xc3\xbcller\'\nauthor = \'Jan M\xc3\xbcller\'\n\n# The short X.Y version\nversion = geometer.__version__\n# The full version, including alpha/beta/rc tags\nrelease = geometer.__version__\n\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.coverage\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.napoleon\',\n    \'sphinx.ext.intersphinx\',\n    \'sphinx.ext.linkcode\',\n]\n\n# Napoleon settings\nnapoleon_google_docstring = True\nnapoleon_numpy_docstring = True\nnapoleon_include_init_with_doc = False\nnapoleon_include_private_with_doc = False\nnapoleon_include_special_with_doc = True\nnapoleon_use_admonition_for_examples = False\nnapoleon_use_admonition_for_notes = False\nnapoleon_use_admonition_for_references = False\nnapoleon_use_ivar = False\nnapoleon_use_param = False\nnapoleon_use_rtype = True\n\n\n# Links to source code on GitHub\ndef linkcode_resolve(domain, info):\n    if domain != \'py\':\n        return None\n\n    modname = info[\'module\']\n    fullname = info[\'fullname\']\n\n    submod = sys.modules.get(modname)\n    if submod is None:\n        return None\n\n    obj = submod\n    for part in fullname.split(\'.\'):\n        try:\n            obj = getattr(obj, part)\n        except Exception:\n            return None\n\n    try:\n        fn = inspect.getsourcefile(obj)\n    except Exception:\n        fn = None\n    if not fn:\n        return None\n\n    try:\n        source, lineno = inspect.getsourcelines(obj)\n    except Exception:\n        lineno = None\n\n    if lineno:\n        linespec = ""#L%d-L%d"" % (lineno, lineno + len(source) - 1)\n    else:\n        linespec = """"\n\n    fn = relpath(fn, start=dirname(geometer.__file__))\n\n    return ""https://github.com/jan-mue/geometer/blob/v%s/geometer/%s%s"" % (geometer.__version__, fn, linespec)\n\n\n# Looks for objects in external projects\nintersphinx_mapping = {\n    \'numpy\': (\'https://docs.scipy.org/doc/numpy/\', None),\n}\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\']\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = None\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'geometerdoc\'\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'geometer.tex\', \'geometer Documentation\',\n     \'Jan M\xc3\xbcller\', \'manual\'),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'geometer\', \'geometer Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'geometer\', \'geometer Documentation\',\n     author, \'geometer\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n# -- Options for Epub output -------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#\n# epub_identifier = \'\'\n\n# A unique identification for the text.\n#\n# epub_uid = \'\'\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [\'search.html\']\n\n\n# -- Extension configuration -------------------------------------------------\n'"
geometer/__init__.py,0,"b'from .point import Point, Line, Plane, PointCollection, LineCollection, PlaneCollection, join, meet,  I, J, infty, infty_plane\nfrom .curve import Conic, Circle, Quadric, Ellipse, Sphere, Cone, Cylinder, QuadricCollection\nfrom .transformation import Transformation, TransformationCollection, identity, affine_transform, rotation, translation, scaling, reflection\nfrom .operators import crossratio, is_cocircular, is_perpendicular, is_collinear, is_concurrent, is_coplanar, dist, angle, angle_bisectors, harmonic_set\nfrom .shapes import Polytope, Segment, Polyhedron, Polygon, Simplex, Triangle, Rectangle, RegularPolygon, Cuboid, PolygonCollection, SegmentCollection\nfrom .__version__ import __version__\n'"
geometer/__version__.py,0,"b'\nVERSION = (0, 2, 2)\n\n__version__ = ""."".join(map(str, VERSION))\n'"
geometer/base.py,31,"b'from abc import ABC\nfrom itertools import permutations\n\nimport numpy as np\n\nfrom .utils import is_multiple, posify_index, normalize_index, sanitize_index\nfrom .exceptions import TensorComputationError\n\n\nEQ_TOL_REL = 1e-15\nEQ_TOL_ABS = 1e-8\n\n\nclass Tensor:\n    """"""Wrapper class around a numpy array that keeps track of covariant and contravariant indices.\n\n    Covariant indices are the lower indices (subscripts) and contravariant indices are the upper indices (superscripts)\n    of a tensor (see [1]).\n\n    Parameters\n    ----------\n    *args\n        Either a single iterable or multiple coordinate numbers.\n    covariant : :obj:`bool` or :obj:`list` of :obj:`int`, optional\n        If False, all indices are contravariant. If a list of indices indices is supplied, the specified indices of the\n        array will be covariant indices and all others contravariant indices. By default all indices are covariant.\n    tensor_rank : int or None, optional\n        If the object contains multiple tensors, this parameter specifies the rank of the tensors contained in the\n        collection. By default only a single tensor is contained in a Tensor object.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    Attributes\n    ----------\n    array : numpy.ndarray\n        The underlying numpy array.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Ricci_calculus#Upper_and_lower_indices\n\n    """"""\n\n    def __init__(self, *args, covariant=True, tensor_rank=None, **kwargs):\n        if len(args) == 0:\n            raise TypeError(""At least one argument is required."")\n\n        if len(args) == 1:\n            if isinstance(args[0], Tensor):\n                self.array = np.array(args[0].array, **kwargs)\n                self._collection_indices = args[0]._collection_indices\n                self._covariant_indices = args[0]._covariant_indices\n                self._contravariant_indices = args[0]._contravariant_indices\n                return\n            else:\n                self.array = np.array(args[0], **kwargs)\n        else:\n            self.array = np.array(args, **kwargs)\n\n        if tensor_rank is None:\n            tensor_rank = self.rank\n        elif tensor_rank < 0:\n            tensor_rank += self.shape[-1]\n\n        if self.rank < tensor_rank:\n            raise ValueError(""tensor_rank must be smaller than or equal to the number of array dimensions."")\n\n        n_col = self.rank - tensor_rank\n        self._collection_indices = set(range(n_col))\n\n        if covariant is True:\n            self._covariant_indices = set(range(n_col, self.rank))\n        elif covariant is False:\n            self._covariant_indices = set()\n        else:\n            self._covariant_indices = set()\n            for idx in covariant:\n                if not -tensor_rank <= idx < tensor_rank:\n                    raise IndexError(""Index out of range"")\n                idx = sanitize_index(idx)\n                idx = posify_index(tensor_rank, idx)\n                self._covariant_indices.add(n_col + idx)\n\n        self._contravariant_indices = set(range(self.rank)) - self._covariant_indices - self._collection_indices\n\n    def __apply__(self, transformation):\n        ts = self.tensor_shape\n        edges = [(self, transformation.copy()) for _ in range(ts[0])]\n        if ts[1] > 0:\n            inv = transformation.inverse()\n            edges.extend((inv.copy(), self) for _ in range(ts[1]))\n        diagram = TensorDiagram(*edges)\n        result = self.copy()\n        result.array = diagram.calculate().array\n        return result\n\n    @property\n    def shape(self):\n        """""":obj:`tuple` of :obj:`int`: The shape of the underlying numpy array, same as ``self.array.shape``.""""""\n        return self.array.shape\n\n    @property\n    def dtype(self):\n        """"""numpy.dtype: The dtype of the underlying numpy array, same as ``self.array.dtype``.""""""\n        return self.array.dtype\n\n    @property\n    def tensor_shape(self):\n        """""":obj:`tuple` of :obj:`int`: The shape or type of the tensor, the first number is the number of\n        covariant indices, the second the number of contravariant indices.""""""\n        return len(self._covariant_indices), len(self._contravariant_indices)\n\n    @property\n    def rank(self):\n        """"""int: The rank of the Tensor, same as ``self.array.ndim``.""""""\n        return self.array.ndim\n\n    def tensor_product(self, other):\n        """"""Return a new tensor that is the tensor product of this and the other tensor.\n\n        This method will also reorder the indices of the resulting tensor, to ensure that covariant indices are in\n        front of the contravariant indices.\n\n        Parameters\n        ----------\n        other : Tensor\n            The other tensor.\n\n        Returns\n        -------\n        Tensor\n            The tensor product.\n\n        """"""\n        offset = self.rank\n        covariant = list(self._covariant_indices) + [offset + i for i in other._covariant_indices]\n        contravariant = list(self._contravariant_indices) + [offset + i for i in other._contravariant_indices]\n\n        result = np.tensordot(self.array, other.array, 0)\n        result = np.transpose(result, axes=covariant + contravariant)\n        return Tensor(result, covariant=range(len(covariant)), copy=False)\n\n    def transpose(self, perm=None):\n        """"""Permute the indices of the tensor.\n\n        Parameters\n        ----------\n        perm : tuple of int, optional\n            A list of permuted indices or a shorter list representing a permutation in cycle notation.\n            By default, the indices are reversed.\n\n        Returns\n        -------\n        Tensor\n            The tensor with permuted indices.\n\n        """"""\n        if perm is None:\n            perm = reversed(range(self.rank))\n\n        perm = list(perm)\n\n        if len(perm) < self.rank:\n            a = list(range(self.rank))\n            for ind in range(len(perm)):\n                i, j = perm[ind], perm[(ind + 1) % len(perm)]\n                a[i] = j\n            perm = a\n\n        covariant_indices = []\n        contravariant_indices = []\n        collection_indices = []\n        for i, j in enumerate(perm):\n            if j in self._covariant_indices:\n                covariant_indices.append(i)\n            elif j in self._contravariant_indices:\n                contravariant_indices.append(i)\n            elif j in self._collection_indices:\n                collection_indices.append(i)\n\n        result = self.copy()\n        result.array = self.array.transpose(perm)\n        result._covariant_indices = set(covariant_indices)\n        result._contravariant_indices = set(contravariant_indices)\n        result._collection_indices = set(collection_indices)\n\n        return result\n\n    @property\n    def T(self):\n        """"""The transposed tensor, same as ``self.transpose()``.""""""\n        return self.transpose()\n\n    def copy(self):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        result.__dict__.update(self.__dict__)\n        return result\n\n    def is_zero(self, tol=EQ_TOL_ABS):\n        """"""Test whether the tensor is zero with respect to covariant and contravariant indices.\n\n        Parameters\n        ----------\n        tol : float, optional\n            The accepted tolerance.\n\n        Returns\n        -------\n        bool\n            True if the tensor is zero. If there are more indices than the covariant and contravariant indices,\n            a boolean array is returned.\n\n        """"""\n        axes = tuple(self._covariant_indices) + tuple(self._contravariant_indices)\n        return np.all(np.isclose(self.array, 0, atol=tol), axis=axes)\n\n    def __repr__(self):\n        return ""{}({})"".format(self.__class__.__name__, str(self.array.tolist()))\n\n    def __getitem__(self, index):\n\n        result = self.array[index]\n\n        if np.isscalar(result):\n            return result\n\n        index = normalize_index(index, self.shape)\n\n        covariant_indices = []\n        contravariant_indices = []\n        collection_indices = []\n\n        advanced_indices = []\n\n        index_mapping = list(range(self.rank))\n        i = 0\n        for ind in index:\n\n            # axis with integer index will be removed\n            if isinstance(ind, int):\n                index_mapping.pop(i)\n                continue\n\n            # new axis inserted by None index\n            if ind is None:\n                index_mapping.insert(i, None)\n\n            # advanced indexing\n            elif isinstance(ind, np.ndarray):\n                advanced_indices.append(i)\n\n            i += 1\n\n        if len(advanced_indices) > 0:\n\n            b = np.broadcast(*[index[i] for i in advanced_indices])\n            a0, a1 = advanced_indices[0], advanced_indices[-1]\n\n            if advanced_indices != list(range(a0, a1+1)):\n                # create advanced indices in front\n                for i in advanced_indices:\n                    index_mapping.remove(i)\n                index_mapping = [None]*b.ndim + index_mapping\n            else:\n                # replace indices with broadcast shape\n                index_mapping = index_mapping[:a0] + [None]*b.ndim + index_mapping[a1+1:]\n\n        for new_axis, old_axis in enumerate(index_mapping):\n            if old_axis is None or old_axis in self._collection_indices:\n                collection_indices.append(new_axis)\n            elif old_axis in self._covariant_indices:\n                covariant_indices.append(new_axis)\n            elif old_axis in self._contravariant_indices:\n                contravariant_indices.append(new_axis)\n\n        result = Tensor(result, copy=False)\n        result._covariant_indices = set(covariant_indices)\n        result._contravariant_indices = set(contravariant_indices)\n        result._collection_indices = set(collection_indices)\n\n        return result\n\n    def __setitem__(self, key, value):\n        if isinstance(value, Tensor):\n            value = value.array\n        self.array[key] = value\n\n    def __copy__(self):\n        return self.copy()\n\n    def __mul__(self, other):\n        if np.isscalar(other):\n            return Tensor(self.array * other, covariant=self._covariant_indices, copy=False)\n        if not isinstance(other, Tensor):\n            other = Tensor(other, copy=False)\n        return TensorDiagram((other, self)).calculate()\n\n    def __rmul__(self, other):\n        if np.isscalar(other):\n            return self * other\n        if not isinstance(other, Tensor):\n            other = Tensor(other, copy=False)\n        return TensorDiagram((self, other)).calculate()\n\n    def __pow__(self, power, modulo=None):\n        if modulo is not None or not isinstance(power, int) or power < 1:\n            return NotImplemented\n\n        if power == 1:\n            return self.copy()\n\n        d = TensorDiagram()\n        prev = self\n        for _ in range(power-1):\n            cur = prev.copy()\n            d.add_edge(cur, prev)\n            prev = cur\n\n        return d.calculate()\n\n    def __truediv__(self, other):\n        if np.isscalar(other):\n            return Tensor(self.array / other, covariant=self._covariant_indices, copy=False)\n        return NotImplemented\n\n    def __add__(self, other):\n        if isinstance(other, Tensor):\n            other = other.array\n        return Tensor(self.array + other, covariant=self._covariant_indices, copy=False)\n\n    def __radd__(self, other):\n        return self + other\n\n    def __sub__(self, other):\n        if isinstance(other, Tensor):\n            other = other.array\n        return Tensor(self.array - other, covariant=self._covariant_indices, copy=False)\n\n    def __rsub__(self, other):\n        return -self + other\n\n    def __neg__(self):\n        return self*(-1)\n\n    def __eq__(self, other):\n        if isinstance(other, Tensor):\n            other = other.array\n        return np.allclose(self.array, other, rtol=EQ_TOL_REL, atol=EQ_TOL_ABS)\n\n\nclass TensorCollection(Tensor):\n    """"""A collection of Tensor objects with identical covariant/contravariant indices and shape stored in a tensor.\n\n    Parameters\n    ----------\n    elements : array_like\n        A (nested) sequence of Tensor objects, a numpy array, a Tensor or a (nested) sequence of numbers.\n        If the sequence contains Tensor objects, they must all have the same shape and the same\n        covariant/contravariant indices.\n    covariant : :obj:`bool` or :obj:`list` of :obj:`int`, optional\n        This parameter is used when elements is a general array or sequence of numbers, to determine the covariant\n        indices of tensors contained in the collection. If False, all indices of all tensors in the collection are\n        contravariant. If instead a sequence of indices is supplied, the specified indices of all tensors in the\n        collection will be covariant indices and the rest of the indices of each tensor will be contravariant.\n        By default all indices are covariant.\n    tensor_rank : int, optional\n        The rank of the tensors contained in the collection. This parameter is only used if elements is not a sequence\n        of Tensor objects or a single tensor. Default is 1.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n    _element_class = Tensor\n\n    def __init__(self, elements, *, covariant=True, tensor_rank=1, **kwargs):\n        if isinstance(elements, Tensor):\n            super(TensorCollection, self).__init__(elements, **kwargs)\n            return\n\n        elements = np.asarray(elements)\n\n        # unpack tensors contained in elements\n        if elements.dtype.hasobject and elements.size > 0:\n            flat_elements = []\n            for t in elements.flat:\n                if not isinstance(t, Tensor):\n                    break\n                flat_elements.append(t.array)\n            else:\n                flat_elements = np.array(flat_elements)\n                tensor_rank = t.rank\n                covariant = t._covariant_indices\n                elements = flat_elements.reshape(elements.shape + t.shape)\n                kwargs[\'copy\'] = False\n\n        super(TensorCollection, self).__init__(elements, covariant=covariant, tensor_rank=tensor_rank, **kwargs)\n\n    def expand_dims(self, axis):\n        """"""Add a new index to the collection.\n\n        Parameters\n        ----------\n        axis : int\n            Position in the new shape where the new axis is placed.\n\n        Returns\n        -------\n        TensorCollection\n            The tensor collection with an additional index.\n\n        """"""\n        result = self.copy()\n        result.array = np.expand_dims(self.array, axis)\n\n        axis = sanitize_index(axis)\n        axis = posify_index(self.rank, axis)\n        result._collection_indices = set(i+1 if i >= axis else i for i in self._collection_indices)\n        result._covariant_indices = set(i+1 if i >= axis else i for i in self._covariant_indices)\n        result._contravariant_indices = set(i+1 if i >= axis else i for i in self._contravariant_indices)\n        result._collection_indices.add(axis)\n\n        return result\n\n    @property\n    def size(self):\n        """"""int: The number of tensors in the collection.""""""\n        return np.prod([self.shape[i] for i in self._collection_indices], dtype=int)\n\n    @property\n    def flat(self):\n        """"""generator: A flat iterator of the collection that yields Tensor objects.""""""\n        n_col = len(self._collection_indices)\n        covariant = set(i - n_col for i in self._covariant_indices)\n        for idx in np.ndindex(self.shape[:n_col]):\n            yield self._element_class(self.array[idx], covariant=covariant, copy=False)\n\n    def __getitem__(self, index):\n        result = super(TensorCollection, self).__getitem__(index)\n\n        if not isinstance(result, Tensor):\n            return result\n\n        if len(result._collection_indices) > 0:\n            return TensorCollection(result, copy=False)\n\n        return self._element_class(result, copy=False)\n\n    def __len__(self):\n        return len(self.array)\n\n\nclass LeviCivitaTensor(Tensor):\n    r""""""This class can be used to construct a tensor representing the Levi-Civita symbol.\n\n    The Levi-Civita symbol is also called :math:`\\varepsilon`-Tensor and is defined as follows:\n\n    .. math::\n\n        \\varepsilon_{\\nu_{1} \\ldots \\nu_{n}} =\n        \\begin{cases}\n            +1 & \\text{ if } (\\nu_{1}, \\ldots, \\nu_{n}) \\text{ are an even permutation of } (1, \\ldots, n)\\\\\n            -1 & \\text{ if } (\\nu_{1}, \\ldots, \\nu_{n}) \\text{ are an odd permutation of } (1, \\ldots, n)\\\\\n            0 & \\text{ else}\n        \\end{cases}\n\n    Parameters\n    ----------\n    size : int\n        The number of indices of the tensor.\n    covariant: :obj:`bool`, optional\n        If true, the tensor will only have covariant indices. Default: True\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Levi-Civita_symbol#Generalization_to_n_dimensions\n\n    """"""\n\n    _cache = {}\n\n    def __init__(self, size, covariant=True):\n        if size in self._cache:\n            array = self._cache[size]\n        else:\n            i, j = np.triu_indices(size, 1)\n            indices = np.array(list(permutations(range(size))), dtype=int).T\n            diff = indices[j] - indices[i]\n            diff = np.sign(diff, dtype=np.int8)\n            array = np.zeros(size * [size], dtype=np.int8)\n            array[tuple(indices)] = np.prod(diff, axis=0)\n\n            self._cache[size] = array\n        super(LeviCivitaTensor, self).__init__(array, covariant=bool(covariant), copy=False)\n\n\nclass KroneckerDelta(Tensor):\n    r""""""This class can be used to construct a (p, p)-tensor representing the Kronecker delta tensor.\n\n    The following generalized definition of the Kronecker delta is used:\n\n    .. math::\n\n        \\delta_{\\nu_{1} \\ldots \\nu_{p}}^{\\mu_{1} \\ldots \\mu_{p}} =\n        \\begin{cases}\n            +1 & \\text{ if } (\\nu_{1}, \\ldots, \\nu_{p}) \\text{ are an even permutation of } (\\mu_{1}, \\ldots, \\mu_{p})\\\\\n            -1 & \\text{ if } (\\nu_{1}, \\ldots, \\nu_{p}) \\text{ are an odd permutation of } (\\mu_{1}, \\ldots, \\mu_{p})\\\\\n            0 & \\text{ else}\n        \\end{cases}\n\n    Parameters\n    ----------\n    n : int\n        The dimension of the tensor.\n    p : int, optional\n        The number of covariant and contravariant indices of the tensor, default is 1.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Kronecker_delta#Generalizations\n\n    """"""\n\n    _cache = {}\n\n    def __init__(self, n, p=1):\n        if p == 1:\n            array = np.eye(n, dtype=int)\n        elif (p, n) in self._cache:\n            array = self._cache[(p, n)]\n        elif p == n:\n            e = LeviCivitaTensor(n)\n            array = np.tensordot(e.array, e.array, 0)\n\n            self._cache[(p, n)] = array\n        else:\n            d1 = KroneckerDelta(n)\n            d2 = KroneckerDelta(n, p-1)\n\n            def calc(*args):\n                return sum((-1)**(p+k+1)*d1.array[args[k], args[-1]]*d2.array[tuple(x for i, x in enumerate(args[:-1]) if i != k)] for k in range(p))\n\n            f = np.vectorize(calc)\n            array = np.fromfunction(f, tuple(2*p*[n]), dtype=int)\n\n        super(KroneckerDelta, self).__init__(array, covariant=range(p), copy=False)\n\n\nclass TensorDiagram:\n    """"""A class used to specify and calculate tensor diagrams (also called Penrose Graphical Notation).\n\n    Each edge in the diagram represents a contraction of two indices of the tensors connected by that edge. In\n    Einstein-notation that would mean that an edge from tensor A to tensor B is equivalent to the expression\n    :math:`A_{i j}B^{i k}_l`, where :math:`j, k, l` are free indices. The indices to contract are chosen from front to\n    back from contravariant and covariant indices of the tensors that are connected by an edge.\n\n    Parameters\n    ----------\n    *edges\n        Variable number of tuples, that represent the edge from one tensor to another.\n\n\n    References\n    ----------\n    .. [1] https://www-m10.ma.tum.de/foswiki/pub/Lehrstuhl/PublikationenJRG/52_TensorDiagrams.pdf\n    .. [2] J. Richter-Gebert: Perspectives on Projective Geometry, Chapters 13-14\n\n    """"""\n\n    def __init__(self, *edges):\n        self._nodes = []\n        self._free_indices = []\n        self._node_positions = []\n        self._contraction_list = []\n        self._index_count = 0\n\n        for e in edges:\n            self.add_edge(*e)\n\n    def add_node(self, node):\n        """"""Add a node to the tensor diagram without adding an edge/contraction.\n\n        A diagram of nodes where none are connected is equivalent to calculating the tensor product with the\n        method :meth:`Tensor.tensor_product`.\n\n        Parameters\n        ----------\n        node : Tensor\n            The node to add.\n\n        """"""\n        self._nodes.append(node)\n        self._node_positions.append(self._index_count)\n        self._index_count += node.rank\n        ind = (list(node._covariant_indices), list(node._contravariant_indices))\n        self._free_indices.append(ind)\n        return ind\n\n    def add_edge(self, source, target):\n        """"""Add an edge to the diagram.\n\n        Parameters\n        ----------\n        source : Tensor\n            The source tensor of the edge in the diagram.\n        target : Tensor\n            The target tensor of the edge in the diagram.\n\n        """"""\n\n        # First step: Find nodes if they are already in the diagram\n        source_index, target_index = None, None\n        for index, node in enumerate(self._nodes):\n            if node is source:\n                source_index = index\n                free_source = self._free_indices[index][0]\n            if node is target:\n                target_index = index\n                free_target = self._free_indices[index][1]\n\n            if source_index is not None and target_index is not None:\n                break\n\n        # One or both nodes were not found in the diagram\n        else:\n            # Second step: Add new nodes to nodes and free indices list\n            if source_index is None:\n                source_index = len(self._nodes)\n                free_source = self.add_node(source)[0]\n\n            if target_index is None:\n                target_index = len(self._nodes)\n                free_target = self.add_node(target)[1]\n\n        if len(free_source) == 0 or len(free_target) == 0:\n            raise TensorComputationError(""Could not add the edge because no free indices are left."")\n\n        # Third step: Pick some free indices\n        i = free_source.pop(0)\n        j = free_target.pop(0)\n\n        if source.shape[i] != target.shape[j]:\n            raise TensorComputationError(\n                ""Dimension of tensors is inconsistent, encountered dimensions {} and {}."".format(\n                    str(source.shape[i]), str(target.shape[j])))\n\n        self._contraction_list.append((source_index, target_index, i, j))\n\n    def calculate(self):\n        """"""Calculates the result of the diagram.\n\n        Returns\n        -------\n        Tensor\n            The tensor resulting from the specified tensor diagram.\n\n        """"""\n        # Build the list of indices for einsum\n        indices = list(range(self._index_count))\n        for source_index, target_index, i, j in self._contraction_list:\n            i = self._node_positions[source_index] + i\n            j = self._node_positions[target_index] + j\n            indices[max(i, j)] = min(i, j)\n\n        # Split the indices and insert the arrays\n        args = []\n        result_indices = ([], [], [])\n        for i, (node, ind, offset) in enumerate(zip(self._nodes, self._free_indices, self._node_positions)):\n            if len(node._collection_indices) > 0:\n                col_ind = sorted(node._collection_indices, reverse=True)\n                for j, k in enumerate(col_ind[:len(result_indices[0])]):\n                    indices[offset + k] = result_indices[0][-j-1]\n                if len(node._collection_indices) > len(result_indices[0]):\n                    for k in col_ind[len(result_indices[0]):]:\n                        result_indices[0].insert(0, offset + k)\n            result_indices[1].extend(offset + x for x in ind[0])\n            result_indices[2].extend(offset + x for x in ind[1])\n            args.append(node.array)\n            s = slice(offset, self._node_positions[i + 1] if i + 1 < len(self._node_positions) else None)\n            args.append(indices[s])\n\n        result = np.einsum(*args, result_indices[0] + result_indices[1] + result_indices[2])\n\n        n_col = len(result_indices[0])\n        n_cov = len(result_indices[1])\n\n        if n_col > 0:\n            return TensorCollection(result, covariant=range(0, n_cov), tensor_rank=result.ndim-n_col, copy=False)\n\n        return Tensor(result, covariant=range(n_cov), copy=False)\n\n    def copy(self):\n        result = TensorDiagram()\n        result._nodes = self._nodes.copy()\n        result._free_indices = self._free_indices.copy()\n        result._node_positions = self._node_positions.copy()\n        result._contraction_list = self._contraction_list.copy()\n        result._index_count = self._index_count\n        return result\n\n    def __copy__(self):\n        return self.copy()\n\n\nclass ProjectiveElement(Tensor, ABC):\n    """"""Base class for all projective tensors, i.e. all objects that identify scalar multiples.\n\n    """"""\n\n    def __eq__(self, other):\n        if np.isscalar(other):\n            return super(ProjectiveElement, self).__eq__(other)\n\n        if not isinstance(other, Tensor):\n            other = Tensor(other)\n\n        if self.shape != other.shape:\n            return False\n\n        return is_multiple(self.array, other.array, rtol=EQ_TOL_REL, atol=EQ_TOL_ABS)\n\n    @property\n    def dim(self):\n        """"""int: The ambient dimension of the tensor.""""""\n        return self.shape[0] - 1\n\n\nclass ProjectiveCollection(TensorCollection, ABC):\n    """"""Base class for collections of projective elements.\n\n    """"""\n\n    def __eq__(self, other):\n        if np.isscalar(other):\n            return super(ProjectiveCollection, self).__eq__(other)\n\n        if not isinstance(other, TensorCollection):\n            other = TensorCollection(other)\n\n        if self.shape != other.shape:\n            return False\n\n        axes = tuple(self._covariant_indices) + tuple(self._contravariant_indices)\n        return np.all(is_multiple(self.array, other.array, axis=axes, rtol=EQ_TOL_REL, atol=EQ_TOL_ABS))\n\n    @property\n    def dim(self):\n        """"""int: The ambient dimension tensors in the collection.""""""\n        return self.shape[-1] - 1\n'"
geometer/curve.py,60,"b'import math\nfrom itertools import combinations\n\nimport numpy as np\nfrom numpy.lib.scimath import sqrt as csqrt\n\nfrom .point import Point, Line, Plane, PointCollection, LineCollection, PlaneCollection, I, J, infty_plane\nfrom .transformation import rotation, translation\nfrom .base import ProjectiveElement, ProjectiveCollection, Tensor, TensorDiagram, EQ_TOL_REL, EQ_TOL_ABS\nfrom .exceptions import NotReducible\nfrom .utils import hat_matrix, is_multiple, adjugate, det, inv\n    \n    \nclass Quadric(ProjectiveElement):\n    r""""""Represents a quadric, i.e. the zero set of a polynomial of degree 2, in any dimension.\n\n    The quadric is defined by a symmetric matrix of size :math:`n+1` where :math:`n` is the dimension of the projective\n    space. If :math:`A \\in \\mathbb{R}^{(n+1) \\times (n+1)}`, the quadric contains all points\n    :math:`x \\in \\mathbb{R}^{n+1}` such that :math:`x^T A x = 0`.\n\n    Parameters\n    ----------\n    matrix : array_like or Tensor\n        A two-dimensional array defining the (n+1)x(n+1) symmetric matrix of the quadric.\n    is_dual : bool, optional\n        If true, the quadric represents a dual quadric, i.e. all hyperplanes tangent to the non-dual quadric.\n    normalize_matrix : bool, optional\n        If true, normalize matrix using the (n+1)-th root of the absolute value of its pseudo-determinant.\n\n    Attributes\n    ----------\n    is_dual : bool\n        True if the quadric is a dual quadric i.e. contains all hyperplanes tangent to the non-dual quadric.\n\n    """"""\n\n    def __init__(self, matrix, is_dual=False, normalize_matrix=False, **kwargs):\n        self.is_dual = is_dual\n\n        if normalize_matrix is True:\n            matrix = matrix.array if isinstance(matrix, Tensor) else matrix\n            w = np.abs(np.linalg.eigvalsh(matrix))\n            matrix = matrix / np.prod(w[w > EQ_TOL_ABS])**(1/matrix.shape[-1])\n            kwargs[""copy""] = False\n\n        kwargs.setdefault(""covariant"", False)\n        super(Quadric, self).__init__(matrix, **kwargs)\n\n    def __add__(self, other):\n        if not isinstance(other, Point):\n            return super(Quadric, self).__add__(other)\n\n        return translation(other).apply(self)\n\n    def __sub__(self, other):\n        return self + (-other)\n\n    @classmethod\n    def from_planes(cls, e, f):\n        """"""Construct a degenerate quadric from two hyperplanes.\n\n        Parameters\n        ----------\n        e, f : Plane\n            The two planes the quadric consists of.\n\n        Returns\n        -------\n        Quadric\n            The resulting quadric.\n\n        """"""\n        m = np.outer(e.array, f.array)\n        return Quadric(m + m.T, normalize_matrix=True)\n\n    def tangent(self, at):\n        """"""Returns the hyperplane defining the tangent space at a given point.\n\n        Parameters\n        ----------\n        at : Point\n            A point on the quadric at which the tangent plane is calculated.\n\n        Returns\n        -------\n        Plane\n            The tangent plane at the given point.\n\n        """"""\n        return Plane(self.array.dot(at.array), copy=False)\n\n    def is_tangent(self, plane):\n        """"""Tests if a given hyperplane is tangent to the quadric.\n\n        Parameters\n        ----------\n        plane : Subspace\n            The hyperplane to test.\n\n        Returns\n        -------\n        bool\n            True if the given hyperplane is tangent to the quadric.\n\n        """"""\n        return self.dual.contains(plane)\n\n    def contains(self, other, tol=EQ_TOL_ABS):\n        """"""Tests if a given point lies on the quadric.\n\n        Parameters\n        ----------\n        other : Point or Subspace\n            The point or hyperplane to test.\n        tol : float, optional\n            The accepted tolerance.\n\n        Returns\n        -------\n        bool\n            True if the quadric contains the point.\n\n        """"""\n        return np.isclose(other.array.dot(self.array.dot(other.array)), 0, atol=tol)\n\n    @property\n    def is_degenerate(self):\n        """"""bool: True if the quadric is degenerate.""""""\n        return np.isclose(det(self.array), 0, atol=EQ_TOL_ABS)\n\n    @property\n    def components(self):\n        """"""list of ProjectiveElement: The components of a degenerate quadric.""""""\n        # Algorithm adapted from Perspectives on Projective Geometry, Section 11.1\n        n = self.shape[0]\n\n        if n == 3:\n            b = adjugate(self.array)\n            i = np.argmax(np.abs(np.diag(b)))\n            beta = csqrt(-b[i, i])\n            p = -b[:, i] / beta if beta != 0 else b[:, i]\n\n        else:\n            p = []\n            for ind in combinations(range(n), n - 2):\n                # calculate all principal minors of order 2\n                row_ind = [[j] for j in range(n) if j not in ind]\n                col_ind = [j for j in range(n) if j not in ind]\n                p.append(csqrt(-det(self.array[row_ind, col_ind])))\n\n        # use the skew symmetric matrix m to get a matrix of rank 1 defining the same quadric\n        m = hat_matrix(p)\n        t = self.array + m\n\n        # components are in the non-zero rows and columns (up to scalar multiple)\n        i = np.unravel_index(np.abs(t).argmax(), t.shape)\n        p, q = t[i[0]], t[:, i[1]]\n\n        if self.dim > 2 and not is_multiple(np.outer(q, p), t, rtol=EQ_TOL_REL, atol=EQ_TOL_ABS):\n            raise NotReducible(""Quadric has no decomposition in 2 components."")\n\n        p, q = np.real_if_close(p), np.real_if_close(q)\n\n        if self.is_dual:\n            return [Point(p, copy=False), Point(q, copy=False)]\n        elif n == 3:\n            return [Line(p, copy=False), Line(q, copy=False)]\n        return [Plane(p, copy=False), Plane(q, copy=False)]\n\n    def intersect(self, other):\n        """"""Calculates points of intersection of a line with the quadric.\n\n        This method also returns complex points of intersection, even if the quadric and the line do not intersect in\n        any real points.\n\n        Parameters\n        ----------\n        other: Line or LineCollection\n            The line to intersect this quadric with.\n\n        Returns\n        -------\n        list of Point or list of PointCollection\n            The points of intersection.\n\n        References\n        ----------\n        .. [1] J. Richter-Gebert: Perspectives on Projective Geometry, Section 11.3\n\n        """"""\n        if isinstance(other, (Line, LineCollection)):\n            reducible = self.is_degenerate\n            if reducible:\n                try:\n                    e, f = self.components\n                except NotReducible:\n                    reducible = False\n\n            if not reducible:\n                if self.dim > 2:\n                    arr = other.array.reshape(other.shape[:-other.tensor_shape[1]] + (-1, self.dim + 1))\n\n                    if isinstance(other, Line):\n                        i = arr.nonzero()[0][0]\n                        m = Plane(arr[i], copy=False).basis_matrix\n                        q = Quadric(m.dot(self.array).dot(m.T), copy=False)\n                        line_base = other.basis_matrix.T\n                        line = Line(*[Point(x, copy=False) for x in m.dot(line_base).T])\n                        return [Point(m.T.dot(p.array), copy=False) for p in q.intersect(line)]\n                    else:\n                        i = np.any(arr, axis=-1).argmax(-1)\n                        m = PlaneCollection(arr[tuple(np.indices(i.shape)) + (i,)], copy=False).basis_matrix\n                        line_base = np.matmul(other.basis_matrix, np.swapaxes(m, -1, -2))\n                        line = PointCollection(line_base[..., 0, :], copy=False).join(PointCollection(line_base[..., 1, :], copy=False))\n                        q = QuadricCollection(np.matmul(np.matmul(m, self.array), np.swapaxes(m, -1, -2)), copy=False)\n                        return [PointCollection(np.squeeze(np.matmul(np.expand_dims(p.array, -2), m), -2), copy=False) for p in q.intersect(line)]\n                else:\n                    m = hat_matrix(other.array)\n                    b = np.matmul(np.matmul(np.swapaxes(m, -1, -2), self.array), m)\n\n                    if isinstance(other, Line):\n                        p, q = Conic(b, is_dual=not self.is_dual, copy=False).components\n                    else:\n                        p, q = QuadricCollection(b, is_dual=not self.is_dual, copy=False).components\n            else:\n                if self.is_dual:\n                    p, q = e.join(other), f.join(other)\n                else:\n                    p, q = e.meet(other), f.meet(other)\n\n            if p == q:\n                return [p]\n\n            return [p, q]\n\n    @property\n    def dual(self):\n        """"""Quadric: The dual quadric.""""""\n        return Quadric(np.linalg.inv(self.array), is_dual=not self.is_dual, copy=False)\n\n\nclass Conic(Quadric):\n    """"""A two-dimensional conic.\n    """"""\n\n    @classmethod\n    def from_points(cls, a, b, c, d, e):\n        """"""Construct a conic through five points.\n\n        Parameters\n        ----------\n        a, b, c, d, e : Point\n            The points lying on the conic.\n\n        Returns\n        -------\n        Conic\n            The resulting conic.\n\n        """"""\n        a, b, c, d, e = a.normalized_array, b.normalized_array, c.normalized_array, d.normalized_array, e.normalized_array\n        ace = det([a, c, e])\n        bde = det([b, d, e])\n        ade = det([a, d, e])\n        bce = det([b, c, e])\n        m = ace*bde*np.outer(np.cross(a, d), np.cross(b, c)) - ade*bce*np.outer(np.cross(a, c), np.cross(b, d))\n        return Conic(np.real_if_close(m+m.T), normalize_matrix=True)\n\n    @classmethod\n    def from_lines(cls, g, h):\n        """"""Construct a degenerate conic from two lines.\n\n        Parameters\n        ----------\n        g, h : Line\n            The two lines the conic consists of.\n\n        Returns\n        -------\n        Conic\n            The resulting conic.\n\n        """"""\n        m = np.outer(g.array, h.array)\n        return Conic(m + m.T, normalize_matrix=True)\n\n    @classmethod\n    def from_tangent(cls, tangent, a, b, c, d):\n        """"""Construct a conic through four points and tangent to a line.\n\n        Parameters\n        ----------\n        tangent : Line\n        a, b, c, d : Point\n            The points lying on the conic.\n\n        Returns\n        -------\n        Conic\n            The resulting conic.\n\n        """"""\n        if any(tangent.contains(p) for p in [a, b, c, d]):\n            raise ValueError(""The supplied points cannot lie on the supplied tangent!"")\n\n        a1, a2 = Line(a, c).meet(tangent).normalized_array, Line(b, d).meet(tangent).normalized_array\n        b1, b2 = Line(a, b).meet(tangent).normalized_array, Line(c, d).meet(tangent).normalized_array\n\n        o = tangent.general_point.array\n\n        a2b1 = det([o, a2, b1])\n        a2b2 = det([o, a2, b2])\n        a1b1 = det([o, a1, b1])\n        a1b2 = det([o, a1, b2])\n\n        c1 = csqrt(a2b1*a2b2)\n        c2 = csqrt(a1b1*a1b2)\n\n        x = Point(c1 * a1 + c2 * a2, copy=False)\n        y = Point(c1 * a1 - c2 * a2, copy=False)\n\n        conic = cls.from_points(a, b, c, d, x)\n        if np.all(np.isreal(conic.array)):\n            return conic\n        return cls.from_points(a, b, c, d, y)\n\n    @classmethod\n    def from_foci(cls, f1, f2, bound):\n        """"""Construct a conic with the given focal points that passes through the boundary point.\n\n        Parameters\n        ----------\n        f1, f2 : Point\n            The two focal points.\n        bound : Point\n            A boundary point that lies on the conic.\n\n        Returns\n        -------\n        Conic\n            The resulting conic.\n\n        """"""\n        t1, t2, t3, t4 = Line(f1, I), Line(f1, J), Line(f2, I), Line(f2, J)\n        p1, p2 = Point(t1.array, copy=False), Point(t2.array, copy=False)\n        p3, p4 = Point(t3.array, copy=False), Point(t4.array, copy=False)\n        c = cls.from_tangent(Line(bound.array, copy=False), p1, p2, p3, p4)\n        return Conic(np.linalg.inv(c.array), copy=False)\n\n    @classmethod\n    def from_crossratio(cls, cr, a, b, c, d):\n        """"""Construct a conic from a cross ratio and four other points.\n\n        This method relies on the fact that a point lies on a conic with five other points, if and only of the\n        cross ratio seen from this point is the same as the cross ratio of four of the other points seen from the fifth\n        point.\n\n        Parameters\n        ----------\n        cr : float\n            The crossratio of the other points that defines the conic.\n        a, b, c, d : Point\n            The points lying on the conic.\n\n        Returns\n        -------\n        Conic\n            The resulting conic.\n\n        References\n        ----------\n        .. [1] J. Richter-Gebert: Perspectives on Projective Geometry, Section 10.2\n\n        """"""\n        ac = adjugate([np.ones(3), a.array, c.array])[:, 0]\n        bd = adjugate([np.ones(3), b.array, d.array])[:, 0]\n        ad = adjugate([np.ones(3), a.array, d.array])[:, 0]\n        bc = adjugate([np.ones(3), b.array, c.array])[:, 0]\n\n        matrix = np.outer(ac, bd) - cr * np.outer(ad, bc)\n\n        return cls(matrix + matrix.T, normalize_matrix=True)\n\n    def intersect(self, other):\n        """"""Calculates points of intersection with the conic.\n\n        Parameters\n        ----------\n        other: Line, LineCollection or Conic\n            The object to intersect this conic with.\n\n        Returns\n        -------\n        list of Point or list of PointCollection\n            The points of intersection.\n\n        References\n        ----------\n        .. [1] J. Richter-Gebert: Perspectives on Projective Geometry, Section 11.4\n\n        """"""\n        if isinstance(other, Conic):\n            if other.is_degenerate:\n                g, h = other.components\n            else:\n                a1, a2, a3 = self.array\n                b1, b2, b3 = other.array\n                alpha = det(self.array)\n                beta = det([a1, a2, b3]) + det([a1, b2, a3]) + det([b1, a2, a3])\n                gamma = det([a1, b2, b3]) + det([b1, a2, b3]) + det([b1, b2, a3])\n                delta = det(other.array)\n\n                W = -2*beta**3 + 9*alpha*beta*gamma - 27*alpha**2*delta\n                D = -beta**2*gamma**2 + 4*alpha*gamma**3 + 4*beta**3*delta - 18*alpha*beta*gamma*delta + 27*alpha**2*delta**3\n                Q = W - alpha*csqrt(27*D)\n                R = np.complex128(4*Q)**(1/3)\n\n                lam = 2*beta**2 - 6*alpha*gamma - beta + R\n                mu = 3*alpha*(R + 3)\n\n                c = Conic(lam*self.array + mu*other.array, is_dual=self.is_dual)\n                g, h = c.components\n\n            result = self.intersect(g)\n            result += [x for x in self.intersect(h) if x not in result]\n            return result\n\n        return super(Conic, self).intersect(other)\n\n    def tangent(self, at):\n        """"""Calculates the tangent line at a given point or the tangent lines between a point and the conic.\n\n        Parameters\n        ----------\n        at : Point\n            The point to calculate the tangent at.\n\n        Returns\n        -------\n        Line or tuple of Line\n            The tangent line(s).\n\n        """"""\n        if self.contains(at):\n            return self.polar(at)\n        p, q = self.intersect(self.polar(at))\n        return at.join(p), at.join(q)\n\n    def polar(self, pt):\n        """"""Calculates the polar line of the conic at a given point.\n\n        Parameters\n        ----------\n        pt : Point\n            The point to calculate the polar at.\n\n        Returns\n        -------\n        Line\n            The polar line.\n\n        """"""\n        return Line(self.array.dot(pt.array), copy=False)\n\n    @property\n    def foci(self):\n        """"""tuple of Point: The foci of the conic.""""""\n        # Algorithm from Perspectives on Projective Geometry, Section 19.4\n        i = self.tangent(at=I)\n        j = self.tangent(at=J)\n\n        if isinstance(i, Line) and isinstance(j, Line):\n            return i.meet(j),\n\n        i1, i2 = i\n        j1, j2 = j\n        f1, f2 = i1.meet(j1), i2.meet(j2)\n        g1, g2 = i1.meet(j2), i2.meet(j1)\n\n        if np.all(np.isreal(f1.normalized_array)):\n            return f1, f2\n\n        return g1, g2\n\n\nabsolute_conic = Conic(np.eye(3))\n\n\nclass Ellipse(Conic):\n    """"""Represents an ellipse in 2D.\n\n    Parameters\n    ----------\n    center : Point, optional\n        The center of the ellipse, default is Point(0, 0).\n    hradius : float, optional\n        The horizontal radius (along the x-axis), default is 1.\n    vradius : float, optional\n         The vertical radius (along the y-axis), default is 1.\n\n    """"""\n\n    def __init__(self, center=Point(0, 0), hradius=1, vradius=1, **kwargs):\n        if hradius == vradius == 0:\n            raise ValueError(""hradius and vradius can not both be zero."")\n\n        r = np.array([vradius ** 2, hradius ** 2, 1])\n        c = -center.normalized_array\n        d = c * r\n        m = np.eye(3, dtype=d.dtype)\n        m[[0, 1], [0, 1]] = r[:2]\n        m[2, :] = d\n        m[:, 2] = d\n        m[2, 2] = d.dot(c) - (r[0] * r[1] + 1)\n\n        # normalize with abs(det(m))\n        m = m / (np.prod(np.maximum(r[:2], 1)))**(2/3)\n\n        kwargs[""copy""] = False\n        super(Ellipse, self).__init__(m, **kwargs)\n\n\nclass Circle(Ellipse):\n    """"""A circle in 2D.\n\n    Parameters\n    ----------\n    center : Point, optional\n        The center point of the circle, default is Point(0, 0).\n    radius : float, optional\n        The radius of the circle, default is 1.\n\n    """"""\n\n    def __init__(self, center=Point(0, 0), radius=1, **kwargs):\n        super(Circle, self).__init__(center, radius, radius, **kwargs)\n\n    @property\n    def center(self):\n        """"""Point: The center of the circle.""""""\n        return self.foci[0]\n\n    @property\n    def radius(self):\n        """"""float: The radius of the circle.""""""\n        c = self.array[:2, 2] / self.array[0, 0]\n        return np.sqrt(c.dot(c) - self.array[2, 2] / self.array[0, 0])\n\n    @property\n    def lie_coordinates(self):\n        """"""Point: The Lie coordinates of the circle as point in RP4.""""""\n        m = self.center.normalized_array\n        x = m[0]**2 + m[1]**2 - self.radius**2\n        return Point([(1 + x)/2, (1 - x)/2, m[0], m[1], self.radius])\n\n    def intersection_angle(self, other):\n        """"""Calculates the angle of intersection of two circles using its Lie coordinates.\n\n        Parameters\n        ----------\n        other : Circle\n            The circle to intersect this circle with.\n\n        Returns\n        -------\n        float\n            The angle of intersection.\n\n        References\n        ----------\n        .. [1] https://en.wikipedia.org/wiki/Lie_sphere_geometry\n\n        """"""\n        # lorenz coordinates\n        p1 = self.lie_coordinates.normalized_array[:-1]\n        p2 = other.lie_coordinates.normalized_array[:-1]\n\n        return np.arccos(np.vdot(p1, p2))\n\n    @property\n    def area(self):\n        """"""float: The area of the circle.""""""\n        return 2*np.pi*self.radius**2\n\n\nclass Sphere(Quadric):\n    """"""A sphere in any dimension.\n\n    Parameters\n    ----------\n    center : Point, optional\n        The center of the sphere, default is Point(0, 0, 0).\n    radius : float, optional\n        The radius of the sphere, default is 1.\n\n    """"""\n\n    def __init__(self, center=Point(0, 0, 0), radius=1, **kwargs):\n        if radius == 0:\n            raise ValueError(""Sphere radius cannot be 0."")\n\n        c = -center.normalized_array\n        m = np.eye(center.shape[0], dtype=np.find_common_type([c.dtype, type(radius)], []))\n        m[-1, :] = c\n        m[:, -1] = c\n        m[-1, -1] = c[:-1].dot(c[:-1])-radius**2\n\n        # normalize with abs(det(m))\n        m = m / radius ** (2 / 3)\n\n        kwargs[""copy""] = False\n        super(Sphere, self).__init__(m, **kwargs)\n\n    @property\n    def center(self):\n        """"""Point: The center of the sphere.""""""\n        return Point(np.append(-self.array[:-1, -1], [self.array[0, 0]]), copy=False)\n\n    @property\n    def radius(self):\n        """"""float: The radius of the sphere.""""""\n        c = self.array[:-1, -1] / self.array[0, 0]\n        return np.sqrt(c.dot(c) - self.array[-1, -1] / self.array[0, 0])\n\n    @staticmethod\n    def _alpha(n):\n        return math.pi**(n/2) / math.gamma(n/2 + 1)\n\n    @property\n    def volume(self):\n        """"""float: The volume of the sphere.""""""\n        n = self.dim\n        return self._alpha(n)*self.radius**n\n\n    @property\n    def area(self):\n        """"""float: The surface area of the sphere.""""""\n        n = self.dim\n        return n*self._alpha(n)*self.radius**(n-1)\n\n\nclass Cone(Quadric):\n    """"""A quadric that forms a circular double cone in 3D.\n\n    Parameters\n    ----------\n    vertex : Point, optional\n        The vertex or apex of the cone. Default is (0, 0, 0).\n    base_center : Point, optional\n        The center of the circle that forms the base of the cone. Default is (0, 0, 1)\n    radius : float, optional\n        The radius of the circle forming the base of the cone. Default is 1.\n\n    """"""\n\n    def __init__(self, vertex=Point(0, 0, 0), base_center=Point(0, 0, 1), radius=1, **kwargs):\n        if radius == 0:\n            raise ValueError(""The radius of a cone can not be zero."")\n\n        from .operators import dist, angle\n\n        h = dist(vertex, base_center)\n        c = (radius / h)**2\n\n        if np.isinf(h):\n            # cone with vertex at infinity is a cylinder with the center of the base as center\n            v = base_center.normalized_array\n        else:\n            v = vertex.normalized_array\n\n        # first build a cone with axis parallel to the z-axis\n        m = np.eye(4, dtype=np.find_common_type([v.dtype, type(c)], []))\n        m[-1, :] = -v\n        m[:, -1] = -v\n\n        if np.isinf(c):\n            # if h == 0 the quadric becomes a circle\n            m[3, 3] = v[:3].dot(v[:3]) - radius ** 2\n        else:\n            m[2:, 2:] *= -c\n            m[3, 3] = v[:2].dot(v[:2]) - (radius**2 if np.isinf(h) else v[2]**2 * c)\n\n        # rotate the axis of the cone\n        v = Point(v, copy=False)\n        axis = Line(v, v+Point(0, 0, 1))\n        new_axis = Line(vertex, base_center)\n\n        if new_axis != axis:\n            a = angle(axis, new_axis)\n            e = axis.join(new_axis)\n            t = rotation(a, axis=Point(*e.array[:3]))\n            t = translation(v) * t * translation(-v)\n            m = t.array.T.dot(m).dot(t.array)\n\n        kwargs[""normalize_matrix""] = True\n        super(Cone, self).__init__(m, **kwargs)\n\n\nclass Cylinder(Cone):\n    """"""A circular cylinder in 3D.\n\n    Parameters\n    ----------\n    center : Point, optional\n        The center of the cylinder. Default is (0, 0, 0).\n    direction : Point\n        The direction of the axis of the cylinder. Default is (0, 0, 1).\n    radius : float, optional\n        The radius of the cylinder. Default is 1.\n\n    """"""\n\n    def __init__(self, center=Point(0, 0, 0), direction=Point(0, 0, 1), radius=1, **kwargs):\n        vertex = infty_plane.meet(Line(center, center+direction))\n        super(Cylinder, self).__init__(vertex, center, radius, **kwargs)\n\n\nclass QuadricCollection(ProjectiveCollection):\n    """"""A collection of quadrics or conics.\n\n    """"""\n\n    def __init__(self, matrices, is_dual=False, **kwargs):\n        self.is_dual = is_dual\n\n        if not is_dual:\n            kwargs.setdefault(""covariant"", False)\n        super(QuadricCollection, self).__init__(matrices, tensor_rank=2, **kwargs)\n\n    def tangent(self, at):\n        """"""Returns the hyperplanes defining the tangent spaces at given points.\n\n        Parameters\n        ----------\n        at : Point or PointCollection\n            A point on the quadric at which the tangent plane is calculated.\n\n        Returns\n        -------\n        PlaneCollection\n            The tangent planes at the given points.\n\n        """"""\n        return PlaneCollection(self*at, copy=False)\n\n    def is_tangent(self, planes):\n        """"""Tests if a given hyperplane is tangent to the quadrics.\n\n        Parameters\n        ----------\n        planes : Subspace or SubspaceCollection\n            The hyperplane to test.\n\n        Returns\n        -------\n        numpy.ndarray\n            Returns a boolean array of which hyperplanes are tangent to the quadrics.\n\n        """"""\n        return self.dual.contains(planes)\n\n    def contains(self, other, tol=EQ_TOL_ABS):\n        """"""Tests if a given point lies on the quadrics.\n\n        Parameters\n        ----------\n        other : Point, PointCollection, Subspace or SubspaceCollection\n            The points to test.\n        tol : float, optional\n            The accepted tolerance.\n\n        Returns\n        -------\n        numpy.ndarray\n            Returns a boolean array of which quadrics contain the points.\n\n        """"""\n        if self.is_dual:\n            d = TensorDiagram((self, other), (self, other.copy()))\n        else:\n            d = TensorDiagram((other, self), (other.copy(), self))\n        return np.isclose(d.calculate().array, 0, atol=tol)\n\n    @property\n    def is_degenerate(self):\n        """"""numpy.ndarray: Boolean array of which quadrics are degenerate in the collection.""""""\n        return np.isclose(det(self.array), 0, atol=EQ_TOL_ABS)\n\n    @property\n    def components(self):\n        """"""list of ProjectiveCollection: The components of the degenerate quadrics.""""""\n        n = self.shape[-1]\n        indices = tuple(np.indices(self.shape[:-2]))\n\n        if n == 3:\n            b = adjugate(self.array)\n            i = np.argmax(np.abs(np.diagonal(b, axis1=-2, axis2=-1)), axis=-1)\n            beta = csqrt(-b[indices + (i, i)])\n            p = -b[indices + (slice(None), i)] / np.where(beta != 0, beta, -1)[..., None]\n\n        else:\n            ind = np.indices((n, n))\n            ind = [np.delete(np.delete(ind, i, axis=1), i, axis=2) for i in combinations(range(n), n - 2)]\n            ind = np.stack(ind, axis=1)\n            minors = det(self.array[..., ind[0], ind[1]])\n            p = csqrt(-minors)\n\n        # use the skew symmetric matrix m to get a matrix of rank 1 defining the same quadric\n        m = hat_matrix(p)\n        t = self.array + m\n\n        # components are in the non-zero rows and columns (up to scalar multiple)\n        i = np.unravel_index(np.abs(t).reshape(t.shape[:-2]+(-1,)).argmax(axis=-1), t.shape[-2:])\n        p, q = t[indices + i[:1]], t[indices + (slice(None), i[1])]\n\n        if self.dim > 2 and not np.all(is_multiple(q[..., None]*p[..., None, :], t, rtol=EQ_TOL_REL, atol=EQ_TOL_ABS, axis=(-2, -1))):\n            raise NotReducible(""Quadric has no decomposition in 2 components."")\n\n        # TODO: make order of components reproducible\n\n        p, q = np.real_if_close(p), np.real_if_close(q)\n\n        if self.is_dual:\n            return [PointCollection(p, copy=False), PointCollection(q, copy=False)]\n        elif n == 3:\n            return [LineCollection(p, copy=False), LineCollection(q, copy=False)]\n        return [PlaneCollection(p, copy=False), PlaneCollection(q, copy=False)]\n\n    def intersect(self, other):\n        """"""Calculates points of intersection of a line or a collection of lines with the quadrics.\n\n        Parameters\n        ----------\n        other: Line or LineCollection\n            The line or lines to intersect the quadrics with.\n\n        Returns\n        -------\n        list of PointCollection\n            The points of intersection\n\n        """"""\n        if isinstance(other, (Line, LineCollection)):\n            reducible = np.all(self.is_degenerate)\n            if reducible:\n                try:\n                    e, f = self.components\n                except NotReducible:\n                    reducible = False\n\n            if not reducible:\n                if self.dim > 2:\n                    arr = other.array.reshape(other.shape[:-other.tensor_shape[1]] + (-1, self.dim + 1))\n\n                    if isinstance(other, Line):\n                        i = arr.nonzero()[0][0]\n                        m = Plane(arr[i], copy=False).basis_matrix\n                        line_base = other.basis_matrix\n                        line = Line(*[Point(x, copy=False) for x in line_base.dot(m.T)])\n                    else:\n                        i = np.any(arr, axis=-1).argmax(-1)\n                        m = PlaneCollection(arr[tuple(np.indices(i.shape)) + (i,)], copy=False).basis_matrix\n                        line_base = np.matmul(other.basis_matrix, np.swapaxes(m, -1, -2))\n                        line = PointCollection(line_base[..., 0, :], copy=False).join(PointCollection(line_base[..., 1, :], copy=False))\n\n                    q = QuadricCollection(np.matmul(np.matmul(m, self.array), np.swapaxes(m, -1, -2)), copy=False)\n                    return [PointCollection(np.squeeze(np.matmul(np.expand_dims(p.array, -2), m), -2), copy=False) for p in q.intersect(line)]\n                else:\n                    m = hat_matrix(other.array)\n                    b = np.matmul(np.matmul(np.swapaxes(m, -1, -2), self.array), m)\n                    p, q = QuadricCollection(b, is_dual=not self.is_dual, copy=False).components\n            else:\n                if self.is_dual:\n                    p, q = e.join(other), f.join(other)\n                else:\n                    p, q = e.meet(other), f.meet(other)\n\n            return [p, q]\n\n    @property\n    def dual(self):\n        """"""QuadricCollection: The dual quadrics of the quadrics in the collection.""""""\n        return QuadricCollection(inv(self.array), is_dual=not self.is_dual, copy=False)\n'"
geometer/exceptions.py,0,"b'\n\nclass GeometryException(Exception):\n    """"""A general geometric error occurred.""""""\n\n\nclass TensorComputationError(GeometryException):\n    """"""An error during a tensor computation occurred.""""""\n\n\nclass NotCollinear(GeometryException, ValueError):\n    """"""The given values are not collinear.""""""\n\n\nclass NotCoplanar(GeometryException, ValueError):\n    """"""The given values are not coplanar.""""""\n\n\nclass IncidenceError(GeometryException, ValueError):\n    """"""The given objects were not incident to each other.""""""\n\n\nclass LinearDependenceError(GeometryException, ValueError):\n    """"""The given values were linearly dependent, making the computation impossible.""""""\n\n\nclass NotReducible(GeometryException, ValueError):\n    """"""The given geometric object is not reducible.""""""\n'"
geometer/operators.py,23,"b'import numpy as np\nfrom .point import Point, Line, Plane, I, J, infty, infty_plane, join, meet\nfrom .curve import absolute_conic\nfrom .base import LeviCivitaTensor, TensorDiagram, EQ_TOL_REL, EQ_TOL_ABS\nfrom .exceptions import IncidenceError, NotCollinear\nfrom .utils import orth, det\n\n\ndef crossratio(a, b, c, d, from_point=None):\n    """"""Calculates the cross ratio of points or lines.\n\n    Parameters\n    ----------\n    a, b, c, d : Point, PointCollection, Line or Plane\n        The points, lines or planes (any dimension) to calculate the cross ratio of.\n    from_point : Point or PointCollection, optional\n        A 2D point, only allowed if the other arguments are also 2D points.\n\n    Returns\n    -------\n    float or complex\n        The cross ration of the given objects.\n\n    """"""\n\n    if a == b:\n        return 1\n\n    if isinstance(a, Line):\n        if not is_concurrent(a, b, c, d):\n            raise IncidenceError(""The lines are not concurrent: "" + str([a, b, c, d]))\n\n        from_point = a.meet(b)\n        a, b, c, d = a.base_point, b.base_point, c.base_point, d.base_point\n\n    if isinstance(a, Plane):\n        l = a.meet(b)\n        e = Plane(l.direction.array, copy=False)\n        a, b, c, d = e.meet(a), e.meet(b), e.meet(c), e.meet(d)\n        m = e.basis_matrix\n        p = e.meet(l)\n        from_point = Point(m.dot(p.array), copy=False)\n        a = Point(m.dot((p + a.direction).array), copy=False)\n        b = Point(m.dot((p + b.direction).array), copy=False)\n        c = Point(m.dot((p + c.direction).array), copy=False)\n        d = Point(m.dot((p + d.direction).array), copy=False)\n\n    if a.dim > 2 or (from_point is None and a.dim == 2):\n\n        # TODO: implement this for collections\n        if not is_collinear(a, b, c, d):\n            raise NotCollinear(""The points are not collinear: "" + str([a, b, c, d]))\n\n        basis = np.stack([a.array, b.array])\n        a = Point(basis.dot(a.array), copy=False)\n        b = Point(basis.dot(b.array), copy=False)\n        c = Point(basis.dot(c.array), copy=False)\n        d = Point(basis.dot(d.array), copy=False)\n\n    if from_point is not None:\n        a, b, c, d, from_point = np.broadcast_arrays(a.array, b.array, c.array, d.array, from_point.array)\n        o = [from_point]\n    else:\n        a, b, c, d = np.broadcast_arrays(a.array, b.array, c.array, d.array)\n        o = []\n\n    ac = det(np.stack(o + [a, c], axis=-1))\n    bd = det(np.stack(o + [b, d], axis=-1))\n    ad = det(np.stack(o + [a, d], axis=-1))\n    bc = det(np.stack(o + [b, c], axis=-1))\n\n    with np.errstate(divide=""ignore""):\n        return ac * bd / (ad * bc)\n\n\ndef harmonic_set(a, b, c):\n    """"""Constructs a fourth point that forms a harmonic set with the given points.\n\n    The three given points must be collinear.\n\n    If the returned point is d, the points {{a, b}, {c, d}} will be in harmonic position.\n\n    Parameters\n    ----------\n    a, b, c : Point\n        The points (any dimension) that are used to construct the fourth point in the harmonic set.\n\n    Returns\n    -------\n    Point\n        The point that forms a harmonic set with the given points.\n\n    """"""\n    l = Line(a, b)\n    o = l.general_point\n    n = l.dim + 1\n\n    if n > 3:\n        e = join(l, o)\n        basis = e.basis_matrix\n        a = Point(basis.dot(a.array))\n        b = Point(basis.dot(b.array))\n        c = Point(basis.dot(c.array))\n        o = Point(basis.dot(o.array))\n        l = Line(a, b)\n\n    m = Line(o, c)\n    p = o + 1/2*m.direction\n    result = l.meet(join(meet(o.join(a), p.join(b)), meet(o.join(b), p.join(a))))\n\n    if n > 3:\n        return Point(basis.T.dot(result.array))\n\n    return result\n\n\ndef angle(*args):\n    r""""""Calculates the (oriented) angle between given points, lines or planes.\n\n    The function uses the Laguerre formula to calculate angles in two or three dimensional projective space\n    using cross ratios. To calculate the angle between two planes, two additional planes tangent to the absolute\n    conic are constructed (see [1]).\n\n    Since the Laguerre formula uses the complex logarithm (which gives values between :math:`-\\pi i` and :math:`\\pi i`)\n    and multiplies it with :math:`1/2i`, this function can only calculate angles between :math:`-\\pi / 2` and\n    :math:`\\pi / 2`.\n\n    The sign of the angle is determined by the order of the arguments. The points passed to the cross ratio are in\n    the same order as the arguments to this function.\n    When three points are given as arguments, the first point is the point at which the angle is calculated.\n\n    Parameters\n    ----------\n    *args\n        The objects between which the function calculates the angle. This can be 2 or 3 points, 2 lines or 2 planes.\n\n    Returns\n    -------\n    float\n        The oriented angle between the given objects.\n\n    References\n    ----------\n    .. [1] Olivier Faugeras, Three-dimensional Computer Vision, Page 30\n\n    """"""\n    if len(args) == 3:\n        a, b, c = args\n        if a.dim > 2:\n            e = join(*args)\n            basis = e.basis_matrix\n            a, b, c = Point(basis.dot(a.array)), Point(basis.dot(b.array)), Point(basis.dot(c.array))\n\n    elif len(args) == 2:\n        x, y = args\n\n        if isinstance(x, Plane) and isinstance(y, Plane):\n            l = x.meet(y)\n            p = l.meet(infty_plane)\n            polar = Line(p.array[:-1], copy=False)\n            tangent_points = absolute_conic.intersect(polar)\n            tangent_points = [Point(np.append(p.array, 0)) for p in tangent_points]\n            i = l.join(p.join(tangent_points[0]))\n            j = l.join(p.join(tangent_points[1]))\n            return 1/2j*np.log(crossratio(x, y, i, j))\n\n        if isinstance(x, Line) and isinstance(y, Line):\n            a = x.meet(y)\n        else:\n            a = Point(*(x.dim * [0]))\n            if isinstance(x, Point):\n                x = a.join(x)\n            if isinstance(y, Point):\n                y = a.join(y)\n\n        if a.dim > 2:\n            e = join(x, y)\n            basis = e.basis_matrix\n            a = Point(basis.dot(a.array))\n            b = Point(basis.dot(x.meet(infty_plane).array))\n            c = Point(basis.dot(y.meet(infty_plane).array))\n        else:\n            b = x.meet(infty)\n            c = y.meet(infty)\n    else:\n        raise ValueError(""Expected 2 or 3 arguments, got %s."" % len(args))\n\n    return np.real(1/2j*np.log(crossratio(b, c, I, J, a)))\n\n\ndef angle_bisectors(l, m):\n    """"""Constructs the angle bisectors of two given lines.\n\n    Parameters\n    ----------\n    l, m : Line\n        Two lines in any dimension.\n\n    Returns\n    -------\n    tuple of Line\n        The two angle bisectors.\n\n    """"""\n    o = l.meet(m)\n\n    if o.dim > 2:\n        e = join(l, m)\n        basis = e.basis_matrix\n        L = Point(basis.dot(l.meet(infty_plane).array))\n        M = Point(basis.dot(m.meet(infty_plane).array))\n\n    else:\n        L, M = l.meet(infty), m.meet(infty)\n\n    p = Point(0, 0)\n    li = det([p.array, L.array, I.array])\n    lj = det([p.array, L.array, J.array])\n    mi = det([p.array, M.array, I.array])\n    mj = det([p.array, M.array, J.array])\n    a, b = np.sqrt(lj*mj), np.sqrt(li*mi)\n    r, s = a*I+b*J, a*I-b*J\n\n    if o.dim > 2:\n        r, s = Point(basis.T.dot(r.array)), Point(basis.T.dot(s.array))\n\n    return Line(o, r), Line(o, s)\n\n\ndef dist(p, q):\n    """"""Calculates the (euclidean) distance between two objects.\n\n    Parameters\n    ----------\n    p, q : Point, Line or Plane\n        The points, lines or planes to calculate the distance between.\n\n    Returns\n    -------\n    float\n        The distance between the given objects.\n\n    """"""\n    if p == q:\n        return 0\n\n    if isinstance(p, (Plane, Line)) and isinstance(q, Point):\n        return dist(p.project(q), q)\n    if isinstance(p, Point) and isinstance(q, (Plane, Line)):\n        return dist(q.project(p), p)\n    if isinstance(p, Plane) and isinstance(q, (Plane, Line)):\n        return dist(p, Point(q.basis_matrix[0, :]))\n    if isinstance(q, Plane) and isinstance(p, Line):\n        return dist(q, p.base_point)\n\n    if p.dim > 2:\n        x = np.array([p.normalized_array, q.normalized_array])\n        z = x[:, -1]\n\n        m = orth(x.T, 2)\n        x = m.T.dot(x.T)\n        x = np.append(x, [z], axis=0).T\n        p, q = Point(x[0]), Point(x[1])\n\n    pqi = det([p.array, q.array, I.array])\n    pqj = det([p.array, q.array, J.array])\n    pij = det([p.array, I.array, J.array])\n    qij = det([q.array, I.array, J.array])\n\n    with np.errstate(divide=""ignore"", invalid=""ignore""):\n        return 4*abs(np.sqrt(pqi * pqj)/(pij*qij))\n\n\ndef is_cocircular(a, b, c, d, rtol=EQ_TOL_REL, atol=EQ_TOL_ABS):\n    """"""Tests whether four points lie on a circle.\n\n    Parameters\n    ----------\n    a, b, c, d : Point\n        Four points in RP2 or CP1.\n    rtol : float, optional\n        The relative tolerance parameter.\n    atol : float, optional\n        The absolute tolerance parameter.\n\n    Returns\n    -------\n    bool\n        True if the four points lie on a circle.\n\n    """"""\n    if a.dim == 1:\n        return np.isreal(crossratio(a, b, c, d))\n\n    elif a.dim > 2:\n        e = join(a, b, c)\n        basis = e.basis_matrix\n        a = Point(basis.dot(a.array))\n        b = Point(basis.dot(b.array))\n        c = Point(basis.dot(c.array))\n        d = Point(basis.dot(d.array))\n\n    i = crossratio(a, b, c, d, I)\n    j = crossratio(a, b, c, d, J)\n    return np.isclose(i, j, rtol, atol)\n\n\ndef is_perpendicular(l, m, rtol=EQ_TOL_REL, atol=EQ_TOL_ABS):\n    """"""Tests whether two lines/planes are perpendicular.\n\n    Parameters\n    ----------\n    l, m : Line or Plane\n        Two lines in any dimension or two planes in 3D.\n    rtol : float, optional\n        The relative tolerance parameter.\n    atol : float, optional\n        The absolute tolerance parameter.\n\n    Returns\n    -------\n    bool\n        True if the two lines/planes are perpendicular.\n\n    """"""\n    if l.dim < 3:\n        L = l.meet(infty)\n        M = m.meet(infty)\n\n    elif isinstance(l, Line) and isinstance(m, Line):\n        e = join(l, m)\n        basis = e.basis_matrix\n        L = Point(basis.dot(l.meet(infty_plane).array))\n        M = Point(basis.dot(m.meet(infty_plane).array))\n\n    elif isinstance(l, Plane) and isinstance(m, Plane):\n        x = l.meet(m)\n        p = x.meet(infty_plane)\n        polar = Line(p.array[:-1], copy=False)\n        tangent_points = absolute_conic.intersect(polar)\n        tangent_points = [Point(np.append(p.array, 0)) for p in tangent_points]\n        i = x.join(p.join(tangent_points[0]))\n        j = x.join(p.join(tangent_points[1]))\n        return np.isclose(crossratio(l, m, i, j), -1, rtol, atol)\n\n    else:\n        raise NotImplementedError(""Only two lines or two planes are supported."")\n\n    return np.isclose(crossratio(L, M, I, J, Point(1, 1)), -1, rtol, atol)\n\n\ndef is_coplanar(*args, tol=EQ_TOL_ABS):\n    """"""Tests whether the given points or lines are collinear, coplanar or concurrent. Works in any dimension.\n\n    Due to line point duality this function has dual versions :obj:`is_collinear` and :obj:`is_concurrent`.\n\n    Parameters\n    ----------\n    *args\n        The points or lines to test.\n    tol : float, optional\n            The accepted tolerance.\n\n    Returns\n    -------\n    bool\n        True if the given points are coplanar (in 3D) or collinear (in 2D) or if the given lines are concurrent.\n\n    """"""\n    n = args[0].dim + 1\n    if not np.isclose(det([a.array for a in args[:n]]), 0, atol=tol):\n        return False\n    if len(args) == n:\n        return True\n    covariant = args[0].tensor_shape[1] > 0\n    e = LeviCivitaTensor(n, covariant=covariant)\n    diagram = TensorDiagram(*[(e, a) if covariant else (a, e) for a in args[:n-1]])\n    tensor = diagram.calculate()\n    for t in args[n:]:\n        x = t*tensor if covariant else tensor*t\n        if not np.isclose(x.array, 0, atol=tol):\n            return False\n    return True\n\n\nis_collinear = is_coplanar\nis_concurrent = is_coplanar\n'"
geometer/point.py,49,"b'import numpy as np\n\nfrom .base import ProjectiveElement, ProjectiveCollection, TensorDiagram, LeviCivitaTensor, TensorCollection, Tensor, EQ_TOL_ABS\nfrom .exceptions import LinearDependenceError, NotCoplanar, GeometryException\nfrom .utils import null_space\n\n\ndef _join_meet_duality(*args, intersect_lines=True):\n    if len(args) < 2:\n        raise ValueError(""Expected at least 2 arguments, got %s."" % len(args))\n\n    n = args[0].dim + 1\n\n    # all arguments are 1-tensors, i.e. points or hypersurfaces (=lines in 2D)\n    if all(o.tensor_shape == args[0].tensor_shape for o in args[1:]) and sum(args[0].tensor_shape) == 1:\n        covariant = args[0].tensor_shape[0] > 0\n        e = LeviCivitaTensor(n, not covariant)\n\n        # summing all arguments with e gives a (n-len(args))-tensor (e.g. a 1-tensor for two 2D-lines)\n        result = TensorDiagram(*[(o, e) if covariant else (e, o) for o in args]).calculate()\n\n    # two lines/planes\n    elif len(args) == 2:\n        a, b = args\n        if isinstance(a, (Line, LineCollection)) and isinstance(b, (Plane, PlaneCollection)) or \\\n                isinstance(b, (Line, LineCollection)) and isinstance(a, (Plane, PlaneCollection)):\n            e = LeviCivitaTensor(n)\n            result = TensorDiagram(*[(e, a)] * a.tensor_shape[1], *[(e, b)] * b.tensor_shape[1]).calculate()\n        elif isinstance(a, (Subspace, SubspaceCollection)) and isinstance(b, (Point, PointCollection)):\n            result = a * b\n        elif isinstance(a, (Point, PointCollection)) and isinstance(b, (Subspace, SubspaceCollection)):\n            result = b * a\n        elif isinstance(a, (Line, LineCollection)) and isinstance(b, (Line, LineCollection)):\n            # can assume that n >= 4, because for n = 3 lines are 1-tensors\n            e = LeviCivitaTensor(n)\n\n            # if this is zero, the lines are coplanar\n            result = TensorDiagram(*[(e, a)] * a.tensor_shape[1], *[(e, b)] * (n-a.tensor_shape[1])).calculate()\n            coplanar = result.is_zero()\n\n            if np.all(coplanar):\n                # this part is inspired by Jim Blinn, Lines in Space: A Tale of Two Lines\n                diagram = TensorDiagram(*[(e, a)] * a.tensor_shape[1], (e, b))\n                array = diagram.calculate().array\n\n                if np.isscalar(coplanar):\n                    i = np.unravel_index(np.abs(array).argmax(), array.shape)\n                    if not intersect_lines:\n                        # extract the common subspace\n                        result = Tensor(array[i[0], ...], covariant=False, copy=False)\n                    else:\n                        # extract the point of intersection\n                        result = Tensor(array[(slice(None),) + i[1:]], copy=False)\n                else:\n                    max_ind = np.abs(array).reshape((np.prod(array.shape[:coplanar.ndim]), -1)).argmax(1)\n                    i = np.unravel_index(max_ind, array.shape[coplanar.ndim:])\n                    i = tuple(np.reshape(x, array.shape[:coplanar.ndim]) for x in i)\n                    indices = tuple(np.indices(array.shape[:coplanar.ndim]))\n                    if not intersect_lines:\n                        result = array[indices + (i[0], Ellipsis)]\n                        result = TensorCollection(result, covariant=False, tensor_rank=result.ndim-coplanar.ndim, copy=False)\n                    else:\n                        result = TensorCollection(array[indices + (slice(None),) + i[1:]], copy=False)\n\n            elif intersect_lines or n == 4:\n                # can\'t intersect lines that are not coplanar and can\'t join skew lines in 3D\n                raise NotCoplanar(""The given lines are not all coplanar."")\n            elif np.any(coplanar) and (isinstance(a, TensorCollection) or isinstance(b, TensorCollection)):\n                raise GeometryException(""Can only join tensors that are either all coplanar or all not coplanar."")\n\n        else:\n            # TODO: intersect arbitrary subspaces (use GA)\n            raise ValueError(""Operation not supported."")\n\n    else:\n        raise ValueError(""Wrong number of arguments."")\n\n    if np.any(result.is_zero()):\n        raise LinearDependenceError(""Arguments are not linearly independent."")\n\n    if isinstance(result, TensorCollection):\n\n        axes = tuple(result._covariant_indices) + tuple(result._contravariant_indices)\n        result.array = result.array / np.max(np.abs(result.array), axis=axes, keepdims=True)\n\n        if result.tensor_shape == (0, 1):\n            return LineCollection(result, copy=False) if n == 3 else PlaneCollection(result, copy=False)\n        if result.tensor_shape == (1, 0):\n            return PointCollection(result, copy=False)\n        if result.tensor_shape == (2, 0):\n            return LineCollection(result, copy=False).contravariant_tensor\n        if result.tensor_shape == (0, n - 2):\n            return LineCollection(result, copy=False)\n\n        return SubspaceCollection(result, copy=False)\n\n    # normalize result to avoid large values\n    result.array = result.array / np.max(np.abs(result.array))\n\n    if result.tensor_shape == (0, 1):\n        return Line(result, copy=False) if n == 3 else Plane(result, copy=False)\n    if result.tensor_shape == (1, 0):\n        return Point(result, copy=False)\n    if result.tensor_shape == (2, 0):\n        return Line(result, copy=False).contravariant_tensor\n    if result.tensor_shape == (0, n-2):\n        return Line(result, copy=False)\n\n    return Subspace(result, copy=False)\n\n\ndef join(*args):\n    """"""Joins a number of objects to form a line, plane or subspace.\n\n    Parameters\n    ----------\n    *args\n        Objects to join, e.g. 2 points, lines, a point and a line or 3 points.\n\n    Returns\n    -------\n    Subspace or SubspaceCollection\n        The resulting line, plane or subspace.\n\n    """"""\n    return _join_meet_duality(*args, intersect_lines=False)\n\n\ndef meet(*args):\n    """"""Intersects a number of given objects.\n\n    Parameters\n    ----------\n    *args\n        Objects to intersect, e.g. two lines, planes, a plane and a line or 3 planes.\n\n    Returns\n    -------\n    Point, PointCollection, Subspace or SubspaceCollection\n        The resulting point, line or subspace.\n\n    """"""\n    return _join_meet_duality(*args, intersect_lines=True)\n\n\nclass Point(ProjectiveElement):\n    """"""Represents points in a projective space of arbitrary dimension.\n\n    The number of supplied coordinates determines the dimension of the space that the point lives in.\n    If the coordinates are given as arguments (not in a single iterable), the coordinates will automatically be\n    transformed into homogeneous coordinates, i.e. a one added as an additional coordinate.\n\n    Addition and subtraction of finite and infinite points will always give a finite result if one of the points\n    was finite beforehand.\n\n    Parameters\n    ----------\n    *args\n        A single iterable object or tensor or multiple (affine) coordinates.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        if np.isscalar(args[0]):\n            super(Point, self).__init__(*args, 1, **kwargs)\n        else:\n            super(Point, self).__init__(*args, **kwargs)\n\n    def __add__(self, other):\n        if isinstance(other, PointCollection):\n            return NotImplemented\n        if not isinstance(other, Point):\n            return super(Point, self).__add__(other)\n        a, b = self.normalized_array, other.normalized_array\n        result = a[:-1] + b[:-1]\n        result = np.append(result, max(a[-1], b[-1]))\n        return Point(result, copy=False)\n\n    def __sub__(self, other):\n        if isinstance(other, PointCollection):\n            return NotImplemented\n        if not isinstance(other, Point):\n            return super(Point, self).__sub__(other)\n        a, b = self.normalized_array, other.normalized_array\n        result = a[:-1] - b[:-1]\n        result = np.append(result, max(a[-1], b[-1]))\n        return Point(result, copy=False)\n\n    def __mul__(self, other):\n        if not np.isscalar(other):\n            return super(Point, self).__mul__(other)\n        result = self.normalized_array[:-1] * other\n        result = np.append(result, self.array[-1] and 1)\n        return Point(result, copy=False)\n\n    def __truediv__(self, other):\n        if not np.isscalar(other):\n            return super(Point, self).__truediv__(other)\n        result = self.normalized_array[:-1] / other\n        result = np.append(result, self.array[-1] and 1)\n        return Point(result, copy=False)\n\n    def __repr__(self):\n        return ""Point({})"".format("", "".join(self.normalized_array[:-1].astype(str))) + ("" at Infinity"" if self.isinf else """")\n\n    @property\n    def normalized_array(self):\n        """"""numpy.ndarray: The normalized coordinates as array.""""""\n        if self.isinf:\n            return np.real_if_close(self.array)\n        return np.real_if_close(self.array / self.array[-1])\n\n    @property\n    def lie_coordinates(self):\n        """"""Point: The Lie coordinates of a point in 2D.""""""\n        x = self.normalized_array[:-1]\n        return Point([(1+x.dot(x))/2, (1-x.dot(x))/2, x[0], x[1], 0])\n\n    def join(self, *others):\n        """"""Execute the join of this point with other objects.\n\n        Parameters\n        ----------\n        *others\n            The objects to join the point with.\n\n        Returns\n        -------\n        Subspace\n            The result of the join operation.\n\n        See Also\n        --------\n        join\n\n        """"""\n        return join(self, *others)\n\n    @property\n    def isinf(self):\n        return np.isclose(self.array[-1], 0, atol=EQ_TOL_ABS)\n\n\nI = Point([-1j, 1, 0])\nJ = Point([1j, 1, 0])\n\n\nclass Subspace(ProjectiveElement):\n    """"""Represents a general subspace of a projective space. Line and Plane are subclasses.\n\n    Parameters\n    ----------\n    *args\n        The coordinates of the subspace. Instead of separate coordinates, a single iterable can be supplied.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault(""covariant"", False)\n        super(Subspace, self).__init__(*args, **kwargs)\n\n    def __add__(self, other):\n        if not isinstance(other, Point):\n            return super(Subspace, self).__add__(other)\n\n        from .transformation import translation\n        return translation(other).apply(self)\n\n    def __sub__(self, other):\n        return self + (-other)\n\n    @property\n    def basis_matrix(self):\n        """"""numpy.ndarray: A matrix with orthonormal basis vectors as rows.""""""\n        x = self.array\n        if x.ndim > 2:\n            x = self.array.reshape(-1, x.shape[-1])\n        return null_space(x, self.shape[-1]-self.rank).T\n\n    @property\n    def general_point(self):\n        """"""Point: A point in general position i.e. not in the subspace, to be used in geometric constructions.""""""\n        n = self.dim + 1\n        p = Point(np.zeros(n, dtype=int), copy=False)\n        for i in range(n):\n            p[-i - 1] = 1\n            if not self.contains(p):\n                return p\n\n    def contains(self, other, tol=EQ_TOL_ABS):\n        """"""Tests whether a given point or line lies in the subspace.\n\n        Parameters\n        ----------\n        other : Point or Line\n            The object to test.\n        tol : float, optional\n            The accepted tolerance.\n\n        Returns\n        -------\n        bool\n            True, if the given point/line lies in the subspace.\n\n        """"""\n        if isinstance(other, (Point, PointCollection)):\n            result = self * other\n\n        elif isinstance(other, (Line, LineCollection)):\n            result = self * other.covariant_tensor\n\n        else:\n            # TODO: test subspace\n            raise ValueError(""argument of type %s not supported"" % type(other))\n\n        axes = tuple(result._covariant_indices) + tuple(result._contravariant_indices)\n        return np.all(np.isclose(result.array, 0, atol=tol), axis=axes)\n\n    def meet(self, *others):\n        """"""Intersect the subspace with other objects.\n\n        Parameters\n        ----------\n        *others\n            The objects to intersect the subspace with.\n\n        Returns\n        -------\n        Point or Subspace\n            The result of the meet operation.\n\n        See Also\n        --------\n        meet\n\n        """"""\n        return meet(self, *others)\n\n    def join(self, *others):\n        """"""Execute the join of the subspace with other objects.\n\n        Parameters\n        ----------\n        *others\n            The objects to join the subspace with.\n\n        Returns\n        -------\n        Subspace\n            The result of the join operation.\n\n        See Also\n        --------\n        join\n\n        """"""\n        return join(self, *others)\n\n    def parallel(self, through):\n        """"""Returns the subspace through a given point that is parallel to this subspace.\n\n        Parameters\n        ----------\n        through : Point\n            The point through which the parallel subspace is to be constructed.\n\n        Returns\n        -------\n        Subspace\n            The parallel subspace.\n\n        """"""\n        x = self.meet(infty_hyperplane(self.dim))\n        return join(x, through)\n\n    def is_parallel(self, other):\n        """"""Tests whether a given subspace is parallel to this subspace.\n\n        Parameters\n        ----------\n        other : Subspace\n            The other space to test.\n\n        Returns\n        -------\n        bool\n            True, if the two spaces are parallel.\n\n        """"""\n        x = self.meet(other)\n        return infty_hyperplane(self.dim).contains(x)\n\n\nclass Line(Subspace):\n    """"""Represents a line in a projective space of arbitrary dimension.\n\n    Parameters\n    ----------\n    *args\n        Two points or the coordinates of the line. Instead of all coordinates separately, a single iterable can also\n        be supplied.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        if len(args) == 2:\n            kwargs[""copy""] = False\n            super(Line, self).__init__(join(*args), **kwargs)\n        else:\n            super(Line, self).__init__(*args, **kwargs)\n\n    @property\n    def covariant_tensor(self):\n        """"""Line: The covariant version of a line in 3D.""""""\n        if self.tensor_shape[0] > 0:\n            return self\n        e = LeviCivitaTensor(4)\n        diagram = TensorDiagram((e, self), (e, self))\n        return Line(diagram.calculate(), copy=False)\n\n    @property\n    def contravariant_tensor(self):\n        """"""Line: The contravariant version of a line in 3D.""""""\n        if self.tensor_shape[1] > 0:\n            return self\n        e = LeviCivitaTensor(4, False)\n        diagram = TensorDiagram((self, e), (self, e))\n        return Line(diagram.calculate(), copy=False)\n\n    def is_coplanar(self, other):\n        """"""Tests whether another line lies in the same plane as this line, i.e. whether two lines intersect.\n\n        Parameters\n        ----------\n        other : Line\n            A line in 3D to test.\n\n        Returns\n        -------\n        bool\n            True if the two lines intersect (i.e. they lie in the same plane).\n\n        References\n        ----------\n        .. [1] Jim Blinn, Lines in Space: Back to the Diagrams, Line Intersections\n\n        """"""\n        if self.dim == 2:\n            return True\n\n        e = LeviCivitaTensor(self.dim + 1)\n        d = TensorDiagram(*[(e, self)]*(self.dim - 1), *[(e, other)]*(self.dim - 1))\n        return d.calculate() == 0\n\n    def perpendicular(self, through):\n        """"""Construct the perpendicular line though a point.\n\n        Parameters\n        ----------\n        through : Point\n            The point through which the perpendicular is constructed.\n\n        Returns\n        -------\n        Line\n            The perpendicular line.\n\n        """"""\n        if self.contains(through):\n            n = self.dim + 1\n\n            l = self\n\n            if n > 3:\n                # additional point is required to determine the exact line\n                e = join(self, self.general_point)\n\n                basis = e.basis_matrix\n                line_pts = basis.dot(self.basis_matrix.T)\n                l = Line(np.cross(*line_pts.T), copy=False)\n\n            from .operators import harmonic_set\n            p = l.meet(infty)\n            q = harmonic_set(I, J, p)\n\n            if n > 3:\n                q = Point(basis.T.dot(q.array), copy=False)\n\n            return Line(through, q)\n\n        return self.mirror(through).join(through)\n\n    def project(self, pt):\n        """"""The orthogonal projection of a point onto the line.\n\n        Parameters\n        ----------\n        pt : Point\n            The point to project.\n\n        Returns\n        -------\n        Point\n            The projected point.\n\n        """"""\n        l = self.perpendicular(pt)\n        return self.meet(l)\n\n    @property\n    def base_point(self):\n        """"""Point: A base point for the line, arbitrarily chosen.""""""\n        if self.dim > 2:\n            base = self.basis_matrix\n            p, q = Point(base[0, :], copy=False), Point(base[1, :], copy=False)\n            if p.isinf:\n                return q\n            return p\n\n        if np.isclose(self.array[2], 0, atol=EQ_TOL_ABS):\n            return Point(0, 0)\n\n        if not np.isclose(self.array[1], 0, atol=EQ_TOL_ABS):\n            return Point([0, -self.array[2], self.array[1]])\n\n        return Point([self.array[2], 0, -self.array[0]])\n\n    @property\n    def direction(self):\n        """"""Point: The direction of the line (not normalized).""""""\n        if self.dim > 2:\n            base = self.basis_matrix\n            p, q = Point(base[0, :], copy=False), Point(base[1, :], copy=False)\n            if p.isinf:\n                return p\n            if q.isinf:\n                return q\n            return Point(p.normalized_array - q.normalized_array, copy=False)\n\n        if np.isclose(self.array[0], 0, atol=EQ_TOL_ABS) and np.isclose(self.array[1], 0, atol=EQ_TOL_ABS):\n            return Point([0, 1, 0])\n\n        return Point([self.array[1], -self.array[0], 0])\n\n    @property\n    def basis_matrix(self):\n        """"""numpy.ndarray: A matrix with orthonormal basis vectors as rows.""""""\n        if self.dim == 2:\n            a = self.base_point.array\n            b = np.cross(self.array, a)\n            return np.array([a / np.linalg.norm(a), b / np.linalg.norm(b)])\n        return super(Line, self).basis_matrix\n\n    @property\n    def lie_coordinates(self):\n        """"""Point: The Lie coordinates of a line in 2D.""""""\n        g = self.array\n        return Point([-g[2], g[2], g[0], g[1], np.sqrt(g[:2].dot(g[:2]))])\n\n    def mirror(self, pt):\n        """"""Construct the reflection of a point at this line.\n\n        Parameters\n        ----------\n        pt : Point\n            The point to reflect.\n\n        Returns\n        -------\n        Point\n            The mirror point.\n\n        References\n        ----------\n        .. [1] J. Richter-Gebert: Perspectives on Projective Geometry, Section 19.1\n\n        """"""\n        l = self\n        if self.dim >= 3:\n            e = join(self, pt)\n            m = e.basis_matrix\n            m = m[np.argsort(np.abs(m.dot(pt.array)))]\n            pt = Point(m.dot(pt.array))\n            a, b = m.dot(self.basis_matrix.T).T\n            l = Line(Point(a), Point(b))\n        l1 = I.join(pt)\n        l2 = J.join(pt)\n        p1 = l.meet(l1)\n        p2 = l.meet(l2)\n        m1 = p1.join(J)\n        m2 = p2.join(I)\n        result = m1.meet(m2)\n        if self.dim >= 3:\n            return Point(m.T.dot(result.array))\n        return result\n\n\ninfty = Line(0, 0, 1)\n\n\nclass Plane(Subspace):\n    """"""Represents a hyperplane in a projective space of arbitrary dimension.\n\n    Parameters\n    ----------\n    *args\n        The points/lines spanning the plane or the coordinates of the hyperplane. Instead of separate coordinates, a\n        single iterable can be supplied.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        if all(isinstance(o, (Line, Point)) for o in args):\n            kwargs[""copy""] = False\n            super(Plane, self).__init__(join(*args), **kwargs)\n        else:\n            super(Plane, self).__init__(*args, **kwargs)\n\n    @property\n    def basis_matrix(self):\n        """"""numpy.ndarray: A matrix with orthonormal basis vectors as rows.""""""\n        n = self.dim + 1\n        i = self.array.nonzero()[0][0]\n        result = np.zeros((n, n - 1), dtype=self.dtype)\n        a = [j for j in range(n) if j != i]\n        result[i, :] = self.array[a]\n        result[a, range(n - 1)] = -self.array[i]\n        q, r = np.linalg.qr(result)\n        return q.T\n\n    def __repr__(self):\n        return ""Plane({})"".format("","".join(self.array.astype(str)))\n\n    def mirror(self, pt):\n        """"""Construct the reflection of a point at this plane.\n\n        Only works in 3D.\n\n        Parameters\n        ----------\n        pt : Point\n            The point to reflect.\n\n        Returns\n        -------\n        Point\n            The mirror point.\n\n        """"""\n        l = self.meet(infty_plane)\n        l = Line(np.cross(*l.basis_matrix[:, :-1]), copy=False)\n        p = l.base_point\n        polar = Line(p.array, copy=False)\n\n        from .curve import absolute_conic\n        tangent_points = absolute_conic.intersect(polar)\n        tangent_points = [Point(np.append(p.array, 0)) for p in tangent_points]\n\n        l1 = tangent_points[0].join(pt)\n        l2 = tangent_points[1].join(pt)\n        p1 = self.meet(l1)\n        p2 = self.meet(l2)\n        m1 = p1.join(tangent_points[1])\n        m2 = p2.join(tangent_points[0])\n        return m1.meet(m2)\n\n    def project(self, pt):\n        """"""The orthogonal projection of a point onto the plane.\n\n        Only works in 3D.\n\n        Parameters\n        ----------\n        pt : Point\n            The point to project.\n\n        Returns\n        -------\n        Point\n            The projected point.\n\n        """"""\n        l = self.perpendicular(pt)\n        return self.meet(l)\n\n    def perpendicular(self, through):\n        """"""Construct the perpendicular line though a point.\n\n        Only works in 3D.\n\n        Parameters\n        ----------\n        through : Point\n            The point through which the perpendicular is constructed.\n\n        Returns\n        -------\n        Line\n            The perpendicular line.\n\n        """"""\n        if self.contains(through):\n            l = self.meet(infty_plane)\n            l = Line(np.cross(*l.basis_matrix[:, :-1]), copy=False)\n            p1, p2 = [Point(a) for a in l.basis_matrix]\n            polar1 = Line(p1.array, copy=False)\n            polar2 = Line(p2.array, copy=False)\n\n            from .curve import absolute_conic\n            tangent_points1 = absolute_conic.intersect(polar1)\n            tangent_points2 = absolute_conic.intersect(polar2)\n\n            from .operators import harmonic_set\n            q1, q2 = harmonic_set(*tangent_points1, l.meet(polar1)), harmonic_set(*tangent_points2, l.meet(polar2))\n            m1, m2 = p1.join(q1), p2.join(q2)\n\n            p = m1.meet(m2)\n            p = Point(np.append(p.array, 0))\n\n            return through.join(p)\n\n        return self.mirror(through).join(through)\n\n\ndef infty_hyperplane(dimension):\n    if dimension == 2:\n        return infty\n    return Plane([0] * dimension + [1])\n\n\ninfty_plane = infty_hyperplane(3)\n\n\nclass PointCollection(ProjectiveCollection):\n    """"""A collection of points.\n\n    Parameters\n    ----------\n    elements : array_like\n        A (nested) sequence of points or a numpy array that contains the coordinates of multiple points.\n    homogenize : bool, optional\n        If True, all points in the array will be converted to homogeneous coordinates, i.e. 1 will be added to\n        the coordinates of each point in elements. By default homogenize is False.\n\n    """"""\n    _element_class = Point\n\n    def __init__(self, elements, *, homogenize=False, **kwargs):\n        super(PointCollection, self).__init__(elements, **kwargs)\n        if homogenize is True:\n            self.array = np.append(self.array, np.ones(self.shape[:-1] + (1,), self.dtype), axis=-1)\n\n    def __add__(self, other):\n        if not isinstance(other, (Point, PointCollection)):\n            return super(PointCollection, self).__add__(other)\n        a, b = self.normalized_array, other.normalized_array\n        result = a[..., :-1] + b[..., :-1]\n        result = np.append(result, np.maximum(a[..., -1:], b[..., -1:]), axis=-1)\n        return PointCollection(result, copy=False)\n\n    def __sub__(self, other):\n        if not isinstance(other, (Point, PointCollection)):\n            return super(PointCollection, self).__add__(other)\n        a, b = self.normalized_array, other.normalized_array\n        result = a[..., :-1] - b[..., :-1]\n        result = np.append(result, np.maximum(a[..., -1:], b[..., -1:]), axis=-1)\n        return PointCollection(result, copy=False)\n\n    def __mul__(self, other):\n        if not np.isscalar(other):\n            return super(PointCollection, self).__mul__(other)\n        result = self.normalized_array[..., :-1] * other\n        result = np.append(result, self.array[..., -1:] != 0, axis=-1)\n        return PointCollection(result, copy=False)\n\n    def __truediv__(self, other):\n        if not np.isscalar(other):\n            return super(PointCollection, self).__truediv__(other)\n        result = self.normalized_array[..., :-1] / other\n        result = np.append(result, self.array[..., -1:] != 0, axis=-1)\n        return PointCollection(result, copy=False)\n\n    def join(self, *others):\n        return join(self, *others)\n\n    def __getitem__(self, index):\n        result = super(PointCollection, self).__getitem__(index)\n\n        if not isinstance(result, TensorCollection) or result.tensor_shape != (1, 0):\n            return result\n\n        return PointCollection(result, copy=False)\n\n    def __repr__(self):\n        return ""{}({})"".format(self.__class__.__name__, str(self.normalized_array.tolist()))\n\n    @staticmethod\n    def _normalize_array(array):\n        isinf = np.isclose(array[..., -1], 0, atol=EQ_TOL_ABS)\n        result = array.astype(np.complex128)\n        result[~isinf] /= array[~isinf, -1, None]\n        return np.real_if_close(result)\n\n    @property\n    def normalized_array(self):\n        return self._normalize_array(self.array)\n\n\nclass SubspaceCollection(ProjectiveCollection):\n    """"""A collection of subspaces.\n\n    Parameters\n    ----------\n    elements : array_like\n        A sequence of Subspace objects, a numpy array, a Tensor or a (nested) sequence of numbers.\n    tensor_rank : int, optional\n        The rank of the tensors contained in the collection. Default is 1.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n    _element_class = Subspace\n\n    def __init__(self, elements, *, tensor_rank=1, **kwargs):\n        super(SubspaceCollection, self).__init__(elements, covariant=False, tensor_rank=tensor_rank, **kwargs)\n\n    def meet(self, other):\n        return meet(self, other)\n\n    def join(self, *others):\n        return join(self, *others)\n\n    def __getitem__(self, index):\n        result = super(SubspaceCollection, self).__getitem__(index)\n\n        if not isinstance(result, TensorCollection) or result.tensor_shape == (0, 0):\n            return result\n\n        return SubspaceCollection(result, copy=False)\n\n    @property\n    def basis_matrix(self):\n        x = self.array\n        x = x.reshape(x.shape[:len(self._collection_indices)] + (-1, x.shape[-1]))\n        return np.swapaxes(null_space(x, self.shape[-1]-self.rank+len(self._collection_indices)), -1, -2)\n\n    def contains(self, other, tol=EQ_TOL_ABS):\n        if isinstance(other, (Point, PointCollection)):\n            result = self * other\n\n        elif isinstance(other, (Line, LineCollection)):\n            result = self * other.covariant_tensor\n\n        else:\n            # TODO: test subspace\n            raise ValueError(""argument of type %s not supported"" % type(other))\n\n        axes = tuple(result._covariant_indices) + tuple(result._contravariant_indices)\n        return np.all(np.isclose(result.array, 0, atol=tol), axis=axes)\n\n\nclass LineCollection(SubspaceCollection):\n    """"""A collection of lines.\n\n    Parameters\n    ----------\n    *args\n        Two collections of points or a (nested) sequence of line coordinates.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n    _element_class = Line\n\n    def __init__(self, *args, **kwargs):\n        if len(args) == 2:\n            kwargs[""copy""] = False\n            super(LineCollection, self).__init__(join(*args), tensor_rank=-2, **kwargs)\n        else:\n            super(LineCollection, self).__init__(*args, tensor_rank=-2, **kwargs)\n\n    def __getitem__(self, index):\n        result = super(LineCollection, self).__getitem__(index)\n\n        if not isinstance(result, TensorCollection) or result.tensor_shape != (0, self.dim-1):\n            return result\n\n        return LineCollection(result, copy=False)\n\n    @property\n    def covariant_tensor(self):\n        """"""LineCollection: The covariant tensors of lines in 3D.""""""\n        if self.tensor_shape[0] > 0:\n            return self\n        e = LeviCivitaTensor(4)\n        diagram = TensorDiagram((e, self), (e, self))\n        return LineCollection(diagram.calculate(), copy=False)\n\n    @property\n    def contravariant_tensor(self):\n        """"""LineCollection: The contravariant tensors of lines in 3D.""""""\n        if self.tensor_shape[1] > 0:\n            return self\n        e = LeviCivitaTensor(4, False)\n        diagram = TensorDiagram((self, e), (self, e))\n        return LineCollection(diagram.calculate(), copy=False)\n\n\nclass PlaneCollection(SubspaceCollection):\n    """"""A collection of planes.\n\n    Parameters\n    ----------\n    *args\n        The collections of points/lines spanning the planes or the coordinates of multiple hyperplanes.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n    _element_class = Plane\n\n    def __init__(self, *args, **kwargs):\n        if len(args) > 1:\n            kwargs[""copy""] = False\n            super(PlaneCollection, self).__init__(join(*args), **kwargs)\n        else:\n            super(PlaneCollection, self).__init__(*args, **kwargs)\n\n    def __getitem__(self, index):\n        result = super(PlaneCollection, self).__getitem__(index)\n\n        if not isinstance(result, TensorCollection) or result.tensor_shape != (0, 1):\n            return result\n\n        return PlaneCollection(result, copy=False)\n'"
geometer/shapes.py,36,"b'from itertools import combinations\n\nimport numpy as np\n\nfrom .base import EQ_TOL_ABS, EQ_TOL_REL\nfrom .utils import distinct, is_multiple, det\nfrom .point import Line, Plane, Point, PointCollection, infty_hyperplane, join\nfrom .transformation import rotation, translation\nfrom .operators import dist, angle, harmonic_set, crossratio\nfrom .exceptions import NotCoplanar, LinearDependenceError\n\n\ndef _general_direction(points, planes):\n    # build array of directions for point in polygon problem\n\n    points, planes = np.broadcast_arrays(points.array, planes.array)\n\n    direction = np.zeros(points.shape, planes.dtype)\n    ind = np.isclose(planes[..., 0], 0, atol=EQ_TOL_ABS)\n    direction[ind, 0] = 1\n    direction[~ind, 0] = planes[~ind, 1]\n    direction[~ind, 1] = -planes[~ind, 0]\n\n    ind = is_multiple(direction, points, axis=-1)\n    direction[ind, 0] = 0\n    ind2 = np.isclose(planes[..., 1], 0, atol=EQ_TOL_ABS)\n    direction[ind & ind2, 1] = 1\n    ind = ind & ~ind2\n    direction[ind, 1] = planes[ind, 2]\n    direction[ind, 2] = -planes[ind, 1]\n\n    return direction / np.linalg.norm(direction[..., :-1], axis=-1, keepdims=True)\n\n\nclass Polytope(PointCollection):\n    """"""A class representing polytopes in arbitrary dimension. A (n+1)-polytope is a collection of n-polytopes that\n    have some (n-1)-polytopes in common, where 3-polytopes are polyhedra, 2-polytopes are polygons and 1-polytopes are\n    line segments.\n\n    The polytope is stored as a multidimensional numpy array. Hence, all facets of the polytope must have the same\n    number of vertices and facets.\n\n    Parameters\n    ----------\n    *args\n        The polytopes defining the facets ot the polytope.\n\n    Attributes\n    ----------\n    array : numpy.ndarray\n        The underlying numpy array.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        super(Polytope, self).__init__(args[0] if len(args) == 1 else args, **kwargs)\n\n    def __repr__(self):\n        return ""{}({})"".format(self.__class__.__name__, "", "".join(str(v) for v in self.vertices))\n\n    @property\n    def vertices(self):\n        """"""list of Point: The vertices of the polytope.""""""\n        return list(distinct(self.flat))\n\n    @property\n    def facets(self):\n        """"""list of Polytope: The facets of the polytope.""""""\n        return list(self)\n\n    @property\n    def _edges(self):\n        v1 = self.array\n        v2 = np.roll(v1, -1, axis=-2)\n        return np.stack([v1, v2], axis=-2)\n\n    def __eq__(self, other):\n        if isinstance(other, Polytope):\n\n            if self.shape != other.shape:\n                return False\n\n            if self.rank > 2:\n                # facets equal up to reordering\n                facets1 = self.facets\n                facets2 = other.facets\n                return all(f in facets2 for f in facets1) and all(f in facets1 for f in facets2)\n\n            # edges equal up to circular reordering\n            edges1 = self._edges\n            edges2 = other._edges\n\n            for i in range(self.shape[0]):\n                if np.all(is_multiple(edges1, np.roll(edges2, i, axis=0), axis=-1, rtol=EQ_TOL_REL, atol=EQ_TOL_ABS)):\n                    return True\n\n            return False\n\n        return super(Polytope, self).__eq__(other)\n\n    def __add__(self, other):\n        if not isinstance(other, Point):\n            return super(Polytope, self).__add__(other)\n        return translation(other) * self\n\n    def __sub__(self, other):\n        return self + (-other)\n\n    def __getitem__(self, index):\n        result = super(Polytope, self).__getitem__(index)\n\n        if not isinstance(result, PointCollection):\n            return result\n\n        if result.rank == 2:\n            if len(result) == 2:\n                return Segment(result, copy=False)\n            if len(result) == 3:\n                return Triangle(result, copy=False)\n\n            try:\n                return Polygon(result, copy=False)\n            except NotCoplanar:\n                return Polytope(result, copy=False)\n\n        if result.rank == 3:\n            return Polyhedron(result)\n\n        return Polytope(result, copy=False)\n\n\nclass Segment(Polytope):\n    """"""Represents a line segment in an arbitrary projective space.\n\n    As a (real) projective line is homeomorphic to a circle, there are two line segments that connect two points. An\n    instance of this class will represent the finite segment connecting the two points, if there is one, and the segment\n    in the direction of the infinite point otherwise (identifying only scalar multiples by positive scalar factors).\n    When both points are at infinity, the points will be considered in the oriented projective space to define the\n    segment between them.\n\n    Segments with one point at infinity represent rays/half-lines in a traditional sense.\n\n    Parameters\n    ----------\n    *args\n        The start and endpoint of the line segment, either as two Point objects or a single coordinate array.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        super(Segment, self).__init__(*args, **kwargs)\n        self._line = Line(Point(self.array[0], copy=False), Point(self.array[1], copy=False))\n\n    def __apply__(self, transformation):\n        result = super(Segment, self).__apply__(transformation)\n        result._line = Line(Point(result.array[0]), Point(result.array[1]))\n        return result\n\n    @property\n    def _edges(self):\n        return self.array\n\n    def contains(self, other, tol=EQ_TOL_ABS):\n        """"""Tests whether a point is contained in the segment.\n\n        Parameters\n        ----------\n        other : Point\n            The point to test.\n        tol : float, optional\n            The accepted tolerance.\n\n        Returns\n        -------\n        bool\n            True if the point is contained in the segment.\n\n        """"""\n        result = self._line.contains(other)\n\n        if np.isscalar(result) and not result:\n            return False\n\n        m = self.array\n        arr = self.array.dot(m.T)\n\n        p, q = Point(arr[0], copy=False), Point(arr[1], copy=False)\n        d = Point(arr[1] - arr[0], copy=False)\n\n        if isinstance(other, PointCollection):\n            other = np.squeeze(np.matmul(m, np.expand_dims(other.array, -1)), -1)\n            other = PointCollection(other, copy=False)\n        else:\n            other = Point(m.dot(other.array), copy=False)\n\n        cr = crossratio(d, p, q, other)\n\n        return result & (0 <= cr + tol) & (cr <= 1 + tol)\n\n    def intersect(self, other):\n        """"""Intersect the line segment with another object.\n\n        Parameters\n        ----------\n        other : Line, Plane, Segment, Polygon or Polyhedron\n            The object to intersect the line segment with.\n\n        Returns\n        -------\n        list of Point\n            The points of intersection.\n\n        """"""\n        if isinstance(other, (Line, Plane)):\n            try:\n                pt = other.meet(self._line)\n            except (LinearDependenceError, NotCoplanar):\n                return []\n            return [pt] if self.contains(pt) else []\n\n        if isinstance(other, Segment):\n            if self._line == other._line:\n                return []\n\n            i = other.intersect(self._line)\n            return i if i and self.contains(i[0]) else []\n\n        if isinstance(other, (Polygon, Polyhedron)):\n            return other.intersect(self)\n\n    @property\n    def midpoint(self):\n        """"""Point: The midpoint of the segment.""""""\n        l = self._line.meet(infty_hyperplane(self.dim))\n        return harmonic_set(*self.vertices, l)\n\n    @property\n    def length(self):\n        """"""float: The length of the segment.""""""\n        return dist(*self.vertices)\n\n\nclass Simplex(Polytope):\n    """"""Represents a simplex in any dimension, i.e. a k-polytope with k+1 vertices where k is the dimension.\n\n    The simplex determined by k+1 points is given by the convex hull of these points.\n\n    Parameters\n    ----------\n    *args\n        The points that are the vertices of the simplex.\n\n    """"""\n\n    def __new__(cls, *args, **kwargs):\n        if len(args) == 2:\n            return Segment(*args, **kwargs)\n\n        return super(Polytope, cls).__new__(cls)\n\n    def __init__(self, *args, **kwargs):\n        if len(args) > 3:\n            args = [Simplex(*x) for x in combinations(args, len(args)-1)]\n        super(Simplex, self).__init__(*args, **kwargs)\n\n    @property\n    def volume(self):\n        """"""float: The volume of the simplex, calculated using the Cayley\xe2\x80\x93Menger determinant.""""""\n        points = np.concatenate([v.array.reshape((1, v.shape[0])) for v in self.vertices], axis=0)\n        points = self._normalize_array(points)\n        n, k = points.shape\n\n        if n == k:\n            return 1 / np.math.factorial(n-1) * abs(det(points))\n\n        indices = np.triu_indices(n)\n        distances = points[indices[0]] - points[indices[1]]\n        distances = np.sum(distances**2, axis=1)\n        m = np.zeros((n+1, n+1), dtype=distances.dtype)\n        m[indices] = distances\n        m += m.T\n        m[-1, :-1] = 1\n        m[:-1, -1] = 1\n\n        return np.sqrt((-1)**n/(np.math.factorial(n-1)**2 * 2**(n-1)) * det(m))\n\n\nclass Polygon(Polytope):\n    """"""A flat polygon with vertices in any dimension.\n\n    Parameters\n    ----------\n    *args\n        The coplanar points that are the vertices of the polygon. They will be connected sequentially by line segments.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        if all(isinstance(x, Segment) for x in args):\n            args = (np.array([s.array[0] for s in args]),)\n            kwargs[\'copy\'] = False\n        super(Polygon, self).__init__(*args, **kwargs)\n        self._plane = Plane(*self.vertices[:self.dim]) if self.dim > 2 else None\n\n    def __apply__(self, transformation):\n        result = super(Polygon, self).__apply__(transformation)\n        if result.dim > 2:\n            result._plane = Plane(*result.vertices[:result.dim])\n        return result\n\n    @property\n    def vertices(self):\n        return [Point(x) for x in self.array]\n\n    @property\n    def facets(self):\n        return list(self.edges)\n\n    @property\n    def edges(self):\n        """"""SegmentCollection: The edges of the polygon.""""""\n        return SegmentCollection(self._edges, copy=False)\n\n    def contains(self, other):\n        """"""Tests whether a point is contained in the polygon.\n\n        Parameters\n        ----------\n        other : Point or PointCollection\n            The point to test.\n\n        Returns\n        -------\n        array_like\n            True if the point is contained in the polygon.\n\n        """"""\n        if self.dim > 2:\n            result = self._plane.contains(other)\n            if isinstance(other, Point) and not result:\n                return result\n            direction = _general_direction(other, self._plane)\n        else:\n            result = True\n            direction = [1, 0, 0]\n\n        edges = self.edges\n\n        if isinstance(other, PointCollection):\n            direction = PointCollection(direction, copy=False)\n            ray = SegmentCollection(other, direction).expand_dims(-3)\n        else:\n            ray = Segment(np.stack([other.array, direction], axis=-2), copy=False)\n\n        edge_intersections = edges._line.meet(ray._line)\n\n        ind = edges.contains(edge_intersections)\n        ind = ind & ray.contains(edge_intersections)\n        ind = np.sum(ind, axis=-1) % 2 == 1\n\n        return result & ind\n\n    def intersect(self, other):\n        """"""Intersect the polygon with another object.\n\n        Parameters\n        ----------\n        other : Line or Segment\n            The object to intersect the polygon with.\n\n        Returns\n        -------\n        list of Point\n            The points of intersection.\n\n        """"""\n        if self.dim > 2:\n\n            if isinstance(other, Line):\n                try:\n                    p = self._plane.meet(other)\n                except LinearDependenceError:\n                    return []\n                return [p] if self.contains(p) else []\n\n            if isinstance(other, Segment):\n                if self._plane.contains(other._line):\n                    return []\n\n                i = other.intersect(self._plane)\n                return i if i and self.contains(i[0]) else []\n\n        intersections = self.edges.intersect(other)\n        return list(distinct(intersections))\n\n    def _normalized_projection(self):\n        points = self.array\n\n        if self.dim > 2:\n            e = self._plane\n            o = Point(*[0] * self.dim)\n            if not e.contains(o):\n                # use parallel hyperplane for projection to avoid rescaling\n                e = e.parallel(o)\n            m = e.basis_matrix\n            points = points.dot(m.T)\n\n        return self._normalize_array(points)\n\n    @property\n    def area(self):\n        """"""float: The area of the polygon.""""""\n        points = self._normalized_projection()\n        a = sum(det(points[[0, i, i + 1]]) for i in range(1, points.shape[0] - 1))\n        return 1/2 * abs(a)\n\n    @property\n    def centroid(self):\n        """"""Point: The centroid (center of mass) of the polygon.""""""\n        points = self.normalized_array\n        centroids = [np.average(points[[0, i, i + 1], :-1], axis=0) for i in range(1, points.shape[0] - 1)]\n        weights = [det(self._normalized_projection()[[0, i, i + 1]])/2 for i in range(1, points.shape[0] - 1)]\n        return Point(*np.average(centroids, weights=weights, axis=0))\n\n    @property\n    def angles(self):\n        """"""list of float: The interior angles of the polygon.""""""\n        result = []\n        a = self.edges[-1]\n        for b in self.edges:\n            result.append(angle(a.vertices[1], a.vertices[0], b.vertices[1]))\n            a = b\n\n        return result\n\n\nclass RegularPolygon(Polygon):\n    """"""A class that can be used to construct regular polygon from a radius and a center point.\n\n    Parameters\n    ----------\n    center : Point\n        The center of the polygon.\n    radius : float\n        The distance from the center to the vertices of the polygon.\n    n : int\n        The number of vertices of the regular polygon.\n    axis : Point, optional\n        If constructed in higher-dimensional spaces, an axis vector is required to orient the polygon.\n\n    """"""\n\n    def __init__(self, center, radius, n, axis=None, **kwargs):\n        if axis is None:\n            p = Point(1, 0)\n        else:\n            e = Plane(np.append(axis.array[:-1], [0]), copy=False)\n            p = Point(*e.basis_matrix[0, :-1], copy=False)\n\n        vertex = center + radius*p\n\n        vertices = []\n        for i in range(n):\n            t = rotation(2*np.pi*i / n, axis=axis)\n            t = translation(center) * t * translation(-center)\n            vertices.append(t*vertex)\n\n        super(RegularPolygon, self).__init__(*vertices, **kwargs)\n\n    @property\n    def radius(self):\n        """"""float: The Circumradius of the regular polygon.""""""\n        return dist(self.center, self.vertices[0])\n\n    @property\n    def center(self):\n        """"""Point: The center of the polygon.""""""\n        return Point(*np.sum(self.normalized_array[:, :-1], axis=0))\n\n    @property\n    def inradius(self):\n        """"""float: The inradius of the regular polygon.""""""\n        return dist(self.center, self.edges[0].midpoint)\n\n\nclass Triangle(Polygon, Simplex):\n    """"""A class representing triangles.\n\n    Parameters\n    ----------\n    a : Point\n    b : Point\n    c : Point\n\n    """"""\n    pass\n\n\nclass Rectangle(Polygon):\n    """"""A class representing rectangles.\n\n    Parameters\n    ----------\n    a : Point\n    b : Point\n    c : Point\n    d : Point\n\n    """"""\n    pass\n\n\nclass Polyhedron(Polytope):\n    """"""A class representing polyhedra (3-polytopes).\n\n    """"""\n\n    @property\n    def faces(self):\n        """"""PolygonCollection: The faces of the polyhedron.""""""\n        return PolygonCollection(self.array, copy=False)\n\n    @property\n    def edges(self):\n        """"""list of Segment: The edges of the polyhedron.""""""\n        result = self._edges\n        return list(distinct(Segment(result[idx], copy=False) for idx in np.ndindex(self.shape[:2])))\n\n    @property\n    def area(self):\n        """"""float: The surface area of the polyhedron.""""""\n        return sum(s.area for s in self.faces)\n\n    def intersect(self, other):\n        """"""Intersect the polyhedron with another object.\n\n        Parameters\n        ----------\n        other : Line or Segment\n            The object to intersect the polyhedron with.\n\n        Returns\n        -------\n        list of Point\n            The points of intersection.\n\n        """"""\n        return list(distinct(self.faces.intersect(other)))\n\n\nclass Cuboid(Polyhedron):\n    """"""A class that can be used to construct a cuboid/box or a cube.\n\n    Parameters\n    ----------\n    a : Point\n        The base point of the cuboid.\n    b : Point\n        The vertex that determines the first direction of the edges.\n    c : Point\n        The vertex that determines the second direction of the edges.\n    d : Point\n        The vertex that determines the third direction of the edges.\n\n    """"""\n\n    def __init__(self, a, b, c, d, **kwargs):\n        x, y, z = b-a, c-a, d-a\n        yz = Rectangle(a, a + z, a + y + z, a + y)\n        xz = Rectangle(a, a + x, a + x + z, a + z)\n        xy = Rectangle(a, a + x, a + x + y, a + y)\n        super(Cuboid, self).__init__(yz, xz, xy, yz + x, xz + y, xy + z, **kwargs)\n\n\nclass PolygonCollection(PointCollection):\n    """"""A collection of polygons with the same number of vertices.\n\n    Parameters\n    ----------\n    *args\n        The collections of points that define the vertices of the polygons or a (nested) sequence of vertex coordinates.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        if len(args) > 1:\n            args = tuple(a.array for a in args)\n            args = np.broadcast_arrays(*args)\n            kwargs[\'copy\'] = False\n            super(PolygonCollection, self).__init__(np.stack(args, axis=-2), **kwargs)\n        else:\n            super(PolygonCollection, self).__init__(args[0], **kwargs)\n        self._plane = join(*self.vertices[:self.dim]) if self.dim > 2 else None\n\n    @property\n    def edges(self):\n        """"""SegmentCollection: The edges of the polygons in the collection.""""""\n        v1 = self.array\n        v2 = np.roll(v1, -1, axis=-2)\n        result = np.stack([v1, v2], axis=-2)\n        return SegmentCollection(result, copy=False)\n\n    def __getitem__(self, index):\n        result = super(PolygonCollection, self).__getitem__(index)\n\n        if not isinstance(result, PointCollection):\n            return result\n\n        if result.rank == 2:\n            return Polygon(result, copy=False)\n\n        return PolygonCollection(result, copy=False)\n\n    @property\n    def vertices(self):\n        """"""list of PointCollection: The vertices of the polygons.""""""\n        return [PointCollection(self.array[..., i, :], copy=False) for i in range(self.shape[-2])]\n\n    def expand_dims(self, axis):\n        result = super(PolygonCollection, self).expand_dims(axis)\n        if self.dim > 2:\n            result._plane = result._plane.expand_dims(axis)\n        return result\n\n    def contains(self, other):\n        """"""Tests whether a point or a collection of points is contained in the polygons.\n\n        Parameters\n        ----------\n        other : Point or PointCollection\n            The points to test. If more than one point is given, the shape of the collection must be compatible\n            with the shape of the polygon collection.\n\n        Returns\n        -------\n        numpy.ndarray\n            Returns a boolean array of which points are contained in the polygons.\n\n        """"""\n        if other.shape[0] == 0:\n            return np.empty((0,), dtype=bool)\n\n        if self.dim > 2:\n            result = self._plane.contains(other)\n        else:\n            result = True\n\n        edges = self.edges\n        directions = PointCollection(_general_direction(other, self._plane), copy=False)\n\n        # TODO: only intersect rays where other is contained in the plane\n        rays = SegmentCollection(other, directions).expand_dims(-3)\n        edge_intersections = edges._line.meet(rays._line)\n\n        ind = edges.contains(edge_intersections)\n        ind = ind & rays.contains(edge_intersections)\n        ind = np.sum(ind, axis=-1) % 2 == 1\n\n        return result & ind\n\n    def intersect(self, other):\n        """"""Intersect the polygons with a line, line segment or a collection of lines.\n\n        Parameters\n        ----------\n        other : Line, Segment, LineCollection or SegmentCollection\n            The object to intersect the polygon with.\n\n        Returns\n        -------\n        PointCollection\n            The points of intersection.\n\n        """"""\n        if isinstance(other, (Segment, SegmentCollection)):\n            result = self._plane.meet(other._line)\n            return result[self.contains(result) & other.contains(result)]\n\n        result = self._plane.meet(other)\n        return result[self.contains(result)]\n\n\nclass SegmentCollection(PointCollection):\n    """"""A collection of line segments.\n\n    Parameters\n    ----------\n    *args\n        Two collections of points representing start and endpoints of the line segments or a (nested) sequence of\n        coordinates for the start and endpoints.\n    **kwargs\n        Additional keyword arguments for the constructor of the numpy array as defined in `numpy.array`.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        if len(args) == 2:\n            a, b = args\n            a, b = np.broadcast_arrays(a.array, b.array)\n            kwargs[\'copy\'] = False\n            super(SegmentCollection, self).__init__(np.stack([a, b], axis=-2), **kwargs)\n        else:\n            super(SegmentCollection, self).__init__(args[0] if len(args) == 1 else args, **kwargs)\n\n        self._line = join(*self.vertices)\n\n    def __getitem__(self, index):\n        result = super(SegmentCollection, self).__getitem__(index)\n\n        if not isinstance(result, PointCollection):\n            return result\n\n        if result.rank == 2:\n            return Segment(result, copy=False)\n\n        return SegmentCollection(result, copy=False)\n\n    @property\n    def vertices(self):\n        """"""list of PointCollection: The start and endpoints of the line segments.""""""\n        a = PointCollection(self.array[..., 0, :], copy=False)\n        b = PointCollection(self.array[..., 1, :], copy=False)\n        return [a, b]\n\n    def expand_dims(self, axis):\n        result = super(SegmentCollection, self).expand_dims(axis)\n        result._line = result._line.expand_dims(axis)\n        return result\n\n    def contains(self, other, tol=1e-8):\n        """"""Tests whether a point or a collection of points is contained in the line segments.\n\n        Parameters\n        ----------\n        other : Point or PointCollection\n            The points to test. If more than one point is given, the shape of the collection must be compatible\n            with the shape of the segment collection.\n        tol : float, optional\n            The accepted tolerance.\n\n        Returns\n        -------\n        numpy.ndarray\n            Returns a boolean array of which points are contained in the line segments.\n\n        """"""\n        if other.shape[0] == 0:\n            return np.empty((0,), dtype=bool)\n\n        result = self._line.contains(other)\n\n        m = self.array\n        arr = np.squeeze(np.matmul(np.expand_dims(m, -3), np.expand_dims(self.array, -1)), -1)\n\n        p = PointCollection(arr[..., 0, :], copy=False)\n        q = PointCollection(arr[..., 1, :], copy=False)\n        d = PointCollection(arr[..., 1, :] - arr[..., 0, :], copy=False)\n\n        # TODO: only project points that lie on the lines\n        other = PointCollection(np.squeeze(np.matmul(m, np.expand_dims(other.array, -1)), -1), copy=False)\n\n        cr = crossratio(d, p, q, other)\n\n        return result & (0 <= cr + tol) & (cr <= 1 + tol)\n\n    def intersect(self, other):\n        """"""Intersect the line segments with a line, line segment or a collection of lines.\n\n        Parameters\n        ----------\n        other : Line, Segment, LineCollection or SegmentCollection\n            The object to intersect the polygon with.\n\n        Returns\n        -------\n        PointCollection\n            The points of intersection.\n\n        """"""\n        # TODO: handle collinear segments\n        if isinstance(other, (Segment, SegmentCollection)):\n            result = self._line.meet(other._line)\n            return result[self.contains(result) & other.contains(result)]\n\n        result = self._line.meet(other)\n        return result[self.contains(result)]\n'"
geometer/transformation.py,25,"b'import numpy as np\n\nfrom .base import ProjectiveElement, TensorDiagram, LeviCivitaTensor, Tensor, ProjectiveCollection\nfrom .point import Point, Subspace, infty_hyperplane\nfrom .utils import inv\n\n\ndef identity(dim):\n    """"""Returns the identity transformation.\n\n    Parameters\n    ----------\n    dim : int\n        The dimension of the projective space that the transformation acts on.\n\n    Returns\n    -------\n    Transformation\n        The identity transformation.\n\n    """"""\n    return Transformation(np.eye(dim+1))\n\n\ndef affine_transform(matrix=None, offset=0):\n    """"""Returns a projective transformation for the given affine transformation.\n\n    Parameters\n    ----------\n    matrix : array_like, optional\n        The transformation matrix.\n    offset : array_like or float, optional\n        The translation.\n\n    Returns\n    -------\n    Transformation\n        The projective transformation that represents the affine transformation.\n\n    """"""\n    n = 2\n    dtype = np.float32\n\n    if not np.isscalar(offset):\n        offset = np.array(offset)\n        n = offset.shape[0] + 1\n        dtype = offset.dtype\n\n    if matrix is not None:\n        matrix = np.array(matrix)\n        n = matrix.shape[0] + 1\n        dtype = np.find_common_type([dtype, matrix.dtype], [])\n\n    result = np.eye(n, dtype=dtype)\n\n    if matrix is not None:\n        result[:-1, :-1] = matrix\n\n    result[:-1, -1] = offset\n    return Transformation(result)\n\n\ndef rotation(angle, axis=None):\n    """"""Returns a projective transformation that represents a rotation by the specified angle (and axis).\n\n    Parameters\n    ----------\n    angle : float\n        The angle to rotate by.\n    axis : Point, optional\n        The axis to rotate around when rotating points in 3D.\n\n    Returns\n    -------\n    Transformation\n        The rotation.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n\n    """"""\n    if axis is None:\n        return affine_transform([[np.cos(angle), -np.sin(angle)],\n                                 [np.sin(angle), np.cos(angle)]])\n\n    dimension = axis.dim\n    e = LeviCivitaTensor(dimension, False)\n    a = axis.normalized_array[:-1]\n    a = a / np.linalg.norm(a)\n    d = TensorDiagram(*[(Tensor(a, copy=False), e) for _ in range(dimension - 2)])\n    u = d.calculate().array\n    v = np.outer(a, a)\n    result = np.cos(angle)*np.eye(dimension) + np.sin(angle)*u + (1 - np.cos(angle))*v\n\n    return affine_transform(result)\n\n\ndef translation(*coordinates):\n    """"""Returns a projective transformation that represents a translation by the given coordinates.\n\n    Parameters\n    ----------\n    *coordinates\n        The coordinates by which points are translated when applying the resulting transformation.\n\n    Returns\n    -------\n    Transformation\n        The translation.\n\n    """"""\n    offset = Point(*coordinates)\n    return affine_transform(offset=offset.normalized_array[:-1])\n\n\ndef scaling(*factors):\n    """"""Returns a projective transformation that represents general scaling by given factors in each dimension.\n\n    Parameters\n    ----------\n    *factors\n        The scaling factors by which each dimension is scaled.\n\n    Returns\n    -------\n    Transformation\n        The scaling transformation.\n\n    """"""\n    if len(factors) == 1:\n        factors = factors[0]\n    return affine_transform(np.diag(factors))\n\n\ndef reflection(axis):\n    """"""Returns a projective transformation that represents a reflection at the given axis/hyperplane.\n\n    Parameters\n    ----------\n    axis : Subspace\n        The 2D-line or hyperplane to reflect points at.\n\n    Returns\n    -------\n    Transformation\n        The reflection.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Householder_transformation\n\n    """"""\n    if axis == infty_hyperplane(axis.dim):\n        return identity(axis.dim)\n\n    v = axis.array[:-1]\n    v = v / np.linalg.norm(v)\n\n    p = affine_transform(np.eye(axis.dim) - 2*np.outer(v, v.conj()))\n\n    base = axis.basis_matrix\n    ind = base[:, -1].nonzero()[0][0]\n    x = base[ind, :-1] / base[ind, -1]\n    x = Point(*x)\n\n    return translation(x) * p * translation(-x)\n\n\nclass Transformation(ProjectiveElement):\n    """"""Represents a projective transformation in an arbitrary projective space.\n\n    The underlying array is the matrix representation of the projective transformation. The matrix must be\n    a nonsingular square matrix of size n+1 when n is the dimension of the projective space.\n    The transformation can be applied to a point or another object by multiplication.\n\n    Parameters\n    ----------\n    *args\n        The array that defines the matrix representing the transformation.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault(""covariant"", [0])\n        super(Transformation, self).__init__(*args, **kwargs)\n\n    def __apply__(self, transformation):\n        return Transformation(transformation.array.dot(self.array), copy=False)\n\n    @classmethod\n    def from_points(cls, *args):\n        """"""Constructs a projective transformation in n-dimensional projective space from the image of n + 2 points in\n        general position.\n\n        For two dimensional transformations, 4 pairs of points are required, of which no three points are collinear.\n        For three dimensional transformations, 5 pairs of points are required, of which no four points are coplanar.\n\n        Parameters\n        ----------\n        *args\n            Pairs of points, where in each pair one point is mapped to the other.\n\n        Returns\n        -------\n        Transformation\n            The transformation mapping each of the given points to the specified points.\n\n        References\n        ----------\n        .. [1] J. Richter-Gebert: Perspectives on Projective Geometry, Proof of Theorem 3.4\n\n        """"""\n        a = [x.array for x, y in args]\n        b = [y.array for x, y in args]\n        m1 = np.column_stack(a[:-1])\n        m2 = np.column_stack(b[:-1])\n        d1 = np.linalg.solve(m1, a[-1])\n        d2 = np.linalg.solve(m2, b[-1])\n        t1 = m1.dot(np.diag(d1))\n        t2 = m2.dot(np.diag(d2))\n        return cls(t2.dot(np.linalg.inv(t1)))\n\n    def apply(self, other):\n        """"""Apply the transformation to another object.\n\n        Parameters\n        ----------\n        other : Tensor\n            The object to apply the transformation to.\n\n        Returns\n        -------\n        Tensor\n            The result of applying this transformation to the supplied object.\n\n        """"""\n        if hasattr(other, ""__apply__""):\n            return other.__apply__(self)\n        raise NotImplementedError(""Object of type %s cannot be transformed."" % type(other))\n\n    def __mul__(self, other):\n        try:\n            return self.apply(other)\n        except NotImplementedError:\n            return super(Transformation, self).__mul__(other)\n\n    def __pow__(self, power, modulo=None):\n        if power == 0:\n            return identity(self.dim)\n        if power < 0:\n            return self.inverse().__pow__(-power, modulo)\n\n        result = super(Transformation, self).__pow__(power, modulo)\n        return Transformation(result, copy=False)\n\n    def inverse(self):\n        """"""Calculates the inverse projective transformation.\n\n        Returns\n        -------\n        Transformation\n            The inverse transformation.\n\n        """"""\n        return Transformation(np.linalg.inv(self.array))\n\n\nclass TransformationCollection(ProjectiveCollection):\n    """"""A Collection of transformations.\n\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault(""covariant"", [0])\n        super(TransformationCollection, self).__init__(*args, tensor_rank=2, **kwargs)\n\n    def apply(self, other):\n        """"""Apply the transformations to another object.\n\n        Parameters\n        ----------\n        other : Tensor\n            The object to apply the transformations to.\n\n        Returns\n        -------\n        TensorCollection\n            The result of applying the transformations to the supplied object.\n\n        """"""\n        if hasattr(other, ""__apply__""):\n            return other.__apply__(self)\n        raise NotImplementedError(""Object of type %s cannot be transformed."" % type(other))\n\n    def __pow__(self, power, modulo=None):\n        if power == 0:\n            e = np.eye(self.dim+1)\n            e = e.reshape((1,)*len(self._collection_indices) + e.shape)\n            e = np.tile(e, self.shape[:len(self._collection_indices)] + (1, 1))\n            return TransformationCollection(e)\n        if power < 0:\n            return self.inverse().__pow__(-power, modulo)\n\n        result = super(TransformationCollection, self).__pow__(power, modulo)\n        return TransformationCollection(result, copy=False)\n\n    def inverse(self):\n        """"""Calculates the inverse projective transformations.\n\n        Returns\n        -------\n        TransformationCollection\n            The inverse transformations.\n\n        """"""\n        return TransformationCollection(inv(self.array))\n'"
tests/test_base.py,6,"b'import numpy as np\nfrom geometer.base import TensorDiagram, Tensor, TensorCollection, LeviCivitaTensor, KroneckerDelta\n\n\nclass TestTensor:\n\n    def test_arithmetic(self):\n        a = Tensor(2, 3)\n        b = Tensor(5, 4)\n\n        # vector operations\n        assert a + b == Tensor(7, 7)\n        assert a - b == Tensor(-3, -1)\n        assert -a == Tensor(-2, -3)\n\n        # scalar operations\n        assert a + 6 == Tensor(8, 9)\n        assert a - 6 == Tensor(-4, -3)\n        assert a * 6 == Tensor(12, 18)\n        assert a / 6 == Tensor(1/3, 0.5)\n\n    def test_transpose(self):\n        a = Tensor([[1, 2],\n                    [3, 4]], covariant=[0])\n\n        assert a.transpose() == Tensor([[1, 3], [2, 4]])\n        assert a.T._covariant_indices == {1}\n        assert a.T.T == a\n\n    def test_getitem(self):\n        a = Tensor([[1, 2],\n                    [3, 4]], covariant=[0])\n\n        assert a[0, 1] == 2\n        assert a[None, 1] == [[3, 4]]\n        assert a[None, 1].tensor_shape == (0, 1)\n        assert a[::-1, 0] == [3, 1]\n        assert a[::-1, 0].tensor_shape == (1, 0)\n\n    def test_dtype(self):\n        a = Tensor(2, 3, dtype=np.float32)\n        assert a.dtype == np.float32\n\n        a = Tensor(2, 3, dtype=np.complex64)\n        assert a.dtype == np.complex64\n\n\nclass TestTensorCollection:\n\n    def test_init(self):\n        # empty list\n        a = TensorCollection([])\n        assert len(a) == 0\n\n        # numpy array\n        a = TensorCollection(np.ones((1, 2, 3)))\n        assert len(a) == 1\n        assert a.size == 2\n\n        # nested list of numbers\n        a = TensorCollection([[1, 2], [3, 4]])\n        assert len(a) == 2\n        assert a.size == 2\n\n        # nested tuple of numbers\n        a = TensorCollection(((1, 2), (3, 4)))\n        assert len(a) == 2\n        assert a.size == 2\n\n        # nested list of Tensor objects\n        a = TensorCollection([[Tensor(1, 2, 3), Tensor(3, 4, 5)]])\n        assert a.shape == (1, 2, 3)\n        assert len(a) == 1\n        assert a.size == 2\n\n        # object with __array__ function\n        class A:\n            def __array__(self):\n                return np.array([Tensor(1, 2), Tensor(3, 4)])\n        a = TensorCollection(A())\n        assert len(a) == 2\n        assert a.size == 2\n\n    def test_flat(self):\n        a = [Tensor([[1, 2], [3, 4]]), Tensor([[5, 6], [7, 8]])]\n        b = TensorCollection([a], tensor_rank=2)\n\n        assert list(b.flat) == a\n\n    def test_getitem(self):\n        a = Tensor([[1, 2],\n                    [3, 4]])\n        b = Tensor([[5, 6],\n                    [7, 8]])\n        c = TensorCollection([a, b])\n\n        assert c[0] == a\n        assert c[1] == b\n        assert list(c) == [a, b]\n        assert c[:, 1] == TensorCollection([Tensor([3, 4]), Tensor([7, 8])])\n        assert c[:, 0, 0] == [1, 5]\n\n\nclass TestTensorDiagram:\n\n    def test_add_edge(self):\n        a = Tensor([1, 0, 0, 0])\n        b = Tensor([[42, 0, 0, 0],\n                    [0, 0, 0, 0],\n                    [0, 0, 0, 0],\n                    [0, 0, 0, 0]], covariant=False)\n        diagram = TensorDiagram((a, b))\n        assert diagram.calculate() == Tensor([42, 0, 0, 0])\n        diagram.add_edge(a.copy(), b)\n        assert diagram.calculate() == 42\n\n    def test_tensor_product(self):\n        e1 = Tensor(1, 0)\n        e2 = Tensor(0, 1)\n        a = Tensor([0, 1],\n                   [1, 0], covariant=[0])\n        b = Tensor([1, 0],\n                   [0, 1], covariant=[0])\n\n        m = a.tensor_product(b)\n        e = e1.tensor_product(e2)\n        assert TensorDiagram((e, m), (e, m)).calculate() == (a * e1).tensor_product(b * e2)\n\n        d = TensorDiagram()\n        d.add_node(a)\n        d.add_node(b)\n        assert d.calculate() == a.tensor_product(b)\n\n    def test_epsilon_delta_rule(self):\n        e1 = LeviCivitaTensor(3, True)\n        e2 = LeviCivitaTensor(3, False)\n        d = KroneckerDelta(3)\n        d2 = d.tensor_product(d)\n        d1 = d2.transpose((0, 1))\n\n        diagram = TensorDiagram((e1, e2.transpose()))\n        assert diagram.calculate() == d1 - d2\n\n    def test_kronecker_delta(self):\n        d = KroneckerDelta(4, 3)\n        assert d.array.shape == (4,)*6\n        assert d.array[0, 1, 2, 0, 1, 2] == 1\n        assert d.array[0, 2, 1, 0, 1, 2] == -1\n'"
tests/test_curve.py,16,"b'import numpy as np\nfrom geometer import Point, Line, Conic, Circle, Quadric, Plane, Ellipse, Sphere, Cone, Cylinder, QuadricCollection\nfrom geometer import PointCollection, LineCollection, PlaneCollection, crossratio, translation, rotation\n\n\nclass TestConic:\n\n    def test_from_points(self):\n        a = Point(0, 1)\n        b = Point(0, -1)\n        c = Point(1.5, 0.5)\n        d = Point(1.5, -0.5)\n        e = Point(-1.5, 0.5)\n\n        conic = Conic.from_points(a, b, c, d, e)\n\n        assert conic.contains(a)\n        assert conic.contains(b)\n        assert conic.contains(c)\n        assert conic.contains(d)\n        assert conic.contains(e)\n\n    def test_ellipse(self):\n        el = Ellipse(Point(1, 2), 2, 3)\n\n        assert el.contains(Point(-1, 2))\n        assert el.contains(Point(3, 2))\n        assert el.contains(Point(1, 5))\n        assert el.contains(Point(1, -1))\n\n    def test_from_tangent(self):\n        a = Point(-1.5, 0.5)\n        b = Point(0, -1)\n        c = Point(1.5, 0.5)\n        d = Point(1.5, -0.5)\n        l = Line(0, 1, -1)\n\n        conic = Conic.from_tangent(l, a, b, c, d)\n\n        assert conic.contains(a)\n        assert conic.contains(b)\n        assert conic.contains(c)\n        assert conic.contains(d)\n        assert conic.is_tangent(l)\n\n    def test_from_crossratio(self):\n        a = Point(0, 1)\n        b = Point(0, -1)\n        c = Point(1.5, 0.5)\n        d = Point(1.5, -0.5)\n        e = Point(-1.5, 0.5)\n\n        conic1 = Conic.from_points(a, b, c, d, e)\n        cr = crossratio(a, b, c, d, e)\n        conic2 = Conic.from_crossratio(cr, a, b, c, d)\n\n        assert conic1 == conic2\n\n    def test_intersections(self):\n        c = Circle(Point(0, 0), 1)\n        i = c.intersect(Line(0, 1, 0))\n        assert len(i) == 2\n        assert Point(1, 0) in i\n        assert Point(-1, 0) in i\n\n        c2 = Circle(Point(0, 2), 1)\n        assert Point(0, 1) in c.intersect(c2)\n\n        c3 = Conic.from_lines(Line(1, 0, 0), Line(0, 1, 0))\n        assert Point(1, 0) in c.intersect(c3)\n        assert Point(0, 1) in c.intersect(c3)\n        assert Point(-1, 0) in c.intersect(c3)\n        assert Point(0, -1) in c.intersect(c3)\n\n    def test_contains(self):\n        c = Conic([[1, 0, 0],\n                   [0, 1, 0],\n                   [0, 0, -1]])\n\n        assert c.contains(Point(1, 0))\n\n    def test_foci(self):\n        e = Ellipse(Point(0, 0), 3, 2)\n        f = e.foci\n        f1 = Point(np.sqrt(5), 0)\n        f2 = Point(np.sqrt(5), 0)\n\n        assert len(f) == 2\n        assert f1 in f and f2 in f\n\n    def test_from_foci(self):\n        f1 = Point(0, np.sqrt(5))\n        f2 = Point(0, -np.sqrt(5))\n        b = Point(0, 3)\n        conic = Conic.from_foci(f1, f2, b)\n\n        assert conic == Ellipse(Point(0, 0), 2, 3)\n\n\nclass TestCircle:\n\n    def test_contains(self):\n        c = Circle(Point(0, 1), 1)\n        assert c.contains(Point(0, 2))\n        assert c.contains(Point(1, 1))\n\n    def test_center(self):\n        c = Circle(Point(0, 1), 1)\n        assert c.center == Point(0, 1)\n\n    def test_intersection(self):\n        c = Circle(Point(0, 2), 2)\n        l = Line(Point(-1, 2), Point(1, 2))\n\n        assert c.contains(Point(0, 0))\n        assert c.intersect(l) == [Point(-2, 2), Point(2, 2)]\n        assert c.intersect(l-Point(0, 2)) == [Point(0, 0)]\n\n        l = LineCollection([Line(Point(-1, 2), Point(1, 2)), Line(Point(0, 2), Point(0, 0))])\n        assert c.intersect(l) == [PointCollection([Point(-2, 2), Point(0, 0)]), PointCollection([Point(2, 2), Point(0, 4)])]\n\n    def test_intersection_angle(self):\n        c1 = Circle()\n        c2 = Circle(Point(1, 1), 1)\n        assert np.isclose(c1.intersection_angle(c2), np.pi/2)\n\n    def test_copy(self):\n        c1 = Circle(Point(0, 1), 4.5)\n        c2 = c1.copy()\n\n        assert c1 == c2\n        assert c1 is not c2\n        assert c1.center == c2.center\n        assert c1.radius == c2.radius\n\n    def test_transform(self):\n        c = Circle()\n        t = translation(1, 1)\n\n        assert t*c == Circle(Point(1, 1))\n        assert t.apply(c).center == Point(1, 1)\n\n\nclass TestQuadric:\n\n    def test_tangent(self):\n        q = Quadric([[1, 0, 0, 0],\n                     [0, 1, 0, 0],\n                     [0, 0, 1, 0],\n                     [0, 0, 0, -1]])\n\n        assert q.contains(Point(1, 0, 0))\n        assert q.tangent(at=Point(1, 0, 0)) == Plane(Point(1, 0, 0), Point(1, 0, 1), Point(1, 1, 0))\n\n    def test_components(self):\n        e = Plane(1, 2, 3, 4)\n        f = Plane(4, 3, 2, 1)\n\n        q = Quadric.from_planes(e, f)\n        assert q.components == [e, f]\n\n\nclass TestSphere:\n\n    def test_intersection(self):\n        s = Sphere(Point(0, 0, 2), 2)\n        l = Line(Point(-1, 0, 2), Point(1, 0, 2))\n\n        assert s.contains(Point(0, 0, 0))\n        assert s.intersect(l) == [Point(-2, 0, 2), Point(2, 0, 2)]\n        assert s.intersect(l-Point(0, 0, 2)) == [Point(0, 0, 0)]\n\n        l = LineCollection([Line(Point(-1, 0, 2), Point(1, 0, 2)), Line(Point(0, 0, 0), Point(0, 0, 2))])\n        assert s.intersect(l) == [PointCollection([Point(-2, 0, 2), Point(0, 0, 0)]),\n                                  PointCollection([Point(2, 0, 2), Point(0, 0, 4)])]\n\n        s = Sphere(Point(0, 0, 0, 2), 2)\n        l = Line(Point(-1, 0, 0, 2), Point(1, 0, 0, 2))\n\n        assert s.contains(Point(0, 0, 0, 0))\n        assert s.intersect(l) == [Point(2, 0, 0, 2), Point(-2, 0, 0, 2)]\n\n    def test_s2(self):\n        s2 = Sphere()\n\n        assert s2.center == Point(0, 0, 0)\n        assert np.isclose(s2.radius, 1)\n        assert np.isclose(s2.volume, 4/3*np.pi)\n        assert np.isclose(s2.area, 4*np.pi)\n\n    def test_s3(self):\n        s3 = Sphere(Point(1, 2, 3, 4), 5)\n\n        assert s3.center == Point(1, 2, 3, 4)\n        assert np.isclose(s3.radius, 5)\n        assert np.isclose(s3.volume, 1/2 * np.pi**2 * 5**4)\n        assert np.isclose(s3.area, 2 * np.pi**2 * 5**3)\n\n    def test_transform(self):\n        s = Sphere(Point(0, 0, 2), 2)\n        t = translation(1, 1, -1)\n\n        assert t*s == Sphere(Point(1, 1, 1), 2)\n\n    def test_add(self):\n        s = Sphere()\n        p = Point(0, 0, 2)\n\n        assert s + p == Sphere(p)\n        assert s - p == Sphere(-p)\n\n\nclass TestCone:\n\n    def test_intersection(self):\n        c = Cone(vertex=Point(1, 1, 1), base_center=Point(2, 2, 2), radius=2)\n        a = np.sqrt(2)\n        l = Line(Point(0, 4, 2), Point(4, 0, 2))\n\n        assert c.intersect(l) == [Point(2 - a, 2 + a, 2), Point(2 + a, 2 - a, 2)]\n\n    def test_init(self):\n        c = Cone(vertex=Point(1, 0, 0), base_center=Point(2, 0, 0), radius=4)\n\n        assert c.contains(Point(1, 0, 0))\n        assert c.contains(Point(2, 4, 0))\n        assert c.contains(Point(2, 0, 4))\n        assert c.contains(Point(0, 0, -4))\n\n        c = Cone(vertex=Point(1, 1, 1), base_center=Point(2, 2, 2), radius=2)\n\n        s = np.sqrt(2)\n        assert c.contains(Point(1, 1, 1))\n        assert c.contains(Point(2+s, 2-s, 2))\n        assert c.contains(Point(2, 2-s, 2+s))\n        assert c.contains(Point(s, 0, -s))\n\n    def test_transform(self):\n        c = Cone(vertex=Point(1, 1, 1), base_center=Point(2, 2, 2), radius=2)\n        t = translation(-1, -1, -1)\n\n        assert t*c == Cone(vertex=Point(0, 0, 0), base_center=Point(1, 1, 1), radius=2)\n\n\nclass TestCylinder:\n\n    def test_init(self):\n        c = Cylinder(center=Point(1, 0, 0), direction=Point(1, 0, 0), radius=4)\n\n        assert c.contains(Point(1, 0, 4))\n        assert c.contains(Point(2, 4, 0))\n        assert c.contains(Point(2, 0, 4))\n        assert c.contains(Point(-1, 0, -4))\n\n        c = Cylinder(direction=Point(1, 1, 1), radius=2)\n\n        s = np.sqrt(2)\n        assert c.contains(Point(2 + s, 2 - s, 2))\n        assert c.contains(Point(2, 2 - s, 2 + s))\n        assert c.contains(Point(s, 0, -s))\n        assert c.contains(Point(42+s, 42, 42-s))\n\n    def test_transform(self):\n        c = Cylinder(center=Point(1, 0, 0), direction=Point(1, 0, 0), radius=4)\n        t = translation(1, 1, 1)\n        r = rotation(np.pi/2, axis=Point(0, 1, 0))\n\n        assert t*c == Cylinder(center=Point(2, 1, 1), direction=Point(1, 0, 0), radius=4)\n        assert r*c == Cylinder(center=Point(0, 0, 1), direction=Point(0, 0, 1), radius=4)\n\n\nclass TestQuadricCollection:\n\n    def test_contains(self):\n        s = QuadricCollection([Sphere(), Sphere(radius=2)])\n        p = Point(1, 0, 0)\n\n        assert np.all(s.contains(p) == [True, False])\n\n    def test_components(self):\n        l = Line(1, 2, 3)\n        m = Line(4, 5, 6)\n        g = Line(3, 2, 1)\n        h = Line(6, 5, 4)\n\n        q = QuadricCollection([Conic.from_lines(l, m), Conic.from_lines(g, h)])\n        assert q.components == [LineCollection([m, g]), LineCollection([l, h])]\n\n        e = Plane(1, 2, 3, 4)\n        f = Plane(4, 3, 2, 1)\n        g = Plane(5, 6, 7, 8)\n        h = Plane(8, 7, 6, 5)\n\n        q = QuadricCollection([Quadric.from_planes(e, f), Quadric.from_planes(g, h)])\n        assert q.components == [PlaneCollection([e, g]), PlaneCollection([f, h])]\n\n    def test_intersection(self):\n        q = QuadricCollection([Circle(Point(0, 1), 1), Circle(Point(0, 2), 2)])\n        l = LineCollection([Line(Point(-1, 1), Point(1, 1)), Line(Point(-1, 2), Point(1, 2))])\n\n        assert q.intersect(l) == [PointCollection([Point(1, 1), Point(-2, 2)]), PointCollection([Point(-1, 1), Point(2, 2)])]\n\n        q = QuadricCollection([Sphere(Point(0, 0, 1), 1), Sphere(Point(0, 0, 2), 2)])\n        l = LineCollection([Line(Point(-1, 0, 1), Point(1, 0, 1)), Line(Point(-1, 0, 2), Point(1, 0, 2))])\n        m = Line(Point(-1, 0, 2), Point(1, 0, 2))\n\n        assert q.intersect(l) == [PointCollection([Point(-1, 0, 1), Point(-2, 0, 2)]), PointCollection([Point(1, 0, 1), Point(2, 0, 2)])]\n        assert q.intersect(m) == [PointCollection([Point(0, 0, 2), Point(-2, 0, 2)]), PointCollection([Point(0, 0, 2), Point(2, 0, 2)])]\n\n    def test_tangent(self):\n        q = QuadricCollection([Sphere(), Sphere(radius=2)])\n        p = PointCollection([Point(1, 0, 0), Point(2, 0, 0)])\n\n        assert all(q.contains(p))\n        assert q.tangent(at=p) == PlaneCollection([Plane(1, 0, 0, -1), Plane(1, 0, 0, -2)])\n        assert all(q.is_tangent(q.tangent(at=p)))\n'"
tests/test_operators.py,19,"b'import numpy as np\nfrom geometer import *\n\n\ndef test_is_collinear():\n    p1 = Point(1, 0)\n    p2 = Point(2, 0)\n    p3 = Point(3, 0)\n    l = Line(p1, p2)\n    assert l.contains(p3)\n    assert is_collinear(p1, p2, p3)\n\n\ndef test_dist():\n    p = Point(0, 0)\n    q = Point(1, 0)\n\n    assert np.isclose(dist(p, q), 1)\n\n    p1 = Point(1j, 0, 0, 2j)\n    p2 = Point(0, 2j, 0, 0)\n\n    assert np.isclose(dist(p1, p2), 3)\n\n    p1 = Point(1, 0, 0)\n    p2 = Point([1, 0, 0, 0])\n\n    assert dist(p1, p2) == dist(p2, p1) == np.inf\n\n    p1 = Point(0, 0, 0)\n    p2 = Point(1, 0, 0)\n\n    assert np.isclose(dist(p1, p2), 1)\n\n    e = Plane(1, 0, 0, 0)\n    assert np.isclose(dist(e, p2), 1)\n\n    l = Line(p2, Point(1, 1, 0))\n    assert np.isclose(dist(l, e), 1)\n    assert np.isclose(dist(l, p1), 1)\n\n\ndef test_angle():\n    a = Point(0, 0)\n    b = Point(1, 1)\n    c = Point(1, 0)\n\n    assert np.isclose(angle(a, b, c), np.pi/4)\n    assert np.isclose(angle(a, c, b), -np.pi/4)\n\n    e1 = Plane(1, 0, 0, 0)\n    e2 = Plane(0, 0, 1, 0)\n\n    assert np.isclose(abs(angle(e1, e2)), np.pi/2)\n\n    p1 = Point(0, 0, 0)\n    p2 = Point(0, 1, 0)\n    p3 = Point(1, 0, 0)\n    l = Line(p1, p2)\n    m = Line(p1, p3)\n\n    assert np.isclose(abs(angle(l, m)), np.pi/2)\n    assert np.isclose(abs(angle(p1, p2, p3)), np.pi/2)\n\n\ndef test_angle_bisectors():\n    a = Point(0, 0)\n    b = Point(1, 1)\n    c = Point(1, 0)\n    l = Line(a, b)\n    m = Line(a, c)\n    q, r = angle_bisectors(l, m)\n    assert is_perpendicular(q, r)\n    assert np.isclose(angle(l, q), angle(q, m))\n\n    p1 = Point(0, 0, 0)\n    p2 = Point(0, 1, 0)\n    p3 = Point(1, 0, 0)\n    l = Line(p1, p2)\n    m = Line(p1, p3)\n    q, r = angle_bisectors(l, m)\n    assert is_perpendicular(q, r)\n    assert np.isclose(angle(l, q), angle(q, m))\n\n\ndef test_is_cocircular():\n    p = Point(0, 1)\n    t = rotation(np.pi/3)\n\n    assert is_cocircular(p, t*p, t*t*p, t*t*t*p)\n\n\ndef test_is_coplanar():\n    p1 = Point(1, 1, 0)\n    p2 = Point(2, 1, 0)\n    p3 = Point(3, 4, 0)\n    p4 = Point(0, 2, 0)\n\n    assert is_coplanar(p1, p2, p3, p4)\n\n\ndef test_is_perpendicular():\n    l = Line(0, 1, 0)\n    m = Line(1, 0, 0)\n    assert is_perpendicular(l, m)\n\n    p1 = Point(0, 0, 0)\n    p2 = Point(0, 1, 0)\n    p3 = Point(1, 0, 0)\n    l = Line(p1, p2)\n    m = Line(p1, p3)\n    assert is_perpendicular(l, m)\n\n    e1 = Plane(p1, p2, p3)\n    e2 = Plane(p1, p2, Point(0, 0, 1))\n    assert is_perpendicular(e1, e2)\n\n\ndef test_pappos():\n    a1 = Point(0, 1)\n    b1 = Point(1, 2)\n    c1 = Point(2, 3)\n\n    a2 = Point(0, 0)\n    b2 = Point(1, 0)\n    c2 = Point(2, 0)\n\n    p = a1.join(b2).meet(b1.join(a2))\n    q = b1.join(c2).meet(c1.join(b2))\n    r = c1.join(a2).meet(a1.join(c2))\n\n    assert is_collinear(p, q, r)\n\n\ndef test_cp1():\n    p = Point(1+0j)\n    q = Point(0+1j)\n    m = Transformation([[np.e**(np.pi/2*1j), 0], [0, 1]])\n    assert m*p == q\n    c = crossratio(p, q, m*q, m*m*q)\n    assert np.isclose(np.real(c), c)\n\n\ndef test_harmonic_set():\n    a = Point(0, 0)\n    b = Point(1, 1)\n    c = Point(3, 3)\n    d = harmonic_set(a, b, c)\n    assert np.isclose(crossratio(a, b, c, d), -1)\n\n    a = Point(0, 0, 0)\n    b = Point(1, 1, 0)\n    c = Point(3, 3, 0)\n    d = harmonic_set(a, b, c)\n    assert np.isclose(crossratio(a, b, c, d), -1)\n'"
tests/test_point.py,2,"b'import numpy as np\nfrom geometer import Point, Line, Plane, PointCollection, LineCollection, PlaneCollection, join, meet, is_perpendicular, translation, rotation\n\n\nclass Test2D:\n\n    def test_join(self):\n        p = Point(1, 0)\n        q = Point(0, 1)\n        assert p.join(q) == Line(-1, -1, 1)\n\n    def test_meet(self):\n        l = Line(-1, -1, 2)\n        m = Line(1, -1, 0)\n        assert l.meet(m) == Point(1, 1)\n\n    def test_add(self):\n        p = Point(1, 0)\n        q = Point(0, 1)\n        assert p + q == Point(1, 1)\n\n        p = Point([1, 0, 0])\n        q = Point(0, 1)\n        assert 2*p + 3*q == Point(2, 3)\n\n    def test_parallel(self):\n        p = Point(0, 1)\n        q = Point(1, 1)\n        r = Point(0, 0)\n        l = Line(p, q)\n        m = l.parallel(through=r)\n\n        assert m == Line(0, 1, 0)\n        assert l.is_parallel(m)\n\n    def test_perpendicular(self):\n        p = Point(1, 1)\n        l = Line(1, 1, 0)\n        m = l.perpendicular(p)\n\n        assert m == Line(-1, 1, 0)\n\n        m = l.perpendicular(Point(0, 0))\n        assert m == Line(-1, 1, 0)\n\n        p = Point(1, 1, 0)\n        q = Point(0, 0, 1)\n        l = Line(p, q)\n        m = l.perpendicular(p)\n\n        assert is_perpendicular(l, m)\n\n\nclass Test3D:\n\n    def test_join(self):\n        p1 = Point(1, 1, 0)\n        p2 = Point(2, 1, 0)\n        p3 = Point(3, 4, 0)\n        p4 = Point(0, 2, 0)\n\n        # 3 points\n        assert join(p1, p2, p3).contains(p4)\n\n        # 2 points\n        l = p1.join(p2)\n        assert l.contains(Point(3, 1, 0))\n\n        # two lines\n        m = Line(Point(0, 0, 0), Point(1, 2, 0))\n        assert join(l, m) == Plane(0, 0, 1, 0)\n\n        # point and line\n        p = join(l, p3)\n        assert p.contains(p4)\n\n    def test_meet(self):\n        p1 = Plane(1, 0, 0, 0)\n        p2 = Plane(0, 0, 1, 0)\n        p3 = Plane(0, 1, 0, 0)\n\n        # three planes\n        assert meet(p1, p2, p3) == Point(0, 0, 0)\n\n        # two planes\n        l = p1.meet(p2)\n        m = Line(Point(0, 0, 0), Point(0, 1, 0))\n        assert l == m\n\n        # two lines\n        m = Line(Point(0, 0, 0), Point(1, 2, 5))\n        assert l.meet(m) == Point(0, 0, 0)\n\n        # plane and line\n        assert p3.meet(l) == Point(0, 0, 0)\n\n    def test_contains(self):\n        p1 = Point(1, 1, 0)\n        p2 = Point(2, 1, 0)\n        p3 = Point(3, 4, 0)\n        p4 = Point(0, 2, 0)\n\n        p = Plane(p1, p2, p3)\n        l = Line(p1, p2)\n        assert p.contains(p4)\n        assert p.contains(l)\n\n    def test_is_coplanar(self):\n        l = Line(Point(1, 1, 0), Point(2, 1, 0))\n        m = Line(Point(0, 0, 0), Point(1, 2, 0))\n\n        assert l.is_coplanar(m)\n\n    def test_project(self):\n        p1 = Point(1, 1, 0)\n        p2 = Point(2, 1, 0)\n        l = Line(p1, p2)\n        assert l.project(Point(0, 0, 0)) == Point(0, 1, 0)\n\n        e = Plane(0, 0, 1, 0)\n        assert e.project(Point(1, 1, 5)) == p1\n\n    def test_parallel(self):\n        p = Point(0, 0, 1)\n        q = Point(1, 0, 1)\n        r = Point(0, 1, 1)\n        e = Plane(p, q, r)\n        f = e.parallel(through=Point(0, 0, 0))\n        assert f == Plane(0, 0, 1, 0)\n        assert e.is_parallel(f)\n\n    def test_perpendicular(self):\n        p = Point(1, 1, 0)\n        q = Point(0, 0, 1)\n        l = Line(p, q)\n        m = l.perpendicular(p)\n\n        assert is_perpendicular(l, m)\n\n        r = Point(1, 2, 3)\n        e = Plane(p, q, r)\n        m = e.perpendicular(p)\n\n        assert is_perpendicular(l, m)\n\n\nclass Test4D:\n\n    def test_join(self):\n        p1 = Point(1, 1, 4, 0)\n        p2 = Point(2, 1, 5, 0)\n        p3 = Point(3, 4, 6, 0)\n        p4 = Point(0, 2, 7, 0)\n        p5 = Point(1, 5, 8, 0)\n\n        # 4 points\n        assert join(p1, p2, p3, p4).contains(p5)\n\n        # 3 points\n        assert join(p1, p2, p3).contains(p3)\n\n        # two lines\n        l = Line(p1, p2)\n        m = Line(p3, p4)\n        assert join(l, m) == Plane(p1, p2, p3, p4)\n\n        # coplanar lines\n        l = Line(p1, p2)\n        m = Line(p1, p3)\n        assert join(l, m).contains(p3)\n\n        # point and line\n        p = join(l, p3)\n        assert p == join(p1, p2, p3)\n\n        # 2 points\n        l = p1.join(p2)\n        assert l.contains(Point(3, 1, 6, 0))\n\n    def test_meet(self):\n        p1 = Plane(1, 0, 0, 0, 0)\n        p2 = Plane(0, 1, 0, 0, 0)\n        p3 = Plane(0, 0, 1, 0, 0)\n        p4 = Plane(0, 0, 0, 1, 0)\n\n        # four hyperplanes\n        assert meet(p1, p2, p3, p4) == Point(0, 0, 0, 0)\n\n        # hyperplane and line\n        l = Line(Point(0, 0, 0, 0), Point(0, 0, 1, 0))\n        assert p3.meet(l) == Point(0, 0, 0, 0)\n\n        # two lines\n        m = Line(Point(0, 0, 0, 0), Point(1, 2, 5, 6))\n        assert l.meet(m) == Point(0, 0, 0, 0)\n\n    def test_project(self):\n        p1 = Point(1, 0, 0, 0)\n        p2 = Point(0, 1, 0, 0)\n\n        l = Line(p1, p2)\n        assert l.project(Point(0, 0, 0, 0)) == Point(0.5, 0.5, 0, 0)\n\n\nclass TestCollections:\n\n    def test_join(self):\n        # 2 points\n        a = PointCollection([Point(0, 0), Point(0, 1)])\n        b = PointCollection([Point(1, 0), Point(1, 1)])\n\n        assert a.join(b) == LineCollection([Line(0, 1, 0), Line(0, 1, -1)])\n\n        # 3 points\n        a = PointCollection([Point(0, 0, 0), Point(0, 0, 1)])\n        b = PointCollection([Point(1, 0, 0), Point(1, 0, 1)])\n        c = PointCollection([Point(0, 1, 0), Point(0, 1, 1)])\n\n        assert join(a, b, c) == PlaneCollection([Plane(0, 0, 1, 0), Plane(0, 0, 1, -1)])\n\n        # two lines\n        l = a.join(b)\n        m = a.join(c)\n        assert join(l, m) == PlaneCollection([Plane(0, 0, 1, 0), Plane(0, 0, 1, -1)])\n\n        # point and line\n        assert join(a, b.join(c)) == PlaneCollection([Plane(0, 0, 1, 0), Plane(0, 0, 1, -1)])\n\n    def test_meet(self):\n        # three planes\n        a = PlaneCollection([Plane(1, 0, 0, 0), Plane(1, 0, 0, -1)])\n        b = PlaneCollection([Plane(0, 1, 0, 0), Plane(0, 1, 0, -1)])\n        c = PlaneCollection([Plane(0, 0, 1, 0), Plane(0, 0, 1, -1)])\n        assert meet(a, b, c) == PointCollection([Point(0, 0, 0), Point(1, 1, 1)])\n\n        # two planes\n        l = a.meet(b)\n        m = LineCollection([Line(Point(0, 0, 0), Point(0, 0, 1)), Line(Point(1, 1, 0), Point(1, 1, 1))])\n        assert l == m\n\n        # two lines in 2D\n        a = LineCollection([Line(0, 1, 0), Line(0, 1, -1)])\n        b = LineCollection([Line(1, 0, 0), Line(1, 0, -1)])\n        assert a.meet(b) == PointCollection([Point(0, 0), Point(1, 1)])\n\n        # two lines in 3D\n        a = LineCollection([Line(Point(0, 0, 0), Point(0, 0, 1)), Line(Point(1, 0, 0), Point(1, 0, 1))])\n        b = LineCollection([Line(Point(0, 0, 0), Point(0, 1, 0)), Line(Point(1, 0, 0), Point(1, 1, 0))])\n        assert a.meet(b) == PointCollection([Point(0, 0, 0), Point(1, 0, 0)])\n\n        # plane and line\n        a = LineCollection([Line(Point(0, 0, 0), Point(0, 0, 1)), Line(Point(1, 0, 0), Point(1, 0, 1))])\n        b = PlaneCollection([Plane(0, 0, 1, 0), Plane(0, 0, 1, -1)])\n        assert a.meet(b) == PointCollection([Point(0, 0, 0), Point(1, 0, 1)])\n\n    def test_homogenize(self):\n        a = PointCollection([(0, 0), (0, 1)], homogenize=True)\n        b = PointCollection([Point(0, 0), Point(0, 1)])\n\n        assert a == b\n\n    def test_arithmetic(self):\n        a = PointCollection([Point(0, 1), Point(0, 1)])\n        b = PointCollection([Point(1, 0), Point(1, 0)])\n        c = PointCollection([Point(1, 1), Point(1, 1)])\n\n        assert a + b == c\n        assert a - c == -b\n        assert 2*a + 2*b == 2*c\n        assert (2*a + 2*b) / 2 == c\n        assert a + Point(1, 0) == c\n\n    def test_transform(self):\n        a = PointCollection([(1, 0), (0, 1)], homogenize=True)\n\n        assert translation(1, 1) * a == PointCollection([(2, 1), (1, 2)], homogenize=True)\n        assert rotation(np.pi/2) * a == PointCollection([(0, 1), (-1, 0)], homogenize=True)\n\n    def test_basis_matrix(self):\n        a = PlaneCollection([Plane(1, 0, 0, 0), Plane(0, 1, 0, 0), Plane(0, 0, 1, 0)])\n\n        assert a.basis_matrix.shape == (3, 3, 4)\n        assert np.allclose(np.matmul(a.basis_matrix, a.array[..., None]), 0)\n'"
tests/test_shapes.py,13,"b'import numpy as np\nfrom geometer import Point, Segment, Rectangle, Simplex, Triangle, Cuboid, Line, RegularPolygon, Polygon, SegmentCollection, PointCollection, dist, rotation, translation\n\n\nclass TestSegment:\n\n    def test_contains(self):\n        # both points finite\n        p = Point(0, 0)\n        q = Point(2, 1)\n        s = Segment(p, q)\n        assert s.contains(p)\n        assert s.contains(q)\n        assert s.contains(0.5 * (p + q))\n        assert not s.contains(p - q)\n        assert not s.contains(Point([2, 1, 0]))\n\n        # first point at infinity\n        p = Point([-2, -1, 0])\n        q = Point(2, 1)\n        s = Segment(p, q)\n        assert s.contains(p)\n        assert s.contains(q)\n        assert s.contains(0.5*q)\n        assert not s.contains(2*q)\n\n        # second point at infinity\n        p = Point(0, 0)\n        q = Point([2, 1, 0])\n        s = Segment(p, q)\n        assert s.contains(p)\n        assert s.contains(q)\n        assert s.contains(Point(2, 1))\n        assert not s.contains(Point(-2, -1))\n\n        # both points at infinity\n        p = Point([-2, 1, 0])\n        q = Point([2, 1, 0])\n        s = Segment(p, q)\n        assert s.contains(p)\n        assert s.contains(q)\n        assert s.contains(0.5*(p+q))\n        assert not s.contains(p-q)\n        assert not s.contains(Point(0, 0))\n\n    def test_equal(self):\n        p = Point(0, 0)\n        q = Point(2, 1)\n        s = Segment(p, q)\n\n        assert s == Segment(q, p)\n        assert s == s\n        assert s == Segment([(0, 0), (2, 1)], homogenize=True)\n        assert s != Segment([(0, 0), (1, 2)], homogenize=True)\n\n    def test_intersect(self):\n        a = Point(0, 0)\n        b = Point(0, 2)\n        c = Point(2, 2)\n        d = Point(2, 0)\n        s1 = Segment(a, c)\n        s2 = Segment(b, d)\n\n        assert s1.intersect(s2) == [Point(1, 1)]\n\n    def test_midpoint(self):\n        p = Point(0, 0)\n        q = Point(2, 2)\n        s = Segment(p, q)\n        assert s.midpoint == Point(1, 1)\n\n        p = Point(0, 0, 0)\n        q = Point(0, 2, 0)\n        s = Segment(p, q)\n        assert s.midpoint == Point(0, 1, 0)\n\n    def test_transformation(self):\n        p = Point(0, 0)\n        q = Point(2, 2)\n        s = Segment(p, q)\n\n        r = rotation(np.pi/2)\n        assert r*s == Segment(p, Point(-2, 2))\n        assert r.apply(s)._line == r.apply(s._line)\n\n    def test_getitem(self):\n        p = Point(0, 0)\n        q = Point(2, 2)\n        s = Segment(p, q)\n\n        assert s[0] == p\n        assert s[1] == q\n\n\nclass TestPolygon:\n\n    def test_equal(self):\n        points = np.random.rand(50, 3)\n\n        p1 = Polygon(points)\n        p2 = Polygon(*[Point(p) for p in points])\n\n        assert p1 == p2\n\n    def test_intersect(self):\n        a = Point(0, 0)\n        b = Point(0, 2)\n        c = Point(2, 2)\n        d = Point(2, 0)\n        r = Rectangle(a, b, c, d)\n        s = Segment(a, c)\n        assert r.intersect(s) == [a, c]\n\n    def test_edges(self):\n        a = Point(0, 0)\n        b = Point(0, 2)\n        c = Point(2, 2)\n        d = Point(2, 0)\n        r = Rectangle(a, b, c, d)\n        assert r.edges == [Segment(a, b), Segment(b, c), Segment(c, d), Segment(d, a)]\n\n    def test_contains(self):\n        a = Point(0, 0)\n        b = Point(0, 2)\n        c = Point(2, 2)\n        d = Point(2, 0)\n        r = Rectangle(a, b, c, d)\n        assert r.contains(Point(1, 1))\n\n        a = Point(0, 0, 1)\n        b = Point(1, 3, 1)\n        c = Point(2, 0, 1)\n        d = Point(1, 1, 1)\n        p = Polygon(a, b, c, d)\n\n        assert p.contains(Point(0.5, 1, 1))\n        assert not p.contains(Point(0.5, 1, 0))\n        assert np.all(p.contains(PointCollection([Point(0.5, 1, 1), Point(1.5, 1, 1)])))\n\n    def test_area(self):\n        a = Point(0, 0)\n        b = Point(2, 0)\n        c = Point(0, 2)\n        t = Triangle(a, b, c)\n        assert np.isclose(t.area, 2)\n\n    def test_transformation(self):\n        a = Point(0, 0)\n        b = Point(0, 1)\n        c = Point(2, 1)\n        d = Point(2, 0)\n        r = Rectangle(a, b, c, d)\n        r2 = rotation(np.pi/2)*r\n\n        assert r.area == r2.area\n        assert r2.contains(Point(-0.5, 1.5))\n\n        l = Line(Point(0, 0, -10), Point(0, 0, 10))\n        r = Rectangle(Point(-10, -10, 0), Point(10, -10, 0), Point(10, 10, 0), Point(-10, 10, 0))\n        t = rotation(np.pi/6, Point(1, 0, 0))\n\n        assert r.intersect(l) == [Point(0, 0, 0)]\n        assert (t*r).intersect(l) == [Point(0, 0, 0)]\n\n    def test_copy(self):\n        a = Point(0, 0)\n        b = Point(0, 2)\n        c = Point(2, 2)\n        d = Point(2, 0)\n\n        r1 = Rectangle(a, b, c, d)\n        p1 = RegularPolygon(a, 1, 6)\n\n        r2 = r1.copy()\n        p2 = p1.copy()\n\n        assert r1 == r2\n        assert r1 is not r2\n        assert r1.vertices == r2.vertices\n        assert p1 == p2\n        assert p1 is not p2\n        assert p1.vertices == p2.vertices\n\n    def test_centroid(self):\n        a = Point(0, 0, 1)\n        b = Point(2, 0, 1)\n        c = Point(2, 2, 1)\n        d = Point(0, 2, 1)\n        t = Triangle(a, b, c)\n        r = Rectangle(a, b, c, d)\n\n        s1, s2, s3 = t.edges\n        l1 = s1.midpoint.join(c)\n        l2 = s2.midpoint.join(a)\n\n        assert t.centroid == (a+b+c)/3\n        assert t.centroid == l1.meet(l2)\n        assert r.centroid == Point(1, 1, 1)\n\n    def test_getitem(self):\n        a = Point(0, 0, 1)\n        b = Point(2, 0, 1)\n        c = Point(2, 2, 1)\n        d = Point(0, 2, 1)\n        r = Rectangle(a, b, c, d)\n\n        assert r[0] == a\n        assert r[1] == b\n        assert r[2] == c\n        assert r[3] == d\n\n\nclass TestRegularPolygon:\n\n    def test_init(self):\n        a = Point(0, 0, 0)\n        p = RegularPolygon(a, 1, 6, axis=Point(0, 0, 1))\n\n        d = p.edges[0].length\n\n        assert len(p.vertices) == 6\n        assert np.isclose(dist(a, p.vertices[0]), 1)\n        assert all(np.isclose(s.length, d) for s in p.edges[1:])\n        assert np.allclose(p.angles, np.pi/3)\n        assert p.center == a\n\n    def test_radius(self):\n        p = RegularPolygon(Point(0, 0, 0), 1, 6, axis=Point(0, 0, 1))\n\n        assert np.isclose(p.radius, 1)\n        assert np.isclose(p.inradius, np.cos(np.pi/6))\n\n    def test_transform(self):\n        p = RegularPolygon(Point(0, 0, 0), 1, 6, axis=Point(0, 0, 1))\n        t = translation(1, 1, 0)\n\n        assert t*p == RegularPolygon(Point(1, 1, 0), 1, 6, axis=Point(0, 0, 1))\n        assert isinstance(t*p, RegularPolygon)\n        \n        \nclass TestSimplex:\n\n    def test_volume(self):\n        a = Point(0, 0, 0)\n        b = Point(1, 0, 0)\n        c = Point(0, 1, 0)\n        d = Point(0, 0, 1)\n        s = Simplex(a, b, c, d)\n\n        assert np.isclose(s.volume, 1/6)\n\n        triangle = Simplex(a, b, c)\n        assert np.isclose(triangle.volume, 1/2)\n\n    def test_transform(self):\n        a = Point(0, 0, 0)\n        b = Point(1, 0, 0)\n        c = Point(0, 1, 0)\n        d = Point(0, 0, 1)\n        s = Simplex(a, b, c, d)\n        x = Point(1, 1, 1)\n        t = translation(x)\n\n        assert t * s == Simplex(a + x, b + x, c + x, d + x)\n\n\nclass TestCuboid:\n\n    def test_intersect(self):\n        a = Point(0, 0, 0)\n        b = Point(1, 0, 0)\n        c = Point(0, 1, 0)\n        d = Point(0, 0, 1)\n        cube = Cuboid(a, b, c, d)\n        l = Line(Point(2, 0.5, 0.5), Point(-1, 0.5, 0.5))\n        assert cube.intersect(l) == [Point(0, 0.5, 0.5), Point(1, 0.5, 0.5)]\n\n    def test_edges(self):\n        a = Point(0, 0, 0)\n        b = Point(1, 0, 0)\n        c = Point(0, 1, 0)\n        d = Point(0, 0, 1)\n        cube = Cuboid(a, b, c, d)\n\n        assert len(cube.edges) == 12\n\n    def test_area(self):\n        a = Point(0, 0, 0)\n        b = Point(1, 0, 0)\n        c = Point(0, 1, 0)\n        d = Point(0, 0, 1)\n        cube = Cuboid(a, b, c, d)\n        assert len(cube.faces) == 6\n        assert len(cube.vertices) == 8\n        assert cube.area == 6\n\n    def test_transform(self):\n        a = Point(0, 0, 0)\n        b = Point(1, 0, 0)\n        c = Point(0, 1, 0)\n        d = Point(0, 0, 1)\n        cube = Cuboid(a, b, c, d)\n        x = Point(1, 1, 1)\n        t = translation(x)\n\n        assert t*cube == Cuboid(a+x, b+x, c+x, d+x)\n        assert isinstance(t*cube, Cuboid)\n\n    def test_add(self):\n        a = Point(0, 0, 0)\n        b = Point(1, 0, 0)\n        c = Point(0, 1, 0)\n        d = Point(0, 0, 1)\n        cube = Cuboid(a, b, c, d)\n        p = Point(1, 2, 3)\n\n        assert cube + p == Cuboid(a+p, b+p, c+p, d+p)\n        assert cube - p == Cuboid(a-p, b-p, c-p, d-p)\n\n    def test_getitem(self):\n        a = Point(0, 0, 0)\n        b = Point(1, 0, 0)\n        c = Point(0, 1, 0)\n        d = Point(0, 0, 1)\n        cube = Cuboid(a, b, c, d)\n\n        x, y, z = b - a, c - a, d - a\n        yz = Rectangle(a, a + z, a + y + z, a + y)\n        xz = Rectangle(a, a + x, a + x + z, a + z)\n        xy = Rectangle(a, a + x, a + x + y, a + y)\n\n        assert isinstance(cube[0], Polygon)\n        assert cube[0] == yz\n        assert cube[1] == xz\n        assert cube[2] == xy\n        assert cube[0, 0] == a\n\n\nclass TestSegmentCollection:\n\n    def test_contains(self):\n        p = PointCollection([(0, 0), (1, 0)], homogenize=True)\n        q = PointCollection([(2, 1), (3, 1)], homogenize=True)\n        s = SegmentCollection(p, q)\n\n        assert all(s.contains(p))\n        assert all(s.contains(q))\n        assert all(s.contains(0.5 * (p + q)))\n        assert not any(s.contains(p - q))\n        assert not any(s.contains(Point([2, 1, 0])))\n'"
tests/test_transformation.py,9,"b'import numpy as np\nfrom geometer import Point, Line, Transformation, TransformationCollection, translation, rotation, angle, scaling, reflection\n\n\nclass TestTransformation:\n\n    def test_from_points(self):\n        p1 = Point(0, 0)\n        p2 = Point(1, 0)\n        p3 = Point(0, 1)\n        p4 = Point(3, 5)\n        l = Line(p1, p3)\n\n        M = Transformation.from_points((p1, p1 + Point(1, 1)), (p2, p2 + Point(1, 1)), (p3, p3 + Point(1, 1)), (p4, p4 + Point(1, 1)))\n\n        assert M*p3 == Point(1, 2)\n        assert (M*l).contains(M*p1)\n        assert (M*l).contains(M*p3)\n\n    def test_translation(self):\n        p = Point(0, 1)\n        t = translation(0, -1)\n        assert t*p == Point(0, 0)\n\n        l = Line(Point(0, 0, 1), Point(1, 0, 1))\n        t = translation(0, 0, -1)\n        assert t*l == Line(Point(0, 0, 0), Point(1, 0, 0))\n\n    def test_inverse(self):\n        E = Transformation(np.eye(4))\n        M = rotation(np.pi, axis=Point(0, 1, 0))\n        assert M.inverse()*M == E\n\n    def test_pow(self):\n        t = translation(1, 2)\n\n        assert t**0 == Transformation(np.eye(3))\n        assert t**1 == t\n        assert t**2 == translation(2, 4)\n        assert t**3 == translation(3, 6)\n        assert t**(-2) == translation(-2, -4)\n\n    def test_rotation(self):\n        p = Point(0, 1)\n        t = rotation(-np.pi)\n        assert t*p == Point(0, -1)\n\n        p = Point(1, 0, 0)\n        t = rotation(-np.pi/2, axis=Point(0, 0, 1))\n        assert t * p == Point(0, 1, 0)\n\n        p = Point(-1, 1, 0)\n        a = np.pi / 7\n        t = rotation(a, axis=Point(1, 1, 2))\n        assert np.isclose(angle(p, t * p), a)\n\n    def test_scaling(self):\n        p = Point(1, 1, 2)\n        s = scaling(3, -4.5, 5)\n\n        assert s * p == Point(3, -4.5, 10)\n\n    def test_reflection(self):\n        p = Point(-1, 1)\n        r = reflection(Line(1, -1, 1))\n\n        assert r * p == Point(0, 0)\n\n\nclass TestTransformationCollection:\n\n    def test_inverse(self):\n        E = TransformationCollection([np.eye(4)]*10)\n        M = TransformationCollection([rotation(np.pi, axis=Point(0, 1, 0))]*10)\n        assert M.inverse() * M == E\n\n    def test_pow(self):\n        t = TransformationCollection([translation(1, 2)]*10)\n\n        assert t**2 == TransformationCollection([translation(2, 4)]*10)\n        assert t**3 == TransformationCollection([translation(3, 6)]*10)\n        assert t**(-2) == TransformationCollection([translation(-2, -4)]*10)\n'"
tests/test_utils.py,14,"b'from geometer.utils import null_space, adjugate, det, inv\nimport numpy as np\n\n\ndef test_adjugate():\n    a = np.array([[2, 3, 4, 3],\n                  [5, 1, 7, 6],\n                  [4, 7, 8, 1],\n                  [2, 3, 4, 5]])\n\n    adj = adjugate(a)\n    assert np.allclose(np.linalg.inv(a)*np.linalg.det(a), adj)\n\n\ndef test_det():\n    matrices = np.random.rand(10, 2, 2)\n    assert np.allclose(np.linalg.det(matrices), det(matrices))\n\n    matrices = np.random.rand(64, 3, 3)\n    assert np.allclose(np.linalg.det(matrices), det(matrices))\n\n\ndef test_inv():\n    matrices = np.random.rand(64, 2, 2)\n    assert np.allclose(np.linalg.inv(matrices), inv(matrices))\n\n    matrices = np.random.rand(64, 3, 3)\n    assert np.allclose(np.linalg.inv(matrices), inv(matrices))\n\n    matrices = np.random.rand(64, 4, 4)\n    assert np.allclose(np.linalg.inv(matrices), inv(matrices))\n\n\ndef test_null_space():\n    a = np.array([[2, 3, 4, 3],\n                  [5, 1, 7, 6],\n                  [4, 7, 8, 1],\n                  [2, 3, 4, 3]])\n    assert np.all(abs(a.dot(null_space(a))) < 1e-9)\n'"
geometer/utils/__init__.py,0,"b'from .math import null_space, hat_matrix, is_multiple, orth, adjugate, det, inv\nfrom .indexing import posify_index, normalize_index, sanitize_index\n\n\ndef distinct(iterable):\n    """"""A simple generator that returns only the distinct elements of another iterable.\n    Parameters\n    ----------\n    iterable\n        The iterable to filter.\n    Yields\n    ------\n        The distinct elements of the iterable.\n    """"""\n    seen = []\n    for x in iterable:\n        if x in seen:\n            continue\n        yield x\n        seen.append(x)\n'"
geometer/utils/indexing.py,15,"b'# Most of this file is taken from https://github.com/dask/dask/blob/master/dask/array/slicing.py\n# See license at https://github.com/dask/dask/blob/master/LICENSE.txt\n\nimport math\nfrom numbers import Integral, Number\n\nimport numpy as np\n\n\ndef _sanitize_index_element(ind):\n    """"""Sanitize a one-element index.""""""\n    if isinstance(ind, Number):\n        ind2 = int(ind)\n        if ind2 != ind:\n            raise IndexError(""Bad index.  Must be integer-like: %s"" % ind)\n        else:\n            return ind2\n    elif ind is None:\n        return None\n    else:\n        raise TypeError(""Invalid index type"", type(ind), ind)\n\n\ndef sanitize_index(ind):\n    """""" Sanitize the elements for indexing along one axis\n\n    >>> sanitize_index([2, 3, 5])\n    array([2, 3, 5])\n    >>> sanitize_index([True, False, True, False])\n    array([0, 2])\n    >>> sanitize_index(np.array([1, 2, 3]))\n    array([1, 2, 3])\n    >>> sanitize_index(np.array([False, True, True]))\n    array([1, 2])\n    >>> type(sanitize_index(np.int32(0)))\n    <class \'int\'>\n    >>> sanitize_index(1.0)\n    1\n    >>> sanitize_index(0.5)\n    Traceback (most recent call last):\n    ...\n    IndexError: Bad index.  Must be integer-like: 0.5\n    """"""\n    if ind is None:\n        return None\n    elif isinstance(ind, slice):\n        return slice(\n            _sanitize_index_element(ind.start),\n            _sanitize_index_element(ind.stop),\n            _sanitize_index_element(ind.step),\n        )\n    elif isinstance(ind, Number):\n        return _sanitize_index_element(ind)\n    index_array = np.asanyarray(ind)\n    if index_array.dtype == bool:\n        nonzero = np.nonzero(index_array)\n        if len(nonzero) == 1:\n            # If a 1-element tuple, unwrap the element\n            nonzero = nonzero[0]\n        return np.asanyarray(nonzero)\n    elif np.issubdtype(index_array.dtype, np.integer):\n        return index_array\n    elif np.issubdtype(index_array.dtype, np.floating):\n        int_index = index_array.astype(np.intp)\n        if np.allclose(index_array, int_index):\n            return int_index\n        else:\n            check_int = np.isclose(index_array, int_index)\n            first_err = index_array.ravel()[np.flatnonzero(~check_int)[0]]\n            raise IndexError(""Bad index.  Must be integer-like: %s"" % first_err)\n    else:\n        raise TypeError(""Invalid index type"", type(ind), ind)\n\n\ndef posify_index(shape, ind):\n    """""" Flip negative indices around to positive ones\n\n    >>> posify_index(10, 3)\n    3\n    >>> posify_index(10, -3)\n    7\n    >>> posify_index(10, [3, -3])\n    array([3, 7])\n    >>> posify_index((10, 20), (3, -3))\n    (3, 17)\n    >>> posify_index((10, 20), (3, [3, 4, -3]))  # doctest: +NORMALIZE_WHITESPACE\n    (3, array([ 3,  4, 17]))\n    """"""\n    if isinstance(ind, tuple):\n        return tuple(map(posify_index, shape, ind))\n    if isinstance(ind, Integral):\n        if ind < 0 and not math.isnan(shape):\n            return ind + shape\n        else:\n            return ind\n    if isinstance(ind, (np.ndarray, list)) and not math.isnan(shape):\n        ind = np.asanyarray(ind)\n        return np.where(ind < 0, ind + shape, ind)\n    return ind\n\n\ndef replace_ellipsis(n, index):\n    """""" Replace ... with slices, :, : ,:\n    >>> replace_ellipsis(4, (3, Ellipsis, 2))\n    (3, slice(None, None, None), slice(None, None, None), 2)\n    >>> replace_ellipsis(2, (Ellipsis, None))\n    (slice(None, None, None), slice(None, None, None), None)\n    """"""\n    # Careful about using in or index because index may contain arrays\n    isellipsis = [i for i, ind in enumerate(index) if ind is Ellipsis]\n    if not isellipsis:\n        return index\n    else:\n        loc = isellipsis[0]\n    extra_dimensions = n - (len(index) - sum(i is None for i in index) - 1)\n    return (\n        index[:loc] + (slice(None, None, None),) * extra_dimensions + index[loc + 1 :]\n    )\n\n\ndef normalize_index(idx, shape):\n    """""" Normalize slicing indexes\n\n    1.  Replaces ellipses with many full slices\n    2.  Adds full slices to end of index\n\n    Examples\n    --------\n    >>> normalize_index(1, (10,))\n    (1,)\n    >>> normalize_index((Ellipsis, None), (10,))\n    (slice(None, None, None), None)\n    """"""\n    if not isinstance(idx, tuple):\n        idx = (idx,)\n    idx = replace_ellipsis(len(shape), idx)\n    n_sliced_dims = 0\n    for i in idx:\n        if hasattr(i, ""ndim"") and i.ndim >= 1:\n            n_sliced_dims += i.ndim\n        elif i is None:\n            continue\n        else:\n            n_sliced_dims += 1\n    idx = idx + (slice(None),) * (len(shape) - n_sliced_dims)\n    if len([i for i in idx if i is not None]) > len(shape):\n        raise IndexError(""Too many indices for array"")\n\n    idx = tuple(map(sanitize_index, idx))\n    return idx\n'"
geometer/utils/math.py,33,"b'import math\nimport numpy as np\n\n\ndef is_multiple(a, b, axis=None, rtol=1.e-15, atol=1.e-8):\n    """"""Returns a boolean array where two arrays are scalar multiples of each other along a given axis.\n\n    This function compares the absolute value of the scalar product and the product of the norm of the arrays (along\n    an axis). The Cauchy-Schwarz inequality guarantees in its edge case that this equality holds if and only if one\n    of the vectors is a scalar multiple of the other.\n\n    For documentation of the tolerance parameters see :func:`numpy.isclose`.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    axis : None or int or tuple of ints, optional\n        The axis or axes along which the two arrays are compared.\n        The default axis=None will compare the whole arrays and return only a single boolean value.\n    rtol : float, optional\n        The relative tolerance parameter.\n    atol : float, optional\n        The absolute tolerance parameter.\n\n    Returns\n    -------\n    array_like\n        Returns a boolean array of where along the given axis the arrays are a scalar multiple of each other (within the\n        given tolerance). If no axis is given, returns a single boolean value.\n\n    """"""\n    a = np.asarray(a)\n    b = np.asarray(b)\n\n    a = a / np.max(np.abs(a), axis=axis, keepdims=True)\n    b = b / np.max(np.abs(b), axis=axis, keepdims=True)\n\n    if axis is None:\n        a = a.ravel()\n        b = b.ravel()\n\n    ab = np.sum(a * b.conj(), axis=axis)\n    return np.isclose(ab*ab.conj(), np.sum(a*a.conj(), axis=axis)*np.sum(b*b.conj(), axis=axis), rtol, atol)\n\n\ndef hat_matrix(*args):\n    r""""""Builds a skew symmetric matrix with the given scalars in the positions shown below.\n\n    .. math::\n\n        \\begin{pmatrix}\n            0  &  c & -b\\\\\n            -c &  0 & a \\\\\n            b  & -a & 0\n        \\end{pmatrix}\n\n    Parameters\n    ----------\n    a, b, c : float\n        The scalars to use in the matrix.\n\n    Returns\n    -------\n    numpy.ndarray\n        The resulting antisymmetric matrix.\n\n    """"""\n    if len(args) == 1:\n        args = args[0]\n\n    x = np.asarray(args)\n    n = int(1+np.sqrt(1+8*x.shape[-1])) // 2\n\n    result = np.zeros(x.shape[:-1] + (n, n), x.dtype)\n\n    if n == 3:\n        i, j = [1, 2, 0], [2, 0, 1]\n        result[..., i, j] = x\n        result[..., j, i] = -x\n        return result\n\n    i, j = np.triu_indices(n, 1)\n    i, j = i[::-1], j[::-1]\n    result[..., i, j] = x\n    result[..., j, i] = -x\n\n    return result\n\n\ndef _assert_square_matrix(A):\n    if A.ndim < 2:\n        raise np.linalg.LinAlgError(""%s-dimensional array given. Array must be at least two-dimensional"" % A.ndim)\n    m, n = A.shape[-2:]\n    if m != n:\n        raise np.linalg.LinAlgError(\'Last 2 dimensions of the array must be square\')\n\n\ndef adjugate(A):\n    r""""""Calculates the adjugate matrix of A.\n\n    The resulting matrix is defined by\n\n    .. math::\n        \\textrm{adj}(A)_{ij} = (-1)^{i+j} M_{j i},\n\n    where :math:`M_{j i}` is the determinant of the submatrix of :math:`A` obtained by deleting the j-th row and the\n    i-th column of :math:`A`.\n\n    For small matrices, this function uses the following formula (Einstein notation):\n\n    .. math::\n        \\textrm{adj}(A)_{ij} = \\frac{1}{(n-1)!} \\varepsilon_{i\\ i_2 \\ldots i_n} \\varepsilon_{j\\ j_2 \\ldots j_n} A_{j_2 i_2} \\ldots A_{j_n i_n}\n\n    Source (German):\n    https://de.wikipedia.org/wiki/Levi-Civita-Symbol#Zusammenhang_mit_der_Determinante\n\n    Parameters\n    ----------\n    A : (..., M, M) array_like\n        The input matrix.\n\n    Returns\n    -------\n    (..., M, M) numpy.ndarray\n        The adjugate of A.\n\n    """"""\n    A = np.asarray(A)\n    _assert_square_matrix(A)\n    n = A.shape[-1]\n\n    if n <= 1:\n        return A\n\n    if n == 2:\n        result = A[..., [[1, 0], [1, 0]], [[1, 1], [0, 0]]]\n        result[..., [0, 1], [1, 0]] *= -1\n        return result\n\n    if n >= 5 or A.size >= n*n*64:\n        indices = np.indices((n, n))\n        indices = [np.delete(np.delete(indices, i, axis=1), j, axis=2) for i in range(n) for j in range(n)]\n        indices = np.stack(indices, axis=1)\n        minors = A[..., indices[0], indices[1]]\n        result = det(minors).reshape(A.shape)\n        result = np.swapaxes(result, -1, -2)\n        result[..., 1::2, ::2] *= -1\n        result[..., ::2, 1::2] *= -1\n        return result\n\n    from ..base import TensorDiagram, Tensor, LeviCivitaTensor\n\n    e1 = LeviCivitaTensor(n, False)\n    e2 = LeviCivitaTensor(n, False)\n    tensors = [Tensor(A, tensor_rank=2, copy=False) for _ in range(n-1)]\n    diagram = TensorDiagram(*[(t, e1) for t in tensors], *[(t, e2) for t in tensors])\n\n    return np.swapaxes(diagram.calculate().array, -1, -2) / math.factorial(n-1)\n\n\ndef det(A):\n    """"""Computes the determinant of A.\n\n    Parameters\n    ----------\n    A : (..., M, M) array_like\n        The input matrix.\n\n    Returns\n    -------\n    (...) array_like\n        The determinant of A.\n\n    """"""\n    A = np.asarray(A)\n    _assert_square_matrix(A)\n    n = A.shape[-1]\n\n    if n == 2:\n        return A[..., 0, 0]*A[..., 1, 1] - A[..., 1, 0]*A[..., 0, 1]\n\n    if n == 3 and A.size >= 9*64:\n        return A[..., 0, 0]*A[..., 1, 1]*A[..., 2, 2] + A[..., 0, 1]*A[..., 1, 2]*A[..., 2, 0]\\\n               + A[..., 0, 2]*A[..., 1, 0]*A[..., 2, 1] - A[..., 2, 0]*A[..., 1, 1]*A[..., 0, 2]\\\n               - A[..., 2, 1]*A[..., 1, 2]*A[..., 0, 0] - A[..., 2, 2]*A[..., 1, 0]*A[..., 0, 1]\n\n    return np.linalg.det(A)\n\n\ndef inv(A):\n    """"""Computes the inverse of A.\n\n    Parameters\n    ----------\n    A : (..., M, M) array_like\n        The input matrix.\n\n    Returns\n    -------\n    (..., M, M) numpy.ndarray\n        The inverse of A.\n\n    """"""\n    A = np.asarray(A)\n    _assert_square_matrix(A)\n    n = A.shape[-1]\n\n    if n <= 4 and A.size >= n*n*64:\n        d = det(A)\n\n        if np.any(d == 0):\n            raise np.linalg.LinAlgError(""Singular matrix"")\n\n        return adjugate(A) / d[..., None, None]\n\n    return np.linalg.inv(A)\n\n\ndef null_space(A, dim=None):\n    """"""Constructs an orthonormal basis for the null space of a A using SVD.\n\n    Parameters\n    ----------\n    A : (..., M, N) array_like\n        The input matrix.\n    dim : int or None, optional\n        The dimension of the null space if previously known.\n\n    Returns\n    -------\n    (..., N, K) numpy.ndarray\n        Orthonormal basis for the null space of A (as column vectors in the returned matrix).\n\n    """"""\n    u, s, vh = np.linalg.svd(A, full_matrices=True)\n\n    if dim is None:\n        tol = max(A.shape[-2:]) * np.spacing(np.max(s, axis=-1, keepdims=True))\n        dim = np.sum(s > tol, axis=-1, dtype=int)\n        if not np.all(dim == dim.flat[0]):\n            raise ValueError(\'Cannot calculate the null spaces of matrices when the spaces have different dimensions.\')\n        dim = -dim.flat[0]\n\n    Q = np.swapaxes(vh[..., -dim:, :], -1, -2).conj()\n    return Q\n\n\ndef orth(A, dim=None):\n    """"""Constructs an orthonormal basis for the range of A using SVD.\n\n    Parameters\n    ----------\n    A : (..., M, N) array_like\n        The input matrix.\n    dim : int or None, optional\n        The dimension of the image space if previously known.\n\n    Returns\n    -------\n    (..., M, K) numpy.ndarray\n        Orthonormal basis for the range of A (as column vectors in the returned matrix).\n\n    """"""\n    u, s, vh = np.linalg.svd(A, full_matrices=False)\n\n    if dim is None:\n        tol = max(A.shape[-2:]) * np.spacing(np.max(s, axis=-1, keepdims=True))\n        dim = np.sum(s > tol, axis=-1, dtype=int)\n        if not np.all(dim == dim.flat[0]):\n            raise ValueError(\'Cannot calculate the image spaces of matrices when the spaces have different dimensions.\')\n        dim = dim.flat[0]\n\n    Q = u[:, :dim]\n    return Q\n'"
