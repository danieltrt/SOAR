file_path,api_count,code
setup.py,0,"b'from setuptools import setup\n\npackages=[\'diced\',\n          \'diced.tests\']\n\nsetup(name=\'diced\',\n      version=\'0.2\',\n      description=\'Enable access to large, cloud-based nD data volumes\',\n      url=\'https://github.com/janelia-flyem/DVIDCloudStore\',\n      packages=packages,\n      include_package_data=True,\n      test_suite=""diced.tests"",\n      zip_safe=False # So we can run the tests after installation\n      )\n'"
diced/DicedArray.py,7,"b'""""""Functionality to store and retrieve data into Diced arrays.\n""""""\n\nfrom __future__ import absolute_import\nimport numpy as np\nfrom enum import Enum\nfrom .DicedException import DicedException\n\nclass ArrayDtype(Enum):\n    """"""Defines datatypes supported.\n    """"""\n    uint8 = np.uint8\n    uint16 = np.uint16\n    uint32 = np.uint32\n    uint64 = np.uint64\n\n\nclass DicedArray(object):\n    """"""Implements acces to nD arrays in Diced (__init__ internally by DicedRepo)\n\n    Diced supports 1D, 2D, and 3D arrays for 8, 16, 32, and\n    64 bits.  This data is stored using lossless compression unless\n    lossy JPEG compression is chosen when the array is created.\n\n    Data can be retrieved or stored using any index int location.\n    The current extents just refers to the BBOX for the currently\n    written data.\n\n    For array data that is a non-noisy labeling (potentially as\n    a result of object prediction), it is best to choose \n    a Diced label array which will support up to 64 bit data and\n    whose compression is mostly independent of the size required\n    for each data element.\n\n    Note:\n        Reserve JPEG compression and label types for 3D data only.\n\n\n    TODO:\n        Support a general ND interface.  This depends on the creation\n        of this API in DVID.\n\n        Extents is a crude way to note what data has been changed.\n        Eventually, there should be a more precise way to note all the\n        voxels that have been written to in the array.\n    """"""\n\n    MAX_REQ_SIZE = 512*512*512\n\n    def __init__(self, name, dicedstore, locked, nodeconn, numdims, dtype, islabel3D):\n        """"""Internal Init.\n\n        Init is called by DicedRepo.  It has a pointer to dicedstore\n        to ensure DiceStore is active while this instance is around.\n\n        Args:\n            name (str): datatype instance\n            dicedstore (DicedStore): referenced to DicedStore\n            locked (str): if node locked, read only\n            nodeconn (libdvid object): connection to DVID version node\n            numdims (int): number of dimensions for array\n            dtype (ArrayDtype): array datatype\n            islabel3D (bool): is a label array type\n        """"""\n\n        self.instancename = name\n        self.dicedstore = dicedstore\n        self.locked = locked\n        self.ns = nodeconn\n        self.numdims = numdims\n        self.dtype = dtype\n        self.islabel3D = islabel3D\n\n        # extract specific meta\n        allmeta = self.ns.get_typeinfo(self.instancename)\n        self.blocksize = allmeta[""Extended""][""BlockSize""]\n   \n    def get_numdims(self):\n        """"""Retrieves the number of dimensions.\n\n        Returns:\n            int indicating the number of dimensions\n        """"""\n\n        return self.numdims\n\n    def get_extents(self):\n        """"""Retrieve extants for array.\n\n        This shows the extent of data written aligned to\n        the internal chunk storage size.\n\n        Returns:\n            tuple of slices\n        """"""\n\n        # return extents (z,y,x)\n        val = self.ns.get_typeinfo(self.instancename)\n        \n        minpoint = val[""Extended""][""MinPoint""]\n        xs = ys = zs = 0\n        if minpoint is not None:\n            xs,ys,zs = val[""Extended""][""MinPoint""]\n        \n        maxpoint = val[""Extended""][""MaxPoint""]\n        xf = yf = zf = -1\n        if maxpoint is not None:\n            xf,yf,zf = val[""Extended""][""MaxPoint""]\n        \n        if self.numdims == 3:\n            return (slice(zs,zf+1), slice(ys,yf+1), slice(xs,xf+1))\n        elif self.numdims == 2:\n            return (slice(ys,yf+1), slice(xs,xf+1))\n        elif self.numdims == 1:\n            return (slice(xs,xf+1))\n\n\n    def _getchunk(self, z, y, x, zsize, ysize, xsize):\n        """"""Internal function to retrieve data.\n        """"""\n        \n        data = None\n        \n        # interface is the same for labels and raw arrays but the function is stateless\n        # and can benefit from extra compression possible in labels in some use cases\n        if self.dtype == ArrayDtype.uint8:\n            data = self.ns.get_array8bit3D(self.instancename, (zsize, ysize, xsize), (z, y, x), self.islabel3D)\n        elif self.dtype == ArrayDtype.uint16:\n            data = self.ns.get_array16bit3D(self.instancename, (zsize, ysize, xsize), (z, y, x), self.islabel3D)\n        elif self.dtype == ArrayDtype.uint32:\n            data = self.ns.get_array32bit3D(self.instancename, (zsize, ysize, xsize), (z, y, x), self.islabel3D)\n        elif self.dtype == ArrayDtype.uint64:\n            data = self.ns.get_array64bit3D(self.instancename, (zsize, ysize, xsize), (z, y, x), self.islabel3D)\n        else:\n            raise DicedException(""Invalid datatype for array"")\n\n        return data\n\n\n    def __getitem__(self, index):\n        """"""Use index to retrieve array data.\n        \n        Note:\n            Large requests are split into several small requests.  Data\n            can be requested outside of the extents.\n        """"""\n\n        dimsreq = 1\n        # handle query of single point\n        singleindex1 = False\n        singleindex2 = False\n        singleindex3 = False\n\n        if type(index) == int:\n            index = slice(index, index+1)\n            singleindex3 = True\n        elif type(index) != slice:\n            dimsreq = len(index)\n            if dimsreq == 3:\n                a, b, c = index\n                if type(a) == int:\n                    a = slice(a, a+1)\n                    singleindex1 = True\n                if type(b) == int:\n                    b = slice(b, b+1)\n                    singleindex2 = True\n                if type(c) == int:\n                    c = slice(c, c+1)\n                    singleindex3 = True\n                index = (a, b, c)\n            if dimsreq == 2:\n                a, b = index\n                if type(a) == int:\n                    a = slice(a, a+1)\n                    singleindex2 = True\n                if type(b) == int:\n                    b = slice(b, b+1)\n                    singleindex3 = True\n                index = (a, b)\n\n        if self.numdims != dimsreq:\n            raise DicedException(""Array has a different number of dimensions than requested"")\n\n        z = y = x = slice(0,1)\n        if dimsreq == 3:\n            z,y,x = index\n        elif dimsreq == 2:\n            y, x = index\n        else:\n            x = index\n\n        data = None\n\n        # only support calls to volumes <= 512x512x512, larger calls should\n        # be split into several pieces\n        zsize = z.stop - z.start\n        ysize = y.stop - y.start\n        xsize = x.stop - x.start\n        if zsize*ysize*xsize > self.MAX_REQ_SIZE:\n            data = np.zeros((zsize, ysize, xsize), self.dtype.value)\n       \n            # split into chunks\n            zincr = zsize    \n            yincr = ysize    \n            xincr = xsize    \n     \n            while zincr*yincr*xincr > self.MAX_REQ_SIZE:\n                if zincr > yincr and zincr > xincr:\n                    zincr = zincr//2 + zincr % 2\n                elif yincr > zincr and yincr > xincr:\n                    yincr = yincr//2 + yincr % 2\n                else:\n                    xincr = xincr//2 + xincr % 2\n\n            for ziter in range(0, zsize, zincr):\n                for yiter in range(0, ysize, yincr):\n                    for xiter in range(0, xsize, xincr):\n                        zstart = ziter + z.start\n                        ystart = yiter + y.start\n                        xstart = xiter + x.start\n                       \n                        csizez = min(z.stop - zstart, zincr)\n                        csizey = min(y.stop - ystart, yincr)\n                        csizex = min(x.stop - xstart, xincr)\n\n                        tdata = self._getchunk(zstart, ystart, xstart, csizez, csizey, csizex)\n                        data[ziter:ziter+csizez, yiter:yiter+csizey, xiter:xiter+csizex] = tdata\n        else:\n            # small call can be had in one call\n            data = self._getchunk(z.start, y.start, x.start, zsize, ysize, xsize)\n\n        # squeeze data as requested\n        if self.numdims == 3:\n            if singleindex1 and singleindex2 and singleindex3:\n                data = int(data.squeeze())\n            elif singleindex1 and singleindex2:\n                data = data.squeeze((0,1))\n            elif singleindex2 and singleindex3:\n                data = data.squeeze((1,2))\n            elif singleindex1 and singleindex3:\n                data = data.squeeze((0,2))\n            elif singleindex1:\n                data = data.squeeze(0)\n            elif singleindex2:\n                data = data.squeeze(1)\n            elif singleindex3:\n                data = data.squeeze(2)\n\n        elif self.numdims == 2:\n            data = data.squeeze(0)\n\n            if singleindex2 and singleindex3:\n                data = int(data.squeeze())\n            elif singleindex2:\n                data = data.squeeze(0)\n            elif singleindex3:\n                data = data.squeeze(1)\n\n        elif self.numdims == 1:\n            data = data.squeeze((0,1))\n            if singleindex3:\n                data = int(data.squeeze)\n\n        return data\n    \n    def _setchunk(self, z, y, x, data):\n        """"""Internal function to set data.\n        """"""\n       \n        # does not support setting individual elements\n        # (inefficiently accesses diced store)\n        if type(data) != np.ndarray:\n            raise DicedException(""Must set data using a numpy array"")\n        \n        # check if block aligned and adjust extents\n        xblk, yblk, zblk = self.blocksize\n        zsize = ysize = xsize = 1\n        if len(data.shape) == 3:\n            zsize, ysize, xsize = data.shape\n        elif len(data.shape) == 2:\n            ysize, xsize = data.shape\n        elif len(data.shape) == 1:\n            xsize = data.shape[0]\n       \n        zsizeorig = zsize\n        ysizeorig = ysize\n        xsizeorig = xsize\n        \n        blockaligned = True\n    \n        znew = z - (z%zblk)\n        ynew = y - (y%yblk)\n        xnew = x - (x%xblk)\n       \n        zsize += (z%zblk)\n        ysize += (y%yblk)\n        xsize += (x%xblk)\n\n        if znew != z or ynew != y or xnew != x:\n            blockaligned = False\n       \n        if zsize % zblk > 0:\n            blockaligned = False\n            zsize += (zblk - zsize%zblk)\n        \n        if ysize % yblk > 0:\n            blockaligned = False\n            ysize += (yblk - ysize%yblk)\n\n        if xsize % xblk > 0:\n            blockaligned = False\n            xsize += (xblk - xsize%xblk)\n       \n        # retrieve data from DVID and pad with data if not block aligned\n        # TODO: optimize to minimize data fetches from DVID\n        if not blockaligned:\n            newdata = self._getchunk(znew, ynew, xnew, zsize, ysize, xsize)\n            newdata[(z-znew):(z-znew+zsizeorig),(y-ynew):(y-ynew+ysizeorig),(x-xnew):(x-xnew+xsizeorig)] = data\n            data = newdata\n\n        # interface is the same for labels and raw arrays but the function is stateless\n        # and can benefit from extra compression possible in labels in some use cases\n        if self.dtype == ArrayDtype.uint8:\n            data = self.ns.put_array8bit3D(self.instancename, data, (znew, ynew, xnew), self.islabel3D)\n        elif self.dtype == ArrayDtype.uint16:\n            data = self.ns.put_array16bit3D(self.instancename, data, (znew, ynew, xnew), self.islabel3D)\n        elif self.dtype == ArrayDtype.uint32:\n            data = self.ns.put_array32bit3D(self.instancename, data, (znew, ynew, xnew), self.islabel3D)\n        elif self.dtype == ArrayDtype.uint64:\n            data = self.ns.put_array64bit3D(self.instancename, data, (znew, ynew, xnew), self.islabel3D)\n        else:\n            raise DicedException(""Invalid datatype for array"")\n\n\n    def __setitem__(self, index, val):\n        """"""Use index to set array data.\n\n        Note:\n            Large requests are split into several small requests.  Data\n            can be sent outside of the extents.\n        """"""\n       \n        dimsreq = 1\n        if type(index) == int:\n            # handle query of single point\n            index = slice(index, index+1)\n        elif type(index) != slice:\n            dimsreq = len(index)\n            if dimsreq == 3:\n                a, b, c = index\n                if type(a) == int:\n                    a = slice(a, a+1)\n                if type(b) == int:\n                    b = slice(b, b+1)\n                if type(c) == int:\n                    c = slice(c, c+1)\n                index = (a, b, c)\n            if dimsreq == 2:\n                a, b = index\n                if type(a) == int:\n                    a = slice(a, a+1)\n                if type(b) == int:\n                    b = slice(b, b+1)\n                index = (a, b)\n\n\n        if self.numdims != dimsreq:\n            raise DicedException(""Array has a different number of dimensions than requested"")\n\n        if self.locked:\n            raise DicedException(""Cannot write to locked node"")\n\n        z = y = x = slice(0,1)\n        if dimsreq == 3:\n            z,y,x = index\n        elif dimsreq == 2:\n            y, x = index\n        else:\n            x = index\n\n        # only support calls to volumes <= 512x512x512, larger calls should\n        # be split into several pieces\n        zsize = z.stop - z.start\n        ysize = y.stop - y.start\n        xsize = x.stop - x.start\n        if zsize*ysize*xsize > self.MAX_REQ_SIZE: \n            data = np.zeros((zsize, ysize, xsize), self.dtype.value)\n            # split into chunks\n            zincr = zsize    \n            yincr = ysize    \n            xincr = xsize    \n       \n            while zincr*yincr*xincr > self.MAX_REQ_SIZE:\n                if zincr > yincr and zincr > xincr:\n                    zincr = zincr//2 + zincr % 2\n                elif yincr > zincr and yincr > xincr:\n                    yincr = yincr//2 + yincr % 2\n                else:\n                    xincr = xincr//2 + xincr % 2\n\n            for ziter in range(0, zsize, zincr):\n                for yiter in range(0, ysize, yincr):\n                    for xiter in range(0, xsize, xincr):\n                        zstart = ziter + z.start\n                        ystart = yiter + y.start\n                        xstart = xiter + x.start\n                       \n                        csizez = min(z.stop - zstart, zincr)\n                        csizey = min(y.stop - ystart, yincr)\n                        csizex = min(x.stop - xstart, xincr)\n\n                        self._setchunk(zstart, ystart, xstart,\n                                val[ziter:ziter+csizez, yiter:yiter+csizey, xiter:xiter+csizex].copy())\n        else:\n            self._setchunk(z.start, y.start, x.start, val)\n\n        return\n\n'"
diced/DicedException.py,0,"b'""""""Simple custom excpetion for DICED.\n""""""\n\nclass DicedException(Exception):\n    """"""Use default Exception handling.\n    """"""\n    pass\n'"
diced/DicedRepo.py,0,"b'""""""Functonality to access a specific version of a repository.\n""""""\n\nfrom __future__ import absolute_import\nimport sys\nimport json\nimport subprocess\n\nfrom libdvid import DVIDNodeService, ConnectionMethod, DVIDConnection\nfrom libdvid._dvid_python import DVIDException\nfrom .DicedException import DicedException\nfrom .DicedArray import DicedArray\nfrom .DicedArray import ArrayDtype\n\nif sys.version_info.major >= 3:\n    unicode = str\n\nclass DicedRepo(object):\n    """"""Provides access to a version of the specified repo.\n\n    Note:\n        If the version of the repo has been locked (i.e., is not open),\n        creating datainstance and writing data is disabled.  If one\n        wants to write to the repo, a new node should be branched.\n    \n        There are several several metadata conventions that are\n        used by diced.\n\n            * files are always located in \'.files\'\n            * .meta contains various information about repo\n            * .meta/restrictions: is a list of instance names to be ignored by default (set outside of diced)\n            * .meta/instance:{instancename:datauuid}: contains \'{""numdims"": <num>}\'\n            * .meta/neuroglancer: contains a list of instances compatible with neuroglancer\n\n    """""" \n    \n    # block size constants\n    BLKSIZE3D = 64\n    BLKSIZE2D = 512\n    BLKSIZE1D = 262144\n   \n    # keep track of all internal DVID datatypes supported\n    SupportedTypes = {""uint8blk"" : ArrayDtype.uint8, ""uint16blk"": ArrayDtype.uint16,\n            ""uint32blk"": ArrayDtype.uint32, ""uint64blk"": ArrayDtype.uint64,\n            ""labelblk"": ArrayDtype.uint64}\n    RawTypeMappings = {ArrayDtype.uint8: ""uint8blk"", ArrayDtype.uint16: ""uint16blk"",\n                        ArrayDtype.uint32: ""uint32blk"", ArrayDtype.uint64: ""uint64blk""} \n    LabelTypeMappings = {ArrayDtype.uint8: ""labelblk"", ArrayDtype.uint16: ""labelblk"",\n                        ArrayDtype.uint32: ""labelblk"", ArrayDtype.uint64: ""labelblk""} \n\n    LabelTypes = set([""labelblk""])\n   \n    MetaLocation = "".meta""\n    FilesLocation = "".files""\n    RestrictionName = ""restrictions""\n    InstanceMetaPrefix = ""instance:""\n\n    def __init__(self, server, uuid, dicedstore, readonly=False):\n        self.server = server\n        \n        # create connection object to DVID\n        self.rawconn = DVIDConnection(server) \n        \n        # hold reference\n        self.dicedstore = dicedstore\n\n        self.uuid = None\n        \n        # DVID version node connection\n        self.nodeconn = None\n\n        # all instances to ignore for ls\n        self.hidden_instances = None\n\n        # fetch all repo information\n        self.repoinfo = None\n        # whether current version is read only\n        self.locked = None\n       \n        # meta for current node\n        self.current_node = None\n\n        # instances available at version\n        self.allinstances = None\n        self.activeinstances = None\n        \n        # initialize version specific data\n        self._init_version(uuid)\n\n        # create meta types if not currently available\n        # This operation is not available if the DVID server is running in\n        # readonly mode, but most of this library will still work if it is.\n        # Supplying readonly=True in the constructor will bypass this initialisation.\n        if not readonly:\n            if self.MetaLocation not in self.activeinstances:\n                self.nodeconn.create_keyvalue(self.MetaLocation)\n            if self.FilesLocation not in self.activeinstances:\n                self.nodeconn.create_keyvalue(self.FilesLocation)\n\n    def change_version(self, uuid):\n        """"""Change the current node version.\n\n        Args:\n            uuid (str): version node to use\n        \n        Raises:\n            DicedException if UUID not found\n        """"""\n        \n        for tuuid in self.alluuids:\n            if tuuid.startswith(uuid):\n                self._init_version(uuid) \n                return\n        raise DicedException(""UUID not found"")\n\n    def get_current_version(self):\n        """"""Retrieve the current version ID.\n\n        Returns:\n            String for UUID\n        """"""\n\n        return self.uuid\n\n    def get_array(self, name):\n        """"""Retrive a DicedArray object.\n\n        Returns:\n            DicedArray\n\n        Raises:\n            DicedException if the array does not exist\n        """"""\n\n        if name in self.activeinstances:\n            # check if accepted type\n            typename = self.activeinstances[name]\n            if typename in self.SupportedTypes: # only support arrays\n                islabel3D = typename in self.LabelTypes\n                numdims = 3\n\n                # check if num dims specified\n                try:\n                    datauuid = self.repoinfo[""DataInstances""][name][""Base""][""DataUUID""]\n                    data = self.nodeconn.get_json(self.MetaLocation, str(self.InstanceMetaPrefix+name+"":""+datauuid))\n                    numdims = data[""numdims""]\n                except:\n                    pass\n\n                return DicedArray(name, self.dicedstore, self.locked, self.nodeconn, \n                        numdims, self.SupportedTypes[typename], islabel3D)\n            else:\n                raise DicedException(""Instance name: "" + name + "" has an unsupported type "" + typename)\n        \n        raise DicedException(""Instance name: "" + name + "" not found in version "" + self.uuid)\n\n\n    def create_array(self, name, dtype, dims=3, islabel3D=False,\n            lossycompression=False, versioned=True): \n        """"""Create a new array in the repo at this version.\n\n        Args:\n            name (str): unique name for this array\n            dtype (ArrayDtype): datatype (not relevant if labels)\n            dims (int): number of dimensions (support 1,2,3)\n            islabel3D (bool): treat as label data (usually highly compressible) (always 64bit)\n            versioned (bool): allow array to be versioned\n            lossycompresion (bool): use lossy compression (only if not islabel3D)\n\n        Returns:\n            new DicedArray object\n\n        Raises:\n            DicedException if node is locked or name is already used.\n        """"""\n\n        if self.locked:\n            raise DicedException(""Cannot create instance on locked node"")\n       \n        for (tname, uuid) in self.allinstances:\n            if tname == name:\n                raise DicedException(""Name already exists in repo"")\n\n        if islabel3D and dims != 3:\n            raise DicedException(""islabel3D only supported for 3D data"")\n        \n        if islabel3D and dtype != ArrayDtype.uint64:\n            raise DicedException(""islabel3D only works with 64 bit data"")\n\n        endpoint = ""/repo/"" + self.uuid + ""/instance""\n        typename = self.RawTypeMappings[dtype]\n        if islabel3D:\n            typename = self.LabelTypeMappings[dtype]\n\n        # handle blocksize\n        blockstr = str(self.BLKSIZE3D) + "","" + str(self.BLKSIZE3D) + "","" + str(self.BLKSIZE3D)\n        if dims == 2:\n            blockstr = str(self.BLKSIZE2D) + "","" + str(self.BLKSIZE2D) + "","" + str(1)\n        if dims == 1:\n            blockstr = str(self.BLKSIZE1D) + "","" + str(1) + "","" + str(1)\n\n        data = {""typename"": typename, ""dataname"": name, ""BlockSize"": blockstr}\n        \n        if not islabel3D and lossycompression:\n            data[""Compression""] = ""jpeg""\n\n        self.rawconn.make_request(endpoint, ConnectionMethod.POST, json.dumps(data).encode(\'utf-8\'))\n\n        # update current node meta \n        self._init_version(self.uuid)\n        \n        # use \'.meta\' keyvalue to store array size (since not internal to DVID yet)\n        self.nodeconn.put(self.MetaLocation, self.InstanceMetaPrefix+name+"":""+str(self.repoinfo[""DataInstances""][name][""Base""][""DataUUID""]), json.dumps({""numdims"": dims}).encode(\'utf-8\'))\n\n        return DicedArray(name, self.dicedstore, False, self.nodeconn, \n            dims, dtype, islabel3D)\n\n    def get_commit_log(self):\n        """"""Retrieve a list of commit log messages.\n        \n        Returns:\n            [(str, str] array of uuid, log messages\n        """"""\n\n        return self.loghistory \n        \n\n    def upload_filedata(self, dataname, data):\n        """"""Upload file data to this repo version.\n\n        Args:\n            dataname (str): name of file\n            data (str): data to store\n        \n        Raises:\n            DicedException if locked\n        """"""\n\n        if self.locked:\n            raise DicedException(""Node already locked"")\n        if isinstance(data, unicode):\n            data = data.encode(\'utf-8\')\n        self.nodeconn.put(self.FilesLocation, dataname, data)\n\n\n    def download_filedata(self, dataname):\n        """"""Download file data.\n\n        Args:\n            dataname (str): name of file\n           \n        Returns:\n            Data for file as a string\n\n        Raises:\n            DicedException if file does not exist\n        """"""\n\n        data = None\n        try:\n            data = self.nodeconn.get(self.FilesLocation, dataname)\n        except DVIDException:\n            raise DicedException(""file does not exist"")\n        return data\n\n    def list_instances(self, showhidden=False):\n        """"""Lists data store in this version of the repo.\n\n        This will show all the array data.  The user can\n        choose to show everything shown in DVID.\n\n        Args:\n            showhidden (boolean): show all instances (even non-array)\n       \n        Return:\n            [ (instance name, ArrayDtype) ] if showhidden is True\n            the function returns [ (instance name, type name string) ].\n\n        """"""\n        \n        res = []\n        for instance, typename in self.activeinstances.items():\n            if showhidden:\n                res.append((instance, typename))\n            elif typename in self.SupportedTypes and instance not in self.hidden_instances:\n                res.append((instance, self.SupportedTypes[typename]))\n    \n        return res\n\n    def list_files(self):\n        """"""List all the files for this version node.\n        \n        Returns:\n            List of strings for file names\n        """"""\n\n        json_text = self.nodeconn.custom_request(""/"" + self.FilesLocation + ""/keys/0/z"", b"""",\n            ConnectionMethod.GET)\n        return json.loads(json_text)\n\n    def create_branch(self, message):\n        """"""Create a new branch from this locked node.\n\n        Args:\n            message (str): commit message\n        \n        Returns:\n            string for new version UUID            \n\n        Raises:\n            DicedExcpetion if node is not locked.\n        """"""\n        \n        if not self.locked:\n            raise DicedException(""Must lock node before branching"")\n        \n        res = self.nodeconn.custom_request(""/branch"",\n                                           json.dumps({""note"": message}).encode(\'utf-8\'),\n                                           ConnectionMethod.POST)\n        res = json.loads(res)\n\n        #  add new uuid (no need to reinit everything)\n        self.alluuids.add(str(res[""child""]))\n\n        return str(res[""child""])\n        \n\n    def lock_node(self, message):\n        """"""Lock node.\n\n        Args:\n            message (str): commit message\n        \n        Returns:\n            string for new version UUID            \n\n        Raises:\n            DicedExcpetion if node is already locked.\n        """"""\n        \n        if self.locked:\n            raise DicedException(""Node already locked"")\n        \n        self.nodeconn.custom_request(""/commit"",\n                                     json.dumps({""note"": message}).encode(\'utf-8\'),\n                                     ConnectionMethod.POST)\n\n        # no need to reinit everything\n        self.locked = True\n   \n    def delete_file(self, filename):\n        """"""Delete file from this version.\n\n        This will only delete the file from the current version.\n        \n        Args:\n            filename (str): name of file\n        \n        Raises:\n            DicedExcpetion if node is already locked.\n        """"""\n        \n        if self.locked:\n            raise DicedException(""Node already locked"")\n\n        self.nodeconn.custom_request(""/"" + self.FilesLocation + ""/key/"" + filename, \n                b"""", ConnectionMethod.DELETE)\n        \n    def delete_array(self, dataname):\n        """"""Delete array from repo (not just version!) -- this cannot be undone!\n\n        Note:\n            For large arrays this could be very time-consuming.\n            While this is non-blocking, currently, DVID\n            will not resume the deletion on restart, so it is\n            possible for data to still be stored even if it\n            is superficially removed.  For now, the user should\n            ensure DicedStore is open for a some time after\n            issue the command.\n\n        TODO:\n            Implement a restartable background delete.\n\n        """"""\n\n        addr = self.dicedstore._server.split(\':\')[0]\n        rpcaddress = addr + "":"" + str(self.dicedstore.rpcport)\n        deletecall = subprocess.Popen([\'dvid\', \'-rpc=\'+rpcaddress, \'repo\', self.uuid, \'delete\', dataname], stdout=None)\n        deletecall.communicate()\n\n        self._init_version(self.uuid)\n\n    def _init_version(self, uuid):\n        # create connection to repo\n        self.nodeconn = DVIDNodeService(str(self.server), str(uuid))\n        \n        # fetch all repo information\n        status, data, errmsg = self.rawconn.make_request(""/repo/"" + uuid + ""/info"", ConnectionMethod.GET)\n        self.repoinfo = json.loads(data)\n        self.allinstances = {}\n        # load all versions in repo\n        self.alluuids = set()\n        dag = self.repoinfo[""DAG""][""Nodes""]\n        for uuidt, nodedata in dag.items():\n            self.alluuids.add(str(nodedata[""UUID""]))\n        \n        for instancename, val in self.repoinfo[""DataInstances""].items():\n            # name is not necessarily unique to a repo\n            self.allinstances[(str(instancename), str(val[""Base""][""DataUUID""]))] = str(val[""Base""][""TypeName""])\n        \n\n        # datainstances that should be hidden (array of names) \n        try:\n            self.hidden_instances = set(self.nodeconn.get_json(self.MetaLocation, self.RestrictionName))\n        except:\n            self.hidden_instances = set()\n        \n        nodeids = {}\n        # check if locked note\n        dag = self.repoinfo[""DAG""][""Nodes""]\n        for tuuid, nodedata in dag.items():\n            nodeids[str(nodedata[""VersionID""])] = nodedata\n            if tuuid.startswith(uuid):\n                self.uuid = str(tuuid)\n                self.current_node = nodedata\n                self.locked = nodedata[""Locked""]\n           \n        # load all ancestors\n        ancestors = set()\n\n        # commit history uuid, commit note in order from oldest to newest\n        self.loghistory = []\n        currnode = self.current_node\n        while True:\n            ancestors.add(str(currnode[""UUID""]))\n            self.loghistory.append((str(currnode[""UUID""]), currnode[""Note""]))\n            if len(currnode[""Parents""]) > 0:\n                currnode = nodeids[str(currnode[""Parents""][0])] \n            else:\n                break\n        self.loghistory.reverse()\n\n        # load all instances\n        self.activeinstances = {}\n        \n        if not self.locked:\n            tempuuid = self.loghistory[-1][0]\n            self.loghistory[-1] = (tempuuid, ""(open node)"")\n\n        for instancename, val in self.repoinfo[""DataInstances""].items():\n            if str(val[""Base""][""RepoUUID""]) in ancestors:\n                self.activeinstances[str(instancename)] = str(val[""Base""][""TypeName""])\n\n'"
diced/DicedStore.py,0,"b'""""""Functionality to open/close connection to a DVID server.\n\nIn addition to connecting to the DICED store, it also provides\ntop-level exception handling for the package.\n""""""\n\nfrom __future__ import absolute_import\nfrom libdvid import DVIDNodeService, DVIDServerService, ConnectionMethod, DVIDConnection\nfrom libdvid._dvid_python import DVIDException\nimport subprocess\nimport os\nimport tempfile\nimport json\n\nfrom .DicedRepo import DicedRepo\nfrom .DicedException import DicedException\n\n\nclass DicedStore(object):\n    """"""Setup and destroy DVID connection or point to pre-existing DVID server.\n\n    TODO:\n        Support deletion of created repos.  Support custom launch options, such\n        as using groupcache, read-only.\n    """"""\n\n    # constants to configure DVID toml files\n    WEBCLIENT = ""WEBCLIENT"" # local (stored in package)\n    LOGNAME = ""LOGNAME"" # local in application directory\n    DBPATH = ""DBPATH"" # gbucket or local\n    PORT = ""PORT"" \n    RPCPORT = ""RPCPORT""\n    \n    GBUCKET_TOML = \'\'\'\n[server]\nhttpAddress = "":PORT""\nrpcAddress = "":RPCPORT""\nwebClient = ""WEBCLIENT""\ninstance_id_gen = ""sequential""\ninstance_id_start = 100  # new ids start at least from this.\n\nnote = """"""\n{""source"": ""gs://DBPATH""}\n""""""\n\n[logging]\nlogfile = ""LOGNAME""\nmax_log_size = 500 # MB\nmax_log_age = 30   # days\n[store]\n    [store.mutable]\n        engine = ""gbucket""\n        bucket= ""DBPATH""\n    \'\'\'\n\n    LEVELDB_TOML = \'\'\'\n[server]\nhttpAddress = "":PORT""\nrpcAddress = "":RPCPORT""\nwebClient = ""WEBCLIENT""\ninstance_id_gen = ""sequential""\ninstance_id_start = 100  # new ids start at least from this.\n\nnote = """"""\n{""source"": ""DBPATH""}\n""""""\n\n[logging]\nlogfile = ""LOGNAME""\nmax_log_size = 500 # MB\nmax_log_age = 30   # days\n[store]\n    [store.default]\n        engine = ""basholeveldb""\n        path = ""DBPATH""\n    \'\'\'\n\n    def __init__(self, location, port=8000, rpcport=8001, permissionfile=None, appdir=None):\n        """"""Init.\n\n        The user can start the DVIDStore in three different ways.\n        To store data in Google Storage, DVIDStore location should be\n        formatted as \'gs://<bucketname>, where the bucket should already\n        exist.  This will automatically launch a server on the specified\n        local port that will communicate with this storage.  A local\n        path can also be specified, instead of a google bucket if very\n        large-scale storage in unnecessary.  If the user wants to point\n        to a pre-existing DVID server that could have any backend\n        storage, the location should be formatted as ""dvid://<servername>"".\n\n        Note:\n            If permissions are needed to access the google bucket, a\n            configuration JSON should be pointed to by GOOGLE_APPLICATION_CREDENTIALS\n            environment variable or should be passed to this function.\n\n            \'dvid\' needs to be in the executable path.  This will be setup\n            by default if using a conda installation.\n\n            Default DVID ports or specified ports must be available to the program.\n\n        Args:\n            location (str): location of DVID server or DB\n            port (integer): port that DVID will take http requests\n            port (integer): port that DVID will take rpc requests\n            permissionfile (str): permission json file location for gbucket\n            appdir (str): directory that contains diced logs and other data\n        \n        Exceptons:\n            Will raise DicedException if DVID server cannot be created or\n            if provide address cannot be found.\n        """"""\n    \n        self._dvidproc = None\n        self._server = None\n        self.rpcport = rpcport\n        self.port = port\n\n        # if gs or local launch DVID\n        gbucket = location.startswith(""gs://"")\n        fileloc = not location.startswith(""dvid://"") and not gbucket\n        if gbucket or fileloc:\n            # appdir is \'~/.dicedstore\' by default\n            if appdir is None:\n                appdir = \'~/.dicedstore\'\n            appdir = os.path.expanduser(appdir)\n            if not os.path.exists(appdir):\n                os.makedirs(appdir)\n            if not os.path.exists(appdir + ""/dvid""):\n                os.makedirs(appdir + ""/dvid"")\n\n            self._server = ""127.0.0.1:"" + str(port)\n            \n            # find pre-built console in resources\n            import pkg_resources\n            consolepath = pkg_resources.resource_filename(\'diced\', \'dvid-console\')\n\n            # create dvidlog \n            logfile = tempfile.NamedTemporaryFile(dir=(appdir + ""/dvid""),\n                    suffix=\'.log\', delete=False)\n            logname = logfile.name\n\n            tomldata = None\n            if gbucket:\n                tomldata = self.GBUCKET_TOML\n                tomldata = tomldata.replace(self.DBPATH, location.split(""gs://"")[1])\n            else:\n                tomldata = self.LEVELDB_TOML\n                tomldata = tomldata.replace(self.DBPATH, location)\n\n            tomldata = tomldata.replace(self.WEBCLIENT, consolepath + ""/lite-dist/"")\n            tomldata = tomldata.replace(self.LOGNAME, logname)\n            tomldata = tomldata.replace(self.RPCPORT, str(rpcport))\n            tomldata = tomldata.replace(self.PORT, str(port))\n\n            # write toml to temporary file\n            tomlfile = tempfile.NamedTemporaryFile(dir=appdir + ""/dvid"",\n                    suffix=\'.toml\', delete=False)\n            tomllocation = tomlfile.name\n            tomlfile.write(tomldata.encode(\'utf-8\'))\n            tomlfile.close()\n\n            # copy environment and set new variable if permissionfile\n            local_env = os.environ.copy()\n            if permissionfile is not None:\n                local_env[""GOOGLE_APPLICATION_CREDENTIALS""] = permissionfile \n                \n            # check dvid does not already exist\n            dvidexists = False \n            try:\n                DVIDServerService(self._server)\n                dvidexists = True\n            except:\n                pass\n            if dvidexists:\n                raise DicedException(""DVID already exists"")\n\n            with open(os.devnull, \'w\') as devnull:\n                self._dvidproc = subprocess.Popen([\'dvid\', \'serve\', tomllocation],\n                    env=local_env, stdout=devnull) \n        else:\n            self._server = location.split(""dvid://"")[1] + "":"" + str(port)\n            \n\n        # allow a few seconds for DVID to launch\n        if self._dvidproc is not None:\n            import time\n            #print ""Establishing connection...""\n\n            # poll server every second\n            while True:\n                try:\n                    retval = self._dvidproc.poll()\n                    # early termination (checking DVID later will fail)\n                    if retval is not None:\n                        self._dvidproc = None\n                        break\n\n                    DVIDServerService(self._server)\n                    break\n                except:\n                    time.sleep(1) # wait for connection\n                \n\n        # check that dvid server is accepting connections\n        try:\n            DVIDServerService(self._server)\n        except DVIDException as err:\n            raise DicedException(""DVID connection failed"")\n\n\n    def __del__(self):\n        """"""Shuts down DVID server if user created it.\n\n        This class does not contain references to other objects, so\n        this should be safe.  We opted for using __del__ to release\n        the database resource; a context manager would be too restrictive.\n        Using weak refs is another option.\n        """"""\n\n        if self._dvidproc is not None:\n            self._dvidproc.terminate()\n\n\n    def _shutdown_store(self):\n        """"""Stops the connection to DVID thereby freeing port.\n\n        This does not need to be called by user in general\n        as the garbage collector will automatically free\n        up the resource when no longer in use.\n        """"""\n        \n        if self._dvidproc is not None:\n            import time\n            self._dvidproc.terminate()\n            while True:\n                retval = self._dvidproc.poll()\n                if retval is not None:\n                    self._dvidproc = None\n                    break\n                time.sleep(1)\n\n    def create_repo(self, name, description=""""):\n        """"""Create repo.\n\n        Note:\n            DVID does not require unique names but unique names\n            will be enforced through this interface.  This will\n            simplify access for most common use cases.  In general,\n            users should use the web console and specific version\n            ids to ensure access to the desired data.\n\n        Args:\n            name (str): name of DVID respository (must be unique)\n            description (str): description of repository\n        """"""\n        try:\n            curr_repos = self.list_repos()\n            for (reponame, uuid) in curr_repos:\n                if reponame == name:\n                    raise DicedException(""Repo name already exists"")\n            service = DVIDServerService(self._server)\n            uuid = service.create_new_repo(name, description)\n        except DVIDException as err:\n            raise DicedException(""Failed to create repo"")\n\n    def delete_repo(self, name):\n        """"""Delete entire repo -- this cannot be undone!\n\n        Note:\n            For large repos this could be very time-consuming.\n            While this is non-blocking, currently, DVID\n            will not resume the deletion on restart, so it is\n            possible for data to still be stored even if it\n            is superficially removed.  For now, the user should\n            ensure DicedStore is open for a some time after\n            issue the command.\n\n        TODO:\n            Implement a restartable background delete.\n\n        """"""\n\n        uuid = self.get_repouuid(name)\n\n        addr = self._server.split(\':\')[0]\n        rpcaddress = addr + "":"" + str(self.rpcport)\n\n        deletecall = subprocess.Popen([\'dvid\', \'-rpc=\'+rpcaddress, \n            \'repos\', \'delete\', uuid], stdout=None)\n        deletecall.communicate()\n\n    def list_repos(self):\n        """"""List all repositories in the store.\n\n        Returns:\n            A list of (name, uuid) tuples\n        """"""\n        \n        data = None \n        try:\n            conn = DVIDConnection(self._server) \n            code, data, errmsg = conn.make_request(""/repos/info"", ConnectionMethod.GET)\n        except DVIDException as err:\n            raise DicedException(""Failed to access /repos/info on DVID"")\n      \n        jdata = json.loads(data) \n        res = []\n        for _key, val in jdata.items():\n            res.append((str(val[""Alias""]), str(val[""Root""])))\n\n        return res\n\n    def get_repouuid(self, name):\n        """"""Return a repo UUID given the name.\n\n        The root node is taken by default.\n\n        Returns:\n            A string representing the UUID.\n\n        Raises:\n            Raised DicedException if repo does not exist.\n        """"""\n        repos = self.list_repos()\n        for (tname, repoid) in repos:\n            if tname == name:\n                return repoid\n        raise DicedException(""repo name does not exist"")\n\n    def open_repo(self, name=None, uuid=None, readonly=False):\n        """"""Open repository of the specified name (or by unique identifier).\n\n        If only the name is specified, the root node is taken by default.\n\n        Args:\n            name (str): name of repository to open\n            uuid (str): unique identifier for repository\n        \n        Returns:\n            A repository object if it exists.\n\n        Exception:\n            Raises a DicedException if repo does not exist.\n        """"""\n\n        if uuid is not None:\n            try:\n                ns = DVIDNodeService(self._server, uuid)\n                return DicedRepo(self._server, uuid, self, readonly)\n            except DVIDException:\n                # repo does not exist\n                raise DicedException(""uuid does not exist"")\n        elif name is not None:\n            repoid = self.get_repouuid(name)\n            return DicedRepo(self._server, repoid, self, readonly)\n\n'"
diced/__init__.py,0,b'from diced.DicedStore import DicedStore\nfrom diced.DicedException import DicedException\nfrom diced.DicedArray import ArrayDtype\n'
diced/tests/__init__.py,0,b''
diced/tests/test_DicedArray.py,0,"b'import unittest\nimport tempfile\nimport shutil\nimport numpy\n\nfrom diced import DicedStore\nfrom diced import DicedException\nfrom diced import ArrayDtype\n\nclass TestDicedArray(unittest.TestCase):\n    def test_newdvidinstances(self):\n        """"""Tests 16,32,64 raw data.\n        """"""\n               \n        # create store object and repo\n        dbdir = tempfile.mkdtemp()\n        store = DicedStore(dbdir)\n        \n        try:\n            # my initial repo\n            store.create_repo(""myrepo"")\n            myrepo = store.open_repo(""myrepo"")\n    \n            # test generic 16 bit\n            arr = myrepo.create_array(""myarray16"", ArrayDtype.uint16)\n            self.assertEqual(arr.get_numdims(), 3)\n            extents = arr.get_extents()\n            self.assertEqual(extents, (slice(0,0),slice(0,0),slice(0,0)))\n    \n            # set and get data\n            data = numpy.zeros((400,200,100), numpy.uint16)\n            data[:] = 5\n            arr[1:401,2:202,3:103] = data\n            matchdata = arr[1:401,2:202,3:103]\n            matches = numpy.array_equal(data, matchdata)\n            self.assertTrue(matches)\n    \n            # test generic 32 bit\n            arr = myrepo.create_array(""myarray32"", ArrayDtype.uint32)\n            self.assertEqual(arr.get_numdims(), 3)\n            extents = arr.get_extents()\n            self.assertEqual(extents, (slice(0,0),slice(0,0),slice(0,0)))\n    \n            # set and get data\n            data = numpy.zeros((400,200,100), numpy.uint32)\n            data[:] = 5\n            arr[1:401,2:202,3:103] = data\n            matchdata = arr[1:401,2:202,3:103]\n            matches = numpy.array_equal(data, matchdata)\n            self.assertTrue(matches)\n    \n            # test generic 64 bit array type\n            arr = myrepo.create_array(""myarray64"", ArrayDtype.uint64)\n            self.assertEqual(arr.get_numdims(), 3)\n            extents = arr.get_extents()\n            self.assertEqual(extents, (slice(0,0),slice(0,0),slice(0,0)))\n    \n            # set and get data\n            data = numpy.zeros((400,200,100), numpy.uint64)\n            data[:] = 5\n            arr[1:401,2:202,3:103] = data\n            matchdata = arr[1:401,2:202,3:103]\n            matches = numpy.array_equal(data, matchdata)\n            self.assertTrue(matches)\n        \n        finally:\n            store._shutdown_store()\n            shutil.rmtree(dbdir)\n\n    def test_arraysmall(self):\n        """"""Tests small get/puts.\n\n        This test creates 3D array and tests get/set.\n        """"""\n        # create store object and repo\n        dbdir = tempfile.mkdtemp()\n        store = DicedStore(dbdir)\n\n        try:\n            # my initial repo\n            store.create_repo(""myrepo"")\n            myrepo = store.open_repo(""myrepo"")\n    \n            # test 3D label array type\n            arr = myrepo.create_array(""myarray"", ArrayDtype.uint64, islabel3D=True)\n            self.assertEqual(arr.get_numdims(), 3)\n            extents = arr.get_extents()\n            self.assertEqual(extents, (slice(0,0),slice(0,0),slice(0,0)))\n    \n            # set and get data\n            data = numpy.zeros((400,200,100), numpy.uint64)\n            data[:] = 5\n            arr[1:401,2:202,3:103] = data\n            matchdata = arr[1:401,2:202,3:103]\n            matches = numpy.array_equal(data, matchdata)\n            self.assertTrue(matches)\n    \n            extents = arr.get_extents()\n            self.assertEqual(extents, (slice(0,448),slice(0,256),slice(0,128)))\n    \n            # check negative coordinates\n            arr[-3,-1,4] = numpy.array([[[121]]])\n            val = arr[-3,-1,4] \n            self.assertEqual(121, val)\n    \n            extents = arr.get_extents()\n            self.assertEqual(extents, (slice(-64,448),slice(-64,256),slice(0,128)))\n    \n            # check array access\n            arr[-3,-1,3:5] = numpy.array([[[121,122]]], numpy.uint64)\n            val = arr[-3,-1,3:5] \n            matches = numpy.array_equal(numpy.array([121,122], numpy.uint64), val)\n            self.assertTrue(matches)\n    \n            # check error cases\n            try:\n                _ = arr[0,5]\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n\n        finally:\n            store._shutdown_store()\n            shutil.rmtree(dbdir)\n\n    def test_array1d2d(self):\n        """"""Tests small get/puts on 1D/2D arrays.\n\n        This test creates 1D/2D array and tests get/set.\n        """"""\n\n        # create store object and repo\n        dbdir = tempfile.mkdtemp()\n        store = DicedStore(dbdir)\n\n        try:\n            # my initial repo\n            store.create_repo(""myrepo"")\n            myrepo = store.open_repo(""myrepo"")\n    \n            # test generic 2D raw array type\n            arr = myrepo.create_array(""myarray2d"", ArrayDtype.uint8, dims=2)\n            self.assertEqual(arr.get_numdims(), 2)\n            extents = arr.get_extents()\n            self.assertEqual(extents, (slice(0,0),slice(0,0)))\n    \n            # set and get data\n            data = numpy.zeros((200,100), numpy.uint8)\n            data[:] = 5\n            arr[2:202,3:103] = data\n            matchdata = arr[2:202,3:103]\n            matches = numpy.array_equal(data, matchdata)\n            self.assertTrue(matches)\n    \n            extents = arr.get_extents()\n            self.assertEqual(extents, (slice(0,512),slice(0,512)))\n    \n            # check error cases\n            try:\n                _ = arr[0]\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n    \n            # test generic 1D raw array type\n            arr = myrepo.create_array(""myarray1d"", ArrayDtype.uint8, dims=1)\n            self.assertEqual(arr.get_numdims(), 1)\n            extents = arr.get_extents()\n            self.assertEqual(extents, slice(0,0))\n    \n            # set and get data\n            data = numpy.zeros((100), numpy.uint8)\n            data[:] = 5\n            arr[3:103] = data\n            matchdata = arr[3:103]\n            matches = numpy.array_equal(data, matchdata)\n            self.assertTrue(matches)\n    \n            extents = arr.get_extents()\n            self.assertEqual(extents, slice(0,262144))\n    \n            # check error cases\n            try:\n                _ = arr[0:3, 0:3]\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n\n        finally:\n            store._shutdown_store()\n            shutil.rmtree(dbdir)\n\n\n    def test_arraylarge(self):\n        """"""Tests large get/puts.\n\n        This test creates large 3D array and tests get/set.\n        """"""\n        \n        # create store object and repo\n        dbdir = tempfile.mkdtemp()\n        store = DicedStore(dbdir)\n\n        try:\n            # my initial repo\n            store.create_repo(""myrepo"")\n            myrepo = store.open_repo(""myrepo"")\n    \n            # test generic 3D raw array type\n            arr = myrepo.create_array(""myarray"", ArrayDtype.uint8)\n    \n            # ?! test negative coord\n    \n            _b = ArrayDtype.uint8\n    \n            # set and get data\n            #data = numpy.random.randint(1031, size=(1400,1200,1000)).astype(numpy.uint8)\n            data = numpy.zeros((1400,1200,1000), numpy.uint8)\n            data[:] = 3\n    \n            arr[1:1401,2:1202,3:1003] = data\n            \n            matchdata = arr[1:1401,2:1202,3:1003]\n            matches = numpy.array_equal(data, matchdata)\n            self.assertTrue(matches)\n            \n            matchzero = arr[1401,1202,1003]\n            self.assertEqual(0, matchzero)\n    \n            extents = arr.get_extents()\n            self.assertEqual(extents, (slice(0,1408),slice(0,1216),slice(0,1024)))\n\n        finally:\n            store._shutdown_store()\n            shutil.rmtree(dbdir)\n\nif __name__ == ""main"":\n    unittest.main()\n'"
diced/tests/test_DicedRepo.py,0,"b'import unittest\nimport tempfile\nimport shutil\nimport json\n\nfrom diced import DicedStore\nfrom diced import DicedException\nfrom diced import ArrayDtype\nfrom libdvid import DVIDNodeService\n\nclass TestDicedRepo(unittest.TestCase):\n    def test_repoversion(self):\n        """"""Check versioning in repos.\n\n        This test creates a repo and creates different versions.\n        """"""\n        # create store object and repo\n        dbdir = tempfile.mkdtemp()\n        store = DicedStore(dbdir)\n        try:\n            # my initial repo\n            store.create_repo(""myrepo"")\n            myrepo = store.open_repo(""myrepo"")\n    \n            # check current version\n            uuid = myrepo.get_current_version()\n            uuid2 = store.list_repos()[0][1]\n            self.assertEqual(uuid, uuid2)\n    \n            # check lock status\n            self.assertFalse(myrepo.locked)\n    \n            # check branch on open node is illegal\n            try:\n                myrepo.create_branch(""start"")\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n    \n            # lock node\n            myrepo.lock_node(""now done"")\n            self.assertTrue(myrepo.locked)\n    \n            # create new branch\n            uuidnew = myrepo.create_branch(""start"")\n            self.assertNotEqual(uuid, uuidnew) \n    \n            # open repo with uuid\n            myrepov2= store.open_repo(uuid=uuidnew)\n            self.assertEqual(myrepov2.get_current_version(), uuidnew)\n    \n            # check log history\n            logs = myrepov2.get_commit_log()\n            self.assertEqual(logs[0][0], uuid) \n            self.assertEqual(logs[0][1], ""now done"") \n            self.assertEqual(logs[1][0], uuidnew) \n            self.assertEqual(logs[1][1], ""(open node)"")\n    \n            # change version\n            myrepo.change_version(uuidnew)\n            self.assertFalse(myrepo.locked)\n            self.assertEqual(myrepo.uuid, uuidnew)\n        \n        finally:\n            store._shutdown_store()\n            shutil.rmtree(dbdir)\n\n    def test_files(self):\n        """"""Test file interface in DicedRepo.\n\n        This test adds files, retrieves files, and delete files\n        from the version repo.\n        """"""\n        # create store object and repo\n        dbdir = tempfile.mkdtemp()\n        store = DicedStore(dbdir)\n        try:\n            # my initial repo\n            store.create_repo(""myrepo"")\n            myrepo = store.open_repo(""myrepo"")\n    \n            # create file\n            myrepo.upload_filedata(""hello.txt"", ""world text"")\n            res = myrepo.download_filedata(""hello.txt"")\n            self.assertEqual(res, b""world text"")\n            \n            # overwrite\n            myrepo.upload_filedata(""hello.txt"", ""world text2"")\n            res = myrepo.download_filedata(""hello.txt"")\n            self.assertEqual(res, b""world text2"")\n    \n            # new file\n            myrepo.upload_filedata(""world.txt"", ""foobar"")\n    \n            # test file list\n            allfiles = myrepo.list_files() \n            self.assertEqual(len(allfiles), 2)\n            self.assertTrue(""hello.txt"" in allfiles)\n            self.assertTrue(""world.txt"" in allfiles)\n    \n            # test error handling\n            try:\n                res = myrepo.download_filedata(""hello2.txt"")\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n    \n            rootuuid = myrepo.get_current_version()\n    \n            myrepo.lock_node(""lock"")\n    \n            # check lock error message\n            try:\n                myrepo.upload_filedata(""world.txt"", ""foobar"")\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n    \n            # create new branch and overwrite file data\n            newuuid = myrepo.create_branch(""new branch"")\n            myrepo.change_version(newuuid)\n    \n            # modify data in child node\n            myrepo.upload_filedata(""world.txt"", ""newdata"")\n            res = myrepo.download_filedata(""world.txt"")\n            self.assertEqual(res, b""newdata"")\n          \n            myrepo.delete_file(""hello.txt"")\n            allfiles = myrepo.list_files() \n            self.assertEqual(len(allfiles), 1)\n            self.assertTrue(""world.txt"" in allfiles)\n    \n            # text not overwritten in root\n            myrepo.change_version(rootuuid)\n            res = myrepo.download_filedata(""world.txt"")\n            self.assertEqual(res, b""foobar"")\n    \n            # file shouldn\'t be deleted in root\n            allfiles = myrepo.list_files() \n            self.assertEqual(len(allfiles), 2)\n\n        finally:\n            store._shutdown_store()\n\n    def test_array(self): \n        """"""Test array creation/loading interface.\n\n        Tries creating different types of arrays,\n        checks proper deletion, and checks error\n        handling.\n        """"""\n\n        # create store object and repo\n        dbdir = tempfile.mkdtemp()\n        store = DicedStore(dbdir)\n        try:\n        \n            # my initial repo\n            store.create_repo(""myrepo"")\n            myrepo = store.open_repo(""myrepo"")\n    \n            # test generic 3D raw array type\n            arr = myrepo.create_array(""myarray"", ArrayDtype.uint8)\n            self.assertEqual(arr.numdims, 3)\n            self.assertFalse(arr.islabel3D)\n            self.assertFalse(arr.locked)\n    \n            arr = myrepo.get_array(""myarray"")\n            self.assertEqual(arr.numdims, 3)\n            self.assertFalse(arr.islabel3D)\n            self.assertFalse(arr.locked)\n    \n    \n            # test 2D raw array type\n            arr = myrepo.create_array(""myarray2d"", ArrayDtype.uint8, dims=2)\n            self.assertEqual(arr.numdims, 2)\n            self.assertFalse(arr.islabel3D)\n            self.assertFalse(arr.locked)\n    \n            arr = myrepo.get_array(""myarray2d"")\n            self.assertEqual(arr.numdims, 2)\n            self.assertFalse(arr.islabel3D)\n            self.assertFalse(arr.locked)\n            \n    \n            # check 3D labels\n            arr = myrepo.create_array(""mylabelarray"", ArrayDtype.uint64, islabel3D=True)\n            self.assertEqual(arr.numdims, 3)\n            self.assertTrue(arr.islabel3D)\n            self.assertFalse(arr.locked)\n            \n            arr = myrepo.get_array(""myarray2d"")\n            self.assertEqual(arr.numdims, 2)\n            \n    \n            # query instances\n            instances = myrepo.list_instances()\n            self.assertEqual(len(instances), 3)\n            \n            allinstances = myrepo.list_instances(showhidden=True)\n            self.assertEqual(len(allinstances), 5)\n    \n    \n            # test delete\n            myrepo.delete_array(""myarray2d"")\n            instances = myrepo.list_instances()\n            self.assertEqual(len(instances), 2)\n    \n            # reinsert and change meta and lossy\n            arr = myrepo.create_array(""myarray2d"", ArrayDtype.uint8, dims=3, lossycompression=True)\n            self.assertEqual(arr.numdims, 3)\n            self.assertFalse(arr.islabel3D)\n            self.assertFalse(arr.locked)\n    \n            # test hidden files set in meta\n            ns = DVIDNodeService(""127.0.0.1:8000"", myrepo.get_current_version())\n            ns.create_keyvalue(""blahblah"")\n           \n            # reload myrepo\n            myrepo.change_version(myrepo.get_current_version())\n            allinstances = myrepo.list_instances(showhidden=True)\n            self.assertEqual(len(allinstances), 6)\n            self.assertTrue((""blahblah"", ""keyvalue"") in allinstances) \n    \n             \n            # test hidden exclusion add\n            ns.put("".meta"", ""restrictions"", json.dumps([""myarray2d""]).encode(\'utf-8\'))\n            myrepo.change_version(myrepo.get_current_version())\n            allinstances = myrepo.list_instances()\n            self.assertEqual(len(allinstances), 2)\n        \n    \n            # test array errors\n            try:\n                arr = myrepo.create_array(""myarray"", ArrayDtype.uint8)\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n    \n            try:\n                arr = myrepo.create_array(""myarray"", ArrayDtype.uint16, islabel3D=True)\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n    \n            try:\n                arr = myrepo.get_array(""myarray3"")\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n    \n            # try to create array on locked node\n            myrepo.lock_node(""blah"")\n            try:\n                arr = myrepo.create_array(""myarray4"", ArrayDtype.uint16)\n            except DicedException:\n                pass\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n    \n            # check lock status\n            arr = myrepo.get_array(""myarray2d"")\n            self.assertEqual(arr.numdims, 3)\n            self.assertFalse(arr.islabel3D)\n            self.assertTrue(arr.locked)\n\n        finally:\n            store._shutdown_store()\n\n\nif __name__ == ""main"":\n    unittest.main()\n'"
diced/tests/test_DicedStore.py,0,"b'import unittest\nimport tempfile\nimport shutil\n\nfrom diced import DicedStore\nfrom diced import DicedException\n\nclass TestDicedStore(unittest.TestCase):\n    def test_initserver(self):\n        """"""Check running of default dvid server and potential errors.\n        """"""\n\n        defstore2 = None\n        dbdir = tempfile.mkdtemp()\n        dbdir2 = tempfile.mkdtemp()\n\n        defstore = DicedStore(dbdir)\n        try:\n\n            # dvid address\n            self.assertEqual(defstore._server, ""127.0.0.1:8000"")\n    \n            # try running DVID on same address\n            try:\n                defstore = DicedStore(dbdir)\n            except DicedException:\n                pass # Good, should not be able to create duplicate store\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n           \n            # use previous address\n            reusestore = DicedStore(""dvid://127.0.0.1"", port=8000, \n                    rpcport=8001)\n            self.assertEqual(reusestore._server, ""127.0.0.1:8000"")\n    \n            # run a second dvid server\n            defstore2 = DicedStore(dbdir2, port=9000, rpcport=9001)\n    \n            # dvid address\n            self.assertEqual(defstore2._server, ""127.0.0.1:9000"")      \n        \n        finally:\n            # shutdown DVID \n            defstore._shutdown_store()\n            if defstore2:\n                defstore2._shutdown_store()\n        \n            # cleanup dirs\n            shutil.rmtree(dbdir)\n            shutil.rmtree(dbdir2)\n\n    def test_repos(self):\n        """"""Test the creation, deletion, and querying of repos.\n        """"""\n        dbdir = tempfile.mkdtemp()\n        store = DicedStore(dbdir, port=10000, rpcport=10001)\n\n        try:\n            store.create_repo(""myrepo"")\n            store.create_repo(""myrepo1"")\n    \n            # make sure duplicate repos cannot be added\n            try:\n                store.create_repo(""myrepo1"")\n            except DicedException:\n                pass # Good, should not be able to create duplicate repo\n            else:\n                assert False, ""Expected an exception above, but it wasn\'t raised!""\n    \n            # grab repo names\n            reponames = store.list_repos()\n            self.assertEqual(len(reponames), 2)\n            nameonly = []\n            for (name, uuid) in reponames:\n                nameonly.append(name)\n            self.assertTrue(""myrepo"" in nameonly)\n            self.assertTrue(""myrepo1"" in nameonly)\n            \n            # delete repo and check repo list\n            store.delete_repo(""myrepo"")\n            reponames = store.list_repos()\n            self.assertEqual(len(reponames), 1)\n            nameonly = []\n            for (name, uuid) in reponames:\n                nameonly.append(name)\n            self.assertFalse(""myrepo"" in nameonly)\n            self.assertTrue(""myrepo1"" in nameonly)\n    \n            #  test get uuid interface\n            uuid = store.get_repouuid(""myrepo1"")\n            self.assertEqual(uuid, reponames[0][1])\n    \n            # retrieve DicedRepo object\n            repo = store.open_repo(""myrepo1"") \n\n        finally:\n            store._shutdown_store()\n            shutil.rmtree(dbdir)\n\nif __name__ == ""main"":\n    unittest.main()\n'"
