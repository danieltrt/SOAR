file_path,api_count,code
FaceDetection/EFace.py,0,"b'""""""\nProgrammer  :   EOF\nFile        :   EFace.py\nDate        :   2015.12.29\nE-mail      :   jasonleaster@163.com\n\n""""""\n\nfrom config import TEST_IMG\nfrom matplotlib import image\nfrom matplotlib import pyplot\nimport pylab\nfrom time import time\nfrom detector import Detector\n\nstart_time = time()\n\nimg = image.imread(TEST_IMG)\n\nif len(img.shape) == 3:\n    imgSingleChannel = img[:,:, 1]\nelse:\n    imgSingleChannel = img\n\ndet = Detector()\n\nrectangles = det.scanImgOverScale(imgSingleChannel)\n\nend_time = time()\n\nprint ""Number of rectangles: "", len(rectangles)\nprint ""Cost time: "", end_time - start_time\n\ndet.showResult(img, rectangles)\n'"
FaceDetection/adaboost.py,0,"b'""""""\nProgrammer  :   EOF\nE-mail      :   jasonleaster@163.com\nCooperator  :   Wei Chen.\nDate        :   2015.11.22\nFile        :   adaboost.py\nLicense     :   MIT License\n\nFile Description:\n    AdaBoost is a machine learning meta-algorithm.\nThat is the short for ""Adaptive Boosting"".\n\nThanks Wei Chen. Without him, I can\'t understand AdaBoost in this short time.\nWe help each other and learn this algorithm.\n\n""""""\n\nfrom config import DEBUG_MODEL\nfrom config import USING_CASCADE\n\nfrom config import LABEL_POSITIVE\nfrom config import LABEL_NEGATIVE\n\nfrom config import EXPECTED_TPR\nfrom config import EXPECTED_FPR\n\nfrom config import ROC_FILE\n\nfrom weakClassifier import WeakClassifier\nfrom matplotlib     import pyplot\nfrom haarFeature    import Feature\n\nimport numpy\nimport time\nimport pylab\n\n\ndef getCachedAdaBoost(mat = None, label = None, filename = """", limit = 0):\n    """"""\n        Construct a AdaBoost object with cached data\n        from file @ADABOOST_FILE """"""\n\n    fileObj = open(filename, ""a+"")\n\n    print ""Constructing AdaBoost from existed model data""\n\n    tmp = fileObj.readlines()\n\n    if len(tmp) == 0:\n        raise ValueError(""There is no cached AdaBoost model"")\n\n    weakerNum = len(tmp) / 4\n    model     = AdaBoost(train = False, limit = weakerNum)\n\n    if limit < weakerNum:\n        model.weakerLimit = limit\n    else:\n        model.weakerLimit = weakerNum\n\n    for i in xrange(0, len(tmp), 4):\n\n        alpha, dimension, direction, threshold = None, None, None, None\n\n        for j in xrange(i, i + 4):\n            if   (j % 4) == 0:\n                alpha     = float(tmp[j])\n            elif (j % 4) == 1:\n                dimension = int(tmp[j])\n            elif (j % 4) == 2:\n                direction = float(tmp[j])\n            elif (j % 4) == 3:\n                threshold = float(tmp[j])\n\n        classifier = model.Weaker(train = False)\n        classifier.constructor(dimension, direction, threshold)\n        classifier._mat = mat\n        classifier._label = label\n\n        if mat is not None:\n            classifier.sampleNum = mat.shape[1]\n\n        model.G[i/4]     = classifier\n        model.alpha[i/4] = alpha\n        model.N         += 1\n\n    model._mat = mat\n    model._label = label\n    if model.N > limit:\n        model.N    = limit\n\n    if label is not None:\n        model.samplesNum = len(label)\n\n    print ""Construction finished""\n    fileObj.close()\n\n    return model\n\n\nclass AdaBoost:\n    """"""\n        Parameter:\n        @Mat    :   A matrix(or two dimension array) which\'s size is\n                    (row    = number of features,\n                    column  = number of total sample)\n        @Tag    :   A vector(or one dimension array) which\'s size is the\n                    same as the number of total sample\n        @classifier: Object. A instance of weaker classifier.\n\n        @train  :   A bool value. If it\'s False, it means that user want to\n                    get a instance of this class object from cached data\n        @limit  :   A integer. The limitation of training times.""""""\n\n\n    def __init__(self, Mat = None, Tag = None, classifier = WeakClassifier, train = True, limit = 4):\n        if train == True:\n            self._mat   = Mat\n            self._label = Tag\n\n            self.samplesDim, self.samplesNum = self._mat.shape\n\n            # Make sure that the inputted data\'s dimension is right.\n            assert self.samplesNum == self._label.size\n\n            self.posNum = numpy.count_nonzero(self._label == LABEL_POSITIVE)\n            self.negNum = numpy.count_nonzero(self._label == LABEL_NEGATIVE)\n\n            # Initialization of weight\n            pos_W = [1.0/(2 * self.posNum) for i in range(self.posNum)]\n\n            neg_W = [1.0/(2 * self.negNum) for i in range(self.negNum)]\n            self.W = numpy.array(pos_W + neg_W)\n\n            self.accuracy = []\n\n        self.Weaker = classifier\n\n        self.weakerLimit = limit\n\n        self.G      = [None for _ in xrange(limit)]\n        self.alpha  = [  0  for _ in xrange(limit)]\n        self.N      = 0\n        self.detectionRate = 0.\n\n        # true positive rate\n        self.tpr = 0.\n        # false positive rate\n        self.fpr = 0.\n\n        self.th  = 0.\n\n\n    def is_good_enough(self):\n\n        output = self.prediction(self._mat, self.th)\n\n        correct = numpy.count_nonzero(output == self._label)/(self.samplesNum*1.)\n        self.accuracy.append( correct)\n\n        self.detectionRate = numpy.count_nonzero(output[0:self.posNum] == LABEL_POSITIVE) * 1./ self.posNum\n\n        Num_tp = 0 # Number of true positive\n        Num_fn = 0 # Number of false negative\n        Num_tn = 0 # Number of true negative\n        Num_fp = 0 # Number of false positive\n        for i in xrange(self.samplesNum):\n            if self._label[i] == LABEL_POSITIVE:\n                if output[i] == LABEL_POSITIVE:\n                    Num_tp += 1\n                else:\n                    Num_fn += 1\n            else:\n                if output[i] == LABEL_POSITIVE:\n                    Num_fp += 1\n                else:\n                    Num_tn += 1\n\n        self.tpr = Num_tp * 1./(Num_tp + Num_fn)\n        self.fpr = Num_fp * 1./(Num_tn + Num_fp)\n\n        if self.tpr > EXPECTED_TPR and self.fpr < EXPECTED_FPR:\n            return True\n\n    def train(self):\n        """"""\n        function @train() is the main process which run\n        AdaBoost algorithm.""""""\n\n        adaboost_start_time = time.time()\n\n        for m in xrange(self.weakerLimit):\n            self.N += 1\n\n            if DEBUG_MODEL == True:\n                weaker_start_time = time.time()\n\n            self.G[m] = self.Weaker(self._mat, self._label, self.W)\n            \n            errorRate = self.G[m].train()\n\n            if DEBUG_MODEL == True:\n                print ""Time for training WeakClassifier:"", \\\n                        time.time() - weaker_start_time\n\n            if errorRate < 0.0001:\n                errorRate = 0.0001\n\n            beta = errorRate / (1 - errorRate)\n            self.alpha[m] = numpy.log(1/beta)\n\n            output = self.G[m].prediction(self._mat)\n\n            for i in xrange(self.samplesNum):\n                #self.W[i] *= numpy.exp(-self.alpha[m] * self._label[i] * output[i])\n                if self._label[i] == output[i]:\n                    self.W[i] *=  beta\n\n            self.W /= sum(self.W)\n\n            if USING_CASCADE is True:\n                self.th, self.detectionRate = self.findThreshold(EXPECTED_TPR)\n\n            if self.is_good_enough():\n                print (self.N) ,"" weak classifier is enough to "",\n                print ""meet the request which given by user.""\n                print ""Training Done :)""\n                break\n\n            if DEBUG_MODEL is True:\n                print ""weakClassifier:"", self.N\n                print ""errorRate     :"", errorRate\n                print ""accuracy      :"", self.accuracy[-1]\n                print ""detectionRate :"", self.detectionRate\n                print ""AdaBoost\'s Th :"", self.th\n                print ""alpha         :"", self.alpha[m]\n\n        #self.showErrRates()\n        #self.showROC()\n\n        print ""The time cost of training this AdaBoost model:"",\\\n                time.time() - adaboost_start_time\n\n        output = self.prediction(self._mat, self.th)\n        return output, self.fpr\n\n\n    def grade(self, Mat):\n\n        #Mat = numpy.array(Mat)\n\n        sampleNum = Mat.shape[1]\n\n        output = numpy.zeros(sampleNum, dtype = numpy.float16)\n\n        for i in xrange(self.N):\n            output += self.G[i].prediction(Mat) * self.alpha[i]\n\n        return output\n\n\n    def prediction(self, Mat, th = None):\n\n        #Mat = numpy.array(Mat)\n\n        output = self.grade(Mat)\n            \n        if th == None:\n            th = self.th\n\n        """"""\n        # Don\'t do this! Bug!! the first statement will rewrite the output\n        output[output > th]  = LABEL_POSITIVE\n        output[output <= th] = LABEL_NEGATIVE\n        """"""\n\n        for i in range(len(output)):\n            if output[i] > th:\n                output[i] = LABEL_POSITIVE\n            else:\n                output[i] = LABEL_NEGATIVE\n\n        return output\n\n\n    def findThreshold(self, expected_tpr):\n        detectionRate = 0.\n        best_th       = None\n\n        low_bound = -sum(self.alpha)\n        up__bound = +sum(self.alpha)\n        step      = -0.1\n        threshold = numpy.arange(up__bound - step, low_bound + step, step)\n\n        for t in xrange(threshold.size):\n\n            output = self.prediction(self._mat, threshold[t])\n\n            Num_tp = 0 # Number of true positive\n            Num_fn = 0 # Number of false negative\n            Num_tn = 0 # Number of true negative\n            Num_fp = 0 # Number of false positive\n            for i in range(self.samplesNum):\n                if self._label[i] == LABEL_POSITIVE:\n                    if output[i] == LABEL_POSITIVE:\n                        Num_tp += 1\n                    else:\n                        Num_fn += 1\n                else:\n                    if output[i] == LABEL_POSITIVE:\n                        Num_fp += 1\n                    else:\n                        Num_tn += 1\n\n            tpr = Num_tp * 1./(Num_tp + Num_fn)\n            fpr = Num_fp * 1./(Num_tn + Num_fp)\n\n            if tpr >= expected_tpr:\n\n                detectionRate = numpy.count_nonzero(output[0:self.posNum] == LABEL_POSITIVE) * 1./ self.posNum\n\n                best_th = threshold[t]\n                break\n\n        return best_th, detectionRate\n\n    def showErrRates(self):\n\n        pyplot.title(""The changes of accuracy (Figure by Jason Leaster)"")\n        pyplot.xlabel(""Iteration times"")\n        pyplot.ylabel(""Accuracy of Prediction"")\n        pyplot.plot([i for i in xrange(self.N)], \n                    self.accuracy, \'-.\', \n                    label = ""Accuracy * 100%"")\n        pyplot.axis([0., self.N, 0, 1.])\n\n        if DEBUG_MODEL == True:\n            pyplot.show()\n        else:\n            pyplot.savefig(""accuracyflow.jpg"")\n\n    def showROC(self):\n        best_tpr = 0.\n        best_fpr = 1.\n        best_th  = None\n\n        low_bound = -sum(self.alpha) * 0.5\n        up__bound = +sum(self.alpha) * 0.5\n        step      = 0.1\n        threshold = numpy.arange(low_bound, up__bound, step)\n\n        tprs      = numpy.zeros(threshold.size, dtype = numpy.float16)\n        fprs      = numpy.zeros(threshold.size, dtype = numpy.float16)\n\n        for t in xrange(threshold.size):\n\n            output = self.prediction(self._mat, threshold[t])\n\n            Num_tp = 0 # Number of true positive\n            Num_fn = 0 # Number of false negative\n            Num_tn = 0 # Number of true negative\n            Num_fp = 0 # Number of false positive\n            for i in range(self.samplesNum):\n                if self._label[i] == LABEL_POSITIVE:\n                    if output[i] == LABEL_POSITIVE:\n                        Num_tp += 1\n                    else:\n                        Num_fn += 1\n                else:\n                    if output[i] == LABEL_POSITIVE:\n                        Num_fp += 1\n                    else:\n                        Num_tn += 1\n\n            tpr = Num_tp * 1./(Num_tp + Num_fn)\n            fpr = Num_fp * 1./(Num_tn + Num_fp)\n\n            # if tpr >= best_tpr and fpr <= best_fpr:\n            #     best_tpr = tpr\n            #     best_fpr = fpr\n            #     best_th  = threshold[t]\n\n            tprs[t] = tpr\n            fprs[t] = fpr\n\n        fileObj = open(ROC_FILE, ""a+"")\n        for t, f, th in zip(tprs, fprs, threshold):\n            fileObj.write(str(t) + ""\\t"" + str(f) + ""\\t"" + str(th) + ""\\n"")\n\n        fileObj.flush()\n        fileObj.close()\n\n        pyplot.title(""The ROC curve"")\n        pyplot.plot(fprs, tprs, ""-r"", linewidth = 1)\n        pyplot.xlabel(""fpr"")\n        pyplot.ylabel(""tpr"")\n        pyplot.axis([-0.02, 1.1, 0, 1.1])\n        if DEBUG_MODEL == True:\n            pyplot.show()\n        else:\n            pyplot.savefig(""roc.jpg"")\n\n    def saveModel(self, filename):\n        """"""\n            function @saveModel save the key data member of AdaBoost\n        into a template file @ADABOOST_FILE\n        """"""\n        fileObj = open(filename, ""a+"")\n\n        for m in xrange(self.N):\n            fileObj.write(str(self.alpha[m]) + ""\\n"")\n            fileObj.write(str(self.G[m].opt_dimension) + ""\\n"")\n            fileObj.write(str(self.G[m].opt_direction) + ""\\n"")\n            fileObj.write(str(self.G[m].opt_threshold) + ""\\n"")\n\n        fileObj.flush()\n        fileObj.close()\n\n    def makeClassifierPic(self):\n        from config import TRAINING_IMG_HEIGHT\n        from config import TRAINING_IMG_WIDTH\n        from config import WHITE\n        from config import BLACK\n        from config import FIGURES\n\n        from config import HAAR_FEATURE_TYPE_I\n        from config import HAAR_FEATURE_TYPE_II\n        from config import HAAR_FEATURE_TYPE_III\n        from config import HAAR_FEATURE_TYPE_IV\n        from config import HAAR_FEATURE_TYPE_V\n\n        IMG_WIDTH  = TRAINING_IMG_WIDTH\n        IMG_HEIGHT = TRAINING_IMG_HEIGHT\n\n        haar = Feature(IMG_WIDTH, IMG_HEIGHT)\n\n        featuresAll = haar.features\n        selFeatures = [] # selected features\n\n        for n in xrange(self.N):\n            selFeatures.append(featuresAll[self.G[n].opt_dimension])\n\n        classifierPic = numpy.zeros((IMG_HEIGHT, IMG_WIDTH))\n\n        for n in xrange(self.N):\n            feature   = selFeatures[n]\n            alpha     = self.alpha[n]\n            direction = self.G[n].opt_direction\n\n            (types, x, y, width, height) = feature\n\n            image = numpy.array([[155 for i in xrange(IMG_WIDTH)] for j in xrange(IMG_HEIGHT)])\n\n            assert x >= 0 and x < IMG_WIDTH\n            assert y >= 0 and y < IMG_HEIGHT\n            assert width > 0 and height > 0\n\n            if direction == +1:\n                black = BLACK\n                white = WHITE\n            else:\n                black = WHITE\n                white = BLACK\n\n            if types == HAAR_FEATURE_TYPE_I:\n                for i in xrange(y, y + height * 2):\n                    for j in xrange(x, x + width):\n                        if i < y + height:\n                            image[i][j] = black\n                        else:\n                            image[i][j] = white\n\n            elif types == HAAR_FEATURE_TYPE_II:\n                for i in xrange(y, y + height):\n                    for j in xrange(x, x + width * 2):\n                        if j < x + width:\n                            image[i][j] = white\n                        else:\n                            image[i][j] = black\n\n            elif types == HAAR_FEATURE_TYPE_III:\n                for i in xrange(y, y + height):\n                    for j in xrange(x, x + width * 3):\n                        if j >= (x + width) and j < (x + width * 2):\n                            image[i][j] = black\n                        else:\n                            image[i][j] = white\n\n            elif types == HAAR_FEATURE_TYPE_IV:\n                for i in xrange(y, y + height*3):\n                    for j in xrange(x, x + width):\n                        if i >= (y + height) and i < (y + height * 2):\n                            image[i][j] = black\n                        else:\n                            image[i][j] = white\n\n            elif types == HAAR_FEATURE_TYPE_V:\n                for i in xrange(y, y + height * 2):\n                    for j in xrange(x, x + width * 2):\n                        if (j < x + width and i < y + height) or\\\n                           (j >= x + width and i >= y + height):\n                            image[i][j] = white\n                        else:\n                            image[i][j] = black\n            else:\n                raise Exception(""Unkown type feature"")\n\n            #classifierPic += image * alpha * direction\n            classifierPic += image\n\n\n            pyplot.matshow(image, cmap = ""gray"")\n            if DEBUG_MODEL == True:\n                pylab.show()\n            else:\n                pyplot.savefig(FIGURES + ""feature_"" + str(n) + "".jpg"")\n\n        from image import Image\n        classifierPic = Image._normalization(classifierPic)\n        pylab.matshow(classifierPic, cmap = ""gray"")\n        if DEBUG_MODEL == True:\n            pylab.show()\n        else:\n            pyplot.savefig(FIGURES + ""boosted_features.jpg"")\n'"
FaceDetection/cascade.py,0,"b'""""""\nProgrammer  :   EOF\nFile        :   cascade.py\nDate        :   2016.01.17\nE-mail      :   jasonleaster@163.com\n\nLicense     :   MIT License\n\n""""""\n\n\nfrom config   import POSITIVE_SAMPLE\nfrom config   import NEGATIVE_SAMPLE\nfrom config   import TRAINING_IMG_HEIGHT\nfrom config   import TRAINING_IMG_WIDTH\nfrom config   import FEATURE_FILE_TRAINING\nfrom config   import FEATURE_NUM\nfrom config   import ADABOOST_LIMIT\nfrom config   import ADABOOST_CACHE_FILE\nfrom config   import DEBUG_MODEL\n\nfrom haarFeature import Feature\nfrom image       import ImageSet\nfrom adaboost    import AdaBoost\nfrom adaboost    import getCachedAdaBoost\n\nimport os\nimport numpy\n\n\nclass Cascade:\n\n    def __init__(self, face_dir = """", nonface_dir = """", train = True, limit = 30):\n        #tot_samples = 0\n\n        self.Face    = ImageSet(face_dir,    sampleNum = POSITIVE_SAMPLE)\n        self.nonFace = ImageSet(nonface_dir, sampleNum = NEGATIVE_SAMPLE)\n\n        tot_samples = self.Face.sampleNum + self.nonFace.sampleNum\n\n        self.classifier = AdaBoost\n\n        self.haar   = Feature(TRAINING_IMG_WIDTH, TRAINING_IMG_HEIGHT)\n\n        if os.path.isfile(FEATURE_FILE_TRAINING + "".npy""):\n\n            self._mat = numpy.load(FEATURE_FILE_TRAINING + "".npy"")\n\n        else:\n            if DEBUG_MODEL is True:\n                self._mat = numpy.zeros((self.haar.featuresNum, tot_samples))\n\n                for i in xrange(self.Face.sampleNum):\n                    featureVec = self.haar.calFeatureForImg(self.Face.images[i])\n                    for j in xrange(self.haar.featuresNum):\n                        self._mat[j][i                     ]  = featureVec[j]\n\n                for i in xrange(self.nonFace.sampleNum):\n                    featureVec = self.haar.calFeatureForImg(self.nonFace.images[i])\n                    for j in xrange(self.haar.featuresNum):\n                        self._mat[j][i + self.Face.sampleNum] = featureVec[j]\n\n                numpy.save(FEATURE_FILE_TRAINING, self._mat)\n            else:\n                from mapReduce import map\n                from mapReduce import reduce\n\n                map(self.Face, self.nonFace)\n                self._mat = reduce()\n\n        featureNum, sampleNum = self._mat.shape\n\n        assert sampleNum  == (POSITIVE_SAMPLE + NEGATIVE_SAMPLE)\n        assert featureNum == FEATURE_NUM\n\n        Label_Face    = [+1 for i in xrange(POSITIVE_SAMPLE)]\n        Label_NonFace = [-1 for i in xrange(NEGATIVE_SAMPLE)]\n\n        self._label = numpy.array(Label_Face + Label_NonFace)\n        self.limit  = limit\n        self.classifierNum     = 0\n        self.strong_classifier = [None for i in xrange(limit)]\n\n\n    def train(self):\n\n        raise (""Unfinished"")\n\n        detection_rate = 0\n        from config import EXPECTED_FPR_PRE_LAYYER\n        from config import EXPECTED_FPR\n        from config import LABEL_NEGATIVE\n\n        cur_fpr = 1.0\n        mat   = self._mat\n        label = self._label\n\n        for i in xrange(self.limit):\n\n            if cur_fpr < EXPECTED_FPR:\n                break\n            else:\n                cache_filename = ADABOOST_CACHE_FILE + str(i)\n\n                if os.path.isfile(cache_filename):\n                    self.strong_classifier[i] = getCachedAdaBoost(mat     = self._mat,\n                                                                  label   = self._label,\n                                                                  filename= cache_filename,\n                                                                  limit   = ADABOOST_LIMIT)\n                else:\n                    self.strong_classifier[i] = AdaBoost(mat, label, limit = ADABOOST_LIMIT)\n                    output, fpr = self.strong_classifier[i].train()\n\n                    cur_fpr *= fpr\n\n                    fp_num = fpr * numpy.count_nonzero(label == LABEL_NEGATIVE)\n\n                    self.strong_classifier[i].saveModel(cache_filename)\n                    mat, label = self.updateTrainingDate(mat, output, fp_num)\n\n                self.classifierNum += 1\n\n\n    def updateTrainingDate(self, mat, output, fp_num):\n\n        fp_num = int(fp_num)\n\n        assert len(output) == self._label.size\n\n        _mat = numpy.zeros((FEATURE_NUM, POSITIVE_SAMPLE + fp_num), dtype=numpy.float16)\n\n        _mat[:, :POSITIVE_SAMPLE] = mat[:, :POSITIVE_SAMPLE]\n        """"""\n        for i in xrange(POSITIVE_SAMPLE):\n            for j in xrange(FEATURE_NUM):\n                mat[j][i] = self._mat[j][i]\n        """"""\n\n        counter = 0\n        # only reserve negative samples which are classified wrong\n        for i in xrange(POSITIVE_SAMPLE, self._label.size):\n            if output[i] != self._label[i]:\n                for j in xrange(FEATURE_NUM):\n                    _mat[j][POSITIVE_SAMPLE + counter] = mat[j][i]\n                counter += 1\n\n        assert counter == fp_num\n\n        Label_Face    = [+1 for i in xrange(POSITIVE_SAMPLE)]\n        Label_NonFace = [-1 for i in xrange(fp_num)]\n\n        _label = numpy.array(Label_Face + Label_NonFace)\n\n        return _mat, _label\n\n\n    def predict(self):\n\n        output = numpy.zeros(POSITIVE_SAMPLE + NEGATIVE_SAMPLE, dtype= numpy.float16)\n        for i in xrange(self.classifierNum):\n\n            self.strong_classifier[i].prediction(mat, th = 0)\n\n            """"""unfinished""""""\n\n    def save(self):\n        pass\n\n    def is_goodenough(self):\n        pass\n\n'"
FaceDetection/config.py,0,"b'""""""\nProgrammer  :   EOF\nFile        :   config.py\nDate        :   2016.01.06\nE-mail      :   jasonleaster@163.com\nLicense     :   MIT License\n\nDescription :\n    This is a configure file for this project.\n\n""""""\n\nDEBUG_MODEL   = True\nUSING_CASCADE = False\n\n# training set directory for face and non-face images\nTRAINING_FACE    = ""E:/JasonLeasterGraduationProject/FaceDetection/TrainingImages/FACES/""\nTRAINING_NONFACE = ""E:/JasonLeasterGraduationProject/FaceDetection/TrainingImages/NFACES/""\n\n# test set directory for face and non-face images\nTEST_FACE        = ""./TrainingImages/FACES/""\nTEST_NONFACE     = ""./TrainingImages/NFACES/""\n\n# single image for testing\nTEST_IMG         = ""./Test/soccer.gif""\n\nFEATURE_FILE_TRAINING = ""./features/features_train.cache""\nFEATURE_FILE_TESTING  = ""./features/features_test.cache""\n\nFEATURE_FILE_SUBSET   = ""./features/features_train_subset""\nFEATURE_FILE_SUBSET_0 = ""./features/features_train_subset0.cache""\nFEATURE_FILE_SUBSET_1 = ""./features/features_train_subset1.cache""\n\n# For parallel\nPROCESS_NUM = 2\n\nADABOOST_CACHE_FILE = ""./model/adaboost_classifier.cache""\nROC_FILE            = ""./model/roc.cache""\n\nFIGURES             = ""./figure/""\n\n# image size in the training set 19 * 19\nTRAINING_IMG_HEIGHT = 19\nTRAINING_IMG_WIDTH  = 19\n\n# How many different types of  Haar-feature\nFEATURE_TYPE_NUM    = 5\n# How many number of features that a single training image have\nFEATURE_NUM = 37862\n#FEATURE_NUM         = 16373\n#FEATURE_NUM         = 49608\n\n# number of positive and negative sample will be used in the training process\nPOSITIVE_SAMPLE     = 4800\nNEGATIVE_SAMPLE     = 9000\n\nSAMPLE_NUM = POSITIVE_SAMPLE + NEGATIVE_SAMPLE\n\nTESTING_POSITIVE_SAMPLE = 20\nTESTING_NEGATIVE_SAMPLE = 20\n\nTESTING_SAMPLE_NUM = TESTING_NEGATIVE_SAMPLE + TESTING_POSITIVE_SAMPLE\n\nLABEL_POSITIVE = +1\nLABEL_NEGATIVE = -1\n\nWHITE = 255\nBLACK = 0\n\nEXPECTED_TPR = 0.999\nEXPECTED_FPR = 0.0005\n\n# for CASCADE\nEXPECTED_FPR_PRE_LAYYER = 0.1\nEXPECTED_TPR_PRE_LAYYER = 0.999\n\n# the threshold range of adaboost. (from -inf to +inf)\nAB_TH_MIN   = -15\nAB_TH_MAX   = +15\n\nHAAR_FEATURE_TYPE_I     = ""I""\nHAAR_FEATURE_TYPE_II    = ""II""\nHAAR_FEATURE_TYPE_III   = ""III""\nHAAR_FEATURE_TYPE_IV    = ""IV""\nHAAR_FEATURE_TYPE_V     = ""V""\n\nAB_TH       = -3.\nOVER_LAP_TH = 0.1\n\nMAX_WEAK_NUM = 12\n\nCASACADE_LIMIT = 3\nADABOOST_LIMIT = 150\n\nSEARCH_WIN_STEP = 4\n\nDETECT_START = 1.\nDETECT_END   = 2.\nDETECT_STEP  = 0.2\n'"
FaceDetection/detector.py,0,"b'""""""\r\nProgrammer  :   EOF\r\nFile        :   detector.py\r\nE-mail      :   jasonleaster@163.com\r\nDate        :   2016.01.18\r\n""""""\r\n\r\nfrom config         import TRAINING_IMG_WIDTH\r\nfrom config         import TRAINING_IMG_HEIGHT\r\nfrom config         import HAAR_FEATURE_TYPE_I\r\nfrom config         import HAAR_FEATURE_TYPE_II\r\nfrom config         import HAAR_FEATURE_TYPE_III\r\nfrom config         import HAAR_FEATURE_TYPE_IV\r\nfrom config         import AB_TH\r\nfrom config         import SEARCH_WIN_STEP\r\n\r\nfrom image          import Image\r\nfrom haarFeature    import Feature\r\nfrom matplotlib     import pyplot\r\nfrom adaboost       import getCachedAdaBoost\r\nimport pylab\r\nimport numpy\r\n\r\n\r\nclass Detector:\r\n\r\n    def __init__(self):\r\n        pass\r\n\r\n\r\n    def scanImgAtScale(self, model, image, scale):\r\n        assert isinstance(image, numpy.ndarray)\r\n\r\n        ImgHeight, ImgWidth = image.shape\r\n\r\n        SEARCH_WIN_WIDTH  = int(TRAINING_IMG_WIDTH  * scale)\r\n        SEARCH_WIN_HEIGHT = int(TRAINING_IMG_HEIGHT * scale)\r\n\r\n        width     = ImgWidth - SEARCH_WIN_WIDTH - 10\r\n        height    = ImgHeight - SEARCH_WIN_HEIGHT - 10\r\n\r\n        step      = SEARCH_WIN_WIDTH/SEARCH_WIN_STEP\r\n\r\n        subWinNum = (width/step + 1) * (height/step + 1)\r\n\r\n        subImages = numpy.zeros(subWinNum, dtype = object)\r\n        subWins   = numpy.zeros(subWinNum, dtype = object)\r\n\r\n        idx = 0\r\n        for x in xrange(0, width, step):\r\n            for y in xrange(0, height, step):\r\n                subWins[idx]   = (x, y, SEARCH_WIN_WIDTH, SEARCH_WIN_HEIGHT)\r\n\r\n                subImages[idx] = Image(Mat = image[y:y+SEARCH_WIN_HEIGHT, x:x+SEARCH_WIN_WIDTH])\r\n                idx += 1\r\n\r\n        assert idx <= subWinNum\r\n\r\n        subImgNum = idx\r\n\r\n        selFeatures = numpy.zeros(model.N, dtype=object)\r\n\r\n        haar_scaled = Feature(SEARCH_WIN_WIDTH,   SEARCH_WIN_HEIGHT)\r\n        haar_train  = Feature(TRAINING_IMG_WIDTH, TRAINING_IMG_HEIGHT)\r\n\r\n        for n in xrange(model.N):\r\n            selFeatures[n] = haar_train.features[ model.G[n].opt_dimension ] + tuple([model.G[n].opt_dimension])\r\n\r\n        mat = numpy.zeros((haar_train.featuresNum, subImgNum), dtype=numpy.float16)\r\n\r\n        for feature in selFeatures:\r\n            (types, x, y, w, h, dim) = feature\r\n\r\n            x = int(x * scale)\r\n            y = int(y * scale)\r\n            w = int(w * scale)\r\n            h = int(h * scale)\r\n\r\n            for i in xrange(subImgNum):\r\n                if   types == HAAR_FEATURE_TYPE_I:\r\n                    mat[dim][i] = haar_scaled.VecFeatureTypeI(subImages[i].vecImg, x, y, w, h)\r\n                elif types == HAAR_FEATURE_TYPE_II:\r\n                    mat[dim][i] = haar_scaled.VecFeatureTypeII(subImages[i].vecImg, x, y, w, h)\r\n                elif types == HAAR_FEATURE_TYPE_III:\r\n                    mat[dim][i] = haar_scaled.VecFeatureTypeIII(subImages[i].vecImg, x, y, w, h)\r\n                elif types == HAAR_FEATURE_TYPE_IV:\r\n                    mat[dim][i] = haar_scaled.VecFeatureTypeIV(subImages[i].vecImg, x, y, w, h)\r\n\r\n        output = model.grade(mat)\r\n\r\n        rectangle = []\r\n        for i in xrange(len(output)):\r\n            if output[i] > AB_TH:\r\n                candidate = numpy.array(subWins[i])\r\n                x, y, w, h = candidate\r\n                rectangle.append((x, y, w, h, output[i]))\r\n\r\n        return rectangle\r\n\r\n\r\n    def scanImgOverScale(self, image):\r\n\r\n        from config import DETECT_START\r\n        from config import DETECT_END\r\n        from config import DETECT_STEP\r\n        from config import ADABOOST_CACHE_FILE\r\n        from config import ADABOOST_LIMIT\r\n\r\n        model = getCachedAdaBoost(filename = ADABOOST_CACHE_FILE + str(0), limit = ADABOOST_LIMIT)\r\n\r\n        rectangles = []\r\n\r\n        for scale in numpy.arange(DETECT_START , DETECT_END, DETECT_STEP):\r\n            rectangles += self.scanImgAtScale(model, image, scale)\r\n\r\n        return self.optimalRectangle(rectangles)\r\n\r\n\r\n    def optimalRectangle(self, rectangles):\r\n\r\n        # number of rectangles\r\n        numRec = len(rectangles)\r\n\r\n        for i in xrange(numRec):\r\n            for j in xrange(i+1, numRec):\r\n                if rectangles[i][4] < rectangles[j][4]:\r\n                    rectangles[i], rectangles[j] = \\\r\n                    tuple(rectangles[j]), tuple(rectangles[i])\r\n\r\n        """"""\r\n        (x1, y1, w1, h1) represent as the first  rectangle.\r\n        (x2, y2, w2, h2) represent as the second rectangle.\r\n        |-------> x\r\n        | _______\r\n        ||  1  __|____\r\n        ||____|__|    |\r\n        |     |____2__|\r\n        \\/ y\r\n        """"""\r\n        reduced = [i for i in xrange(numRec)]\r\n        for i in xrange(numRec):\r\n            x1, y1, w1, h1, score1 = rectangles[i]\r\n            area_1 = w1 * h1\r\n            for j in xrange(i+1, numRec):\r\n                x2, y2, w2, h2, score2 = rectangles[j]\r\n                area_2 = h2 * w2\r\n\r\n                if( self.pointInRectangle((x2,      y2     ), rectangles[i]) or\r\n                    self.pointInRectangle((x2 + w2, y2     ), rectangles[i]) or\r\n                    self.pointInRectangle((x2,      y2 + h2), rectangles[i]) or\r\n                    self.pointInRectangle((x2 + w2, y2 + h2), rectangles[i]) or\r\n                    self.pointInRectangle((x2 + w2/2,y2    ), rectangles[i]) or\r\n                    self.pointInRectangle((x2      ,y2+h2/2), rectangles[i]) or\r\n                    self.pointInRectangle((x2 + w2, y2+h2/2), rectangles[i]) or\r\n                    self.pointInRectangle((x2 + w2/2,y2+h2 ), rectangles[i]) ) is True:\r\n\r\n                    reduced[j] = reduced[i]\r\n\r\n                if( self.pointInRectangle((x1,      y1     ), rectangles[j]) or\r\n                    self.pointInRectangle((x1 + w1, y1     ), rectangles[j]) or\r\n                    self.pointInRectangle((x1,      y1 + h1), rectangles[j]) or\r\n                    self.pointInRectangle((x1 + w1, y1 + h1), rectangles[j]) or\r\n                    self.pointInRectangle((x1 + w1/2,y1    ), rectangles[j]) or\r\n                    self.pointInRectangle((x1      ,y1+h1/2), rectangles[j]) or\r\n                    self.pointInRectangle((x1 + w1, y1+h1/2), rectangles[j]) or\r\n                    self.pointInRectangle((x1 + w1/2,y1+h1 ), rectangles[j]) ) is True:\r\n\r\n                    reduced[j] = reduced[i]\r\n\r\n        reducedRectangels = []\r\n        for i in numpy.unique(reduced):\r\n            reducedRectangels.append(rectangles[i])\r\n\r\n        return reducedRectangels\r\n\r\n\r\n    def pointInRectangle(self, point, rectangle):\r\n        m, n = point\r\n        x, y, w, h, _ = rectangle\r\n\r\n        if((x < m and m < x + w) and (y < n and n < y +h)):\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n    def drawRectangle(self, image, x, y, width, height):\r\n        assert isinstance(image, numpy.ndarray)\r\n\r\n        if len(image.shape) != 2:\r\n            Row, Col, _ = image.shape\r\n            if x + width >= Col or y + height >= Row:\r\n                return\r\n            image[y:y+height, x-1:x+1, 0] = 0\r\n            image[y:y+height, x-1:x+1, 1] = 255\r\n            image[y:y+height, x-1:x+1, 2] = 0\r\n\r\n            image[y:y+height, (x-1 + width):(x+1 + width), 0] = 0\r\n            image[y:y+height, (x-1 + width):(x+1 + width), 1] = 255\r\n            image[y:y+height, (x-1 + width):(x+1 + width), 2] = 0\r\n\r\n            image[y-1:y+1, x:x+width, 0] = 0\r\n            image[y-1:y+1, x:x+width, 1] = 255\r\n            image[y-1:y+1, x:x+width, 2] = 0\r\n\r\n            image[(y-1+height):(y+height+1), x:x+width, 0] = 0\r\n            image[(y-1+height):(y+height+1), x:x+width, 1] = 255\r\n            image[(y-1+height):(y+height+1), x:x+width, 2] = 0\r\n        else:\r\n            Row, Col = image.shape\r\n            if x + width >= Col or y + height >= Row:\r\n                return\r\n\r\n            image[y:y+height, x-1:x+1  ] = 255\r\n            image[y:y+height, x-1 + width:x+1 + width] = 255\r\n            image[y-1:y+1   , x:x+width] = 255\r\n            image[y-1+height:y+1+height, x:x+width] = 255\r\n\r\n        pyplot.imshow(image)\r\n        pylab.show()\r\n\r\n\r\n    def showResult(self, image, rectangles):\r\n\r\n        for rectangle in rectangles:\r\n            x, y, width, height, score = rectangle\r\n\r\n            print rectangle\r\n            self.drawRectangle(image, x, y, width, height)\r\n'"
FaceDetection/haarFeature.py,0,"b'""""""\nProgrammer  :   EOF\nDate        :   2016.01.16\nE-mail      :   jasonleaster@163.com\nFile        :   haarFeature.py\n\nDescription:\n\n    Types of Haar-like rectangle features\n     --- ---\n    |   +   |\n    |-------|\n    |   -   |\n     -------\n        I\n     --- ---     \n    |   |   |    \n    | - | + |    \n    |   |   |    \n     --- ---     \n       II\n\n     -- -- -- \n    |  |  |  |\n    |- | +| -|\n    |  |  |  |\n     -- -- -- \n       III\n\n     --- ---\n    |___-___|\n    |___+___|\n    |___-___|\n       IV\n\n     --- ---\n    | - | + |\n    |___|___|\n    | + | - |\n    |___|___|\n        V\n\n    For each feature pattern, the start point(x, y) is at \n    the most left-up pixel in that window. The size of that\n    window is @width * @height\n""""""\nimport numpy\n\nfrom config import HAAR_FEATURE_TYPE_I\nfrom config import HAAR_FEATURE_TYPE_II\nfrom config import HAAR_FEATURE_TYPE_III\nfrom config import HAAR_FEATURE_TYPE_IV\nfrom config import HAAR_FEATURE_TYPE_V\n\nfrom image import Image\n\n\nclass Feature:\n    def __init__(self, img_Width, img_Height):\n\n        self.featureName = ""Haar Feature""\n\n        self.img_Width  = img_Width\n        self.img_Height = img_Height\n\n        self.tot_pixels = img_Width * img_Height\n\n        self.featureTypes = (HAAR_FEATURE_TYPE_I,\n                             HAAR_FEATURE_TYPE_II,\n                             HAAR_FEATURE_TYPE_III,\n                             HAAR_FEATURE_TYPE_IV,\n                             HAAR_FEATURE_TYPE_V)\n\n        self.features    = self._evalFeatures_total()\n\n        self.featuresNum = len(self.features)\n\n        #self.featureMat  =     numpy.zeros((self.tot_pixels, self.featuresNum),\n        #                                   dtype=numpy.float16)\n\n        # just for running faster and save RAM. allocate once and use many times.\n        self.vector          = numpy.zeros(self.featuresNum, dtype=numpy.float32)\n\n        self.idxVector_tmp_0 = numpy.zeros(self.tot_pixels, dtype = numpy.int8)\n        self.idxVector_tmp_1 = numpy.zeros(self.tot_pixels, dtype = numpy.int8)\n        self.idxVector_tmp_2 = numpy.zeros(self.tot_pixels, dtype = numpy.int8)\n        self.idxVector_tmp_3 = numpy.zeros(self.tot_pixels, dtype = numpy.int8)\n\n\n    def vecRectSum(self, idxVector, x, y, width, height):\n        idxVector *= 0 # reset this vector\n        if x == 0 and y == 0:\n            idxVector[width * height + 2] = +1\n\n        elif x == 0:\n            idx1 = self.img_Height * (    width - 1) + height + y - 1\n            idx2 = self.img_Height * (    width - 1) +          y - 1\n            idxVector[idx1] = +1\n            idxVector[idx2] = -1\n\n        elif y == 0:\n            idx1 = self.img_Height * (x + width - 1) + height - 1\n            idx2 = self.img_Height * (x         - 1) + height - 1\n            idxVector[idx1] = +1\n            idxVector[idx2] = -1\n        else:\n            idx1 = self.img_Height * (x + width - 1) + height + y - 1\n            idx2 = self.img_Height * (x + width - 1) +          y - 1\n            idx3 = self.img_Height * (x         - 1) + height + y - 1\n            idx4 = self.img_Height * (x         - 1) +          y - 1\n\n            assert idx1 < self.tot_pixels and idx2 < self.tot_pixels \n            assert idx3 < self.tot_pixels and idx4 < self.tot_pixels \n\n            idxVector[idx1] = + 1\n            idxVector[idx2] = - 1\n            idxVector[idx3] = - 1\n            idxVector[idx4] = + 1\n\n        return idxVector\n\n\n    def VecFeatureTypeI(self, vecImg, x, y, width, height):\n        vec1 = self.vecRectSum(self.idxVector_tmp_0, x, y         , width, height)\n        vec2 = self.vecRectSum(self.idxVector_tmp_1, x, y + height, width, height)\n\n        featureSize = width * height * 2\n\n        return (vec1.dot(vecImg) - vec2.dot(vecImg))/featureSize\n\n\n    def VecFeatureTypeII(self, vecImg, x, y, width, height):\n        vec1 = self.vecRectSum(self.idxVector_tmp_0, x + width, y, width, height)\n        vec2 = self.vecRectSum(self.idxVector_tmp_1, x        , y, width, height)\n\n        featureSize = width * height * 2\n\n        return (vec1.dot(vecImg) - vec2.dot(vecImg))/featureSize\n\n\n    def VecFeatureTypeIII(self,vecImg, x, y, width, height):\n        vec1 = self.vecRectSum(self.idxVector_tmp_0, x +   width, y, width, height)\n        vec2 = self.vecRectSum(self.idxVector_tmp_1, x          , y, width, height)\n        vec3 = self.vecRectSum(self.idxVector_tmp_2, x + 2*width, y, width, height)\n\n        featureSize = width * height * 3\n\n        return (vec1.dot(vecImg) - vec2.dot(vecImg)\n                - vec3.dot(vecImg))/featureSize\n\n\n    def VecFeatureTypeIV(self,vecImg, x, y, width, height):\n        vec1 = self.vecRectSum(self.idxVector_tmp_0, x, y +   height, width, height)\n        vec2 = self.vecRectSum(self.idxVector_tmp_1, x, y           , width, height)\n        vec3 = self.vecRectSum(self.idxVector_tmp_2, x, y + 2*height, width, height)\n\n        featureSize = width * height * 3\n\n        return (vec1.dot(vecImg) - vec2.dot(vecImg)\n                - vec3.dot(vecImg))/featureSize\n\n\n    def VecFeatureTypeV(self, vecImg, x, y, width, height):\n        vec1 = self.vecRectSum(self.idxVector_tmp_0, x + width,          y, width, height)\n        vec2 = self.vecRectSum(self.idxVector_tmp_1, x        ,          y, width, height)\n        vec3 = self.vecRectSum(self.idxVector_tmp_2, x        , y + height, width, height)\n        vec4 = self.vecRectSum(self.idxVector_tmp_3, x + width, y + height, width, height)\n\n        featureSize = width * height * 4\n\n        return (vec1.dot(vecImg) - vec2.dot(vecImg) +\n                vec3.dot(vecImg) - vec4.dot(vecImg))/featureSize\n\n\n    def _evalFeatures_total(self):\n        win_Height = self.img_Height\n        win_Width  = self.img_Width\n\n        height_Limit = {HAAR_FEATURE_TYPE_I    : win_Height/2 - 1,\n                         HAAR_FEATURE_TYPE_II  : win_Height   - 1,\n                         HAAR_FEATURE_TYPE_III : win_Height   - 1,\n                         HAAR_FEATURE_TYPE_IV  : win_Height/3 - 1,\n                         HAAR_FEATURE_TYPE_V   : win_Height/2 - 1}\n\n        width_Limit  = {HAAR_FEATURE_TYPE_I   : win_Width   - 1,\n                        HAAR_FEATURE_TYPE_II  : win_Width/2 - 1,\n                        HAAR_FEATURE_TYPE_III : win_Width/3 - 1,\n                        HAAR_FEATURE_TYPE_IV  : win_Width   - 1,\n                        HAAR_FEATURE_TYPE_V   : win_Width/2 - 1}\n\n        features = []\n        for types in self.featureTypes:\n            for w in xrange(1, width_Limit[types]):\n                for h in xrange(1, height_Limit[types]):\n\n                    if w == 1 and h == 1:\n                        continue\n\n                    if types == HAAR_FEATURE_TYPE_I:\n\n                        x_limit = win_Width  - w\n                        y_limit = win_Height - 2*h\n                        for x in xrange(1, x_limit):\n                            for y in xrange(1, y_limit):\n                                features.append( (types, x, y, w, h))\n\n                    elif types == HAAR_FEATURE_TYPE_II:\n                        x_limit = win_Width  - 2*w\n                        y_limit = win_Height - h\n                        for x in xrange(1, x_limit):\n                            for y in xrange(1, y_limit):\n                                features.append( (types, x, y, w, h))\n\n                    elif types == HAAR_FEATURE_TYPE_III:\n                        x_limit = win_Width  - 3*w\n                        y_limit = win_Height - h\n                        for x in xrange(1, x_limit):\n                            for y in xrange(1, y_limit):\n                                features.append( (types, x, y, w, h))\n\n\n                    elif types == HAAR_FEATURE_TYPE_IV:\n                        x_limit = win_Width  - w\n                        y_limit = win_Height - 3*h\n                        for x in xrange(1, x_limit):\n                            for y in xrange(1, y_limit):\n                                features.append( (types, x, y, w, h))\n\n                    elif types == HAAR_FEATURE_TYPE_V:\n                        x_limit = win_Width  - 2*w\n                        y_limit = win_Height - 2*h\n                        for x in xrange(1, x_limit):\n                            for y in xrange(1, y_limit):\n                                features.append( (types, x, y, w, h))\n\n        return features\n\n\n    def calFeatureForImg(self, img):\n\n        assert isinstance(img, Image)\n        assert img.img.shape[0] == self.img_Height\n        assert img.img.shape[1] == self.img_Width\n\n        for i in xrange(self.featuresNum):\n            type, x, y, w, h = self.features[i]\n\n            if   type == HAAR_FEATURE_TYPE_I:\n                self.vector[i] = self.VecFeatureTypeI(img.vecImg, x, y, w, h)\n            elif type == HAAR_FEATURE_TYPE_II:\n                self.vector[i] = self.VecFeatureTypeII(img.vecImg, x, y, w, h)\n            elif type == HAAR_FEATURE_TYPE_III:\n                self.vector[i] = self.VecFeatureTypeIII(img.vecImg, x, y, w, h)\n            elif type == HAAR_FEATURE_TYPE_IV:\n                self.vector[i] = self.VecFeatureTypeIV(img.vecImg, x, y, w, h)\n            elif type == HAAR_FEATURE_TYPE_V:\n                self.vector[i] = self.VecFeatureTypeV(img.vecImg, x, y, w, h)\n            else:\n                raise Exception(""unknown feature type"")\n\n        return self.vector\n\n\n    def makeFeaturePic(self, feature):\n\n        from matplotlib import pyplot\n        from config     import BLACK\n        from config     import WHITE\n        import pylab\n\n        (types, x, y, width, height) = feature\n\n        assert x >= 0 and x < self.img_Width\n        assert y >= 0 and y < self.img_Height\n        assert width > 0 and height > 0\n\n        image = numpy.array([[125. for i in xrange(self.img_Width)]\n                                 for j in xrange(self.img_Height)])\n\n        if types == HAAR_FEATURE_TYPE_I:\n            for i in xrange(y, y + height * 2):\n                for j in xrange(x, x + width):\n                    if i < y + height:\n                        image[i][j] = BLACK\n                    else:\n                        image[i][j] = WHITE\n\n        elif types == HAAR_FEATURE_TYPE_II:\n            for i in xrange(y, y + height):\n                for j in xrange(x, x + width * 2):\n                    if j < x + width:\n                        image[i][j] = WHITE\n                    else:\n                        image[i][j] = BLACK\n\n        elif types == HAAR_FEATURE_TYPE_III:\n            for i in xrange(y, y + height):\n                for j in xrange(x, x + width * 3):\n                    if j >= (x + width) and j < (x + width * 2):\n                        image[i][j] = BLACK\n                    else:\n                        image[i][j] = WHITE\n\n        elif types == HAAR_FEATURE_TYPE_IV:\n            for i in xrange(y, y + height*3):\n                for j in xrange(x, x + width):\n                    if i >= (y + height) and i < (y + height * 2):\n                        image[i][j] = BLACK\n                    else:\n                        image[i][j] = WHITE\n\n        elif types == HAAR_FEATURE_TYPE_V:\n            for i in xrange(y, y + height * 2):\n                for j in xrange(x, x + width * 2):\n                    if (j < x + width and i < y + height) or\\\n                       (j >= x + width and i >= y + height):\n                        image[i][j] = BLACK\n                    else:\n                        image[i][j] = WHITE\n\n\n        pyplot.matshow(image, cmap = ""gray"")\n        pylab.show()\n\n\n    """"""\n    old version. Don\'t use this.\n    def _evalFeatures(self):\n        win_Height = self.img_Height\n        win_Width  = self.img_Width\n\n        height_Limit = {HAAR_FEATURE_TYPE_I   : win_Height/2 - 1,\n                        HAAR_FEATURE_TYPE_II  : win_Height   - 1,\n                        HAAR_FEATURE_TYPE_III : win_Height   - 1,\n                        HAAR_FEATURE_TYPE_IV  : win_Height/2 - 1}\n\n        width_Limit  = {HAAR_FEATURE_TYPE_I   : win_Width   - 1,\n                        HAAR_FEATURE_TYPE_II  : win_Width/2 - 1,\n                        HAAR_FEATURE_TYPE_III : win_Width/3 - 1,\n                        HAAR_FEATURE_TYPE_IV  : win_Width/2 - 1}\n\n        features = []\n        for types in self.featureTypes:\n            for w in xrange(1, width_Limit[types]):\n                for h in xrange(1, height_Limit[types]):\n\n                    y_start = None\n\n                    if types == HAAR_FEATURE_TYPE_I:\n                        x_limit = win_Width  - w\n                        y_limit = win_Height - 2*h\n                        for x in xrange(1, x_limit):\n                            for y in xrange(1, y_limit, 2):\n                                features.append( (types, x, y, w, h))\n\n                    elif types == HAAR_FEATURE_TYPE_II:\n                        x_limit = win_Width  - 2*w\n                        y_limit = win_Height - h\n                        for x in xrange(1, x_limit):\n                            if h % 2 == 1:\n                                if x % 2 == 1:\n                                    y_start = 1\n                                else:\n                                    y_start = 2\n                            else:\n                                y_start = 1\n\n                            for y in xrange(y_start, y_limit, 2):\n                                features.append( (types, x, y, w, h))\n\n                    elif types == HAAR_FEATURE_TYPE_III:\n                        x_limit = win_Width  - 3*w\n                        y_limit = win_Height - h\n                        for x in xrange(1, x_limit):\n                            if w == 1:\n                                if h % 2 == 1:\n                                    if (h + 1)/2 % 2 == 1:\n                                        if x % 2 == 1:\n                                            y_start = 1\n                                        else:\n                                            y_start = 2\n                                    else:\n                                        if x % 2 == 1:\n                                            y_start = 2\n                                        else:\n                                            y_start = 1\n                                else:\n                                    if (h/2) % 2 == 1:\n                                        y_start = 2\n                                    else:\n                                        y_start = 1\n                            elif w == 2:\n                                if h % 2 == 1:\n                                    if x % 2 == 1:\n                                        y_start = 2\n                                    else:\n                                        y_start = 1\n                                else:\n                                    y_start = 2\n\n                            elif w == 3:\n                                if h % 2 == 1:\n                                    if (h+1)/2 % 2 == 1:\n                                        if x % 2 == 1:\n                                            y_start = 2\n                                        else:\n                                            y_start = 1\n                                    else:\n                                        if x % 2 == 1:\n                                            y_start = 1\n                                        else:\n                                            y_start = 2\n                                else:\n                                    if (h/2) % 2 == 1:\n                                        y_start = 1\n                                    else:\n                                        y_start = 2\n                            #elif w == 4:\n                            else:\n                                if h % 2 == 1:\n                                    if x % 2 == 1:\n                                        y_start = 1\n                                    else:\n                                        y_start = 2\n                                else:\n                                    y_start = 1\n\n                            for y in xrange(y_start, y_limit, 2):\n                                features.append( (types, x, y, w, h))\n\n                    elif types == HAAR_FEATURE_TYPE_IV:\n                        x_limit = win_Width  - 2*w\n                        y_limit = win_Height - 2*h\n                        for x in xrange(1, x_limit):\n                            for y in xrange(1, y_limit, 2):\n                                features.append( (types, x, y, w, h))\n        return features\n    """"""\n\n'"
FaceDetection/image.py,0,"b'""""""\nProgrammer  :   EOF\nFile        :   image.py\nDate        :   2015.12.29\nE-mail      :   jasonleaster@163.com\nLicense     :   MIT License\n\nDescription :\n    This script file will initialize the image set\nand read all images in the directory which is given by\nuser.\n\n""""""\nimport numpy\nimport os\nimport pylab\n\nfrom matplotlib import pyplot\nfrom matplotlib import image\n\n\nclass Image:\n\n    def __init__(self, fileName = None, label = None, Mat = None):\n        if fileName != None:\n            self.imgName = fileName\n            self.img     = image.imread(fileName)\n\n            if len(self.img.shape) == 3:\n                self.img     = self.img[:,:, 1]\n\n        else:\n            assert Mat != None\n            self.img     = Mat\n\n        self.label   = label\n\n        #self.stdImg  = Image._normalization(self.img)\n\n        #self.iimg    = Image._integrateImg(self.stdImg)\n\n        #self.vecImg  = self.iimg.transpose().flatten()\n\n        self.vecImg = Image._integrateImg( Image._normalization(self.img)  ).transpose().flatten()\n\n\n    @staticmethod\n    def _integrateImg(image):\n\n        assert image.__class__ == numpy.ndarray\n\n        row, col = image.shape\n        #@iImg is integrated image of normalized image @self.stdImg\n        iImg = numpy.zeros((row, col))\n\n        """"""\n        for i in xrange(0, row):\n            for j in xrange(0, col):\n                if j == 0:\n                    iImg[i][j] = image[i][j]\n                else:\n                    iImg[i][j] = iImg[i][j - 1] + image[i][j]\n        \n        for j in xrange(0, col):\n            for i in xrange(1, row):\n                iImg[i][j] += iImg[i - 1][j]\n        """"""\n\n        iImg = image.cumsum(axis=1).cumsum(axis=0)\n        return iImg\n\n\n    @staticmethod\n    def _normalization(image):\n\n        assert image.__class__ == numpy.ndarray\n\n        row, col = image.shape\n\n        #stdImag standardized image\n        stdImg = numpy.zeros((row, col))\n        """"""\n            What image.sum() do is the same as the following code \n        but more faster than this.\n\n        for i in xrange(self.Row):\n            for j in xrange(self.Col):\n                sigma += image[i][j]\n        """"""\n        #sigma = image.sum()\n\n        meanVal = image.mean()\n\n        stdValue = image.std()\n        if stdValue == 0:\n            stdValue = 1\n\n        stdImg = (image - meanVal) / stdValue\n\n        return stdImg\n\n\n    @staticmethod\n    def show(image = None):\n        if image == None:\n            return\n        pyplot.matshow(image)\n        pylab.show()\n\n\nclass ImageSet:\n    def __init__(self, imgDir = None, label = None, sampleNum = None):\n\n        assert isinstance(imgDir, str)\n\n        self.imgDir = imgDir\n        self.fileList = os.listdir(imgDir)\n        self.fileList.sort()\n\n        if sampleNum == None:\n            self.sampleNum = len(self.fileList)\n        else:\n            self.sampleNum = sampleNum\n\n        self.curFileIdx = self.sampleNum\n        self.label  = label\n\n        self.images = [None for _ in xrange(self.sampleNum)]\n\n        processed = -10.\n        for i in xrange(self.sampleNum):\n            self.images[i] = Image(imgDir + self.fileList[i], label)\n\n            if i % (self.sampleNum / 10) == 0:\n                processed += 10.\n                print ""Loading "", processed, ""%""\n\n        print ""Loading  100 %\\n""\n\n\n    def readNextImg(self):\n        img = Image(self.imgDir + self.fileList[self.curFileIdx], self.label)\n        self.curFileIdx += 1\n        return img\n'"
FaceDetection/mapReduce.py,0,"b'""""""\nProgrammer  :   EOF\nE-mail      :   jasonleaster@gmail.com\nFile        :   mapReduce.py\nDate        :   2016.04.15\n\nFile Description:\n\n        This file contain two helpful function @Map and @Reduce\n    which will help us to do parallel computing to accelerate the \n    process to compute features of images.\n\n""""""\n\nfrom config     import PROCESS_NUM\nfrom config     import FEATURE_FILE_SUBSET\nfrom config     import TRAINING_IMG_WIDTH\nfrom config     import TRAINING_IMG_HEIGHT\n\nfrom mr_routine import routine\nfrom haarFeature import Feature\n\nfrom multiprocessing import Process\nfrom image      import ImageSet\n\nimport numpy\n\n\ndef map(Face, NonFace):\n\n    assert isinstance(Face,    ImageSet)\n    assert isinstance(NonFace, ImageSet)\n\n    # Multi-Process for acceleration\n    images    = Face.images + NonFace.images\n    images_num= len(images)\n    processes = []\n\n    for i in xrange(PROCESS_NUM):\n        start = int((i    *1./PROCESS_NUM) * images_num)\n        end   = int(((i+1)*1./PROCESS_NUM) * images_num )\n        sub_imgs = images[start:end]\n\n        process = Process(target = routine,\n                            args = (sub_imgs,\n                                    FEATURE_FILE_SUBSET + str(i) + "".cache"")) \n        processes.append(process)\n        \n    for i in xrange(PROCESS_NUM):\n        processes[i].start()\n\n    for i in xrange(PROCESS_NUM):\n        processes[i].join()\n\n\ndef reduce():\n    from config import FEATURE_FILE_TRAINING\n    from config import FEATURE_FILE_SUBSET\n    from config import PROCESS_NUM\n\n    mats = []\n    tot_samples = 0\n    for i in xrange(PROCESS_NUM):\n        sub_mat = numpy.load(FEATURE_FILE_SUBSET + str(i) + "".cache"" + "".npy"")\n        mats.append(sub_mat)\n        tot_samples += sub_mat.shape[1]\n\n    haar = Feature(TRAINING_IMG_WIDTH, TRAINING_IMG_HEIGHT)\n\n    mat  = numpy.zeros((haar.featuresNum, tot_samples), numpy.float32)\n    sample_readed = 0\n    for i in xrange(PROCESS_NUM):\n        for m in xrange(mats[i].shape[0]): # feature number\n            for n in xrange(mats[i].shape[1]): # sample number\n\n                mat[m][n + sample_readed] = mats[i][m][n]\n\n        sample_readed += mats[i].shape[1]\n\n    numpy.save(FEATURE_FILE_TRAINING, mat)\n\n    return mat\n'"
FaceDetection/mr_routine.py,0,"b'""""""\r\nProgrammer  :   EOF\r\nFile        :   mr_routine.py\r\nDate        :   2015.12.29\r\nE-mail      :   jasonleaster@163.com\r\n\r\n""""""\r\nfrom config     import TRAINING_IMG_WIDTH\r\nfrom config     import TRAINING_IMG_HEIGHT\r\n\r\nfrom haarFeature import Feature\r\nimport numpy\r\nfrom functools import wraps\r\ndef processMeassure(fn):\r\n    @wraps(fn)\r\n    def measure_time(*args, **kwargs):\r\n        import os\r\n        import time\r\n        print ""process "", os.getpid(), ""started!""\r\n        start = time.time()\r\n        fn(*args, **kwargs)\r\n        end   = time.time()\r\n        print ""Cost time: "", end - start, "" second.""\r\n        print ""Process ""   , os.getpid(), "" end!""\r\n\r\n    return measure_time\r\n\r\n@processMeassure\r\ndef routine(images, filename):\r\n    tot_samples = len(images)\r\n\r\n    haar = Feature(TRAINING_IMG_WIDTH, TRAINING_IMG_HEIGHT)\r\n\r\n    mat = numpy.zeros((haar.featuresNum, tot_samples), dtype = numpy.float32)\r\n\r\n    for i in xrange(tot_samples):\r\n        featureVec = haar.calFeatureForImg(images[i])\r\n        for j in xrange(haar.featuresNum):\r\n            mat[j][i]  = featureVec[j]\r\n\r\n    numpy.save(filename, mat)\r\n'"
FaceDetection/testing.py,0,"b'from config import TEST_FACE\nfrom config import TEST_NONFACE\nfrom config import TRAINING_IMG_HEIGHT\nfrom config import TRAINING_IMG_WIDTH\nfrom config import ADABOOST_CACHE_FILE\nfrom config import POSITIVE_SAMPLE\nfrom config import LABEL_POSITIVE\n\nfrom adaboost import getCachedAdaBoost\n\nfrom image  import ImageSet\nfrom haarFeature import Feature\n\nimport numpy\n\nface    = ImageSet(TEST_FACE,    sampleNum = 100)\n\nnonFace = ImageSet(TEST_NONFACE, sampleNum = 100)\n\ntot_samples = face.sampleNum + nonFace.sampleNum\n\nhaar   = Feature(TRAINING_IMG_WIDTH, TRAINING_IMG_HEIGHT)\n\nmat = numpy.zeros((haar.featuresNum, tot_samples))\n\nfor i in xrange(face.sampleNum):\n    featureVec = haar.calFeatureForImg(face.images[i])\n    for j in xrange(haar.featuresNum):\n        mat[j][i                     ]  = featureVec[j]\n        \nfor i in xrange(nonFace.sampleNum):\n    featureVec = haar.calFeatureForImg(nonFace.images[i])\n    for j in xrange(haar.featuresNum):\n        mat[j][i + face.sampleNum] = featureVec[j]\n\n\nmodel = getCachedAdaBoost(filename = ADABOOST_CACHE_FILE + str(0), limit = 10)\n\noutput = model.prediction(mat, th=0)\n\ndetectionRate = numpy.count_nonzero(output[0:100] == LABEL_POSITIVE) * 1./ 100\n\nprint output\n\n\n\n'"
FaceDetection/training.py,0,"b'""""""\nProgrammer  :   EOF\nFile        :   training.py\nDate        :   2015.12.29\nE-mail      :   jasonleaster@163.com\n\n""""""\n\nfrom config import TRAINING_FACE\nfrom config import TRAINING_NONFACE\nfrom config import CASACADE_LIMIT\n\nfrom cascade import Cascade\n\nfrom time import time\n\nfrom multiprocessing import  freeze_support\n\nraise Exception(""Unimplemented Cascade"")\n\nif __name__ == ""__main__"":\n    freeze_support()\n\n    start_time = time()\n    model      = Cascade(TRAINING_FACE, TRAINING_NONFACE, limit = CASACADE_LIMIT)\n    end_time   = time()\n\n    print ""total Cost time: "", end_time - start_time\n\n    try:\n        model.train()\n        model.save()\n    except KeyboardInterrupt:\n        print ""key board interrupt happened. training pause.""\n    \n    \n\n\t\n\n\n'"
FaceDetection/trainingAdaBoost.py,0,"b'""""""\nProgrammer  :   EOF\nFile        :   trainingAdaBoost.py\nDate        :   2015.12.29\nE-mail      :   jasonleaster@163.com\n\n""""""\n\nfrom config   import POSITIVE_SAMPLE\nfrom config   import NEGATIVE_SAMPLE\nfrom config   import TRAINING_IMG_HEIGHT\nfrom config   import TRAINING_IMG_WIDTH\nfrom config   import FEATURE_FILE_TRAINING\nfrom config   import FEATURE_NUM\nfrom config   import ADABOOST_LIMIT\nfrom config   import ADABOOST_CACHE_FILE\nfrom config   import DEBUG_MODEL\nfrom config   import TRAINING_FACE\nfrom config   import TRAINING_NONFACE\n\nfrom haarFeature import Feature\nfrom image       import ImageSet\nfrom adaboost    import AdaBoost\nfrom adaboost    import getCachedAdaBoost\n\nimport os\nimport numpy\n\nFace    = ImageSet(TRAINING_FACE,    sampleNum = POSITIVE_SAMPLE)\nnonFace = ImageSet(TRAINING_NONFACE, sampleNum = NEGATIVE_SAMPLE)\n\ntot_samples = Face.sampleNum + nonFace.sampleNum\n\nhaar   = Feature(TRAINING_IMG_WIDTH, TRAINING_IMG_HEIGHT)\n\nif os.path.isfile(FEATURE_FILE_TRAINING + "".npy""):\n\n    _mat = numpy.load(FEATURE_FILE_TRAINING + "".npy"")\n\nelse:\n    if DEBUG_MODEL is True:\n        _mat = numpy.zeros((haar.featuresNum, tot_samples))\n\n        for i in xrange(Face.sampleNum):\n            featureVec = haar.calFeatureForImg(Face.images[i])\n            for j in xrange(haar.featuresNum):\n                _mat[j][i                     ]  = featureVec[j]\n\n        for i in xrange(nonFace.sampleNum):\n            featureVec = haar.calFeatureForImg(nonFace.images[i])\n            for j in xrange(haar.featuresNum):\n                _mat[j][i + Face.sampleNum] = featureVec[j]\n\n        numpy.save(FEATURE_FILE_TRAINING, _mat)\n    else:\n        from mapReduce import map\n        from mapReduce import reduce\n\n        map(Face, nonFace)\n        _mat = reduce()\n\nmat = _mat\n\nfeatureNum, sampleNum = _mat.shape\n\nassert sampleNum  == (POSITIVE_SAMPLE + NEGATIVE_SAMPLE)\nassert featureNum == FEATURE_NUM\n\nLabel_Face    = [+1 for i in xrange(POSITIVE_SAMPLE)]\nLabel_NonFace = [-1 for i in xrange(NEGATIVE_SAMPLE)]\n\nlabel = numpy.array(Label_Face + Label_NonFace)\n\ncache_filename = ADABOOST_CACHE_FILE + str(0)\n\nif os.path.isfile(cache_filename):\n    model = getCachedAdaBoost(mat     = _mat,\n                              label   = label,\n                              filename= cache_filename,\n                              limit   = ADABOOST_LIMIT)\nelse:\n    model = AdaBoost(mat, label, limit = ADABOOST_LIMIT)\n    model.train()\n    model.saveModel(cache_filename)\n\nprint model\n'"
FaceDetection/weakClassifier.py,0,"b'""""""\nProgrammer  :   EOF\nE-mail      :   jasonleaster@163.com\nDate        :   2015.11.22\nFile        :   weakClassifier.py\n\nLicense     :   MIT License\n\n""""""\n\nfrom matplotlib import pyplot\nimport numpy\n\nfrom config import LABEL_POSITIVE\nfrom config import LABEL_NEGATIVE\n\n\nclass WeakClassifier:\n\n    def __init__(self, Mat = None, Tag = None, W = None, train = True):\n        """"""\n        Parameter:\n        @Mat    :   A matrix(or two dimension array) which\'s size is\n                    (row    = number of features, \n                    column  = number of total sample)\n        @Tag    :   A vector(or one dimension array) which\'s size is the\n                    same as the number of total sample\n\n        @W      :   Weight of each sample in the training set.\n                    A vector or a list, which\'s size is the same as the \n                    number of total sample.\n\n        @train  :   A bool value. If it\'s False, it means that user want to\n                    get a instance of this class object from cached data""""""\n\n        if train == True:\n            """"""\n            It\'s necessary to do this check.\n            The implementation depend on numpy.ndarray heavily\n            """"""\n            assert Mat.__class__ == numpy.ndarray\n            assert Tag.__class__ == numpy.ndarray\n            assert   W.__class__ == numpy.ndarray\n\n            """"""\n            It will cost a lot of memory, if I use @Mat to initialize\n            the @self._mat like this:\n                self._mat = numpy.array(Mat)\n\n            constructor @numpy.array will return a new object which\'s\n            message is the same as @Mat\n\n            To save memory, I just set the data member @self._mat\n            the same as the parameter passed into this constructor,\n            which means that they point to the same address.\n\n            Make sure this weak classifier will not modify the inputed mat.\n            """"""\n            self._mat = Mat\n            self._label = Tag\n\n            # sampleDim == the number of features\n            self.sampleDim, self.sampleNum = self._mat.shape\n\n            if W == None:\n                self.numPos = numpy.count_nonzero(self._label == LABEL_POSITIVE)\n                self.numNeg = numpy.count_nonzero(self._label == LABEL_NEGATIVE)\n                pos_W = [1.0/(2 * self.numPos) for i in xrange(self.numPos)]\n                            \n                neg_W = [1.0/(2 * self.numNeg) for i in xrange(self.numNeg)]\n                self.weight = numpy.array(pos_W + neg_W)\n\n            else:\n                self.weight = W\n\n            self.output = numpy.zeros(self.sampleNum, dtype = numpy.int)\n\n            self.opt_errorRate = 1.\n            self.opt_dimension = 0\n            self.opt_threshold = None\n            self.opt_direction = 0\n            \n\n    def optimal(self, d):\n\n        # for positive sample\n        idx = (self._label + LABEL_POSITIVE) / (LABEL_POSITIVE * 2)\n        weight = self.weight  * idx\n        vector = self._mat[d] * idx\n        sumPos = weight.dot(vector)\n        sumPosW= weight.sum()\n\n        # for negative sample\n        idx = (self._label + LABEL_NEGATIVE) / (LABEL_NEGATIVE * 2)\n        weight = self.weight  * idx\n        vector = self._mat[d] * idx\n        sumNeg = weight.dot(vector)\n        sumNegW= weight.sum()\n\n        """"""\n        Code beyong there is just optimal version of this one.\n        ======================================================\n        sumPos = 0.\n        sumNeg = 0.\n\n        sumPosW = 0.\n        sumNegW = 0.\n\n        for i in xrange(self.sampleNum):\n            if self._label[i] == LABEL_POSITIVE:\n                sumPos  += self.weight[i] * self._mat[d][i]\n                sumPosW += self.weight[i]\n            else:\n                sumNeg  += self.weight[i] * self._mat[d][i]\n                sumNegW += self.weight[i]\n        """"""\n                \n        miuPos = sumPos / sumPosW\n        miuNeg = sumNeg / sumNegW\n\n        threshold = (miuPos + miuNeg)/2\n\n        minErrRate    = numpy.inf\n        bestDirection = None\n        for direction in [-1, 1]:\n            errorRate = 0.\n\n            self.output[self._mat[d] * direction < threshold * direction]\\\n                    = LABEL_POSITIVE\n\n            self.output[self._mat[d] * direction >= threshold * direction]\\\n                    = LABEL_NEGATIVE\n\n            errorRate = self.weight[ self.output != self._label].sum()\n\n            """"""\n            Code beyond there is just optimal version of this one.\n            ======================================================\n\n            self.output *= 0 # reset the output\n            start = time.time()\n            for i in xrange(self.sampleNum):\n                if self._mat[d][i] *direction < threshold * direction:\n                    self.output[i] = LABEL_POSITIVE\n                else:\n                    self.output[i] = LABEL_NEGATIVE\n\n                if self.output[i] != self._label[i]:\n                    errorRate += self.weight[i]\n            """"""\n\n            self.output *= 0 # reset the output\n            if errorRate < minErrRate:\n                minErrRate    = errorRate\n                bestDirection = direction\n\n        return minErrRate, threshold, bestDirection\n\n    def train(self):\n\n        for dim in xrange(self.sampleDim):\n            err, threshold, direction = self.optimal(dim)\n            if err < self.opt_errorRate:\n                self.opt_errorRate = err\n                self.opt_dimension = dim\n                self.opt_threshold = threshold\n                self.opt_direction = direction\n\n        assert self.opt_errorRate < 0.5\n\n        return self.opt_errorRate\n\n    def prediction(self, Mat):\n        sampleNum = Mat.shape[1]\n\n        dim       = self.opt_dimension\n        threshold = self.opt_threshold\n        direction = self.opt_direction\n\n        output = numpy.zeros(sampleNum, dtype = numpy.int)\n\n        output[Mat[dim] * direction <  direction * threshold] = LABEL_POSITIVE\n        output[Mat[dim] * direction >= direction * threshold] = LABEL_NEGATIVE\n        """"""\n        Optimised for this.\n        ========================================================\n        for i in xrange(sampleNum):\n            if direction * Mat[dim][i] < direction * threshold:\n                output[i] = LABEL_POSITIVE\n            else:\n                output[i] = LABEL_NEGATIVE\n        """"""\n\n        return output\n\n    def show(self, dim = None):\n\n        if dim == None:\n            dim = self.opt_dimension\n\n        N = 10 # the number of center\n        MaxVal = numpy.max(self._mat[dim])\n        MinVal = numpy.min(self._mat[dim])\n\n        scope = (MaxVal - MinVal) / N\n\n        centers = [ (MinVal - scope/2)+ scope*i for i in xrange(N)]\n        counter = [ [0, 0] for i in xrange(N)]\n\n        for j in xrange(N):\n            for i in xrange(self.sampleNum):\n                if abs(self._mat[dim][i] - centers[j]) < scope/2:\n                    if self._label[i] == LABEL_POSITIVE:\n                        counter[j][1] += 1\n                    else:\n                        counter[j][0] += 1\n\n        posVal, negVal = [], []\n\n        for i in xrange(N):\n            posVal.append(counter[i][1])\n            negVal.append(counter[i][0])\n\n        sumPosVal = sum(posVal)\n        sumNegVal = sum(negVal)\n\n        for i in xrange(len(posVal)): posVal[i] /= (1. * sumPosVal)\n        for i in xrange(len(negVal)): negVal[i] /= (1. * sumNegVal)\n\n        pyplot.title(""A simple weak classifier"")\n        pyplot.plot(centers, posVal, ""r-o"", label = ""Face class"")\n        pyplot.plot(centers, negVal, ""b-o"", label = ""Non-Face class"")\n        pyplot.xlabel(""feature response"")\n        pyplot.ylabel(""frequency"")\n\n        # plot threshold line\n        sumPosW = 0.\n        sumNegW = 0.\n        sumPos = 0.\n        sumNeg = 0.\n        for i in xrange(self.sampleNum):\n            if self._label[i] == LABEL_POSITIVE:\n                sumPos  += self.weight[i] * self._mat[dim][i]\n                sumPosW += self.weight[i]\n            else:\n                sumNeg  += self.weight[i] * self._mat[dim][i]\n                sumNegW += self.weight[i]\n                \n        miuPos = sumPos / sumPosW\n        miuNeg = sumNeg / sumNegW\n\n        threshold = (miuPos + miuNeg)/2\n        pyplot.plot([threshold for i in xrange(10)], [i for i in numpy.arange(0.0, 0.5, 0.05)], label = ""threshold"")\n        pyplot.legend()\n        pyplot.show()\n\n    def __str__(self):\n\n        string  = ""opt_errorRate:"" + str(self.opt_errorRate) + ""\\n""\n        string += ""opt_threshold:"" + str(self.opt_threshold) + ""\\n""\n        string += ""opt_dimension:"" + str(self.opt_dimension) + ""\\n""\n        string += ""opt_direction:"" + str(self.opt_direction) + ""\\n""\n        string += ""weights      :"" + str(self.weight)        + ""\\n""\n        return string\n\n    def constructor(self, dimension, direction, threshold):\n        self.opt_dimension = dimension\n        self.opt_threshold = threshold\n        self.opt_direction = direction\n\n        return self\n'"
FaceDetection/Test/testProject.py,0,b'import unittest\n\nfrom matplotlib import image\nfrom matplotlib import pyplot\nimport pylab\n\nclass TestImage(unittest.TestCase):\n    def func():\n        assert False\n        pyplot.matshow(self.image)\n        pylab.show()\n\n    def setUp():\n        assert False\n        self.image = image.imread()\n'
