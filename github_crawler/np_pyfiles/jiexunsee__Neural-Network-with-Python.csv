file_path,api_count,code
3layer.py,0,"b'from numpy import exp, array, random, dot\n\nclass NeuralNetwork():\n\tdef __init__(self):\n\t\trandom.seed(1)\n\n\t\t# setting the number of nodes in layer 2 and layer 3\n\t\t# more nodes --> more confidence in predictions (?)\n\t\tl2 = 5\n\t\tl3 = 4\n\n\t\t# assign random weights to matrices in network\n\t\t# format is (no. of nodes in previous layer) x (no. of nodes in following layer)\n\t\tself.synaptic_weights1 = 2 * random.random((3, l2)) -1\n\t\tself.synaptic_weights2 = 2 * random.random((l2, l3)) -1\n\t\tself.synaptic_weights3 = 2 * random.random((l3, 1)) -1\n\t\t\n\tdef __sigmoid(self, x):\n\t\treturn 1/(1+exp(-x))\n\n\t# derivative of sigmoid function, indicates confidence about existing weight\n\tdef __sigmoid_derivative(self, x):\n\t\treturn x*(1-x)\n\n\t# train neural network, adusting synaptic weights each time\n\tdef train(self, training_set_inputs, training_set_outputs, number_of_training_iterations):\n\t\tfor iteration in xrange(number_of_training_iterations):\n\n\t\t\t# pass training set through our neural network\n\t\t\t# a2 means the activations fed to second layer\n\t\t\ta2 = self.__sigmoid(dot(training_set_inputs, self.synaptic_weights1))\n\t\t\ta3 = self.__sigmoid(dot(a2, self.synaptic_weights2))\n\t\t\toutput = self.__sigmoid(dot(a3, self.synaptic_weights3))\n\n\t\t\t# calculate \'error\'\n\t\t\tdel4 = (training_set_outputs - output)*self.__sigmoid_derivative(output)\n\n\t\t\t# find \'errors\' in each layer\n\t\t\tdel3 = dot(self.synaptic_weights3, del4.T)*(self.__sigmoid_derivative(a3).T)\n\t\t\tdel2 = dot(self.synaptic_weights2, del3)*(self.__sigmoid_derivative(a2).T)\n\n\t\t\t# get adjustments (gradients) for each layer\n\t\t\tadjustment3 = dot(a3.T, del4)\n\t\t\tadjustment2 = dot(a2.T, del3.T)\n\t\t\tadjustment1 = dot(training_set_inputs.T, del2.T)\n\n\t\t\t# adjust weights accordingly\n\t\t\tself.synaptic_weights1 += adjustment1\n\t\t\tself.synaptic_weights2 += adjustment2\n\t\t\tself.synaptic_weights3 += adjustment3\n\n\tdef forward_pass(self, inputs):\n\t\t# pass our inputs through our neural network\n\t\ta2 = self.__sigmoid(dot(inputs, self.synaptic_weights1))\n\t\ta3 = self.__sigmoid(dot(a2, self.synaptic_weights2))\n\t\toutput = self.__sigmoid(dot(a3, self.synaptic_weights3)) \n\t\treturn output\n\nif __name__ == ""__main__"":\n\t# initialise single neuron neural network\n\tneural_network = NeuralNetwork()\n\n\tprint ""Random starting synaptic weights (layer 1): ""\n\tprint neural_network.synaptic_weights1\n\tprint ""\\nRandom starting synaptic weights (layer 2): ""\n\tprint neural_network.synaptic_weights2\n\tprint ""\\nRandom starting synaptic weights (layer 3): ""\n\tprint neural_network.synaptic_weights3\n\n\t# the training set.\n\ttraining_set_inputs = array([[0,0,1],[1,1,1],[1,0,1],[0,1,1]])\n\ttraining_set_outputs = array([[0,1,1,0]]).T\n\n\tneural_network.train(training_set_inputs, training_set_outputs, 10000)\n\n\tprint ""\\nNew synaptic weights (layer 1) after training: ""\n\tprint neural_network.synaptic_weights1\n\tprint ""\\nNew synaptic weights (layer 2) after training: ""\n\tprint neural_network.synaptic_weights2\n\tprint ""\\nNew synaptic weights (layer 3) after training: ""\n\tprint neural_network.synaptic_weights3\n\n\t# test with new input\n\tprint ""\\nConsidering new situation [1,0,0] -> ?""\n\tprint neural_network.forward_pass(array([1,0,0]))\n'"
