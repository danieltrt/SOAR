file_path,api_count,code
utils/bounding_box.py,0,"b'def resizeBoundingBox(image_dimens, bbox, percentage = 0.05):\n  if percentage < .01 or percentage > 1. : raise Exception(""Percentage not allowed. Range [0.01 - 1]"")\n  x, y, w, h = bbox\n  image_width, image_height = image_dimens\n  total_width,total_height = (x+w, y+h)\n  \n  paddingWidth = int(total_width * percentage)\n  paddingHeight = int(total_height * percentage)\n  \n  new_x = 0 if(x-paddingWidth < 0) else x - paddingWidth\n  new_y = 0 if(y-paddingHeight < 0) else y - paddingHeight\n  \n  new_w = new_x + w + (paddingWidth * 2)\n  new_h = new_y + h + (paddingHeight * 2)\n\n  new_w = image_width if(new_w > image_width) else w + (paddingWidth * 2)\n  new_h = image_height if(new_h > image_height) else h + (paddingHeight * 2)\n\n  return new_x, new_y, new_w, new_h'"
utils/detect_faces.py,1,"b'import numpy as np\nimport cv2\nfrom utils.bounding_box import resizeBoundingBox\nfrom utils.predictor_keras import predict\nfrom utils.predictor_pytorch import model_predict\n\ndef detect_faces(img, face_model, confidence=0.5, target_size=(160, 160), enable_generator=False):\n    faces = face_model.detect_faces(img)\n    img_color = img.copy()\n    index = 1\n    for face in faces:\n        bbox = face[\'box\']\n        cnf = face[\'confidence\']\n        if cnf >= confidence:\n            x,y,w,h = bbox\n            img_face_slice = img[y:(y + h),x:(x + w), :]\n            img_resize = cv2.resize(img_face_slice, target_size, cv2.INTER_AREA)      \n            cv2.rectangle(img_color, (x, y), (x + w, y + h), (0,255,0), 3)\n            if (enable_generator):\n                cv2.imwrite(f\'face_{str(index)}.jpg\', img_resize[:,:,::-1])\n                index = index + 1\n    return img_color\n\n\ndef detect_faces_with_mask(img, face_model, mask_model, classes=[\'no_mask\', \'mask\'], confidence=0.5, bbox_percentage=0.1, predictor=\'keras\', target_size=(160,160)):\n    if predictor != \'keras\' and predictor != \'torch\': raise Exception(\'Predictor must be keras or torch\')\n    \n    faces = face_model.detect_faces(img)\n    img_color = img.copy()\n    for face in faces:\n        bbox = face[\'box\']\n        cnf = face[\'confidence\']\n        if cnf >= confidence:\n            x, y, w, h = resizeBoundingBox((img.shape[1], img.shape[0]), bbox, bbox_percentage)\n            img_face_slice = img[y:(y + h),x:(x + w), :]\n            img_resize = cv2.resize(img_face_slice, target_size, cv2.INTER_AREA)\n            pred,_ = predict(mask_model, classes, np.expand_dims(img_resize[:,:,::-1], axis = 0)) if predictor == \'keras\' else model_predict(mask_model, img_resize, classes)\n            color = (0,255, 0) if pred == \'mask\' else (255,0,0)\n            cv2.rectangle(img_color, (x, y), (x + w, y + h), color, 3)\n            cv2.putText(img_color, pred.replace(""_"", "" "").capitalize(), (x-2, y-7), cv2.FONT_HERSHEY_SIMPLEX, .9, color, 2)\n    return img_color\n'"
utils/predictor_keras.py,0,"b'def predict(model, classes, image):\n    prob = model.predict(image)\n    pred = 0 if prob[0] < 0.5 else 1\n    return (classes[pred], prob)'"
utils/predictor_pytorch.py,0,"b'## Import needed packages\nimport torch\nimport numpy as np\nfrom torch.autograd import Variable\nfrom torchvision import transforms\nfrom PIL import Image\n\ndef model_predict(model, image, classes = None):\n\n    image = Image.fromarray(image) # eliminar en caso el input sea del tipo PIL.Image\n    \n    data_transforms = transforms.Compose([\n    transforms.Resize(160),\n    transforms.CenterCrop(160), \n    transforms.ToTensor(),\n    transforms.Normalize([0.5737, 0.4802, 0.4410],[0.2369, 0.2243, 0.2235])])\n\n    use_gpu = torch.cuda.is_available()\n    device = torch.device(""cuda:0"" if use_gpu else ""cpu"")   \n\n    model.eval() \n\n    imgblob = data_transforms(image)\n    imgblob.unsqueeze_(dim=0)\n    imgblob = Variable(imgblob)\n    torch.no_grad()\n\n    imgblob = imgblob.to(device)\n\n    output = model(imgblob)\n    prob, pred = torch.max(output, 1)\n\n    if classes is None:\n        return(int(pred),float(prob))\n    else:\n        return(classes[int(pred)],float(prob))\n\n'"
