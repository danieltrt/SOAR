file_path,api_count,code
fourier_transform.py,7,"b'\nimport numpy as np\n\ndef fourier_transform(signal, N, T):\n    """"""Function for computing the Fourier ransform of <signal>\n    consisting of <N> data points and and upper sample time <T>""""""\n    N_half = int(round(N/2))\n\n    A = np.zeros(N_half)\n    B = np.zeros(N_half)\n    A[0] = signal.mean()\n\n    q = np.arange(1, N+1)\n\n    for n in range(1, N_half):\n        A[n-1] = np.sum(2/N*signal*np.cos((2*np.pi*q*n)/N))\n        B[n-1] = np.sum(2/N*signal*np.sin((2*np.pi*q*n)/N))\n\n    A[N_half-1] = np.sum(1/N*signal*np.cos(np.pi*q))\n    B[N_half-1] = 0\n\n    freq = np.zeros(N_half)\n\n    for n in range(1, N_half+1):\n        freq[n-1] = n/T\n\n    E = A**2 + B**2\n\n    return freq, E'"
swe.py,38,"b'\n""""""Script that solves that solves the 2D shallow water equations using finite\ndifferences where the momentum equations are taken to be linear, but the\ncontinuity equation is solved in its nonlinear form. The model supports turning\non/off various terms, but in its mst complete form, the model solves the following\nset of eqations:\n\n    du/dt - fv = -g*d(eta)/dx + tau_x/(rho_0*H)- kappa*u\n    dv/dt + fu = -g*d(eta)/dy + tau_y/(rho_0*H)- kappa*v\n    d(eta)/dt + d((eta + H)*u)/dx + d((eta + H)*u)/dy = sigma - w\n\nwhere f = f_0 + beta*y can be the full latitude varying coriolis parameter.\nFor the momentum equations, an ordinary forward-in-time centered-in-space\nscheme is used. However, the coriolis terms is not so trivial, and thus, one\nfirst finds a predictor for u, v and then a corrected value is computed in\norder to include the coriolis terms. In the continuity equation, it\'s used a\nforward difference for the time derivative and an upwind scheme for the non-\nlinear terms. The model is stable under the CFL condition of\n\n    dt <= min(dx, dy)/sqrt(g*H)    and    alpha << 1 (if coriolis is used)\n\nwhere dx, dy is the grid spacing in the x- and y-direction respectively, g is\nthe acceleration of gravity and H is the resting depth of the fluid.""""""\n\nimport time\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport viz_tools\n\n# ==================================================================================\n# ================================ Parameter stuff =================================\n# ==================================================================================\n# --------------- Physical prameters ---------------\nL_x = 1E+6              # Length of domain in x-direction\nL_y = 1E+6              # Length of domain in y-direction\ng = 9.81                 # Acceleration of gravity [m/s^2]\nH = 100                # Depth of fluid [m]\nf_0 = 1E-4              # Fixed part ofcoriolis parameter [1/s]\nbeta = 2E-11            # gradient of coriolis parameter [1/ms]\nrho_0 = 1024.0          # Density of fluid [kg/m^3)]\ntau_0 = 0.1             # Amplitude of wind stress [kg/ms^2]\nuse_coriolis = True     # True if you want coriolis force\nuse_friction = False     # True if you want bottom friction\nuse_wind = False        # True if you want wind stress\nuse_beta = True         # True if you want variation in coriolis\nuse_source = False       # True if you want mass source into the domain\nuse_sink = False       # True if you want mass sink out of the domain\nparam_string = ""\\n================================================================""\nparam_string += ""\\nuse_coriolis = {}\\nuse_beta = {}"".format(use_coriolis, use_beta)\nparam_string += ""\\nuse_friction = {}\\nuse_wind = {}"".format(use_friction, use_wind)\nparam_string += ""\\nuse_source = {}\\nuse_sink = {}"".format(use_source, use_sink)\nparam_string += ""\\ng = {:g}\\nH = {:g}"".format(g, H)\n\n# --------------- Computational prameters ---------------\nN_x = 150                            # Number of grid points in x-direction\nN_y = 150                            # Number of grid points in y-direction\ndx = L_x/(N_x - 1)                   # Grid spacing in x-direction\ndy = L_y/(N_y - 1)                   # Grid spacing in y-direction\ndt = 0.1*min(dx, dy)/np.sqrt(g*H)    # Time step (defined from the CFL condition)\ntime_step = 1                        # For counting time loop steps\nmax_time_step = 5000                 # Total number of time steps in simulation\nx = np.linspace(-L_x/2, L_x/2, N_x)  # Array with x-points\ny = np.linspace(-L_y/2, L_y/2, N_y)  # Array with y-points\nX, Y = np.meshgrid(x, y)             # Meshgrid for plotting\nX = np.transpose(X)                  # To get plots right\nY = np.transpose(Y)                  # To get plots right\nparam_string += ""\\ndx = {:.2f} km\\ndy = {:.2f} km\\ndt = {:.2f} s"".format(dx, dy, dt)\n\n# Define friction array if friction is enabled.\nif (use_friction is True):\n    kappa_0 = 1/(5*24*3600)\n    kappa = np.ones((N_x, N_y))*kappa_0\n    #kappa[0, :] = kappa_0\n    #kappa[-1, :] = kappa_0\n    #kappa[:, 0] = kappa_0\n    #kappa[:, -1] = kappa_0\n    #kappa[:int(N_x/15), :] = 0\n    #kappa[int(14*N_x/15)+1:, :] = 0\n    #kappa[:, :int(N_y/15)] = 0\n    #kappa[:, int(14*N_y/15)+1:] = 0\n    #kappa[int(N_x/15):int(2*N_x/15), int(N_y/15):int(14*N_y/15)+1] = 0\n    #kappa[int(N_x/15):int(14*N_x/15)+1, int(N_y/15):int(2*N_y/15)] = 0\n    #kappa[int(13*N_x/15)+1:int(14*N_x/15)+1, int(N_y/15):int(14*N_y/15)+1] = 0\n    #kappa[int(N_x/15):int(14*N_x/15)+1, int(13*N_y/15)+1:int(14*N_y/15)+1] = 0\n    param_string += ""\\nkappa = {:g}\\nkappa/beta = {:g} km"".format(kappa_0, kappa_0/(beta*1000))\n\n# Define wind stress arrays if wind is enabled.\nif (use_wind is True):\n    tau_x = -tau_0*np.cos(np.pi*y/L_y)*0\n    tau_y = np.zeros((1, len(x)))\n    param_string += ""\\ntau_0 = {:g}\\nrho_0 = {:g} km"".format(tau_0, rho_0)\n\n# Define coriolis array if coriolis is enabled.\nif (use_coriolis is True):\n    if (use_beta is True):\n        f = f_0 + beta*y        # Varying coriolis parameter\n        L_R = np.sqrt(g*H)/f_0  # Rossby deformation radius\n        c_R = beta*g*H/f_0**2   # Long Rossby wave speed\n    else:\n        f = f_0*np.ones(len(y))                 # Constant coriolis parameter\n\n    alpha = dt*f                # Parameter needed for coriolis scheme\n    beta_c = alpha**2/4         # Parameter needed for coriolis scheme\n\n    param_string += ""\\nf_0 = {:g}"".format(f_0)\n    param_string += ""\\nMax alpha = {:g}\\n"".format(alpha.max())\n    param_string += ""\\nRossby radius: {:.1f} km"".format(L_R/1000)\n    param_string += ""\\nRossby number: {:g}"".format(np.sqrt(g*H)/(f_0*L_x))\n    param_string += ""\\nLong Rossby wave speed: {:.3f} m/s"".format(c_R)\n    param_string += ""\\nLong Rossby transit time: {:.2f} days"".format(L_x/(c_R*24*3600))\n    param_string += ""\\n================================================================\\n""\n\n# Define source array if source is enabled.\nif (use_source):\n    sigma = np.zeros((N_x, N_y))\n    sigma = 0.0001*np.exp(-((X-L_x/2)**2/(2*(1E+5)**2) + (Y-L_y/2)**2/(2*(1E+5)**2)))\n    \n# Define source array if source is enabled.\nif (use_sink is True):\n    w = np.ones((N_x, N_y))*sigma.sum()/(N_x*N_y)\n\n# Write all parameters out to file.\nwith open(""param_output.txt"", ""w"") as output_file:\n    output_file.write(param_string)\n\nprint(param_string)     # Also print parameters to screen\n# ============================= Parameter stuff done ===============================\n\n# ==================================================================================\n# ==================== Allocating arrays and initial conditions ====================\n# ==================================================================================\nu_n = np.zeros((N_x, N_y))      # To hold u at current time step\nu_np1 = np.zeros((N_x, N_y))    # To hold u at next time step\nv_n = np.zeros((N_x, N_y))      # To hold v at current time step\nv_np1 = np.zeros((N_x, N_y))    # To hold v at enxt time step\neta_n = np.zeros((N_x, N_y))    # To hold eta at current time step\neta_np1 = np.zeros((N_x, N_y))  # To hold eta at next time step\n\n# Temporary variables (each time step) for upwind scheme in eta equation\nh_e = np.zeros((N_x, N_y))\nh_w = np.zeros((N_x, N_y))\nh_n = np.zeros((N_x, N_y))\nh_s = np.zeros((N_x, N_y))\nuhwe = np.zeros((N_x, N_y))\nvhns = np.zeros((N_x, N_y))\n\n# Initial conditions for u and v.\nu_n[:, :] = 0.0             # Initial condition for u\nv_n[:, :] = 0.0             # Initial condition for u\nu_n[-1, :] = 0.0            # Ensuring initial u satisfy BC\nv_n[:, -1] = 0.0            # Ensuring initial v satisfy BC\n\n# Initial condition for eta.\n#eta_n[:, :] = np.sin(4*np.pi*X/L_y) + np.sin(4*np.pi*Y/L_y)\n#eta_n = np.exp(-((X-0)**2/(2*(L_R)**2) + (Y-0)**2/(2*(L_R)**2)))\neta_n = np.exp(-((X-L_x/2.7)**2/(2*(0.05E+6)**2) + (Y-L_y/4)**2/(2*(0.05E+6)**2)))\n#eta_n[int(3*N_x/8):int(5*N_x/8),int(3*N_y/8):int(5*N_y/8)] = 1.0\n#eta_n[int(6*N_x/8):int(7*N_x/8),int(6*N_y/8):int(7*N_y/8)] = 1.0\n#eta_n[int(3*N_x/8):int(5*N_x/8), int(13*N_y/14):] = 1.0\n#eta_n[:, :] = 0.0\n\n#viz_tools.surface_plot3D(X, Y, eta_n, (X.min(), X.max()), (Y.min(), Y.max()), (eta_n.min(), eta_n.max()))\n\n# Sampling variables.\neta_list = list(); u_list = list(); v_list = list()         # Lists to contain eta and u,v for animation\nhm_sample = list(); ts_sample = list(); t_sample = list()   # Lists for Hovmuller and time series\nhm_sample.append(eta_n[:, int(N_y/2)])                      # Sample initial eta in middle of domain\nts_sample.append(eta_n[int(N_x/2), int(N_y/2)])             # Sample initial eta at center of domain\nt_sample.append(0.0)                                        # Add initial time to t-samples\nanim_interval = 20                                         # How often to sample for time series\nsample_interval = 1000                                      # How often to sample for time series\n# =============== Done with setting up arrays and initial conditions ===============\n\nt_0 = time.clock()  # For timing the computation loop\n\n# ==================================================================================\n# ========================= Main time loop for simulation ==========================\n# ==================================================================================\nwhile (time_step < max_time_step):\n    # ------------ Computing values for u and v at next time step --------------\n    u_np1[:-1, :] = u_n[:-1, :] - g*dt/dx*(eta_n[1:, :] - eta_n[:-1, :])\n    v_np1[:, :-1] = v_n[:, :-1] - g*dt/dy*(eta_n[:, 1:] - eta_n[:, :-1])\n\n    # Add friction if enabled.\n    if (use_friction is True):\n        u_np1[:-1, :] -= dt*kappa[:-1, :]*u_n[:-1, :]\n        v_np1[:-1, :] -= dt*kappa[:-1, :]*v_n[:-1, :]\n\n    # Add wind stress if enabled.\n    if (use_wind is True):\n        u_np1[:-1, :] += dt*tau_x[:]/(rho_0*H)\n        v_np1[:-1, :] += dt*tau_y[:]/(rho_0*H)\n\n    # Use a corrector method to add coriolis if it\'s enabled.\n    if (use_coriolis is True):\n        u_np1[:, :] = (u_np1[:, :] - beta_c*u_n[:, :] + alpha*v_n[:, :])/(1 + beta_c)\n        v_np1[:, :] = (v_np1[:, :] - beta_c*v_n[:, :] - alpha*u_n[:, :])/(1 + beta_c)\n    \n    v_np1[:, -1] = 0.0      # Northern boundary condition\n    u_np1[-1, :] = 0.0      # Eastern boundary condition\n    # -------------------------- Done with u and v -----------------------------\n\n    # --- Computing arrays needed for the upwind scheme in the eta equation.----\n    h_e[:-1, :] = np.where(u_np1[:-1, :] > 0, eta_n[:-1, :] + H, eta_n[1:, :] + H)\n    h_e[-1, :] = eta_n[-1, :] + H\n\n    h_w[0, :] = eta_n[0, :] + H\n    h_w[1:, :] = np.where(u_np1[:-1, :] > 0, eta_n[:-1, :] + H, eta_n[1:, :] + H)\n\n    h_n[:, :-1] = np.where(v_np1[:, :-1] > 0, eta_n[:, :-1] + H, eta_n[:, 1:] + H)\n    h_n[:, -1] = eta_n[:, -1] + H\n\n    h_s[:, 0] = eta_n[:, 0] + H\n    h_s[:, 1:] = np.where(v_np1[:, :-1] > 0, eta_n[:, :-1] + H, eta_n[:, 1:] + H)\n\n    uhwe[0, :] = u_np1[0, :]*h_e[0, :]\n    uhwe[1:, :] = u_np1[1:, :]*h_e[1:, :] - u_np1[:-1, :]*h_w[1:, :]\n\n    vhns[:, 0] = v_np1[:, 0]*h_n[:, 0]\n    vhns[:, 1:] = v_np1[:, 1:]*h_n[:, 1:] - v_np1[:, :-1]*h_s[:, 1:]\n    # ------------------------- Upwind computations done -------------------------\n\n    # ----------------- Computing eta values at next time step -------------------\n    eta_np1[:, :] = eta_n[:, :] - dt*(uhwe[:, :]/dx + vhns[:, :]/dy)    # Without source/sink\n\n    # Add source term if enabled.\n    if (use_source is True):\n        eta_np1[:, :] += dt*sigma\n\n    # Add sink term if enabled.\n    if (use_sink is True):\n        eta_np1[:, :] -= dt*w\n    # ----------------------------- Done with eta --------------------------------\n\n    u_n = np.copy(u_np1)        # Update u for next iteration\n    v_n = np.copy(v_np1)        # Update v for next iteration\n    eta_n = np.copy(eta_np1)    # Update eta for next iteration\n\n    time_step += 1\n\n    # Samples for Hovmuller diagram and spectrum every sample_interval time step.\n    if (time_step % sample_interval == 0):\n        hm_sample.append(eta_n[:, int(N_y/2)])              # Sample middle of domain for Hovmuller\n        ts_sample.append(eta_n[int(N_x/2), int(N_y/2)])     # Sample center point for spectrum\n        t_sample.append(time_step*dt)                       # Keep track of sample times.\n\n    # Store eta and (u, v) every anin_interval time step for animations.\n    if (time_step % anim_interval == 0):\n        print(""Time: \\t{:.2f} hours"".format(time_step*dt/3600))\n        print(""Step: \\t{} / {}"".format(time_step, max_time_step))\n        print(""Mass: \\t{}\\n"".format(np.sum(eta_n)))\n        u_list.append(u_n)\n        v_list.append(v_n)\n        eta_list.append(eta_n)\n\n# ============================= Main time loop done ================================\nprint(""Main computation loop done!\\nExecution time: {:.2f} s"".format(time.clock() - t_0))\nprint(""\\nVisualizing results..."")\n\n# ==================================================================================\n# ================== Visualizing results by call to external file ==================\n# ==================================================================================\n#viz_tools.pmesh_plot(X, Y, eta_n, ""Final state of surface elevation $\\eta$"")\n#viz_tools.quiver_plot(X, Y, u_n, v_n, ""Final state of velocity field $\\mathbf{u}(x,y)$"")\n#viz_tools.hovmuller_plot(x, t_sample, hm_sample)\n#viz_tools.plot_time_series_and_ft(t_sample, ts_sample)\neta_anim = viz_tools.eta_animation(X, Y, eta_list, anim_interval*dt, ""eta"")\n#eta_surf_anim = viz_tools.eta_animation3D(X, Y, eta_list, anim_interval*dt, ""eta_surface"")\nquiv_anim = viz_tools.velocity_animation(X, Y, u_list, v_list, anim_interval*dt, ""velocity"")\n# ============================ Done with visualization =============================\n\nprint(""\\nVisualization done!"")\nplt.show()\n'"
viz_tools.py,9,"b'\n""""""File with several visualization functions intended to use\nwith results from 2D shallow water model swe2D.py""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom mpl_toolkits.mplot3d import Axes3D\nimport fourier_transform as ft\n\n#plt.style.use(""seaborn"")\n\ndef eta_animation(X, Y, eta_list, frame_interval, filename):\n    """"""Function that takes in the domain x, y (2D meshgrids) and a list of 2D arrays\n    eta_list and creates an animation of all eta images. To get updating title one\n    also need specify time step dt between each frame in the simulation, the number\n    of time steps between each eta in eta_list and finally, a filename for video.""""""\n    fig, ax = plt.subplots(1, 1)\n    #plt.title(""Velocity field $\\mathbf{u}(x,y)$ after 0.0 days"", fontname = ""serif"", fontsize = 17)\n    plt.xlabel(""x [m]"", fontname = ""serif"", fontsize = 12)\n    plt.ylabel(""y [m]"", fontname = ""serif"", fontsize = 12)\n    pmesh = plt.pcolormesh(X, Y, eta_list[0], vmin = -0.7*np.abs(eta_list[int(len(eta_list)/2)]).max(),\n        vmax = np.abs(eta_list[int(len(eta_list)/2)]).max(), cmap = plt.cm.RdBu_r)\n    plt.colorbar(pmesh, orientation = ""vertical"")\n\n    # Update function for quiver animation.\n    def update_eta(num):\n        ax.set_title(""Surface elevation $\\eta$ after t = {:.2f} hours"".format(\n            num*frame_interval/3600), fontname = ""serif"", fontsize = 16)\n        pmesh.set_array(eta_list[num][:-1, :-1].flatten())\n        return pmesh,\n\n    anim = animation.FuncAnimation(fig, update_eta,\n        frames = len(eta_list), interval = 10, blit = False)\n    mpeg_writer = animation.FFMpegWriter(fps = 24, bitrate = 10000,\n        codec = ""libx264"", extra_args = [""-pix_fmt"", ""yuv420p""])\n    anim.save(""{}.mp4"".format(filename), writer = mpeg_writer)\n    return anim    # Need to return anim object to see the animation\n\ndef velocity_animation(X, Y, u_list, v_list, frame_interval, filename):\n    """"""Function that takes in the domain x, y (2D meshgrids) and a lists of 2D arrays\n    u_list, v_list and creates an quiver animation of the velocity field (u, v). To get\n    updating title one also need specify time step dt between each frame in the simulation,\n    the number of time steps between each eta in eta_list and finally, a filename for video.""""""\n    fig, ax = plt.subplots(figsize = (8, 8), facecolor = ""white"")\n    plt.title(""Velocity field $\\mathbf{u}(x,y)$ after 0.0 days"", fontname = ""serif"", fontsize = 19)\n    plt.xlabel(""x [km]"", fontname = ""serif"", fontsize = 16)\n    plt.ylabel(""y [km]"", fontname = ""serif"", fontsize = 16)\n    q_int = 3\n    Q = ax.quiver(X[::q_int, ::q_int]/1000.0, Y[::q_int, ::q_int]/1000.0, u_list[0][::q_int,::q_int], v_list[0][::q_int,::q_int],\n        scale=0.2, scale_units=\'inches\')\n    #qk = plt.quiverkey(Q, 0.9, 0.9, 0.001, ""0.1 m/s"", labelpos = ""E"", coordinates = ""figure"")\n\n    # Update function for quiver animation.\n    def update_quiver(num):\n        u = u_list[num]\n        v = v_list[num]\n        ax.set_title(""Velocity field $\\mathbf{{u}}(x,y,t)$ after t = {:.2f} hours"".format(\n            num*frame_interval/3600), fontname = ""serif"", fontsize = 19)\n        Q.set_UVC(u[::q_int, ::q_int], v[::q_int, ::q_int])\n        return Q,\n\n    anim = animation.FuncAnimation(fig, update_quiver,\n        frames = len(u_list), interval = 10, blit = False)\n    mpeg_writer = animation.FFMpegWriter(fps = 24, bitrate = 10000,\n        codec = ""libx264"", extra_args = [""-pix_fmt"", ""yuv420p""])\n    fig.tight_layout()\n    anim.save(""{}.mp4"".format(filename), writer = mpeg_writer)\n    return anim    # Need to return anim object to see the animation\n\ndef eta_animation3D(X, Y, eta_list, frame_interval, filename):\n    fig = plt.figure(figsize = (8, 8), facecolor = ""white"")\n    ax = fig.add_subplot(111, projection=\'3d\')\n\n    surf = ax.plot_surface(X, Y, eta_list[0], cmap = plt.cm.RdBu_r)\n\n    def update_surf(num):\n        ax.clear()\n        surf = ax.plot_surface(X/1000, Y/1000, eta_list[num], cmap = plt.cm.RdBu_r)\n        ax.set_title(""Surface elevation $\\eta(x,y,t)$ after $t={:.2f}$ hours"".format(\n            num*frame_interval/3600), fontname = ""serif"", fontsize = 19, y=1.04)\n        ax.set_xlabel(""x [km]"", fontname = ""serif"", fontsize = 14)\n        ax.set_ylabel(""y [km]"", fontname = ""serif"", fontsize = 14)\n        ax.set_zlabel(""$\\eta$ [m]"", fontname = ""serif"", fontsize = 16)\n        ax.set_xlim(X.min()/1000, X.max()/1000)\n        ax.set_ylim(Y.min()/1000, Y.max()/1000)\n        ax.set_zlim(-0.3, 0.7)\n        plt.tight_layout()\n        return surf,\n\n    anim = animation.FuncAnimation(fig, update_surf,\n        frames = len(eta_list), interval = 10, blit = False)\n    mpeg_writer = animation.FFMpegWriter(fps = 24, bitrate = 10000,\n        codec = ""libx264"", extra_args = [""-pix_fmt"", ""yuv420p""])\n    anim.save(""{}.mp4"".format(filename), writer = mpeg_writer)\n    return anim    # Need to return anim object to see the animation\n\ndef surface_plot3D(X, Y, eta, x_lim, y_lim, z_lim):\n    """"""Function that takes input 1D coordinate arrays x, y and 2D array\n    array psi. Then plots psi as a surface in 3D space on a meshgrid.""""""\n    fig = plt.figure(figsize = (11, 7))\n    ax = Axes3D(fig)\n    surf = ax.plot_surface(X, Y, eta, rstride = 1, cstride = 1,\n        cmap = plt.cm.jet, linewidth = 0, antialiased = True)\n    ax.set_xlim(*x_lim)\n    ax.set_ylim(*y_lim)\n    ax.set_zlim(*z_lim)\n    ax.set_title(""Surface elevation $\\eta$"", fontname = ""serif"", fontsize = 17)\n    ax.set_xlabel(""x [m]"", fontname = ""serif"", fontsize = 16)\n    ax.set_ylabel(""y [m]"", fontname = ""serif"", fontsize = 16)\n    ax.set_zlabel(""Surface elevation [m]"", fontname = ""serif"", fontsize = 16)\n    plt.show()\n\ndef pmesh_plot(X, Y, eta, plot_title):\n    """"""Function that generates a colored contour plot of eta in the domain X, Y""""""\n    plt.figure(figsize = (9, 8))\n    plt.pcolormesh(X, Y, eta, cmap = plt.cm.RdBu_r)\n    plt.colorbar(orientation = ""vertical"")\n    plt.title(plot_title, fontname = ""serif"", fontsize = 17)\n    plt.xlabel(""x [m]"", fontname = ""serif"", fontsize = 12)\n    plt.ylabel(""y [s]"", fontname = ""serif"", fontsize = 12)\n\ndef quiver_plot(X, Y, U, V, plot_title):\n    """"""Function that makes a quiver plot of (U, V) at points (X, Y).""""""\n    plt.figure()\n    plt.title(plot_title, fontname = ""serif"", fontsize = 17)\n    plt.xlabel(""x [m]"", fontname = ""serif"", fontsize = 12)\n    plt.ylabel(""y [m]"", fontname = ""serif"", fontsize = 12)\n    Q = plt.quiver(X[::4, ::4], Y[::4, ::4], U[::4, ::4], V[::4, ::4],\n        units = ""xy"", scale = 0.002, scale_units = ""inches"")\n    qk = plt.quiverkey(Q, 0.9, 0.9, 0.001, ""0.1 m/s"",\n        labelpos = ""E"", coordinates = ""figure"")\n\ndef hovmuller_plot(x, t, eta):\n    """"""Function that generates a Hovmuller diagram of\n    eta as a function of x and t at a choosen y-coordinate""""""\n    X, T = np.meshgrid(x, np.array(t))\n    X = np.transpose(X)         # Transpose for plotting\n    T = np.transpose(T)         # Transpose for plotting\n    eta_hm = np.transpose(np.array(eta))  # Transpose for plotting\n\n    plt.figure(figsize = (5, 8))\n    plt.pcolormesh(X, T, eta_hm, vmin = eta_hm.min(), vmax = eta_hm.max(), cmap = plt.cm.PiYG)\n    plt.colorbar(orientation = ""vertical"")\n    plt.title(""x-t plot for middle of domain"", fontname = ""serif"", fontsize = 17)\n    plt.xlabel(""x [m]"", fontname = ""serif"", fontsize = 12)\n    plt.ylabel(""t [s]"", fontname = ""serif"", fontsize = 12)\n\ndef plot_time_series_and_ft(t, signal):\n    """"""Function that takes a signal and its corresponding time array.\n    Then plots the time signal as well as its Fourier transform.""""""\n    t = np.array(t)\n    signal = np.array(signal)\n\n    # Plotting the time series.\n    plt.figure(figsize = (8, 7))\n    plt.subplot(2, 1, 1)\n    plt.plot(t, signal, linewidth = 2)\n    plt.title(""Time series of $\\eta$ at center of domain"", fontname = ""serif"", fontsize = 17)\n    plt.xlabel(""t [s]"", fontname = ""serif"", fontsize = 12)\n    plt.ylabel(""$\\eta$ [m]"", fontname = ""serif"", fontsize = 12)\n\n    # Plotting the Fourier transform of the time series (calling homemade ft).\n    freq, spectrum = ft.fourier_transform(signal, len(signal), len(signal)*np.diff(t)[1])\n    plt.subplot(2, 1, 2)\n    plt.plot(freq, spectrum, linewidth = 2)\n    plt.title(""Fourier transformed signal"", fontname = ""serif"", fontsize = 17)\n    plt.xlabel(""Frequency [Hz]"", fontname = ""serif"", fontsize = 12)\n    plt.ylabel(""Amplitude"", fontname = ""serif"", fontsize = 12)\n    plt.tight_layout()'"
