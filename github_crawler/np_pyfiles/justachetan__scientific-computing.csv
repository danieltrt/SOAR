file_path,api_count,code
a1/problem_3a.py,4,"b'\n\nfrom __future__ import division\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\nimport numpy.linalg as npla\nimport scipy.linalg as spla\nimport scipy.special\nimport pandas as pd\n\n\n# # Part (a)\n\n# Code might send out RunTime warnings. These are benign, caused due to Python 2.7.\n# Can verify here: https://stackoverflow.com/questions/40845304/runtimewarning-numpy-dtype-size-changed-may-indicate-binary-incompatibility\n\n\ndef get_approx_jv(n, z):\n    \n    # returns approximate value of J_{n+1}\n    \n    if (n < 1).any() == True:\n        return ValueError\n    \n    return ( ( ( ( 2 * n ) / z ) * scipy.special.jv(n, z) ) - scipy.special.jv(n - 1, z) )\n\n\n\n\n\nz = 20\n\n\n\ntrue_jv = scipy.special.jv(np.arange(2, 51), z)\napprox_jv = get_approx_jv(np.arange(1, 50), z)\n\n\n\n\n\n# I have printed the magnitude of the Relative Error\n\nrelative_err = (approx_jv - true_jv) / true_jv\nrelative_err = np.abs(relative_err)\n\n\n\n\n\ndf = pd.DataFrame({""n"" : [i for i in range(2, 51)], ""LHS"" : true_jv, ""RHS"" : approx_jv, ""Relative Error"" : relative_err}, columns=[""n"", ""LHS"", ""RHS"", ""Relative Error""])\nprint(df.to_string(index_names=False))\n\n\n\n\n\n\n\n\n\nplt.xlabel(""Value of n"")\nplt.ylabel(""Absolute Value of Relative Error"")\nplt.title(""Problem 3(a)"")\nplt.plot( np.arange(2, 51), relative_err)\nplt.savefig(""problem_3a.png"")\n\n# Uncomment to see figures\nplt.show()\n\n'"
a1/problem_3b.py,1,"b'\n\nfrom __future__ import division\nimport pandas as pd\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\nimport numpy.linalg as npla\nimport scipy.linalg as spla\nimport scipy.special\n\n\n\n# Code may print some warnings due to pandas in Python2. \n# These warning are benign. Verigy here: https://stackoverflow.com/questions/40845304/runtimewarning-numpy-dtype-size-changed-may-indicate-binary-incompatibility\n\n\n\nz = 20\n\n\n\n\nJ_0 = scipy.special.jv(0, z)\nJ_1 = scipy.special.jv(1, z)\n\n\n\n\n\nbessel_val_by_rec = [J_0, J_1]\n\n\n\n\n\nfor i in range(2, 51):\n    \n    J_i = ( ( ( ( 2 * ( i - 1 ) ) / z ) * bessel_val_by_rec[i - 1] ) - bessel_val_by_rec[i - 2] )\n\n    bessel_val_by_rec.append(J_i)\n\n\n\n\n\nbessel_val_by_func = [scipy.special.jv(i, z) for i in range(0, 51)]\n\n\n\n\n\nrelative_err = []\nfor i in range(2, 51):\n    relative_err.append((bessel_val_by_rec[i] - bessel_val_by_func[i])/bessel_val_by_func[i])\n\n# Again, just printing magnitude of the Relative Error\n# Comment this value to print just the ratio\nrelative_err = [abs(i) for i in relative_err]\n\n\n\n\n\ndf = pd.DataFrame({""n"" : [i for i in range(2, 51)], ""From Function"" : bessel_val_by_func[2:], ""From Recurrence"" : bessel_val_by_rec[2:], ""Relative Error"" : relative_err}, columns=[""n"", ""From Function"", ""From Recurrence"", ""Relative Error""])\nprint(df.to_string(index_names=False))\n\n\n\n\n\n\n\nplt.xlabel(""Value of n"")\nplt.ylabel(""Absolute Value of Relative Error"")\nplt.plot( np.arange(2, 51), relative_err)\nplt.savefig(""problem_3b.png"")\n# Uncomment to show plot\n# plt.show()\n\n'"
a1/problem_3d.py,1,"b'\n\nfrom __future__ import division\nimport pandas as pd\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\nimport numpy.linalg as npla\nimport scipy.linalg as spla\nimport scipy.special\n\n\n\n\n# Code may print some warnings due to pandas in Pyton 2.7\n# It can be run in Python3 as well. The warnings are completely benign.\n\n\n\nz = 20\n\n\n\n\n\nJ_50 = scipy.special.jv(50, z)\nJ_49 = scipy.special.jv(49, z)\n\n\n\n\n\nbessel_val_by_rec = [J_50, J_49]\n\n\n\n\n\nfor i in range(48, -1, -1):\n    \n    J_i = ( ( ( ( 2 * ( i + 1 ) ) / z ) * bessel_val_by_rec[50 - i - 1] ) - bessel_val_by_rec[50 - i - 2] )\n\n    bessel_val_by_rec.append(J_i)\n\n\n\n\n\nbessel_val_by_func = [scipy.special.jv(i, z) for i in range(50, -1, -1)]\n\n\n\n\n\nrelative_err = []\nfor i in range(2, 51):\n    relative_err.append((bessel_val_by_rec[i] - bessel_val_by_func[i])/bessel_val_by_func[i])\n\n# Again, I am just printing magnitude of the Relative Error\n# Comment this line to print just the ratio\nrelative_err = [abs(i) for i in relative_err]\n\n\n\n\n\ndf = pd.DataFrame({""n"" : [i for i in range(2, 51)], ""From Function"" : bessel_val_by_func[2:], ""From Recurrence"" : bessel_val_by_rec[2:], ""Relative Error"" : relative_err}, columns=[""n"", ""From Function"", ""From Recurrence"", ""Relative Error""])\nprint(df.to_string(index_names=False))\n\n\n\n\n\n\n\nplt.xlabel(""Value of n"")\nplt.ylabel(""Absolute Value of Relative Error"")\nplt.title(""Problem 3(d)"")\nplt.plot( np.arange(2, 51), relative_err)\nplt.savefig(""problem_3d.png"")\n# Uncomment to show plot\n# plt.show()\n'"
a2/helper.py,1,"b'from __future__ import division\nimport numpy as np\nimport scipy as sp\n\ndef back_substitute(U, bb):\n    n = U.shape[1]\n    x = np.zeros(n)\n    for j in range(n - 1, -1, -1):   # loop backwards over columns\n        if U[j, j] == 0:\n            raise RuntimeError(""singular matrix"")\n        x[j] = bb[j] / U[j, j]\n        for i in range(0, j):\n            bb[i] -= U[i, j] * x[j]\n    return x\n'"
a2/problem_4a.py,8,"b'from __future__ import division\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom helper import back_substitute\n\ndef ge_nop(A, b):\n    n = len(A)\n    for k in range(0, n-1):\n        \n        M = np.identity(A.shape[0])\n        if A[k][k] == 0:\n            raise RuntimeError(""pivot element 0"")\n        for i in range(k+1, n):\n            M[i][k] = -1 * (A[i][k] / A[k][k])\n        U = np.array([[0] * n for i in range(n)], dtype=np.float64)\n#         print(A,""\\n"", M)\n        for i in range(0, n):\n            for j in range(0, n):\n                U[i, j] = np.dot(M[i], A.T[j])\n        A = np.asarray(U)\n#         print(A,""\\n"", M)\n        b_dash = np.zeros(b.shape)\n        for i in range(0, n):\n            b_dash[i] = np.dot(M[i], b)\n        b = b_dash\n    return A, b\n\n\ndef main():\n    try:\n        A = np.array([[1, 2, 2], [4, 4, 2], [4, 6, 4]], dtype=np.float64)\n        b = np.array([3, 6, 10], dtype=np.float64)\n        U, b_n = ge_nop(A, b)\n        x = back_substitute(U, b_n)\n        print(""A = \\n"", A)\n        print(""b = \\n"", b)\n        print(""Solution for Ax = b, x = \\n"", x.T)\n    except RuntimeError as e:\n        print(e)\n        print(""Faulty Matrix is, \\n"", A)\n\nif __name__ == \'__main__\':\n    main()\n\n'"
a2/problem_4b.py,8,"b'from __future__ import division\nimport numpy as np\nimport scipy as sp\nfrom helper import back_substitute\n\n\ndef get_index_of_pivot(A, i):\n    # returns the index of the row suitable for pivot in column i\n    max_elem = None\n    max_index = None\n    for j in range(i+1, A.shape[0]):\n        if max_elem == None or abs(max_elem) < abs(A[j][i]):\n            max_elem = A[j][i]\n            max_index = j\n    return max_index\n\ndef swap_rows(A, i, j):\n    # swaps rows i and j of the matrix A\n    A[i], A[j] = A[j].copy(), A[i].copy()\n    return A\n\ndef ge_pp(A, b):\n    n = len(A)\n    for k in range(0, n - 1):\n        M = np.identity(A.shape[0], dtype=np.float64)\n        p = get_index_of_pivot(A, k)\n        if p != k:\n            A = swap_rows(A, k, p)\n            b = swap_rows(b, k, p)\n        if A[k][k] == 0:\n            continue\n        for i in range(k+1, n):\n            M[i][k] = -1 * (A[i][k] / A[k][k])\n        U = np.array([[0] * n for i in range(n)], dtype=np.float64)\n        for i in range(0, n):\n            for j in range(0, n):\n                U[i, j] = np.dot(M[i], A.T[j])\n#         print(A, ""\\n"", U,""\\n"", M)\n        A = np.asarray(U)\n        b_dash = np.zeros(b.shape, dtype=np.float64)\n        for i in range(0, n):\n            b_dash[i] = np.dot(M[i], b)\n\n        b = b_dash\n    return A, b\n\ndef main():\n    A = np.array([[1, 2, 2], [4, 4, 2], [4, 6, 4]], dtype=np.float64)\n    b = np.array([3, 6, 10], dtype=np.float64)\n    U, b_n = ge_pp(A, b)\n    x = back_substitute(U, b_n)\n    print(""A = \\n"", A)\n    print(""b = \\n"", b)\n    print(""Solution for Ax = b, x = \\n"", x)\n\nif __name__ == \'__main__\':\n    main()'"
a2/problem_4c.py,81,"b'from __future__ import division\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom problem_4a import ge_nop\nfrom problem_4b import ge_pp\nfrom helper import back_substitute\n\n# def bmatrix(a):\n#     """"""Returns a LaTeX bmatrix\n\n#     :a: numpy array\n#     :returns: LaTeX bmatrix as a string\n#     """"""\n#     if len(a.shape) > 2:\n#         raise ValueError(\'bmatrix can at most display two dimensions\')\n#     lines = str(a).replace(\'[\', \'\').replace(\']\', \'\').splitlines()\n#     rv = [r\'\\begin{bmatrix}\']\n#     rv += [\'  \' + \' & \'.join(l.split()) + r\'\\\\\' for l in lines]\n#     rv +=  [r\'\\end{bmatrix}\']\n#     return \'\\n\'.join(rv)\n\n\n\n\nn = 100\nA_1 = np.random.randn(n, n)\nA_2 = np.array([[0] * n for i in range(n)], dtype=np.float64)\nA_3 = np.array([[0] * n for i in range(n)], dtype=np.float64)\nfor i in range(n):\n    for j in range(n):\n        if (i + 2)%n == j:\n            A_2[i, j] = 5\n        else:\n            A_2[i, j] = 10**(-3)\n        A_3[i, j] = 1 / ((1 + abs((i + 1)%n - j))**4)\n\nnp.random.seed(2018)\nx_1, x_2, x_3 = np.random.rand(n, 3).T\n\nb_1 = np.zeros((n,), dtype=np.float64)\nb_2 = np.zeros((n,), dtype=np.float64)\nb_3 = np.zeros((n,), dtype=np.float64)\nfor i in range(n):\n    b_1[i] = np.dot(A_1[i], x_1)\n    b_2[i] = np.dot(A_2[i], x_2)\n    b_3[i] = np.dot(A_3[i], x_3)\n\ncno_1 = np.linalg.cond(A_1, p=2)\ncno_2 = np.linalg.cond(A_2, p=2)\ncno_3 = np.linalg.cond(A_3, p=2)\n\n\nx_err_nop_1 = None\nx_err_nop_2 = None\nx_err_nop_3 = None\nx_rerr_nop_1 = None\nx_rerr_nop_2 = None\nx_rerr_nop_3 = None\nres_nop_1 = None\nres_nop_2 = None\nres_nop_3 = None\nrres_nop_1 = None\nrres_nop_2 = None\nrres_nop_3 = None\n\n\ntry:\n    x_sol_nop_1 = back_substitute(ge_nop(A_1, b_1)[0], ge_nop(A_1, b_1)[1])\n    x_err_nop_1 = np.linalg.norm(x_sol_nop_1 - x_1, ord=2)\n    x_rerr_nop_1 = x_err_nop_1 / np.linalg.norm(x_1, ord=2)\n    res_nop_1 = np.linalg.norm(b_1 - np.array([np.dot(A_1[i], x_sol_nop_1) for i in range(n)],\\\n                                              dtype=np.float64), ord=2)\n    rres_nop_1 = res_nop_1 / (np.linalg.norm(A_1, ord=2) * np.linalg.norm(x_1, ord=2))\n    \nexcept RuntimeError as e:\n    x_sol_nop_1 = np.nan\n    x_err_nop_1 = np.nan\n    res_nop_1 = np.nan\n    rres_nop_1 = np.nan\n    x_rerr_nop_1 = np.nan\n    print(e)\n    print(""Faulty Matrix is, A_1 = \\n"", A_1)\n\ntry:    \n    x_sol_nop_2 = back_substitute(ge_nop(A_2, b_2)[0], ge_nop(A_2, b_2)[1])\n    x_err_nop_2 = np.linalg.norm(x_sol_nop_2 - x_2, ord=2)\n    x_rerr_nop_2 = x_err_nop_2 / np.linalg.norm(x_2, ord=2)\n    res_nop_2 = np.linalg.norm(b_2 - np.array([np.dot(A_2[i], x_sol_nop_2) for i in range(n)],\\\n                                              dtype=np.float64), ord=2)\n    rres_nop_2 = res_nop_2 / (np.linalg.norm(A_2, ord=2) * np.linalg.norm(x_2, ord=2))\n    \nexcept RuntimeError as e:\n    x_sol_nop_2 = np.nan\n    x_err_nop_2 = np.nan\n    x_rerr_nop_2 = np.nan\n    res_nop_2 = np.nan\n    rres_nop_2 = np.nan\n    print(e)\n    print(""Faulty Matrix is, A_2 = \\n"", A_2)\n    # print(bmatrix(A_2))\n\ntry:\n    x_sol_nop_3 = back_substitute(ge_nop(A_3, b_3)[0], ge_nop(A_3, b_3)[1])\n    x_err_nop_3 = np.linalg.norm(x_sol_nop_3 - x_3, ord=2)\n    x_rerr_nop_3 = x_err_nop_3 / np.linalg.norm(x_3, ord=2)\n    res_nop_3 = np.linalg.norm(b_3 - np.array([np.dot(A_3[i], x_sol_nop_3) for i in range(n)],\\\n                                              dtype=np.float64), ord=2)\n    rres_nop_3 = res_nop_3 / (np.linalg.norm(A_3, ord=2) * np.linalg.norm(x_3, ord=2))\n    \nexcept RuntimeError as e:\n    x_sol_nop_3 = np.nan\n    x_err_nop_3 = np.nan\n    x_rerr_nop_3 = np.nan\n    res_nop_3 = np.nan\n    rres_nop_3 = np.nan\n    print(e)\n    print(""Faulty Matrix is, A_3 = \\n"", A_3)\n\n\n\nU_1, b_n1 = ge_pp(A_1, b_1)\nU_2, b_n2 = ge_pp(A_2, b_2)\nU_3, b_n3 = ge_pp(A_3, b_3)\n\nx_sol_pp_1 = back_substitute(U_1, b_n1)\nx_sol_pp_2 = back_substitute(U_2, b_n2)\nx_sol_pp_3 = back_substitute(U_3, b_n3)\n\nx_err_pp_1 = np.linalg.norm(x_sol_pp_1 - x_1, ord=2)\nx_err_pp_2 = np.linalg.norm(x_sol_pp_2 - x_2, ord=2)\nx_err_pp_3 = np.linalg.norm(x_sol_pp_3 - x_3, ord=2)\n\nx_rerr_pp_1 = x_err_pp_1 / np.linalg.norm(x_1, ord=2)\nx_rerr_pp_2 = x_err_pp_2 / np.linalg.norm(x_2, ord=2)\nx_rerr_pp_3 = x_err_pp_3 / np.linalg.norm(x_3, ord=2)\n\n\nres_pp_1 = np.linalg.norm(b_1 - np.array([np.dot(A_1[i], x_sol_pp_1) for i in range(n)],\\\n                                              dtype=np.float64), ord=2)\nres_pp_2 = np.linalg.norm(b_2 - np.array([np.dot(A_2[i], x_sol_pp_2) for i in range(n)],\\\n                                              dtype=np.float64), ord=2)\nres_pp_3 = np.linalg.norm(b_3 - np.array([np.dot(A_3[i], x_sol_pp_3) for i in range(n)],\\\n                                              dtype=np.float64), ord=2)\n\nrres_pp_1 = res_pp_1 / (np.linalg.norm(A_1, ord=2) * np.linalg.norm(x_1, ord=2))\nrres_pp_2 = res_pp_2 / (np.linalg.norm(A_2, ord=2) * np.linalg.norm(x_2, ord=2))\nrres_pp_3 = res_pp_3 / (np.linalg.norm(A_3, ord=2) * np.linalg.norm(x_3, ord=2))\n\n\nx_1_np = np.linalg.solve(A_1, b_1)\nx_2_np = np.linalg.solve(A_2, b_2)\nx_3_np = np.linalg.solve(A_3, b_3)\n\nx_err_np_1 = np.linalg.norm(x_1_np - x_1, ord=2)\nx_err_np_2 = np.linalg.norm(x_2_np - x_2, ord=2)\nx_err_np_3 = np.linalg.norm(x_3_np - x_3, ord=2)\n\nx_rerr_np_1 = x_err_np_1 / np.linalg.norm(x_1, ord=2)\nx_rerr_np_2 = x_err_np_2 / np.linalg.norm(x_2, ord=2)\nx_rerr_np_3 = x_err_np_3 / np.linalg.norm(x_3, ord=2)\n\nres_np_1 = np.linalg.norm(b_1 - np.array([np.dot(A_1[i], x_1_np) for i in range(n)],\\\n                                              dtype=np.float64), ord=2)\nres_np_2 = np.linalg.norm(b_2 - np.array([np.dot(A_2[i], x_2_np) for i in range(n)],\\\n                                              dtype=np.float64), ord=2)\nres_np_3 = np.linalg.norm(b_3 - np.array([np.dot(A_3[i], x_3_np) for i in range(n)],\\\n                                              dtype=np.float64), ord=2)\n\nrres_np_1 = res_np_1 / (np.linalg.norm(A_1, ord=2) * np.linalg.norm(x_1, ord=2))\nrres_np_2 = res_np_1 / (np.linalg.norm(A_2, ord=2) * np.linalg.norm(x_2, ord=2))\nrres_np_3 = res_np_1 / (np.linalg.norm(A_3, ord=2) * np.linalg.norm(x_3, ord=2))\n\n\nindex = [(""Error"", ""ge_nop""), (""Error"", ""ge_pp""), (""Error"", ""np.solve""),\\\n         (""Residual"", ""ge_nop""), (""Residual"", ""ge_pp""), (""Residual"", ""np.solve""),\\\n         (""Relative Error"", ""ge_nop""), (""Relative Error"", ""ge_pp""), (""Relative Error"", ""np.solve""),\\\n         (""Relative Residual"", ""ge_nop""), (""Relative Residual"", ""ge_pp""), (""Relative Residual"", ""np.solve"")]\n\nindex = pd.MultiIndex.from_tuples(index, names=[\'Statistic\', \'Method\'])\n\nmatrix = {\'A_1, x_1\': [x_err_nop_1, x_err_pp_1, x_err_np_1,\\\n                       res_nop_1, res_pp_1, res_np_1,\\\n                       x_rerr_nop_1, x_rerr_pp_1, x_rerr_np_1,\\\n                       rres_nop_1, rres_pp_1, rres_pp_1],\\\n          \'A_2, x_2\': [x_err_nop_2, x_err_pp_2, x_err_np_2,\\\n                       res_nop_2, res_pp_2, res_np_2,\\\n                       x_rerr_nop_2, x_rerr_pp_2, x_rerr_np_2,\\\n                       rres_nop_2, rres_pp_2, rres_pp_2], \\\n          \'A_3, x_3\': [x_err_nop_3, x_err_pp_3, x_err_np_3,\\\n                       res_nop_3, res_pp_3, res_np_3,\\\n                       x_rerr_nop_3, x_rerr_pp_3, x_rerr_np_3,\\\n                       rres_nop_1, rres_pp_1, rres_pp_1]}\n\n\ndf = pd.DataFrame(matrix, index = index)\ndf.columns.name = ""Input""\ndf = df.T\ndf[\'Condition number\'] = pd.Series([cno_1, cno_2, cno_3], index=df.T.columns)\ndf = df.T\n\nprint(\'\\n\\n\')\nprint(\'\\t\\tAnalysis Table\\n\')\n\nprint(df.to_string())\n# print(df.to_latex())\n'"
a2/problem_5.py,27,"b'from __future__ import division\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n\ndef matmul(A, B):\n    # multiply two 2-D square matrices together\n    n = A.shape[0]\n    U = np.array([[0] * n for i in range(n)], dtype=np.float64)\n    for i in range(0, n):\n        for j in range(0, n):\n            U[i, j] = np.dot(A[i], B.T[j])\n    return U\n\ndef rel_residual(A, x_cap, x, b):\n    # returns 2-norm relative residual of a linear system\n    res = np.linalg.norm(b - np.array([np.dot(A[i], x_cap) for i in range(n)]), ord=2)\n    rel_res = res / (np.linalg.norm(A, ord=2) * np.linalg.norm(x, ord=2))\n    return rel_res\n\ndef rel_error(x_cap, x):\n    # returns 2-norm relative error\n    return np.linalg.norm(x_cap - x, ord=2) / np.linalg.norm(x, ord=2)\n\n\nn = 100\nnp.random.seed(1729)\nA = np.random.randn(n, n)\n\nx = np.ones(n)\nb = np.array([np.dot(A[i], x) for i in range(n)])\n\nDA = A\nDb = b\nx_cap = np.linalg.solve(DA, Db)\nrel_err_1 = rel_error(x_cap, x)\nrel_res_1 = rel_residual(DA, x_cap, x, Db)\ncno_1 = np.linalg.cond(DA, p=2)\n\n\nD = np.diag(2 * np.ones(n))\nDA = matmul(D, A)\nDb = np.array([np.dot(D[i], b) for i in range(n)])\nx_cap = np.linalg.solve(DA, Db)\nrel_err_2 = rel_error(x_cap, x)\nrel_res_2 = rel_residual(DA, x_cap, x, Db)\ncno_2 = np.linalg.cond(DA, p=2)\n\n\nD = np.diag(np.linspace(1, 100, 100))\nDA = matmul(D, A)\nDb = np.array([np.dot(D[i], b) for i in range(n)])\nx_cap = np.linalg.solve(DA, Db)\nrel_err_3 = rel_error(x_cap, x)\nrel_res_3 = rel_residual(DA, x_cap, x, Db)\ncno_3 = np.linalg.cond(DA, p=2)\n\n\nD = np.diag(np.linspace(1, 10000, 100))\nDA = matmul(D, A)\nDb = np.array([np.dot(D[i], b) for i in range(n)])\nx_cap = np.linalg.solve(DA, Db)\nrel_err_4 = rel_error(x_cap, x)\nrel_res_4 = rel_residual(DA, x_cap, x, Db)\ncno_4 = np.linalg.cond(DA, p=2)\n\n\nD = np.diag(2**-np.arange(-n//2, n//2, dtype=np.float64))\nDA = matmul(D, A)\nDb = np.array([np.dot(D[i], b) for i in range(n)])\nx_cap = np.linalg.solve(DA, Db)\nrel_err_5 = rel_error(x_cap, x)\nrel_res_5 = rel_residual(DA, x_cap, x, Db)\ncno_5 = np.linalg.cond(DA, p=2)\n\n\ndata = pd.DataFrame({""(i)"" : [rel_err_1, rel_res_1, cno_1], ""(ii)"" : [rel_err_2, rel_res_2, cno_2],\\\n              ""(iii)"" : [rel_err_3, rel_res_3, cno_3], ""(iv)"" : [rel_err_4, rel_res_4, cno_4],\\\n              ""(v)"" : [rel_err_5, rel_res_5, cno_5]}, index=[""Relative Error"", ""Relative Residual"",\\\n                                                             ""Condition Number""]).T\ndata.index.name = ""Part""\ndata.columns.name = ""Statistic""\n\n\nprint(data.to_string())\n\n# print(data.to_latex())'"
a2/problem_6a.py,4,"b'from __future__ import division\nimport numpy as np\nimport scipy as sp\n\ndef construct_A(n):\n    A = np.diag([2] * n)\n\n    A += np.diag([-1] * (n - 1), k=1)\n    A += np.diag([-1] * (n - 1), k=-1)\n\n    condn_no = np.linalg.cond(A, p=2)\n    return A, condn_no\n\nif __name__ == \'__main__\':\n    A, condn_no = construct_A(512)\n    print(""A = \\n"", A)\n    print(""Condition number of A  = "", condn_no)'"
a2/problem_6b.py,5,"b""from __future__ import division\nimport numpy as np\nimport scipy as sp\n\ndef gen_vectors():\n\n    b_all = np.random.rand(110, 512)\n    perturbations = np.arange(0.01, 0.11, 0.01)\n\n    for i in range(10):\n        b_all[i] = b_all[i] / np.linalg.norm(b_all[i], ord=2)\n    \n    for i in range(10, b_all.shape[0], 10):\n\n        for j in range(10):\n            # print(np.linalg.norm(b_all[i//10 - 1], ord=2), np.linalg.norm((b_all[i + j] / np.linalg.norm(b_all[i + j], ord=2)) * perturbations[i//10 - 1], ord=2))\n            \n            b_all[i + j] = b_all[i//10 - 1] + ((b_all[i + j] / np.linalg.norm(b_all[i + j], ord=2)) * perturbations[i//10 - 1])\n\n\n    return b_all\n\n\nif __name__ == '__main__':\n    b_all = gen_vectors()\n    print(b_all.shape)\n"""
a2/problem_6c.py,9,"b'from __future__ import division\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\nfrom problem_6a import construct_A\nfrom problem_6b import gen_vectors\nfrom matplotlib import rc\n\n\n\ndef generate_four_tuples(A, b_all):\n\n\ttuples = []\n\n\tfor i in range(10):\n\n\t\tb = b_all[i]\n\n\t\tx = np.linalg.solve(A, b)\n\n\t\tfor j in range(10):\n\t\t\t# print(i, j)\n\t\t\tb_db = b_all[(i+1) * 10 + j]\n\t\t\tx_dx = np.linalg.solve(A, b_db)\n\n\t\t\tdb = b_db - b\n\t\t\tdx = x_dx - x\n\n\t\t\ttuples.append((b, db, x, dx))\n\n\treturn np.array(tuples)\n\ndef generate_plot(cno_A, tuples):\n\n\tpoints_x = []\n\tpoints_y = []\n\n\n\tfor i in range(len(tuples)):\n\n\t\tdb_norm = np.linalg.norm(tuples[i][1], ord=2)\n\t\tb_norm = np.linalg.norm(tuples[i][0], ord=2)\n\t\tdx_norm = np.linalg.norm(tuples[i][3], ord=2)\n\t\tx_norm = np.linalg.norm(tuples[i][2], ord=2)\n\n\t\tx = cno_A * (db_norm / b_norm)\n\t\ty = dx_norm / x_norm\n\n\t\tpoints_x.append(x)\n\t\tpoints_y.append(y)\n\t\n\tpoints_x = np.array(points_x, dtype=np.float128)\n\tpoints_y = np.array(points_y, dtype=np.float128)\n\n\tplt.figure()\n\tplt.xlabel(u""cond(A) * (||\\delta b|| / ||b||)"")\n\tplt.ylabel(u""||\\delta x|| / ||x||"")\n\tplt.plot(points_x, points_y, ""ko"")\n\tplt.savefig(""problem_6c.png"")\n\t# Uncomment this line to see the plot\n\t# plt.show()\n\ndef main():\n\n\tA, cno_A = construct_A(512)\n\tb_all = gen_vectors()\n\ttuples = generate_four_tuples(A, b_all)\n\tgenerate_plot(cno_A, tuples)\n\nif __name__ == \'__main__\':\n\tmain()\n\n\n'"
a3/problem_1b.py,6,"b'import numpy as np\n\ndef pow_iter(A, x_0, tol=10**(-16), max_iter=100):\n    y = None\n    xo = x_0.copy()\n    lamdao = 1\n    diff = 10000\n    lamdan = 0\n    while diff > tol:\n        y = np.dot(A, xo)\n        xn = y / np.linalg.norm(y, ord=np.inf)\n        lamdan = np.linalg.norm(y, ord=np.inf)\n        diff = np.abs(lamdao - lamdan) / np.abs(lamdao)\n        lamdao = lamdan\n        xo = xn\n    return xn, lamdao\n\ndef main():\n\tA = np.array([[2, 3, 2], [10, 3, 4], [3, 6, 1]])\n\tx_0 = np.array([0, 0, 1])\n\tx, lamda = pow_iter(A.copy(), x_0)\n\tprint(""Absolute Value of Largest Eigenvalue:"", lamda)\n\tprint(""Normalized Eigenvector:"", x)\n\nif __name__ == \'__main__\':\n\tmain()'"
a3/problem_1c.py,4,"b'import numpy as np\nfrom problem_1b import pow_iter\n\n\ndef deflate(A, x_1):\n\tk = 0\n\tfor i in range(len(x_1)):\n\t\tif x_1[i] == 1: k = i\n\tu_1 = A.T[:, k]\n\tA_new = A - np.outer(x_1, u_1)\n\n\tx2, lamda = pow_iter(A_new, np.random.random(3))\n\treturn lamda\n\ndef main():\n\tA = np.array([[2, 3, 2], [10, 3, 4], [3, 6, 1]])\n\tx_0 = np.array([0, 0, 1])\n\tx, lamda = pow_iter(A.copy(), x_0)\n\tlamda_2 = deflate(A.copy(), x)\n\tprint(""Absolute Value of Largest Eigenvalue:"", lamda)\n\tprint(""Normalized Eigenvector:"", x)\n\tprint(""Absolute Value of Second - largest Eigenvalue:"", lamda_2)\n\nif __name__ == \'__main__\':\n\tmain()'"
a3/problem_2a.py,10,"b'import numpy as np\nimport matplotlib.pyplot as plt\n\ndef QR_fact(A):\n\t\n\t""""""\n\t\tI spent 4 hours on this. This still does\n\t\tnot work properly. Ultimately I just cries\n\t\tand left this as is in remembrance.\n\t""""""\n\n\n\tif A is None:\n\t\traise RuntimeError(""A cannot be NoneType"")\n\t\n\tncols = A.shape[1]\n\tnrows = A.shape[0]\n\t\n\tQ = np.zeros(A.shape)\n\tR = np.zeros((ncols, ncols))\n\tfor i in range(ncols):\n\t\tu_i = A[:, i]\n\t\tu_i-=np.dot(Q[:, :i], np.dot(u_i, Q[:, :i]))\n\t\te_i = u_i / np.linalg.norm(u_i, ord=2)\n\t\tQ[:, i] = e_i\n\t\tR[:, i] = np.dot(np.dot(u_i, Q[:, :i+1]), np.diag(np.ones(ncols))[:i+1])\n\treturn Q, R\n\ndef QR_fact_iter(A):\n\tif A is None:\n\t\traise RuntimeError(""A cannot be NoneType"")\n\t\n\tncols = A.shape[1]\n\tnrows = A.shape[0]\n\t\n\tQ = np.zeros(A.shape)\n\tR = np.zeros((ncols, ncols))\n\t\n\t\n\tfor k in range(ncols):\n\t\t\n\t\tQ[:, k] = A[:, k]\n\t\tfor j in range(k):\n\t\t\t\n\t\t\tR[j, k] = np.dot(Q[:, j], A[:, k])\n\t\t\tQ[:, k] = Q[:, k] - R[j, k] * Q[:, j]\n\t\t\n\t\tR[k, k] = np.linalg.norm(Q[:, k], ord=2)\n\t\tif R[k, k] == 0:\n\t\t\traise RuntimeError(""Matrix A is not full rank."")\n\t\t\n\t\tQ[:, k] = Q[:, k] / R[k, k]\n\t\t\n\treturn Q, R\n\ndef main():\n\tA = np.random.random((100, 80))\n\tQ, R = QR_fact_iter(A)\n\n\nif __name__ == \'__main__\':\n\tmain()'"
a3/problem_2b.py,12,"b'import numpy as np\nimport matplotlib.pyplot as plt\nfrom problem_2a import QR_fact_iter\n\n\nA_1 = np.random.random((5, 5))\nprint(""Shape of Matrix A ="", A_1.shape)\nQ, R = QR_fact_iter(A_1)\nrel_err = np.linalg.norm((np.dot(Q, R) - A_1), ord=2) / np.linalg.norm(A_1, ord=2)\nprint(""Relative Error ="", rel_err)\nprint(""Condition Number of A ="", np.linalg.cond(A_1, p=2))\nprint(""Condition Number of QR ="", np.linalg.cond(np.dot(Q, R), p=2))\nprint(""\\n"")\n\nA_2 = np.random.random((10, 10))\nprint(""Shape of Matrix A ="", A_2.shape)\nQ, R = QR_fact_iter(A_2)\nrel_err = np.linalg.norm((np.dot(Q, R) - A_2), ord=2) / np.linalg.norm(A_2, ord=2)\nprint(""Relative Error ="", rel_err)\nprint(""Condition Number of A ="", np.linalg.cond(A_2, p=2))\nprint(""Condition Number of QR ="", np.linalg.cond(np.dot(Q, R), p=2))\nprint(""\\n"")\n\nA_3 = np.random.random((100, 80))\nprint(""Shape of Matrix A ="", A_3.shape)\nQ, R = QR_fact_iter(A_3)\nrel_err = np.linalg.norm((np.dot(Q, R) - A_3), ord=2) / np.linalg.norm(A_3, ord=2)\nprint(""Relative Error ="", rel_err)\nprint(""Condition Number of A ="", np.linalg.cond(A_2, p=2))\nprint(""Condition Number of QR ="", np.linalg.cond(np.dot(Q, R), p=2))\nprint(""\\n"")'"
a3/problem_2c.py,24,"b'import numpy as np\nimport matplotlib.pyplot as plt\nfrom problem_2a import QR_fact_iter\n\ndef back_subsitute(U, bb):\n\tn = U.shape[1]\n\tx = np.zeros(n)\n\tfor j in range(n - 1, -1, -1):   # loop backwards over columns\n\t\tif U[j, j] == 0:\n\t\t\traise RuntimeError(""singular matrix"")\n\n\t\tx[j] = bb[j] / U[j, j]\n\t\tfor i in range(0, j):\n\t\t\tbb[i] -= U[i, j] * x[j]\n\n\treturn x\n\n\n\ndef fit_poly_on_data(data, order=1):\n\tA = np.array([[float(i) ** j for j in range(order+1)] for i in range(1, len(data) + 1)])\n#     print(A)\n\tb = data\n\tQ, R = QR_fact_iter(A)\n\td = np.dot(Q.T, b)\n\tc = back_subsitute(R, d)\n\treturn c\n\ndef str_poly(coeff):\n\tif len(coeff) > 6:\n\t\traise RuntimeError(""Degree > 5. Please handle."")\n\t\n\ttemplate = {0 : """", 1 : ""x"", 2 : ""x^2"", 3 : ""x^3"", 4 : ""x^4"", 5 : ""x^5"",}\n\tletters = [""a"", ""b"", ""c"", ""d"", ""e"", ""f""]\n\t\n\tstring = """"\n\tvalues = ""\\n\\n""\n\t\n\tfor i in range(len(coeff), 1, -1):\n\t\t\n\t\tstring = string + letters[len(coeff) - i] + "" * "" + template[i - 1] + "" + ""\n\t\tvalues = values + letters[len(coeff) - i] + "" = "" + str(coeff[i - 1]) + ""\\n""\n\t\t\n\tstring = string + letters[len(coeff) - 1]\n\tvalues = values + letters[len(coeff) - 1] + "" = "" + str(coeff[0])\n\tstring = string + values\n\t\n\t\n\treturn string\n\n\ndef get_relative_residual(A, x, b):\n\treturn np.linalg.norm(np.dot(A, x) - b, ord=2) / np.linalg.norm(b, ord=2)\n\n\ndef main():\n\tv = np.loadtxt(""petrol_price_delhi.txt"", delimiter=""\\n"")\n\tY_cal = list()\n\tY_true = list()\n\n\tfor i in range(1, 6):\n\t\tprint(""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"")\n\t\tprint(""Results for Degree:"", i)\n\t\tcoeff_cal = fit_poly_on_data(v, order=i)\n\t\tA = np.array([[float(j) ** k for k in range(i+1)] for j in range(1, len(v) + 1)])\n\t\tcoeff_true = np.linalg.lstsq(A, v, rcond=None)[0]\n\t\trel_res_cal = get_relative_residual(A, coeff_cal, v)\n\t\trel_res_true = get_relative_residual(A, coeff_true, v)\n\t\tstr_poly_cal = str_poly(coeff_cal)\n\t\tstr_ploy_true = str_poly(coeff_true)\n\t\tprint(""\\n\\n"")\n\t\tprint(""------------------------------------------------------------------------"")\n\t\tprint(""Strategy: np.linalg.lstsq"")\n\t\tprint(""------------------------------------------------------------------------"")\n\t\tprint(""Approximate Polynomial:\\n\\n"")\n\t\tprint(str_ploy_true)\n\t\tprint(""\\n\\n"")\n\t\tprint(""Relative Residual:"", rel_res_true)\n\t\tprint(""\\n\\n"")\n\t\tprint(""------------------------------------------------------------------------"")\n\t\tprint(""Strategy: get_QR()"")\n\t\tprint(""------------------------------------------------------------------------"")\n\t\tprint(""Approximate Polynomial:\\n\\n"")\n\t\tprint(str_poly_cal)\n\t\tprint(""\\n\\n"")\n\t\tprint(""Relative Residual:"", rel_res_cal)\n\t\tprint(""\\n\\n"")\n\t\tY_cal.append(np.dot(A, coeff_cal))\n\t\tY_true.append(np.dot(A, coeff_true))\n\n\tplt.figure(figsize=(10, 10))\n\tplt.subplots_adjust(hspace=8)\n\tplt.subplot(2, 1, 1)\n\tplt.scatter(np.arange(1, len(v) + 1), v, marker=""+"", c=""black"", label=""Original Data"")\n\t# plt.plot(np.arange(1, len(v) + 1), Y_true[0], np.arange(1, len(v) + 1), Y_true[1], np.arange(1, len(v) + 1), Y_true[2], np.arange(1, len(v) + 1), Y_true[3], np.arange(1, len(v) + 1), Y_true[4])\n\tplt.plot(np.arange(1, len(v) + 1), Y_true[0], label=""Degree = 1"")\n\tplt.plot(np.arange(1, len(v) + 1), Y_true[1], label=""Degree = 2"")\n\tplt.plot(np.arange(1, len(v) + 1), Y_true[2], label=""Degree = 3"")\n\tplt.plot(np.arange(1, len(v) + 1), Y_true[3], label=""Degree = 4"")\n\tplt.plot(np.arange(1, len(v) + 1), Y_true[4], label=""Degree = 5"")\n\tplt.xlabel(""Day"")\n\tplt.ylabel(""Price of petrol (Rs./l)"")\n\tplt.title(""Data fitted using np.linalg.lstsq()"")\n\tplt.legend(loc=1)\n\tplt.subplot(2,1,2)\n\tplt.scatter(np.arange(1, len(v) + 1), v, marker=""+"", c=""black"", label=""Original Data"")\n\tplt.plot(np.arange(1, len(v) + 1), Y_cal[0], label=""Degree = 1"")\n\tplt.plot(np.arange(1, len(v) + 1), Y_cal[1], label=""Degree = 2"")\n\tplt.plot(np.arange(1, len(v) + 1), Y_cal[2], label=""Degree = 3"")\n\tplt.plot(np.arange(1, len(v) + 1), Y_cal[3], label=""Degree = 4"")\n\tplt.plot(np.arange(1, len(v) + 1), Y_cal[4], label=""Degree = 5"")\n\tplt.xlabel(""Day"")\n\tplt.ylabel(""Price of petrol (Rs./l)"")\n\tplt.title(""Data fitted using get_QR()"")\n\tplt.legend(loc=1)\n\tplt.tight_layout()\n\tplt.savefig(""problem_2c.png"")\n\tplt.show()\n\nif __name__ == \'__main__\':\n\tmain()'"
a3/problem_3a.py,8,"b'import numpy as np\n\ndef inverse_iteration(A, x, shift=2):\n\tdiff = 10000\n\tdiffn = 0\n\txn = None\n\txo = x\n\tlamda = 0\n\titers = 0\n\tA = A - shift * np.diag(np.diag(np.ones(A.shape)))\n\twhile(diff > 10**(-12)):\n\t\titers+=1\n\t\tyn = np.linalg.solve(A, xo)\n\t\txn = yn / np.linalg.norm(yn, ord=2)\n\t\tlamda = np.linalg.norm(yn, ord=2)\n\t\tdiff = np.linalg.norm((xn - xo), ord=2) / np.linalg.norm(xo, ord=2)\n\t\txo = xn\n\n\treturn 1/(lamda) + shift, xn, iters\n\nif __name__ == \'__main__\':\n\tprint(""Inverse Iteration"")\n\tprint(""-------------------\\n\\n"")\n\n\tseeds = [1, 89, 98, 23, 88, 91, 101, 11, 17, 19]\n\n\tfor i in range(10):\n\t\tA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\n\t\tnp.random.seed(seeds[i])\n\t\tprint(\'Seed:\', seeds[i])\n\t\tx0 = np.random.random((3,))\n\t\tl, x, iters = inverse_iteration(A, x0)\n\t\tprint(""Computed Eigenvalue:"", l)\n\t\tprint(""Computed Eigenvector:\\n\\t"", x, ""\'\\n"")\n\t\tprint(""Number of iterations:"", iters)\n\t\tprint(""\\n\\n"")\n\n\n'"
a3/problem_3b.py,7,"b'import numpy as np\n\ndef rayleigh_iter(A, x):\n\tdiff = 100000\n\txo = x\n\txk = None\n\titers = 0\n\twhile(diff > 10**(-12)):\n\t\titers+=1\n\n\t\tsigma_k = np.dot(xo, np.dot(A, xo)) / np.dot(xo, xo)\n\n\t\tyk = np.linalg.solve(A - (sigma_k * np.diag(np.diag(np.ones(A.shape)))), xo)\n\n\t\txk = yk / np.linalg.norm(yk, ord=2)\n\n\t\tdiff = np.linalg.norm(xk - xo, ord=2) / np.linalg.norm(xo, ord=2)\n\n\t\txo = xk\n\treturn sigma_k, xk, iters\n\nif __name__ == \'__main__\':\n\tprint(""Rayleigh Quotient Iteration"")\n\tprint(""------------------------------\\n\\n"")\n\n\tseeds = [1, 89, 98, 23, 88, 91, 101, 11, 17, 19]\n\n\tfor i in range(10):\n\t\tA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\n\t\tnp.random.seed(seeds[i])\n\t\tprint(\'Seed:\', seeds[i])\n\t\tx0 = np.random.randn(3)\n\t\tl, x, iters = rayleigh_iter(A, x0)\n\t\t\n\t\tprint(""Computed Eigenvalue:"", l)\n\t\tprint(""Computed Eigenvector:\\n\\t"", x, ""\'\\n"")\n\t\tprint(""Number of iterations:"", iters)\n\t\tprint(""\\n\\n"")'"
a3/problem_3d.py,12,"b'import numpy as np\nfrom problem_3a import inverse_iteration\nfrom problem_3b import rayleigh_iter\n\ndef main():\n\tprint(""Inverse Iteration"")\n\tprint(""-------------------\\n\\n"")\n\n\tseeds = [1, 89, 98, 23, 88, 91, 101, 11, 17, 19]\n\n\tfor i in range(10):\n\t\tA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\n\t\tnp.random.seed(seeds[i])\n\t\tprint(\'Seed:\', seeds[i])\n\t\tx0 = np.random.random((3,))\n\t\tl, x, iters = inverse_iteration(A, x0)\n\t\tvals, vecs = np.linalg.eig(A)\n\t\trel_err_vals = np.min(np.abs(vals - l) / vals[np.argmin(np.abs(vals - l))])\n\t\tprint(""Computed Eigenvalue:"", l)\n\t\tprint(""Computed Eigenvector:\\n\\t"", x, ""\'\\n"")\n\t\trel_err_vecs = np.linalg.norm(x - vecs[:, np.argmin(np.abs(vals - l))], ord=2) / np.linalg.norm(vecs[:, np.argmin(np.abs(vals - l))]) \n\t\tprint(""Relative Error in Eigenvalues:"", rel_err_vals)\n\t\tprint(""Relative Error in Eigenvectors:"", rel_err_vecs)\n\t\tprint(""Number of iterations:"", iters)\n\t\tprint(""\\n\\n"")\n\n\n\tprint(""Rayleigh Quotient Iteration"")\n\tprint(""------------------------------\\n\\n"")\n\n\tseeds = [1, 89, 98, 23, 88, 91, 101, 11, 17, 19]\n\n\tfor i in range(10):\n\t\tA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\n\t\tnp.random.seed(seeds[i])\n\t\tprint(\'Seed:\', seeds[i])\n\t\tx0 = np.random.randn(3)\n\t\tl, x, iters = rayleigh_iter(A, x0)\n\t\tvals, vecs = np.linalg.eig(A)\n\t\trel_err_vals = np.min(np.abs(vals - l) / vals[np.argmin(np.abs(vals - l))])\n\t\t\n\t\trel_err_vecs = np.linalg.norm(x - vecs[:, np.argmin(np.abs(vals - l))], ord=2) / np.linalg.norm(vecs[:, np.argmin(np.abs(vals - l))]) \n\t\tprint(""Computed Eigenvalue:"", l)\n\t\tprint(""Computed Eigenvector:\\n\\t"", x, ""\'\\n"")\n\t\tprint(""Relative Error in Eigenvalues:"", rel_err_vals)\n\t\tprint(""Relative Error in Eigenvectors:"", rel_err_vecs)\n\t\tprint(""Number of iterations:"", iters)\n\t\tprint(""\\n\\n"")\n\n\nif __name__ == \'__main__\':\n\tmain()\n\t'"
a3/problem_3e.py,6,"b'import numpy as np\nfrom problem_3a import inverse_iteration\nfrom problem_3b import rayleigh_iter\n\ndef main():\n\tprint(""Inverse Iteration"")\n\tprint(""-------------------\\n\\n"")\n\t\n\tA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\n\tx0 = np.array([1, 4, 2])\n\tprint(""Initial Array:\\n\\t"", x0, ""\'\\n"")\n\tl, x, iters = inverse_iteration(A, x0)\n\t\n\tprint(""Computed Eigenvalue:"", l)\n\tprint(""Computed Eigenvector:\\n\\t"", x, ""\'\\n"")\n\tprint(""Number of iterations:"", iters)\n\n\tprint(""\\n\\n"")\n\n\tprint(""Rayleigh Quotient Iteration"")\n\tprint(""------------------------------\\n\\n"")\n\n\n\tA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\n\tx0 = np.array([1, 4, 2])\n\tprint(""Initial Array:\\n\\t"", x0, ""\'\\n"")\n\tl_r, x_r, iters_r = rayleigh_iter(A, x0)\n\t\n\tprint(""Computed Eigenvalue:"", l_r)\n\tprint(""Computed Eigenvector:\\n\\t"", x_r, ""\'\\n"")\n\tprint(""Number of iterations:"", iters_r)\n\tprint(""\\n\\n"")\n\n\tprint(""Picking Rayleigh Quotient Iteration result as true value...\\n\\n"")\n\n\trel_err_vec = np.linalg.norm(x - x_r, ord=2) / np.linalg.norm(x_r, ord=2)\n\trel_err_val = np.abs(l - l_r) / np.abs(l_r)\n\n\tprint(""Relative Error for Eigenvector:"", rel_err_vec)\n\tprint(""Relative Error for Eigenvalue:"", rel_err_val)\n\n\nif __name__ == \'__main__\':\n\tmain()'"
a3/problem_4a.py,5,"b'import numpy as np\nimport matplotlib.pyplot as plt\n\ndef make_data(dims=2, npts=3000): \n    np.random.seed(13)\n    mix_mat = np.random.randn(dims, dims) \n    mean = np.random.randn(dims)\n    return np.dot( mix_mat, \\\n                  np.random.randn(dims, npts)) + mean[:, np.newaxis]\n\ndef main():\n\tdata = make_data()\n\tplt.scatter(data[0], data[1])\n\tplt.xlabel(""x"")\n\tplt.ylabel(""y"")\n\tplt.title(""Plot of complete dataset"")\n\tplt.savefig(""problem_4a.png"")\n\tplt.show()\n\nif __name__ == \'__main__\':\n\tmain()'"
a3/problem_4b.py,7,"b'import numpy as np\nimport matplotlib.pyplot as plt\nfrom problem_4a import make_data\n\ndef pca(data):\n    mean = np.mean(data, axis=1)\n    data = np.array([data[i] - mean[i] for i in range(len(data))])\n    N = data.shape[1]\n    Y = (1 / np.sqrt(N - 1)) * data\n    u, s, vh = np.linalg.svd(Y.copy(), full_matrices=False)\n    sigma = np.diag(s)\n    pc = np.dot(u, np.diag(s))\n    return pc, u, s, vh, Y\n\ndef main():\n\tdata = make_data()\n\n\tpcs, u, s, vh, Y = pca(data.copy())\n\tmean = np.mean(data, axis=1)\n\tplt.figure(figsize=(8, 4))\n\tplt.scatter(data[0], data[1])\n\tplt.gca().set_aspect(""equal"")\n\tplt.arrow(mean[0], mean[1], pcs[:, 0][0],  pcs[:, 0][1], head_width=0.05, head_length=0.1, fc=\'k\', ec=\'k\')\n\tplt.arrow(mean[0], mean[1], pcs[:, 1][0],  pcs[:, 1][1], head_width=0.05, head_length=0.1, fc=\'k\', ec=\'k\')\n\tplt.xlabel(""x"")\n\tplt.ylabel(""y"")\n\tplt.title(""Dataset with Principal Components"")\n\tplt.savefig(""problem_4b.png"")\n\tplt.show()\n\nif __name__ == \'__main__\':\n\tmain()'"
a3/problem_4c.py,3,"b'import numpy as np\nfrom problem_4a import make_data\nfrom problem_4b import pca\n\ndef main():\n\tdata = make_data()\n\tpcs, u, s, vh, Y = pca(data.copy())\n\tmean = np.mean(data, axis=1)\n\tY_n = np.dot(np.dot(u, np.diag(s)), vh)\n\trel_err = np.linalg.norm(Y_n - Y, ord=2) / np.linalg.norm(Y, ord=2)\n\tprint(""Relative error of Y:"", rel_err)\n\nif __name__ == \'__main__\':\n\tmain()'"
a3/problem_4d.py,3,"b'import numpy as np\nimport matplotlib.pyplot as plt\nfrom problem_4a import make_data\nfrom problem_4b import pca\n\ndef main():\n\tdata = make_data()\n\tpcs, u, s, vh, Y = pca(data.copy())\n\ts_d = s.copy()\n\ts_d[-1] = 0\n\tY_d = np.dot(np.dot(u, np.diag(s_d)), vh)\n\tdata_d = Y_d * np.sqrt(Y.shape[1] + 1) + np.mean(data, axis=1).reshape(Y_d.shape[0], 1)\n\tpcs_d, u_d, s_dd, vh_d, Y_d = pca(data_d.copy())\n\tmean_d = np.mean(data, axis=1)\n\tplt.figure(figsize=(8, 4))\n\tplt.scatter(data_d[0], data_d[1])\n\tplt.gca().set_aspect(""equal"")\n\tplt.arrow(mean_d[0], mean_d[1], pcs_d[:, 0][0],  pcs_d[:, 0][1], head_width=0.05, head_length=0.1, fc=\'k\', ec=\'k\')\n\tplt.arrow(mean_d[0], mean_d[1], pcs_d[:, 1][0],  pcs_d[:, 1][1], head_width=0.05, head_length=0.1, fc=\'k\', ec=\'k\')\n\tplt.xlabel(""x"")\n\tplt.ylabel(""y"")\n\tplt.title(""Reformed Dataset with Principal Components"")\n\tplt.savefig(""problem_4d.png"")\n\tplt.show()\n\nif __name__ == \'__main__\':\n\tmain()'"
a3/problem_5.py,7,"b'import numpy as np\nimport numpy.linalg as npla\n\ndef qr_iteration(A, tol):\n    # Your implementation goes here\n    \n    for i in range(A.shape[1] - 1, 0, -1):\n        while npla.norm(A[i - 1, :i - 1], ord=2) > tol:\n            sigma = A[i, i]\n            Q, R = npla.qr(A - sigma * np.diag(np.diag(np.ones(A.shape))))\n            A = np.dot(R, Q) + sigma * np.diag(np.diag(np.ones(A.shape)))\n    \n    return np.diag(A)\n\ndef main():\n\t\n\ttol = 10 ** (-16)\n\tA_1 = np.array([[2, 3, 2], [10, 3, 4], [3, 6, 1]])\n\teigenvalues_1 = qr_iteration(A_1.copy(), tol)\n\tprint(""Matrix:\\n"", A_1)\n\tprint(""\\n"")\n\tprint (""Computed eigenvalues: "", eigenvalues_1)\n\tprint (""Actual eigenvalues: "", np.linalg.eigvals(A_1))\n\n\tprint(""\\n\\n"")\n\n\ttol = 10 ** (-16)\n\tA_2 = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\n\teigenvalues_2 = qr_iteration(A_2.copy(), tol)\n\tprint(""Matrix:\\n"", A_2)\n\tprint(""\\n"")\n\tprint (""Computed eigenvalues: "", eigenvalues_2)\n\tprint (""Actual eigenvalues: "", np.linalg.eigvals(A_2))\n\nif __name__ == \'__main__\':\n\tmain()\n        \n\t'"
a3/problem_6b.py,14,"b'import numpy as np\nimport numpy.linalg as npla\nimport matplotlib.pyplot as plt\n\n\n\n\n\ndef lancoiz(A, max_iter=20):\n    alphas = list()\n    betas = list()\n    ritz_vals = list()\n    qk_1 = np.zeros(A.shape[1])\n    qk = np.random.random(A.shape[1])\n    qk = qk / np.linalg.norm(qk, ord=2)\n    Q = list()\n    Q.append(qk_1)\n    Q.append(qk)\n    beta = 0\n    k = 1\n    while True:\n        qk = Q[k]\n        qk_1 = Q[k-1]\n        uk = np.dot(A, qk)\n        ak = np.dot(qk, uk)\n        alphas.append(ak)\n        uk -= ((beta * qk_1) + (ak * qk))\n        beta = npla.norm(uk, ord=2)\n        if beta == 0:\n            break\n        betas.append(beta)\n        qk_p1 = uk / beta\n        \n        T_i = np.diag(np.array(alphas))\n        T_i = T_i + np.diag(np.array(betas[:len(alphas) - 1]), -1) + np.diag(np.array(betas[:len(alphas) - 1]), +1) \n        ritzs = np.linalg.eigvals(T_i)\n        \n        ritz_vals.extend([[k, ritzs[j]] for j in range(len(ritzs))])\n        \n        k+=1\n        if k >= max_iter:\n            break\n        Q.append(qk_p1)\n\n    H = np.diag(np.array(alphas))\n    H = H + np.diag(np.array(betas[:len(alphas) - 1]), -1) + np.diag(np.array(betas[:len(alphas) - 1]), +1) \n    return np.array(Q[1:]).T, H, np.array(ritz_vals)\n    \n\n\n\t\n\n\n\n\ndef main():\n\n\tB = np.random.random((100, 100))\n\tA = B + B.T\n\tQ, H, rvals = lancoiz(A, max_iter=20)\n\n\n\n\n\tpart_1 = npla.norm(np.dot(Q, Q.T) - np.diag(np.ones(100)), ord = 2)\n\n\n\n\n\n\tpart_2 = npla.norm(np.dot(np.dot(Q.T, A), Q) - H, ord=2) / npla.norm(A, ord=2)\n\n\n\n\tprint(""Answer for part 6(a) (i):"", part_1)\n\tprint(""Answer for part 6(a) (ii):"", part_2)\n\n\nif __name__ == \'__main__\':\n\tmain()\n\n\n\n'"
a3/problem_6c.py,3,"b'import numpy as np\nimport numpy.linalg as npla\nimport matplotlib.pyplot as plt\nfrom problem_2a import QR_fact_iter\nfrom problem_6b import lancoiz\n\n\n\ndef main():\n\n\tB = np.random.random((100, 100))\n\tQ, R = QR_fact_iter(B)\n\tD = np.diag(np.arange(1, Q.shape[1] + 1))\n\tA = np.dot(np.dot(Q, D), Q.T)\n\tQ, H, rvals = lancoiz(A)\n\n\tplt.xlabel(""Ritz Values"")\n\tplt.ylabel(""Number of iterations"")\n\tplt.title(""Ritz Values Vs. No. of iterations"")\n\tplt.scatter(rvals[:, 1], rvals[:, 0])\n\tplt.savefig(""problem_6c.png"")\n\tplt.show()\n\nif __name__ == \'__main__\':\n\tmain()'"
