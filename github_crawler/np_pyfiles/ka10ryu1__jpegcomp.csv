file_path,api_count,code
create_dataset.py,3,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x93\xe3\x81\xa7\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x82\x92\xe4\xbd\x9c\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\'\n#\n\nimport logging\n# basicConfig()\xe3\x81\xaf\xe3\x80\x81 debug()\xe3\x82\x84info()\xe3\x82\x92\xe6\x9c\x80\xe5\x88\x9d\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99""\xe5\x89\x8d""\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99\xe3\x81\x93\xe3\x81\xa8\nlevel = logging.INFO\nlogging.basicConfig(format=\'%(message)s\')\nlogging.getLogger(\'Tools\').setLevel(level=level)\n\nimport cv2\nimport argparse\nimport numpy as np\n\nimport Tools.imgfunc as IMG\nimport Tools.func as F\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument(\'jpeg\', nargs=\'+\',\n                        help=\'\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\')\n    parser.add_argument(\'--channel\', \'-c\', type=int, default=1,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0 [default: 1 channel]\')\n    parser.add_argument(\'--img_size\', \'-s\', type=int, default=32,\n                        help=\'\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba [default: 32 pixel]\')\n    parser.add_argument(\'--flip_num\', \'-f\', type=int, default=2,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe5\x8f\x8d\xe8\xbb\xa2\xe5\x9b\x9e\xe6\x95\xb0 [default: 2, max: 3]\')\n    parser.add_argument(\'--round\', \'-r\', type=int, default=1000,\n                        help=\'\xe5\x88\x87\xe3\x82\x8a\xe6\x8d\xa8\xe3\x81\xa6\xe3\x82\x8b\xe6\x95\xb0 [default: 1000]\')\n    parser.add_argument(\'--quality\', \'-q\', type=int, default=5,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe5\x9c\xa7\xe7\xb8\xae\xe7\x8e\x87 [default: 5]\')\n    parser.add_argument(\'--train_per_all\', \'-t\', type=float, default=0.9,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe6\x95\xb0\xe3\x81\xab\xe5\xaf\xbe\xe3\x81\x99\xe3\x82\x8b\xe5\xad\xa6\xe7\xbf\x92\xe7\x94\xa8\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe5\x89\xb2\xe5\x90\x88 [default: 0.9]\')\n    parser.add_argument(\'-o\', \'--out_path\', default=\'./result/\',\n                        help=\'\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe4\xbf\x9d\xe5\xad\x98\xe5\x85\x88(default: ./result/)\')\n    args = parser.parse_args()\n    F.argsPrint(args)\n    return args\n\n\ndef saveNPZ(x, y, name, folder, size):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xa8\xe6\xad\xa3\xe8\xa7\xa3\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92NPZ\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xa7\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n    [in] x:      \xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\n    [in] y:      \xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe6\xad\xa3\xe8\xa7\xa3\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\n    [in] name:   \xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe5\x90\x8d\xe5\x89\x8d\n    [in] folder: \xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\n    [in] size:   \xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xef\xbc\x88\xe6\xad\xa3\xe6\x96\xb9\xe5\xbd\xa2\xe7\x94\xbb\xe5\x83\x8f\xef\xbc\x89\xe3\x81\xae\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\n    """"""\n\n    size_str = \'_\' + str(size).zfill(2) + \'x\' + str(size).zfill(2)\n    num_str = \'_\' + str(x.shape[0]).zfill(6)\n    np.savez(F.getFilePath(folder, name + size_str + num_str), x=x, y=y)\n\n\ndef main(args):\n    # OpenCV\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xa7\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\n    # \xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0\xe3\x82\x92OpenCV\xe3\x81\xae\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\n    ch = IMG.getCh(args.channel)\n    # OpenCV\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xa7\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xa7\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\n    print(\'read images...\')\n    imgs = [cv2.imread(name, ch) for name in args.jpeg if IMG.isImgPath(name)]\n    if len(imgs) == 0:\n        print(\'image get error\')\n        exit(1)\n\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x9c\xa7\xe7\xb8\xae\xe3\x81\x97\xe3\x81\xa6\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x99\xe3\x82\x8b\xef\xbc\x88\xe5\xad\xa6\xe7\xbf\x92\xe3\x81\xae\xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xab\xe7\x9b\xb8\xe5\xbd\x93\xef\xbc\x89\n    print(\'split images...\')\n    x, _ = IMG.splitSQN(\n        IMG.flipN(IMG.encodeDecodeN(imgs, ch, args.quality), args.flip_num),\n        args.img_size, args.round\n    )\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x99\xe3\x82\x8b\xef\xbc\x88\xe6\xad\xa3\xe8\xa7\xa3\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xab\xe7\x9b\xb8\xe5\xbd\x93\xef\xbc\x89\n    y, _ = IMG.splitSQN(IMG.flipN(imgs, args.flip_num),\n                        args.img_size, args.round)\n\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe4\xb8\xa6\xe3\x81\xb3\xe9\xa0\x86\xe3\x82\x92\xe3\x82\xb7\xe3\x83\xa3\xe3\x83\x83\xe3\x83\x95\xe3\x83\xab\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xae\xe9\x85\x8d\xe5\x88\x97\xe3\x82\x92\xe4\xbd\x9c\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\n    # comp\xe3\x81\xa8raw\xe3\x81\xae\xe5\xaf\xbe\xe5\xbf\x9c\xe3\x82\x92\xe5\xb4\xa9\xe3\x81\x95\xe3\x81\xaa\xe3\x81\x84\xe3\x82\x88\xe3\x81\x86\xe3\x81\xab\xe3\x82\xb7\xe3\x83\xa3\xe3\x83\x83\xe3\x83\x95\xe3\x83\xab\xe3\x81\x97\xe3\x81\xaa\xe3\x81\x91\xe3\x82\x8c\xe3\x81\xb0\xe3\x81\xaa\xe3\x82\x89\xe3\x81\xaa\xe3\x81\x84\n    # \xe3\x81\xbe\xe3\x81\x9f\xe3\x80\x81train_size\xe3\x81\xa7\xe7\xab\xaf\xe6\x95\xb0\xe3\x82\x92\xe5\x88\x87\xe3\x82\x8a\xe6\x8d\xa8\xe3\x81\xa6\xe3\x82\x8b\n    # \xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92int8\xe3\x81\x8b\xe3\x82\x89float16\xe3\x81\xab\xe5\xa4\x89\xe3\x81\x88\xe3\x82\x8b\xe3\x81\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe6\x95\xb0\xe3\x81\x8c\xe5\xa4\xa7\xe3\x81\x8d\xe3\x81\x8f\xe3\x81\xaa\xe3\x82\x8b\xe3\x81\xae\xe3\x81\xa7\xe6\xb3\xa8\xe6\x84\x8f\n    print(\'shuffle images...\')\n    dtype = np.float16\n    shuffle = np.random.permutation(range(len(x)))\n    train_size = int(len(x) * args.train_per_all)\n    train_x = IMG.imgs2arr(x[shuffle[:train_size]], dtype=dtype)\n    train_y = IMG.imgs2arr(y[shuffle[:train_size]], dtype=dtype)\n    test_x = IMG.imgs2arr(x[shuffle[train_size:]], dtype=dtype)\n    test_y = IMG.imgs2arr(y[shuffle[train_size:]], dtype=dtype)\n    print(\'train x/y:{0}/{1}\'.format(train_x.shape, train_y.shape))\n    print(\'test  x/y:{0}/{1}\'.format(test_x.shape, test_y.shape))\n\n    # \xe7\x94\x9f\xe6\x88\x90\xe3\x81\x97\xe3\x81\x9f\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92npz\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xa7\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x81\xa8\xe3\x81\x97\xe3\x81\xa6\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n    # \xe3\x81\x93\xe3\x81\x93\xe3\x81\xa7\xe4\xbd\x9c\xe6\x88\x90\xe3\x81\x97\xe3\x81\x9f\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae\xe4\xb8\xad\xe8\xba\xab\xe3\x82\x92\xe7\xa2\xba\xe8\xaa\x8d\xe3\x81\x99\xe3\x82\x8b\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xafnpz2jpg.py\xe3\x82\x92\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe3\x81\xa8\xe3\x82\x88\xe3\x81\x84\n    print(\'save npz...\')\n    saveNPZ(train_x, train_y, \'train\', args.out_path, args.img_size)\n    saveNPZ(test_x, test_y, \'test\', args.out_path, args.img_size)\n\n\nif __name__ == \'__main__\':\n    main(command())\n'"
predict.py,2,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x81\xa8\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92\xe5\x88\xa9\xe7\x94\xa8\xe3\x81\x97\xe3\x81\xa6\xe6\x8e\xa8\xe8\xab\x96\xe5\xae\x9f\xe8\xa1\x8c\xe3\x81\x99\xe3\x82\x8b\'\n#\n\nimport logging\n# basicConfig()\xe3\x81\xaf\xe3\x80\x81 debug()\xe3\x82\x84info()\xe3\x82\x92\xe6\x9c\x80\xe5\x88\x9d\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99""\xe5\x89\x8d""\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99\xe3\x81\x93\xe3\x81\xa8\nlogging.basicConfig(format=\'%(message)s\')\nlogging.getLogger(\'Tools\').setLevel(level=logging.INFO)\n# logging.getLogger(\'Tools\').setLevel(level=logging.DEBUG)\n\nimport cv2\nimport time\nimport argparse\nimport numpy as np\n\nimport chainer\nimport chainer.links as L\nfrom chainer.cuda import to_cpu\n\nfrom Lib.concat_3_images import concat3Images\nimport Tools.imgfunc as IMG\nimport Tools.getfunc as GET\nimport Tools.func as F\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument(\'model\',\n                        help=\'\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe5\xad\xa6\xe7\xbf\x92\xe6\xb8\x88\xe3\x81\xbf\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\')\n    parser.add_argument(\'param\',\n                        help=\'\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\')\n    parser.add_argument(\'jpeg\', nargs=\'+\',\n                        help=\'\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\')\n    parser.add_argument(\'--quality\', \'-q\', type=int, default=5,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe5\x9c\xa7\xe7\xb8\xae\xe7\x8e\x87 [default: 5]\')\n    parser.add_argument(\'--batch\', \'-b\', type=int, default=20,\n                        help=\'\xe3\x83\x9f\xe3\x83\x8b\xe3\x83\x90\xe3\x83\x83\xe3\x83\x81\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba [default: 20]\')\n    parser.add_argument(\'--gpu\', \'-g\', type=int, default=-1,\n                        help=\'GPU ID [default -1]\')\n    parser.add_argument(\'--out_path\', \'-o\', default=\'./result/\',\n                        help=\'\xe7\x94\x9f\xe6\x88\x90\xe7\x89\xa9\xe3\x81\xae\xe4\xbf\x9d\xe5\xad\x98\xe5\x85\x88[default: ./result/]\')\n    args = parser.parse_args()\n    F.argsPrint(args)\n    return args\n\n\ndef encDecWrite(img, ch, quality, out_path=\'./result\', val=-1):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe5\x9c\xa7\xe7\xb8\xae\xe3\x81\xa8\xe4\xbf\x9d\xe5\xad\x98\xe3\x82\x92\xe5\xae\x9f\xe8\xa1\x8c\xe3\x81\x99\xe3\x82\x8b\n    [in] img:      \xe5\x9c\xa7\xe7\xb8\xae\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x84\xe7\x94\xbb\xe5\x83\x8f\n    [in] ch:       \xe5\x9c\xa7\xe7\xb8\xae\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x84\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0\n    [in] quality:  \xe5\x9c\xa7\xe7\xb8\xae\xe7\x8e\x87\xef\xbc\x88\xe4\xbd\x8e\xe3\x81\x84\xe3\x81\xbb\xe3\x81\xa9\xe9\xab\x98\xe5\x9c\xa7\xe7\xb8\xae\xef\xbc\x89\n    [in] out_path: \xe5\x87\xba\xe5\x8a\x9b\xe5\x85\x88\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\n    [in] val:      \xe4\xbf\x9d\xe5\xad\x98\xe6\x99\x82\xe3\x81\xae\xe9\x80\xa3\xe7\x95\xaa\xef\xbc\x88\xe8\xb2\xa0\xe6\x95\xb0\xe3\x81\xa7\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x97\xe3\x81\xaa\xe3\x81\x84\xef\xbc\x89\n    [out] \xe5\x9c\xa7\xe7\xb8\xae\xe6\xb8\x88\xe3\x81\xbf\xe7\x94\xbb\xe5\x83\x8f\n    """"""\n\n    # \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x9c\xa7\xe7\xb8\xae\xe3\x81\x97\xe3\x81\xa6\xe5\x8a\xa3\xe5\x8c\x96\xe3\x81\x95\xe3\x81\x9b\xe3\x82\x8b\n    comp = IMG.encodeDecode(img, IMG.getCh(ch), quality)\n    # \xe6\xaf\x94\xe8\xbc\x83\xe3\x81\xae\xe3\x81\x9f\xe3\x82\x81\xe5\x9c\xa7\xe7\xb8\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n    if(val >= 0):\n        path = F.getFilePath(out_path, \'comp-\' +\n                             str(val * 10).zfill(3), \'.jpg\')\n        cv2.imwrite(path, comp)\n\n    return comp\n\n\ndef predict(model, data, batch, org_shape, rate, gpu):\n    """"""\n    \xe6\x8e\xa8\xe8\xab\x96\xe5\xae\x9f\xe8\xa1\x8c\xe3\x83\xa1\xe3\x82\xa4\xe3\x83\xb3\xe9\x83\xa8\n    [in]  model:     \xe6\x8e\xa8\xe8\xab\x96\xe5\xae\x9f\xe8\xa1\x8c\xe3\x81\xab\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\n    [in]  data:      \xe5\x88\x86\xe5\x89\xb2\xef\xbc\x88IMG.split\xef\xbc\x89\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x82\x82\xe3\x81\xae\n    [in]  batch:     \xe3\x83\x90\xe3\x83\x83\xe3\x83\x81\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\n    [in]  org_shape: \xe5\x88\x86\xe5\x89\xb2\xe5\x89\x8d\xe3\x81\xaeshape\n    [in]  rate:      \xe5\x87\xba\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe6\x8b\xa1\xe5\xa4\xa7\xe7\x8e\x87\n    [in]  gpu:       GPU ID\n    [out] img:       \xe6\x8e\xa8\xe8\xab\x96\xe5\xae\x9f\xe8\xa1\x8c\xe3\x81\xa7\xe5\xbe\x97\xe3\x82\x89\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\x9f\xe6\x88\x90\xe7\x94\xbb\xe5\x83\x8f\n    """"""\n\n    # data\xe3\x81\xab\xe3\x81\xaf\xe5\x9c\xa7\xe7\xb8\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xa8\xe5\x88\x86\xe5\x89\xb2\xe6\x83\x85\xe5\xa0\xb1\xe3\x81\x8c\xe5\x90\xab\xe3\x81\xbe\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3\x82\x8b\xe3\x81\xae\xe3\x81\xa7\xe3\x80\x81\xe5\x88\x86\xe9\x9b\xa2\xe3\x81\x99\xe3\x82\x8b\n    comp, size = data\n    imgs = []\n    st = time.time()\n    # \xe3\x83\x90\xe3\x83\x83\xe3\x83\x81\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\x94\xe3\x81\xa8\xe3\x81\xab\xe5\xad\xa6\xe7\xbf\x92\xe6\xb8\x88\xe3\x81\xbf\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x81\xab\xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x97\xe3\x81\xa6\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\n    for i in range(0, len(comp), batch):\n        x = IMG.imgs2arr(comp[i:i + batch], gpu=gpu)\n        y = model.predictor(x)\n        imgs.extend(IMG.arr2imgs(to_cpu(y.array)))\n\n    print(\'exec time: {0:.2f}[s]\'.format(time.time() - st))\n    # \xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x88\x86\xe5\x89\xb2\xe6\x83\x85\xe5\xa0\xb1\xe3\x82\x92\xe3\x82\x82\xe3\x81\xa8\xe3\x81\xab\xe7\xb5\x90\xe5\x90\x88\xe3\x81\x99\xe3\x82\x8b\n    buf = [np.vstack(imgs[i * size[0]: (i + 1) * size[0]])\n           for i in range(size[1])]\n    img = np.hstack(buf)\n    # \xe5\x87\xba\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xaf\xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae2\xe5\x80\x8d\xe3\x81\xae\xe5\xa4\xa7\xe3\x81\x8d\xe3\x81\x95\xe3\x81\xab\xe3\x81\xaa\xe3\x81\xa3\xe3\x81\xa6\xe3\x81\x84\xe3\x82\x8b\xe3\x81\xae\xe3\x81\xa7\xe5\x8d\x8a\xe5\x88\x86\xe3\x81\xab\xe7\xb8\xae\xe5\xb0\x8f\xe3\x81\x99\xe3\x82\x8b\n    img = IMG.resize(img, 1/rate)\n    # \xe7\xb5\x90\xe5\x90\x88\xe3\x81\x97\xe3\x81\x9f\xe3\x81\xa0\xe3\x81\x91\xe3\x81\xa7\xe3\x81\xaf\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\x8c\xe3\x82\xaa\xe3\x83\xaa\xe3\x82\xb8\xe3\x83\x8a\xe3\x83\xab\xe3\x81\xa8\xe7\x95\xb0\xe3\x81\xaa\xe3\x82\x8b\xe3\x81\xae\xe3\x81\xa7\xe5\x88\x87\xe3\x82\x8a\xe5\x8f\x96\xe3\x82\x8b\n    return img[:org_shape[0], :org_shape[1]]\n\n\ndef main(args):\n    # json\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\x8b\xe3\x82\x89\xe5\xad\xa6\xe7\xbf\x92\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x81\xae\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    p = [\'network\', \'unit\', \'shape\', \'layer_num\',\n         \'shuffle_rate\', \'actfun1\', \'actfun2\']\n    net, unit, shape, layer, sr, af1, af2 = GET.jsonData(args.param, p)\n    af1 = GET.actfun(af1)\n    af2 = GET.actfun(af2)\n    ch, size = shape[:2]\n    # \xe5\xad\xa6\xe7\xbf\x92\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x82\x92\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\n    if net == 0:\n        from Lib.network import JC_DDUU as JC\n    else:\n        from Lib.network2 import JC_UDUD as JC\n\n    model = L.Classifier(\n        JC(n_unit=unit, n_out=ch, rate=sr, actfun1=af1, actfun2=af2)\n    )\n\n    # load_npz\xe3\x81\xaepath\xe6\x83\x85\xe5\xa0\xb1\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x97\xe3\x80\x81\xe5\xad\xa6\xe7\xbf\x92\xe6\xb8\x88\xe3\x81\xbf\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\n    load_path = F.checkModelType(args.model)\n    try:\n        chainer.serializers.load_npz(args.model, model, path=load_path)\n    except:\n        import traceback\n        traceback.print_exc()\n        print(F.fileFuncLine())\n        exit()\n\n    # GPU\xe3\x81\xae\xe8\xa8\xad\xe5\xae\x9a\n    if args.gpu >= 0:\n        chainer.cuda.get_device_from_id(args.gpu).use()\n        model.to_gpu()\n    # else:\n    #     model.to_intel64()\n\n    # \xe9\xab\x98\xe5\x9c\xa7\xe7\xb8\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe7\x94\x9f\xe6\x88\x90\n    ch_flg = IMG.getCh(ch)\n    org_imgs = [cv2.imread(name, ch_flg)\n                for name in args.jpeg if IMG.isImgPath(name)]\n    ed_imgs = [encDecWrite(img, ch, args.quality, args.out_path, i)\n               for i, img in enumerate(org_imgs)]\n    imgs = []\n    with chainer.using_config(\'train\', False):\n        # \xe5\xad\xa6\xe7\xbf\x92\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x82\x92\xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\x94\xe3\x81\xa8\xe3\x81\xab\xe5\xae\x9f\xe8\xa1\x8c\xe3\x81\x99\xe3\x82\x8b\n        for i, ei in enumerate(ed_imgs):\n            img = predict(\n                model, IMG.splitSQ(ei, size),\n                args.batch, ei.shape, sr, args.gpu\n            )\n            # \xe7\x94\x9f\xe6\x88\x90\xe7\xb5\x90\xe6\x9e\x9c\xe3\x82\x92\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n            name = F.getFilePath(\n                args.out_path, \'comp-\' + str(i * 10 + 1).zfill(3), \'.jpg\'\n            )\n            print(\'save:\', name)\n            cv2.imwrite(name, img)\n            imgs.append(img)\n\n    # \xe3\x82\xaa\xe3\x83\xaa\xe3\x82\xb8\xe3\x83\x8a\xe3\x83\xab\xe3\x80\x81\xe9\xab\x98\xe5\x9c\xa7\xe7\xb8\xae\xe3\x80\x81\xe6\x8e\xa8\xe8\xab\x96\xe5\xae\x9f\xe8\xa1\x8c\xe7\xb5\x90\xe6\x9e\x9c\xe3\x82\x92\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x97\xe3\x81\xa6\xe4\xbf\x9d\xe5\xad\x98\xe3\x83\xbb\xe8\xa1\xa8\xe7\xa4\xba\xe3\x81\x99\xe3\x82\x8b\n    c3i = [concat3Images([i, j, k], 50, 333, ch, 1)\n           for i, j, k in zip(org_imgs, ed_imgs, imgs)]\n    for i, img in enumerate(c3i):\n        path = F.getFilePath(\n            args.out_path, \'concat-\' + str(i * 10).zfill(3), \'.jpg\'\n        )\n        cv2.imwrite(path, img)\n        cv2.imshow(path, img)\n        cv2.waitKey()\n\n\nif __name__ == \'__main__\':\n    main(command())\n'"
predict_some_snapshot.py,5,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'\xe8\xa4\x87\xe6\x95\xb0\xe3\x81\xaesnapshoto\xe3\x81\xa8\xe3\x81\xb2\xe3\x81\xa8\xe3\x81\xa4\xe3\x81\xae\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92\xe5\x88\xa9\xe7\x94\xa8\xe3\x81\x97\xe3\x81\xa6snapshot\xe3\x81\xae\xe6\x8e\xa8\xe7\xa7\xbb\xe3\x82\x92\xe5\x8f\xaf\xe8\xa6\x96\xe5\x8c\x96\xe3\x81\x99\xe3\x82\x8b\'\n#\n\nimport logging\n# basicConfig()\xe3\x81\xaf\xe3\x80\x81 debug()\xe3\x82\x84info()\xe3\x82\x92\xe6\x9c\x80\xe5\x88\x9d\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99""\xe5\x89\x8d""\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99\xe3\x81\x93\xe3\x81\xa8\nlogging.basicConfig(format=\'%(message)s\')\nlogging.getLogger(\'Tools\').setLevel(level=logging.INFO)\n\nimport os\nimport cv2\nimport argparse\nimport numpy as np\n\nimport chainer\nimport chainer.links as L\n\nimport Tools.imgfunc as IMG\nimport Tools.getfunc as GET\nimport Tools.func as F\nfrom predict import encDecWrite, predict\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument(\'snapshot_and_json\',\n                        help=\'\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x81\xa8\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae\xe3\x81\x82\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\')\n    parser.add_argument(\'jpeg\', nargs=\'+\',\n                        help=\'\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\')\n    parser.add_argument(\'--quality\', \'-q\', type=int, default=5,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe5\x9c\xa7\xe7\xb8\xae\xe7\x8e\x87 [default: 5]\')\n    parser.add_argument(\'--batch\', \'-b\', type=int, default=20,\n                        help=\'\xe3\x83\x9f\xe3\x83\x8b\xe3\x83\x90\xe3\x83\x83\xe3\x83\x81\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba [default: 20]\')\n    parser.add_argument(\'--img_num\', \'-n\', type=int, default=10,\n                        help=\'\xe5\x88\x87\xe3\x82\x8a\xe5\x87\xba\xe3\x81\x99\xe7\x94\xbb\xe5\x83\x8f\xe6\x95\xb0 [default: 10]\')\n    parser.add_argument(\'--random_seed\', \'-rs\', type=int, default=25,\n                        help=\'\xe4\xb9\xb1\xe6\x95\xb0\xe3\x82\xb7\xe3\x83\xbc\xe3\x83\x89 [default: 25, random: -1]\')\n    parser.add_argument(\'--img_rate\', \'-r\', type=float, default=1,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xae\xe5\x80\x8d\xe7\x8e\x87 [default: 1.0]\')\n    parser.add_argument(\'--gpu\', \'-g\', type=int, default=-1,\n                        help=\'GPU ID [default -1]\')\n    parser.add_argument(\'--out_path\', \'-o\', default=\'./result/\',\n                        help=\'\xe7\x94\x9f\xe6\x88\x90\xe7\x89\xa9\xe3\x81\xae\xe4\xbf\x9d\xe5\xad\x98\xe5\x85\x88[default: ./result/]\')\n    args = parser.parse_args()\n    F.argsPrint(args)\n    return args\n\n\ndef getSnapshotAndParam(folder):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\xe3\x81\x8b\xe3\x82\x89\xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x81\xa8\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    \xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x81\xaf\xe4\xbd\x9c\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe6\x97\xa5\xe6\x99\x82\xe9\xa0\x86\xe3\x81\xab\xe3\x82\xbd\xe3\x83\xbc\xe3\x83\x88\xe3\x81\x99\xe3\x82\x8b\n    [in]  folder:        \xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x81\xa8\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae\xe3\x81\x82\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\n    [out] snapshot_path: \xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\xe3\x81\xae\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [out] param:         \xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\n    """"""\n\n    snapshot_path = []\n    param_path = \'\'\n    for f in os.listdir(folder):\n        name, ext = os.path.splitext(os.path.basename(f))\n        full_path = os.path.join(folder, f)\n        # print(f, name, ext)\n        if(\'.snapshot\' in ext):\n            snapshot_path.append(full_path)\n        elif(\'.json\' in ext):\n            param_path = full_path\n\n    snapshot_path = sorted([x for x in snapshot_path\n                            if os.path.isfile(x)], key=os.path.getmtime)\n\n    return snapshot_path, param_path\n\n\ndef getImage(jpg_path, ch, img_size, img_num, seed):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x93\xe3\x81\xa7\xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe3\x81\xab\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x97\xe3\x81\xa6\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\n    [in]  jpg_path: \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\n    [in]  ch:       \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0\n    [in]  img_size: \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x99\xe3\x82\x8b\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\n    [in]  img_num:  \xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe6\x95\xb0\n    [in]  seed:     \xe4\xb9\xb1\xe6\x95\xb0\xe3\x82\xb7\xe3\x83\xbc\xe3\x83\x89\n    [out] \xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xef\xbc\x88\xe7\xb8\xa6\xe9\x95\xb7\xef\xbc\x89\n    """"""\n\n    ch_flg = IMG.getCh(ch)\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x81\xbf\n    imgs = [cv2.imread(jpg, ch_flg) for jpg in jpg_path if IMG.isImgPath(jpg)]\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x97\n    imgs, size = IMG.splitSQN(imgs, img_size)\n    # \xe3\x81\xbb\xe3\x81\xa8\xe3\x82\x93\xe3\x81\xa9\xe7\x99\xbd\xe3\x81\x84\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe9\x99\xa4\xe5\x8e\xbb\xe3\x81\x97\n    imgs = np.array(IMG.whiteCheckN(imgs))\n    if(seed >= 0):\n        np.random.seed(seed)\n\n    # \xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe3\x81\xab\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    shuffle = np.random.permutation(range(len(imgs)))\n\n    return np.vstack(imgs[shuffle[:img_num]])\n\n\ndef stackImages(imgs, rate):\n    """"""\n    \xe6\x8e\xa8\xe8\xab\x96\xe5\xae\x9f\xe8\xa1\x8c\xe3\x81\xa7\xe5\xbe\x97\xe3\x82\x89\xe3\x82\x8c\xe3\x81\x9f \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe7\xb5\x90\xe5\x90\x88\xe3\x81\x97\xe3\x81\xa6\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x92\xe8\xaa\xbf\xe6\x95\xb4\xe3\x81\x99\xe3\x82\x8b\n    [in]  imgs:    \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in]  rate: \xe3\x83\xaa\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\x99\xe3\x82\x8b\xe5\x80\x8d\xe7\x8e\x87\n    [out] \xe7\xb5\x90\xe5\x90\x88\xe7\x94\xbb\xe5\x83\x8f\n    """"""\n\n    img = np.hstack(\n        [cv2.cvtColor(img, cv2.COLOR_GRAY2RGB) if len(img.shape) < 3 else img\n         for img in imgs]\n    )\n    return IMG.resize(img, rate)\n\n\ndef main(args):\n    # \xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x81\xa8\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    snapshot_path, param = getSnapshotAndParam(args.snapshot_and_json)\n    # json\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\x8b\xe3\x82\x89\xe5\xad\xa6\xe7\xbf\x92\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x81\xae\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    p = [\'network\', \'unit\', \'shape\', \'layer_num\',\n         \'shuffle_rate\', \'actfun1\', \'actfun2\']\n    net, unit, shape, layer, sr, af1, af2 = GET.jsonData(param, p)\n    af1 = GET.actfun(af1)\n    af2 = GET.actfun(af2)\n    ch, size = shape[:2]\n    # \xe6\x8e\xa8\xe8\xab\x96\xe5\xae\x9f\xe8\xa1\x8c\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x93\xe3\x81\xa7\xe7\xb5\x90\xe5\x90\x88\xe3\x81\x99\xe3\x82\x8b\n    img = getImage(args.jpeg, ch, size, args.img_num, args.random_seed)\n    # \xe5\xad\xa6\xe7\xbf\x92\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x82\x92\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\n    if net == 0:\n        from Lib.network import JC_DDUU as JC\n    else:\n        from Lib.network2 import JC_UDUD as JC\n\n    model = L.Classifier(\n        JC(n_unit=unit, n_out=1, layer=layer, rate=sr, actfun1=af1, actfun2=af2)\n    )\n    out_imgs = [img]\n    for s in snapshot_path:\n        # load_npz\xe3\x81\xaepath\xe6\x83\x85\xe5\xa0\xb1\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n        load_path = F.checkModelType(s)\n        # \xe5\xad\xa6\xe7\xbf\x92\xe6\xb8\x88\xe3\x81\xbf\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x81\xae\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x81\xbf\n        try:\n            chainer.serializers.load_npz(s, model, path=load_path)\n        except:\n            import traceback\n            traceback.print_exc()\n            print(F.fileFuncLine())\n            exit()\n\n        # GPU\xe3\x81\xae\xe8\xa8\xad\xe5\xae\x9a\n        if args.gpu >= 0:\n            chainer.cuda.get_device_from_id(args.gpu).use()\n            model.to_gpu()\n        else:\n            model.to_intel64()\n\n        # \xe5\xad\xa6\xe7\xbf\x92\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x82\x92\xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\x94\xe3\x81\xa8\xe3\x81\xab\xe5\xae\x9f\xe8\xa1\x8c\xe3\x81\x99\xe3\x82\x8b\n        ed = encDecWrite(img, ch, args.quality)\n        with chainer.using_config(\'train\', False):\n            out_imgs.append(\n                predict(model, IMG.splitSQ(ed, size),\n                        args.batch, ed.shape, sr, args.gpu)\n            )\n\n    # \xe6\x8e\xa8\xe8\xab\x96\xe5\xae\x9f\xe8\xa1\x8c\xe3\x81\x97\xe3\x81\x9f\xe5\x90\x84\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe7\xb5\x90\xe5\x90\x88\xe3\x81\x97\xe3\x81\xa6\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x92\xe8\xaa\xbf\xe6\x95\xb4\xe3\x81\x99\xe3\x82\x8b\n    img = stackImages(out_imgs, args.img_rate)\n    # \xe7\x94\x9f\xe6\x88\x90\xe7\xb5\x90\xe6\x9e\x9c\xe3\x81\xae\xe8\xa1\xa8\xe7\xa4\xba\n    cv2.imshow(\'predict some snapshots\', img)\n    cv2.waitKey()\n    # \xe7\x94\x9f\xe6\x88\x90\xe7\xb5\x90\xe6\x9e\x9c\xe3\x81\xae\xe4\xbf\x9d\xe5\xad\x98\n    cv2.imwrite(F.getFilePath(args.out_path, \'snapshots.jpg\'), img)\n\n\nif __name__ == \'__main__\':\n    main(command())\n'"
train.py,1,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'\xe5\xad\xa6\xe7\xbf\x92\xe3\x83\xa1\xe3\x82\xa4\xe3\x83\xb3\xe9\x83\xa8\'\n#\n\n\nimport logging\n# basicConfig()\xe3\x81\xaf\xe3\x80\x81 debug()\xe3\x82\x84info()\xe3\x82\x92\xe6\x9c\x80\xe5\x88\x9d\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99""\xe5\x89\x8d""\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99\xe3\x81\x93\xe3\x81\xa8\nlevel = logging.INFO\nlogging.basicConfig(format=\'%(message)s\')\nlogging.getLogger(\'Tools\').setLevel(level=level)\n\nimport argparse\nimport numpy as np\n\nimport chainer\nimport chainer.links as L\nfrom chainer import training\nfrom chainer.training import extensions\n\n\nfrom Lib.plot_report_log import PlotReportLog\nimport Tools.imgfunc as IMG\nimport Tools.getfunc as GET\nimport Tools.func as F\nimport Tools.pruning as pruning\n\n\nclass ResizeImgDataset(chainer.dataset.DatasetMixin):\n    def __init__(self, dataset, rate, dtype=np.float32):\n        self._dataset = dataset\n        self._rate = rate\n        self._dtype = dtype\n        self._len = len(self._dataset)\n\n    def __len__(self):\n        # \xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe6\x95\xb0\xe3\x82\x92\xe8\xbf\x94\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x99\n        return self._len\n\n    def get_example(self, i):\n        # \xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe3\x82\xa4\xe3\x83\xb3\xe3\x83\x87\xe3\x83\x83\xe3\x82\xaf\xe3\x82\xb9\xe3\x82\x92\xe5\x8f\x97\xe3\x81\x91\xe5\x8f\x96\xe3\x81\xa3\xe3\x81\xa6\xe3\x80\x81\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92\xe8\xbf\x94\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x99\n        inputs = self._dataset[i]\n        x, y = inputs\n        y = IMG.arrNx(y, self._rate)\n        return x.astype(self._dtype), y.astype(self._dtype)\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument(\'-i\', \'--in_path\', default=\'./result/\',\n                        help=\'\xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80 [default: ./result/]\')\n    parser.add_argument(\'-n\', \'--network\', type=int, default=0, choices=(0, 1),\n                        help=\'\xe3\x83\x8d\xe3\x83\x83\xe3\x83\x88\xe3\x83\xaf\xe3\x83\xbc\xe3\x82\xaf\xe5\xb1\xa4 [default: 0(DDUU), other: 1(DUDU)]\')\n    parser.add_argument(\'-u\', \'--unit\', type=int, default=2, metavar=\'INT\',\n                        help=\'\xe3\x83\x8d\xe3\x83\x83\xe3\x83\x88\xe3\x83\xaf\xe3\x83\xbc\xe3\x82\xaf\xe3\x81\xae\xe3\x83\xa6\xe3\x83\x8b\xe3\x83\x83\xe3\x83\x88\xe6\x95\xb0 [default: 2]\')\n    parser.add_argument(\'-sr\', \'--shuffle_rate\', type=int, default=2, metavar=\'INT_VAL\',\n                        help=\'PS\xe3\x81\xae\xe6\x8b\xa1\xe5\xa4\xa7\xe7\x8e\x87 [default: 2]\')\n    parser.add_argument(\'-ln\', \'--layer_num\', type=int, default=2, metavar=\'INT\',\n                        help=\'\xe3\x83\x8d\xe3\x83\x83\xe3\x83\x88\xe3\x83\xaf\xe3\x83\xbc\xe3\x82\xaf\xe5\xb1\xa4\xe3\x81\xae\xe6\x95\xb0 [default: 2]\')\n    parser.add_argument(\'-a1\', \'--actfun1\', default=\'relu\',\n                        choices=(\'relu\', \'elu\', \'c_relu\', \'l_relu\',\n                                 \'sigmoid\', \'h_sigmoid\', \'tanh\', \'s_plus\'),\n                        help=\'\xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0(1) [default: relu]\')\n    parser.add_argument(\'-a2\', \'--actfun2\', default=\'sigmoid\',\n                        choices=(\'sigmoid\', \'relu\', \'elu\', \'c_relu\',\n                                 \'l_relu\', \'h_sigmoid\', \'tanh\', \'s_plus\'),\n                        help=\'\xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0(2) [default: sigmoid]\')\n    parser.add_argument(\'-d\', \'--dropout\', type=float, default=0.2, metavar=\'FLOAT\',\n                        help=\'\xe3\x83\x89\xe3\x83\xad\xe3\x83\x83\xe3\x83\x97\xe3\x82\xa2\xe3\x82\xa6\xe3\x83\x88\xe7\x8e\x87\xef\xbc\x880\xe3\x80\x9c0.9\xe3\x80\x810\xe3\x81\xa7\xe4\xb8\x8d\xe4\xbd\xbf\xe7\x94\xa8\xef\xbc\x89[default: 0.2]\')\n    parser.add_argument(\'-opt\', \'--optimizer\', default=\'adam\',\n                        choices=(\'adam\', \'ada_d\', \'ada_g\', \'m_sgd\',\n                                 \'n_ag\', \'rmsp\', \'rmsp_g\', \'sgd\', \'smorms\'),\n                        help=\'\xe3\x82\xaa\xe3\x83\x97\xe3\x83\x86\xe3\x82\xa3\xe3\x83\x9e\xe3\x82\xa4\xe3\x82\xb6 [default: adam]\')\n    parser.add_argument(\'-lf\', \'--lossfun\', default=\'mse\',\n                        choices=(\'mse\', \'mae\', \'ber\', \'gauss_kl\'),\n                        help=\'\xe6\x90\x8d\xe5\xa4\xb1\xe9\x96\xa2\xe6\x95\xb0 [default: mse]\')\n    parser.add_argument(\'-p\', \'--pruning\', type=float, default=0.33, metavar=\'FLOAT\',\n                        help=\'pruning\xe7\x8e\x87\xef\xbc\x88snapshot\xe4\xbd\xbf\xe7\x94\xa8\xe6\x99\x82\xe3\x81\xae\xe3\x81\xbf\xe5\x8a\xb9\xe6\x9e\x9c\xe3\x81\x82\xe3\x82\x8a\xef\xbc\x89 [default: 0.5]\')\n    parser.add_argument(\'-b\', \'--batchsize\', type=int, default=100, metavar=\'INT\',\n                        help=\'\xe3\x83\x9f\xe3\x83\x8b\xe3\x83\x90\xe3\x83\x83\xe3\x83\x81\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba [default: 100]\')\n    parser.add_argument(\'-e\', \'--epoch\', type=int, default=10, metavar=\'INT\',\n                        help=\'\xe5\xad\xa6\xe7\xbf\x92\xe3\x81\xae\xe3\x82\xa8\xe3\x83\x9d\xe3\x83\x83\xe3\x82\xaf\xe6\x95\xb0 [default 10]\')\n    parser.add_argument(\'-f\', \'--frequency\', type=int, default=-1, metavar=\'INT\',\n                        help=\'\xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe5\x91\xa8\xe6\x9c\x9f [default: -1]\')\n    parser.add_argument(\'-g\', \'--gpu_id\', type=int, default=-1, metavar=\'INT\',\n                        help=\'\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8bGPU\xe3\x81\xaeID [default -1]\')\n    parser.add_argument(\'-o\', \'--out_path\', default=\'./result/\',\n                        help=\'\xe7\x94\x9f\xe6\x88\x90\xe7\x89\xa9\xe3\x81\xae\xe4\xbf\x9d\xe5\xad\x98\xe5\x85\x88[default: ./result/]\')\n    parser.add_argument(\'-r\', \'--resume\', default=\'\',\n                        help=\'\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9[default: no use]\')\n    parser.add_argument(\'--noplot\', dest=\'plot\', action=\'store_false\',\n                        help=\'\xe5\xad\xa6\xe7\xbf\x92\xe9\x81\x8e\xe7\xa8\x8b\xe3\x82\x92PNG\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xa7\xe5\x87\xba\xe5\x8a\x9b\xe3\x81\x97\xe3\x81\xaa\xe3\x81\x84\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xab\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\')\n    parser.add_argument(\'--only_check\', action=\'store_true\',\n                        help=\'\xe3\x82\xaa\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\xb3\xe5\xbc\x95\xe6\x95\xb0\xe3\x81\x8c\xe6\xad\xa3\xe3\x81\x97\xe3\x81\x8f\xe8\xa8\xad\xe5\xae\x9a\xe3\x81\x95\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3\x82\x8b\xe3\x81\x8b\xe3\x83\x81\xe3\x82\xa7\xe3\x83\x83\xe3\x82\xaf\xe3\x81\x99\xe3\x82\x8b\')\n    args = parser.parse_args()\n    F.argsPrint(args)\n    return args\n\n\ndef main(args):\n    # \xe5\x90\x84\xe7\xa8\xae\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92\xe3\x83\xa6\xe3\x83\x8b\xe3\x83\xbc\xe3\x82\xaf\xe3\x81\xaa\xe5\x90\x8d\xe5\x89\x8d\xe3\x81\xa7\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe6\x99\x82\xe5\x88\xbb\xe6\x83\x85\xe5\xa0\xb1\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    exec_time = GET.datetimeSHA()\n\n    # Set up a neural network to train\n    # Classifier reports softmax cross entropy loss and accuracy at every\n    # iteration, which will be used by the PrintReport extension below.\n\n    # \xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    actfun1 = GET.actfun(args.actfun1)\n    actfun2 = GET.actfun(args.actfun2)\n    # \xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x82\x92\xe6\xb1\xba\xe5\xae\x9a\xe3\x81\x99\xe3\x82\x8b\n    if args.network == 0:\n        from Lib.network import JC_DDUU as JC\n    else:\n        from Lib.network2 import JC_UDUD as JC\n\n    model = L.Classifier(\n        JC(n_unit=args.unit, layer=args.layer_num, rate=args.shuffle_rate,\n           actfun1=actfun1, actfun2=actfun2, dropout=args.dropout,\n           view=args.only_check),\n        lossfun=GET.lossfun(args.lossfun)\n    )\n    # Accuracy\xe3\x81\xaf\xe4\xbb\x8a\xe5\x9b\x9e\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x97\xe3\x81\xaa\xe3\x81\x84\xe3\x81\xae\xe3\x81\xa7False\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\n    # \xe3\x82\x82\xe3\x81\x97\xe3\x82\x82\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x84\xe3\x81\xae\xe3\x81\xa7\xe3\x81\x82\xe3\x82\x8c\xe3\x81\xb0\xe3\x80\x81\xe8\x87\xaa\xe5\x88\x86\xe3\x81\xa7Accuracy\xe3\x82\x92\xe8\xa9\x95\xe4\xbe\xa1\xe3\x81\x99\xe3\x82\x8b\xe9\x96\xa2\xe6\x95\xb0\xe3\x82\x92\xe4\xbd\x9c\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\xe5\xbf\x85\xe8\xa6\x81\xe3\x81\x82\xe3\x82\x8a\xef\xbc\x9f\n    model.compute_accuracy = False\n\n    # Setup an optimizer\n    optimizer = GET.optimizer(args.optimizer).setup(model)\n\n    # Load dataset\n    train, test, _ = GET.imgData(args.in_path)\n    train = ResizeImgDataset(train, args.shuffle_rate)\n    test = ResizeImgDataset(test, args.shuffle_rate)\n    # predict.py\xe3\x81\xa7\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x82\x92\xe6\xb1\xba\xe5\xae\x9a\xe3\x81\x99\xe3\x82\x8b\xe9\x9a\x9b\xe3\x81\xab\xe5\xbf\x85\xe8\xa6\x81\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe8\xa8\x98\xe6\x86\xb6\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x8a\xe3\x81\x8f\n    model_param = F.args2dict(args)\n    model_param[\'shape\'] = train[0][0].shape\n\n    train_iter = chainer.iterators.SerialIterator(train, args.batchsize)\n    test_iter = chainer.iterators.SerialIterator(test, args.batchsize,\n                                                 repeat=False, shuffle=False)\n\n    # Set up a trainer\n    updater = training.StandardUpdater(\n        train_iter, optimizer, device=args.gpu_id\n    )\n    trainer = training.Trainer(\n        updater, (args.epoch, \'epoch\'), out=args.out_path\n    )\n\n    # Evaluate the model with the test dataset for each epoch\n    trainer.extend(extensions.Evaluator(test_iter, model, device=args.gpu_id))\n\n    # Dump a computational graph from \'loss\' variable at the first iteration\n    # The ""main"" refers to the target link of the ""main"" optimizer.\n    trainer.extend(\n        extensions.dump_graph(\'main/loss\', out_name=exec_time + \'_graph.dot\')\n    )\n\n    # Take a snapshot for each specified epoch\n    frequency = args.epoch if args.frequency == -1 else max(1, args.frequency)\n    trainer.extend(\n        extensions.snapshot(filename=exec_time + \'_{.updater.epoch}.snapshot\'),\n        trigger=(frequency, \'epoch\')\n    )\n\n    # Write a log of evaluation statistics for each epoch\n    trainer.extend(extensions.LogReport(log_name=exec_time + \'.log\'))\n    # trainer.extend(extensions.observe_lr())\n\n    # Save two plot images to the result dir\n    if args.plot and extensions.PlotReport.available():\n        trainer.extend(\n            PlotReportLog([\'main/loss\', \'validation/main/loss\'],\n                          \'epoch\', file_name=\'loss.png\')\n        )\n\n        # trainer.extend(\n        #     PlotReportLog([\'lr\'],\n        #                   \'epoch\', file_name=\'lr.png\', val_pos=(-80, -60))\n        # )\n\n    # Print selected entries of the log to stdout\n    # Here ""main"" refers to the target link of the ""main"" optimizer again, and\n    # ""validation"" refers to the default name of the Evaluator extension.\n    # Entries other than \'epoch\' are reported by the Classifier link, called by\n    # either the updater or the evaluator.\n    trainer.extend(extensions.PrintReport([\n        \'epoch\',\n        \'main/loss\',\n        \'validation/main/loss\',\n        # \'lr\',\n        \'elapsed_time\'\n    ]))\n\n    # Print a progress bar to stdout\n    trainer.extend(extensions.ProgressBar())\n\n    # Resume from a snapshot\n    if args.resume:\n        chainer.serializers.load_npz(args.resume, trainer)\n        # Set pruning\n        # http://tosaka2.hatenablog.com/entry/2017/11/17/194051\n        masks = pruning.create_model_mask(model, args.pruning, args.gpu_id)\n        trainer.extend(pruning.pruned(model, masks))\n\n    # Make a specified GPU current\n    if args.gpu_id >= 0:\n        chainer.backends.cuda.get_device_from_id(args.gpu_id).use()\n        # Copy the model to the GPU\n        model.to_gpu()\n        chainer.global_config.autotune = True\n    else:\n        model.to_intel64()\n\n    # predict.py\xe3\x81\xa7\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x81\xae\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80json\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xa7\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n    if args.only_check is False:\n        F.dict2json(args.out_path, exec_time + \'_train\', model_param)\n\n    # Run the training\n    trainer.run()\n\n    # \xe6\x9c\x80\xe5\xbe\x8c\xe3\x81\xab\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x82\x92\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n    # \xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x82\x92\xe4\xbd\xbf\xe3\x81\xa3\xe3\x81\xa6\xe3\x82\x82\xe3\x81\x84\xe3\x81\x84\xe3\x81\x8c\xe3\x80\x81\n    # \xe3\x82\xb9\xe3\x83\x8a\xe3\x83\x83\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x81\xaf\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\x8c\xe5\xa4\xa7\xe3\x81\x8d\xe3\x81\x84\n    chainer.serializers.save_npz(\n        F.getFilePath(args.out_path, exec_time, \'.model\'),\n        model\n    )\n\n\nif __name__ == \'__main__\':\n    main(command())\n'"
Lib/concat_3_images.py,5,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'3\xe6\x9e\x9a\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\xef\xbc\x88org, comp, restration\xef\xbc\x89\'\n#\n\nimport os\nimport sys\nimport cv2\nimport argparse\nimport numpy as np\n\n[sys.path.append(d) for d in [\'./Tools/\', \'../Tools/\'] if os.path.isdir(d)]\nfrom func import argsPrint, getFilePath\n[sys.path.append(d) for d in [\'./Lib/\', \'../Lib/\'] if os.path.isdir(d)]\nimport imgfunc as IMG\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument(\'image\', nargs=\'+\',\n                        help=\'\xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80 (default: ./result/)\')\n    parser.add_argument(\'-o\', \'--offset\', type=int, default=50,\n                        help=\'\xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80 (default: ./result/)\')\n    parser.add_argument(\'-s\', \'--img_width\', type=int, default=333,\n                        help=\'\xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80 (default: ./result/)\')\n    parser.add_argument(\'-r\', \'--img_rate\', type=float, default=1,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xae\xe5\x80\x8d\xe7\x8e\x87\xef\xbc\x88default: 1\xef\xbc\x89\')\n    parser.add_argument(\'--channel\', \'-c\', type=int, default=1,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0\xef\xbc\x88default: 1 channel\xef\xbc\x89\')\n    parser.add_argument(\'-op\', \'--out_path\', default=\'./result/\',\n                        help=\'\xe3\x83\xbb (default: ./result/)\')\n    return parser.parse_args()\n\n\ndef titleInsert(img, text, header_size,\n                color=(255, 255, 255), org=(10, 20), scale=0.5, thick=1):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe4\xb8\x8a\xe9\x83\xa8\xe3\x81\xab\xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe7\xb5\x90\xe5\x90\x88\xe3\x81\x99\xe3\x82\x8b\n    [in] img:         \xe7\xb5\x90\xe5\x90\x88\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\n    [in] text:        \xe7\xb5\x90\xe5\x90\x88\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\n    [in] header_size: \xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe6\x9b\xb8\xe3\x81\x8d\xe8\xbe\xbc\xe3\x82\x80\xe5\xa0\xb4\xe6\x89\x80\xe3\x81\xae\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\n    [in] color:       \xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe6\x9b\xb8\xe3\x81\x8d\xe8\xbe\xbc\xe3\x82\x80\xe5\xa0\xb4\xe6\x89\x80\xe3\x81\xae\xe8\x89\xb2\n    [in] org:         \xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe6\x9b\xb8\xe3\x81\x8d\xe8\xbe\xbc\xe3\x82\x80\xe4\xbd\x8d\xe7\xbd\xae\n    [in] scale:       \xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xae\xe3\x82\xb9\xe3\x82\xb1\xe3\x83\xbc\xe3\x83\xab\n    [in] thick:       \xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xae\xe5\xa4\xaa\xe3\x81\x95\n    [out] \xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\xe3\x81\x8c\xe4\xb8\x8a\xe9\x83\xa8\xe3\x81\xab\xe7\xb5\x90\xe5\x90\x88\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\n    """"""\n\n    if(len(img.shape) == 2):\n        header = np.zeros(header_size[:2], dtype=np.uint8)\n    else:\n        header = np.zeros(header_size, dtype=np.uint8)\n\n    img = np.vstack([header, img])\n    return cv2.putText(img, text, org, cv2.FONT_HERSHEY_SIMPLEX,\n                       scale, color, thick, cv2.LINE_AA)\n\n\ndef stackImages(imgs, thick=1, color=(0, 0, 0), flg=cv2.BORDER_CONSTANT):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe6\xa8\xaa\xe3\x81\xab\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\n    [in] imgs:  \xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in] thick: \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x8c\xba\xe5\x88\x87\xe3\x82\x8b\xe7\xb7\x9a\xe3\x81\xae\xe5\xa4\xaa\xe3\x81\x95\n    [in] color: \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x8c\xba\xe5\x88\x87\xe3\x82\x8b\xe7\xb7\x9a\xe3\x81\xae\xe8\x89\xb2\n    [in] flg:   \xe5\xa2\x83\xe7\x95\x8c\xe7\xb7\x9a\xe3\x81\xae\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [out] \xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\n    """"""\n\n    imgs = [cv2.copyMakeBorder(img, 0, thick, 0, thick, flg, value=color)\n            for img in imgs]\n    return np.hstack(imgs)\n\n\ndef concat3Images(imgs, start_pos, img_width, ch, rate,\n                  text=[\'[Original]\', \'[Compression]\', \'[Restoration]\']):\n    """"""\n    3\xe6\x9e\x9a\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe4\xbb\xbb\xe6\x84\x8f\xe3\x81\xae\xe9\x83\xa8\xe5\x88\x86\xe5\x88\x87\xe3\x82\x8a\xe6\x8a\x9c\xe3\x81\x8d\xe3\x80\x81\xe3\x81\x9d\xe3\x81\xae\xe4\xb8\x8a\xe9\x83\xa8\xe3\x81\xab\xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\xe3\x81\x97\xe3\x80\x81\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\n    [in] imgs:      \xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in] start_pos: \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x88\x87\xe3\x82\x8a\xe6\x8a\x9c\xe3\x81\x8f\xe9\x96\x8b\xe5\xa7\x8b\xe3\x83\x94\xe3\x82\xaf\xe3\x82\xbb\xe3\x83\xab\n    [in] img_width: \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x88\x87\xe3\x82\x8a\xe6\x8a\x9c\xe3\x81\x8f\xe5\xb9\x85\xe3\x83\x94\xe3\x82\xaf\xe3\x82\xbb\xe3\x83\xab\n    [in] ch:        \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0\n    [in] rate:      \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe7\xb8\xae\xe5\xb0\xba\n    [in] text:      \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xab\xe6\x8c\xbf\xe5\x85\xa5\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x86\xe3\x82\xad\xe3\x82\xb9\xe3\x83\x88\n    [out] \xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\n    """"""\n\n    height = np.min([i.shape[0] for i in imgs])\n    end_pos = start_pos + img_width\n    if(ch == 1):\n        imgs = [i[:height, start_pos:end_pos] for i in imgs]\n    else:\n        imgs = [i[:height, start_pos:end_pos, :] for i in imgs]\n\n    imgs = [IMG.resize(i, rate) for i in imgs]\n    header_size = (30, int(img_width * rate), 3)\n    imgs = [titleInsert(i, t, header_size) for i, t in zip(imgs, text)]\n    return stackImages(imgs, thick=1, color=(0, 0, 0))\n\n\ndef main(args):\n    ch = IMG.getCh(args.channel)\n    imgs = [cv2.imread(name, ch) for name in args.image]\n    #text = [\'[hitotsume]\', \'[futatsume]\', \'[mittsume]\']\n    img = concat3Images(\n        imgs, args.offset, args.img_width, args.channel, args.img_rate\n    )\n\n    cv2.imshow(\'test\', img)\n    cv2.waitKey()\n    cv2.imwrite(getFilePath(args.out_path, \'concat\', \'.jpg\'), img)\n\n\nif __name__ == \'__main__\':\n    args = command()\n    argsPrint(args)\n    main(args)\n'"
Lib/network.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\nhelp = \'jpegcomp\xe3\x81\xae\xe3\x83\x8d\xe3\x83\x83\xe3\x83\x88\xe3\x83\xaf\xe3\x83\xbc\xe3\x82\xaf\xe9\x83\xa8\xe5\x88\x86\'\n#\n\nimport time\n\nfrom chainer import Chain\nimport chainer.initializers as I\nimport chainer.functions as F\nimport chainer.links as L\n\n\nclass DownSampleBlock(Chain):\n    def __init__(self, n_unit, ksize, stride, pad,\n                 actfun=None, dropout=0, wd=0.02):\n\n        super(DownSampleBlock, self).__init__()\n        with self.init_scope():\n            self.cnv = L.Convolution2D(\n                None, n_unit, ksize=ksize, stride=stride, pad=pad, initialW=I.Normal(wd)\n            )\n            self.brn = L.BatchRenormalization(n_unit)\n\n        self.actfun = actfun\n        self.dropout_ratio = dropout\n\n    def __call__(self, x):\n        h = self.actfun(self.brn(self.cnv(x)))\n        if self.dropout_ratio > 0:\n            h = F.dropout(h, self.dropout_ratio)\n\n        return h\n\n\nclass UpSampleBlock(Chain):\n    def __init__(self, n_unit1, n_unit2, ksize, stride, pad,\n                 actfun=None, dropout=0.0, wd=0.02, rate=2):\n\n        super(UpSampleBlock, self).__init__()\n        with self.init_scope():\n            self.cnv = L.Convolution2D(\n                None, n_unit1, ksize=ksize, stride=stride, pad=pad, initialW=I.Normal(wd)\n            )\n            self.brn = L.BatchRenormalization(n_unit2)\n\n        self.actfun = actfun\n        self.dropout_ratio = dropout\n        self.rate = rate\n\n    def __call__(self, x):\n        h = self.actfun(self.brn(self.PS(self.cnv(x))))\n        if self.dropout_ratio > 0:\n            h = F.dropout(h, self.dropout_ratio)\n\n        return h\n\n    def PS(self, h):\n        """"""\n        ""P""ixcel""S""huffler\n        Deconvolution\xe3\x81\xae\xe9\xab\x98\xe9\x80\x9f\xe7\x89\x88\n        """"""\n\n        batchsize, in_ch, in_h, in_w = h.shape\n        out_ch = int(in_ch / (self.rate ** 2))\n        out_h = in_h * self.rate\n        out_w = in_w * self.rate\n        out = F.reshape(h, (batchsize, self.rate, self.rate, out_ch, in_h, in_w))\n        out = F.transpose(out, (0, 3, 4, 1, 5, 2))\n        out = F.reshape(out, (batchsize, out_ch, out_h, out_w))\n        return out\n\n\nclass JC_DDUU(Chain):\n    def __init__(self, n_unit=128, n_out=1, rate=4,\n                 layer=3, actfun1=F.relu, actfun2=F.sigmoid,\n                 dropout=0.0, view=False):\n        """"""\n        [in] n_unit:    \xe4\xb8\xad\xe9\x96\x93\xe5\xb1\xa4\xe3\x81\xae\xe3\x83\xa6\xe3\x83\x8b\xe3\x83\x83\xe3\x83\x88\xe6\x95\xb0\n        [in] n_out:     \xe5\x87\xba\xe5\x8a\x9b\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\n        [in] actfun1: \xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0\xef\xbc\x88Layer A\xe7\x94\xa8\xef\xbc\x89\n        [in] actfun2: \xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0\xef\xbc\x88Layer B\xe7\x94\xa8\xef\xbc\x89\n        """"""\n\n        unit1 = n_unit\n        unit2 = n_unit * 2\n        unit4 = n_unit * 4\n        unit8 = n_unit * 8\n        nout = (rate**2) * n_out\n\n        super(JC_DDUU, self).__init__()\n        with self.init_scope():\n            # D: n_unit, ksize, stride, pad,\n            #    actfun=None, dropout=0, wd=0.02\n            self.d1 = DownSampleBlock(unit1, 5, 2, 2, actfun1, dropout)\n            self.d2 = DownSampleBlock(unit2, 5, 2, 2, actfun1, dropout)\n            self.d3 = DownSampleBlock(unit4, 5, 2, 2, actfun1, dropout)\n            self.d4 = DownSampleBlock(unit8, 5, 2, 2, actfun1, dropout)\n            self.d5 = DownSampleBlock(unit8, 3, 1, 1, actfun1, dropout)\n\n            # U: n_unit1, n_unit2, ksize, stride, pad,\n            #    actfun=None, dropout=0, wd=0.02, rate=2\n            self.u1 = UpSampleBlock(unit4, unit1, 5, 1, 2, actfun2, dropout)\n            self.u2 = UpSampleBlock(unit4, unit1, 5, 1, 2, actfun2, dropout)\n            self.u3 = UpSampleBlock(unit4, unit1, 5, 1, 2, actfun2, dropout)\n            self.u4 = UpSampleBlock(unit4, unit1, 5, 1, 2, actfun2, dropout)\n            self.u5 = UpSampleBlock(nout, n_out, 5, 1, 2, actfun2, 0, 0.02, rate)\n\n        self.view = view\n        self.cnt = 0\n        self.timer = 0\n\n        print(\'[Network info]\', self.__class__.__name__)\n        print(\'  Unit:\\t{0}\\n  Out:\\t{1}\\n  Drop out:\\t{2}\\n  Act Func:\\t{3}, {4}\'.format(\n            n_unit, n_out, dropout, actfun1.__name__, actfun2.__name__)\n        )\n\n    def block(self, f, x):\n        if self.view:\n            print(\'{0:2}: {1}\\t{2:5.3f} s\\t{3} \'.format(\n                self.cnt, f.__class__.__name__, time.time()-self.timer, x.shape))\n            self.cnt += 1\n\n        return f(x)\n\n    def __call__(self, x):\n        if self.view:\n            self.timer = time.time()\n\n        hc = []\n        ha = self.block(self.d1, x)\n        hb = self.block(self.d2, ha)\n        hc = self.block(self.d3, hb)\n        hd = self.block(self.d4, hc)\n        he = self.block(self.d5, hd)\n\n        h = self.block(self.u1, F.concat([hd, he]))\n        h = self.block(self.u2, F.concat([hc, h]))\n        h = self.block(self.u3, F.concat([hb, h]))\n        h = self.block(self.u4, F.concat([ha, h]))\n        y = self.block(self.u5, h)\n\n        if self.view:\n            print(\'Output {0:5.3f} s: {1}\'.format(time.time()-self.timer, y.shape))\n            exit()\n        else:\n            return y\n'"
Lib/network2.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\nhelp = \'jpegcomp\xe3\x81\xae\xe3\x83\x8d\xe3\x83\x83\xe3\x83\x88\xe3\x83\xaf\xe3\x83\xbc\xe3\x82\xaf\xe9\x83\xa8\xe5\x88\x86\xe3\x81\x9d\xe3\x81\xae2\'\n#\n\nfrom chainer import Chain\nimport chainer.functions as F\nfrom Lib.network import DownSampleBlock, UpSampleBlock\n\n\nclass JC_UDUD(Chain):\n    def __init__(self, n_unit=128, n_out=1, rate=4,\n                 layer=3, actfun1=F.relu, actfun2=F.sigmoid,\n                 dropout=0.0, view=False):\n        """"""\n        [in] n_unit:    \xe4\xb8\xad\xe9\x96\x93\xe5\xb1\xa4\xe3\x81\xae\xe3\x83\xa6\xe3\x83\x8b\xe3\x83\x83\xe3\x83\x88\xe6\x95\xb0\n        [in] n_out:     \xe5\x87\xba\xe5\x8a\x9b\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\n        [in] layer:     \xe4\xb8\xad\xe9\x96\x93\xe5\xb1\xa4\xe3\x81\xae\xe6\x95\xb0\n        [in] actfun1: \xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0\xef\xbc\x88Layer A\xe7\x94\xa8\xef\xbc\x89\n        [in] actfun2: \xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0\xef\xbc\x88Layer B\xe7\x94\xa8\xef\xbc\x89\n        """"""\n\n        unit1 = n_unit\n        unit2 = n_unit*2\n        unit4 = n_unit*4\n\n        super(JC_UDUD, self).__init__()\n        with self.init_scope():\n            self.d1a = DownSampleBlock(unit1, 5, 2, 2, actfun1)\n            self.d1b = DownSampleBlock(unit2, 3, 1, 1, actfun1, dropout)\n            self.u1c = UpSampleBlock(unit4, unit1, 5, 1, 2, actfun2)\n            if(layer > 2):\n                self.d2a = DownSampleBlock(unit1, 5, 2, 2, actfun1)\n                self.d2b = DownSampleBlock(unit2, 3, 1, 1, actfun1, dropout)\n                self.u2c = UpSampleBlock(unit4, unit1, 5, 1, 2, actfun2)\n\n            if(layer > 3):\n                self.d3a = DownSampleBlock(unit1, 5, 2, 2, actfun1)\n                self.d3b = DownSampleBlock(unit2, 3, 1, 1, actfun1, dropout)\n                self.u3c = UpSampleBlock(unit4, unit1, 5, 1, 2, actfun2)\n\n            if(layer > 4):\n                self.d4a = DownSampleBlock(unit1, 5, 2, 2, actfun1)\n                self.d4b = DownSampleBlock(unit2, 3, 1, 1, actfun1, dropout)\n                self.u4c = UpSampleBlock(unit4, unit1, 5, 1, 2, actfun2)\n\n            if(layer > 5):\n                self.da = DownSampleBlock(unit1, 5, 2, 2, actfun1)\n                self.d5b = DownSampleBlock(unit2, 3, 1, 1, actfun1, dropout)\n                self.d5c = UpSampleBlock(unit4, unit1, 5, 1, 2, actfun2)\n\n            self.dNa = DownSampleBlock(unit4, 5, 2, 2, actfun1)\n            self.dNb = UpSampleBlock(unit4, unit1, 3, 1, 1, actfun2)\n            self.uNc = UpSampleBlock(rate**2, 1, 5, 1, 2, actfun2, rate=rate)\n\n        self.layer = layer\n        self.view = view\n\n        print(\'[Network info]\', self.__class__.__name__)\n        print(\'  Unit:\\t{0}\\n  Out:\\t{1}\\n  Layer:\\t{2}\\n  Drop out:\\t{3}\\nAct Func:\\t{4}, {5}\'.format(\n            n_unit, n_out, layer, dropout, actfun1.__name__, actfun2.__name__)\n        )\n\n    def block(self, a, b, c, x):\n        if self.view:\n            print(\'D\', x.shape)\n\n        h = a(x)\n        if self.view:\n            print(\'D\', h.shape)\n\n        h = b(h)\n        if self.view:\n            print(\'U\', h.shape)\n\n        h = c(h)\n        return h\n\n    def __call__(self, x):\n        hc = []\n        h = self.block(self.d1a, self.d1b, self.u1c, x)\n        hc.append(h)\n\n        if(self.layer > 2):\n            h = self.block(self.d2a, self.d2b, self.u2c, h)\n            hc.append(h)\n\n        if(self.layer > 3):\n            h = self.block(self.d3a, self.d3b, self.u3c, h)\n            hc.append(h)\n\n        if(self.layer > 4):\n            h = self.block(self.d4a, self.d4b, self.u4c, h)\n            hc.append(h)\n\n        if(self.layer > 5):\n            h = self.block(self.d5a, self.d5b, self.u5c, h)\n            hc.append(h)\n\n        h = F.concat(hc)\n        y = self.block(self.dNa, self.dNb, self.uNc, h)\n        if self.view:\n            print(\'Y\', y.shape)\n            exit()\n\n        return y\n'"
Lib/plot_report_log.py,0,"b'import json\nfrom os import path\nimport warnings\n\nimport numpy\nimport six\n\nfrom chainer import reporter\nfrom chainer import serializer as serializer_module\nfrom chainer.training import extension\nfrom chainer.training import trigger as trigger_module\n\n\ntry:\n    import matplotlib  # NOQA\n\n    _available = True\n\nexcept (ImportError, TypeError):\n    _available = False\n\n\ndef _check_available():\n    if not _available:\n        warnings.warn(\'matplotlib is not installed on your environment, \'\n                      \'so nothing will be plotted at this time. \'\n                      \'Please install matplotlib to plot figures.\\n\\n\'\n                      \'  $ pip install matplotlib\\n\')\n\n\nclass PlotReportLog(extension.Extension):\n\n    """"""Trainer extension to output plots.\n\n    This extension accumulates the observations of the trainer to\n    :class:`~chainer.DictSummary` at a regular interval specified by a supplied\n    trigger, and plot a graph with using them.\n\n    There are two triggers to handle this extension. One is the trigger to\n    invoke this extension, which is used to handle the timing of accumulating\n    the results. It is set to ``1, \'iteration\'`` by default. The other is the\n    trigger to determine when to emit the result. When this trigger returns\n    True, this extension appends the summary of accumulated values to the list\n    of past summaries, and writes the list to the log file. Then, this\n    extension makes a new fresh summary object which is used until the next\n    time that the trigger fires.\n\n    It also adds ``\'epoch\'`` and ``\'iteration\'`` entries to each result\n    dictionary, which are the epoch and iteration counts at the output.\n\n    .. warning::\n\n        If your environment needs to specify a backend of matplotlib\n        explicitly, please call ``matplotlib.use`` before calling\n        ``trainer.run``. For example:\n\n        .. code-block:: python\n\n            import matplotlib\n            matplotlib.use(\'Agg\')\n\n            trainer.extend(\n                extensions.PlotReport([\'main/loss\', \'validation/main/loss\'],\n                                      \'epoch\', file_name=\'loss.png\'))\n            trainer.run()\n\n        Then, once one of instances of this extension is called,\n        ``matplotlib.use`` will have no effect.\n\n    For the details, please see here:\n    http://matplotlib.org/faq/usage_faq.html#what-is-a-backend\n\n    Args:\n        y_keys (iterable of strs): Keys of values regarded as y. If this is\n            None, nothing is output to the graph.\n        x_key (str): Keys of values regarded as x. The default value is\n            \'iteration\'.\n        trigger: Trigger that decides when to aggregate the result and output\n            the values. This is distinct from the trigger of this extension\n            itself. If it is a tuple in the form ``<int>, \'epoch\'`` or ``<int>,\n            \'iteration\'``, it is passed to :class:`IntervalTrigger`.\n        postprocess: Callback to postprocess the result dictionaries. Figure\n            object, Axes object, and all plot data are passed to this callback\n            in this order. This callback can modify the figure.\n        file_name (str): Name of the figure file under the output directory.\n            It can be a format string.\n        marker (str): The marker used to plot the graph. Default is ``\'x\'``. If\n            ``None`` is given, it draws with no markers.\n        grid (bool): Set the axis grid on if True. Default is True.\n\n    """"""\n\n    def __init__(self, y_keys, x_key=\'iteration\', trigger=(1, \'epoch\'),\n                 postprocess=None, file_name=\'plot.png\', marker=\'x\',\n                 grid=True, val_pos=(-80, 60)):\n\n        _check_available()\n\n        self._x_key = x_key\n        if isinstance(y_keys, str):\n            y_keys = (y_keys,)\n\n        self._y_keys = y_keys\n        self._trigger = trigger_module.get_trigger(trigger)\n        self._file_name = file_name\n        self._marker = marker\n        self._grid = grid\n        self._postprocess = postprocess\n        self._init_summary()\n        self._data = {k: [] for k in y_keys}\n        self.val_pos = val_pos\n\n    @staticmethod\n    def available():\n        _check_available()\n        return _available\n\n    def __call__(self, trainer):\n        if _available:\n            # Dynamically import pyplot to call matplotlib.use()\n            # after importing chainer.training.extensions\n            import matplotlib.pyplot as plt\n        else:\n            return\n\n        keys = self._y_keys\n        observation = trainer.observation\n        summary = self._summary\n\n        if keys is None:\n            summary.add(observation)\n        else:\n            summary.add({k: observation[k] for k in keys if k in observation})\n\n        if self._trigger(trainer):\n            stats = self._summary.compute_mean()\n            stats_cpu = {}\n            for name, value in six.iteritems(stats):\n                stats_cpu[name] = float(value)  # copy to CPU\n\n            updater = trainer.updater\n            stats_cpu[\'epoch\'] = updater.epoch\n            stats_cpu[\'iteration\'] = updater.iteration\n            x = stats_cpu[self._x_key]\n            data = self._data\n\n            for k in keys:\n                if k in stats_cpu:\n                    data[k].append((x, stats_cpu[k]))\n\n            f = plt.figure()\n            a = f.add_subplot(111)\n            a.set_xlabel(self._x_key)\n            if self._grid:\n                # \xe8\xbf\xbd\xe8\xa8\x98\xef\xbc\x88\xe3\x82\xb0\xe3\x83\xaa\xe3\x83\x83\xe3\x83\x89\xe7\xb7\x9a\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\xef\xbc\x89\n                a.grid(which=\'major\', color=\'gray\', linestyle=\':\')\n                a.grid(which=\'minor\', color=\'gray\', linestyle=\':\')\n                # a.grid()\n\n            for k in keys:\n                xy = data[k]\n                if len(xy) == 0:\n                    continue\n\n                xy = numpy.array(xy)\n                # \xe8\xbf\xbd\xe8\xa8\x98\xef\xbc\x88\xe5\xaf\xbe\xe6\x95\xb0\xe8\xa1\xa8\xe7\xa4\xba\xe3\x81\xab\xe5\xa4\x89\xe6\x9b\xb4\xef\xbc\x89\n                plt.yscale(""log"")\n                a.plot(xy[:, 0], xy[:, 1], marker=self._marker, label=k)\n\n            if a.has_data():\n                if self._postprocess is not None:\n                    self._postprocess(f, a, summary)\n\n                # \xe8\xbf\xbd\xe8\xa8\x98\xef\xbc\x88validation\xe3\x81\xae\xe6\x9c\x80\xe6\x96\xb0\xe3\x81\xae\xe5\x80\xa4\xe3\x82\x92\xe8\xa1\xa8\xe7\xa4\xba\xef\xbc\x89\n                style = \'arc,angleA=0,armA=60,rad=10\'\n                a.annotate(\'{0:8.6f}\'.format(xy[-1, 1]),\n                           xy=(xy[-1]), xycoords=\'data\',\n                           xytext=self.val_pos, textcoords=\'offset points\',\n                           bbox=dict(boxstyle=\'round\', fc=\'0.8\'),\n                           arrowprops=dict(arrowstyle=\'->\', connectionstyle=style))\n\n                l = a.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\n                f.tight_layout()\n                f.savefig(path.join(trainer.out, self._file_name),\n                          bbox_extra_artists=(l,), bbox_inches=\'tight\')\n\n            plt.close()\n            self._init_summary()\n\n    def serialize(self, serializer):\n        if isinstance(serializer, serializer_module.Serializer):\n            serializer(\'_plot_{}\'.format(self._file_name),\n                       json.dumps(self._data))\n\n        else:\n            self._data = json.loads(\n                serializer(\'_plot_{}\'.format(self._file_name), \'\'))\n\n    def _init_summary(self):\n        self._summary = reporter.DictSummary()\n'"
Tools/concat.py,6,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'\xe8\xa4\x87\xe6\x95\xb0\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe4\xbb\xbb\xe6\x84\x8f\xe3\x81\xae\xe8\xa1\x8c\xe5\x88\x97\xe3\x81\xa7\xe7\xb5\x90\xe5\x90\x88\xe3\x81\x99\xe3\x82\x8b\'\n#\n\nimport os\nimport sys\nimport cv2\nimport argparse\nimport numpy as np\n\n[sys.path.append(d) for d in [\'./Tools/\', \'../Tools/\'] if os.path.isdir(d)]\nimport func as F\nimport imgfunc as IMG\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument(\'jpeg\', nargs=\'+\',\n                        help=\'\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\')\n    parser.add_argument(\'--out_path\', \'-o\', default=\'./result/\',\n                        help=\'\xe7\x94\x9f\xe6\x88\x90\xe7\x89\xa9\xe3\x81\xae\xe4\xbf\x9d\xe5\xad\x98\xe5\x85\x88 [default: ./result/]\')\n    parser.add_argument(\'--row\', \'-r\', type=int, default=-1,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\xe8\xa1\x8c\xef\xbc\x88\xe8\xb2\xa0\xe6\x95\xb0\xe3\x81\xa7\xe8\x87\xaa\xe5\x8b\x95\xe8\xa8\x88\xe7\xae\x97\xef\xbc\x89 [default: -1]\')\n    parser.add_argument(\'--line_width\', \'-lw\', type=int, default=2,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\xe8\xa1\x8c [default: 2]\')\n    parser.add_argument(\'--resize\', \'-rs\', type=float, default=0.5,\n                        help=\'\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe7\xb8\xae\xe5\xb0\xba [default: 0.5]\')\n    return parser.parse_args()\n\n\ndef makeDivisorList(num):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe6\x95\xb0\xe3\x81\xae\xe7\xb4\x84\xe6\x95\xb0\xe3\x81\xab1\xe3\x82\x92\xe5\x8a\xa0\xe3\x81\x88\xe3\x81\x9f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe8\xbf\x94\xe3\x81\x99\n    [in]  num:          \xe7\xb4\x84\xe6\x95\xb0\xe3\x82\x92\xe8\xa8\x88\xe7\xae\x97\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x84\xe6\x95\xb0\n    [out] divisor_list: num\xe3\x81\xae\xe7\xb4\x84\xe6\x95\xb0\xe3\x81\xab1\xe3\x82\x92\xe5\x8a\xa0\xe3\x81\x88\xe3\x81\x9f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    if num < 1:\n        return [0]\n    elif num == 1:\n        return [1]\n    else:\n        divisor_list = [i for i in range(2, num // 2 + 1) if num % i == 0]\n        divisor_list.append(1)\n\n        return divisor_list\n\n\ndef stackImgAndShape(imgs, row):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe7\xb8\xa6\xe6\xa8\xaa\xe3\x81\xab\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xa8\xe7\xb8\xa6\xe6\xa8\xaa\xe7\x94\xbb\xe5\x83\x8f\xe6\x95\xb0\xe6\x83\x85\xe5\xa0\xb1\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    [in]  imgs: \xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x84\xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in]  row:\n    [out] \xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [out] \xe7\xb8\xa6\xe6\xa8\xaa\xe7\x94\xbb\xe5\x83\x8f\xe6\x95\xb0\xe6\x83\x85\xe5\xa0\xb1\n    """"""\n\n    # row=0\xe3\x81\xaf\xe5\xbc\xb7\xe5\x88\xb6\xe7\x9a\x84\xe3\x81\xab1\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\n    if row == 0:\n        row = 1\n\n    # \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x81\x8crow\xe3\x81\xa7\xe5\x89\xb2\xe3\x82\x8a\xe5\x88\x87\xe3\x82\x8c\xe3\x81\xaa\xe3\x81\x84\xe6\x99\x82\xe7\x94\xa8\xe3\x81\xab\n    # \xe9\xbb\x92\xe5\xa1\x97\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe7\x94\xa8\xe6\x84\x8f\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x8c\xe3\x80\x813\xe6\x9e\x9a\xe3\x81\xae\xe6\xa0\xb9\xe6\x8b\xa0\xe3\x81\xaf\xe3\x81\xaa\xe3\x81\x84\n    if row > 3 or 0 > row:\n        bk = np.zeros(imgs[0].shape, dtype=np.uint8)\n        imgs.append(bk)\n        imgs.append(bk)\n        imgs.append(bk)\n\n    # row\xe3\x81\x8c\xe8\xb2\xa0\xe6\x95\xb0\xe3\x81\xae\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xafrow\xe3\x82\x92\xe8\x87\xaa\xe5\x8b\x95\xe8\xa8\x88\xe7\xae\x97\xe3\x81\x99\xe3\x82\x8b\n    if 0 > row:\n        # \xe9\xbb\x92\xe5\xa1\x97\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x920\xe6\x9e\x9a\xe5\x90\xab\xe3\x82\x93\xe3\x81\xa0\xe7\x8a\xb6\xe6\x85\x8b\xe3\x81\xa7div_list\xe3\x81\x8c3\xe4\xbb\xa5\xe4\xb8\x8a\xe3\x81\xab\xe3\x81\xaa\xe3\x82\x8c\xe3\x81\xb0div\xe3\x81\xa8imgs\xe3\x82\x92\xe6\xb1\xba\xe5\xae\x9a\n        # div_list\xe3\x81\x8c\xe5\x8d\x81\xe5\x88\x86\xe3\x81\xa7\xe3\x81\xaa\xe3\x81\x8b\xe3\x81\xa3\xe3\x81\x9f\xe5\xa0\xb4\xe5\x90\x88\xe3\x80\x81\n        # \xe9\xbb\x92\xe5\xa1\x97\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x921\xe6\x9e\x9a\xe5\x90\xab\xe3\x82\x93\xe3\x81\xa0\xe7\x8a\xb6\xe6\x85\x8b\xe3\x81\xa7div_list\xe3\x81\x8c3\xe4\xbb\xa5\xe4\xb8\x8a\xe3\x81\xab\xe3\x81\xaa\xe3\x82\x8c\xe3\x81\xb0div\xe3\x81\xa8imgs\xe3\x82\x92\xe6\xb1\xba\xe5\xae\x9a\n        # \xe3\x81\x93\xe3\x82\x8c\xe3\x82\x92\xe9\xbb\x92\xe5\xa1\x97\xe7\x94\xbb\xe5\x83\x8f3\xe6\x9e\x9a\xe3\x81\xbe\xe3\x81\xa7\xe7\xb6\x9a\xe3\x81\x91\xe3\x82\x8b\n        for i in range(3, 0, -1):\n            # \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe6\x95\xb0\xe3\x81\xa7\xe7\xb4\x84\xe6\x95\xb0\xe3\x82\x92\xe6\x8e\xa2\xe3\x81\x99\n            div_list = makeDivisorList(len(imgs[:-i]))\n            if(len(div_list) > 2):\n                # row\xe3\x81\xaf\xe7\xb4\x84\xe6\x95\xb0\xe3\x81\xae\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xae\xe4\xb8\xad\xe5\xbf\x83\xe3\x81\xae\xe5\x80\xa4\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n                # \xe3\x81\x93\xe3\x82\x8c\xe3\x81\xab\xe3\x82\x88\xe3\x82\x8a\xe6\xad\xa3\xe6\x96\xb9\xe5\xbd\xa2\xe3\x81\xab\xe8\xbf\x91\xe3\x81\x84\xe9\x80\xa3\xe7\xb5\x90\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\x8c\xe7\x94\x9f\xe6\x88\x90\xe3\x81\xa7\xe3\x81\x8d\xe3\x82\x8b\n                row = div_list[len(div_list) // 2]\n                imgs = imgs[:-i]\n                break\n\n    else:\n        img_len = len(imgs) // row * row\n        imgs = imgs[:img_len]\n\n    return np.array(imgs), np.arange(len(imgs)).reshape(-1, row)\n\n\ndef makeBorder(img, top, bottom, left, right, flg, value=None):\n    """"""\n    cv2.copyMakeBorder()\xe3\x81\xae\xe3\x83\xa9\xe3\x83\x83\xe3\x83\x91\xe3\x83\xbc\xe9\x96\xa2\xe6\x95\xb0\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe8\xa9\xb3\xe7\xb4\xb0\xe3\x81\xaf\xe7\x9c\x81\xe3\x81\x8f\n    """"""\n\n    if flg == cv2.BORDER_CONSTANT:\n        return cv2.copyMakeBorder(img, top, bottom, left, right, flg, value=value)\n    else:\n        return cv2.copyMakeBorder(img, top, bottom, left, right, flg)\n\n\ndef main(args):\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\n    imgs = [cv2.imread(name) for name in args.jpeg if IMG.isImgPath(name)]\n    # concat\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe3\x81\x99\xe3\x81\xb9\xe3\x81\xa6\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe9\xab\x98\xe3\x81\x95\xe3\x82\x92\xe7\xb5\xb1\xe4\xb8\x80\xe3\x81\x99\xe3\x82\x8b\n    h = np.max([img.shape[0] for img in imgs])\n    imgs = [IMG.resize(img, h / img.shape[0]) for img in imgs]\n    # concat\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe3\x81\x99\xe3\x81\xb9\xe3\x81\xa6\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe5\xb9\x85\xe3\x82\x92\xe7\xb5\xb1\xe4\xb8\x80\xe3\x81\x99\xe3\x82\x8b\n    flg = cv2.BORDER_REFLECT_101\n    w = np.max([img.shape[1] for img in imgs])\n    imgs = [makeBorder(img, 0, 0, 0, w - img.shape[1], flg) for img in imgs]\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xab\xe9\xbb\x92\xe7\xb8\x81\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\xe3\x81\x99\xe3\x82\x8b\n    flg = cv2.BORDER_CONSTANT\n    lw = args.line_width\n    imgs = [makeBorder(img, 0, lw, 0, lw, flg, (0, 0, 0)) for img in imgs]\n    # \xe7\xb8\xa6\xe6\xa8\xaa\xe3\x81\xab\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xa8\xe7\xb8\xa6\xe6\xa8\xaa\xe6\x83\x85\xe5\xa0\xb1\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    imgs, size = stackImgAndShape(imgs, args.row)\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x97\xe3\x81\xa6\xe3\x83\xaa\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\x99\xe3\x82\x8b\n    buf = [np.vstack(imgs[s]) for s in size]\n    img = IMG.resize(np.hstack(buf), args.resize)\n    # \xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n    name = F.getFilePath(args.out_path, \'concat\', \'.jpg\')\n    print(\'save:\', name)\n    cv2.imwrite(name, img)\n\n\nif __name__ == \'__main__\':\n    args = command()\n    F.argsPrint(args)\n    main(args)\n'"
Tools/dot2png.py,0,"b""#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = 'dot\xe8\xa8\x80\xe8\xaa\x9e\xe3\x81\xa7\xe8\xa8\x98\xe8\xbf\xb0\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x82\x92PNG\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b'\n#\n\nimport os\n# pydot: 1.2.4\n# graphviz: 0.8.2\nimport pydot\nimport argparse\n\nfrom func import argsPrint, getFilePath\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument('dot', nargs='+',\n                        help='\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8bdot\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9')\n    parser.add_argument('-e', '--ext', default='png',\n                        help='\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe6\x8b\xa1\xe5\xbc\xb5\xe5\xad\x90 (default: png, other: pdf, svg)')\n    parser.add_argument('-o', '--out_path', default='./result/',\n                        help='\xe5\x87\xba\xe5\x8a\x9b\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80 (default: ./result/)')\n    return parser.parse_args()\n\n\ndef main(args):\n    for name in args.dot:\n        # dot\xe8\xa8\x80\xe8\xaa\x9e\xe3\x81\xa7\xe8\xa8\x98\xe8\xbf\xb0\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\n        (graph,) = pydot.graph_from_dot_file(name)\n        # \xe4\xbf\x9d\xe5\xad\x98\xe7\x94\xa8\xe3\x81\xae\xe5\x90\x8d\xe5\x89\x8d\xe3\x82\x92\xe6\x8a\xbd\xe5\x87\xba\xe3\x81\x99\xe3\x82\x8b\n        name, _ = os.path.splitext(os.path.basename(name))\n        # \xe5\xbd\xa2\xe5\xbc\x8f\xe3\x82\x92\xe9\x81\xb8\xe6\x8a\x9e\xe3\x81\x97\xe3\x81\xa6\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n        if(args.ext == 'png'):\n            graph.write_png(getFilePath(args.out_path, name, '.png'))\n        elif(args.ext == 'pdf'):\n            graph.write_pdf(getFilePath(args.out_path, name, '.pdf'))\n        elif(args.ext == 'svg'):\n            graph.write_svg(getFilePath(args.out_path, name, '.svg'))\n        else:\n            print('[ERROR] ext option miss:', args.ext)\n\n\nif __name__ == '__main__':\n    args = command()\n    argsPrint(args)\n    main(args)\n"""
Tools/func.py,0,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'\xe4\xbe\xbf\xe5\x88\xa9\xe6\xa9\x9f\xe8\x83\xbd\'\n#\n\nimport os\nimport inspect\nfrom pathlib import Path\nfrom watchdog.events import FileSystemEventHandler\nfrom logging import getLogger\nlogger = getLogger(__name__)\n\n\nclass ChangeHandler(FileSystemEventHandler):\n\n    def __init__(self):\n        pass\n\n    def on_created(self, event):\n        filepath = event.src_path\n        filename = os.path.basename(filepath)\n        _, ext = os.path.splitext(filename)\n        return filepath, filename, ext\n\n    def on_modified(self, event):\n        filepath = event.src_path\n        filename = os.path.basename(filepath)\n        _, ext = os.path.splitext(filename)\n        return filepath, filename, ext\n\n    def on_deleted(self, event):\n        filepath = event.src_path\n        filename = os.path.basename(filepath)\n        _, ext = os.path.splitext(filename)\n        return filepath, filename, ext\n\n\ndef argsPrint(p, bar=30):\n    """"""\n    argparse\xe3\x81\xaeparse_args() \xe3\x81\xa7\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x82\xaa\xe3\x83\x96\xe3\x82\xb8\xe3\x82\xa7\xe3\x82\xaf\xe3\x83\x88\xe3\x82\x92\xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x99\xe3\x82\x8b\xe3\x81\xa8\xe3\x80\x81\n    integers\xe3\x81\xa8accumulate\xe3\x82\x92\xe8\x87\xaa\xe5\x8b\x95\xe3\x81\xa7\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x97\xe3\x81\xa6\xe8\xa1\xa8\xe7\xa4\xba\xe3\x81\x99\xe3\x82\x8b\n    [in] p: parse_args()\xe3\x81\xa7\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x82\xaa\xe3\x83\x96\xe3\x82\xb8\xe3\x82\xa7\xe3\x82\xaf\xe3\x83\x88\n    [in] bar: \xe5\x8c\xba\xe5\x88\x87\xe3\x82\x8a\xe3\x81\xae\xe3\x83\x8f\xe3\x82\xa4\xe3\x83\x95\xe3\x83\xb3\xe3\x81\xae\xe6\x95\xb0\n    """"""\n\n    print(\'-\' * bar)\n    args = [(i, getattr(p, i)) for i in dir(p) if not \'_\' in i[0]]\n    for i, j in args:\n        if isinstance(j, list):\n            print(\'{0}[{1}]:\'.format(i, len(j)))\n            [print(\'\\t{}\'.format(k)) for k in j]\n        else:\n            print(\'{0}:\\t{1}\'.format(i, j))\n\n    print(\'-\' * bar)\n\n\ndef args2dict(args):\n    """"""\n    argparse\xe3\x81\xaeparse_args() \xe3\x81\xa7\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x82\xaa\xe3\x83\x96\xe3\x82\xb8\xe3\x82\xa7\xe3\x82\xaf\xe3\x83\x88\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x97\xe3\x81\xa6\xe8\xbe\x9e\xe6\x9b\xb8\xe5\x9e\x8b\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\n    [in]  parse_args() \xe3\x81\xa7\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x82\xaa\xe3\x83\x96\xe3\x82\xb8\xe3\x82\xa7\xe3\x82\xaf\xe3\x83\x88\n    [out] in\xe3\x81\xae\xe8\xbe\x9e\xe6\x9b\xb8\xe5\x9e\x8b\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x97\xe3\x81\x9f\xe7\xb5\x90\xe6\x9e\x9c\n    """"""\n    return {i: getattr(args, i) for i in dir(args) if not \'_\' in i[0]}\n\n\ndef dict2json(folder, name, mydict, indent=4, sort_keys=True):\n    """"""\n    \xe8\xbe\x9e\xe6\x9b\xb8\xe5\x9e\x8b\xe3\x81\xae\xe3\x82\xaa\xe3\x83\x96\xe3\x82\xb8\xe3\x82\xa7\xe3\x82\xaf\xe3\x83\x88\xe3\x82\x92json\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xa7\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n    [in]  folder:    \xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\n    [in]  name:      \xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe5\x90\x8d\n    [in]  mydict:    \xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x84\xe8\xbe\x9e\xe6\x9b\xb8\xe5\x9e\x8b\xe3\x81\xae\xe3\x82\xaa\xe3\x83\x96\xe3\x82\xb8\xe3\x82\xa7\xe3\x82\xaf\xe3\x83\x88\n    [in]  indent:    json\xe3\x81\xa7\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe9\x9a\x9b\xe3\x81\xae\xe3\x82\xa4\xe3\x83\xb3\xe3\x83\x87\xe3\x83\xb3\xe3\x83\x88\xe7\x94\xa8\xe3\x81\xae\xe3\x82\xb9\xe3\x83\x9a\xe3\x83\xbc\xe3\x82\xb9\xe3\x81\xae\xe6\x95\xb0\n    [in]  sort_keys: json\xe3\x81\xa7\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe9\x9a\x9b\xe3\x81\xae\xe8\xbe\x9e\xe6\x9b\xb8\xe3\x82\x92\xe3\x82\xbd\xe3\x83\xbc\xe3\x83\x88\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    """"""\n\n    import json\n    path = getFilePath(folder, name, \'.json\')\n    with open(path, \'w\') as f:\n        json.dump(mydict, f, indent=4, sort_keys=True)\n\n\ndef checkModelType(path):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x91\xe3\x82\xb9\xe3\x81\x8c.model\xe3\x81\x8b.snapshot\xe3\x81\x8b\xe3\x81\x9d\xe3\x82\x8c\xe4\xbb\xa5\xe5\xa4\x96\xe3\x81\x8b\xe5\x88\xa4\xe5\xae\x9a\xe3\x81\x97\xe3\x80\x81\n    load_npz\xe3\x81\xaepath\xe3\x82\x92\xe8\xa8\xad\xe5\xae\x9a\xe3\x81\x99\xe3\x82\x8b\n    [in]  path:      \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x91\xe3\x82\xb9\n    [out] load_path: load_npz\xe3\x81\xaepath\n    """"""\n\n    # \xe6\x8b\xa1\xe5\xbc\xb5\xe5\xad\x90\xe3\x82\x92\xe6\xad\xa3\xe3\x81\xa8\xe3\x81\x99\xe3\x82\x8b\n    name, ext = os.path.splitext(os.path.basename(path))\n    load_path = \'\'\n    if(ext == \'.model\'):\n        logger.debug(\'model read: {}\'.format(path))\n    elif(ext == \'.snapshot\'):\n        logger.debug(\'snapshot read: {}\'.format(path))\n        load_path = \'updater/model:main/\'\n    else:\n        logger.error(\'model read error: {}\'.format(path))\n        logger.error(fileFuncLine())\n        exit(1)\n\n    logger.debug(load_path)\n    return load_path\n\n\ndef getFilePath(folder, name, ext=\'\'):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\xe5\x90\x8d\xe3\x81\xa8\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe5\x90\x8d\xe3\x81\xa8\xe6\x8b\xa1\xe5\xbc\xb5\xe5\xad\x90\xe3\x82\x92\xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x99\xe3\x82\x8b\n    [in]  folder: \xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\xe5\x90\x8d\n    [in]  name:   \xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe5\x90\x8d\n    [in]  ext:    \xe6\x8b\xa1\xe5\xbc\xb5\xe5\xad\x90\n    [out] \xe9\x80\xa3\xe7\xb5\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x95\xe3\x83\xab\xe3\x83\x91\xe3\x82\xb9\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe5\x90\x8d\n    """"""\n\n    if not os.path.isdir(folder):\n        os.makedirs(folder)\n\n    path = os.path.join(folder, name + ext)\n    logger.debug(\'get file path: {}\'.format(path))\n    return path\n\n\ndef sortTimeStamp(folder_list, ext):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\xe4\xbb\xa5\xe4\xb8\x8b\xe3\x81\xae\xe3\x81\x82\xe3\x82\x8bext\xe6\x8b\xa1\xe5\xbc\xb5\xe5\xad\x90\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x82\x92\xe3\x82\xbf\xe3\x82\xa4\xe3\x83\xa0\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x83\x97\xe3\x81\xa7\xe3\x82\xbd\xe3\x83\xbc\xe3\x83\x88\xe3\x81\x99\xe3\x82\x8b\n    [in]  folder_list: \xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x82\x92\xe6\x8e\xa2\xe7\xb4\xa2\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\n    [in]  ext:         \xe6\x8e\xa2\xe7\xb4\xa2\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\xae\xe6\x8b\xa1\xe5\xbc\xb5\xe5\xad\x90\n    [out] \xe3\x82\xbf\xe3\x82\xa4\xe3\x83\xa0\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x83\x97\xe3\x81\xa7\xe3\x82\xbd\xe3\x83\xbc\xe3\x83\x88\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    path = []\n    [path.extend(list(Path(f).glob(\'*\'+ext))) for f in folder_list]\n    return sorted([x.as_posix() for x in path], key=os.path.getmtime)\n\n\ndef fileFuncLine():\n    """"""\n    \xe3\x81\x93\xe3\x81\xae\xe9\x96\xa2\xe6\x95\xb0\xe3\x82\x92\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99\xe3\x81\xa8\xe3\x80\x81\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x97\xe5\x85\x88\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe5\x90\x8d\xe3\x80\x81\xe9\x96\xa2\xe6\x95\xb0\xe5\x90\x8d\xe3\x80\x81\xe5\xae\x9f\xe8\xa1\x8c\xe8\xa1\x8c\xe6\x95\xb0\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\xa7\xe3\x81\x8d\xe3\x82\x8b\n    \xe3\x83\x87\xe3\x83\x90\xe3\x83\x83\xe3\x82\xb0\xe6\x99\x82\xe3\x81\xab\xe4\xbe\xbf\xe5\x88\xa9\n    """"""\n\n    funcname = inspect.currentframe().f_back.f_code.co_name\n    filename = os.path.basename(\n        inspect.currentframe().f_back.f_code.co_filename\n    )\n    lineno = inspect.currentframe().f_back.f_lineno\n    return \'>>> {0}, {1}(), {2}[line] <<<\'.format(filename, funcname, lineno)\n'"
Tools/getfunc.py,4,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'\xe5\x90\x84\xe7\xa8\xae\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\xab\xe9\x96\xa2\xe3\x81\x99\xe3\x82\x8b\xe4\xbe\xbf\xe5\x88\xa9\xe6\xa9\x9f\xe8\x83\xbd\'\n#\n\nimport os\nimport sys\nimport json\nimport numpy as np\nfrom datetime import datetime\n\nfrom chainer.datasets import tuple_dataset\nimport chainer.functions as F\nimport chainer.optimizers as O\n\n[sys.path.append(d) for d in [\'./Tools/\', \'../Tools/\'] if os.path.isdir(d)]\nfrom func import fileFuncLine\nfrom logging import getLogger\nlogger = getLogger(__name__)\n\n\ndef randomStr(choice_len):\n    import random\n    import string\n\n    # return random.choices(string.ascii_letters, k=choice_len) # < Python 3.6+\n    return \'\'.join([random.choice(string.ascii_letters)\n                    for _ in range(choice_len)])  # < Python 3.5\n\n\ndef datetime32():\n    """"""\n    \xe6\x99\x82\xe5\x88\xbb\xe6\x83\x85\xe5\xa0\xb1\xe3\x82\x92\xe5\x85\x83\xe3\x81\xab\xe8\xa1\x9d\xe7\xaa\x81\xe3\x81\x97\xe3\x81\xab\xe3\x81\x8f\xe3\x81\x84\xe5\x90\x8d\xe5\x89\x8d\xe3\x82\x92\xe8\x87\xaa\xe5\x8b\x95\xe3\x81\xa7\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\xef\xbc\x88base_repr\xe4\xbd\xbf\xe7\x94\xa8\xe7\x89\x88\xef\xbc\x89\n    [out] \xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe5\x90\x8d\xe5\x89\x8d\n    """"""\n\n    now = datetime.today()\n    exec_time1 = int(now.strftime(\'%y%m%d\'))\n    exec_time2 = int(now.strftime(\'%H%M%S\'))\n    logger.debug(\'time1: {}\'.format(exec_time1))\n    logger.debug(\'time2: {}\'.format(exec_time2))\n    return np.base_repr(exec_time1 * exec_time2, 32).lower()\n\n\ndef datetimeSHA(secret=\'emacs\', str_len=8):\n    """"""\n    \xe6\x99\x82\xe5\x88\xbb\xe6\x83\x85\xe5\xa0\xb1\xe3\x82\x92\xe5\x85\x83\xe3\x81\xab\xe8\xa1\x9d\xe7\xaa\x81\xe3\x81\x97\xe3\x81\xab\xe3\x81\x8f\xe3\x81\x84\xe5\x90\x8d\xe5\x89\x8d\xe3\x82\x92\xe8\x87\xaa\xe5\x8b\x95\xe3\x81\xa7\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\xef\xbc\x88hmac\xe4\xbd\xbf\xe7\x94\xa8\xe7\x89\x88\xef\xbc\x89\n    [out] \xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe5\x90\x8d\xe5\x89\x8d\n    """"""\n\n    import hmac\n\n    byte_1 = bytearray(secret, \'ASCII\')\n    now = datetime.today()\n    exec_time1 = int(now.strftime(\'%y%m%d\'))\n    exec_time2 = int(now.strftime(\'%H%M%S\'))\n    byte_2 = bytearray(np.base_repr(\n        exec_time1 * exec_time2, 32).lower(), \'ASCII\')\n    myhash = hmac.new(byte_1, byte_2).hexdigest()\n    logger.debug(\'time1: {}\'.format(exec_time1))\n    logger.debug(\'time2: {}\'.format(exec_time2))\n    logger.debug(\'secret: {}\'.format(secret))\n    return myhash[:str_len]\n\n\ndef lossfun(lossfun_str):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe6\x96\x87\xe5\xad\x97\xe5\x88\x97\xe3\x81\x8b\xe3\x82\x89\xe6\x90\x8d\xe5\xa4\xb1\xe9\x96\xa2\xe6\x95\xb0\xe3\x82\x92\xe6\x8e\xa8\xe5\xae\x9a\xe3\x81\x99\xe3\x82\x8b\n    """"""\n\n    if(lossfun_str.lower() == \'mse\'):\n        lossfun = F.mean_squared_error\n    elif(lossfun_str.lower() == \'mae\'):\n        lossfun = F.mean_absolute_error\n    elif(lossfun_str.lower() == \'ber\'):\n        lossfun = F.bernoulli_nll\n    elif(lossfun_str.lower() == \'gauss_kl\'):\n        lossfun = F.gaussian_kl_divergence\n    else:\n        lossfun = F.mean_squared_error\n        logger.warning(\'{0}->{1}\'.format(lossfun_str, lossfun.__name__))\n\n    logger.debug(\'Loss func: {}\'.format(lossfun.__name__))\n    return lossfun\n\n\ndef F_None(x):\n    return x\n\n\ndef actfun(actfun_str):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe6\x96\x87\xe5\xad\x97\xe5\x88\x97\xe3\x81\x8b\xe3\x82\x89\xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0\xe3\x82\x92\xe6\x8e\xa8\xe5\xae\x9a\xe3\x81\x99\xe3\x82\x8b\n    """"""\n\n    if(actfun_str.lower() == \'relu\'):\n        actfun = F.relu\n    elif(actfun_str.lower() == \'elu\'):\n        actfun = F.elu\n    elif(actfun_str.lower() == \'c_relu\'):\n        actfun = F.clipped_relu\n    elif(actfun_str.lower() == \'l_relu\'):\n        actfun = F.leaky_relu\n    elif(actfun_str.lower() == \'sigmoid\'):\n        actfun = F.sigmoid\n    elif(actfun_str.lower() == \'h_sigmoid\'):\n        actfun = F.hard_sigmoid\n    elif(actfun_str.lower() == \'tanh\'):\n        actfun = F.tanh\n    elif(actfun_str.lower() == \'s_plus\'):\n        actfun = F.softplus\n    elif(actfun_str.lower() == \'none\'):\n        actfun = F_None\n    else:\n        actfun = F.relu\n        logger.warning(\'{}->{}\'.format(actfun_str, actfun.__name__))\n\n    logger.debug(\'Activation func: {}\'.format(actfun.__name__))\n    return actfun\n\n\ndef optimizer(opt_str):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe6\x96\x87\xe5\xad\x97\xe5\x88\x97\xe3\x81\x8b\xe3\x82\x89\xe3\x82\xaa\xe3\x83\x97\xe3\x83\x86\xe3\x82\xa3\xe3\x83\x9e\xe3\x82\xa4\xe3\x82\xb6\xe3\x82\x92\xe6\x8e\xa8\xe5\xae\x9a\xe3\x81\x99\xe3\x82\x8b\n    """"""\n\n    if(opt_str.lower() == \'adam\'):\n        opt = O.Adam(amsgrad=True)\n    elif(opt_str.lower() == \'ada_d\'):\n        opt = O.AdaDelta()\n    elif(opt_str.lower() == \'ada_g\'):\n        opt = O.AdaGrad()\n    elif(opt_str.lower() == \'m_sgd\'):\n        opt = O.MomentumSGD()\n    elif(opt_str.lower() == \'n_ag\'):\n        opt = O.NesterovAG()\n    elif(opt_str.lower() == \'rmsp\'):\n        opt = O.RMSprop()\n    elif(opt_str.lower() == \'rmsp_g\'):\n        opt = O.RMSpropGraves()\n    elif(opt_str.lower() == \'sgd\'):\n        opt = O.SGD()\n    elif(opt_str.lower() == \'smorms\'):\n        opt = O.SMORMS3()\n    else:\n        opt = O.Adam(amsgrad=True)\n        logger.warning(\'{}->{}\'.format(opt_str, opt.__doc__.split(\'.\')[0]))\n\n    logger.debug(\'Optimizer: {}\'.format(opt.__doc__.split(\'.\')[0]))\n    return opt\n\n\ndef jsonData(path, data):\n    logger.debug(\'json read: {}\'.format(path))\n    try:\n        with open(path, \'r\') as f:\n            j_dict = json.load(f)\n\n    except:\n        import traceback\n        traceback.print_exc()\n        logger.error(fileFuncLine())\n        exit(1)\n\n    param = [j_dict[d] for d in data if d in j_dict]\n    logger.debug(\'param[{}]: {}\'.format(len(data), data))\n    logger.debug(\'param[{}]: {}\'.format(len(param), param))\n    if len(param) == 0:\n        logger.error(\'json read miss: {}\'.format(data))\n    elif len(param) == 1:\n        return param[0]\n    else:\n        return param\n\n\ndef modelParam(path):\n    """"""\n    json\xe3\x81\xa7\xe8\xa8\x98\xe8\xbf\xb0\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x83\x91\xe3\x83\xa9\xe3\x83\xa1\xe3\x83\xbc\xe3\x82\xbf\xe6\x83\x85\xe5\xa0\xb1\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\n    [in]  path:              json\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\n    [out] d[\'network\']:      \xe3\x83\x8d\xe3\x83\x83\xe3\x83\x88\xe3\x83\xaf\xe3\x83\xbc\xe3\x82\xaf\xe3\x81\xae\xe7\xa8\xae\xe9\xa1\x9e\n    [out] d[\'unut\']:         \xe4\xb8\xad\xe9\x96\x93\xe5\xb1\xa4\xe3\x81\xae\xe3\x83\xa6\xe3\x83\x8b\xe3\x83\x83\xe3\x83\x88\xe6\x95\xb0\n    [out] ch:                \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0\n    [out] size:              \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe5\x88\x86\xe5\x89\xb2\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\n    [out] d[\'layer_num\']:    \xe3\x83\x8d\xe3\x83\x83\xe3\x83\x88\xe3\x83\xaf\xe3\x83\xbc\xe3\x82\xaf\xe5\xb1\xa4\xe3\x81\xae\xe6\x95\xb0\n    [out] d[\'shuffle_rate\']: PS\xe3\x81\xaeshuffle rate\n    [out] af1:               \xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0(1)\n    [out] af2:               \xe6\xb4\xbb\xe6\x80\xa7\xe5\x8c\x96\xe9\x96\xa2\xe6\x95\xb0(2)\n    """"""\n\n    logger.debug(\'model param: {}\'.format(path))\n    try:\n        with open(path, \'r\') as f:\n            d = json.load(f)\n\n    except:\n        import traceback\n        traceback.print_exc()\n        logger.error(fileFuncLine())\n        exit(1)\n\n    if \'network\' in d:\n        net = d[\'network\']\n    else:\n        net = \'None\'\n\n    if \'layer_num\' in d:\n        layer = d[\'layer_num\']\n    else:\n        layer = 0\n\n    try:\n        af1 = actfun(d[\'actfun1\'])\n    except:\n        af1 = None\n\n    try:\n        af2 = actfun(d[\'actfun2\'])\n    except:\n        af2 = None\n\n    try:\n        ch = d[\'shape\'][0]\n    except:\n        ch = 0\n\n    try:\n        size = d[\'shape\'][1]\n    except:\n        size = 0\n\n    try:\n        sr = d[\'shuffle_rate\']\n    except:\n        sr = 0\n\n    return \\\n        net, d[\'unit\'], ch, size, \\\n        layer, sr, af1, af2\n\n\ndef imgData(folder):\n    """"""\n    \xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\xe3\x81\xab\xe3\x81\x82\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\x8b\xe3\x82\x89\xe5\xad\xa6\xe7\xbf\x92\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xa8\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\n    [in]  folder: \xe6\x8e\xa2\xe7\xb4\xa2\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\n    [out] train:  \xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x97\xe3\x81\x9f\xe5\xad\xa6\xe7\xbf\x92\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\n    [out] test:   \xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x97\xe3\x81\x9f\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\n    [out] ch:     \xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x97\xe3\x81\x9f\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0\n    """"""\n\n    # \xe6\x8e\xa2\xe7\xb4\xa2\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\xe3\x81\x8c\xe3\x81\xaa\xe3\x81\x91\xe3\x82\x8c\xe3\x81\xb0\xe7\xb5\x82\xe4\xba\x86\n    if not os.path.isdir(folder):\n        logger.error(\'folder not found: {}\'.format(folder))\n        logger.error(fileFuncLine())\n        exit()\n\n    # \xe5\xad\xa6\xe7\xbf\x92\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xa8\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\x92\xe7\x99\xba\xe8\xa6\x8b\xe3\x81\x97\xe3\x81\x9f\xe3\x82\x89True\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\n    train_flg = False\n    test_flg = False\n    ch = 3\n    # \xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\xe5\x86\x85\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x82\x92\xe6\x8e\xa2\xe7\xb4\xa2\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x84\xe3\x81\x8d\xe3\x80\x81\n    # 1. \xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe5\x90\x8d\xe3\x81\xae\xe9\xa0\xad\xe3\x81\x8ctrain_\xe3\x81\xaa\xe3\x82\x89\xe5\xad\xa6\xe7\xbf\x92\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xa8\xe3\x81\x97\xe3\x81\xa6\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\n    # 2. \xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe5\x90\x8d\xe3\x81\xae\xe9\xa0\xad\xe3\x81\x8ctest_\xe3\x81\xaa\xe3\x82\x89\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xa8\xe3\x81\x97\xe3\x81\xa6\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\n    for l in os.listdir(folder):\n        name, ext = os.path.splitext(os.path.basename(l))\n        if os.path.isdir(l):\n            pass\n        elif(\'train_\' in name)and(\'.npz\' in ext)and(train_flg is False):\n            np_arr = np.load(os.path.join(folder, l))\n            x, y = np_arr[\'x\'], np_arr[\'y\']\n            train = tuple_dataset.TupleDataset(x, y)\n            logger.info(\'{0}:\\tx{1}\\ty{2}\'.format(l, x.shape, y.shape))\n            ch = x[0].shape[0]\n            if(train._length > 0):\n                train_flg = True\n\n        elif(\'test_\' in name)and(\'.npz\' in ext)and(test_flg is False):\n            np_arr = np.load(os.path.join(folder, l))\n            x, y = np_arr[\'x\'], np_arr[\'y\']\n            test = tuple_dataset.TupleDataset(x, y)\n            logger.info(\'{0}:\\tx{1}\\ty{2}\'.format(l, x.shape, y.shape))\n            if(test._length > 0):\n                test_flg = True\n\n    # \xe5\xad\xa6\xe7\xbf\x92\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xa8\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88\xe7\x94\xa8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae\xe4\xb8\xa1\xe6\x96\xb9\xe3\x81\x8c\xe8\xa6\x8b\xe3\x81\xa4\xe3\x81\x8b\xe3\x81\xa3\xe3\x81\x9f\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xab\xe3\x81\xae\xe3\x81\xbf\xe6\xac\xa1\xe3\x81\xae\xe3\x82\xb9\xe3\x83\x86\xe3\x83\x83\xe3\x83\x97\xe3\x81\xb8\xe9\x80\xb2\xe3\x82\x81\xe3\x82\x8b\n    if(train_flg is True)and(test_flg is True):\n        return train, test, ch\n    else:\n        logger.error(\'dataset not found in this folder: {}\'.format(folder))\n        logger.error(fileFuncLine())\n        exit()\n'"
Tools/imgfunc.py,36,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'\xe7\x94\xbb\xe5\x83\x8f\xe5\x87\xa6\xe7\x90\x86\xe3\x81\xab\xe9\x96\xa2\xe3\x81\x99\xe3\x82\x8b\xe4\xbe\xbf\xe5\x88\xa9\xe6\xa9\x9f\xe8\x83\xbd\'\n#\n\nimport os\nimport sys\nimport cv2\nimport numpy as np\nfrom logging import getLogger\nlogger = getLogger(__name__)\n\ntry:\n    import cupy as xp\nexcept ImportError:\n    logger.warning(\'not import cupy\')\n\n[sys.path.append(d) for d in [\'./Tools/\', \'../Tools/\'] if os.path.isdir(d)]\nfrom func import fileFuncLine\n\n\ndef getCh(ch):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0\xe3\x82\x92OpenCV\xe3\x81\xae\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\n    [in]  ch:\xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0 (type=int or np.shape)\n    [out] OpenCV\xe3\x81\xae\xe5\xbd\xa2\xe5\xbc\x8f\n    """"""\n\n    logger.debug(\'getCh({})\'.format(ch))\n    if(ch == 1):\n        return cv2.IMREAD_GRAYSCALE\n    elif(ch == 3):\n        return cv2.IMREAD_COLOR\n    else:\n        return cv2.IMREAD_UNCHANGED\n\n\ndef blank(size, color, dtype=np.uint8, min_val=0, max_val=255):\n    """"""\n    \xe5\x8d\x98\xe8\x89\xb2\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\n    [in]  size: \xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba [h,w,ch]\xef\xbc\x88ch\xe3\x81\x8c\xe3\x81\xaa\xe3\x81\x84\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xaf1\xe3\x82\x92\xe8\xa8\xad\xe5\xae\x9a\xef\xbc\x89\n    [in]  color: \xe8\x89\xb2\xef\xbc\x88int\xe3\x81\xa7\xe3\x82\xb0\xe3\x83\xac\xe3\x83\xbc\xe3\x80\x81tuple\xe3\x81\xa7\xe3\x82\xab\xe3\x83\xa9\xe3\x83\xbc\xef\xbc\x89\n    [in]  dtype: \xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe5\x9e\x8b\n    [in]  min_val: \xe8\x89\xb2\xe3\x81\xae\xe6\x9c\x80\xe5\xb0\x8f\xe5\x80\xa4\n    [in]  max_val: \xe8\x89\xb2\xe3\x81\xae\xe6\x9c\x80\xe5\xa4\xa7\xe5\x80\xa4\n    [out] img:   \xe7\x94\x9f\xe6\x88\x90\xe3\x81\x97\xe3\x81\x9f\xe5\x8d\x98\xe8\x89\xb2\xe7\x94\xbb\xe5\x83\x8f\n    """"""\n\n    logger.debug(\'blank({},{},{},{},{})\'.format(\n        size, color, dtype.__name__, min_val, max_val\n    ))\n    # \xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xab\xe8\xb2\xa0\xe6\x95\xb0\xe3\x81\x8c\xe3\x81\x82\xe3\x82\x8b\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xaf\xe3\x82\xa8\xe3\x83\xa9\xe3\x83\xbc\n    if np.min(size) < 0:\n        logger.error(\'\\tsize < 0: {}\'.format(size))\n        logger.error(fileFuncLine())\n        exit(1)\n\n    # \xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xab\xe7\xb8\xa6\xe6\xa8\xaa\xe3\x81\x97\xe3\x81\x8b\xe5\x90\xab\xe3\x81\xbe\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3\x81\xaa\xe3\x81\x84\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xaf\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe8\xbf\xbd\xe5\x8a\xa0\n    if len(size) == 2:\n        logger.debug(\'\\tsize len = 2: {}\'.format(size))\n        size = (size[0], size[1], 1)\n\n    # \xe8\x89\xb2\xe3\x81\x8cint\xe3\x81\xae\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xaf\xe3\x82\xb0\xe3\x83\xac\xe3\x83\xbc\xe3\x82\xb9\xe3\x82\xb1\xe3\x83\xbc\xe3\x83\xab\xe3\x81\xa8\xe3\x81\x97\xe3\x81\xa6\xe5\xa1\x97\xe3\x82\x8a\xe3\x81\xa4\xe3\x81\xb6\xe3\x81\x99\n    # 0 < color < 255\xe3\x81\xae\xe7\xaf\x84\xe5\x9b\xb2\xe3\x81\xab\xe3\x81\xaa\xe3\x81\x84\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xaf\xe4\xb8\xb8\xe3\x82\x81\xe3\x82\x8b\n    if type(color) is int:\n        img = np.zeros(size, dtype=dtype)\n        if color < min_val:\n            color = min_val\n        elif color > max_val:\n            color = max_val\n\n        logger.debug(\'\\t0 < color < 255: {}\', color)\n        img.fill(color)\n        return img\n\n    # \xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe3\x81\x8c3\xe3\x81\x98\xe3\x82\x83\xe3\x81\xaa\xe3\x81\x84\xe6\x99\x82\xe3\x81\xaf3\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\n    if size[2] != 3:\n        logger.debug(\'\\tsize len != 3: {}\'.format(size))\n        size = (size[0], size[1], 3)\n\n    img = np.zeros(size, dtype=dtype)\n    img[:, :, :] = color\n    return img\n\n\ndef isImgPath(path, silent=False):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x83\x91\xe3\x82\xb9\xe3\x81\x8c\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\x8b\xe5\x88\xa4\xe5\xae\x9a\xe3\x81\x99\xe3\x82\x8b\n    [in]  path:   \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\x8b\xe5\x88\xa4\xe5\xae\x9a\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x84\xe3\x83\x91\xe3\x82\xb9\n    [in]  silent: cv2.imread\xe5\xa4\xb1\xe6\x95\x97\xe6\x99\x82\xe3\x81\xab\xe3\x82\xa8\xe3\x83\xa9\xe3\x83\xbc\xe3\x82\x92\xe8\xa1\xa8\xe7\xa4\xba\xe3\x81\x95\xe3\x81\x9b\xe3\x81\xaa\xe3\x81\x84\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xafTrue\n    [out] \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xaa\xe3\x82\x89True\n    """"""\n\n    logger.debug(\'isImgPath({},{})\'.format(path, silent))\n\n    if not type(path) is str:\n        return False\n\n    import imghdr\n    if not os.path.isfile(path):\n        logger.error(\'image not found: {}\'.format(path))\n        logger.error(fileFuncLine())\n        return False\n\n    if imghdr.what(path) is None:\n        logger.error(\'image not found: {}\'.format(path))\n        logger.error(fileFuncLine())\n        return False\n    else:\n        return True\n\n\ndef encodeDecode(img, ch, quality=5, ext=\'.jpg\'):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x9c\xa7\xe7\xb8\xae\xe3\x81\x99\xe3\x82\x8b\n    \xe2\x80\xbb\xe8\xa9\xb3\xe7\xb4\xb0\xe3\x81\xafencodeDecodeN\xe3\x81\xa8\xe3\x81\xbb\xe3\x81\xbc\xe5\x90\x8c\xe3\x81\x98\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe7\x9c\x81\xe7\x95\xa5\n    """"""\n\n    logger.debug(\'encodeDecode({},{},{},{})\'.format(\n        img.shape, ch, quality, ext))\n    encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), quality]\n    result, encimg = cv2.imencode(ext, img, encode_param)\n    if False == result:\n        logger.error(\'image encode failed!\')\n        logger.error(fileFuncLine())\n        exit(1)\n\n    return cv2.imdecode(encimg, getCh(ch))\n\n\ndef encodeDecodeN(imgs, ch, quality=5, ext=\'.jpg\'):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe5\x9c\xa7\xe7\xb8\xae\xe3\x81\x99\xe3\x82\x8b\n    [in]  imgs:    \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in]  ch:      \xe5\x87\xba\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xae\xe3\x83\x81\xe3\x83\xa3\xe3\x83\xb3\xe3\x83\x8d\xe3\x83\xab\xe6\x95\xb0\n    [in]  quality: \xe5\x9c\xa7\xe7\xb8\xae\xe3\x81\x99\xe3\x82\x8b\xe5\x93\x81\xe8\xb3\xaa (1-100)\n    [in]  ext:     \xe5\x9c\xa7\xe7\xb8\xae\xe3\x81\x99\xe3\x82\x8b\xe6\x8b\xa1\xe5\xbc\xb5\xe5\xad\x90\n    [out] \xe5\x9c\xa7\xe7\xb8\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n    logger.debug(\'encodeDecodeN(N={})\'.format(len(imgs)))\n    return [encodeDecode(img, ch, quality, ext) for img in imgs]\n\n\ndef cut(img, size=-1):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe4\xb8\xad\xe5\xbf\x83\xe3\x81\x8b\xe3\x82\x89\xe4\xbb\xbb\xe6\x84\x8f\xe3\x81\xae\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xa7\xe5\x88\x87\xe3\x82\x8a\xe5\x8f\x96\xe3\x82\x8b\n    \xe2\x80\xbb\xe8\xa9\xb3\xe7\xb4\xb0\xe3\x81\xafcutN\xe3\x81\xa8\xe3\x81\xbb\xe3\x81\xbc\xe5\x90\x8c\xe3\x81\x98\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe7\x9c\x81\xe7\x95\xa5\n    """"""\n\n    logger.debug(\'cut({},{})\'.format(img.shape, size))\n    # \xe3\x82\xab\xe3\x83\x83\xe3\x83\x88\xe3\x81\x99\xe3\x82\x8b\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xae\xe5\x8d\x8a\xe5\x88\x86\xe3\x82\x92\xe8\xa8\x88\xe7\xae\x97\xe3\x81\x99\xe3\x82\x8b\n    if size <= 1:\n        # \xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\x8c1\xe4\xbb\xa5\xe4\xb8\x8b\xe3\x81\xae\xe5\xa0\xb4\xe5\x90\x88\xe3\x80\x81img\xe3\x81\xae\xe7\x9f\xad\xe8\xbe\xba\xe3\x81\x8c\xe3\x82\xab\xe3\x83\x83\xe3\x83\x88\xe3\x81\x99\xe3\x82\x8b\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xab\xe3\x81\xaa\xe3\x82\x8b\n        half = np.min(img.shape[:2]) // 2\n        logger.debug(\'\\tsize <= 1\')\n    else:\n        half = size // 2\n\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe4\xb8\xad\xe5\xbf\x83\xe4\xbd\x8d\xe7\xbd\xae\xe3\x82\x92\xe8\xa8\x88\xe7\xae\x97\n    ch, cw = img.shape[0] // 2, img.shape[1] // 2\n    return img[ch - half:ch + half, cw - half:cw + half]\n\n\ndef cutN(imgs, size=-1, round_num=-1):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe4\xb8\xad\xe5\xbf\x83\xe3\x81\x8b\xe3\x82\x89\xe4\xbb\xbb\xe6\x84\x8f\xe3\x81\xae\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xa7\xe5\x88\x87\xe3\x82\x8a\xe5\x8f\x96\xe3\x82\x8b\n    [in]  img:       \xe3\x82\xab\xe3\x83\x83\xe3\x83\x88\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\n    [in]  size:      \xe3\x82\xab\xe3\x83\x83\xe3\x83\x88\xe3\x81\x99\xe3\x82\x8b\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xef\xbc\x88\xe6\xad\xa3\xe6\x96\xb9\xe5\xbd\xa2\xef\xbc\x89\n    [in]  round_num: \xe4\xb8\xb8\xe3\x82\x81\xe3\x82\x8b\xe6\x95\xb0\n    [out] \xe3\x82\xab\xe3\x83\x83\xe3\x83\x88\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    logger.debug(\'cutN(N={})\'.format(len(imgs)))\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x82\xab\xe3\x83\x83\xe3\x83\x88\xe3\x82\x92\xe5\xae\x9f\xe8\xa1\x8c\n    out_imgs = [cut(img, size) for img in imgs]\n    # \xe5\x88\x87\xe3\x82\x8a\xe6\x8d\xa8\xe3\x81\xa6\xe3\x81\x9f\xe3\x81\x84\xe6\x95\xb0\xe3\x82\x88\xe3\x82\x8a\xe3\x82\x82\xe7\x94\xbb\xe5\x83\x8f\xe6\x95\xb0\xe3\x81\x8c\xe5\xb0\x91\xe3\x81\xaa\xe3\x81\x84\xe3\x81\xa80\xe6\x9e\x9a\xe3\x81\xab\xe3\x81\xaa\xe3\x81\xa3\xe3\x81\xa6\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x86\xe3\x81\xae\xe3\x81\xa7\xe6\xb3\xa8\xe6\x84\x8f\n    if(round_num > len(out_imgs)):\n        logger.debug(\'\\tround_num > len(out_imgs)\')\n        round_num = -1\n\n    # \xe3\x83\x90\xe3\x83\x83\xe3\x83\x81\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xae\xe9\x96\xa2\xe4\xbf\x82\xe3\x81\xaa\xe3\x81\xa9\xe3\x81\xa7\xe3\x80\x81\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe6\x95\xb0\xe3\x82\x92\xe8\xaa\xbf\xe6\x95\xb4\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x84\xe6\x99\x82\xe3\x81\xaf\xe3\x81\x93\xe3\x81\x93\xe3\x81\xa7\xe8\xaa\xbf\xe6\x95\xb4\xe3\x81\x99\xe3\x82\x8b\n    # predict.py\xe3\x81\xaa\xe3\x81\xa9\xe3\x81\xa7\xe5\x88\x86\xe5\x89\xb2\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\xbe\xa9\xe5\x85\x83\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x8f\xe3\x81\xaa\xe3\x82\x8b\xe3\x81\xae\xe3\x81\xa7\xe7\xb8\xa6\xe6\xa8\xaa\xe3\x81\xae\xe5\x88\x86\xe5\x89\xb2\xe6\x95\xb0\xe3\x82\x82\xe8\xbf\x94\xe3\x81\x99\n    if(round_num > 0):\n        logger.debug(\'\\tround_num > 0\')\n        round_len = len(out_imgs) // round_num * round_num\n        return np.array(out_imgs[:round_len])\n    else:\n        return np.array(out_imgs)\n\n\ndef splitSQ(img, size, flg=cv2.BORDER_REPLICATE, w_rate=0.2, array=True):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe6\xad\xa3\xe6\x96\xb9\xe5\xbd\xa2\xe3\x81\xab\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x99\xe3\x82\x8b\n    \xe2\x80\xbb\xe8\xa9\xb3\xe7\xb4\xb0\xe3\x81\xafsplitSQN\xe3\x81\xa8\xe3\x81\xbb\xe3\x81\xbc\xe5\x90\x8c\xe3\x81\x98\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe7\x9c\x81\xe7\x95\xa5\n    """"""\n\n    logger.debug(\'splitSQ({},{},{},{},{})\'.format(\n        img.shape, size, flg, w_rate, array)\n    )\n\n    def arrayChk(x, to_arr):\n        logger.debug(\'arrayChk({},{})\'.format(len(x), to_arr))\n        # np.array (True)\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x8b\xe3\x80\x81list (False)\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x8b\xe9\x81\xb8\xe6\x8a\x9e\xe3\x81\x99\xe3\x82\x8b\n        if to_arr:\n            return np.array(x)\n        else:\n            return x\n\n    # size\xe3\x81\x8c\xe8\xb2\xa0\xe6\x95\xb0\xe3\x81\xa0\xe3\x81\xa8\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x97\xe3\x81\xaa\xe3\x81\x84\xe3\x81\xa7\xe3\x81\x9d\xe3\x81\xae\xe3\x81\xbe\xe3\x81\xbe\xe8\xbf\x94\xe3\x81\x99\n    if size <= 1:\n        logger.debug(\'\\tsize <= 1\')\n        return arrayChk(cutN(img), array), (1, 1)\n\n    h, w = img.shape[:2]\n    split = (h // size, w // size)\n\n    # size\xe3\x81\x8c\xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x88\xe3\x82\x8a\xe3\x82\x82\xe5\xa4\xa7\xe3\x81\x8d\xe3\x81\x84\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xaf\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x97\xe3\x81\xaa\xe3\x81\x84\xe3\x81\xa7\xe3\x81\x9d\xe3\x81\xae\xe3\x81\xbe\xe3\x81\xbe\xe8\xbf\x94\xe3\x81\x99\n    if split[0] == 0 or split[1] == 0:\n        logger.debug(\'\\tsplit[0] == 0 or split[1] == 0\')\n        return arrayChk([cut(img)], array), (1, 1)\n\n    # \xe7\xb8\xa6\xe6\xa8\xaa\xe3\x81\xae\xe5\x88\x86\xe5\x89\xb2\xe6\x95\xb0\xe3\x82\x92\xe8\xa8\x88\xe7\xae\x97\xe3\x81\x99\xe3\x82\x8b\n    if (h / size + w / size) > (h // size + w // size):\n        # \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x99\xe3\x82\x8b\xe9\x9a\x9b\xe3\x81\xab\xe7\xab\xaf\xe3\x81\x8c\xe5\x88\x87\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x86\xe3\x81\xae\xe3\x82\x92\xe9\x98\xb2\xe3\x81\x90\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe4\xbd\x99\xe7\x99\xbd\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\xe3\x81\x99\xe3\x82\x8b\n        width = int(size * w_rate)\n        img = cv2.copyMakeBorder(img, 0, width, 0, width, flg)\n        # \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x97\xe3\x82\x84\xe3\x81\x99\xe3\x81\x84\xe3\x82\x88\xe3\x81\x86\xe3\x81\xab\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x92\xe5\xa4\x89\xe6\x9b\xb4\xe3\x81\x99\xe3\x82\x8b\n        h, w = img.shape[:2]\n        split = (h // size, w // size)\n        img = img[:split[0] * size, :split[1] * size]\n\n    # \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x99\xe3\x82\x8b\n    imgs_2d = [np.vsplit(i, split[0]) for i in np.hsplit(img, split[1])]\n    imgs_1d = [x for l in imgs_2d for x in l]\n    logger.debug(\'\\tsplit: {}\'.format(split))\n    return arrayChk(imgs_1d, array), split\n\n\ndef splitSQN(imgs, size, round_num=-1, flg=cv2.BORDER_REPLICATE, w_rate=0.2):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe6\xad\xa3\xe6\x96\xb9\xe5\xbd\xa2\xe3\x81\xab\xe5\x88\x86\xe5\x89\xb2\xe3\x81\x99\xe3\x82\x8b\n    imgs\xe3\x81\xab\xe6\xa0\xbc\xe7\xb4\x8d\xe3\x81\x95\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xaf\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\x8c\xe5\x90\x8c\xe3\x81\x98\xe3\x81\xa7\xe3\x81\x82\xe3\x82\x8b\xe3\x81\x93\xe3\x81\xa8\n    [in]  imgs:      \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in]  size:      \xe6\xad\xa3\xe6\x96\xb9\xe5\xbd\xa2\xe3\x81\xae\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xef\xbc\x88size x size\xef\xbc\x89\n    [in]  round_num: \xe4\xb8\xb8\xe3\x82\x81\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe6\x95\xb0\n    [in]  flg:       \xe5\xa2\x83\xe7\x95\x8c\xe7\xb7\x9a\xe3\x81\xae\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [out] out_imgs:  \xe5\x88\x86\xe5\x89\xb2\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9fnp.array\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xae\xe6\xad\xa3\xe6\x96\xb9\xe5\xbd\xa2\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [out] split:     \xe7\xb8\xa6\xe6\xa8\xaa\xe3\x81\xae\xe5\x88\x86\xe5\x89\xb2\xe6\x83\x85\xe5\xa0\xb1\n    """"""\n\n    logger.debug(\'splitSQN(N={})\'.format(len(imgs)))\n    out_imgs = []\n    split = []\n    for img in imgs:\n        i, s = splitSQ(img, size, flg, w_rate, False)\n        out_imgs.extend(i)\n        split.extend(s)\n\n    # \xe5\x88\x87\xe3\x82\x8a\xe6\x8d\xa8\xe3\x81\xa6\xe3\x81\x9f\xe3\x81\x84\xe6\x95\xb0\xe3\x82\x88\xe3\x82\x8a\xe3\x82\x82\xe7\x94\xbb\xe5\x83\x8f\xe6\x95\xb0\xe3\x81\x8c\xe5\xb0\x91\xe3\x81\xaa\xe3\x81\x84\xe3\x81\xa80\xe6\x9e\x9a\xe3\x81\xab\xe3\x81\xaa\xe3\x81\xa3\xe3\x81\xa6\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x86\xe3\x81\xae\xe3\x81\xa7\xe6\xb3\xa8\xe6\x84\x8f\n    if(round_num > len(out_imgs)):\n        logger.debug(\'\\tround_num > len(out_imgs)\')\n        round_num = -1\n\n    # \xe3\x83\x90\xe3\x83\x83\xe3\x83\x81\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xae\xe9\x96\xa2\xe4\xbf\x82\xe3\x81\xaa\xe3\x81\xa9\xe3\x81\xa7\xe3\x80\x81\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe6\x95\xb0\xe3\x82\x92\xe8\xaa\xbf\xe6\x95\xb4\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x84\xe6\x99\x82\xe3\x81\xaf\xe3\x81\x93\xe3\x81\x93\xe3\x81\xa7\xe8\xaa\xbf\xe6\x95\xb4\xe3\x81\x99\xe3\x82\x8b\n    # predict.py\xe3\x81\xaa\xe3\x81\xa9\xe3\x81\xa7\xe5\x88\x86\xe5\x89\xb2\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\xbe\xa9\xe5\x85\x83\xe3\x81\x97\xe3\x81\x9f\xe3\x81\x8f\xe3\x81\xaa\xe3\x82\x8b\xe3\x81\xae\xe3\x81\xa7\xe7\xb8\xa6\xe6\xa8\xaa\xe3\x81\xae\xe5\x88\x86\xe5\x89\xb2\xe6\x95\xb0\xe3\x82\x82\xe8\xbf\x94\xe3\x81\x99\n    if(round_num > 0):\n        logger.debug(\'\\tround_num > 0\')\n        round_len = len(out_imgs) // round_num * round_num\n        return np.array(out_imgs[:round_len]), (split[0], split[1])\n    else:\n        return np.array(out_imgs), (split[0], split[1])\n\n\ndef rotate(img, angle, scale, border=(0, 0, 0)):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x9b\x9e\xe8\xbb\xa2\xef\xbc\x88\xe5\x8f\x8d\xe8\xbb\xa2\xef\xbc\x89\xe3\x81\x95\xe3\x81\x9b\xe3\x82\x8b\n    [in]  img:    \xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\n    [in]  angle:  \xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x82\x8b\xe8\xa7\x92\xe5\xba\xa6\n    [in]  scale:  \xe6\x8b\xa1\xe5\xa4\xa7\xe7\x8e\x87\n    [in]  border: \xe5\x9b\x9e\xe8\xbb\xa2\xe6\x99\x82\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe6\x83\x85\xe5\xa0\xb1\xe3\x81\x8c\xe3\x81\xaa\xe3\x81\x84\xe5\xa0\xb4\xe6\x89\x80\xe3\x82\x92\xe5\x9f\x8b\xe3\x82\x81\xe3\x82\x8b\xe8\x89\xb2\n    [out] \xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\n    """"""\n\n    logger.debug(\'rotate({},{},{},{})\'.format(\n        img.shape, angle, scale, border)\n    )\n    size = (img.shape[1], img.shape[0])\n    mat = cv2.getRotationMatrix2D((size[0] // 2, size[1] // 2), angle, scale)\n    return cv2.warpAffine(img, mat, size, flags=cv2.INTER_CUBIC, borderValue=border)\n\n\ndef rotateR(img, level=[-10, 10], scale=1.2, border=(0, 0, 0)):\n    """"""\n    \xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe3\x81\xab\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x82\x8b\n    \xe2\x80\xbb\xe8\xa9\xb3\xe7\xb4\xb0\xe3\x81\xafrotateRN\xe3\x81\xa8\xe3\x81\xbb\xe3\x81\xbc\xe5\x90\x8c\xe3\x81\x98\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe7\x9c\x81\xe7\x95\xa5\n    """"""\n\n    logger.debug(\'rotateR({},{},{},{})\'.format(\n        img.shape, level, scale, border)\n    )\n    angle = np.random.randint(level[0], level[1])\n    logger.debug(\'\\tangle: {}\'.format(angle))\n    return rotate(img, angle, scale, border), angle\n\n\ndef rotateRN(imgs, num, level=[-10, 10], scale=1.2, border=(0, 0, 0)):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92\xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe3\x81\xab\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x82\x8b\n    [in]  img:   \xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\n    [in]  num:   \xe7\xb9\xb0\xe3\x82\x8a\xe8\xbf\x94\xe3\x81\x97\xe6\x95\xb0\n    [in]  level: \xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x82\x8b\xe8\xa7\x92\xe5\xba\xa6\xe3\x81\xae\xe7\xaf\x84\xe5\x9b\xb2\n    [in]  scale: \xe6\x8b\xa1\xe5\xa4\xa7\xe7\x8e\x87\n    [in]  border: \xe5\x9b\x9e\xe8\xbb\xa2\xe6\x99\x82\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe6\x83\x85\xe5\xa0\xb1\xe3\x81\x8c\xe3\x81\xaa\xe3\x81\x84\xe5\xa0\xb4\xe6\x89\x80\xe3\x82\x92\xe5\x9f\x8b\xe3\x82\x81\xe3\x82\x8b\xe8\x89\xb2\n    [out] \xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [out] \xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x81\x9f\xe8\xa7\x92\xe5\xba\xa6\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    logger.debug(\'rotateRN(N={},{})\'.format(len(imgs), num))\n    out_imgs = []\n    out_angle = []\n    for n in range(num):\n        for img in imgs:\n            i, a = rotateR(img, level, scale, border)\n            out_imgs.append(i)\n            out_angle.append(a)\n\n    return np.array(out_imgs), np.array(out_angle)\n\n\ndef flip(img, num=2):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x81\xa6\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe6\x95\xb0\xe3\x82\x92\xe6\xb0\xb4\xe5\xa2\x97\xe3\x81\x97\xe3\x81\x99\xe3\x82\x8b\n    \xe2\x80\xbb\xe8\xa9\xb3\xe7\xb4\xb0\xe3\x81\xafflipN\xe3\x81\xa8\xe3\x81\xbb\xe3\x81\xbc\xe5\x90\x8c\xe3\x81\x98\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe7\x9c\x81\xe7\x95\xa5\n    """"""\n\n    logger.debug(\'flip({},{})\'.format(img.shape, num))\n    if num < 1:\n        logger.debug(\'\\tnum < 1\')\n        return [img]\n\n    horizontal = 0\n    vertical = 1\n    # \xe3\x83\x99\xe3\x83\xbc\xe3\x82\xb9\n    out_imgs = [img.copy()]\n    # \xe4\xb8\x8a\xe4\xb8\x8b\xe5\x8f\x8d\xe8\xbb\xa2\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\n    f = cv2.flip(img, horizontal)\n    out_imgs.append(f)\n    if num > 1:\n        logger.debug(\'\\tnum > 1\')\n        # \xe5\xb7\xa6\xe5\x8f\xb3\xe5\x8f\x8d\xe8\xbb\xa2\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\n        f = cv2.flip(img, vertical)\n        out_imgs.append(f)\n\n    if num > 2:\n        logger.debug(\'\\tnum > 2\')\n        # \xe4\xb8\x8a\xe4\xb8\x8b\xe5\xb7\xa6\xe5\x8f\xb3\xe5\x8f\x8d\xe8\xbb\xa2\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\n        f = cv2.flip(cv2.flip(img, horizontal), vertical)\n        out_imgs.append(f)\n\n    return out_imgs\n\n\ndef flipN(imgs, num=2):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x95\xe3\x81\x9b\xe3\x81\xa6\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe6\x95\xb0\xe3\x82\x92\xe6\xb0\xb4\xe5\xa2\x97\xe3\x81\x97\xe3\x81\x99\xe3\x82\x8b\n    [in]  imgs:     \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in]  num:      \xe6\xb0\xb4\xe5\xa2\x97\xe3\x81\x97\xe3\x81\x99\xe3\x82\x8b\xe6\x95\xb0\xef\xbc\x88\xe6\x9c\x80\xe5\xa4\xa74\xe5\x80\x8d\xef\xbc\x89\n    [out] out_imgs: \xe5\x87\xba\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    logger.debug(\'flipN(N={},{})\'.format(len(imgs), num))\n    if num < 1:\n        logger.debug(\'\\tnum < 1\')\n        return np.array(imgs)\n\n    horizontal = 0\n    vertical = 1\n    # \xe3\x83\x99\xe3\x83\xbc\xe3\x82\xb9\n    out_imgs = imgs.copy()\n    # \xe4\xb8\x8a\xe4\xb8\x8b\xe5\x8f\x8d\xe8\xbb\xa2\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\n    f = [cv2.flip(i, horizontal) for i in imgs]\n    out_imgs.extend(f)\n    if num > 1:\n        logger.debug(\'\\tnum > 1\')\n        # \xe5\xb7\xa6\xe5\x8f\xb3\xe5\x8f\x8d\xe8\xbb\xa2\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\n        f = [cv2.flip(i, vertical) for i in imgs]\n        out_imgs.extend(f)\n\n    if num > 2:\n        logger.debug(\'\\tnum > 2\')\n        # \xe4\xb8\x8a\xe4\xb8\x8b\xe5\xb7\xa6\xe5\x8f\xb3\xe5\x8f\x8d\xe8\xbb\xa2\xe3\x82\x92\xe8\xbf\xbd\xe5\x8a\xa0\n        f = [cv2.flip(cv2.flip(i, vertical), horizontal) for i in imgs]\n        out_imgs.extend(f)\n\n    return np.array(out_imgs)\n\n\ndef whiteCheckN(imgs, val=245):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xae\xe3\x81\x86\xe3\x81\xa1\xe3\x80\x81\xe3\x81\xbb\xe3\x81\xa8\xe3\x82\x93\xe3\x81\xa9\xe7\x99\xbd\xe3\x81\x84\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe9\x99\xa4\xe5\x8e\xbb\xe3\x81\x99\xe3\x82\x8b\n    [in] imgs: \xe5\x88\xa4\xe5\xae\x9a\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in] val:  \xe9\x99\xa4\xe5\x8e\xbb\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x97\xe3\x81\x8d\xe3\x81\x84\xe5\x80\xa4\n    [out] \xe3\x81\xbb\xe3\x81\xa8\xe3\x82\x93\xe3\x81\xa9\xe7\x99\xbd\xe3\x81\x84\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe9\x99\xa4\xe5\x8e\xbb\xe3\x81\x97\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    logger.debug(\'whiteCheckN(N={},{})\'.format(len(imgs), val))\n    return np.array(\n        [i for i in imgs if(val > np.sum(i) // (i.shape[0] * i.shape[1]))]\n    )\n\n\ndef resize(img, rate, flg=cv2.INTER_NEAREST):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x92\xe5\xa4\x89\xe6\x9b\xb4\xe3\x81\x99\xe3\x82\x8b\n    [in] img:  N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\n    [in] rate: \xe5\x80\x8d\xe7\x8e\x87\n    [in] flg:  N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe6\x99\x82\xe3\x81\xae\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [out] N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    if rate < 0:\n        logger.debug(\'resize({},{},{})\'.format(\n            img.shape, rate, flg\n        ))\n        return img\n\n    size = (int(img.shape[1] * rate),\n            int(img.shape[0] * rate))\n    logger.debug(\'resize({},{},{})->{}\'.format(\n        img.shape, rate, flg, size\n    ))\n    return cv2.resize(img, size, flg)\n\n\ndef resizeP(img, pixel, flg=cv2.INTER_NEAREST):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x92\xe5\xa4\x89\xe6\x9b\xb4\xe3\x81\x99\xe3\x82\x8b\n    [in] img:   \xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x92\xe5\xa4\x89\xe6\x9b\xb4\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\n    [in] pixel: \xe7\x9f\xad\xe8\xbe\xba\xe3\x81\xae\xe5\xb9\x85\n    [in] flg:   \xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x92\xe5\xa4\x89\xe6\x9b\xb4\xe3\x81\x99\xe3\x82\x8b\xe6\x99\x82\xe3\x81\xae\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [out] \xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x92\xe5\xa4\x89\xe6\x9b\xb4\xe3\x81\x97\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    logger.debug(\'resizeP({},{},{})\'.format(img.shape, pixel, flg))\n    r_img = resize(img, pixel / np.min(img.shape[:2]), flg)\n    logger.debug(\'\\tr_img: {}\'.format(r_img.shape))\n    b_img = cv2.copyMakeBorder(\n        r_img, 0, 2, 0, 2, cv2.BORDER_CONSTANT, value=(0, 0, 0)\n    )\n    logger.debug(\'\\tb_img: {}\'.format(b_img.shape))\n    return b_img[:pixel, :pixel]\n\n\ndef resizeN(imgs, rate, flg=cv2.INTER_NEAREST):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe5\x85\xa8\xe3\x81\xa6\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe5\xa4\x89\xe6\x9b\xb4\xe3\x81\x99\xe3\x82\x8b\n    [in] img:  N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\n    [in] rate: \xe5\x80\x8d\xe7\x8e\x87\n    [in] flg:  N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe6\x99\x82\xe3\x81\xae\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [out] N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    logger.debug(\'resizeN(N={})\'.format(len(imgs)))\n    return np.array([resize(img, rate, flg) for img in imgs])\n\n\ndef size2x(imgs, flg=cv2.INTER_NEAREST):\n    """"""\n    \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x922\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\n    [in] imgs: 2\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in] flg:  2\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe6\x99\x82\xe3\x81\xae\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [out] 2\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    """"""\n\n    logger.debug(\'size2x(N={},{})\'.format(len(imgs), flg))\n    rate = 2\n    return [resize(i, rate, flg) for i in imgs]\n\n\ndef paste(fg, bg, rot=0, x=0, y=0, mask_flg=True, rand_rot_flg=True, rand_pos_flg=True):\n    """"""\n    \xe8\x83\x8c\xe6\x99\xaf\xe3\x81\xab\xe5\x89\x8d\xe6\x99\xaf\xe3\x82\x92\xe9\x87\x8d\xe3\x81\xad\xe5\x90\x88\xe3\x81\x9b\xe3\x82\x8b\n    [in]  fg:           \xe9\x87\x8d\xe3\x81\xad\xe5\x90\x88\xe3\x81\x9b\xe3\x82\x8b\xe5\x89\x8d\xe6\x99\xaf\n    [in]  bg:           \xe9\x87\x8d\xe3\x81\xad\xe5\x90\x88\xe3\x81\x9b\xe3\x82\x8b\xe8\x83\x8c\xe6\x99\xaf\n    [in]  rot:          \xe9\x87\x8d\xe3\x81\xad\xe5\x90\x88\xe3\x82\x8f\xe3\x81\x9b\xe6\x99\x82\xe3\x81\xae\xe5\x89\x8d\xe6\x99\xaf\xe5\x9b\x9e\xe8\xbb\xa2\xe8\xa7\x92\n    [in]  x:            \xe9\x87\x8d\xe3\x81\xad\xe5\x90\x88\xe3\x82\x8f\xe3\x81\x9b\xe6\x99\x82\xe3\x81\xae\xe5\x89\x8d\xe6\x99\xafx\xe4\xbd\x8d\xe7\xbd\xae\n    [in]  y:            \xe9\x87\x8d\xe3\x81\xad\xe5\x90\x88\xe3\x82\x8f\xe3\x81\x9b\xe6\x99\x82\xe3\x81\xae\xe5\x89\x8d\xe6\x99\xafy\xe4\xbd\x8d\xe7\xbd\xae\n    [in]  mask_flg:     \xe3\x83\x9e\xe3\x82\xb9\xe3\x82\xaf\xe5\x87\xa6\xe7\x90\x86\xe3\x82\x92\xe5\xa4\xa7\xe3\x81\x8d\xe3\x82\x81\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [in]  rand_rot_flg: \xe5\x89\x8d\xe6\x99\xaf\xe3\x82\x92\xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe3\x81\xab\xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [in]  rand_pos_flg: \xe5\x89\x8d\xe6\x99\xaf\xe3\x82\x92\xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe3\x81\xab\xe9\x85\x8d\xe7\xbd\xae\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [out] \xe9\x87\x8d\xe3\x81\xad\xe5\x90\x88\xe3\x81\x9b\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\n    http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_image_arithmetics/py_image_arithmetics.html#bitwise-operations\n    """"""\n\n    logger.debug(\'paste({},{},{},{},{},{},{},{})\'.format(\n        fg.shape, bg.shape, rot, x, y, mask_flg, rand_rot_flg, rand_pos_flg\n    ))\n\n    # \xe7\x94\xbb\xe7\xb4\xa0\xe3\x81\xae\xe6\x9c\x80\xe5\xa4\xa7\xe5\x80\xa4\n    max_val = 255\n\n    # Load two images\n    img1 = bg.copy()\n    white = (max_val, max_val, max_val)\n    angle = [-90, 90]  # \xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe5\x9b\x9e\xe8\xbb\xa2\xe3\x81\xae\xe7\xaf\x84\xe5\x9b\xb2\n    scale = 1.0  # \xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe6\x8b\xa1\xe5\xa4\xa7\xe7\x8e\x87\n    logger.debug(\'\\trand_rot_flg: {}\'.format(rand_rot_flg))\n    if rand_rot_flg:\n        # \xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe3\x81\xab\xe5\x9b\x9e\xe8\xbb\xa2\n        img2, rot = rotateR(fg, angle, scale, white)\n    else:\n        # \xe4\xbb\xbb\xe6\x84\x8f\xe3\x81\xae\xe8\xa7\x92\xe5\xba\xa6\xe3\x81\xa7\xe5\x9b\x9e\xe8\xbb\xa2\n        img2 = rotate(fg, rot, scale, white)\n\n    # I want to put logo on top-left corner, So I create a ROI\n    w1, h1 = img1.shape[:2]\n    w2, h2 = img2.shape[:2]\n    logger.debug(\'\\trand_pos_flg: {}\'.format(rand_pos_flg))\n    if rand_pos_flg:\n        x = np.random.randint(0, w1 - w2 + 1)\n        y = np.random.randint(0, w1 - w2 + 1)\n\n    roi = img1[x:x + w2, y:y + h2]\n    logger.debug(\'\\trot:{}, pos:({},{}), shape:{}\'.format(\n        rot, x, y, roi.shape))\n\n    def masked(img):\n        logger.debug(\'masked({})\'.format(img.shape))\n        if len(img.shape) < 3:\n            return False\n        elif img.shape[2] != 4:\n            return False\n        else:\n            return True\n\n    # Now create a mask of logo and create its inverse mask also\n    if not masked(img2):\n        thresh = 10\n        mask = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)\n        ret, mask = cv2.threshold(\n            cv2.bitwise_not(mask), thresh, max_val, cv2.THRESH_BINARY\n        )\n    else:\n        mask = img2[:, :, 3]\n\n    thresh = 200\n    ret, mask_inv = cv2.threshold(\n        cv2.bitwise_not(mask), thresh, max_val, cv2.THRESH_BINARY\n    )\n\n    if mask_flg:\n        kernel1 = np.ones((5, 5), np.uint8)\n        kernel2 = np.ones((3, 3), np.uint8)\n        mask_inv = cv2.dilate(mask_inv, kernel1, iterations=1)\n        mask_inv = cv2.erode(mask_inv, kernel2, iterations=1)\n\n    # Now black-out the area of logo in ROI\n    img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)\n\n    # Take only region of logo from logo image.\n    img2_fg = cv2.bitwise_and(img2, img2, mask=mask)\n\n    # Put logo in ROI and modify the main image\n    dst = cv2.add(img1_bg, img2_fg)\n    img1[x:x + w2, y:y + h2] = dst\n    logger.debug(\'\\timg1.shape: {}\'.format(img1.shape))\n    return img1, (rot, x, y)\n\n\ndef arr2x(arr, flg=cv2.INTER_NEAREST):\n    """"""\n    \xe8\xa1\x8c\xe5\x88\x97\xe3\x82\x92\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x97\xe3\x80\x81\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x922\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\n    [in] arr: 2\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe8\xa1\x8c\xe5\x88\x97\n    [in] flg: 2\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe6\x99\x82\xe3\x81\xae\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [out] 2\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe8\xa1\x8c\xe5\x88\x97\n    """"""\n\n    logger.debug(\'arr2x({},{})\'.format(arr.shape, flg))\n    return imgs2arr(size2x(arr2imgs(arr), flg))\n\n\ndef arrNx(arr, rate, flg=cv2.INTER_NEAREST):\n    """"""\n    \xe8\xa1\x8c\xe5\x88\x97\xe3\x82\x92\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x97\xe3\x80\x81\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x82\x92N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\n    [in] arr:  N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe8\xa1\x8c\xe5\x88\x97\n    [in] rate: \xe5\x80\x8d\xe7\x8e\x87\n    [in] flg:  N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x99\xe3\x82\x8b\xe6\x99\x82\xe3\x81\xae\xe3\x83\x95\xe3\x83\xa9\xe3\x82\xb0\n    [out] N\xe5\x80\x8d\xe3\x81\xab\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe8\xa1\x8c\xe5\x88\x97\n    """"""\n\n    #logger.debug(\'arrNx({},{},{})\'.format(arr.shape, rate, flg))\n    if(len(arr.shape) == 3):\n        img = arr2img(arr)\n        return img2arr(resize(img, rate, flg))\n\n    if(len(arr.shape) == 4):\n        imgs = arr2imgs(arr)\n        return imgs2arr(resizeN(imgs, rate, flg))\n\n\ndef img2arr(img, norm=255, dtype=np.float32, gpu=-1):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92Chainer\xe3\x81\xa7\xe5\x88\xa9\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\n    \xe2\x80\xbb\xe8\xa9\xb3\xe7\xb4\xb0\xe3\x81\xafimgs2arr\xe3\x81\xa8\xe3\x81\xbb\xe3\x81\xbc\xe5\x90\x8c\xe3\x81\x98\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe7\x9c\x81\xe7\x95\xa5\n    """"""\n\n    # logger.debug(\'img2arr({},{},{},{})\'.format(\n    # img.shape, norm, dtype.__name__, gpu\n    # ))\n    try:\n        w, h, _ = img.shape\n    except:\n        w, h = img.shape[:2]\n\n    if(gpu >= 0):\n        return xp.array(img, dtype=dtype).reshape((-1, w, h)) / norm\n    else:\n        return np.array(img, dtype=dtype).reshape((-1, w, h)) / norm\n\n\ndef imgs2arr(imgs, norm=255, dtype=np.float32, gpu=-1):\n    """"""\n    \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe3\x82\x92Chainer\xe3\x81\xa7\xe5\x88\xa9\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\n    [in]  imgs:  \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in]  norm:  \xe6\xad\xa3\xe8\xa6\x8f\xe5\x8c\x96\xe3\x81\x99\xe3\x82\x8b\xe5\x80\xa4\xef\xbc\x88255\xe3\x81\xa7\xe3\x81\x82\xe3\x82\x8c\xe3\x81\xb0\xe3\x80\x810-255\xe3\x82\x920-1\xe3\x81\xab\xe6\xad\xa3\xe8\xa6\x8f\xe5\x8c\x96\xe3\x81\x99\xe3\x82\x8b\xef\xbc\x89\n    [in]  dtype: \xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbf\xe3\x82\xa4\xe3\x83\x97\n    [in]  gpu:   GPU\xe3\x82\x92\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xafGPUID\xe3\x82\x92\xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x99\xe3\x82\x8b\n    [out] \xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe8\xa1\x8c\xe5\x88\x97\n    """"""\n\n    # logger.debug(\'imgs2arr(N={},{},{},{})\'.format(\n    #     len(imgs), norm, dtype.__name__, gpu\n    # ))\n    try:\n        w, h, ch = imgs[0].shape\n    except:\n        w, h = imgs[0].shape\n        ch = 1\n\n    if(gpu >= 0):\n        return xp.array(imgs, dtype=dtype).reshape((-1, ch, w, h)) / norm\n    else:\n        return np.array(imgs, dtype=dtype).reshape((-1, ch, w, h)) / norm\n\n\ndef arr2img(arr, norm=255, dtype=np.uint8):\n    """"""\n    Chainer\xe3\x81\xae\xe5\x87\xba\xe5\x8a\x9b\xe3\x82\x92OpenCV\xe3\x81\xa7\xe5\x8f\xaf\xe8\xa6\x96\xe5\x8c\x96\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\xe5\x85\xa5\xe5\x8a\x9b\xef\xbc\x88\xe5\x8d\x98\xe7\x94\xbb\xe5\x83\x8f\xe7\x94\xa8\xef\xbc\x89\n    \xe2\x80\xbb\xe8\xa9\xb3\xe7\xb4\xb0\xe3\x81\xafarr2imgs\xe3\x81\xa8\xe3\x81\xbb\xe3\x81\xbc\xe5\x90\x8c\xe3\x81\x98\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe7\x9c\x81\xe7\x95\xa5\n    """"""\n\n    try:\n        ch, h, w = arr.shape\n    except:\n        h, w = arr.shape\n        ch = 1\n\n    y = np.array(arr).reshape((h, w, ch)) * norm\n    # logger.debug(\'arr2img({},{},{})->{}\'.format(\n    #     arr.shape, norm, dtype.__name__, y.shape\n    # ))\n    return np.array(y, dtype=dtype)\n\n\ndef arr2imgs(arr, norm=255, dtype=np.uint8):\n    """"""\n    Chainer\xe3\x81\xae\xe5\x87\xba\xe5\x8a\x9b\xe3\x82\x92OpenCV\xe3\x81\xa7\xe5\x8f\xaf\xe8\xa6\x96\xe5\x8c\x96\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\xef\xbc\x88\xe7\x94\xbb\xe5\x83\x8f\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\xe7\x94\xa8\xef\xbc\x89\n    [in]  arr:   Chainer\xe3\x81\x8b\xe3\x82\x89\xe5\x87\xba\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe8\xa1\x8c\xe5\x88\x97\n    [in]  norm:  \xe6\xad\xa3\xe8\xa6\x8f\xe5\x8c\x96\xe3\x82\x92\xe3\x82\x82\xe3\x81\xa8\xe3\x81\xab\xe6\x88\xbb\xe3\x81\x99\xe6\x95\xb0\xef\xbc\x88255\xe3\x81\xa7\xe3\x81\x82\xe3\x82\x8c\xe3\x81\xb0\xe3\x80\x810-1\xe3\x82\x920-255\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\xef\xbc\x89\n    [in]  dtype: \xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbf\xe3\x82\xa4\xe3\x83\x97\n    [out] OpenCV\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xab\xe5\xa4\x89\xe6\x8f\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe8\xa1\x8c\xe5\x88\x97\n    """"""\n\n    try:\n        ch, size = arr.shape[1], arr.shape[2]\n    except:\n        logger.error(\'input data is not img arr\')\n        logger.error(fileFuncLine())\n        exit(1)\n\n    y = np.array(arr).reshape((-1, size, size, ch)) * norm\n    # logger.debug(\'arr2imgs({},{},{})->{}\'.format(\n    #     arr.shape, norm, dtype.__name__, y.shape\n    # ))\n    return np.array(y, dtype=dtype)\n'"
Tools/npz2jpg.py,8,"b""#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = '\xe4\xbd\x9c\xe6\x88\x90\xe3\x81\x97\xe3\x81\x9f\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xef\xbc\x88.npz\xef\xbc\x89\xe3\x81\xae\xe4\xb8\xad\xe8\xba\xab\xe3\x82\x92\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xa8\xe3\x81\x97\xe3\x81\xa6\xe5\x87\xba\xe5\x8a\x9b\xe3\x81\x99\xe3\x82\x8b'\n#\n\nimport os\nimport cv2\nimport sys\nimport argparse\nimport numpy as np\n\n[sys.path.append(d) for d in ['./Lib/', '../Lib/'] if os.path.isdir(d)]\nfrom func import argsPrint, getFilePath\nimport imgfunc as IMG\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument('npz',\n                        help='\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8bnpz\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9')\n    parser.add_argument('--img_num', '-n', type=int, default=10,\n                        help='\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\xe7\x94\xbb\xe5\x83\x8f\xe6\x95\xb0 [default: 10]')\n    parser.add_argument('--random_seed', '-s', type=int, default=2,\n                        help='\xe4\xb9\xb1\xe6\x95\xb0\xe3\x82\xb7\xe3\x83\xbc\xe3\x83\x89 [default: 2, random: -1]')\n    parser.add_argument('--img_rate', '-r', type=float, default=1,\n                        help='\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xae\xe5\x80\x8d\xe7\x8e\x87 [default: 1]')\n    parser.add_argument('-o', '--out_path', default='./result/',\n                        help='\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xae\xe5\x87\xba\xe5\x8a\x9b\xe5\x85\x88 [default: ./result/]')\n    parser.add_argument('--only_x', action='store_true',\n                        help='x\xe3\x81\xa0\xe3\x81\x91\xe3\x82\x92\xe8\xa1\xa8\xe7\xa4\xba\xe3\x81\x99\xe3\x82\x8b')\n    return parser.parse_args()\n\n\ndef main(args):\n    # NPZ\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x82\x92\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\n    np_arr = np.load(args.npz)\n    x = IMG.arr2imgs(np_arr['x'])\n    if not args.only_x:\n        y = IMG.arr2imgs(np_arr['y'])\n        ch = 3\n        if(x.shape[ch] > y.shape[ch]):\n            y = [cv2.cvtColor(i, cv2.COLOR_GRAY2RGB) for i in y]\n            y = np.array(y)\n\n        if(x.shape[ch] > y.shape[ch]):\n            x = [cv2.cvtColor(i, cv2.COLOR_GRAY2RGB) for i in x]\n            x = np.array(x)\n\n    # \xe5\x85\xa8\xe3\x81\xa6\xe3\x82\x92\xe7\x94\xbb\xe5\x83\x8f\xe5\x8c\x96\xe3\x81\x99\xe3\x82\x8b\xe3\x81\xae\xe3\x81\xaf\xe7\x84\xa1\xe9\xa7\x84\xe3\x81\xaa\xe3\x81\xae\xe3\x81\xa7\xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe3\x81\xab\xe6\x8a\xbd\xe5\x87\xba\xe3\x81\x99\xe3\x82\x8b\n    if(args.random_seed >= 0):\n        np.random.seed(args.random_seed)\n\n    shuffle = np.random.permutation(range(len(x)))\n    # \xe3\x83\xa9\xe3\x83\xb3\xe3\x83\x80\xe3\x83\xa0\xe3\x81\xab\xe6\x8a\xbd\xe5\x87\xba\xe3\x81\x97\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe7\xb5\x90\xe5\x90\x88\xe3\x81\x99\xe3\x82\x8b\n    # \xe4\xb8\x8a\xe5\x8d\x8a\xe5\x88\x86\xe3\x81\xab\xe3\x81\xafx\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92img_num\xe3\x81\xae\xe6\x95\xb0\xe3\x81\xa0\xe3\x81\x91\n    # \xe4\xb8\x8b\xe5\x8d\x8a\xe5\x88\x86\xe3\x81\xab\xe3\x81\xafy\xe3\x81\xae\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92img_num\xe3\x81\xae\xe6\x95\xb0\xe3\x81\xa0\xe3\x81\x91\xe7\xb5\x90\xe5\x90\x88\xe3\x81\x97\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe4\xbd\x9c\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\n    if not args.only_x:\n        img = np.vstack((np.hstack(x[shuffle[:args.img_num]]),\n                         np.hstack(y[shuffle[:args.img_num]])))\n    else:\n        img = np.hstack(x[shuffle[:args.img_num]])\n\n    # \xe3\x81\x9d\xe3\x81\xae\xe3\x81\xbe\xe3\x81\xbe\xe3\x81\xae\xe3\x82\xb5\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xa7\xe3\x81\xaf\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\x8c\xe5\xb0\x8f\xe3\x81\x95\xe3\x81\x84\xe3\x81\xae\xe3\x81\xa7\xe3\x80\x81\xe6\x8b\xa1\xe5\xa4\xa7\xe3\x81\x99\xe3\x82\x8b\n    img = IMG.resize(img, args.img_rate, cv2.INTER_NEAREST)\n    # \xe4\xbd\x9c\xe6\x88\x90\xe3\x81\x97\xe3\x81\x9f\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe8\xa1\xa8\xe7\xa4\xba\xe3\x83\xbb\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\n    cv2.imshow('test', img)\n    cv2.waitKey(0)\n    cv2.imwrite(getFilePath(args.out_path, 'npz2jpg', '.jpg'), img)\n\n\nif __name__ == '__main__':\n    args = command()\n    argsPrint(args)\n    main(args)\n"""
Tools/plot_diff.py,3,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'log\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\xae\xe8\xa4\x87\xe6\x95\xb0\xe6\xaf\x94\xe8\xbc\x83\'\n#\n\nimport json\nimport argparse\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom func import argsPrint, getFilePath, sortTimeStamp\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument(\'log_dir\', nargs=\'+\',\n                        help=\'\xe5\x85\xa5\xe5\x8a\x9b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xbb\xe3\x83\x83\xe3\x83\x88\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\')\n    parser.add_argument(\'--auto_ylim\', action=\'store_true\',\n                        help=\'ylim\xe8\x87\xaa\xe5\x8b\x95\xe8\xa8\xad\xe5\xae\x9a\')\n    parser.add_argument(\'-l\', \'--label\', default=\'loss\',\n                        help=\'\xe5\x8f\x96\xe5\xbe\x97\xe3\x81\x99\xe3\x82\x8b\xe3\x83\xa9\xe3\x83\x99\xe3\x83\xab(default: loss, other: lr, all)\')\n    parser.add_argument(\'-o\', \'--out_path\', default=\'./result/\',\n                        help=\'\xe7\x94\x9f\xe6\x88\x90\xe7\x89\xa9\xe3\x81\xae\xe4\xbf\x9d\xe5\xad\x98\xe5\x85\x88(default: ./result/)\')\n    parser.add_argument(\'--no_show\', action=\'store_true\',\n                        help=\'plt.show()\xe3\x82\x92\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x97\xe3\x81\xaa\xe3\x81\x84\')\n\n    return parser.parse_args()\n\n\ndef jsonRead(path):\n    """"""\n    chainer\xe3\x81\xaeextension\xe3\x81\xa7\xe5\x87\xba\xe5\x8a\x9b\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9flog\xe3\x82\x92json\xe3\x81\xa7\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x80\n    [in]  path: log\xe3\x81\xae\xe3\x83\x91\xe3\x82\xb9\n    [out] d:    \xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x82\x93\xe3\x81\xa0\xe8\xbe\x9e\xe6\x9b\xb8\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\n    """"""\n\n    try:\n        with open(path, \'r\') as f:\n            d = json.load(f)\n\n    except json.JSONDecodeError as e:\n        print(\'JSONDecodeError: \', e)\n        exit()\n\n    return d\n\n\ndef subplot(sub, val, log, ylim, line, header):\n    """"""\n    subplot\xe3\x82\x92\xe8\x87\xaa\xe5\x8b\x95\xe5\x8c\x96\n    [in] sub:    subplot\xe3\x82\xaa\xe3\x83\x96\xe3\x82\xb8\xe3\x82\xa7\xe3\x82\xaf\xe3\x83\x88\n    [in] val:    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x99\xe3\x82\x8b\xe5\x80\xa4\xe3\x81\xae\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in] log:    \xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x99\xe3\x82\x8b\xe3\x83\xa9\xe3\x83\x99\xe3\x83\xab\xe3\x81\xae\xe3\x83\xaa\xe3\x82\xb9\xe3\x83\x88\n    [in] ylim:   auto_ylim\xe3\x82\x92\xe4\xbd\xbf\xe7\x94\xa8\xe3\x81\x99\xe3\x82\x8b\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xafTrue\n    [in] header: \xe3\x83\xa9\xe3\x83\x99\xe3\x83\xab\xe3\x81\xae\xe3\x83\x98\xe3\x83\x83\xe3\x83\x80\n    """"""\n\n    # \xe3\x82\xb0\xe3\x83\xaa\xe3\x83\x83\xe3\x83\x89\xe3\x82\x92\xe7\x81\xb0\xe8\x89\xb2\xe3\x81\xae\xe7\x82\xb9\xe7\xb7\x9a\xe3\x81\xa7\xe6\x8f\x8f\xe7\x94\xbb\xe3\x81\x99\xe3\x82\x8b\n    sub.grid(which=\'major\', color=\'gray\', linestyle=\':\')\n    sub.grid(which=\'minor\', color=\'gray\', linestyle=\':\')\n    sub.set_yscale(""log"")\n    # args.auto_ylim\xe3\x81\x8c\xe8\xa8\xad\xe5\xae\x9a\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe5\xa0\xb4\xe5\x90\x88\xe3\x80\x81ylim\xe3\x82\x92\xe8\xa8\xad\xe5\xae\x9a\xe3\x81\x99\xe3\x82\x8b\n    # ymax: \xe5\x90\x84\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae1/8\xe7\x95\xaa\xe7\x9b\xae\xef\xbc\x88400\xe5\x80\x8b\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\x8c\xe3\x81\x82\xe3\x82\x8c\xe3\x81\xb050\xe7\x95\xaa\xe7\x9b\xae\xef\xbc\x89\xe3\x81\xae\xe3\x81\x86\xe3\x81\xa1\xe6\x9c\x80\xe5\xb0\x8f\xe3\x81\xae\xe6\x95\xb0\xe3\x82\x92\xe6\x9c\x80\xe5\xa4\xa7\xe5\x80\xa4\xe3\x81\xa8\xe3\x81\x99\xe3\x82\x8b\n    # ymin: \xe5\x90\x84\xe3\x83\x87\xe3\x83\xbc\xe3\x82\xbf\xe3\x81\xae\xe3\x81\x86\xe3\x81\xa1\xe6\x9c\x80\xe5\xb0\x8f\xe3\x81\xae\xe6\x95\xb0X0.98\xe3\x82\x92\xe6\x9c\x80\xe5\xb0\x8f\xe5\x80\xa4\xe3\x81\xa8\xe3\x81\x99\xe3\x82\x8b\n    if ylim:\n        ymax = np.min([i[int(len(i) / 8)] for i in val])\n        ymin = np.min([np.min(i)for i in val]) * 0.98\n        sub.set_ylim([ymin, ymax])\n        print(\'ymin:{0:.4f}, ymax:{1:.4f}\'.format(ymin, ymax))\n\n    # \xe3\x83\x97\xe3\x83\xad\xe3\x83\x83\xe3\x83\x88\n    def getX(y):\n        return list(range(1, len(y)+1))\n\n    def getY(y):\n        return np.array(y)\n\n    def getLabel(header, body):\n        return \'[\' + header + \'] \' + body\n\n    [sub.plot(getX(v), getY(v), label=getLabel(header, d), linestyle=line)\n     for v, d in zip(val, log)]\n\n\ndef savePNG(plt, loc, name, dpi=200):\n    """"""\n    png\xe5\xbd\xa2\xe5\xbc\x8f\xe3\x81\xa7\xe3\x81\xae\xe4\xbf\x9d\xe5\xad\x98\xe3\x82\x92\xe8\x87\xaa\xe5\x8b\x95\xe5\x8c\x96\n    [in] plt:  plt\xe3\x82\xaa\xe3\x83\x96\xe3\x82\xb8\xe3\x82\xa7\xe3\x82\xaf\xe3\x83\x88\n    [in] loc:  \xe3\x83\xa9\xe3\x83\x99\xe3\x83\xab\xe3\x81\xae\xe4\xbd\x8d\xe7\xbd\xae\n    [in] name: \xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe5\x90\x8d\n    [in] dpi:  \xe4\xbf\x9d\xe5\xad\x98\xe6\x99\x82\xe3\x81\xae\xe8\xa7\xa3\xe5\x83\x8f\xe5\xba\xa6\n    """"""\n\n    plt.legend(loc=loc)\n    plt.savefig(getFilePath(args.out_path, name, \'.png\'), dpi=dpi)\n\n\ndef plot(args, loc, name, solid_line, dotted_line=\'\', no_show=False):\n    """"""\n    \xe3\x83\x97\xe3\x83\xad\xe3\x83\x83\xe3\x83\x88\xe3\x83\xa1\xe3\x82\xa4\xe3\x83\xb3\xe9\x83\xa8\n    [in] args:   \xe3\x82\xaa\xe3\x83\x97\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\xb3\xe5\xbc\x95\xe6\x95\xb0\n    [in] loc:    \xe3\x83\xa9\xe3\x83\x99\xe3\x83\xab\xe3\x81\xae\xe4\xbd\x8d\xe7\xbd\xae\n    [in] name:   \xe4\xbf\x9d\xe5\xad\x98\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe5\x90\x8d\n    [in] solid_line: \xe6\x8e\xa2\xe7\xb4\xa2\xe3\x83\xa9\xe3\x83\x99\xe3\x83\xab\xef\xbc\x88\xe5\xae\x9f\xe7\xb7\x9a\xef\xbc\x89\n    [in] dotted_line: \xe6\x8e\xa2\xe7\xb4\xa2\xe3\x83\xa9\xe3\x83\x99\xe3\x83\xab\xef\xbc\x88\xe7\x82\xb9\xe7\xb7\x9a\xef\xbc\x89\n    """"""\n\n    sol = []\n    dot = []\n    log_file = []\n    for l in sortTimeStamp(args.log_dir, \'.log\'):\n        log_file.append(l)\n        print(log_file[-1])\n        data = jsonRead(log_file[-1])\n        sol.append([i[solid_line] for i in data if(solid_line in i.keys())])\n        dot.append([i[dotted_line] for i in data if(dotted_line in i.keys())])\n\n    # log\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\x8c\xe8\xa6\x8b\xe3\x81\xa4\xe3\x81\x8b\xe3\x82\x89\xe3\x81\xaa\xe3\x81\x8b\xe3\x81\xa3\xe3\x81\x9f\xe5\xa0\xb4\xe5\x90\x88\xe3\x80\x81\xe3\x81\x93\xe3\x81\x93\xe3\x81\xa7\xe7\xb5\x82\xe4\xba\x86\n    if not sol:\n        print(\'[Error] .log not found\')\n        exit()\n\n    if len(sol[0]) == 0:\n        print(\'[Error] data not found:\', solid_line)\n        return 0\n\n    # \xe5\xaf\xbe\xe6\x95\xb0\xe3\x82\xb0\xe3\x83\xa9\xe3\x83\x95\xe3\x81\xae\xe8\xa8\xad\xe5\xae\x9a\n    f = plt.figure(figsize=(10, 6))\n    a = f.add_subplot(111)\n    plt.xlabel(\'epoch\')\n    plt.ylabel(name.split(\'_\')[-1])\n    subplot(a, sol, log_file, args.auto_ylim, \'-\', \'test \')\n    plt.gca().set_prop_cycle(None)\n    subplot(a, dot, log_file, args.auto_ylim, \':\', \'train\')\n\n    # \xe3\x82\xb0\xe3\x83\xa9\xe3\x83\x95\xe3\x81\xae\xe4\xbf\x9d\xe5\xad\x98\xe3\x81\xa8\xe8\xa1\xa8\xe7\xa4\xba\n    savePNG(plt, loc, name)\n    if not no_show:\n        plt.show()\n\n\ndef main(args):\n    if(args.label == \'loss\' or args.label == \'all\'):\n        plot(args, \'upper right\', \'plot_diff_loss\',\n             \'validation/main/loss\', \'main/loss\',\n             no_show=args.no_show)\n\n    if(args.label == \'acc\' or args.label == \'all\'):\n        plot(args, \'lower right\', \'plot_diff_acc\',\n             \'validation/main/accuracy\', \'main/accuracy\',\n             no_show=args.no_show)\n\n    if(args.label == \'lr\' or args.label == \'all\'):\n        plot(args, \'lower right\', \'plot_diff_lr\', \'lr\',\n             no_show=args.no_show)\n\n\nif __name__ == \'__main__\':\n    args = command()\n    argsPrint(args)\n    main(args)\n'"
Tools/png_monitoring.py,0,"b""#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = '\xe4\xbb\xbb\xe6\x84\x8f\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\xe3\x81\xae\xe7\x9b\xa3\xe8\xa6\x96'\n#\n\nimport os\nimport time\nimport argparse\nimport shutil\n\nfrom func import ChangeHandler\nfrom watchdog.observers import Observer\n\n\ndef command():\n    parser = argparse.ArgumentParser(description=help)\n    parser.add_argument('monitor', help='\xe7\x9b\xa3\xe8\xa6\x96\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80')\n    parser.add_argument('copy', help='\xe3\x82\xb3\xe3\x83\x94\xe3\x83\xbc\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80')\n    parser.add_argument('--force', action='store_true',\n                        help='monotor\xe3\x81\xa8copy\xe3\x81\xae\xe3\x83\x95\xe3\x82\xa9\xe3\x83\xab\xe3\x83\x80\xe3\x81\x8c\xe3\x81\xaa\xe3\x81\x84\xe5\xa0\xb4\xe5\x90\x88\xe3\x81\xab\xe5\xbc\xb7\xe5\x88\xb6\xe7\x9a\x84\xe3\x81\xab\xe4\xbd\x9c\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b')\n    return parser.parse_args()\n\n\nclass PNGMonitor(ChangeHandler):\n    def __init__(self, copy):\n        self.copy = copy\n\n    def on_modified(self, event):\n        path1, name1, ext = super().on_modified(event)\n        if('png' in ext.lower()):\n            time.sleep(1)\n            path2 = os.path.join(self.copy, name1)\n            shutil.copy2(path1, path2)\n\n\ndef main(monitor, copy):\n    while 1:\n        event_handler = PNGMonitor(copy)\n        observer = Observer()\n        observer.schedule(event_handler, monitor, recursive=True)\n        observer.start()\n        try:\n            while True:\n                time.sleep(1)\n        except KeyboardInterrupt:\n            observer.stop()\n\n        observer.join()\n\n\nif __name__ in '__main__':\n    args = command()\n    print('Monitoring :', args.monitor)\n    print('Copy to :', args.copy)\n    print('Exit: Ctrl-c')\n\n    if not os.path.isdir(args.monitor):\n        if args.force:\n            os.makedirs(args.monitor)\n        else:\n            print('[Error] monitor folder not found:', args.monitor)\n            exit()\n\n    if not os.path.isdir(args.copy):\n        if args.force:\n            os.makedirs(args.copy)\n        else:\n            print('[Error] copy folder not found:', args.copy)\n            exit()\n\n    main(args.monitor, args.copy)\n"""
Tools/pruning.py,0,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'\xe3\x83\xa2\xe3\x83\x87\xe3\x83\xab\xe3\x81\xae\xe6\x9e\x9d\xe5\x88\x88\xe3\x82\x92\xe3\x81\x99\xe3\x82\x8b\'\n#\n\nimport numpy\n\nimport chainer\nimport chainer.links as L\nfrom chainer import training\nimport chainer.cuda\n\n\ndef create_layer_mask(weights, pruning_rate, xp=chainer.cuda.cupy):\n\n    if weights.data is None:\n        raise Exception(""Some weights of layer is None."")\n\n    abs_W = xp.abs(weights.data)\n    data = xp.sort(xp.ndarray.flatten(abs_W))\n    num_prune = int(len(data) * pruning_rate)\n    idx_prune = min(num_prune, len(data)-1)\n    threshould = data[idx_prune]\n\n    mask = abs_W\n    mask[mask < threshould] = 0\n    mask[mask >= threshould] = 1\n    return mask\n\n\n\'\'\'Returns a trainer extension to fix pruned weight of the model.\n\'\'\'\n\n\ndef create_model_mask(model, pruning_rate, gpu_id):\n    masks = {}\n    xp = numpy\n    if gpu_id >= 0:\n        xp = chainer.cuda.cupy\n\n    for name, link in model.namedlinks():\n        # specify pruned layer\n        if type(link) not in (L.Convolution2D, L.Linear):\n            continue\n        mask = create_layer_mask(link.W, pruning_rate, xp)\n        masks[name] = mask\n    return masks\n\n\ndef prune_weight(model, masks):\n    for name, link in model.namedlinks():\n        if name not in masks.keys():\n            continue\n        mask = masks[name]\n        link.W.data = link.W.data * mask\n\n\n\'\'\'Returns a trainer extension to fix pruned weight of the model.\n\'\'\'\n\n\ndef pruned(model, masks):\n    @training.make_extension(trigger=(1, \'iteration\'))\n    def _pruned(trainer):\n        prune_weight(model, masks)\n    return _pruned\n'"
Tools/Tests/test_getfunc.py,0,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'getfunc\xe3\x81\xae\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88\xe7\x94\xa8\xe3\x82\xb3\xe3\x83\xbc\xe3\x83\x89\'\n#\n\nimport logging\n# basicConfig()\xe3\x81\xaf\xe3\x80\x81 debug()\xe3\x82\x84info()\xe3\x82\x92\xe6\x9c\x80\xe5\x88\x9d\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99""\xe5\x89\x8d""\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99\xe3\x81\x93\xe3\x81\xa8\nlogging.basicConfig(format=\'%(message)s\')\nlevel = logging.INFO\nlogging.getLogger(\'Tools\').setLevel(level=level)\n\nimport unittest\n\nimport getfunc as GET\n\n\nclass TestGetFunc(unittest.TestCase):\n\n    def test_lossfun(self):\n        self.assertEqual(\n            GET.lossfun(\'mse\').__name__, \'mean_squared_error\'\n        )\n        self.assertEqual(\n            GET.lossfun(\'mae\').__name__, \'mean_absolute_error\'\n        )\n        self.assertEqual(\n            GET.lossfun(\'ber\').__name__, \'bernoulli_nll\'\n        )\n        self.assertEqual(\n            GET.lossfun(\'gauss_kl\').__name__, \'gaussian_kl_divergence\'\n        )\n        self.assertEqual(\n            GET.lossfun(\'test\').__name__, \'mean_squared_error\'\n        )\n        self.assertEqual(\n            GET.lossfun(\'\').__name__, \'mean_squared_error\'\n        )\n\n    def test_actfun(self):\n        self.assertEqual(\n            GET.actfun(\'relu\').__name__, \'relu\'\n        )\n        self.assertEqual(\n            GET.actfun(\'elu\').__name__, \'elu\'\n        )\n        self.assertEqual(\n            GET.actfun(\'c_relu\').__name__, \'clipped_relu\'\n        )\n        self.assertEqual(\n            GET.actfun(\'l_relu\').__name__, \'leaky_relu\'\n        )\n        self.assertEqual(\n            GET.actfun(\'sigmoid\').__name__, \'sigmoid\'\n        )\n        self.assertEqual(\n            GET.actfun(\'h_sigmoid\').__name__, \'hard_sigmoid\'\n        )\n        self.assertEqual(\n            GET.actfun(\'tanh\').__name__, \'tanh\'\n        )\n        self.assertEqual(\n            GET.actfun(\'s_plus\').__name__, \'softplus\'\n        )\n        self.assertEqual(\n            GET.actfun(\'none\').__name__, \'F_None\'\n        )\n        self.assertEqual(\n            GET.actfun(\'test\').__name__, \'relu\'\n        )\n        self.assertEqual(\n            GET.actfun(\'\').__name__, \'relu\'\n        )\n\n    def test_optimizer(self):\n        self.assertEqual(\n            GET.optimizer(\'adam\').__class__.__name__, \'Adam\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'ada_d\').__class__.__name__, \'AdaDelta\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'ada_g\').__class__.__name__, \'AdaGrad\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'m_sgd\').__class__.__name__, \'MomentumSGD\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'n_ag\').__class__.__name__, \'NesterovAG\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'rmsp\').__class__.__name__, \'RMSprop\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'rmsp_g\').__class__.__name__, \'RMSpropGraves\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'sgd\').__class__.__name__, \'SGD\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'smorms\').__class__.__name__, \'SMORMS3\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'test\').__class__.__name__, \'Adam\'\n        )\n        self.assertEqual(\n            GET.optimizer(\'\').__class__.__name__, \'Adam\'\n        )\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
Tools/Tests/test_imgfunc.py,6,"b'#!/usr/bin/env python3\n# -*-coding: utf-8 -*-\n#\nhelp = \'imgfunc\xe3\x81\xae\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88\xe7\x94\xa8\xe3\x82\xb3\xe3\x83\xbc\xe3\x83\x89\'\n#\n\nimport logging\n# basicConfig()\xe3\x81\xaf\xe3\x80\x81 debug()\xe3\x82\x84info()\xe3\x82\x92\xe6\x9c\x80\xe5\x88\x9d\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99""\xe5\x89\x8d""\xe3\x81\xab\xe5\x91\xbc\xe3\x81\xb3\xe5\x87\xba\xe3\x81\x99\xe3\x81\x93\xe3\x81\xa8\nlogging.basicConfig(format=\'%(message)s\')\nlevel = logging.INFO\nlogging.getLogger(\'Tools\').setLevel(level=level)\n\nimport cv2\nimport unittest\nimport numpy as np\n\nimport imgfunc as IMG\n\nlenna_path = \'./Tests/Lenna.bmp\'\nmandrill_path = \'./Tests/Mandrill.bmp\'\n\n\nclass TestImgFunc(unittest.TestCase):\n\n    def test_getCh(self):\n        self.assertEqual(IMG.getCh(-1), cv2.IMREAD_UNCHANGED)\n        self.assertEqual(IMG.getCh(0), cv2.IMREAD_UNCHANGED)\n        self.assertEqual(IMG.getCh(1), cv2.IMREAD_GRAYSCALE)\n        self.assertEqual(IMG.getCh(2), cv2.IMREAD_UNCHANGED)\n        self.assertEqual(IMG.getCh(3), cv2.IMREAD_COLOR)\n        self.assertEqual(IMG.getCh(4), cv2.IMREAD_UNCHANGED)\n        self.assertEqual(IMG.getCh(2.5), cv2.IMREAD_UNCHANGED)\n\n    def test_blank(self):\n        img = IMG.blank((128, 128, 3), 0)\n        self.assertEqual(img.shape, (128, 128, 3))\n        self.assertEqual(np.sum(img), 0)\n        with self.assertRaises(SystemExit):\n            img = IMG.blank((128, 128, -1), 0)\n\n        img = IMG.blank((128, 128, 3), -1)\n        self.assertEqual(img.shape, (128, 128, 3))\n        self.assertEqual(np.sum(img), 0)\n        img = IMG.blank((128, 128, 1), -1)\n        self.assertEqual(img.shape, (128, 128, 1))\n        self.assertEqual(np.sum(img), 0)\n        img = IMG.blank((128, 128), -1)\n        self.assertEqual(img.shape, (128, 128, 1))\n        self.assertEqual(np.sum(img), 0)\n        img = IMG.blank((128, 128, 3), (255, 255, 255))\n        self.assertEqual(img.shape, (128, 128, 3))\n        self.assertEqual(np.sum(img), 255 * 128 * 128 * 3)\n        img = IMG.blank((128, 128), (255, 255, 255))\n        self.assertEqual(img.shape, (128, 128, 3))\n        self.assertEqual(np.sum(img), 255 * 128 * 128 * 3)\n\n    def test_isImgPath(self):\n        self.assertTrue(IMG.isImgPath(lenna_path))\n        self.assertFalse(IMG.isImgPath(\'./Tools/Tests/Lenno.bmp\'))\n        self.assertFalse(IMG.isImgPath(None))\n        self.assertFalse(IMG.isImgPath(0))\n\n    def test_encodeDecode(self):\n        l = cv2.imread(lenna_path)\n        m = cv2.imread(mandrill_path)\n        self.assertEqual(len(IMG.encodeDecodeN([l, m], 3)), 2)\n        self.assertEqual(len(IMG.encodeDecodeN([l, m], 1)), 2)\n        l = cv2.imread(lenna_path, IMG.getCh(1))\n        m = cv2.imread(mandrill_path, IMG.getCh(1))\n        self.assertEqual(len(IMG.encodeDecodeN([l, m], 3)), 2)\n        self.assertEqual(len(IMG.encodeDecodeN([l, m], 1)), 2)\n\n    def test_cut(self):\n        l = cv2.imread(lenna_path)\n        m = cv2.imread(mandrill_path)\n        self.assertEqual(IMG.cutN([l, m], 64).shape, (2, 64, 64, 3))\n        lm16 = [l, l, l, l, m, m, m, m, l, l, l, l, m, m, m, m]\n        self.assertEqual(IMG.cutN(lm16, 64, 100).shape, (16, 64, 64, 3))\n        self.assertEqual(IMG.cutN(lm16, 64, 10).shape, (10, 64, 64, 3))\n        self.assertEqual(IMG.cutN([l, m], 1).shape, (2, 256, 256, 3))\n        self.assertEqual(IMG.cutN([l, m], 0).shape, (2, 256, 256, 3))\n        self.assertEqual(IMG.cutN([l, m], -1).shape, (2, 256, 256, 3))\n\n    def test_split(self):\n        l = cv2.imread(lenna_path)\n        m = cv2.imread(mandrill_path)\n        imgs, split = IMG.splitSQN([l, m], 32)\n        self.assertEqual(imgs.shape, (128, 32, 32, 3))\n        self.assertEqual(split, (8, 8))\n\n        imgs, split = IMG.splitSQN([l, m], 0)\n        self.assertEqual(imgs.shape, (512, 2, 2))\n        self.assertEqual(split, (1, 1))\n\n        imgs, split = IMG.splitSQN([l, m], 32, 10)\n        self.assertEqual(imgs.shape, (120, 32, 32, 3))\n        self.assertEqual(split, (8, 8))\n\n        imgs, split = IMG.splitSQN([l, m], 32, 100)\n        self.assertEqual(imgs.shape, (100, 32, 32, 3))\n        self.assertEqual(split, (8, 8))\n\n        imgs, split = IMG.splitSQN([l, m], 32, 1000)\n        self.assertEqual(imgs.shape, (128, 32, 32, 3))\n        self.assertEqual(split, (8, 8))\n\n        print(l.shape, m.shape)\n        imgs, split = IMG.splitSQN([l, m], 1024)\n        self.assertEqual(imgs.shape, (2, 256, 256, 3))\n        self.assertEqual(split, (1, 1))\n\n        bk = IMG.blank((100, 120, 3), 255)\n        imgs, split = IMG.splitSQN([bk], 1024)\n        self.assertEqual(imgs.shape, (1, 100, 100, 3))\n        self.assertEqual(split, (1, 1))\n\n        l = cv2.imread(lenna_path, IMG.getCh(1))\n        m = cv2.imread(mandrill_path, IMG.getCh(1))\n        imgs, split = IMG.splitSQN([l, m], 32)\n        self.assertEqual(imgs.shape, (128, 32, 32))\n        self.assertEqual(split, (8, 8))\n\n    def test_rotateRN(self):\n        l = cv2.imread(lenna_path)\n        m = cv2.imread(mandrill_path)\n        imgs, angle = IMG.rotateRN([l, m], 3)\n        self.assertEqual(imgs.shape, (6, 256, 256, 3))\n        self.assertEqual(angle.shape, (6,))\n\n    def test_flip(self):\n        l = cv2.imread(lenna_path)\n        m = cv2.imread(mandrill_path)\n        self.assertEqual(IMG.flipN([l, m]).shape, (6, 256, 256, 3))\n        self.assertEqual(IMG.flipN([l, m], -1).shape, (2, 256, 256, 3))\n        self.assertEqual(IMG.flipN([l, m], 0).shape,  (2, 256, 256, 3))\n        self.assertEqual(IMG.flipN([l, m], 1).shape,  (4, 256, 256, 3))\n        self.assertEqual(IMG.flipN([l, m], 2).shape,  (6, 256, 256, 3))\n        self.assertEqual(IMG.flipN([l, m], 3).shape,  (8, 256, 256, 3))\n\n    def test_resize(self):\n        l = cv2.imread(lenna_path)\n        m = cv2.imread(mandrill_path)\n        imgs = IMG.size2x([l, m])\n        self.assertEqual(imgs[0].shape, (512, 512, 3))\n        self.assertEqual(imgs[1].shape, (512, 512, 3))\n        self.assertEqual(IMG.resize(l, -1).shape, (256, 256, 3))\n        self.assertEqual(IMG.resize(l, 2).shape, (512, 512, 3))\n        self.assertEqual(IMG.resize(l, 1.5).shape, (384, 384, 3))\n        self.assertEqual(IMG.resize(l, 0.5).shape, (128, 128, 3))\n\n    def test_imgs2arr(self):\n        l = cv2.imread(lenna_path)\n        m = cv2.imread(mandrill_path)\n        self.assertEqual(IMG.imgs2arr([l, m]).shape, (2, 3, 256, 256))\n\n        l = cv2.imread(lenna_path, IMG.getCh(1))\n        m = cv2.imread(mandrill_path, IMG.getCh(1))\n        self.assertEqual(IMG.imgs2arr([l, m]).shape, (2, 1, 256, 256))\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
