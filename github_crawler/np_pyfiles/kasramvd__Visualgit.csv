file_path,api_count,code
visualgit.py,0,"b'from subprocess import Popen, PIPE\nfrom pymongo import MongoClient, ASCENDING\nfrom pymongo.errors import ConnectionFailure\nfrom pyqtgraph.Qt import QtGui, QtCore\nfrom operator import itemgetter, attrgetter\nfrom datetime import datetime\nfrom itertools import izip\nfrom collections import OrderedDict, defaultdict\nimport pyqtgraph as pg\nimport argparse\nimport time\nimport sys\nimport re\n\nclass DateAxis(pg.AxisItem):\n    def tickStrings(self, values, scale, spacing):\n        """"""\n        .. py:attribute:: tickStrings()\n\n           :param values: \n           :type values: \n           :param scale: \n           :type scale: \n           :param spacing: \n           :type spacing: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        strns = []\n        rng = max(values)-min(values)\n        #if rng < 120:\n        #    return pg.AxisItem.tickStrings(self, values, scale, spacing)\n        if rng < 3600*24:\n            string = \'%H:%M:%S\'\n            label1 = \'%Y/%m %d -\'\n            label2 = \' %m %d, %Y\'\n        elif rng >= 3600*24 and rng < 3600*24*30:\n            string = \'%Y/%m/%d\'\n            label1 = \'%Y/%m\'\n            label2 = \'%m, %Y\'\n        elif rng >= 3600*24*30 and rng < 3600*24*30*24:\n            string = \'%Y/%m\'\n            label1 = \'%Y -\'\n            label2 = \' %Y\'\n        elif rng >= 3600*24*30*24:\n            string = \'%Y\'\n            label1 = \'\'\n            label2 = \'\'\n        for x in values:\n            try:\n                strns.append(time.strftime(string, time.localtime(x)))\n            except ValueError:  ## Windows can\'t handle dates before 1970\n                strns.append(\'\')\n        try:\n            label = time.strftime(label1, time.localtime(min(values)))+\\\n            time.strftime(label2, time.localtime(max(values)))\n        except ValueError:\n            label = \'\'\n        #self.setLabel(text=label)\n        return strns\nclass CustomViewBox(pg.ViewBox):\n    def __init__(self, *args, **kwds):\n        """"""\n        .. py:attribute:: __init__()\n\n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        pg.ViewBox.__init__(self, *args, **kwds)\n        self.setMouseMode(self.RectMode)\n    ## reimplement right-click to zoom out\n    def mouseClickEvent(self, ev):\n        """"""\n        .. py:attribute:: mouseClickEvent()\n\n           :param ev: \n           :type ev: \n           :rtype: None\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        if ev.button() == QtCore.Qt.RightButton:\n            self.autoRange()\n    def mouseDragEvent(self, ev):\n        """"""\n        .. py:attribute:: mouseDragEvent()\n\n\n           :param ev: \n           :type ev: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        if ev.button() == QtCore.Qt.RightButton:\n            ev.ignore()\n        else:\n            pg.ViewBox.mouseDragEvent(self, ev)\nclass GitStatics(object):\n    def __init__(self, *args, **kwargs):\n        """"""\n        .. py:attribute:: __init__()\n         \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        try:\n            self.dbname = kwargs[\'dbname\']\n            self.host = kwargs[\'host\']\n            self.vb = kwargs[\'vb\']\n            self.axis = kwargs[\'axis\']\n            self.git_path = kwargs[\'git_path\']\n            self.branch_name = kwargs[\'branch_name\']\n            self.start_year = kwargs[\'start_year\']\n            self.args = kwargs[\'args\']\n            self.set_args()\n\n        except KeyError as e:\n            raise Exception(""Please insert a correct argument name.\\n{}"".foramt(e))\n        self.mongo_cursor = self.mongo_connector()\n        self.output = self.get_log_info()\n        self.collection_name = ""log_info""\n        self.branch_name = self.get_branch_name()\n        self.tag_names = self.get_tag_names().split(\'\\n\')\n        self.tag_extracter_regex = re.compile(\n            r\'(:?(?P<changed>(\\d+)) files changed)?(:?, (?P<insertations>(\\d+)) insertions\\(\\+\\))?(?:, (?P<deletions>(\\d+)) deletions\\(-\\))?\')\n    \n    def set_args(self):\n        attrs = attrgetter(\'B\', \'t\', \'m\', \'y\', \'x\', \'ct\', \'dt\', \'e\', \'i\', \'s\')(self.args)\n        self.sub_branch_name, self.time_type, self.time_mode, self.y_axis_type, self.x_axis_type,\\\n        self.count_type, self.diff_type, self.excludes, self.includes, self.start_time = attrs\n        try:\n            self.start_time = int(self.start_time)\n        except ValueError:\n            raise Exception(""Please enter a integer value for start_year (more than 0)."")\n\n    def get_branch_name(self):\n        """"""\n        .. py:attribute:: get_branch_name()\n\n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        command =  ""git branch""\n        P = Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, cwd=self.git_path,shell=True)\n        output, err = P.communicate(b""Get the result of git log"")\n        if err:\n            raise Exception(""Invalid command"")\n        matched = re.search(r\'\\* (?:\\(detached from )?(.*)\\)?\',output)\n        try:\n            return matched.group(1)\n        except AttributeError:\n            raise Exception(""The result of git branch command is {}.\\\n             And it doesn\'t match with our proper format"".format(matched))\n        #return output\n    def get_diff(self, commit_hash):\n        """"""\n        .. py:attribute:: get_diff()\n\n\n           :param commit_hash: \n           :type commit_hash: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        command = \'git show --numstat {}\'.format(commit_hash)\n        P = Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, cwd=self.git_path, shell=True)\n        output, err = P.communicate(b""Get the result of git log"")\n        if err:\n            return None\n            #raise Exception(""Invalid command"")\n        return output\n    def get_tag_names(self):\n        """"""\n        .. py:attribute:: get_tag_names()\n\n\n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        command = \'git tag\'\n        P = Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, cwd=self.git_path, shell=True)\n        output, err = P.communicate(b""Get the result of git log"")\n        return output\n    def fileter_tag_names(self, filt):\n        """"""\n        .. py:attribute:: fileter_tag_names()\n\n\n           :param filt: \n           :type filt: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        if filt == ""master"":\n            return [i for i in self.tag_names if i.isdigit()]\n        elif filt == ""invoice_on_demand"":\n            return [i for i in self.tag_names if i.startswith(""invoice_on_demand"")]\n        elif filt == ""invoice"":\n            return [i for i in self.tag_names if i.startswith(""C_invoice"")]\n        elif filt == ""c"" or filt == ""C"":\n            return [i for i in self.tag_names if re.match(r""C_\\d+"",i)]\n    def tag_diff(self, tag_type):\n        """"""\n        .. py:attribute:: tag_diff()\n\n\n           :param tag_type: \n           :type tag_type: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        if tag_type == ""master"": \n            tags = self.fileter_tag_names(""master"")\n        elif tag_type == ""invoice_on_demand"":\n            tags = self.fileter_tag_names(""invoice_on_demand"")\n        elif tag_type == ""invoice"":\n            tags = self.fileter_tag_names(""invoice"")\n        elif tag_type == ""c"" or tag_type == ""C"":\n            tags = self.fileter_tag_names(""C"")\n        else:\n            raise Exception(\n                ""Tag name *{}* in not defined. You need to use one of the following names:\\n\\\n                [master, invoice_on_demand, invoice, C]"".format(tag_type)\n                )\n        try:\n            tags = sorted(tags, key=lambda x: int(re.search(r\'\\d+$\', x).group(0)))\n        except AttributeError:\n            raise Exception(""AttributeError : There is an invalid tag name in {} tag."".format(tag_type))\n        else:\n            for pre,front in zip(tags, tags[1:]):\n                command = ""git diff {} {} --shortstat"".format(pre, front)\n                P = Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, cwd=self.git_path, shell=True)\n                output, err = P.communicate(b""Get the result of git log"")\n                if err:\n                    yield ""{}_{}"".format(pre, front), 0, 0, 0\n                else:\n                    try:\n                        numbers_dict = self.tag_extracter_regex.search(output.strip()).groupdict()\n                    except:\n                        yield ""{}_{}"".format(pre, front), 0, 0, 0\n                    else:\n                        yield [""{}_{}"".format(pre, front)] + [i if i else 0 for i in itemgetter(\n                            ""changed"",""insertations"",""deletions"")(numbers_dict)]\n    def get_log_info(self):\n        """"""\n        .. py:attribute:: get_log_info()\n\n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        if self.sub_branch_name:\n            command = [\'git\',\'log\', self.branch_name+\'/\'+sub_branch, ""--pretty=\'%H\\t%an\\t%at\\t%cn\\t%ct\\t%s\'""]\n        else:\n            command = [\'git\',\'log\', self.branch_name, ""--pretty=\'%H\\t%an\\t%at\\t%cn\\t%ct\\t%s\'""]\n        P = Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, cwd=self.git_path)\n        output, err = P.communicate(b""Get the result of git log"")\n        if err:\n            raise Exception(""Invalid command.\\n{}"".format(err))\n        return output\n\n    def mongo_connector(self):\n        """"""\n        .. py:attribute:: mongo_connector()\n\n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        # Connect to mongoDB and return a connection object.\n        try:\n            c = MongoClient(host=self.host, port=27017)\n        except ConnectionFailure, error:\n            sys.stderr.write(""Could not connect to MongoDB: {}"".format(error))\n        else:\n            print ""Connected successfully""\n        return c[self.dbname]\n    def insert_to_db(self, commit_hash, author_name, author_time, commiter_name, commiter_time, commit):\n        """"""\n        .. py:attribute:: insert_to_db()\n\n           :param commit_hash: \n           :type commit_hash: \n           :param author_name: \n           :type author_name: \n           :param author_time: \n           :type author_time: \n           :param commiter_name: \n           :type commiter_name: \n           :param commiter_time: \n           :type commiter_time: \n           :param commit: \n           :type commit: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n\n\n    def indexer(self):\n        """"""\n        .. py:attribute:: indexer()\n\n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        self.mongo_cursor[self.collection_name].ensure_index(\n            [\n                (\'author_time\', ASCENDING),\n            ],)\n        self.mongo_cursor[self.collection_name].ensure_index(\n            [\n                (\'commiter_name\', ASCENDING),\n            ],)\n        self.mongo_cursor[self.collection_name].ensure_index(\n            [\n                (\'author_name\', ASCENDING),\n            ],)\n    def run(self):\n        """"""\n        .. py:attribute:: run()\n\n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        revert_commits = {}\n        all_lines = [line.split(\'\\t\') for line in self.output.split(""\\n"")]\n        try:\n            for commit_hash, author_name, author_time, commiter_name, commiter_time, commit in all_lines:\n                if commit.startswith(\'merge\'):\n                    self.mongo_cursor[self.collection_name].insert(\n                        {\n                            ""branch_name"": self.branch_name,\n                            ""commit_hash"": commit_hash.strip(""\'""),\n                            ""author_name"": author_name,\n                            ""author_time"": author_time,\n                            ""commiter_name"": commiter_name,\n                            ""commiter_time"": commiter_time,\n                            ""commit"": commit,\n                        }\n                    )\n                else:\n                    diff = self.get_diff(commit_hash.strip(""\'""))\n                    all_diffs = re.findall(r\'(?:\\b(\\d+)\\b\\t\\b(\\d+)\\b)\\t(.*)\',diff)\n                    self.mongo_cursor[self.collection_name].insert(\n                        {\n                            ""branch_name"": self.branch_name,\n                            ""commit_hash"": commit_hash,\n                            ""author_name"": author_name,\n                            ""author_time"": author_time,\n                            ""commiter_name"": commiter_name,\n                            ""commiter_time"": commiter_time,\n                            ""commit"": commit,\n                            ""diff"": all_diffs\n                        }\n                    )\n        except (TypeError, ValueError) as e:\n            pass\n        self.indexer()\n\n    def get_data(self):\n        """"""\n        .. py:attribute:: get_data()\n\n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        result = self.mongo_cursor[self.collection_name].find({}).sort([(\'author_time\',1)])\n        return result\n\n    def extract_data_count(self):\n        """"""\n        .. py:attribute:: extract_data_count()\n\n         \n           :param timestamp: \n           :type boolean: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        all_data = self.get_data()\n        result_dict = defaultdict(list)\n        if self.excludes:\n            cond1 = lambda x: x not in self.excludes\n        else:\n            cond1 = lambda x: True\n        if self.includes:\n            cond2 = lambda x: x in self.include\n        else:\n            cond2 = lambda x: True\n        for item in all_data:\n            name = item[\'{}_name\'.format(self.y_axis_type)]\n            if not item[\'commit\'].startswith(\'merge\') and cond1(name) and cond2(name):\n                try:\n                    time = item[self.time_type] \n                except KeyError:\n                    raise Exception(""Please pass a correct time_type.([commiter_time, author_time])"")\n                else:\n                    year = datetime.fromtimestamp(float(time)).year\n                    month = datetime.fromtimestamp(float(time)).month\n                if year >= self.start_time:\n                    names_and_times = item[\'author_name\'], item[\'author_time\'], item[\'commiter_name\'],item[\'commiter_time\']\n                    if self.count_type == \'name\':\n                        result_dict[name].append(names_and_times)\n                    else:\n                        result_dict[year, month, 1].append(names_and_times)\n        return result_dict\n\n    def extract_data_diff(self):\n        """"""\n        .. py:attribute:: extract_data_in_del()\n\n           :param start_year: \n           :type start_year: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        all_data = self.get_data()\n        result_dict = defaultdict(list)\n        if self.excludes:\n            cond1 = lambda x: x in self.excludes\n        else:\n            cond1 = lambda x: True\n        if self.includes:\n            cond2 = lambda x: x in self.include\n        else:\n            cond2 = lambda x: True\n        for item in all_data:\n            name = item[\'{}_name\'.format(self.y_axis_type)]\n            if not item[\'commit\'].startswith(\'merge\') and cond1(name) and cond2(name):\n                time = item[self.time_type] \n                try:\n                    insert, delete = [sum(map(int,i)) for i in zip(*item[\'diff\'])[:2]]\n                except ValueError:\n                    pass\n                else:\n                    year = datetime.fromtimestamp(float(time)).year\n                    month = datetime.fromtimestamp(float(time)).month\n                if year >= self.start_time:\n                    names_and_times = insert, delete, time\n                    result_dict[year,month,1].append(names_and_times)\n        return result_dict\n\n\n\nclass Ploter(GitStatics):\n    def __init__(self, *args, **kwargs):\n        super(Ploter, self).__init__(*args, **kwargs)\n        self.Epoch = datetime(1970, 1, 1, 0, 0)\n\n\n    def main_ploter(self):\n        if self.x_axis_type == \'count\':\n            self.cal_commit_count()\n        else:\n            self.cal_commit_diff()\n\n\n    def veiw_commit(self, X, Y):\n        """"""\n        .. py:attribute:: veiw_custom()\n\n\n           :param X: \n           :type X: \n           :param Y: \n           :type Y: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        if isinstance(X[0],tuple):\n            X = sorted([time.mktime(datetime(*i).timetuple()) for i in X])\n        else:\n            X = sorted(map(float, X))\n        coords = zip(X, Y)\n        app = pg.mkQApp()\n        pw = pg.PlotWidget(viewBox=self.vb, axisItems={\'bottom\': self.axis}, enableMenu=False,\n            title=""PROJECT_NAME git log changes"",clickable=True)\n        def mouseMoved(pos):\n                display_text = pg.TextItem(text=\'salooom\',color=(176,23,31),anchor=pos)\n                pw.addItem(display_text)\n        pw.plot(X, Y, symbol=\'o\')\n        pw.show()\n        pw.setWindowTitle(\'PROJECT_NAME Git Log: customPlot\')\n        r = pg.PolyLineROI([(0,0), (10,10)])\n        pw.addItem(r)\n        pw.scene().sigMouseClicked.connect(mouseMoved)\n        if (sys.flags.interactive != 1) or not hasattr(QtCore, \'PYQT_VERSION\'):\n            QtGui.QApplication.instance().exec_()\n\n    def cal_commit_diff(self):\n        """"""\n        .. py:attribute:: veiw_custom_monthly_diff()\n\n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        all_data = self.extract_data_diff()\n        print self.diff_type\n        if self.diff_type == \'insert\':\n            diff_index = 0\n        else:\n            diff_index = 1\n        aggregated_result = zip(*[(time,sum(map(int,zip(*values)[diff_index]))) for time, values in all_data.iteritems()])\n        self.veiw_commit(*aggregated_result)\n    def cal_commit_count(self):\n        """"""\n        .. py:attribute:: veiw_custom_monthly_commit_count()\n\n         \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        all_data = self.extract_data_count()\n        aggregated_result = zip(*[(k,len(v)) for k,v in all_data.iteritems()])\n        self.veiw_commit(*aggregated_result)\n\n    def quadruple_ploter(self, *args, **kwargs):\n\n        try:\n            lable1, lable2, lable3, lable4 = kwargs[\'lables\']\n            (x1, y1), (x2, y2), (x3, y3), (x4, y4) = kwargs[\'coordinates\']\n        except KeyError:\n            raise Exception(""Enter a correct key word argument(lables or coordinates)."")\n\n        win = pg.GraphicsWindow(title=""PROJECT_NAME git statics"")\n        win.resize(800, 600)\n\n        win.addLabel(""Linked Views"", colspan=2)\n        win.nextRow()\n\n        p1 = win.addPlot(x=x1, y=y1, name=""Plot1"", title=lable1, pen=\'b\')\n        p2 = win.addPlot(x=x2, y=y2, name=""Plot2"", title=label2, pen=\'y\')\n        p3 = win.addPlot(x=x3, y=y3, name=""Plot3"", title=lable3, row=2, col=0, pen=\'r\')\n        p4 = win.addPlot(\n            x=x4,\n            y=y4,\n            name=""Plot4"",\n            title=lable4,\n            row=2,\n            col=1,\n            pen=\'g\')\n\n    def view_box(self, x, y, plot_type=\'\', author_name=\'\'):\n        """"""\n        .. py:attribute:: view_box()\n\n           :param x: \n           :type x: \n           :param y: \n           :type y: \n           :param plot_type: \n           :type plot_type: \n           :param author_name: \n           :type author_name: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        .. todo:: \n        """"""\n        win = pg.GraphicsWindow(title=""Basic plotting examples"")\n        win.resize(1000,600)\n        win.setWindowTitle(\'PROJECT_NAME: LogPlotTest\')\n        xdict = OrderedDict(enumerate([\'{}/{}\'.format(i, j) for i,j in sorted(x)]))\n        stringaxis = pg.AxisItem(orientation=\'bottom\')\n        stringaxis.setTicks([xdict.items()])\n        p5 = win.addPlot(title=""Commit {} per month \\n author_name : {}"".format(plot_type, author_name),axisItems={\'bottom\': stringaxis})\n        p5.plot(\n            xdict.keys(),\n            y,\n            pen=\'r\',\n            symbol=\'t\',\n            symbolPen=None,\n            symbolSize=10,\n            symbolBrush=(100, 100, 255, 50)\n            )\n        p5.setLabel(\'left\', ""Commit {}"".format(plot_type), units=\'line\')\n        p5.setLabel(\'bottom\', ""Date"", units=\'\')\n        if (sys.flags.interactive != 1) or not hasattr(QtCore, \'PYQT_VERSION\'):\n            QtGui.QApplication.instance().exec_()\n    def tag_viewer(self, tag_name):\n        """"""\n        .. py:attribute:: tag_viewer()\n\n\n           :param self: \n           :type self: \n           :param tag_name: \n           :type tag_name: \n           :rtype: UNKNOWN\n\n        .. note:: \n\n        Example\n\n        .. code-block:: python\n        \t\n\n        .. todo:: \n        """"""\n        win = pg.GraphicsWindow(title=""Basic plotting examples"")\n        win.resize(1000,600)\n        win.setWindowTitle(\'PROJECT_NAME: LogPlotTest\')\n        all_tag_names, file_changes, insertations, deletations = zip(*self.tag_diff(tag_name))\n        xdict = dict(enumerate(all_tag_names))\n        stringaxis = pg.AxisItem(orientation=\'bottom\')\n        stringaxis.setTicks([xdict.items()])\n        p5 = win.addPlot(title=""tag *{}* insertions"".format(tag_name),axisItems={\'bottom\': stringaxis})\n        p5.plot(\n            xdict.keys(),\n            map(float, insertations),\n            pen=\'r\',\n            symbol=\'t\',\n            symbolPen=None,\n            symbolSize=10,\n            symbolBrush=(100, 100, 255, 50)\n            )\n        p5.setLabel(\'left\', ""Insertions"", units=\'line\')\n        p5.setLabel(\'bottom\', ""Y Axis"", units=\'s\')\n        if (sys.flags.interactive != 1) or not hasattr(QtCore, \'PYQT_VERSION\'):\n            QtGui.QApplication.instance().exec_()\n\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser(\n        description=""Visualize PROJECT_NAME git-log results in any way you like ;)"")\n    # Adding arguments\n    parser.add_argument(""-B"", ""-branch_name"", help=""Based on your \\\n        available sub branches you can pass the those names to plot."", default=\'\')\n    parser.add_argument(""-t"", ""-time_type"", help=""author_time or commiter_time"", \n        choices=[\'author_time\', \'commiter_time\'], default=\'author_time\')\n    parser.add_argument(""-m"", ""-time_mode"", help=""The format of time representation\\\n    can be one of the {yearly, monthly, per_commit}"", choices=[\'yearly\', \'monthly\', \'per_commit\'],\n    default=\'monthly\')\n    parser.add_argument(""-y"", ""-y_axis_type"", help=""Y axis type, which can be author or \\\n        commiter."", choices=[\'author\', \'commiter\'], default=\'author\')\n    parser.add_argument(""-x"", ""-x_axis_type"", help=""X axis type (based on commit),\\\n        which can be count or diff"", choices=[\'count\',\'diff\'],default=\'count\')\n    parser.add_argument(""-dt"", ""-diff_type"", help=""Type of commit diff which can be,\\\n        insert or delete"", choices=[\'insert\',\'delete\'], default=\'insert\')\n    parser.add_argument(""-ct"", ""-count_type"", help=""categorize the counts based on date or \\\n        names"", choices=[\'date\',\'name\'], default=\'date\')\n    parser.add_argument(""-e"", ""-excludes"", help=""Names that must be exclude from log result"", default=\'\')\n    parser.add_argument(""-i"", ""-includes"", help=""Names that must be include to log result"", default=\'\')\n    parser.add_argument(""-s"", ""-start_time"", help=""The start time of ploting"", default=2008)\n    args = parser.parse_args()\n\n    app = QtGui.QApplication(sys.argv)\n    CVB = CustomViewBox()\n    axis = DateAxis(orientation=\'bottom\')\n    PL = Ploter(\n        host=\'localhost\',\n        dbname=\'GitStat\',\n        vb=CVB,\n        axis=axis,\n        args=args,\n        git_path=\'/home/user_name/PROJECT_NAME\',\n        branch_name=\'ehsan/C\',\n        start_year = 2014)\n    #PL.tag_viewer(""invoice_on_demand"")\n    #PL.run()\n    PL.main_ploter()\n'"
