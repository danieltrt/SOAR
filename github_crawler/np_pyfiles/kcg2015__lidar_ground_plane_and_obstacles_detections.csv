file_path,api_count,code
Python/pcl_processing.py,13,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n""""""\nCreated on Wed Sep 25 20:52:45 2019\n\n@author: kyleguan\n""""""\n\nimport numpy as np\nimport pcl\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport os\n\n\ndef voxel_filter(cloud, leaf_sizes):\n    """"""\n    Input parameters:\n    cloud: input point cloud to be filtered\n    leaf_sizes: a list of leaf_size for X, Y, Z \n    Output:\n    cloud_voxel_filtered: voxel-filtered cloud\n    """"""\n    sor = cloud.make_voxel_grid_filter()\n    size_x, size_y, size_z = leaf_sizes\n    sor.set_leaf_size(size_x, size_y, size_z)\n    cloud_voxel_filtered = sor.filter()\n    \n    return cloud_voxel_filtered\n\n\ndef roi_filter(cloud, x_roi, y_roi, z_roi):\n    """"""\n    Input Parameters:\n        cloud: input point cloud\n        x_roi: ROI range in X\n        y_roi: ROI range in Y\n        z_roi: ROI range in Z\n    \n    Output:    \n        ROI region filtered point cloud\n    """"""\n    clipper = cloud.make_cropbox()\n    cloud_roi_filtered= pcl.PointCloud()\n    xc_min, xc_max = x_roi\n    yc_min, yc_max = y_roi\n    zc_min, zc_max = z_roi\n    clipper.set_MinMax(xc_min, yc_min, zc_min, 0, xc_max, yc_max, zc_max, 0)\n    cloud_roi_filtered =clipper.filter()\n    return cloud_roi_filtered\n\n\n\ndef plane_segmentation(cloud, dist_thold, max_iter):\n    """"""\n    Input parameters:\n        cloud: Input cloud\n        dist_thold: distance threshold\n        max_iter: maximal number of iteration\n    Output:\n        indices: list of indices of the PCL points that belongs to the plane\n        coefficient: the coefficients of the plane-fitting (e.g., [a, b, c, d] for ax + by +cz + d =0)\n    """"""\n    seg = cloud.make_segmenter_normals(ksearch=50)# For simplicity,hard coded\n    seg.set_optimize_coefficients(True)\n    seg.set_model_type(pcl.SACMODEL_NORMAL_PLANE)\n    seg.set_method_type(pcl.SAC_RANSAC)\n    seg.set_distance_threshold(dist_thold)\n    seg.set_max_iterations(max_iter)\n    indices, coefficients = seg.segment()\n    return indices, coefficients\n\n\ndef clustering(cloud, tol, min_size, max_size):\n    """"""\n    Input parameters:\n        cloud: Input cloud\n        tol: tolerance\n        min_size: minimal number of points to form a cluster\n        max_size: maximal number of points that a cluster allows \n    Output:\n        cluster_indices: a list of list. Each element list contains the indices of the points that belongs to\n                         the same cluster\n    """"""\n    tree = cloud.make_kdtree()\n    ec = cloud.make_EuclideanClusterExtraction()\n    ec.set_ClusterTolerance(tol)\n    ec.set_MinClusterSize(min_size)\n    ec.set_MaxClusterSize(max_size)\n    ec.set_SearchMethod(tree)\n    cluster_indices = ec.Extract()\n    return cluster_indices\n\n\n\ndef get_cluster_box_list(cluster_indices, cloud_obsts):\n    """"""\n    Input parameters:\n        cluster_indices: a list of list. Each element list contains the indices of the points that belongs to\n                         the same cluster\n        colud_obsts: PCL for the obstacles                 \n    Output:\n        cloud_cluster_list: a list for the PCL clusters: each element is a point cloud of a cluster\n        box_coord_list: a list of corrdinates for bounding boxes\n    """"""    \n    cloud_cluster_list =[]\n    box_coord_list =[]\n    \n\n    for j, indices in enumerate(cluster_indices):\n        points = np.zeros((len(indices), 3), dtype=np.float32)\n        for i, indice in enumerate(indices):\n            \n            points[i][0] = cloud_obsts[indice][0]\n            points[i][1] = cloud_obsts[indice][1]\n            points[i][2] = cloud_obsts[indice][2]\n        cloud_cluster = pcl.PointCloud()\n        cloud_cluster.from_array(points)\n        cloud_cluster_list.append(cloud_cluster)\n        x_max, x_min = np.max(points[:, 0]), np.min(points[:, 0])\n        y_max, y_min = np.max(points[:, 1]), np.min(points[:, 1])\n        z_max, z_min = np.max(points[:, 2]), np.min(points[:, 2])\n        box = np.zeros([8, 3])\n        box[0, :] =[x_min, y_min, z_min]\n        box[1, :] =[x_max, y_min, z_min]\n        box[2, :] =[x_max, y_max, z_min]\n        box[3, :] =[x_min, y_max, z_min]\n        box[4, :] =[x_min, y_min, z_max]\n        box[5, :] =[x_max, y_min, z_max]\n        box[6, :] =[x_max, y_max, z_max]\n        box[7, :] =[x_min, y_max, z_max]\n        box = np.transpose(box)\n        box_coord_list.append(box)\n    return cloud_cluster_list, box_coord_list  \n\n\ndef box_center(box):\n    """"""\n    Calculate the centroid of a 3D bounding box\n    Input: box, a 3-by-8 matrix, each coloum represents the xyz coordinate of a corner of the box\n           (e.g.  \n           array([[42.62581635, 46.09998703, 46.09998703, 42.62581635, 42.62581635, 46.09998703, 46.09998703, 42.62581635],\n                  [2.64766479,  2.64766479,  4.64661026,  4.64661026,  2.64766479, 2.64766479,  4.64661026,  4.64661026],\n                  [0.10515476,  0.10515476,  0.10515476,  0.10515476,  1.98793995, 1.98793995,  1.98793995,  1.98793995]])\n           )\n    Output: the centroid of the box in 3D [x_cent, y_cent, z_cent]\n    """"""\n    x_min, x_max = min(box[0]), max(box[0])\n    y_min, y_max = min(box[1]), max(box[1])\n    z_min, z_max = min(box[2]), max(box[2])\n    \n    return ((x_min + x_max)/2.0, (y_min + y_max)/2.0, (z_min + z_max)/2.0)\n\n\n\ndef draw_box(pyplot_axis, vertices, axes=[0, 1, 2], color=\'red\'):\n    """"""\n    Draws a bounding 3D box in a pyplot axis.\n    \n    Parameters\n    ----------\n    pyplot_axis : Pyplot axis to draw in.\n    vertices    : Array 8 box vertices containing x, y, z coordinates.\n    axes        : Axes to use. Defaults to `[0, 1, 2]`, e.g. x, y and z axes.\n    color       : Drawing color. Defaults to `black`.\n    """"""\n    vertices = vertices[axes, :]\n    connections = [\n        [0, 1], [1, 2], [2, 3], [3, 0],  # Lower plane parallel to Z=0 plane\n        [4, 5], [5, 6], [6, 7], [7, 4],  # Upper plane parallel to Z=0 plane\n        [0, 4], [1, 5], [2, 6], [3, 7]  # Connections between upper and lower planes\n    ]\n    for connection in connections:\n        pyplot_axis.plot(*vertices[:, connection], c=color, lw=0.5)\n        \n        \n        \n        \ndef draw_point_cloud(cloud, ax, title, axes_str , axes_limits, axes=[0, 1, 2]):\n        \n        cloud = np.array(cloud) # Covert point cloud to numpy array\n        no_points = np.shape(cloud)[0]\n        point_size = 10**(3- int(np.log10(no_points))) # Adjust the point size based on the point cloud size\n        if np.shape(cloud)[1] == 4: # If point cloud is XYZI format (e.g., I stands for intensity)\n            ax.scatter(*np.transpose(cloud[:, axes]), s = point_size, c=cloud[:, 3], cmap=\'gray\')\n        elif np.shape(cloud)[1] == 3:   # If point cloud is XYZ format \n            ax.scatter(*np.transpose(cloud[:, axes]), s = point_size, c=\'b\', alpha = 0.7)\n        ax.set_xlabel(\'{} axis\'.format(axes_str[axes[0]]))\n        ax.set_ylabel(\'{} axis\'.format(axes_str[axes[1]]))\n        if len(axes) > 2: # 3-D plot\n            ax.set_xlim3d(axes_limits[axes[0]])\n            ax.set_ylim3d(axes_limits[axes[1]])\n            ax.set_zlim3d(axes_limits[axes[2]])\n            ax.set_zlabel(\'{} axis\'.format(axes_str[axes[2]]))\n        else: # 2-D plot\n            ax.set_xlim(*axes_limits[axes[0]])\n            ax.set_ylim(*axes_limits[axes[1]])\n#        # User specified limits\n#        if xlim3d!=None:\n#            ax.set_xlim3d(xlim3d)\n#        if ylim3d!=None:\n#            ax.set_ylim3d(ylim3d)\n#        if zlim3d!=None:\n#            ax.set_zlim3d(zlim3d)\n        ax.set_title(title)            \n'"
