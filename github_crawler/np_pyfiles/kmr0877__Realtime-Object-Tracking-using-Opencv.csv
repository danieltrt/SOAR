file_path,api_count,code
frames_per_sec.py,1,"b'from imutils.video import FPS\nimport numpy as np\nimport argparse\nimport imutils\nimport cv2\n\nap = argparse.ArgumentParser()\nap.add_argument(""-v"", ""--video"", required=True,\n\thelp=""/sample_test.mp4"")\nargs = vars(ap.parse_args())\n\nstream = cv2.VideoCapture(args[""video""])\nfps = FPS().start()\n\nwhile True:\n\t(grabbed, frame) = stream.read()\n \n\tif not grabbed:\n\t\tbreak\n\tframe = imutils.resize(frame, width=450)\n\tframe = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\tframe = np.dstack([frame, frame, frame])\n \n\t# show the frame and update the FPS counter\n\tcv2.imshow(""Frame"", frame)\n\tcv2.waitKey(1)\n\tfps.update()\n\nfps.stop()\nprint(""approx. FPS: {:.2f}"".format(fps.fps()))\n \n\nstream.release()\ncv2.destroyAllWindows()\n'"
object_track.py,2,"b'import cv2\nimport numpy as np\nimport pylab\nimport os\nimport shutil\nimport imageio\nfrom collections import deque\nfrom collections import deque\nimport numpy as np\nimport argparse\n\nimport imutils\nimport cv2\ngreenLower = (29, 86, 6)\ngreenUpper = (64, 255, 255)\n \n# initialize the list of tracked points, the frame counter,\n# and the coordinate deltas\npts = deque(maxlen=20)\ncounter = 0\n(dX, dY) = (0, 0)\ndirection = """"\nfilename = \'test_sample1.avi\'\nvid = imageio.get_reader(filename,  \'ffmpeg\')\ncount = 0\nfor num in range(vid.get_length()):\n    try:\n        img = vid.get_data(num)\n        \n        img = cv2.resize(img,(1000,600))\n        gray_image = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n        _,im =  cv2.threshold(gray_image,220,1,cv2.THRESH_BINARY+cv2.THRESH_OTSU)\n        \n        image, cnts, hier = cv2.findContours(im,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)\n        center = None\n\tfor c in cnts:\n            x, y, w, h = cv2.boundingRect(c)\n\n            # draw a green rectangle to visualize the bounding rect\n            cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n\n            # get the min area rect\n            rect = cv2.minAreaRect(c)\n            box = cv2.boxPoints(rect)\n\n            # convert all coordinates floating point values to int\n            box = np.int0(box)\n\n            # draw a red \'nghien\' rectangle\n            cv2.drawContours(img, [box], 0, (0, 0, 255))\n        # only proceed if at least one contour was found\n\tif len(cnts) > 1:\n            \n            # Change objects for finding trajectory\n            # By changing the value of -2 to any other integer you can change the tracking\n            # if you change it to -3 it will pickup the object which has third largest area  \n            # and so on. but the area of objects will change as you move and rotate the image\n            # So it will not give much accurate results\n            # -2 works best because it is the second largest area. first largest area is usually \n            # the full video size.\n            c = sorted(cnts, key=cv2.contourArea)[-2]\n            \n            # for tracking most dominant object uncomment this and comment above  line\n       #     c = [contour for contour in sorted(cnts, key=cv2.contourArea)[::-1] if cv2.contourArea(contour)< 450000][0]\n             \n            \n            ((x, y), radius) = cv2.minEnclosingCircle(c)\n            M = cv2.moments(c)\n            center = (int(M[""m10""] / M[""m00""]), int(M[""m01""] / M[""m00""]))\n            cv2.circle(img, (int(x), int(y)), int(radius),\n                (0, 255, 255), 2)\n            cv2.circle(img, center, 5, (0, 0, 255), -1)\n            pts.appendleft(center)\n\t\ndef process_image(im):\n    image, contours, hierarchy= cv2.findContours(im, cv2.RETR_TREE,\n                    cv2.CHAIN_APPROX_SIMPLE)\n    for c in contours:\n        \n        # get the bounding rect\n\n        x, y, w, h = cv2.boundingRect(c)\n        \n        # draw a green rectangle to visualize the bounding rect\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n        #cv2.putText(img,\'(x,y)\',(x-25,y-10),cv2.FONT_HERSHEY_SIMPLEX,1,(255,255,255),2,cv2.LINE_AA)\n    \n        \n        # get the min area rect\n        rect = cv2.minAreaRect(c)\n        box = cv2.boxPoints(rect)\n        \n        # convert all coordinates floating point values to int\n        box = np.int0(box)\n        \n        # draw a red \'nghien\' rectangle\n        cv2.drawContours(img, [box], 0, (0, 0, 255))\n\n    cv2.drawContours(img, contours, -1, (255, 255, 0), 1)\n    return img\n\ntry:\n    os.mkdir(""images"")\nexcept:\n    shutil.rmtree(""images"")\n    os.mkdir(""images"")\n\ntry:\n    shutil.rmtree(\'output.avi\')\nexcept:\n    pass\nfilename = \'vtest.avi\'\nvid = imageio.get_reader(filename, \'ffmpeg\')\n\nfor num in range(vid.get_length()):\n\n\timg = vid.get_data(num)\n\tgray_image = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n\t_,im =  cv2.threshold(gray_image,220,1,cv2.THRESH_BINARY+cv2.THRESH_OTSU)\n\tim = process_image(im)\n\tcv2.imshow(\'image\',im)\n\t#fourcc = cv2.VideoWriter_fourcc(\'M\',\'J\',\'P\',\'G\')\n\tfourcc = cv2.VideoWriter_fourcc(\'F\',\'M\',\'P\',\'4\')\n\t#w = int(vid.get(cv2.VID_PROP_FRAME_WIDTH))\n\t#h = int(vid.get(cv2.VID_PROP_FRAME_HEIGHT))\n\t#out = cv2.VideoWriter(\'output.avi\',fourcc,20.0,(w,h))\n\tout = cv2.VideoWriter(\'output.avi\',-1,20.0,(640,480))\n\t#vid.release()\n\tpylab.imsave(""images/""+""image-""+str(num)+"".jpg"",im)\n\nos.system(\'ffmpeg -framerate 25 -i images/image-%00d.jpg -r 76 -s 800x600 output.avi\')\n\n\n\n\n'"
