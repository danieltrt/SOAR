file_path,api_count,code
bench.py,0,"b""from time import time\n\nfrom imageio import imread\n\nfrom pymartini import Martini, decode_ele\n\npath = './test/data/fuji.png'\nfuji = imread(path)\nterrain = decode_ele(fuji, 'mapbox')\n\nstart = time()\nmartini = Martini(fuji.shape[0] + 1)\nend = time()\nprint(f'init tileset: {(end - start) * 1000:.3f}ms')\n\nstart = time()\ntile = martini.create_tile(terrain)\nend = time()\nprint(f'create tile: {(end - start) * 1000:.3f}ms')\n\nstart = time()\nvertices, triangles = tile.get_mesh(30)\nend = time()\nprint(f'mesh (max_error=30): {(end - start) * 1000:.3f}ms')\nprint(f'vertices: {len(vertices) / 2}, triangles: {len(triangles) / 3}')\n\nall_meshes_start = time()\nfor i in range(21):\n    start = time()\n    tile.get_mesh(i)\n    end = time()\n    print(f'mesh {i}: {(end - start) * 1000:.3f}ms')\n\nall_meshes_end = time()\nprint(f'20 meshes total: {(all_meshes_end - all_meshes_start) * 1000:.3f}ms')\n"""
setup.py,1,"b'""""""Setup for pymartini.""""""\nfrom pathlib import Path\n\nimport numpy as np\n# setuptools must be before Cython\nfrom setuptools import find_packages, setup\nfrom Cython.Build import cythonize\n\nwith open(""README.md"") as f:\n    readme = f.read()\n\n# Runtime requirements.\ninst_reqs = [""numpy""]\n\nextra_reqs = {\n    ""test"": [""pytest"", ""pytest-benchmark"", ""imageio""], }\n\n\n# Ref https://suzyahyah.github.io/cython/programming/2018/12/01/Gotchas-in-Cython.html\ndef find_pyx(path=\'.\'):\n    return list(map(str, Path(path).glob(\'**/*.pyx\')))\n\n\nsetup(\n    name=""pymartini"",\n    version=""0.2.3"",\n    description=""A Python port of Martini for fast terrain mesh generation"",\n    long_description=readme,\n    long_description_content_type=""text/markdown"",\n    classifiers=[\n        ""Intended Audience :: Information Technology"",\n        ""Intended Audience :: Science/Research"",\n        ""License :: OSI Approved :: MIT License"",\n        ""Programming Language :: Python :: 3.6"",\n        ""Programming Language :: Python :: 3.7"",\n        ""Programming Language :: Python :: 3.8"",\n        ""Topic :: Scientific/Engineering :: GIS""],\n    keywords=""mesh heightmap elevation terrain numpy"",\n    author=""Kyle Barron"",\n    author_email=""kylebarron2@gmail.com"",\n    url=""https://github.com/kylebarron/pymartini"",\n    license=""MIT"",\n    packages=find_packages(exclude=[""ez_setup"", ""scripts"", ""examples"", ""test""]),\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=inst_reqs,\n    extras_require=extra_reqs,\n    ext_modules=cythonize(find_pyx(), language_level=3),\n    # Include Numpy headers\n    include_dirs=[np.get_include()],\n)\n'"
pymartini/__init__.py,0,"b'""""""Top-level package for pymartini.""""""\n\n__author__ = """"""Kyle Barron""""""\n__email__ = \'kylebarron2@gmail.com\'\n__version__ = \'0.2.3\'\n\nfrom .martini import Martini\nfrom .util import decode_ele\nfrom .util_cy import rescale_positions\n'"
pymartini/util.py,4,"b'import numpy as np\n\n\ndef decode_ele(png, encoding, backfill=True):\n    """"""Decode array to elevations\n\n    Arguments:\n        - png (np.ndarray). Ndarray of elevations encoded in three channels,\n          representing red, green, and blue. Must be of shape (tile_size,\n          tile_size, >=3), where `tile_size` is usually 256 or 512\n        - encoding: (str): Either \'mapbox\' or \'terrarium\', the two main RGB\n          encodings for elevation values.\n        - backfill: (bool): Whether to create an array of size (tile_size +\n          1)^2, backfilling the bottom and right edges. This is used because\n          Martini needs a grid of size 2^n + 1\n\n    Returns:\n        (np.array) Array of shape (tile_size^2) with decoded elevation values\n    """"""\n    allowed_encodings = [\'mapbox\', \'terrarium\']\n    if encoding not in allowed_encodings:\n        raise ValueError(f\'encoding must be one of {allowed_encodings}\')\n\n    if png.shape[0] <= 4:\n        png = png.T\n\n    # Get bands\n    if encoding == \'mapbox\':\n        red = png[:, :, 0] * (256 * 256)\n        green = png[:, :, 1] * (256)\n        blue = png[:, :, 2]\n\n        # Compute float height\n        terrain = (red + green + blue) / 10 - 10000\n    elif encoding == \'terrarium\':\n        red = png[:, :, 0] * (256)\n        green = png[:, :, 1]\n        blue = png[:, :, 2] / 256\n\n        # Compute float height\n        terrain = (red + green + blue) - 32768\n\n    if backfill:\n        terrain = compute_backfill(terrain)\n\n    return terrain\n\n\ndef compute_backfill(arr):\n    grid_size = arr.shape[0] + 1\n\n    terrain = np.zeros((grid_size, grid_size), dtype=np.float32)\n\n    # Copy to larger array to allow backfilling\n    np.copyto(terrain[:grid_size - 1, :grid_size - 1], arr)\n\n    # backfill right and bottom borders\n    terrain[grid_size - 1, :] = terrain[grid_size - 2, :]\n    terrain[:, grid_size - 1] = terrain[:, grid_size - 2]\n    return terrain\n'"
test/test_martini.py,15,"b'from pathlib import Path\n\nimport numpy as np\nimport pytest\nfrom imageio import imread\n\nfrom pymartini import Martini, decode_ele\n\nTEST_PNG_FILES = [(\'fuji\', \'mapbox\'), (\'mapbox_st_helens\', \'mapbox\'),\n                  (\'terrarium\', \'terrarium\')]\nTEST_CASES = []\nfor png_fname, encoding in TEST_PNG_FILES:\n    for max_error in [1, 5, 20, 50, 100, 500]:\n        TEST_CASES.append([png_fname, max_error, encoding])\n\n\ndef this_dir():\n    try:\n        return Path(__file__).resolve().parents[0]\n    except NameError:\n        return Path(\'.\').resolve()\n\n\n@pytest.mark.parametrize(""png_fname,encoding"", TEST_PNG_FILES)\ndef test_terrain(png_fname, encoding):\n    """"""Test output from decode_ele against JS output\n    """"""\n    # Generate terrain output in Python\n    path = this_dir() / f\'data/{png_fname}.png\'\n    png = imread(path)\n    terrain = decode_ele(png, encoding=encoding).flatten(\'C\')\n\n    # Load JS terrain output\n    path = this_dir() / f\'data/{png_fname}_terrain\'\n    with open(path, \'rb\') as f:\n        exp_terrain = np.frombuffer(f.read(), dtype=np.float32)\n\n    assert np.array_equal(terrain, exp_terrain), \'terrain not matching expected\'\n\n\n@pytest.mark.parametrize(""png_fname,encoding"", TEST_PNG_FILES)\ndef test_martini(png_fname, encoding):\n    """"""Test output from decode_ele against JS output\n    """"""\n    # Generate Martini constructor output in Python\n    path = this_dir() / f\'data/{png_fname}.png\'\n    png = imread(path)\n    martini = Martini(png.shape[0] + 1)\n    indices = np.asarray(martini.indices_view, dtype=np.uint32)\n    coords = np.asarray(martini.coords_view, dtype=np.uint16)\n\n    # Load JS terrain output\n    path = this_dir() / f\'data/{png_fname}_martini_indices\'\n    with open(path, \'rb\') as f:\n        exp_indices = np.frombuffer(f.read(), dtype=np.uint32)\n\n    path = this_dir() / f\'data/{png_fname}_martini_coords\'\n    with open(path, \'rb\') as f:\n        exp_coords = np.frombuffer(f.read(), dtype=np.uint16)\n\n    assert np.array_equal(indices, exp_indices), \'indices not matching expected\'\n    assert np.array_equal(coords, exp_coords), \'coords not matching expected\'\n\n\n@pytest.mark.parametrize(""png_fname,encoding"", TEST_PNG_FILES)\ndef test_errors(png_fname, encoding):\n    """"""Test errors output from martini.create_tile(terrain)\n    """"""\n    # Generate errors output in Python\n    path = this_dir() / f\'data/{png_fname}.png\'\n    png = imread(path)\n    terrain = decode_ele(png, encoding=encoding)\n    martini = Martini(png.shape[0] + 1)\n    tile = martini.create_tile(terrain)\n    errors = np.asarray(tile.errors_view, dtype=np.float32)\n\n    # Load JS errors output\n    path = this_dir() / f\'data/{png_fname}_errors\'\n    with open(path, \'rb\') as f:\n        exp_errors = np.frombuffer(f.read(), dtype=np.float32)\n\n    assert np.array_equal(errors, exp_errors), \'errors not matching expected\'\n\n\n@pytest.mark.parametrize(""png_fname,max_error,encoding"", TEST_CASES)\ndef test_mesh(png_fname, max_error, encoding):\n    # Generate mesh output in Python\n    path = this_dir() / f\'data/{png_fname}.png\'\n    png = imread(path)\n    terrain = decode_ele(png, encoding=encoding)\n    martini = Martini(png.shape[0] + 1)\n    tile = martini.create_tile(terrain)\n    vertices, triangles = tile.get_mesh(max_error)\n\n    # Load JS mesh output\n    path = this_dir() / f\'data/{png_fname}_vertices_{max_error}\'\n    with open(path, \'rb\') as f:\n        exp_vertices = np.frombuffer(f.read(), dtype=np.uint16)\n\n    path = this_dir() / f\'data/{png_fname}_triangles_{max_error}\'\n    with open(path, \'rb\') as f:\n        exp_triangles = np.frombuffer(f.read(), dtype=np.uint32)\n\n    assert np.array_equal(\n        vertices, exp_vertices), \'vertices not matching expected\'\n    assert np.array_equal(\n        triangles, exp_triangles), \'triangles not matching expected\'\n'"
