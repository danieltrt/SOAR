file_path,api_count,code
dev.py,0,"b'#!/usr/bin/env python3\n\nimport os\nimport click\nfrom executor import execute\n\n\ndef python_source_files():\n    import glob\n\n    include_paths = glob.glob(""*.py"") + glob.glob(""vg/*.py"") + [""doc/""]\n    exclude_paths = []\n    return [x for x in include_paths if x not in exclude_paths]\n\n\n@click.group()\ndef cli():\n    pass\n\n\n@cli.command()\ndef init():\n    execute(""pip2 install --upgrade -r requirements_dev_py2.txt"")\n    execute(""pip3 install --upgrade -r requirements_dev_py3.txt"")\n\n\n@cli.command()\ndef test():\n    execute(""pytest"")\n\n\n@cli.command()\ndef coverage():\n    execute(""pytest --cov=vg"")\n\n\n@cli.command()\ndef coverage_report():\n    execute(""coverage html"")\n    execute(""open htmlcov/index.html"")\n\n\n@cli.command()\ndef test_both():\n    execute(""python2 -m pytest"")\n    execute(""python3 -m pytest"")\n\n\n@cli.command()\ndef lint():\n    execute(""flake8"", *python_source_files())\n\n\n@cli.command()\ndef black():\n    execute(""black"", *python_source_files())\n\n\n@cli.command()\ndef black_check():\n    execute(""black"", ""--check"", *python_source_files())\n\n\n@cli.command()\ndef doc():\n    execute(""rm -rf build/ doc/build/ doc/api/"")\n    execute(""sphinx-build -b singlehtml doc doc/build"")\n\n\n@cli.command()\ndef doc_open():\n    execute(""open doc/build/index.html"")\n\n\n@cli.command()\ndef publish():\n    execute(""rm -rf dist/"")\n    execute(""python3 setup.py sdist bdist_wheel"")\n    execute(""twine upload dist/*"")\n\n\nif __name__ == ""__main__"":\n    os.chdir(os.path.abspath(os.path.dirname(__file__)))\n    cli()\n'"
setup.py,0,"b'from setuptools import find_packages, setup\n\n# Set version_info[__version__], while avoiding importing numpy, in case numpy\n# and vg are being installed concurrently.\n# https://packaging.python.org/guides/single-sourcing-package-version/\nversion_info = {}\nexec(open(""vg/package_version.py"").read(), version_info)\n\n# https://github.com/lace/vg/issues/72\nreadme = open(""README.md"", ""rb"").read().decode(""utf-8"")\ninstall_requires = open(""requirements.txt"", ""rb"").read().decode(""utf-8"")\n\nsetup(\n    name=""vg"",\n    version=version_info[""__version__""],\n    description=""Linear algebra for humans: a very good vector-geometry and linear-algebra toolbelt"",\n    long_description=readme,\n    long_description_content_type=""text/markdown"",\n    author=""Metabolize, Body Labs, and other contributors"",\n    author_email=""github@paulmelnikow.com"",\n    url=""https://github.com/lace/vg"",\n    project_urls={\n        ""Issue Tracker"": ""https://github.com/lace/vg/issues"",\n        ""Documentation"": ""https://vgpy.readthedocs.io/en/stable/"",\n    },\n    packages=find_packages(),\n    install_requires=install_requires,\n    classifiers=[\n        ""Development Status :: 5 - Production/Stable"",\n        ""Intended Audience :: Developers"",\n        ""Intended Audience :: Science/Research"",\n        ""Intended Audience :: Manufacturing"",\n        ""Topic :: Artistic Software"",\n        ""Topic :: Multimedia :: Graphics :: 3D Modeling"",\n        ""Topic :: Scientific/Engineering :: Mathematics"",\n        ""Topic :: Scientific/Engineering :: Visualization"",\n        ""License :: OSI Approved :: BSD License"",\n        ""Operating System :: OS Independent"",\n        ""Programming Language :: Python :: 3"",\n    ],\n)\n'"
doc/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n\nimport os\nimport sys\n\nsys.path.insert(0, os.path.abspath(""..""))\n\n# -- Project information -----------------------------------------------------\n\nproject = ""vg""\ncopyright = ""2018-2020 Metabolize LLC; 2016 Body Labs, Inc.""\nauthor = ""Metabolize, Body Labs, and other contributors""\n\n# The short X.Y version\nversion = """"\n# The full version, including alpha/beta/rc tags\nrelease = """"\n\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    ""sphinx.ext.autodoc"",\n    ""sphinx.ext.doctest"",\n    ""sphinx.ext.coverage"",\n    ""sphinx.ext.viewcode"",\n    ""sphinx.ext.napoleon"",\n]\n\nsource_parsers = {"".md"": ""recommonmark.parser.CommonMarkParser""}\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [""_templates""]\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\nsource_suffix = ["".rst"", "".md""]\n\n# The master toctree document.\nmaster_doc = ""index""\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [""_build"", ""Thumbs.db"", "".DS_Store""]\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = None\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = ""alabaster""\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [""_static""]\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = ""vgdoc""\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [(master_doc, ""vg.tex"", ""vg Documentation"", ""Metabolize"", ""manual"")]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, ""vg"", ""vg Documentation"", [author], 1)]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        ""vg"",\n        ""vg Documentation"",\n        author,\n        ""vg"",\n        ""One line description of project."",\n        ""Miscellaneous"",\n    )\n]\n\n\n# -- Options for Epub output -------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#\n# epub_identifier = \'\'\n\n# A unique identification for the text.\n#\n# epub_uid = \'\'\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [""search.html""]\n\n\n# -- Extension configuration -------------------------------------------------\n\n# Napoleon settings.\nnapoleon_numpy_docstring = False\nnapoleon_include_special_with_doc = True\n\n\ndef setup(app):\n    from recommonmark.transform import AutoStructify\n\n    app.add_config_value(""recommonmark_config"", {}, True)\n    app.add_transform(AutoStructify)\n'"
vg/__init__.py,0,"b'from . import core as _core\nfrom . import matrix  # noqa: F401\nfrom . import shape  # noqa: F401\nfrom .core import *  # noqa: F403,F401\nfrom .package_version import __version__  # noqa: F401\n\n\n__all__ = _core.__all__ + [""matrix"", ""shape""]\n'"
vg/_helpers.py,2,"b'import numpy as np\nfrom .shape import check, check_value\n\n\ndef pluralize(noun, count):\n    return noun if count == 1 else ""{}s"".format(noun)\n\n\ndef raise_dimension_error(*input_values):\n    messages = [\n        ""{} {}"".format(input_value.ndim, pluralize(""dimension"", input_value.ndim))\n        for input_value in input_values\n    ]\n    if len(messages) == 1:\n        message = messages[0]\n    elif len(messages) == 2:\n        message = ""{} and {}"".format(*messages)\n    else:\n        message = ""those inputs""\n    raise ValueError(""Not sure what to do with {}"".format(message))\n\n\ndef broadcast_and_tile(v1, v2):\n    if v1.ndim == 1 and v2.ndim == 2:\n        check(locals(), ""v1"", (3,))\n        k = check(locals(), ""v2"", (-1, 3))\n        return np.tile(v1, (k, 1)), v2\n    elif v1.ndim == 2 and v2.ndim == 1:\n        k = check(locals(), ""v1"", (-1, 3))\n        check(locals(), ""v2"", (3,))\n        return v1, np.tile(v2, (k, 1))\n    elif v1.ndim == 2 and v2.ndim == 2:\n        k = check(locals(), ""v1"", (-1, 3))\n        check(locals(), ""v2"", (k, 3))\n        return v1, v2\n    else:\n        raise_dimension_error(v1, v2)\n\n\n# TODO: After dropping Python 2, make `name=None` a regular kwarg.\ndef _check_value_any(a, *shapes, **kwargs):\n    """"""\n    Similar to `check_value()`, but accepts many candidate shapes and checks\n    each of them before raising an error.\n\n    Returns:\n        object: The wildcard dimension (if one) or a tuple of wildcard\n        dimensions (if more than one) of the matched shape\n    """"""\n    if len(shapes) == 0:\n        raise ValueError(""At least one shape is required"")\n    name = kwargs.get(""name"")\n    for shape in shapes:\n        try:\n            return check_value(a, shape, name=name)\n        except ValueError:\n            pass\n\n    if name is None:\n        preamble = ""Expected an array""\n    else:\n        preamble = ""Expected {} to be an array"".format(name)\n\n    shape_choices = "", "".join(\n        shapes[:-2] + ("" or "".join([str(shapes[-2]), str(shapes[-1])]),)\n    )\n\n    if a is None:\n        raise ValueError(""{} with shape {}; got None"".format(preamble, shape_choices))\n    else:\n        raise ValueError(\n            ""{} with shape {}; got {}"".format(preamble, shape_choices, a.shape)\n        )\n'"
vg/core.py,87,"b'import math\nimport numpy as np\nfrom ._helpers import _check_value_any, broadcast_and_tile, raise_dimension_error\nfrom .shape import check, check_value_any\n\n__all__ = [\n    ""normalize"",\n    ""perpendicular"",\n    ""project"",\n    ""scalar_projection"",\n    ""reject"",\n    ""reject_axis"",\n    ""magnitude"",\n    ""euclidean_distance"",\n    ""angle"",\n    ""signed_angle"",\n    ""rotate"",\n    ""scale_factor"",\n    ""orient"",\n    ""almost_zero"",\n    ""almost_unit_length"",\n    ""almost_collinear"",\n    ""almost_equal"",\n    ""principal_components"",\n    ""major_axis"",\n    ""apex"",\n    ""argapex"",\n    ""nearest"",\n    ""farthest"",\n    ""basis"",\n    ""within"",\n    ""average"",\n    ""cross"",\n    ""dot"",\n]\n\n\ndef normalize(vector):\n    """"""\n    Return the vector, normalized.\n\n    If vector is 2d, treats it as stacked vectors, and normalizes each one.\n\n    """"""\n    if vector.ndim == 1:\n        return vector / np.linalg.norm(vector)\n    elif vector.ndim == 2:\n        return vector / np.linalg.norm(vector, axis=1)[:, np.newaxis]\n    else:\n        raise_dimension_error(vector)\n\n\ndef perpendicular(v1, v2, normalized=True):\n    """"""\n    Given two noncollinear vectors, return a vector perpendicular to both.\n\n    Result vectors follow the right-hand rule. When the right index finger\n    points along `v1` and the right middle finger along `v2`, the right thumb\n    points along the result.\n\n    When one or both sets of inputs is stacked, compute the perpendicular\n    vectors elementwise, returning a stacked result. (e.g. when `v1` and `v2`\n    are both stacked, `result[k]` is perpendicular to `v1[k]` and `v2[k]`.)\n\n    Args:\n        v1 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors.\n        v2 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors. If\n            stacked, the shape must be the same as `v1`.\n        normalized (bool): When `True`, the result vector is guaranteed to be\n            unit length.\n\n    Return:\n        np.arraylike: An array with the same shape as `v1` and `v2`.\n\n    See also:\n        - https://en.wikipedia.org/wiki/Cross_product#Definition\n        - https://commons.wikimedia.org/wiki/File:Right_hand_rule_cross_product.svg\n    """"""\n    result = cross(v1, v2)\n    return normalize(result) if normalized else result\n\n\ndef project(vector, onto):\n    """"""\n    Compute the vector projection of `vector` onto the vector `onto`.\n\n    `onto` need not be normalized.\n\n    """"""\n    if vector.ndim == 1:\n        return scalar_projection(vector, onto=onto) * normalize(onto)\n    elif vector.ndim == 2:\n        return scalar_projection(vector, onto=onto)[:, np.newaxis] * normalize(onto)\n    else:\n        raise_dimension_error(vector)\n\n\ndef scalar_projection(vector, onto):\n    """"""\n    Compute the scalar projection of `vector` onto the vector `onto`.\n\n    `onto` need not be normalized.\n\n    """"""\n    if vector.ndim == 1:\n        check(locals(), ""vector"", (3,))\n        check(locals(), ""onto"", (3,))\n    else:\n        k = check(locals(), ""vector"", (-1, 3))\n        if onto.ndim == 1:\n            check(locals(), ""onto"", (3,))\n        else:\n            check(locals(), ""onto"", (k, 3))\n\n    return dot(vector, normalize(onto))\n\n\ndef reject(vector, from_v):\n    """"""\n    Compute the vector rejection of `vector` from `from_v` -- i.e.\n    the vector component of `vector` perpendicular to `from_v`.\n\n    `from_v` need not be normalized.\n\n    """"""\n    return vector - project(vector, onto=from_v)\n\n\ndef reject_axis(vector, axis, squash=False):\n    """"""\n    Compute the vector component of `vector` perpendicular to the basis\n    vector specified by `axis`. 0 means x, 1 means y, 2 means z.\n\n    In other words, return a copy of vector that zeros the `axis` component.\n\n    When `squash` is True, instead of zeroing the component, it drops it, so\n    an input vector (in R3) is mapped to a point in R2.\n\n    (N.B. Don\'t be misled: this meaning of `axis` is pretty different from\n    the typical meaning in numpy.)\n\n    """"""\n    if squash:\n        dims_to_keep = [0, 1, 2]\n        try:\n            dims_to_keep.remove(axis)\n        except ValueError:\n            raise ValueError(""axis should be 0, 1, or 2"")\n\n        if vector.ndim == 1:\n            return vector[dims_to_keep]\n        elif vector.ndim == 2:\n            return vector[:, dims_to_keep]\n        else:\n            raise_dimension_error(vector)\n    else:\n        if axis not in [0, 1, 2]:\n            raise ValueError(""axis should be 0, 1, or 2"")\n        result = vector.copy()\n        if vector.ndim == 1:\n            result[axis] = 0.0\n        elif vector.ndim == 2:\n            result[:, axis] = 0.0\n        else:\n            raise_dimension_error(vector)\n        return result\n\n\ndef magnitude(vector):\n    """"""\n    Compute the magnitude of `vector`. For a stacked input, compute the\n    magnitude of each one.\n\n    Args:\n        vector (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors.\n\n    Returns:\n        object: For a `(3,)` input, a `float` with the magnitude. For a `kx3`\n            input, a `(k,)` array.\n    """"""\n    if vector.ndim == 1:\n        return np.linalg.norm(vector)\n    elif vector.ndim == 2:\n        return np.linalg.norm(vector, axis=1)\n    else:\n        raise_dimension_error(vector)\n\n\n# Alias because angle()\'s parameter shadows the name.\n_normalize = normalize\n\n\ndef euclidean_distance(v1, v2):\n    """"""\n    Compute Euclidean distance, which is the distance between two points in a\n    straight line. This can be done individually by passing in single\n    point for either or both arguments, or pairwise by passing in stacks of\n    points.\n\n    Args:\n        v1 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors.\n        v2 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors. If\n            stacks are provided for both `v1` and `v2` they must have the\n            same shape.\n\n    Returns:\n        object: When both inputs are `(3,)`, a `float` with the distance.\n        Otherwise a `(k,)` array.\n    """"""\n    k = check_value_any(v1, (3,), (-1, 3), name=""v1"")\n    check_value_any(\n        v2, (3,), (-1 if k is None else k, 3), name=""v2"",\n    )\n\n    if v1.ndim == 1 and v2.ndim == 1:\n        return np.sqrt(np.sum(np.square(v2 - v1)))\n    else:\n        return np.sqrt(np.sum(np.square(v2 - v1), axis=1))\n\n\ndef angle(v1, v2, look=None, assume_normalized=False, units=""deg""):\n    """"""\n    Compute the unsigned angle between two vectors. For a stacked input, the\n    angle is computed pairwise.\n\n    When `look` is provided, the angle is computed in that viewing plane\n    (`look` is the normal). Otherwise the angle is computed in 3-space.\n\n    Args:\n        v1 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors.\n        v2 (np.arraylike): A vector or stack of vectors with the same shape as\n            `v1`.\n        look (np.arraylike): A `(3,)` vector specifying the normal of a viewing\n            plane, or `None` to compute the angle in 3-space.\n        assume_normalized (bool): When `True`, assume the input vectors\n            are unit length. This improves performance, however when the inputs\n            are not normalized, setting this will cause an incorrect results.\n        units (str): `\'deg\'` to return degrees or `\'rad\'` to return radians.\n\n    Return:\n        object: For a `(3,)` input, a `float` with the angle. For a `kx3`\n        input, a `(k,)` array.\n    """"""\n    if units not in [""deg"", ""rad""]:\n        raise ValueError(""Unrecognized units {}; expected deg or rad"".format(units))\n\n    if look is not None:\n        # This is a simple approach. Since this is working in two dimensions,\n        # a smarter approach could reduce the amount of computation needed.\n        v1, v2 = [reject(v, from_v=look) for v in (v1, v2)]\n\n    dot_products = np.einsum(""ij,ij->i"", v1.reshape(-1, 3), v2.reshape(-1, 3))\n\n    if assume_normalized:\n        cosines = dot_products\n    else:\n        cosines = dot_products / magnitude(v1) / magnitude(v2)\n\n    # Clip, because the dot product can slip past 1 or -1 due to rounding and\n    # we can\'t compute arccos(-1.00001).\n    angles = np.arccos(np.clip(cosines, -1.0, 1.0))\n    if units == ""deg"":\n        angles = np.degrees(angles)\n\n    return angles[0] if v1.ndim == 1 and v2.ndim == 1 else angles\n\n\ndef signed_angle(v1, v2, look, units=""deg""):\n    """"""\n    Compute the signed angle between two vectors. For a stacked input, the\n    angle is computed pairwise.\n\n    Results are in the range -180 and 180 (or `-math.pi` and `math.pi`). A\n    positive number indicates a clockwise sweep from `v1` to `v2`. A negative\n    number is counterclockwise.\n\n    Args:\n        v1 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors.\n        v2 (np.arraylike): A vector or stack of vectors with the same shape as\n            `v1`.\n        look (np.arraylike): A `(3,)` vector specifying the normal of the\n            viewing plane.\n        units (str): `\'deg\'` to return degrees or `\'rad\'` to return radians.\n\n    Returns:\n        object: For a `(3,)` input, a `float` with the angle. For a `kx3`\n        input, a `(k,)` array.\n    """"""\n    # The sign of (A x B) dot look gives the sign of the angle.\n    # > 0 means clockwise, < 0 is counterclockwise.\n    sign = np.array(np.sign(np.cross(v1, v2).dot(look)))\n\n    # 0 means collinear: 0 or 180. Let\'s call that clockwise.\n    sign[sign == 0] = 1\n\n    return sign * angle(v1, v2, look, units=units)\n\n\ndef rotate(vector, around_axis, angle, units=""deg"", assume_normalized=False):\n    """"""\n    Rotate a point or vector around a given axis. The direction of rotation\n    around `around_axis` is determined by the right-hand rule.\n\n    Args:\n        vector (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors.\n        around_axis (np.arraylike): A `(3,)` vector specifying the axis of rotation.\n        assume_normalized (bool): When `True`, assume `around_axis` is unit\n            length. This improves performance marginally, however\n            when the inputs are not normalized, setting this will cause an\n            incorrect results.\n        units (str): `\'deg\'` to specify `angle` in degrees or `\'rad\'` to specify\n            radians.\n\n    Returns:\n        np.arraylike: The transformed point or points. This has the same shape as\n            `vector`.\n\n    See also:\n        - https://en.wikipedia.org/wiki/Cross_product#Definition\n        - https://commons.wikimedia.org/wiki/File:Right_hand_rule_cross_product.svg\n    """"""\n    if units == ""deg"":\n        angle = math.radians(angle)\n    elif units != ""rad"":\n        raise ValueError(\'Unknown units ""{}""; expected ""deg"" or ""rad""\'.format(units))\n\n    cosine = math.cos(angle)\n    sine = math.sin(angle)\n\n    if not assume_normalized:\n        around_axis = normalize(around_axis)\n\n    if vector.ndim == 1:\n        dot_products = np.inner(around_axis, vector)\n    elif vector.ndim == 2:\n        dot_products = np.inner(around_axis, vector)[:, np.newaxis]\n    else:\n        raise_dimension_error(vector)\n\n    # Rodrigues\' rotation formula.\n    return (\n        cosine * vector\n        + sine * np.cross(around_axis, vector)\n        + (1 - cosine) * dot_products * around_axis\n    )\n\n\ndef scale_factor(v1, v2):\n    """"""\n    Given two parallel vectors, compute the scale factor `k` such that\n    `k * v1` is approximately equal to `v2`.\n\n    Args:\n        v1 (np.arraylike): A vector in `R^3` or a `kx3` stack of vectors.\n        v2 (np.arraylike): A second vector in `R^3` or a `kx3` stack of\n          vectors. If `v1` and `v2` are both stacked, they must be the\n          same shape.\n\n    Returns:\n        object: A float containing the scale factor `k`, or `nan` if `v1`\n        is the zero vector. If either input is stacked, the result will also\n        be stacked.\n    """"""\n    k = _check_value_any(v1, (3,), (-1, 3), name=""v1"")\n    _check_value_any(v2, (3,), (-1 if k is None else k, 3), name=""v1"")\n\n    v1_dot_v2 = dot(v1, v2)\n    v1_dot_v1 = dot(v1, v1)\n\n    if np.isscalar(v1_dot_v1) and v1_dot_v1 == 0:\n        v1_dot_v1 = np.nan\n    elif not np.isscalar(v1_dot_v1):\n        v1_dot_v1[v1_dot_v1 == 0] = np.nan\n\n    return v1_dot_v2 / v1_dot_v1\n\n\ndef orient(vector, along, reverse=False):\n    """"""\n    Given two vectors, flip the first if necessary, so that it points\n    (approximately) along the second vector rather than (approximately)\n    opposite it.\n\n    Args:\n        vector (np.arraylike): A vector in `R^3`.\n        along (np.arraylike): A second vector in `R^3`.\n        reverse (bool): When `True`, reverse the logic, returning a vector\n          that points against `along`.\n\n    Returns:\n        np.arraylike: Either `vector` or `-vector`.\n    """"""\n    check(locals(), ""vector"", (3,))\n    check(locals(), ""along"", (3,))\n\n    projected = project(vector, onto=along)\n    computed_scale_factor = scale_factor(projected, along)\n    if not reverse and computed_scale_factor < 0:\n        return -vector\n    elif reverse and computed_scale_factor > 0:\n        return -vector\n    else:\n        return vector\n\n\ndef almost_zero(v, atol=1e-08):\n    """"""\n    Test if v is almost the zero vector.\n\n    """"""\n    return np.allclose(v, np.array([0.0, 0.0, 0.0]), rtol=0, atol=atol)\n\n\ndef almost_unit_length(vector, atol=1e-08):\n    """"""\n    Test if the `vector` has almost unit length. For a stacked input, test each\n    one.\n\n    Args:\n        vector (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors.\n\n    Returns:\n        object: For a `(3,)` input, a `bool`. For a `kx3` input, a `(k,)`\n        array.\n    """"""\n    return np.isclose(magnitude(vector), 1.0, rtol=0, atol=atol)\n\n\ndef almost_collinear(v1, v2, atol=1e-08):\n    """"""\n    Test if `v1` and `v2` are almost collinear.\n\n    This will return true if either `v1` or `v2` is the zero vector, because\n    mathematically speaking, the zero vector is collinear to everything.\n\n    Geometrically that doesn\'t necessarily make sense, so if you want to handle\n    zero vectors specially, you can test your inputs with `vg.almost_zero()`.\n    """"""\n    cross = np.cross(v1, v2)\n    norm = np.linalg.norm(cross)\n    return np.isclose(norm, 0.0, rtol=0, atol=atol)\n\n\ndef almost_equal(v1, v2, atol=1e-08):\n    """"""\n    Test if `v1` and `v2` are equal within the given absolute tolerance.\n\n    See also:\n        - https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html\n\n    """"""\n    return np.allclose(v1, v2, rtol=0, atol=atol)\n\n\ndef principal_components(coords):\n    """"""\n    Compute the principal components of the input coordinates. These are\n    useful for dimensionality reduction and feature modeling.\n\n    Args:\n        coords (np.arraylike): A `nxk` stack of coordinates.\n\n    Returns:\n        np.ndarray: A `kxk` stack of vectors.\n\n    See also:\n        - http://setosa.io/ev/principal-component-analysis/\n        - https://en.wikipedia.org/wiki/Principal_component_analysis\n        - https://plot.ly/ipython-notebooks/principal-component-analysis/\n    """"""\n    mean = np.mean(coords, axis=0)\n    _, _, result = np.linalg.svd(coords - mean)\n    return result\n\n\ndef major_axis(coords):\n    """"""\n    Compute the first principal component of the input coordinates. This is\n    the vector which best describes the multidimensional data using a single\n    dimension.\n\n    Args:\n        coords (np.arraylike): A `nxk` stack of coordinates.\n\n    Returns:\n        np.ndarray: A `(k,)` vector.\n\n    See also:\n        - http://setosa.io/ev/principal-component-analysis/\n        - https://en.wikipedia.org/wiki/Principal_component_analysis\n        - https://plot.ly/ipython-notebooks/principal-component-analysis/\n    """"""\n    return principal_components(coords)[0]\n\n\ndef argapex(points, along):\n    """"""\n    Find the index of the most extreme point in the direction provided.\n\n    Args:\n        points (np.arraylike): A `kx3` stack of points in R^3.\n        along (np.arraylike): A `(3,)` vector specifying the direction of\n            interest.\n\n    Returns:\n        int: The index of the most extreme point.\n    """"""\n    k = check(locals(), ""points"", (-1, 3))\n    if k == 0:\n        raise ValueError(""At least one point is required"")\n    check(locals(), ""along"", (3,))\n    coords_on_axis = points.dot(along)\n    return np.argmax(coords_on_axis)\n\n\ndef apex(points, along):\n    """"""\n    Find the most extreme point in the direction provided.\n\n    Args:\n        points (np.arraylike): A `kx3` stack of points in R^3.\n        along (np.arraylike): A `(3,)` vector specifying the direction of\n            interest.\n\n    Returns:\n        np.ndarray: A copy of a point taken from `points`.\n    """"""\n    return points[argapex(points=points, along=along)].copy()\n\n\ndef nearest(from_points, to_point, ret_index=False):\n    """"""\n    Find the point nearest to the given point.\n\n    Args:\n        from_points (np.arraylike): A `kx3` stack of points in R^3.\n        to_point (np.arraylike): A `(3,)` point of interest.\n        ret_index (bool): When `True`, return both the point and its index.\n\n    Returns:\n        np.ndarray: A `(3,)` vector taken from `from_points`.\n    """"""\n    check(locals(), ""from_points"", (-1, 3))\n    check(locals(), ""to_point"", (3,))\n\n    absolute_distances = magnitude(from_points - to_point)\n\n    index_of_nearest_point = np.argmin(absolute_distances)\n    nearest_point = from_points[index_of_nearest_point]\n\n    if ret_index:\n        return nearest_point, index_of_nearest_point\n    else:\n        return nearest_point\n\n\ndef farthest(from_points, to_point, ret_index=False):\n    """"""\n    Find the point farthest from the given point.\n\n    Args:\n        from_points (np.arraylike): A `kx3` stack of points in R^3.\n        to_point (np.arraylike): A `(3,)` point of interest.\n        ret_index (bool): When `True`, return both the point and its index.\n\n    Returns:\n        np.ndarray: A `(3,)` vector taken from `from_points`.\n    """"""\n    if from_points.ndim != 2 or from_points.shape[1] != 3:\n        raise ValueError(\n            ""Invalid shape %s: farthest expects nx3"" % (from_points.shape,)\n        )\n    if to_point.shape != (3,):\n        raise ValueError(""to_point should be (3,)"")\n\n    absolute_distances = magnitude(from_points - to_point)\n\n    index_of_farthest_point = np.argmax(absolute_distances)\n    farthest_point = from_points[index_of_farthest_point]\n\n    if ret_index:\n        return farthest_point, index_of_farthest_point\n    else:\n        return farthest_point\n\n\ndef within(points, radius, of_point, atol=1e-08, ret_indices=False):\n    """"""\n    Select points within a given radius of a point.\n\n    Args:\n        points (np.arraylike): A `kx3` stack of points in R^3.\n        radius (float): The radius of the sphere of interest centered on\n            `of_point`.\n        of_point (np.arraylike): The `(3,)` point of interest.\n        atol (float): The distance tolerance. Points within `radius + atol`\n            of `of_point` are selected.\n        ret_indexes (bool): When `True`, return both the points and their\n            indices.\n\n    Returns:\n        np.ndarray: A `(3,)` vector taken from `points`.\n    """"""\n    if points.ndim != 2 or points.shape[1] != 3:\n        raise ValueError(""Invalid shape %s: within expects nx3"" % (points.shape,))\n    if not isinstance(radius, float):\n        raise ValueError(""radius should be a float"")\n    if of_point.shape != (3,):\n        raise ValueError(""to_point should be (3,)"")\n\n    absolute_distances = magnitude(points - of_point)\n    (indices_within_radius,) = (absolute_distances < radius + atol).nonzero()\n    points_within_radius = points[indices_within_radius]\n    if ret_indices:\n        return points_within_radius, indices_within_radius\n    else:\n        return points_within_radius\n\n\ndef average(values, weights=None, ret_sum_of_weights=False):\n    """"""\n    Compute a weighted or unweighted average of the 3D input values. The\n    inputs could be points or vectors.\n\n    Args:\n        values (np.arraylike): A `kx3` stack of vectors.\n        weights (array-convertible): An optional `k` array of weights.\n        ret_sum_of_weights (bool): When `True`, the sum of the weights is\n            returned. When `weights` is `None`, this is the number of\n            elements over which the average is taken.\n\n    Returns:\n        np.ndarray: A `(3,)` vector with the weighted or unweighted average.\n    """"""\n    k = check(locals(), ""values"", (-1, 3))\n    if weights is not None:\n        weights = np.array(weights)\n        check(locals(), ""weights"", (k,))\n    result = np.average(values, axis=0, weights=weights)\n    if ret_sum_of_weights:\n        sum_of_weights = np.sum(weights)\n        return result, sum_of_weights\n    else:\n        return result\n\n\ndef dot(v1, v2):\n    """"""\n    Compute individual or pairwise dot products.\n\n    Args:\n        v1 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors.\n        v2 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors. If\n            stacks are provided for both `v1` and `v2` they must have the\n            same shape.\n    """"""\n    if v1.ndim == 1 and v2.ndim == 1:\n        check(locals(), ""v1"", (3,))\n        check(locals(), ""v2"", (3,))\n        return np.dot(v1, v2)\n    else:\n        v1, v2 = broadcast_and_tile(v1, v2)\n        return np.einsum(""ij,ij->i"", v1.reshape(-1, 3), v2.reshape(-1, 3))\n\n\ndef cross(v1, v2):\n    """"""\n    Compute individual or pairwise cross products.\n\n    Args:\n        v1 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors.\n        v2 (np.arraylike): A `(3,)` vector or a `kx3` stack of vectors. If\n            stacks are provided for both `v1` and `v2` they must have the\n            same shape.\n    """"""\n    if v1.ndim == 1 and v2.ndim == 1:\n        check(locals(), ""v1"", (3,))\n        check(locals(), ""v2"", (3,))\n        return np.cross(v1, v2)\n    else:\n        v1, v2 = broadcast_and_tile(v1, v2)\n        return np.cross(v1[:, np.newaxis, :], v2[:, np.newaxis, :])[:, 0, :]\n\n\nclass _BasisVectors(object):\n    """"""\n    The cartesian basis vectors.\n    """"""\n\n    @property\n    def x(self):\n        return np.array([1.0, 0.0, 0.0])\n\n    @property\n    def y(self):\n        return np.array([0.0, 1.0, 0.0])\n\n    @property\n    def z(self):\n        return np.array([0.0, 0.0, 1.0])\n\n    @property\n    def neg_x(self):\n        return np.array([-1.0, 0.0, 0.0])\n\n    @property\n    def neg_y(self):\n        return np.array([0.0, -1.0, 0.0])\n\n    @property\n    def neg_z(self):\n        return np.array([0.0, 0.0, -1.0])\n\n\nbasis = _BasisVectors()\n'"
vg/matrix.py,4,"b'import numpy as np\nfrom ._helpers import raise_dimension_error\n\n\ndef pad_with_ones(matrix):\n    """"""\n    Add a column of ones. Transform from:\n        array([[1., 2., 3.],\n               [2., 3., 4.],\n               [5., 6., 7.]])\n    to:\n        array([[1., 2., 3., 1.],\n               [2., 3., 4., 1.],\n               [5., 6., 7., 1.]])\n\n    """"""\n    if matrix.ndim != 2 or matrix.shape[1] != 3:\n        raise ValueError(""Invalid shape %s: pad expects nx3"" % (matrix.shape,))\n    return np.pad(matrix, ((0, 0), (0, 1)), mode=""constant"", constant_values=1)\n\n\ndef unpad(matrix):\n    """"""\n    Strip off a column (e.g. of ones). Transform from:\n        array([[1., 2., 3., 1.],\n               [2., 3., 4., 1.],\n               [5., 6., 7., 1.]])\n    to:\n        array([[1., 2., 3.],\n               [2., 3., 4.],\n               [5., 6., 7.]])\n\n    """"""\n    if matrix.ndim != 2 or matrix.shape[1] != 4:\n        raise ValueError(""Invalid shape %s: unpad expects nx4"" % (matrix.shape,))\n    if not all(matrix[:, 3] == 1.0):\n        raise ValueError(""Expected a column of ones"")\n    return np.delete(matrix, 3, axis=1)\n\n\ndef transform(vertices, transform):\n    """"""\n    Apply the given transformation matrix to the vertices using homogenous\n    coordinates.\n    """"""\n    if transform.shape != (4, 4):\n        raise ValueError(""Transformation matrix should be 4x4"")\n\n    if vertices.ndim == 1:\n        matrix = vertices[np.newaxis]\n    elif vertices.ndim == 2:\n        matrix = vertices\n    else:\n        raise_dimension_error(vertices)\n\n    if matrix.shape[1] != 3:\n        raise ValueError(""Vertices should be (3,) or Nx3"")\n\n    result = unpad(np.dot(transform, pad_with_ones(matrix).T).T)\n    return result[0] if vertices.ndim == 1 else result\n'"
vg/package_version.py,0,"b'__version__ = ""1.9.0""\n'"
vg/shape.py,4,"b'def check_value(arr, shape, **kwargs):\n    """"""\n    Check that the given argument has the expected shape. Shape dimensions can\n    be ints or -1 for a wildcard. The wildcard dimensions are returned, which\n    allows them to be used for subsequent validation or elsewhere in the\n    function.\n\n    Args:\n        arr (np.arraylike): An array-like input.\n        shape (list): Shape to validate. To require an array with 3 elements,\n            pass `(3,)`. To require n by 3, pass `(-1, 3)`.\n        name (str): Variable name to embed in the error message.\n\n    Returns:\n        object: The wildcard dimension (if one) or a tuple of wildcard\n        dimensions (if more than one).\n\n    Example:\n        >>> vg.shape.check_value(np.zeros((4, 3)), (-1, 3))\n        >>> # Proceed with confidence that `points` is a k x 3 array.\n\n    Example:\n        >>> k = vg.shape.check_value(np.zeros((4, 3)), (-1, 3))\n        >>> k\n        4\n    """"""\n\n    def is_wildcard(dim):\n        return dim == -1\n\n    if any(not isinstance(dim, int) and not is_wildcard(dim) for dim in shape):\n        raise ValueError(""Expected shape dimensions to be int"")\n\n    if ""name"" in kwargs:\n        preamble = ""{} must be an array"".format(kwargs[""name""])\n    else:\n        preamble = ""Expected an array""\n\n    if arr is None:\n        raise ValueError(""{} with shape {}; got None"".format(preamble, shape))\n    try:\n        len(arr.shape)\n    except (AttributeError, TypeError):\n        raise ValueError(\n            ""{} with shape {}; got {}"".format(preamble, shape, arr.__class__.__name__)\n        )\n\n    # Check non-wildcard dimensions.\n    if len(arr.shape) != len(shape) or any(\n        actual != expected\n        for actual, expected in zip(arr.shape, shape)\n        if not is_wildcard(expected)\n    ):\n        raise ValueError(""{} with shape {}; got {}"".format(preamble, shape, arr.shape))\n\n    wildcard_dims = [\n        actual for actual, expected in zip(arr.shape, shape) if is_wildcard(expected)\n    ]\n    if len(wildcard_dims) == 0:\n        return None\n    elif len(wildcard_dims) == 1:\n        return wildcard_dims[0]\n    else:\n        return tuple(wildcard_dims)\n\n\n# TODO-2.x: Remove kwargs hack when upgrading to Python 3.\ndef check_value_any(arr, *shapes, **kwargs):\n    """"""\n    Check that the given argument has any of the expected shapes. Shape dimensons\n    can be ints or -1 for a wildcard.\n\n    Args:\n        arr (np.arraylike): An array-like input.\n        shape (list): Shape candidates to validate. To require an array with 3\n            elements, pass `(3,)`. To require n by 3, pass `(-1, 3)`.\n        name (str): Variable name to embed in the error message.\n\n    Returns:\n        object: The wildcard dimension of the matched shape (if one) or a tuple\n        of wildcard dimensions (if more than one). If the matched shape has no\n        wildcard dimensions, returns `None`.\n\n    Example:\n        >>> k = check_shape_any(points, (3,), (-1, 3), name=""points"")\n        >>> check_shape_any(\n                reference_points_of_lines,\n                (3,),\n                (-1 if k is None else k, 3),\n                name=""reference_points_of_lines"",\n            )\n    """"""\n    if len(shapes) == 0:\n        raise ValueError(""At least one shape is required"")\n    for shape in shapes:\n        try:\n            return check_value(arr, shape, name=kwargs.get(""name"", ""arr""))\n        except ValueError:\n            pass\n\n    if ""name"" in kwargs:\n        preamble = ""Expected {} to be an array"".format(kwargs[""name""])\n    else:\n        preamble = ""Expected an array""\n\n    if len(shapes) == 1:\n        (shape_choices,) = shapes\n    else:\n        shape_choices = "", "".join(\n            shapes[:-2] + ("" or "".join([str(shapes[-2]), str(shapes[-1])]),)\n        )\n\n    if arr is None:\n        raise ValueError(""{} with shape {}; got None"".format(preamble, shape_choices))\n    else:\n        try:\n            len(arr.shape)\n        except (AttributeError, TypeError):\n            raise ValueError(\n                ""{} with shape {}; got {}"".format(\n                    preamble, shape_choices, arr.__class__.__name__\n                )\n            )\n        raise ValueError(\n            ""{} with shape {}; got {}"".format(preamble, shape_choices, arr.shape)\n        )\n\n\ndef check(locals_namespace, name, shape):\n    """"""\n    Convenience function for invoking `vg.shape.check_value()` with a\n    `locals()` dict.\n\n    Args:\n        namespace (dict): A subscriptable object, typically `locals()`.\n        name (str): Key to pull from `namespace`.\n        shape (list): Shape to validate. To require 3 by 1, pass `(3,)`. To\n            require n by 3, pass `(-1, 3)`.\n\n    Returns:\n        object: The wildcard dimension (if one) or a tuple of wildcard\n        dimensions (if more than one).\n\n    Example:\n        >>> def my_fun_function(points):\n        ...     vg.shape.check(locals(), \'points\', (-1, 3))\n        ...     # Proceed with confidence that `points` is a k x 3 array.\n\n    Example:\n        >>> def my_fun_function(points):\n        ...     k = vg.shape.check(locals(), \'points\', (-1, 3))\n        ...     print(""my_fun_function invoked with {} points"".format(k))\n\n    """"""\n    return check_value(locals_namespace[name], shape, name=name)\n\n\ndef columnize(arr, shape=(-1, 3), name=None):\n    """"""\n    Helper for functions which may accept a stack of points (`kx3`) returning\n    a stack of results, or a single set of three points `(3,)` returning a\n    single result.\n\n    For either kind of input, it returns the points as `kx3`, a boolean\n    `is_columnized`, and a `maybe_decolumnized` function which can be applied\n    to the result before returning it. For a columnized input this function\n    does nothing, and for a non-columnized input, it decolumnizes it,\n    producing the desired return value.\n\n    This is not limited to `kx3`. It can be used for different dimensional\n    shapes like `kx4`, and even higher dimensional shapes like `kx3x3`.\n    """"""\n    if not isinstance(shape, tuple):\n        raise ValueError(""shape should be a tuple"")\n    if len(shape) < 2:\n        raise ValueError(""shape should have at least two dimensions"")\n\n    check_value_any(arr, shape, shape[1:], name=name or ""arr"")\n\n    if arr.ndim == len(shape):\n        return arr, True, lambda x: x\n    else:\n        return arr.reshape(*shape), False, lambda x: x[0]\n'"
vg/test_almost_collinear.py,3,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_almost_collinear():\n    collinear_vectors = np.array(\n        [[1.0, 1.0, 0.0], [-1.0, -1.0, 0.0], [2.0, 2.0, 0.0], [1.000000001, 1.0, 0.0]]\n    )\n\n    for v1 in collinear_vectors:\n        for v2 in collinear_vectors:\n            assert vg.almost_collinear(v1, v2) == True  # noqa: E712\n\n    for v in collinear_vectors:\n        zero_v = np.array([0.0, 0.0, 0.0])\n        assert vg.almost_collinear(v, zero_v) == True  # noqa: E712\n        assert vg.almost_collinear(zero_v, v) == True  # noqa: E712\n        assert vg.almost_collinear(zero_v, zero_v) == True  # noqa: E712\n\n    non_collinear_vectors = np.array(\n        [[1.0, 1.0, 0.0], [-1.0, -1.3, 0.0], [2.0, 2.0, 1.0], [1.000001, 1.0, 0.0]]\n    )\n\n    for index1, v1 in enumerate(non_collinear_vectors):\n        for index2, v2 in enumerate(non_collinear_vectors):\n            if index1 != index2:\n                assert vg.almost_collinear(v1, v2) == False  # noqa: E712\n'"
vg/test_almost_equal.py,4,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_almost_equal():\n    assert (\n        vg.almost_equal(\n            np.array([1.0, 2.0, 3.0]),\n            np.array([1.000000000001, 2.000000000001, 3.000000000001]),\n        )\n        == True  # noqa: E712\n    )\n    assert (\n        vg.almost_equal(np.array([1.0, 2.0, 3.0]), np.array([1.01, 2.0, 3.0]))\n        == False  # noqa: E712\n    )\n    assert (\n        vg.almost_equal(np.array([1.0, 2.0, 3.0]), np.array([1.0]))\n        == False  # noqa: E712\n    )\n'"
vg/test_almost_unit_length.py,7,"b'import math\nimport numpy as np\nfrom . import core as vg\n\n\ndef test_almost_unit_length():\n    unit_vectors = np.array(\n        [\n            [1.0, 0.0, 0.0],\n            [0.0, -1.0, 0.0],\n            [0.0, 0.0, 1.000000001],\n            [1.0 / math.sqrt(3), 1.0 / math.sqrt(3), 1.0 / math.sqrt(3)],\n        ]\n    )\n\n    for v in unit_vectors:\n        assert vg.almost_unit_length(np.array(v)) == True  # noqa: E712\n\n    assert vg.almost_unit_length(np.array(unit_vectors)).tolist() == [\n        True,\n        True,\n        True,\n        True,\n    ]\n\n    non_unit_vectors = np.array(\n        [[1.0, 1.0, 0.0], [-1.0, -1.3, 0.0], [2.0, 2.0, 1.0], [1.000001, 1.0, 0.0]]\n    )\n\n    for v in non_unit_vectors:\n        assert vg.almost_unit_length(np.array(v)) == False  # noqa: E712\n\n    assert vg.almost_unit_length(np.array(non_unit_vectors)).tolist() == [\n        False,\n        False,\n        False,\n        False,\n    ]\n\n    assert vg.almost_unit_length(\n        np.vstack([unit_vectors, non_unit_vectors])\n    ).tolist() == [True, True, True, True, False, False, False, False]\n'"
vg/test_almost_zero.py,3,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_almost_zero():\n    assert vg.almost_zero(np.array([0.0, 0.0, 0.0])) is True\n    assert vg.almost_zero(np.array([0.000000000000000001, 0.0, 0.0])) is True\n    assert vg.almost_zero(np.array([0.0000001, 0.0, 0.0])) is False\n'"
vg/test_angle.py,36,"b'import math\nimport numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_basic():\n    perpendicular = np.array([[1.0, 1.0, 0.0], [-1.0, 1.0, 0.0]])\n    assert vg.angle(*perpendicular) == 90\n    assert vg.angle(*perpendicular[::-1]) == 90\n    assert isinstance(vg.angle(*perpendicular), float)\n\n    acute = np.array([[1.0, 2.0, 0.0], [-1.0, 2.0, 0.0]])\n    acute_angle = math.acos(3.0 / 5.0)\n    assert vg.angle(*acute, units=""rad"") == acute_angle\n    assert vg.angle(*acute, units=""rad"") == acute_angle\n\n\ndef test_units():\n    v1 = np.array([1, 1, 0])\n    v2 = np.array([-1, 1, 0])\n    assert vg.angle(v1, v2, units=""deg"") == 90\n    assert vg.angle(v2, v1, units=""rad"") == math.pi / 2.0\n    with pytest.raises(ValueError):\n        vg.angle(v2, v1, units=""cm"")\n\n\ndef test_assume_normalized():\n    acute = np.array([[1.0, 2.0, 0.0], [-1.0, 2.0, 0.0]])\n    acute_angle = math.acos(3.0 / 5.0)\n    np.testing.assert_almost_equal(\n        vg.angle(*acute, units=""rad"", assume_normalized=False), acute_angle\n    )\n    np.testing.assert_raises(\n        AssertionError,\n        np.testing.assert_almost_equal,\n        vg.angle(*acute, units=""rad"", assume_normalized=True),\n        acute_angle,\n    )\n\n    acute_norm = vg.normalize(acute)\n    np.testing.assert_almost_equal(\n        vg.angle(*acute_norm, units=""rad"", assume_normalized=False), acute_angle\n    )\n    np.testing.assert_almost_equal(\n        vg.angle(*acute_norm, units=""rad"", assume_normalized=True), acute_angle\n    )\n\n\ndef test_look():\n    v1 = np.array([1, 1, 1])\n    v2 = np.array([-1, 1, 0])\n    np.testing.assert_almost_equal(vg.angle(v1, v2, look=vg.basis.z), 90.0)\n    np.testing.assert_almost_equal(vg.angle(v1, v2, look=vg.basis.x), 45.0)\n    np.testing.assert_almost_equal(vg.angle(v1, v2, look=vg.basis.y), 135.0)\n\n\ndef test_stacked_basic():\n    v1 = np.array([[1, 1, 0], [1, 1, 0]])\n    v2 = np.array([[-1, 1, 0], [-1, -1, 0]])\n    np.testing.assert_array_almost_equal(vg.angle(v2, v1), np.array([90, 180]))\n\n\ndef test_stacked_units():\n    v1 = np.array([[1, 1, 0], [1, 1, 0]])\n    v2 = np.array([[-1, 1, 0], [-1, -1, 0]])\n    np.testing.assert_array_almost_equal(\n        vg.angle(v2, v1, units=""deg""), np.array([90, 180])\n    )\n    np.testing.assert_array_almost_equal(\n        vg.angle(v2, v1, units=""rad""), np.array([math.pi / 2.0, math.pi])\n    )\n\n\ndef test_stacked_assume_normalized():\n    v1 = np.array([[1.0, 2.0, 0.0], [1.0, 1.0, 0.0]])\n    v2 = np.array([[-1.0, 2.0, 0.0], [-1.0, -1.0, 0.0]])\n    expected = np.array([math.acos(3.0 / 5.0), math.pi])\n    np.testing.assert_array_almost_equal(\n        vg.angle(v2, v1, assume_normalized=False, units=""rad""), expected\n    )\n    np.testing.assert_raises(\n        AssertionError,\n        np.testing.assert_array_almost_equal,\n        vg.angle(v2, v1, assume_normalized=True, units=""rad""),\n        expected,\n    )\n\n    v1, v2 = [vg.normalize(v) for v in (v1, v2)]\n    np.testing.assert_array_almost_equal(\n        vg.angle(v2, v1, assume_normalized=False, units=""rad""), expected\n    )\n    np.testing.assert_array_almost_equal(\n        vg.angle(v2, v1, assume_normalized=True, units=""rad""), expected\n    )\n\n\ndef test_stacked_look():\n    v1 = np.array([[1, 1, 1], vg.basis.y])\n    v2 = np.array([[-1, 1, 0], vg.basis.z])\n    np.testing.assert_almost_equal(\n        vg.angle(v1, v2, look=vg.basis.x), np.array([45.0, 90.0])\n    )\n'"
vg/test_apex.py,20,"b'import numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_argapex_and_apex():\n    points = np.array(\n        [\n            [-0.97418884, -0.79808404, -0.18545491],\n            [0.60675227, 0.32673201, -0.20369793],\n            [0.67040405, 0.19267665, -0.56983579],\n            [-0.68038753, -0.90011588, 0.4649872],\n            [-0.62813991, -0.23947753, 0.07933854],\n            [0.26348356, 0.23701114, -0.38230596],\n            [0.08302473, 0.2784907, 0.09308946],\n            [0.58695587, -0.33253376, -0.33493078],\n            [-0.39221704, -0.45240036, 0.25284163],\n            [0.46270635, -0.3865265, -0.98106526],\n        ]\n    )\n\n    np.testing.assert_array_equal(vg.argapex(points, along=vg.basis.x), 2)\n    np.testing.assert_array_equal(vg.apex(points, along=vg.basis.x), points[2])\n    np.testing.assert_array_equal(vg.argapex(points, along=vg.basis.neg_x), 0)\n    np.testing.assert_array_equal(vg.apex(points, along=vg.basis.neg_x), points[0])\n    np.testing.assert_array_equal(vg.argapex(points, along=vg.basis.y), 1)\n    np.testing.assert_array_equal(vg.apex(points, along=vg.basis.y), points[1])\n    np.testing.assert_array_equal(vg.argapex(points, along=vg.basis.neg_y), 3)\n    np.testing.assert_array_equal(vg.apex(points, along=vg.basis.neg_y), points[3])\n    np.testing.assert_array_equal(vg.argapex(points, along=vg.basis.z), 3)\n    np.testing.assert_array_equal(vg.apex(points, along=vg.basis.z), points[3])\n    np.testing.assert_array_equal(vg.argapex(points, along=vg.basis.neg_z), 9)\n    np.testing.assert_array_equal(vg.apex(points, along=vg.basis.neg_z), points[9])\n\n    v = np.full(3, 1 / 3 ** 0.5)\n    expected = points[np.argmax(points.sum(axis=1))]\n    np.testing.assert_array_equal(vg.apex(points, along=v), expected)\n\n    # Test non-normalized too.\n    np.testing.assert_array_equal(vg.apex(points, along=np.array([1, 1, 1])), expected)\n\n    with pytest.raises(ValueError, match=r""At least one point is required""):\n        vg.apex(np.zeros((0, 3)), vg.basis.z)\n\n\ndef test_apex_returns_a_copy():\n    points = np.array(\n        [\n            [-0.97418884, -0.79808404, -0.18545491],\n            [0.60675227, 0.32673201, -0.20369793],\n            [0.67040405, 0.19267665, -0.56983579],\n            [-0.68038753, -0.90011588, 0.4649872],\n            [-0.62813991, -0.23947753, 0.07933854],\n            [0.26348356, 0.23701114, -0.38230596],\n            [0.08302473, 0.2784907, 0.09308946],\n            [0.58695587, -0.33253376, -0.33493078],\n            [-0.39221704, -0.45240036, 0.25284163],\n            [0.46270635, -0.3865265, -0.98106526],\n        ]\n    )\n    result = vg.apex(points, along=vg.basis.x)\n    result[1] = 5.0\n    np.testing.assert_array_equal(points[2], [0.67040405, 0.19267665, -0.56983579])\n'"
vg/test_average.py,9,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_average():\n    np.testing.assert_array_equal(\n        vg.average(np.array([[1.0, 2.0, 3.0], [-6.0, -9.0, -15.0]])),\n        np.array([-2.5, -3.5, -6.0]),\n    )\n    np.testing.assert_array_equal(\n        vg.average(np.array([[1.0, 2.0, 3.0], [-6.0, -9.0, -15.0]]), weights=(3, 5)),\n        np.array([-3.375, -4.875, -8.25]),\n    )\n    result, sum_of_weights = vg.average(\n        np.array([[1.0, 2.0, 3.0], [-6.0, -9.0, -15.0]]),\n        weights=(3, 5),\n        ret_sum_of_weights=True,\n    )\n    np.testing.assert_array_equal(\n        result, np.array([-3.375, -4.875, -8.25]),\n    )\n    assert sum_of_weights == 8.0\n'"
vg/test_basis.py,8,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_constants():\n    np.testing.assert_array_equal(vg.basis.x, np.array([1.0, 0.0, 0.0]))\n    np.testing.assert_array_equal(vg.basis.y, np.array([0.0, 1.0, 0.0]))\n    np.testing.assert_array_equal(vg.basis.z, np.array([0.0, 0.0, 1.0]))\n    np.testing.assert_array_equal(vg.basis.neg_x, np.array([-1.0, 0.0, 0.0]))\n    np.testing.assert_array_equal(vg.basis.neg_y, np.array([0.0, -1.0, 0.0]))\n    np.testing.assert_array_equal(vg.basis.neg_z, np.array([0.0, 0.0, -1.0]))\n\n\ndef test_that_constants_are_copies():\n    x1 = vg.basis.x\n    x1[1] = 5.0\n\n    x2 = vg.basis.y\n    x2[0] = 3.0\n\n    np.testing.assert_array_equal(x1, [1.0, 5.0, 0.0])\n    np.testing.assert_array_equal(x2, [3.0, 1.0, 0.0])\n'"
vg/test_cross.py,19,"b'import numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_cross():\n    v1 = np.array([1.0, 2.0, 3.0])\n    v2 = np.array([4.0, 5.0, 6.0])\n\n    expected = np.array([-3.0, 6.0, -3.0])\n\n    np.testing.assert_array_almost_equal(vg.cross(v1, v2), expected)\n    np.testing.assert_array_almost_equal(vg.cross(v2, v1), -expected)\n\n\ndef test_cross_stacked():\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([[2.0, 2.0, 2.0], [4.0, 5.0, 6.0]])\n\n    expected = np.array([[2.0, -4.0, 2.0], [-3.0, 6.0, -3.0]])\n\n    np.testing.assert_array_almost_equal(vg.cross(v1, v2), expected)\n    np.testing.assert_array_almost_equal(vg.cross(v2, v1), -expected)\n\n\ndef test_cross_mixed():\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([4.0, 5.0, 6.0])\n\n    expected = np.array([[5.0, -10.0, 5.0], [-3.0, 6.0, -3.0]])\n    np.testing.assert_array_almost_equal(vg.cross(v1, v2), expected)\n    np.testing.assert_array_almost_equal(vg.cross(v2, v1), -expected)\n\n\ndef test_cross_error():\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([[4.0, 5.0, 6.0]])\n\n    with pytest.raises(\n        ValueError, match=""v2 must be an array with shape \\\\(2, 3\\\\); got \\\\(1, 3\\\\)""\n    ):\n        vg.cross(v1, v2)\n\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([[[4.0, 5.0, 6.0]]])\n\n    with pytest.raises(\n        ValueError, match=""Not sure what to do with 2 dimensions and 3 dimensions""\n    ):\n        vg.cross(v1, v2)\n'"
vg/test_dot.py,18,"b'import numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_dot():\n    v1 = np.array([1.0, 2.0, 3.0])\n    v2 = np.array([4.0, 5.0, 6.0])\n\n    expected = 32.0\n\n    np.testing.assert_array_almost_equal(vg.dot(v1, v2), expected)\n    np.testing.assert_array_almost_equal(vg.dot(v2, v1), expected)\n\n\ndef test_dot_stacked():\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([[2.0, 2.0, 2.0], [4.0, 5.0, 6.0]])\n\n    expected = np.array([0.0, 32.0])\n\n    np.testing.assert_array_almost_equal(vg.dot(v1, v2), expected)\n    np.testing.assert_array_almost_equal(vg.dot(v2, v1), expected)\n\n\ndef test_dot_mixed():\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([4.0, 5.0, 6.0])\n\n    expected = np.array([-2.0, 32.0])\n    np.testing.assert_array_almost_equal(vg.dot(v1, v2), expected)\n    np.testing.assert_array_almost_equal(vg.dot(v2, v1), expected)\n\n\ndef test_dot_error():\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([[4.0, 5.0, 6.0]])\n\n    with pytest.raises(\n        ValueError, match=""v2 must be an array with shape \\\\(2, 3\\\\); got \\\\(1, 3\\\\)""\n    ):\n        vg.dot(v1, v2)\n\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([[[4.0, 5.0, 6.0]]])\n\n    with pytest.raises(\n        ValueError, match=""Not sure what to do with 2 dimensions and 3 dimensions""\n    ):\n        vg.dot(v1, v2)\n'"
vg/test_euclidean_distance.py,12,"b'import math\nimport numpy as np\nfrom . import core as vg\n\n\ndef test_euclidean_distance():\n    v1 = np.array([1, 1, 0])\n    v2 = np.array([2, -1, 5])\n    expected = math.sqrt(1 ** 2 + 2 ** 2 + 5 ** 2)\n    result = vg.euclidean_distance(v1, v2)\n    np.testing.assert_almost_equal(result, expected)\n    assert isinstance(result, float)\n\n\ndef test_euclidean_distance_stacked():\n    v1s = np.array([[1, 1, 0], [-1, 0, 0], [0, 0, 5]])\n    v2s = np.array([[2, -1, 5], [3, 4, 0], [-1, 0, 6]])\n    expected = np.array(\n        [\n            math.sqrt(1 ** 2 + 2 ** 2 + 5 ** 2),\n            math.sqrt(4 ** 2 + 4 ** 2),\n            math.sqrt(1 ** 2 + 1 ** 2),\n        ]\n    )\n    np.testing.assert_array_almost_equal(vg.euclidean_distance(v1s, v2s), expected)\n\n\ndef test_euclidean_distance_mixed():\n    v1s = np.array([[1, 1, 0], [-1, 0, 0], [0, 0, 5]])\n    v2 = np.array([2, -1, 5])\n    expected = np.array(\n        [\n            math.sqrt(1 ** 2 + 2 ** 2 + 5 ** 2),\n            math.sqrt(3 ** 2 + 1 ** 2 + 5 ** 2),\n            math.sqrt(2 ** 2 + 1 ** 2),\n        ]\n    )\n    np.testing.assert_array_almost_equal(vg.euclidean_distance(v1s, v2), expected)\n    np.testing.assert_array_almost_equal(vg.euclidean_distance(v2, v1s), expected)\n'"
vg/test_farthest.py,5,"b'import numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_farthest():\n    to_point = np.array([-1.0, 0.0, 0.0])\n\n    from_points = np.array([[1.0, -2.0, -3.0], [-1.0, -20.0, -30.0]])\n\n    point, index = vg.farthest(from_points, to_point, ret_index=True)\n\n    np.testing.assert_array_equal(point, from_points[1])\n    np.testing.assert_array_equal(index, 1)\n\n    np.testing.assert_array_equal(\n        vg.farthest(from_points, to_point, ret_index=False), from_points[1]\n    )\n\n    with pytest.raises(ValueError, match=r""Invalid shape \\(3,\\): farthest expects nx3""):\n        vg.farthest(to_point, to_point)\n\n    with pytest.raises(ValueError, match=r""to_point should be \\(3,\\)""):\n        vg.farthest(from_points, from_points)\n'"
vg/test_internal.py,8,"b'import numpy as np\nimport pytest\nfrom ._helpers import _check_value_any\nfrom .core import raise_dimension_error\n\n\ndef test_raise_dimension_error():\n    with pytest.raises(ValueError, match=""Not sure what to do with those inputs""):\n        raise_dimension_error(np.array([]), np.array([]), np.array([]))\n\n\ndef test_check_value_any_valid():\n    assert _check_value_any(np.zeros((3,)), (3,), (-1, 3), name=""points"") is None\n    assert _check_value_any(np.zeros((12, 3)), (3,), (-1, 3), name=""points"") == 12\n    assert _check_value_any(np.zeros((0, 3)), (3,), (-1, 3), name=""points"") == 0\n    assert _check_value_any(\n        np.zeros((5, 3, 3)), (-1, 3), (-1, -1, 3), name=""points""\n    ) == (5, 3)\n\n\ndef test_check_value_any_errors():\n    with pytest.raises(ValueError, match=""At least one shape is required""):\n        _check_value_any(np.zeros(9).reshape(-3, 3))\n\n\ndef test_check_value_any_message():\n    with pytest.raises(\n        ValueError,\n        match=r""^Expected an array with shape \\(-1, 2\\) or \\(2,\\); got \\(3, 3\\)$"",\n    ):\n        _check_value_any(np.zeros(9).reshape(-3, 3), (-1, 2), (2,))\n\n    with pytest.raises(\n        ValueError,\n        match=r""^Expected coords to be an array with shape \\(-1, 2\\) or \\(2,\\); got \\(3, 3\\)$"",\n    ):\n        _check_value_any(np.zeros(9).reshape(-3, 3), (-1, 2), (2,), name=""coords"")\n\n    with pytest.raises(\n        ValueError,\n        match=r""^Expected coords to be an array with shape \\(-1, 2\\) or \\(2,\\); got None$"",\n    ):\n        _check_value_any(None, (-1, 2), (2,), name=""coords"")\n'"
vg/test_magnitude.py,6,"b'import math\nimport numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_magnitude():\n    v = np.array([1, 1, 0])\n    expected = math.sqrt(2)\n    np.testing.assert_almost_equal(vg.magnitude(v), expected)\n    assert isinstance(vg.magnitude(v), float)\n\n\ndef test_magnitude_stacked():\n    vs = np.array([[1, 1, 0], [-1, 0, 0], [0, 0, 5]])\n    expected = np.array([math.sqrt(2), 1, 5])\n    np.testing.assert_array_almost_equal(vg.magnitude(vs), expected)\n\n\ndef test_error():\n    with pytest.raises(ValueError, match=""Not sure what to do with 3 dimensions""):\n        vg.magnitude(np.array([[[1, 1, 0]]]))\n'"
vg/test_matrix_pad_with_ones.py,5,"b'import numpy as np\nimport pytest\nfrom .matrix import pad_with_ones\n\n\ndef test_pad_with_ones():\n    np.testing.assert_array_equal(\n        pad_with_ones(np.array([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [5.0, 6.0, 7.0]])),\n        np.array([[1.0, 2.0, 3.0, 1.0], [2.0, 3.0, 4.0, 1.0], [5.0, 6.0, 7.0, 1.0]]),\n    )\n\n\ndef test_pad_with_wrong_dimensions():\n    # NB: on windows, the sizes here will render as 3L, not 3:\n    with pytest.raises(\n        ValueError, match=r""^Invalid shape \\(3L?, 4L?\\): pad expects nx3$""\n    ):\n        pad_with_ones(\n            np.array(\n                [[1.0, 2.0, 3.0, 42.0], [2.0, 3.0, 4.0, 42.0], [5.0, 6.0, 7.0, 42.0]]\n            )\n        )\n\n    with pytest.raises(ValueError, match=r""^Invalid shape \\(3L?,\\): pad expects nx3$""):\n        pad_with_ones(np.array([1.0, 2.0, 3.0]))\n'"
vg/test_matrix_transform.py,11,"b'import numpy as np\nimport pytest\nfrom .matrix import transform as apply_transform\n\nscale_factor = np.array([3.0, 0.5, 2.0])\ntransform = np.array(\n    [\n        [scale_factor[0], 0, 0, 0],\n        [0, scale_factor[1], 0, 0],\n        [0, 0, scale_factor[2], 0],\n        [0, 0, 0, 1],\n    ]\n)\n\n\ndef test_apply_homogeneous():\n    point = np.array([5.0, 0.0, 1.0])\n    expected_point = np.array([15.0, 0.0, 2.0])\n    np.testing.assert_array_equal(apply_transform(point, transform), expected_point)\n\n\ndef test_apply_homogeneous_stacked():\n    points = np.array([[1.0, 2.0, 3.0], [5.0, 0.0, 1.0]])\n    expected_points = np.array([[3.0, 1.0, 6.0], [15.0, 0.0, 2.0]])\n    np.testing.assert_array_equal(apply_transform(points, transform), expected_points)\n\n\ndef test_apply_homogeneous_error():\n    with pytest.raises(ValueError, match=""Transformation matrix should be 4x4""):\n        apply_transform(np.array([1.0, 2.0, 3.0]), np.array([1.0]))\n    with pytest.raises(ValueError, match=r""Vertices should be \\(3,\\) or Nx3""):\n        apply_transform(np.array([1.0, 2.0]), transform)\n    with pytest.raises(ValueError, match=""Not sure what to do with 3 dimensions""):\n        apply_transform(np.array([[[1.0, 2.0, 3.0]]]), transform)\n'"
vg/test_matrix_unpad.py,6,"b'import numpy as np\nimport pytest\nfrom .matrix import unpad\n\n\ndef test_unpad():\n    np.testing.assert_array_equal(\n        unpad(\n            np.array([[1.0, 2.0, 3.0, 1.0], [2.0, 3.0, 4.0, 1.0], [5.0, 6.0, 7.0, 1.0]])\n        ),\n        np.array([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [5.0, 6.0, 7.0]]),\n    )\n\n    # NB: on windows, the sizes here will render as 3L, not 3:\n    with pytest.raises(\n        ValueError, match=r""^Invalid shape \\(3L?, 3L?\\): unpad expects nx4$""\n    ):\n        unpad(np.array([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [5.0, 6.0, 7.0]]))\n\n    with pytest.raises(\n        ValueError, match=r""^Invalid shape \\(4L?,\\): unpad expects nx4$""\n    ):\n        unpad(np.array([1.0, 2.0, 3.0, 4.0]))\n\n    with pytest.raises(ValueError, match=""Expected a column of ones""):\n        unpad(\n            np.array([[1.0, 2.0, 3.0, 1.0], [2.0, 3.0, 4.0, 1.0], [5.0, 6.0, 7.0, 3.0]])\n        )\n'"
vg/test_nearest.py,5,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_nearest():\n    to_point = np.array([-1.0, 0.0, 0.0])\n\n    from_points = np.array([[1.0, -2.0, -3.0], [-1.0, -20.0, -30.0]])\n\n    point, index = vg.nearest(from_points, to_point, ret_index=True)\n\n    np.testing.assert_array_equal(point, from_points[0])\n    np.testing.assert_array_equal(index, 0)\n\n    np.testing.assert_array_equal(\n        vg.nearest(from_points, to_point, ret_index=False), from_points[0]\n    )\n'"
vg/test_normalize.py,7,"b'import math\nimport numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_normalize():\n    v = np.array([1, 1, 0])\n    expected = np.array([math.sqrt(2) / 2.0, math.sqrt(2) / 2.0, 0])\n    np.testing.assert_array_almost_equal(vg.normalize(v), expected)\n\n\ndef test_normalize_stacked():\n    vs = np.array([[1, 1, 0], [-1, 0, 0], [0, 0, 5]])\n    expected = np.array(\n        [[math.sqrt(2) / 2.0, math.sqrt(2) / 2.0, 0], [-1, 0, 0], [0, 0, 1]]\n    )\n    np.testing.assert_array_almost_equal(vg.normalize(vs), expected)\n\n\ndef test_normalized_wrong_dim():\n    with pytest.raises(ValueError, match=""Not sure what to do with 3 dimensions""):\n        vg.normalize(np.array([[[1, 1, 0], [0, 1, 0]], [[0, 0, 0], [0, 1, 0]]]))\n'"
vg/test_orient.py,6,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_orient():\n    v1 = np.array([1.0, 2.0, 3.0])\n    neg_v1 = np.array([-1.0, -2.0, -3.0])\n\n    np.testing.assert_array_equal(vg.orient(v1, along=vg.basis.z), v1)\n    np.testing.assert_array_equal(vg.orient(neg_v1, along=vg.basis.z), v1)\n\n    np.testing.assert_array_equal(vg.orient(v1, along=vg.basis.z, reverse=True), neg_v1)\n    np.testing.assert_array_equal(\n        vg.orient(neg_v1, along=vg.basis.z, reverse=True), neg_v1\n    )\n'"
vg/test_pca.py,3,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_principal_components():\n    # Example from http://www.iro.umontreal.ca/~pift6080/H09/documents/papers/pca_tutorial.pdf\n    coords = np.array(\n        [\n            [2.5, 2.4],\n            [0.5, 0.7],\n            [2.2, 2.9],\n            [1.9, 2.2],\n            [3.1, 3.0],\n            [2.3, 2.7],\n            [2, 1.6],\n            [1, 1.1],\n            [1.5, 1.6],\n            [1.1, 0.9],\n        ]\n    )\n\n    pcs = vg.principal_components(coords)\n\n    assert pcs.shape == (2, 2)\n    np.testing.assert_array_almost_equal(pcs[0], np.array([-0.677873, -0.735179]))\n\n    first_pc = vg.major_axis(coords)\n\n    np.testing.assert_array_almost_equal(first_pc, np.array([-0.677873, -0.735179]))\n'"
vg/test_perpendicular.py,22,"b'import math\nimport numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_perpendicular():\n    v1 = np.array([1.0, 2.0, 3.0])\n    v2 = np.array([4.0, 5.0, 6.0])\n\n    expected = np.array([-3.0, 6.0, -3.0])\n    expected_magnitude = math.sqrt(9.0 + 36.0 + 9.0)\n\n    np.testing.assert_array_almost_equal(\n        vg.perpendicular(v1, v2, normalized=False), expected\n    )\n\n    np.testing.assert_array_almost_equal(\n        vg.perpendicular(v1, v2, normalized=True), expected / expected_magnitude\n    )\n\n\ndef test_perpendicular_stacked():\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([[2.0, 2.0, 2.0], [4.0, 5.0, 6.0]])\n\n    expected = np.array([[2.0, -4.0, 2.0], [-3.0, 6.0, -3.0]])\n    expected_magnitude = np.array(\n        [math.sqrt(4.0 + 16.0 + 4.0), math.sqrt(9.0 + 36.0 + 9.0)]\n    )\n\n    np.testing.assert_array_almost_equal(\n        vg.perpendicular(v1, v2, normalized=False), expected\n    )\n\n    np.testing.assert_array_almost_equal(\n        vg.perpendicular(v1, v2, normalized=True),\n        expected / expected_magnitude[:, np.newaxis],\n    )\n\n\ndef test_perpendicular_mixed():\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([4.0, 5.0, 6.0])\n\n    expected = np.array([[5.0, -10.0, 5.0], [-3.0, 6.0, -3.0]])\n    expected_magnitude = np.array(\n        [math.sqrt(25.0 + 100.0 + 25.0), math.sqrt(9.0 + 36.0 + 9.0)]\n    )\n    np.testing.assert_array_almost_equal(\n        vg.perpendicular(v1, v2, normalized=False), expected\n    )\n    np.testing.assert_array_almost_equal(\n        vg.perpendicular(v1, v2, normalized=True),\n        expected / expected_magnitude.reshape(-1, 1),\n    )\n\n\ndef test_perpendicular_error():\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([[4.0, 5.0, 6.0]])\n\n    with pytest.raises(\n        ValueError, match=""v2 must be an array with shape \\\\(2, 3\\\\); got \\\\(1, 3\\\\)""\n    ):\n        vg.perpendicular(v1, v2, normalized=False)\n\n    v1 = np.array([[1.0, 0.0, -1.0], [1.0, 2.0, 3.0]])\n    v2 = np.array([[[4.0, 5.0, 6.0]]])\n\n    with pytest.raises(\n        ValueError, match=""Not sure what to do with 2 dimensions and 3 dimensions""\n    ):\n        vg.perpendicular(v1, v2, normalized=False)\n'"
vg/test_project.py,19,"b'import numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_project():\n    v = np.array([5.0, -3.0, 1.0])\n    onto = np.array([0, -1.0, 0])\n    expected_s = 3.0\n    expected_v = np.array([0, -3.0, 0])\n    np.testing.assert_array_almost_equal(vg.scalar_projection(v, onto=onto), expected_s)\n    np.testing.assert_array_almost_equal(vg.project(v, onto=onto), expected_v)\n\n    with pytest.raises(\n        ValueError, match=r""onto must be an array with shape \\(3,\\); got \\(2, 3\\)""\n    ):\n        vg.project(v, onto=np.array([vg.basis.x, vg.basis.x]))\n\n\ndef test_project_stacked_vs():\n    vs = np.array([[5.0, -3.0, 1.0], [1.0, 0, 1.0], [0.0, 1, 0.0], [0.0, 0, 0.0]])\n    onto = np.array([0, -1.0, 0])\n    expected_s = np.array([3.0, 0.0, -1.0, 0])\n    expected_v = np.array(\n        [[0.0, -3.0, 0.0], [0.0, 0, 0.0], [0.0, 1.0, 0.0], [0.0, 0, 0.0]]\n    )\n    np.testing.assert_array_almost_equal(\n        vg.scalar_projection(vs, onto=onto), expected_s\n    )\n    np.testing.assert_array_almost_equal(vg.project(vs, onto=onto), expected_v)\n\n\ndef test_project_stacked_both():\n    vs = np.array([[5.0, -3.0, 1.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.5], [0.0, 0, 0.0]])\n    onto = np.array(\n        [[0.0, -1.0, 0], [0.0, 0.0, 1.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]\n    )\n    expected_s = np.array([3.0, 1.0, -1.5, 0])\n    expected_v = np.array(\n        [[0.0, -3.0, 0.0], [0.0, 0, 1.0], [0.0, 0.0, 1.5], [0.0, 0, 0.0]]\n    )\n    np.testing.assert_array_almost_equal(\n        vg.scalar_projection(vs, onto=onto), expected_s\n    )\n    np.testing.assert_array_almost_equal(vg.project(vs, onto=onto), expected_v)\n\n\ndef test_project_error():\n    with pytest.raises(ValueError, match=""Not sure what to do with 3 dimensions""):\n        vg.project(np.array([[[5.0, -3.0, 1.0]]]), onto=np.array([0, -1.0, 0]))\n'"
vg/test_reject.py,8,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_reject():\n    v = np.array([2.0, 4.0, 0.0])\n    from_v = np.array([0.0, 5.0, 0.0])\n    expected = np.array([2.0, 0.0, 0.0])\n    np.testing.assert_array_almost_equal(vg.reject(v, from_v=from_v), expected)\n\n\ndef test_reject_stacked():\n    vs = np.array([[2.0, 4.0, 0.0], [-2.0, -1.0, 0.0]])\n    from_v = np.array([0.0, 5.0, 0.0])\n    expected = np.array([[2.0, 0.0, 0.0], [-2.0, 0.0, 0.0]])\n    np.testing.assert_array_almost_equal(vg.reject(vs, from_v=from_v), expected)\n'"
vg/test_reject_axis.py,16,"b'import numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_reject_axis():\n    v = np.array([2.0, 4.0, 0.0])\n    expected = np.array([2.0, 0.0, 0.0])\n    np.testing.assert_array_almost_equal(vg.reject_axis(v, axis=1), expected)\n\n\ndef test_reject_axis_stacked():\n    vs = np.array([[2.0, 4.0, 0.0], [-2.0, -1.0, 0.0]])\n    expected = np.array([[2.0, 0.0, 0.0], [-2.0, 0.0, 0.0]])\n    np.testing.assert_array_almost_equal(vg.reject_axis(vs, axis=1), expected)\n\n\ndef test_reject_axis_with_squash():\n    v = np.array([2.0, 4.0, 0.0])\n    expected = np.array([2.0, 0.0])\n    np.testing.assert_array_almost_equal(\n        vg.reject_axis(v, axis=1, squash=True), expected\n    )\n\n\ndef test_reject_axis_stacked_with_squash():\n    vs = np.array([[2.0, 4.0, 0.0], [-2.0, -1.0, 0.0]])\n    expected = np.array([[2.0, 0.0], [-2.0, 0.0]])\n    np.testing.assert_array_almost_equal(\n        vg.reject_axis(vs, axis=1, squash=True), expected\n    )\n\n\ndef test_reject_axis_error():\n    with pytest.raises(ValueError, match=""axis should be 0, 1, or 2""):\n        vg.reject_axis(np.array([2.0, 4.0, 0.0]), axis=5)\n    with pytest.raises(ValueError, match=""Not sure what to do with 3 dimensions""):\n        vg.reject_axis(np.array([[[2.0, 4.0, 0.0]]]), axis=1)\n    with pytest.raises(ValueError, match=""axis should be 0, 1, or 2""):\n        vg.reject_axis(np.array([2.0, 4.0, 0.0]), axis=5, squash=True)\n    with pytest.raises(ValueError, match=""Not sure what to do with 3 dimensions""):\n        vg.reject_axis(np.array([[[2.0, 4.0, 0.0]]]), axis=1, squash=True)\n'"
vg/test_rotate.py,13,"b'import math\nimport numpy as np\nimport pytest\nfrom . import core as vg\n\n\naround_axis = np.array([0.0, 2.0, -1.0])\n\n\ndef test_rotate():\n    # Example verified using\n    # http://www.nh.cas.cz/people/lazar/celler/online_tools.php?start_vec=1,1,1&rot_ax=0,2,-1&rot_ang=180\n    v = np.array([1.0, 1.0, 1.0])\n\n    np.testing.assert_array_almost_equal(\n        vg.rotate(v, around_axis=around_axis, angle=90),\n        np.array([1.341641, -0.047214, -1.094427]),\n    )\n\n    np.testing.assert_array_almost_equal(\n        vg.rotate(v, around_axis=around_axis, angle=180), np.array([-1, -0.2, -1.4])\n    )\n\n    np.testing.assert_array_almost_equal(\n        vg.rotate(v, around_axis=around_axis, angle=math.pi, units=""rad""),\n        np.array([-1, -0.2, -1.4]),\n    )\n\n\ndef test_rotate_stacked():\n    vs = np.array([[3.0, -1.0, 5.0], [1.0, 1.0, 1.0]])\n    np.testing.assert_array_almost_equal(\n        vg.rotate(vs, around_axis=around_axis, angle=90),\n        np.array([[4.024922, -4.141641, -1.283282], [1.341641, -0.047214, -1.094427]]),\n    )\n\n\ndef test_rotate_error():\n    with pytest.raises(ValueError, match=""Not sure what to do with 3 dimensions""):\n        vg.rotate(np.array([[[5.0, -3.0, 1.0]]]), around_axis=around_axis, angle=90),\n    with pytest.raises(ValueError, match=\'Unknown units ""in""; expected ""deg"" or ""rad""\'):\n        vg.rotate(\n            np.array([1.0, 1.0, 1.0]), around_axis=around_axis, angle=90, units=""in""\n        )\n'"
vg/test_scale_factor.py,30,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_scale_factor():\n    v = np.array([1.0, 2.0, 3.0])\n    neg_v = np.array([-1.0, -2.0, -3.0])\n    thrice_v = np.array([3.0, 6.0, 9.0])\n\n    np.testing.assert_almost_equal(vg.scale_factor(v, v), 1.0)\n    np.testing.assert_almost_equal(vg.scale_factor(v, neg_v), -1.0)\n    np.testing.assert_almost_equal(vg.scale_factor(v, thrice_v), 3.0)\n    np.testing.assert_almost_equal(vg.scale_factor(v, np.zeros(3)), 0.0)\n    np.testing.assert_almost_equal(vg.scale_factor(np.zeros(3), v), np.nan)\n\n\ndef test_scale_factor_vectorized_both():\n    v = np.array([1.0, 2.0, 3.0])\n    neg_v = np.array([-1.0, -2.0, -3.0])\n    thrice_v = np.array([3.0, 6.0, 9.0])\n    zero = np.zeros(3)\n\n    v1s = np.array([neg_v, thrice_v, neg_v, v, zero])\n    v2s = np.array([neg_v, v, thrice_v, thrice_v, v])\n\n    np.testing.assert_array_equal(\n        vg.scale_factor(v1s, v2s), np.array([1.0, 1.0 / 3.0, -3.0, 3.0, np.nan])\n    )\n\n\ndef test_scale_factor_vectorized_first():\n    v = np.array([1.0, 2.0, 3.0])\n    neg_v = np.array([-1.0, -2.0, -3.0])\n    thrice_v = np.array([3.0, 6.0, 9.0])\n    zero = np.zeros(3)\n\n    v1s = np.array([neg_v, thrice_v, neg_v, v, zero])\n\n    np.testing.assert_array_equal(\n        vg.scale_factor(v1s, v), np.array([-1.0, 1.0 / 3.0, -1.0, 1.0, np.nan])\n    )\n\n\ndef test_scale_factor_vectorized_second():\n    v = np.array([1.0, 2.0, 3.0])\n    neg_v = np.array([-1.0, -2.0, -3.0])\n    thrice_v = np.array([3.0, 6.0, 9.0])\n    zero = np.zeros(3)\n\n    v2s = np.array([neg_v, v, thrice_v, thrice_v, zero])\n\n    np.testing.assert_array_equal(\n        vg.scale_factor(v, v2s), np.array([-1.0, 1.0, 3.0, 3.0, 0.0])\n    )\n'"
vg/test_shape.py,37,"b'import numpy as np\nimport pytest\nfrom .shape import check, check_value, check_value_any, columnize\n\n\ndef test_check_value_valid():\n    check_value(np.zeros(3), (3,))\n\n\ndef test_check_value_valid_scalar():\n    check_value(np.int64(3), ())\n\n\ndef test_check_value_valid_wildcard():\n    assert check_value(np.zeros((5, 3)), (-1, 3)) == 5\n    assert check_value(np.zeros((5, 3)), (5, -1)) == 3\n    assert check_value(np.zeros((5, 3, 2)), (-1, 3, -1)) == (5, 2)\n\n\ndef test_check_value_wrong_shape():\n    with pytest.raises(ValueError) as e:\n        check_value(np.zeros(4), (3,))\n    assert ""Expected an array with shape (3,); got (4,)"" in str(e.value)\n\n\ndef test_check_value_wrong_shape_wildcard():\n    with pytest.raises(ValueError) as e:\n        check_value(np.zeros((5, 4)), (-1, 3))\n    assert ""Expected an array with shape (-1, 3); got (5, 4)"" in str(e.value)\n\n\ndef test_check_value_none():\n    with pytest.raises(ValueError) as e:\n        check_value(None, (3,))\n    assert ""Expected an array with shape (3,); got None"" in str(e.value)\n\n\ndef test_check_value_wrong_type():\n    with pytest.raises(ValueError) as e:\n        check_value({}, (3,))\n    assert ""Expected an array with shape (3,); got dict"" in str(e.value)\n\n    class Value:\n        def __init__(self):\n            self.shape = None\n\n    with pytest.raises(ValueError) as e:\n        check_value(Value(), (3,))\n    assert ""Expected an array with shape (3,); got Value"" in str(e.value)\n\n\ndef test_check_value_valid_named():\n    check_value(np.zeros(3), (3,), name=""input_value"")\n\n\ndef test_check_value_valid_wildcard_named():\n    assert check_value(np.zeros((5, 3)), (-1, 3), name=""input_value"") == 5\n    assert check_value(np.zeros((5, 3)), (5, -1), name=""input_value"") == 3\n\n\ndef test_check_value_wrong_shape_named():\n    with pytest.raises(ValueError) as e:\n        check_value(np.zeros(4), (3,), name=""input_value"")\n    assert ""input_value must be an array with shape (3,); got (4,)"" in str(e.value)\n\n\ndef test_check_value_wrong_shape_wildcard_named():\n    with pytest.raises(ValueError) as e:\n        check_value(np.zeros((5, 4)), (-1, 3), name=""input_value"")\n    assert ""input_value must be an array with shape (-1, 3); got (5, 4)"" in str(e.value)\n\n\ndef test_check_value_none_named():\n    with pytest.raises(ValueError) as e:\n        check_value(None, (3,), name=""input_value"")\n    assert ""input_value must be an array with shape (3,); got None"" in str(e.value)\n\n\ndef test_check_value_with_invalid_shape_raises_expected_error():\n    with pytest.raises(ValueError) as e:\n        check_value(np.zeros(3), (3.0,))\n    assert ""Expected shape dimensions to be int"" in str(e.value)\n\n\ndef test_check_value_any_valid():\n    assert check_value_any(np.zeros((3,)), (3,), (-1, 3), name=""points"") is None\n    assert check_value_any(np.zeros((12, 3)), (3,), (-1, 3), name=""points"") == 12\n    assert check_value_any(np.zeros((0, 3)), (3,), (-1, 3), name=""points"") == 0\n    assert check_value_any(\n        np.zeros((5, 3, 3)), (-1, 3), (-1, -1, 3), name=""points""\n    ) == (5, 3)\n\n\ndef test_check_value_any_errors():\n    with pytest.raises(ValueError, match=""At least one shape is required""):\n        check_value_any(np.zeros(9).reshape(-3, 3))\n    with pytest.raises(\n        ValueError, match=r""Expected an array with shape \\(3,\\) or \\(-1, 3\\); got list""\n    ):\n        check_value_any([1, 2, 3], (3,), (-1, 3))\n    with pytest.raises(\n        ValueError, match=r""Expected an array with shape \\(3,\\); got list""\n    ):\n        check_value_any([1, 2, 3], (3,))\n\n\ndef test_check_value_any_message():\n    with pytest.raises(\n        ValueError,\n        match=r""^Expected an array with shape \\(-1, 2\\) or \\(2,\\); got \\(3, 3\\)$"",\n    ):\n        check_value_any(np.zeros(9).reshape(-3, 3), (-1, 2), (2,))\n\n    with pytest.raises(\n        ValueError,\n        match=r""^Expected coords to be an array with shape \\(-1, 2\\) or \\(2,\\); got \\(3, 3\\)$"",\n    ):\n        check_value_any(np.zeros(9).reshape(-3, 3), (-1, 2), (2,), name=""coords"")\n\n    with pytest.raises(\n        ValueError,\n        match=r""^Expected coords to be an array with shape \\(-1, 2\\) or \\(2,\\); got None$"",\n    ):\n        check_value_any(None, (-1, 2), (2,), name=""coords"")\n\n\ndef test_check():\n    input_value = np.zeros(3)\n    check(locals(), ""input_value"", (3,))\n\n\ndef test_check_valid_wildcard():\n    input_value = np.zeros((5, 3))\n    assert check(locals(), ""input_value"", (-1, 3)) == 5\n    assert check(locals(), ""input_value"", (5, -1)) == 3\n    input_value = np.zeros((5, 3, 2))\n    assert check(locals(), ""input_value"", (-1, 3, -1)) == (5, 2)\n\n\ndef test_check_wrong_shape_named():\n    input_value = np.zeros(4)\n    with pytest.raises(ValueError) as e:\n        check(locals(), ""input_value"", (3,))\n    assert ""input_value must be an array with shape (3,); got (4,)"" in str(e.value)\n\n\ndef test_check_wrong_shape_wildcard_named():\n    input_value = np.zeros((5, 4))\n    with pytest.raises(ValueError) as e:\n        check(locals(), ""input_value"", (-1, 3))\n    assert ""input_value must be an array with shape (-1, 3); got (5, 4)"" in str(e.value)\n\n\ndef test_check_none_named():\n    input_value = None\n    with pytest.raises(ValueError) as e:\n        check(locals(), ""input_value"", (3,))\n    assert ""input_value must be an array with shape (3,); got None"" in str(e.value)\n\n\ndef test_columnize_with_2d_shape():\n    shape = (-1, 3)\n\n    columnized, is_columnized, transform_result = columnize(\n        np.array([1.0, 0.0, 0.0]), shape\n    )\n    np.testing.assert_array_equal(columnized, np.array([[1.0, 0.0, 0.0]]))\n    assert columnized.shape == (1, 3)\n    assert is_columnized is False\n    assert transform_result([1.0]) == 1.0\n\n    columnized, is_columnized, transform_result = columnize(\n        np.array([[1.0, 0.0, 0.0]]), shape\n    )\n    np.testing.assert_array_equal(columnized, np.array([[1.0, 0.0, 0.0]]))\n    assert columnized.shape == (1, 3)\n    assert is_columnized is True\n    assert transform_result([1.0]) == [1.0]\n\n\ndef test_columnize_with_3d_shape():\n    shape = (-1, 3, 3)\n\n    columnized, is_columnized, transform_result = columnize(\n        np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]), shape\n    )\n    np.testing.assert_array_equal(\n        columnized, np.array([[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]])\n    )\n    assert columnized.shape == (1, 3, 3)\n    assert is_columnized is False\n    assert transform_result([1.0]) == 1.0\n\n    columnized, is_columnized, transform_result = columnize(\n        np.array([[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]]), shape\n    )\n    np.testing.assert_array_equal(\n        columnized, np.array([[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]])\n    )\n    assert columnized.shape == (1, 3, 3)\n    assert is_columnized is True\n    assert transform_result([1.0]) == [1.0]\n\n\ndef test_columnize_invalid_shape():\n    with pytest.raises(ValueError, match=""shape should be a tuple""):\n        columnize(np.array([1.0, 0.0, 0.0]), ""this is not a shape"")\n    with pytest.raises(ValueError, match=""shape should have at least two dimension""):\n        columnize(np.array([1.0, 0.0, 0.0]), (3,))\n'"
vg/test_signed_angle.py,6,"b'import numpy as np\nfrom . import core as vg\n\n\ndef test_basic():\n    v1 = np.array([1, 1, 0])\n    v2 = np.array([-1, 1, 0])\n    look = vg.basis.z\n    assert vg.signed_angle(v1, v2, look) == 90\n    assert vg.signed_angle(v2, v1, look) == -90\n    assert isinstance(vg.signed_angle(v1, v2, look), float)\n\n\ndef test_stacked_basic():\n    v1 = np.array([[1, 1, 0], [1, 1, 0]])\n    v2 = np.array([[-1, 1, 0], [-1, -1, 0]])\n    look = vg.basis.z\n    np.testing.assert_array_almost_equal(\n        vg.signed_angle(v2, v1, look), np.array([-90, 180])\n    )\n'"
vg/test_within.py,16,"b'import numpy as np\nimport pytest\nfrom . import core as vg\n\n\ndef test_within():\n    points = np.array(\n        [\n            [1.0, 0.0, 0.0],\n            [2.0, 2.0, 0.0],\n            [0.0, 0.0, 3.0],\n            [4.0, 1.0, 0.0],\n            [4.0, 5.0, 4.0],\n            [0.0, 1.0, 3.9],\n            [0.0, 1.0, 4.05],\n            [0.0, 1.0, 4.099],\n            [0.0, 1.0, 4.1],\n        ]\n    )\n\n    is_within_4 = np.array([True, True, True, True, False, True, True, True, False])\n    points_within_4 = points[is_within_4]\n    (indices_within_4,) = is_within_4.nonzero()\n\n    np.testing.assert_array_almost_equal(\n        vg.within(points, radius=4.0, of_point=np.array([0.0, 1.0, 0.0]), atol=0.1),\n        points_within_4,\n    )\n    actual_points, actual_indices = vg.within(\n        points,\n        radius=4.0,\n        of_point=np.array([0.0, 1.0, 0.0]),\n        atol=0.1,\n        ret_indices=True,\n    )\n    assert isinstance(actual_indices, np.ndarray)\n    np.testing.assert_array_equal(actual_indices, indices_within_4)\n    np.testing.assert_array_almost_equal(actual_points, points_within_4)\n\n    np.testing.assert_array_almost_equal(\n        vg.within(points, radius=4.0, of_point=np.array([0.0, 1.0, 0.0]), atol=1e-4),\n        np.array(\n            [\n                [1.0, 0.0, 0.0],\n                [2.0, 2.0, 0.0],\n                [0.0, 0.0, 3.0],\n                [4.0, 1.0, 0.0],\n                [0.0, 1.0, 3.9],\n            ]\n        ),\n    )\n\n\ndef test_within_error():\n    with pytest.raises(ValueError, match=r""Invalid shape \\(3,\\): within expects nx3""):\n        vg.within(\n            np.array([2.0, 4.0, 0.0]), radius=4.0, of_point=np.array([0.0, 1.0, 0.0])\n        )\n    with pytest.raises(ValueError, match=r""Invalid shape \\(1, 2\\): within expects nx3""):\n        vg.within(\n            np.array([[2.0, 4.0]]), radius=4.0, of_point=np.array([0.0, 1.0, 0.0])\n        )\n    with pytest.raises(ValueError, match=""radius should be a float""):\n        vg.within(\n            np.array([[2.0, 4.0, 0.0]]),\n            radius=False,\n            of_point=np.array([0.0, 1.0, 0.0]),\n        )\n    with pytest.raises(ValueError, match=r""to_point should be \\(3,\\)""):\n        vg.within(\n            np.array([[2.0, 4.0, 0.0]]), radius=4.0, of_point=np.array([0.0, 1.0])\n        )\n'"
