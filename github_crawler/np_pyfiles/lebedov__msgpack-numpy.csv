file_path,api_count,code
msgpack_numpy.py,6,"b'#!/usr/bin/env python\n\n""""""\nSupport for serialization of numpy data types with msgpack.\n""""""\n\n# Copyright (c) 2013-2020, Lev E. Givon\n# All rights reserved.\n# Distributed under the terms of the BSD license:\n# http://www.opensource.org/licenses/bsd-license\n\nimport sys\nimport functools\n\nimport msgpack\nfrom msgpack import Packer as _Packer, Unpacker as _Unpacker, \\\n    unpack as _unpack, unpackb as _unpackb\nimport numpy as np\n\nif sys.version_info >= (3, 0):\n    if sys.platform == \'darwin\':\n        ndarray_to_bytes = lambda obj: obj.tobytes()\n    else:\n        ndarray_to_bytes = lambda obj: obj.data if obj.flags[\'C_CONTIGUOUS\'] else obj.tobytes()\n\n    num_to_bytes = lambda obj: obj.data\n\n    def tostr(x):\n        if isinstance(x, bytes):\n            return x.decode()\n        else:\n            return str(x)\nelse:\n    if sys.platform == \'darwin\':\n        ndarray_to_bytes = lambda obj: obj.tobytes()\n    else:\n        ndarray_to_bytes = lambda obj: memoryview(obj.data) if obj.flags[\'C_CONTIGUOUS\'] else obj.tobytes()\n\n    num_to_bytes = lambda obj: memoryview(obj.data)\n\n    def tostr(x):\n        return x\n\ndef encode(obj, chain=None):\n    """"""\n    Data encoder for serializing numpy data types.\n    """"""\n\n    if isinstance(obj, np.ndarray):\n        # If the dtype is structured, store the interface description;\n        # otherwise, store the corresponding array protocol type string:\n        if obj.dtype.kind == \'V\':\n            kind = b\'V\'\n            descr = obj.dtype.descr\n        else:\n            kind = b\'\'\n            descr = obj.dtype.str\n        return {b\'nd\': True,\n                b\'type\': descr,\n                b\'kind\': kind,\n                b\'shape\': obj.shape,\n                b\'data\': ndarray_to_bytes(obj)}\n    elif isinstance(obj, (np.bool_, np.number)):\n        return {b\'nd\': False,\n                b\'type\': obj.dtype.str,\n                b\'data\': num_to_bytes(obj)}\n    elif isinstance(obj, complex):\n        return {b\'complex\': True,\n                b\'data\': obj.__repr__()}\n    else:\n        return obj if chain is None else chain(obj)\n\ndef decode(obj, chain=None):\n    """"""\n    Decoder for deserializing numpy data types.\n    """"""\n\n    try:\n        if b\'nd\' in obj:\n            if obj[b\'nd\'] is True:\n\n                # Check if b\'kind\' is in obj to enable decoding of data\n                # serialized with older versions (#20):\n                if b\'kind\' in obj and obj[b\'kind\'] == b\'V\':\n                    descr = [tuple(tostr(t) if type(t) is bytes else t for t in d) \\\n                             for d in obj[b\'type\']]\n                else:\n                    descr = obj[b\'type\']\n                return np.frombuffer(obj[b\'data\'],\n                            dtype=np.dtype(descr)).reshape(obj[b\'shape\'])\n            else:\n                descr = obj[b\'type\']\n                return np.frombuffer(obj[b\'data\'],\n                            dtype=np.dtype(descr))[0]\n        elif b\'complex\' in obj:\n            return complex(tostr(obj[b\'data\']))\n        else:\n            return obj if chain is None else chain(obj)\n    except KeyError:\n        return obj if chain is None else chain(obj)\n\n# Maintain support for msgpack < 0.4.0:\nif msgpack.version < (0, 4, 0):\n    class Packer(_Packer):\n        def __init__(self, default=None,\n                     encoding=\'utf-8\',\n                     unicode_errors=\'strict\',\n                     use_single_float=False,\n                     autoreset=1):\n            default = functools.partial(encode, chain=default)\n            super(Packer, self).__init__(default=default,\n                                         encoding=encoding,\n                                         unicode_errors=unicode_errors,\n                                         use_single_float=use_single_float,\n                                         autoreset=autoreset)\n    class Unpacker(_Unpacker):\n        def __init__(self, file_like=None, read_size=0, use_list=None,\n                     object_hook=None,\n                     object_pairs_hook=None, list_hook=None, encoding=\'utf-8\',\n                     unicode_errors=\'strict\', max_buffer_size=0):\n            object_hook = functools.partial(decode, chain=object_hook)\n            super(Unpacker, self).__init__(file_like=file_like,\n                                           read_size=read_size,\n                                           use_list=use_list,\n                                           object_hook=object_hook,\n                                           object_pairs_hook=object_pairs_hook,\n                                           list_hook=list_hook,\n                                           encoding=encoding,\n                                           unicode_errors=unicode_errors,\n                                           max_buffer_size=max_buffer_size)\n\nelif msgpack.version < (1, 0, 0):\n    class Packer(_Packer):\n        def __init__(self, default=None,\n                     unicode_errors=\'strict\',\n                     use_single_float=False,\n                     autoreset=1,\n                     use_bin_type=True,\n                     strict_types=False):\n            default = functools.partial(encode, chain=default)\n            super(Packer, self).__init__(default=default,\n                                         unicode_errors=unicode_errors,\n                                         use_single_float=use_single_float,\n                                         autoreset=autoreset,\n                                         use_bin_type=use_bin_type,\n                                         strict_types=strict_types)\n\n    class Unpacker(_Unpacker):\n        def __init__(self, file_like=None, read_size=0, use_list=None,\n                     raw=False,\n                     object_hook=None,\n                     object_pairs_hook=None, list_hook=None,\n                     unicode_errors=\'strict\', max_buffer_size=0,\n                     ext_hook=msgpack.ExtType):\n            object_hook = functools.partial(decode, chain=object_hook)\n            super(Unpacker, self).__init__(file_like=file_like,\n                                           read_size=read_size,\n                                           use_list=use_list,\n                                           raw=raw,\n                                           object_hook=object_hook,\n                                           object_pairs_hook=object_pairs_hook,\n                                           list_hook=list_hook,\n                                           unicode_errors=unicode_errors,\n                                           max_buffer_size=max_buffer_size,\n                                           ext_hook=ext_hook)\n\nelse:\n    class Packer(_Packer):\n        def __init__(self,\n                     default=None,\n                     use_single_float=False,\n                     autoreset=True,\n                     use_bin_type=True,\n                     strict_types=False,\n                     datetime=False,\n                     unicode_errors=None):\n            default = functools.partial(encode, chain=default)\n            super(Packer, self).__init__(default=default,\n                                         use_single_float=use_single_float,\n                                         autoreset=autoreset,\n                                         use_bin_type=use_bin_type,\n                                         strict_types=strict_types,\n                                         datetime=datetime,\n                                         unicode_errors=unicode_errors)\n\n    class Unpacker(_Unpacker):\n        def __init__(self,\n                     file_like=None,\n                     read_size=0,\n                     use_list=True,\n                     raw=False,\n                     timestamp=0,\n                     strict_map_key=True,\n                     object_hook=None,\n                     object_pairs_hook=None,\n                     list_hook=None,\n                     unicode_errors=None,\n                     max_buffer_size=100 * 1024 * 1024,\n                     ext_hook=msgpack.ExtType,\n                     max_str_len=-1,\n                     max_bin_len=-1,\n                     max_array_len=-1,\n                     max_map_len=-1,\n                     max_ext_len=-1):\n            object_hook = functools.partial(decode, chain=object_hook)\n            super(Unpacker, self).__init__(file_like=file_like,\n                                           read_size=read_size,\n                                           use_list=use_list,\n                                           raw=raw,\n                                           timestamp=timestamp,\n                                           strict_map_key=strict_map_key,\n                                           object_hook=object_hook,\n                                           object_pairs_hook=object_pairs_hook,\n                                           list_hook=list_hook,\n                                           unicode_errors=unicode_errors,\n                                           max_buffer_size=max_buffer_size,\n                                           ext_hook=ext_hook,\n                                           max_str_len=max_str_len,\n                                           max_bin_len=max_bin_len,\n                                           max_array_len=max_array_len,\n                                           max_map_len=max_map_len,\n                                           max_ext_len=max_ext_len)\n\ndef pack(o, stream, **kwargs):\n    """"""\n    Pack an object and write it to a stream.\n    """"""\n\n    packer = Packer(**kwargs)\n    stream.write(packer.pack(o))\n\ndef packb(o, **kwargs):\n    """"""\n    Pack an object and return the packed bytes.\n    """"""\n\n    return Packer(**kwargs).pack(o)\n\ndef unpack(stream, **kwargs):\n    """"""\n    Unpack a packed object from a stream.\n    """"""\n\n    object_hook = kwargs.get(\'object_hook\')\n    kwargs[\'object_hook\'] = functools.partial(decode, chain=object_hook)\n    return _unpack(stream, **kwargs)\n\ndef unpackb(packed, **kwargs):\n    """"""\n    Unpack a packed object.\n    """"""\n\n    object_hook = kwargs.get(\'object_hook\')\n    kwargs[\'object_hook\'] = functools.partial(decode, chain=object_hook)\n    return _unpackb(packed, **kwargs)\n\nload = unpack\nloads = unpackb\ndump = pack\ndumps = packb\n\ndef patch():\n    """"""\n    Monkey patch msgpack module to enable support for serializing numpy types.\n    """"""\n\n    setattr(msgpack, \'Packer\', Packer)\n    setattr(msgpack, \'Unpacker\', Unpacker)\n    setattr(msgpack, \'load\', unpack)\n    setattr(msgpack, \'loads\', unpackb)\n    setattr(msgpack, \'dump\', pack)\n    setattr(msgpack, \'dumps\', packb)\n    setattr(msgpack, \'pack\', pack)\n    setattr(msgpack, \'packb\', packb)\n    setattr(msgpack, \'unpack\', unpack)\n    setattr(msgpack, \'unpackb\', unpackb)\n'"
setup.py,0,"b'#!/usr/bin/env python\n\nimport os\nimport re\n\nfrom setuptools import setup\n\nNAME =               \'msgpack-numpy\'\nVERSION =            \'0.4.6.post0\'\nAUTHOR =             \'Lev E. Givon\'\nAUTHOR_EMAIL =       \'lev@columbia.edu\'\nURL =                \'https://github.com/lebedov/msgpack-numpy\'\nDESCRIPTION =        \'Numpy data serialization using msgpack\'\nwith open(\'README.md\', \'r\') as f:\n    LONG_DESCRIPTION = f.read()\nLONG_DESCRIPTION = re.search(\'.*(^Package Description.*)\', LONG_DESCRIPTION, re.MULTILINE|re.DOTALL).group(1)\nLONG_DESCRIPTION_CONTENT_TYPE = \'text/markdown\'\nDOWNLOAD_URL =       URL\nLICENSE =            \'BSD\'\nCLASSIFIERS = [\n    \'Development Status :: 3 - Alpha\',\n    \'Intended Audience :: Developers\',\n    \'Intended Audience :: Science/Research\',\n    \'License :: OSI Approved :: BSD License\',\n    \'Operating System :: OS Independent\',\n    \'Programming Language :: Python\',\n    \'Programming Language :: Python :: 2.7\',\n    \'Programming Language :: Python :: 3\',\n    \'Programming Language :: Python :: 3.4\',\n    \'Programming Language :: Python :: 3.5\',\n    \'Programming Language :: Python :: 3.6\',\n    \'Programming Language :: Python :: 3.7\',\n    \'Topic :: Scientific/Engineering\',\n    \'Topic :: Software Development\']\n\nif __name__ == ""__main__"":\n    if os.path.exists(\'MANIFEST\'):\n        os.remove(\'MANIFEST\')\n\n    setup(\n        name = NAME,\n        version = VERSION,\n        author = AUTHOR,\n        author_email = AUTHOR_EMAIL,\n        license = LICENSE,\n        classifiers = CLASSIFIERS,\n        description = DESCRIPTION,\n        long_description = LONG_DESCRIPTION,\n        long_description_content_type = LONG_DESCRIPTION_CONTENT_TYPE,\n        url = URL,\n        py_modules = [\'msgpack_numpy\'],\n        install_requires = [\'numpy>=1.9.0\',\n                            \'msgpack>=0.5.2\']\n        )\n'"
tests.py,32,"b'#!/usr/bin/env python\n\nimport sys\nfrom unittest import main, TestCase\n\nimport msgpack\nimport numpy as np\nfrom numpy.testing import assert_equal, assert_array_equal\n\nfrom msgpack_numpy import patch\n\ntry:\n    range = xrange # Python 2\nexcept NameError:\n    pass # Python 3\n\nclass ThirdParty(object):\n\n    def __init__(self, foo=b\'bar\'):\n        self.foo = foo\n\n    def __eq__(self, other):\n        return isinstance(other, ThirdParty) and self.foo == other.foo\n\nclass test_numpy_msgpack(TestCase):\n    def setUp(self):\n         patch()\n\n    def encode_decode(self, x, use_list=True, max_bin_len=-1):\n        x_enc = msgpack.packb(x)\n        return msgpack.unpackb(x_enc, use_list=use_list,\n                               max_bin_len=max_bin_len)\n\n    def encode_thirdparty(self, obj):\n        return {b\'__thirdparty__\': True, b\'foo\': obj.foo}\n\n    def decode_thirdparty(self, obj):\n        if b\'__thirdparty__\' in obj:\n            return ThirdParty(foo=obj[b\'foo\'])\n        return obj\n\n    def encode_decode_thirdparty(self, x,\n            use_list=True, max_bin_len=-1):\n        x_enc = msgpack.packb(x, default=self.encode_thirdparty)\n        return msgpack.unpackb(x_enc,\n                               object_hook=self.decode_thirdparty,\n                               use_list=use_list, max_bin_len=max_bin_len)\n\n    def test_bin(self):\n        # str == bytes on Python 2:\n        if sys.version_info.major == 2:\n            assert_equal(type(self.encode_decode(b\'foo\')), str)\n        else:\n            assert_equal(type(self.encode_decode(b\'foo\')), bytes)\n\n    def test_str(self):\n        # str != unicode on Python 2:\n        if sys.version_info.major == 2:\n            assert_equal(type(self.encode_decode(\'foo\')), str)\n            assert_equal(type(self.encode_decode(u\'foo\')), unicode)\n        else:\n            assert_equal(type(self.encode_decode(u\'foo\')), str)\n\n    def test_numpy_scalar_bool(self):\n        x = np.bool_(True)\n        x_rec = self.encode_decode(x)\n        assert_equal(x, x_rec)\n        assert_equal(type(x), type(x_rec))\n        x = np.bool_(False)\n        x_rec = self.encode_decode(x)\n        assert_equal(x, x_rec)\n        assert_equal(type(x), type(x_rec))\n\n    def test_numpy_scalar_float(self):\n        x = np.float32(np.random.rand())\n        x_rec = self.encode_decode(x)\n        assert_equal(x, x_rec)\n        assert_equal(type(x), type(x_rec))\n\n    def test_numpy_scalar_complex(self):\n        x = np.complex64(np.random.rand()+1j*np.random.rand())\n        x_rec = self.encode_decode(x)\n        assert_equal(x, x_rec)\n        assert_equal(type(x), type(x_rec))\n\n    def test_scalar_float(self):\n        x = np.random.rand()\n        x_rec = self.encode_decode(x)\n        assert_equal(x, x_rec)\n        assert_equal(type(x), type(x_rec))\n\n    def test_scalar_complex(self):\n        x = np.random.rand()+1j*np.random.rand()\n        x_rec = self.encode_decode(x)\n        assert_equal(x, x_rec)\n        assert_equal(type(x), type(x_rec))\n\n    def test_list_numpy_float(self):\n        x = [np.float32(np.random.rand()) for i in range(5)]\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_array_equal([type(e) for e in x],\n                           [type(e) for e in x_rec])\n\n    def test_list_numpy_float_complex(self):\n        x = [np.float32(np.random.rand()) for i in range(5)] + \\\n          [np.complex128(np.random.rand()+1j*np.random.rand()) for i in range(5)]\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_array_equal([type(e) for e in x],\n                           [type(e) for e in x_rec])\n\n    def test_list_float(self):\n        x = [np.random.rand() for i in range(5)]\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_array_equal([type(e) for e in x],\n                           [type(e) for e in x_rec])\n\n    def test_list_float_complex(self):\n        x = [(np.random.rand()+1j*np.random.rand()) for i in range(5)]\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_array_equal([type(e) for e in x],\n                           [type(e) for e in x_rec])\n\n    def test_list_str(self):\n        x = [b\'x\'*i for i in range(5)]\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_array_equal([type(e) for e in x_rec], [bytes]*5)\n\n    def test_dict_float(self):\n        x = {b\'foo\': 1.0, b\'bar\': 2.0}\n        x_rec = self.encode_decode(x)\n        assert_array_equal(sorted(x.values()), sorted(x_rec.values()))\n        assert_array_equal([type(e) for e in sorted(x.values())],\n                           [type(e) for e in sorted(x_rec.values())])\n        assert_array_equal(sorted(x.keys()), sorted(x_rec.keys()))\n        assert_array_equal([type(e) for e in sorted(x.keys())],\n                           [type(e) for e in sorted(x_rec.keys())])\n\n    def test_dict_complex(self):\n        x = {b\'foo\': 1.0+1.0j, b\'bar\': 2.0+2.0j}\n        x_rec = self.encode_decode(x)\n        assert_array_equal(sorted(x.values(), key=np.linalg.norm),\n                           sorted(x_rec.values(), key=np.linalg.norm))\n        assert_array_equal([type(e) for e in sorted(x.values(), key=np.linalg.norm)],\n                           [type(e) for e in sorted(x_rec.values(), key=np.linalg.norm)])\n        assert_array_equal(sorted(x.keys()), sorted(x_rec.keys()))\n        assert_array_equal([type(e) for e in sorted(x.keys())],\n                           [type(e) for e in sorted(x_rec.keys())])\n\n    def test_dict_str(self):\n        x = {b\'foo\': b\'xxx\', b\'bar\': b\'yyyy\'}\n        x_rec = self.encode_decode(x)\n        assert_array_equal(sorted(x.values()), sorted(x_rec.values()))\n        assert_array_equal([type(e) for e in sorted(x.values())],\n                           [type(e) for e in sorted(x_rec.values())])\n        assert_array_equal(sorted(x.keys()), sorted(x_rec.keys()))\n        assert_array_equal([type(e) for e in sorted(x.keys())],\n                           [type(e) for e in sorted(x_rec.keys())])\n\n    def test_dict_numpy_float(self):\n        x = {b\'foo\': np.float32(1.0), b\'bar\': np.float32(2.0)}\n        x_rec = self.encode_decode(x)\n        assert_array_equal(sorted(x.values()), sorted(x_rec.values()))\n        assert_array_equal([type(e) for e in sorted(x.values())],\n                           [type(e) for e in sorted(x_rec.values())])\n        assert_array_equal(sorted(x.keys()), sorted(x_rec.keys()))\n        assert_array_equal([type(e) for e in sorted(x.keys())],\n                           [type(e) for e in sorted(x_rec.keys())])\n\n    def test_dict_numpy_complex(self):\n        x = {b\'foo\': np.complex128(1.0+1.0j), b\'bar\': np.complex128(2.0+2.0j)}\n        x_rec = self.encode_decode(x)\n        assert_array_equal(sorted(x.values(), key=np.linalg.norm),\n                           sorted(x_rec.values(), key=np.linalg.norm))\n        assert_array_equal([type(e) for e in sorted(x.values(), key=np.linalg.norm)],\n                           [type(e) for e in sorted(x_rec.values(), key=np.linalg.norm)])\n        assert_array_equal(sorted(x.keys()), sorted(x_rec.keys()))\n        assert_array_equal([type(e) for e in sorted(x.keys())],\n                           [type(e) for e in sorted(x_rec.keys())])\n\n    def test_numpy_array_float(self):\n        x = np.random.rand(5).astype(np.float32)\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_equal(x.dtype, x_rec.dtype)\n\n    def test_numpy_array_complex(self):\n        x = (np.random.rand(5)+1j*np.random.rand(5)).astype(np.complex128)\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_equal(x.dtype, x_rec.dtype)\n\n    def test_numpy_array_float_2d(self):\n        x = np.random.rand(5,5).astype(np.float32)\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_equal(x.dtype, x_rec.dtype)\n\n    def test_numpy_array_float_2d_macos(self):\n        """"""\n        Unit test for weird data loss error on MacOS (#35).\n        """"""\n        x = np.random.rand(5, 5).astype(np.float32)\n        x_rec = self.encode_decode(x, use_list=False, max_bin_len=50000000)\n        assert_array_equal(x, x_rec)\n        assert_equal(x.dtype, x_rec.dtype)\n\n    def test_numpy_array_str(self):\n        x = np.array([b\'aaa\', b\'bbbb\', b\'ccccc\'])\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_equal(x.dtype, x_rec.dtype)\n\n    def test_numpy_array_mixed(self):\n        x = np.array([(1, 2, b\'a\', [1.0, 2.0])],\n                     np.dtype([(\'arg0\', np.uint32),\n                               (\'arg1\', np.uint32),\n                               (\'arg2\', \'S1\'),\n                               (\'arg3\', np.float32, (2,))]))\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_equal(x.dtype, x_rec.dtype)\n\n    def test_numpy_array_noncontiguous(self):\n        x = np.ones((10, 10), np.uint32)[0:5, 0:5]\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_equal(x.dtype, x_rec.dtype)\n\n    def test_list_mixed(self):\n        x = [1.0, np.float32(3.5), np.complex128(4.25), b\'foo\']\n        x_rec = self.encode_decode(x)\n        assert_array_equal(x, x_rec)\n        assert_array_equal([type(e) for e in x],\n                           [type(e) for e in x_rec])\n\n    def test_chain(self):\n        x = ThirdParty(foo=b\'test marshal/unmarshal\')\n        x_rec = self.encode_decode_thirdparty(x)\n        self.assertEqual(x, x_rec)\n\nif __name__ == \'__main__\':\n    main()\n'"
