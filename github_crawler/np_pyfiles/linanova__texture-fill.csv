file_path,api_count,code
area_select.py,7,"b'"""""" Allow a user to select an area in the given image and save mask in a pickle.\n\nTwo types of selection are possible:\n1. Flood fill selection - user selects a single point and the edges of the area\nare determined by color theshold comparison.\n2. Polygon selection - user selects multiple points which are treated as vertices\nfor the desired area.\n""""""\n\nfrom argparse import ArgumentParser\nimport pickle\nimport sys\n\nfrom matplotlib import pyplot as plt\nimport matplotlib.patheffects as pe\nimport numpy as np\nfrom PIL import Image, ImageDraw\nfrom skimage import color\n\nimport utils\n\n\nclass PolygonBuilder():\n    """"""\n    Respond to user clicks by recording coordinates and connecting the dots to provide a\n    visualization of the region being selected. On a double click complete area by connecting\n    back to the beginning.\n    """"""\n    def __init__(self, axes, ncols, nrows):\n        # start with empty line\n        self.line, = axes.plot([0], [0], \'--w\', linewidth=2,\n                               path_effects=[pe.Stroke(linewidth=3, foreground=\'black\'), pe.Normal()])\n        self.x_vals = list()\n        self.y_vals = list()\n        self.img_cols = ncols\n        self.img_rows = nrows\n        self.area_mask = None\n        self.cid = self.line.figure.canvas.mpl_connect(\'button_press_event\', self)\n\n    def __call__(self, event):\n        if event.xdata is None:\n            return\n\n        self.x_vals.append(int(event.xdata))\n        self.y_vals.append(int(event.ydata))\n\n        self.line.set_data(self.x_vals, self.y_vals)\n        self.line.figure.canvas.draw()\n\n        if event.dblclick:\n            # build list of coordinates in form (x1,y1,x2,y2,x3...)\n            coords = list()\n            for i in range(len(self.x_vals)):\n                coords.append(self.x_vals[i])\n                coords.append(self.y_vals[i])\n\n            # create mask image defining the texture area\n            mask_img = Image.new(\'L\', (self.img_cols, self.img_rows), 0)\n            ImageDraw.Draw(mask_img).polygon(coords, outline=255, fill=255)\n            self.area_mask = np.array(mask_img, dtype=np.uint8)\n\n            # connect to starting point and show completed selection\n            self.x_vals.append(self.x_vals[0])\n            self.y_vals.append(self.y_vals[0])\n            self.line.set_data(self.x_vals, self.y_vals)\n            self.line.figure.canvas.draw()\n\n            # disconnect event handler to avoid undesired effects on further clicks\n            self.line.figure.canvas.mpl_disconnect(self.cid)\n\n\nclass FloodFiller():\n    """"""\n    Respond to user clicks by performing a flood fill outward from the selected\n    points and provide visualization of current selection.\n    """"""\n    COLOR_THRESHOLD = 15\n\n    def __init__(self, axes, img_array):\n        # convert rgb values to lab\n        img_downscale = np.copy(img_array).astype(np.float32)/255\n        self.img_values = color.rgb2lab(img_downscale)\n\n        self.axes = axes\n        self.target_col = None\n        self.target_row = None\n        self.target_color = None\n        self.area_mask = None\n        self.cid = axes.figure.canvas.mpl_connect(\'button_press_event\', self)\n\n    def __is_similar_color(self, row, col):\n        """"""Determine if the color at the given point is within the desired range.""""""\n        candidate_color = self.img_values[row][col]\n        delta_e = color.deltaE_ciede94(candidate_color, self.target_color)\n        return delta_e <= self.COLOR_THRESHOLD\n\n    def __flood_fill(self):\n        """"""\n        Starting from a single point, move outwards to add all points that match\n        the desired criteria.\n        """"""\n        nrows, ncols, _ = self.img_values.shape\n        if self.area_mask is None:\n            self.area_mask = np.zeros((nrows, ncols), dtype=np.bool)\n\n        to_check = set()\n        to_check.add((self.target_row, self.target_col))\n        checked = np.zeros_like(self.area_mask)\n\n        while to_check:\n            (row, col) = to_check.pop()\n\n            # if we\'ve already seen it, move on\n            # also check mask in case point was added in a previous selection\n            if checked[row][col] or self.area_mask[row][col]:\n                continue\n\n            checked[row, col] = True\n\n            # if it doesn\'t meet the criteria, move on\n            if not self.__is_similar_color(row, col):\n                continue\n\n            self.area_mask[row][col] = True\n            if col > 0:\n                to_check.add((row, col - 1))\n            if col < ncols - 1:\n                to_check.add((row, col + 1))\n            if row > 0:\n                to_check.add((row - 1, col))\n            if row < nrows - 1:\n                to_check.add((row + 1, col))\n\n        indices = np.where(self.area_mask)\n        self.axes.plot(indices[1], indices[0], \'.\', color=\'0.5\', linestyle=\'None\', markersize=2)\n        self.axes.figure.canvas.draw()\n\n    def __call__(self, event):\n        """"""Record the target color and invoke a flood fill.""""""\n        if event.xdata is None:\n            return\n\n        self.target_col = int(round(event.xdata))\n        self.target_row = int(round(event.ydata))\n        self.target_color = self.img_values[self.target_row][self.target_col]\n\n        self.__flood_fill()\n\n\ndef handle_close(event, fname):\n    """"""Handle close event for plot by saving the selection if one was made.""""""\n    mask = event.canvas.figure.selector.area_mask\n\n    if mask is not None:\n        file_p = open(fname, \'wb\')\n        pickle.dump(mask, file_p, -1)\n        file_p.close()\n\n\ndef main():\n    """"""\n    Open and display image. Allow user to choose between making a target or texture\n    selection and initialize appropriate selector.\n    """"""\n    parser = ArgumentParser()\n    parser.add_argument(\n        ""image"", help=""the image to use for area selection"",\n        type=lambda arg: utils.parse_image_argument(parser, arg))\n    args = parser.parse_args()\n\n    img = args.image\n\n    img_array = np.asarray(img, dtype=np.uint8)\n    nrows, ncols, _ = np.shape(img_array)\n    sys.setrecursionlimit(nrows * ncols)\n\n    # remove the standard pyplot toolbar\n    plt.rcParams[\'toolbar\'] = \'None\'\n\n    fig = plt.figure()\n    axes = plt.axes()\n\n    # clear ticks\n    axes.set_xticks([])\n    axes.set_yticks([])\n\n    # set size\n    axes.set_ylim([0, nrows])\n    axes.set_xlim([0, ncols])\n\n    # flip y axis to get image right side up\n    axes.invert_yaxis()\n\n    axes.imshow(img_array)\n\n    print(""Would you like to select the region to be filled (0) or the sample texture region (1)?"")\n\n    valid_input = False\n    while not valid_input:\n        answer = input(""0 or 1: "")\n        if answer == ""0"" or answer == ""1"":\n            valid_input = True\n\n    if answer == ""0"":\n        fname = \'target_region.pkl\'\n        fig.selector = FloodFiller(axes, img_array)\n        axes.set_title(""Select point within area you want to replace."")\n    else:\n        fname = \'texture_region.pkl\'\n        fig.selector = PolygonBuilder(axes, ncols, nrows)\n        axes.set_title(""Click to define an area of texture (double click to end selection)."")\n\n\n    fig.canvas.mpl_connect(\'close_event\', lambda event: handle_close(event, fname))\n    plt.show()\n\nif __name__ == ""__main__"":\n    main()\n'"
texture_fill.py,22,"b'"""""" Copy texture selection over to the undesired area of the target image and synthesize more\nof the same texture to fill the entire area.\n\nRequires:\n1. a target image and a texture image specified as arguments (can be the same file)\n2. masks defining areas within the target and texture images in pickles in the same folder\n""""""\n\nfrom argparse import ArgumentParser\nfrom enum import Enum\nimport multiprocessing as mp\nimport random\nimport os.path\nimport pickle\nimport sys\n\nfrom PIL import Image\nimport numpy as np\n\nimport utils\n\nPATCH_L = 10 # patch length\nSTD_DEVIATION = 2 # standard deviation for random patch selection\n\n\nclass PixelType(Enum):\n    ORIGINAL = 0\n    EMPTY = 1\n    FILLED = 2\n\n\ndef ssd_worker(row, column):\n    """"""Compute squared sum of differences at the given location in the texture image""""""\n    tex_points = texture[(coordinates[0] + row), (coordinates[1] + column)]\n    diff = points - tex_points\n    return (np.sum(diff * diff), row, column)\n\n\ndef ssd_initializer(patch, t, coords):\n    """"""Pool initializer for the ssd worker""""""\n    global texture\n    global points\n    global coordinates\n    texture = t\n    coordinates = coords\n    points = patch[coords[0], coords[1]]\n    points = points.astype(\'float\')\n\n\ndef compute_ssd(patch, patch_mask, texture):\n    """"""\n    Compute squared sum of differences for the given patch at each possible patch\n    location along the texture image.\n    """"""\n    tex_rows, tex_cols, _ = np.shape(texture)\n\n    # only evaluate points that can serve as the centre point for a complete patch\n    ssd_rows = tex_rows - 2 * PATCH_L\n    ssd_cols = tex_cols - 2 * PATCH_L\n\n    # only consider points of interest, ie non-empty pixels\n    # NTOE: currently this includes both newly added texture and pre-existing values\n    # from the original image outside the hole\n    coords = np.where(patch_mask != PixelType.EMPTY.value)\n\n    pool = mp.Pool(mp.cpu_count(), ssd_initializer, (patch, texture, coords))\n\n    # for each possible location of the patch in the texture image\n    iterable = [(r, c) for r in range(ssd_rows) for c in range(ssd_cols)]\n    result = pool.starmap_async(ssd_worker, iterable).get()\n\n    pool.close()\n    pool.join()\n\n    # results from the workers arrive out of order\n    ssd = np.zeros((ssd_rows, ssd_cols))\n    for (value, r, c) in result:\n        ssd[r][c] = value\n\n    return ssd\n\n\ndef copy_patch(target_image, patch_mask, texture,\n               target_ctr_r, target_ctr_c, source_ctr_r, source_ctr_c):\n    """"""Copy patch from texture image to the chosen patch location in the target image.""""""\n    patch_rows, patch_cols = np.shape(patch_mask)\n\n    for r in range(patch_rows):\n        for c in range(patch_cols):\n            if(patch_mask[r, c] == PixelType.EMPTY.value):\n                target_r = target_ctr_r - PATCH_L + r\n                target_c = target_ctr_c - PATCH_L + c\n\n                source_r = source_ctr_r - PATCH_L + r\n                source_c = source_ctr_c - PATCH_L + c\n                target_image[target_r, target_c] = texture[source_r, source_c]\n\n\ndef is_edge_worker(row, column):\n    """"""Determine if the given coordinate is an edge""""""\n    nrows, ncols = shape\n    edge = (mask[row, column] == PixelType.EMPTY.value and\n            ((column > 0 and mask[row, column - 1] == PixelType.FILLED.value) or\n            (column < ncols - 1 and mask[row, column + 1] == PixelType.FILLED.value) or\n            (row > 0 and mask[row - 1, column] == PixelType.FILLED.value) or\n            (row < nrows - 1 and mask[row + 1, column] == PixelType.FILLED.value)))\n    return ((1 if edge else 0), row, column)\n\n\ndef is_edge_initializer(hole_mask, nrows, ncols):\n    """"""Pool initializer for the is_edge workers""""""\n    global mask\n    global shape\n    mask = hole_mask\n    shape = (nrows, ncols)\n\n\ndef find_inner_edge(hole_mask):\n    """"""Find the edge of already transferred texture within the hole image.""""""\n    nrows, ncols = np.shape(hole_mask)\n    pool = mp.Pool(mp.cpu_count(), is_edge_initializer, (hole_mask, nrows, ncols))\n\n    iterable = [(r, c) for r in range(nrows) for c in range(ncols)]\n    result = pool.starmap_async(is_edge_worker, iterable).get()\n\n    pool.close()\n    pool.join()\n\n    # results from the workers arrive out of order\n    edge_mask = np.zeros(np.shape(hole_mask))\n    for (value, r, c) in result:\n        edge_mask[r][c] = value\n\n    return edge_mask\n\n\ndef copy_texture(target_image, target_mask, texture):\n    """"""\n    Copy the given texture image to the centre of the hole in the target image. The centre\n    here is defined as the centre of the bounding box. This approach may not work with highly\n    irregular hole shapes.\n    """"""\n    target_indices = target_mask.nonzero()\n    max_r = max(target_indices[0])\n    min_r = min(target_indices[0])\n    max_c = max(target_indices[1])\n    min_c = min(target_indices[1])\n\n    centre_r = abs(max_r - (max_r - min_r) // 2)\n    centre_c = abs(max_c - (max_c - min_c) // 2)\n\n    texture_rows, texture_cols, _ = np.shape(texture)\n    tex_half_h = texture_rows // 2\n    tex_half_w = texture_cols // 2\n\n    img_rows, img_cols, _ = np.shape(target_image)\n\n    for r in range(texture_rows):\n        for c in range(texture_cols):\n            target_row = centre_r - tex_half_h + r\n            target_col = centre_c - tex_half_w + c\n\n            if(target_row >= 0 and target_row < img_rows\n               and target_col >= 0 and target_col < img_cols\n               and target_mask[target_row, target_col] == PixelType.EMPTY.value):\n                target_image[target_row, target_col] = texture[r, c]\n                target_mask[target_row, target_col] = PixelType.FILLED.value\n\n\ndef main():\n    """"""\n    Load texture and target image as well as mask defining area to be replaced. Start by\n    copying entire texture sample into the centre of the desired area, then build outwards,\n    selecting an appropriate patch to copy over to each location until the entire area is filled.\n    """"""\n    parser = ArgumentParser()\n    parser.add_argument(\n        ""target_image"", help=""the image that will receive the texture"",\n        type=lambda arg: utils.parse_image_argument(parser, arg))\n    parser.add_argument(\n        ""texture_image"",\n        help=""the image that will provide the texture (if not provided, will use target image as the source)"",\n        type=lambda arg: utils.parse_image_argument(parser, arg), nargs=\'?\')\n    args = parser.parse_args()\n\n    target_image = args.target_image\n    texture_image = args.texture_image if args.texture_image is not None else target_image\n\n    target_array = np.asarray(target_image, dtype=np.uint8)\n    texture_array = np.asarray(texture_image, dtype=np.uint8)\n\n    target_region_file = open(\'target_region.pkl\', \'rb\')\n    target_mask = pickle.load(target_region_file)\n    target_region_file.close()\n\n    texture_region_file = open(\'texture_region.pkl\', \'rb\')\n    texture_mask = pickle.load(texture_region_file)\n    texture_region_file.close()\n\n    # define texture image, adjusting selection to a rectangle\n    # TODO: don\'t allow texture smaller than patch size\n    texture_rs, texture_cs = texture_mask.nonzero()\n    texture = texture_array[min(texture_rs):max(texture_rs) + 1, min(texture_cs):max(texture_cs) + 1, :]\n\n    # hole out target region in image\n    target_indices = target_mask.nonzero()\n    target_image = target_array.copy()\n    target_image[target_indices] = 0\n\n    nrows, ncols, _ = np.shape(target_image)\n\n    # cast target mask to uint8 type so we can have 3 possible PixelType modes\n    target_mask = target_mask.astype(np.uint8)\n\n    # copy the initial texture into the hole\n    copy_texture(target_image, target_mask, texture)\n\n    # update pixels needing to be filled\n    target_indices = np.where(target_mask == PixelType.EMPTY.value)\n    total_todo = len(target_indices[0])\n\n    while total_todo > 0:\n        print(f"" Remaining pixels: {total_todo}"", end=""\\r"")\n\n        # find edge of texture that has been copied over so far\n        edge_mask = find_inner_edge(target_mask)\n        edge_indices = np.where(edge_mask)\n        edge_todo = len(edge_indices[0])\n\n        while edge_todo > 0:\n\n            # pick a random pixel that still needs to be done\n            index = np.random.randint(0, edge_todo)\n            target_ctr_r = edge_indices[0][index]\n            target_ctr_c = edge_indices[1][index]\n\n            target_min_r = max(0, target_ctr_r - PATCH_L)\n            target_max_r = target_ctr_r + PATCH_L\n            target_min_c = max(0, target_ctr_c - PATCH_L)\n            target_max_c = target_ctr_c + PATCH_L\n\n            patch = target_image[target_min_r:target_max_r + 1, target_min_c:target_max_c + 1, :]\n            patch_mask = target_mask[target_min_r:target_max_r + 1, target_min_c:target_max_c + 1]\n\n            ssd = compute_ssd(patch, patch_mask, texture)\n\n            # Pick random best:\n            # 1. flatten and sort array\n            ssd_sorted = np.sort(np.copy(ssd), axis=None)\n            # 2. select random number from gaussian distribution with mean 0,\n            # and get the ssd value at that index\n            rand = int(round(abs(random.gauss(0, STD_DEVIATION))))\n            ssd_value = ssd_sorted[min(rand, np.size(ssd_sorted) - 1)]\n            # 3. find which index in the original unflattened array had that value\n            match_index = np.nonzero(ssd == ssd_value)\n\n            # compute_ssd only returns values for all indices around which a patch fits\n            # within the texture image bounds. Therefore a 0,0 index is really the point\n            # at PATCH_L, PATCH_L. Adjust selected index to correct for this.\n            source_ctr_r = match_index[0][0] + PATCH_L\n            source_ctr_c = match_index[1][0] + PATCH_L\n\n            # pad mask to ensure copy_patch doesn\'t need to worry about partial patches near edges\n            overflow_min_r = abs(min(0, target_ctr_r - PATCH_L))\n            overflow_max_r = abs(min(0, nrows - (target_ctr_r + PATCH_L)))\n            overflow_min_c = abs(min(0, target_ctr_c - PATCH_L))\n            overflow_max_c = abs(min(0, ncols - (target_ctr_c + PATCH_L)))\n            patch_mask = np.lib.pad(\n                patch_mask,\n                ((overflow_min_r, overflow_max_r), (overflow_min_c, overflow_max_c)),\n                \'constant\', constant_values=0)\n\n            # copy patch over\n            copy_patch(target_image, patch_mask, texture,\n                       target_ctr_r, target_ctr_c, source_ctr_r, source_ctr_c)\n\n            # update masks and count of remaining edge points in this batch\n            edge_mask[target_min_r:target_max_r + 1, target_min_c:target_max_c + 1] = 0\n            target_mask[target_min_r:target_max_r + 1, target_min_c:target_max_c + 1] = 2\n\n            edge_indices = np.where(edge_mask)\n            edge_todo = len(edge_indices[0])\n\n        # update count of total points remaining\n        target_indices = np.where(target_mask == PixelType.EMPTY.value)\n        total_todo = len(target_indices[0])\n\n    final_img = Image.fromarray(target_image).convert(\'RGB\')\n    final_img.show()\n    final_img.save(\'result.jpg\')\n\nif __name__ == ""__main__"":\n    if not os.path.isfile(\'target_region.pkl\') or not os.path.isfile(\'texture_region.pkl\'):\n        print(""Specify the target and texture regions first."")\n        sys.exit(1)\n\n    main()\n'"
utils.py,0,"b'import os.path\nfrom PIL import Image\n\ndef parse_image_argument(parser, arg):\n    """""" Parser helper for image file arguments. """"""\n    if not os.path.isfile(arg):\n        parser.error(""file %s does not exist"" % arg)\n    else:\n        try:\n            img = Image.open(arg).convert(\'RGB\')\n            return img\n        except IOError:\n            parser.error(""could not open file %s"" % arg)'"
