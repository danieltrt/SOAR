file_path,api_count,code
setup.py,0,"b'# -*- coding: utf-8 -*-\n# Copyright (C) 2009-2019, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n#  of this software and associated documentation files (the ""Software""), to deal\n#  in the Software without restriction, including without limitation the rights\n#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n#  copies of the Software, and to permit persons to whom the Software is\n#  furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n#  all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n#  THE SOFTWARE.\n\nfrom __future__ import division\ntry:\n    import setuptools\nexcept ImportError:\n    print(\'\'\'\nsetuptools not found.\n\nOn linux, the package is often called python-setuptools\'\'\')\n    from sys import exit\n    exit(1)\nimport os\ntry:\n    import numpy\nexcept ImportError:\n    class FakeNumpy(object):\n        def get_include(self):\n           return []\n    numpy = FakeNumpy()\n\n\nfrom distutils.command.build_ext import build_ext\n\nexec(compile(open(\'mahotas/mahotas_version.py\').read(),\n             \'mahotas/mahotas_version.py\', \'exec\'))\n\ntry:\n    long_description = open(\'README.md\', encoding=\'utf-8\').read()\nexcept:\n    long_description = open(\'README.md\').read()\n\nundef_macros = []\ndefine_macros = []\nif os.environ.get(\'DEBUG\'):\n    undef_macros = [\'NDEBUG\']\n    if os.environ.get(\'DEBUG\') == \'2\':\n        define_macros = [(\'_GLIBCXX_DEBUG\',\'1\')]\n\ndefine_macros.append((\'NPY_NO_DEPRECATED_API\',\'NPY_1_7_API_VERSION\'))\ndefine_macros.append((\'PY_ARRAY_UNIQUE_SYMBOL\',\'Mahotas_PyArray_API_Symbol\'))\n\nextensions = {\n    \'mahotas._bbox\': [\'mahotas/_bbox.cpp\'],\n    \'mahotas._center_of_mass\': [\'mahotas/_center_of_mass.cpp\'],\n    \'mahotas._convex\': [\'mahotas/_convex.cpp\'],\n    \'mahotas._convolve\': [\'mahotas/_convolve.cpp\', \'mahotas/_filters.cpp\'],\n    \'mahotas._distance\': [\'mahotas/_distance.cpp\'],\n    \'mahotas._histogram\': [\'mahotas/_histogram.cpp\'],\n    \'mahotas._interpolate\': [\'mahotas/_interpolate.cpp\', \'mahotas/_filters.cpp\'],\n    \'mahotas._labeled\': [\'mahotas/_labeled.cpp\', \'mahotas/_filters.cpp\'],\n    \'mahotas._morph\': [\'mahotas/_morph.cpp\', \'mahotas/_filters.cpp\'],\n    \'mahotas._thin\': [\'mahotas/_thin.cpp\'],\n\n    \'mahotas.features._lbp\': [\'mahotas/features/_lbp.cpp\'],\n    \'mahotas.features._surf\': [\'mahotas/features/_surf.cpp\'],\n    \'mahotas.features._texture\': [\'mahotas/features/_texture.cpp\', \'mahotas/_filters.cpp\'],\n    \'mahotas.features._zernike\': [\'mahotas/features/_zernike.cpp\'],\n}\n\next_modules = [setuptools.Extension(key, sources=sources, undef_macros=undef_macros, define_macros=define_macros, include_dirs=[numpy.get_include()]) for key,sources in extensions.items()]\n\npackages = setuptools.find_packages()\n\npackage_dir = {\n    \'mahotas.tests\': \'mahotas/tests\',\n    \'mahotas.demos\': \'mahotas/demos\',\n    }\npackage_data = {\n    \'mahotas.tests\': [\'data/*\'],\n    \'mahotas.demos\': [\'data/*\'],\n    }\n\ninstall_requires = open(\'requirements.txt\').read()\n\ntests_require = open(\'tests-requirements.txt\').read()\n\ncopt={\n    \'msvc\': [\'/EHsc\'], \n    \'intelw\': [\'/EHsc\']  \n}\n\nclass build_ext_subclass(build_ext):\n    def build_extensions(self):\n        c = self.compiler.compiler_type\n        if c in copt:\n           for e in self.extensions:\n               e.extra_compile_args = copt[c]\n        build_ext.build_extensions(self)\n\nclassifiers = [\n\'Development Status :: 5 - Production/Stable\',\n\'Intended Audience :: Developers\',\n\'Intended Audience :: Science/Research\',\n\'Topic :: Scientific/Engineering :: Image Recognition\',\n\'Topic :: Software Development :: Libraries\',\n\'Programming Language :: Python\',\n\'Programming Language :: Python :: 2\',\n\'Programming Language :: Python :: 2.7\',\n\'Programming Language :: Python :: 3\',\n\'Programming Language :: Python :: 3.3\',\n\'Programming Language :: Python :: 3.4\',\n\'Programming Language :: Python :: 3.5\',\n\'Programming Language :: Python :: 3.6\',\n\'Programming Language :: Python :: 3.7\',\n\'Programming Language :: C++\',\n\'Operating System :: OS Independent\',\n\'License :: OSI Approved :: MIT License\',\n]\n\nsetuptools.setup(name = \'mahotas\',\n      version = __version__,\n      description = \'Mahotas: Computer Vision Library\',\n      long_description = long_description,\n      long_description_content_type = \'text/markdown\',\n      author = \'Luis Pedro Coelho\',\n      author_email = \'luis@luispedro.org\',\n      license = \'MIT\',\n      platforms = [\'Any\'],\n      classifiers = classifiers,\n      url = \'http://luispedro.org/software/mahotas\',\n      packages = packages,\n      ext_modules = ext_modules,\n      package_dir = package_dir,\n      package_data = package_data,\n      entry_points={\n          \'console_scripts\': [\n              \'mahotas-features = mahotas.features_cli:main\',\n          ],\n      },\n      test_suite = \'nose.collector\',\n      install_requires = install_requires,\n      tests_require = tests_require,\n      cmdclass = {\'build_ext\': build_ext_subclass}\n      )\n\n'"
mahotas/__init__.py,0,"b""'''\\\n=======\nMahotas\n=======\n\nA package for computer vision in Python.\n\nMain Features\n-------------\n\nfeatures\n    Compute global and local features (several submodules, include SURF and Haralick features)\nconvolve\n    Convolution and wavelets\nmorph\n    Morphological features. Most are available at the mahotas level, include erode(), dilate()...\nwatershed\n    Seeded watershed implementation\nimread/imsave\n    read/write image\n\nDocumentation: https://mahotas.readthedocs.io/\n\nCitation:\n\n    Coelho, Luis Pedro, 2013. Mahotas: Open source software for scriptable\n    computer vision. Journal of Open Research Software, 1:e3, DOI:\n    http://dx.doi.org/10.5334/jors.ac\n'''\ntry:\n    from .bbox import bbox, croptobbox\n    from .center_of_mass import center_of_mass\n    from .convolve import convolve, \\\n                            convolve1d, \\\n                            find, \\\n                            mean_filter, \\\n                            median_filter, \\\n                            rank_filter, \\\n                            template_match, \\\n                            gaussian_filter1d, \\\n                            gaussian_filter, \\\n                            laplacian_2D\n    from .convolve import haar, ihaar, daubechies, idaubechies, wavelet_center, wavelet_decenter\n    from .distance import distance\n    from .edge import sobel, dog\n    from .euler import euler\n    from .histogram import fullhistogram\n    from .labeled import border, borders, bwperim, label, labeled_sum\n    from .features.moments import moments\n    from .morph import cdilate, \\\n                        cerode, \\\n                        close, \\\n                        close_holes, \\\n                        cwatershed, \\\n                        disk, \\\n                        dilate, \\\n                        erode, \\\n                        get_structuring_elem, \\\n                        hitmiss, \\\n                        locmax, \\\n                        locmin, \\\n                        majority_filter, \\\n                        open, \\\n                        regmin, \\\n                        regmax\n    from .resize import imresize, resize_to\n    from .stretch import as_rgb, \\\n                        overlay, \\\n                        stretch, \\\n                        stretch_rgb\n    from .thin import thin\n    from .thresholding import otsu, rc\n    from .io import imread, imsave\n\n    from .tests import run as test\n\n    from .mahotas_version import __version__\n\n    from . import colors\n    from . import demos\n    from . import features\n    from . import morph\n    from . import polygon\n    from . import segmentation\nexcept ImportError: # pragma: no cover\n    import sys\n    _,e,_ = sys.exc_info()\n    from sys import stderr\n    stderr.write('''\\\nCould not import submodules (exact error was: %s).\n\nThere are many reasons for this error the most common one is that you have\neither not built the packages or have built (using `python setup.py build`) or\ninstalled them (using `python setup.py install`) and then proceeded to test\nmahotas **without changing the current directory**.\n\nTry installing and then changing to another directory before importing mahotas.\n''' % e)\n\ncitation_text = '''\nIf you use mahotas please cite\n\n    Coelho, Luis Pedro, 2013. Mahotas: Open source software for scriptable\n    computer vision. Journal of Open Research Software, 1:e3, DOI:\n    http://dx.doi.org/10.5334/jors.ac\n\n\nIn BibTex format:\n\n@article{coelho:mahotas,\n    title = {Mahotas: Open source software for scriptable computer vision},\n    author = {Luis Pedro Coelho},\n    journal = {Journal of Open Research Software},\n    year = {2013},\n    volume = {1},\n    doi = {10.5334/jors.ac},\n    url = {http://dx.doi.org/10.5334/jors.ac}\n}\n'''\n\nshort_citation_text = \\\n'''If you use mahotas in a scientific publication, please cite\n    Coelho, LP (2013). http://dx.doi.org/10.5334/jors.ac\n'''\n\ndef citation(print_out=True, short=False):\n    text = (short_citation_text if short else citation_text)\n    if print_out:\n        # Use a Python2/3 compatible form of printing:\n        from sys import stdout\n        stdout.write(text)\n    return text\n\n__all__ = [\n    'as_rgb',\n    'bbox',\n    'border',\n    'borders',\n    'bwperim',\n    'cdilate',\n    'center_of_mass',\n    'cerode',\n    'close',\n    'close_holes',\n    'colors',\n    'convolve',\n    'convolve1d',\n    'croptobbox',\n    'cwatershed',\n    'daubechies',\n    'dilate',\n    'disk',\n    'distance',\n    'dog',\n    'erode',\n    'euler',\n    'find',\n    'fullhistogram',\n    'gaussian_filter',\n    'gaussian_filter1d',\n    'get_structuring_elem',\n    'haar',\n    'hitmiss',\n    'idaubechies',\n    'ihaar',\n    'imread',\n    'imresize',\n    'imsave',\n    'label',\n    'labeled_sum',\n    'laplacian_2D',\n    'locmax',\n    'locmin',\n    'majority_filter',\n    'mean_filter',\n    'median_filter',\n    'moments',\n    'open',\n    'otsu',\n    'overlay',\n    'rank_filter',\n    'rc',\n    'regmax',\n    'regmin',\n    'sobel',\n    'stretch',\n    'stretch_rgb',\n    'template_match',\n    'thin',\n    'wavelet_center',\n    'wavelet_decenter',\n\n    'demos',\n    'morph',\n    'features',\n    'polygon',\n    'segmentation',\n\n    'test',\n\n    'citation',\n    'citation_text',\n    '__version__',\n    ]\n\n"""
mahotas/_filters.py,0,"b""# Copyright (C) 2010, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# \n# License: MIT (see COPYING file)\n\nfrom __future__ import division\n\nmode2int = {\n    'nearest' : 0,\n    'wrap' : 1,\n    'reflect' : 2,\n    'mirror' : 3,\n    'constant' : 4,\n    'ignore' : 5,\n}\n\nmodes = frozenset(mode2int.keys())\n\ndef _checked_mode2int(mode, cval, fname):\n    if mode not in modes:\n        raise ValueError('mahotas.%s: `mode` not in %s' % (fname, modes))\n    if mode == 'constant' and cval != 0.:\n        raise NotImplementedError('Please email mahotas developers to get this implemented.')\n    return mode2int[mode]\n\n_check_mode = _checked_mode2int\n\n"""
mahotas/bbox.py,2,"b'# Copyright (C) 2008-2015, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# \n# License: MIT (see COPYING file)\n\nfrom __future__ import division\n\nfrom . import _bbox\nimport numpy as np\n\ndef bbox(img, border=None, as_slice=False):\n    """"""\n    min1,max1,min2,max2 = bbox(img, border={0}, as_slice={False})\n\n    Calculate the bounding box of image img.\n\n    Parameters\n    ----------\n    img : ndarray\n        Any integer image type\n\n    Returns\n    -------\n    min1,max1,min2,max2 : int,int,int,int\n        These are such that ``img[min1:max1, min2:max2]`` contains all non-zero\n        pixels. Returned when ``as_slice`` is false (the default)\n    s : slice\n        A slice representation of the bounding box. Returned when ``as_slice``\n        is true\n    """"""\n    if not img.shape:\n        return np.array([], dtype=np.intp)\n    r = _bbox.bbox(img)\n    if border:\n        r = r.reshape((-1, 2))\n        np.maximum(r.T[0] - border, 0, out=r.T[0])\n        r.T[1] += border\n        r = r.ravel()\n    if as_slice:\n        r = tuple([slice(s,e) for s,e in r.reshape((-1,2))])\n    return r\n\ndef croptobbox(img, border=None):\n    """"""\n    nimg = croptobbox(img, border=0)\n\n    Returns a version of img cropped to the image\'s bounding box\n\n    Parameters\n    ----------\n    img : ndarray\n        Integer image array\n    border : int, optional\n        whether to add a border (default no border)\n\n    Returns\n    -------\n    nimg : ndarray\n        A subimage of img.\n\n    Notes\n    -----\n    Note that the border is on the bounding box, not on the final \n    image! This means that if the image has a positive pixel on its margin, \n    it will still be on the margin.\n\n    This ensures that the result is always a sub-image of the input.\n    """"""\n    sl = bbox(img, border=border, as_slice=True)\n    return img[sl]\n\n'"
mahotas/bwperim.py,0,"b""# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# Copyright (C) 2012  Luis Pedro Coelho\n# \n# License: MIT (see COPYING file)\nimport warnings\nwarnings.warn(\n'''Use\n\nfrom mahotas.labeled import bwperim\n''', DeprecationWarning)\n\n\nfrom .labeled import bwperim\n__all__ = ['bwperim']\n\n"""
mahotas/center_of_mass.py,3,"b'# Copyright (C) 2008-2015, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# License: MIT (see COPYING file)\n\nfrom __future__ import division\nimport numpy as np\nfrom . import _center_of_mass\n\ndef center_of_mass(img, labels=None):\n    \'\'\'\n    coords = center_of_mass(img, labels=None)\n\n    Returns the center of mass of img.\n\n    If `labels` is given, then it returns `L` centers of mass, one for each\n    region identified by `labels` (including region 0).\n\n    Parameters\n    ----------\n    img : ndarray\n    labels : ndarray, optional\n        A labeled array (i.e., an array of integers of the same shape as\n        ``img`` such that each ""object"" is identified by areas with different\n        values).\n\n    Returns\n    -------\n    coords : ndarray\n        The exact shape of the output depends on whether the ``labels``\n        argument was used. If ``labels is None``, then the return value is a\n        1-ndarray of coordinates (``size = len(img.shape)``); otherwise, the\n        return value is a 2-ndarray of coordinates (``shape = (labels.max()+1,\n        len(img.shape)``).  \'\'\'\n    if labels is not None:\n        if labels.dtype != np.int32 or \\\n            not labels.flags[\'C_CONTIGUOUS\']:\n            labels = np.ascontiguousarray(labels, np.int32)\n        else:\n            # This is necessary because it might be of a type that equals\n            # NPY_INT32, but is not NPY_INT32\n            labels = labels.view(np.int32)\n    cm = _center_of_mass.center_of_mass(img, labels)\n    if labels is not None:\n        return cm.reshape((-1, img.ndim))\n    return cm\n\n'"
mahotas/colors.py,18,"b""# Copyright (C) 2012-2019, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# \n# License: MIT (see COPYING file)\n\nfrom __future__ import division\n\nimport numpy as np\nfrom .internal import _check_3\n\ndef rgb2grey(array, dtype=np.float):\n    '''\n    grey = rgb2grey(rgb_image, dtype=np.float)\n\n    Convert an RGB image to a grayscale image\n\n    The interpretation of RGB and greyscale values is very much object\n    dependent (as anyone who has used an overhead projector which mangled their\n    colour figures will have experienced). This function uses a typical method\n    for conversion and will work acceptably well for typical use cases, but if\n    you have strict requirements, consider implementing the conversion by\n    yourself for fine control.\n\n    Parameters\n    ----------\n    array : ndarray of shape (a,b,3)\n    dtype : dtype, optional\n        dtype of return\n\n    Returns\n    -------\n    grey : ndarray of ``dtype``\n    '''\n    _check_3(array, 'rgb2grey')\n    transform = np.array([0.30, 0.59, 0.11])\n    transformed = np.dot(array, transform)\n    return transformed.astype(dtype, copy=False)\n    \nrgb2gray = rgb2grey\n\ndef _convert(array, matrix, dtype, funcname):\n    _check_3(array, funcname)\n    h,w,d = array.shape\n    array = array.transpose((2,0,1))\n    array = array.reshape((3,h*w))\n    array = np.dot(matrix, array)\n    array = array.reshape((3,h,w))\n    array = array.transpose((1,2,0))\n    if dtype is not None:\n        array = array.astype(dtype, copy=False)\n    return array\n\ndef rgb2xyz(rgb, dtype=None):\n    '''\n    xyz = rgb2xyz(rgb, dtype={float})\n\n    Convert RGB to XYZ coordinates\n\n    The input is interpreted as sRGB. See Wikipedia for more details:\n\n    http://en.wikipedia.org/wiki/SRGB\n\n    Parameters\n    ----------\n    rgb : ndarray\n    dtype : dtype, optional \n        What dtype to return\n\n    Returns\n    -------\n    xyz : ndarray\n\n    See Also\n    --------\n    xyz2rgb : function\n        The reverse function\n    '''\n    transformation = np.array([\n                [0.4124, 0.3576, 0.1805],\n                [0.2126, 0.7152, 0.0722],\n                [0.0193, 0.1192, 0.9505],\n                ])\n    rgb = rgb/255.\n    a = 0.055\n    rgb_linear_high = np.power( (rgb + a)/(1.+a), 2.4 )\n    rgb_linear_low = rgb/12.92\n    rgb_linear = np.choose(rgb <= 0.04045, [rgb_linear_low, rgb_linear_high])\n    return _convert(rgb_linear, transformation, dtype, 'rgb2xyz')\n\ndef xyz2rgb(xyz, dtype=None):\n    '''\n    rgb = xyz2rgb(xyz, dtype={float})\n\n    Convert XYZ to sRGB coordinates\n\n    The output should be interpreted as sRGB. See Wikipedia for more details:\n\n    http://en.wikipedia.org/wiki/SRGB\n\n    Parameters\n    ----------\n    xyz : ndarray\n    dtype : dtype, optional \n        What dtype to return. Default will be floats\n\n    Returns\n    -------\n    rgb : ndarray\n\n    See Also\n    --------\n    rgb2xyz : function\n        The reverse function\n    '''\n    transformation = np.array([\n                [ 3.2406, -1.5372, -0.4986],\n                [-0.9689,  1.8758,  0.0415],\n                [ 0.0557, -0.2040,  1.0570],\n                ])\n    rgb_linear = _convert(xyz, transformation, dtype, 'xyz2rgb')\n    a = 0.055\n    srgb_high = (1 + a)*np.power(rgb_linear, 1./2.4)\n    srgb_high -= a\n    srgb_low = 12.92 * rgb_linear\n    srgb = np.choose(rgb_linear <= 0.0031308, [srgb_low, srgb_high])\n    srgb *= 255.\n    return srgb\n\ndef xyz2lab(xyz, dtype=None):\n    '''\n    lab = xyz2lab(xyz, dtype={float})\n\n    Convert CIE XYZ to L*a*b* coordinates\n\n    http://en.wikipedia.org/wiki/CIELAB\n\n    Parameters\n    ----------\n    xyz : ndarray\n    dtype : dtype, optional \n        What dtype to return. Default will be floats\n\n    Returns\n    -------\n    lab : ndarray\n    '''\n    _check_3(xyz, 'xyz2lab')\n    x,y,z = xyz.transpose((2,0,1))\n    def f(t):\n        branch_large = t**(1./3)\n        branch_small = ((1/3.)*(29./6)*(29./6))*t + 4/29.\n        return np.choose(t <= (6./29)**2, [branch_small, branch_large])\n    xn, yn, zn = 0.95047, 1., 1.08883\n    fx = f(x/xn)\n    fy = f(y/yn)\n    fz = f(z/zn)\n    L = 116 * fy - 16\n    a = 500 * (fx - fy)\n    b = 200 * (fy - fz)\n    Lab = np.dstack( [L,a,b] )\n    if dtype is not None:\n        Lab = Lab.astype(dtype, copy=False)\n    return Lab\n\ndef rgb2lab(rgb, dtype=None):\n    '''\n    lab = rgb2lab(rgb, dtype={float})\n\n    Convert sRGB to L*a*b* coordinates\n\n    http://en.wikipedia.org/wiki/CIELAB\n\n    Parameters\n    ----------\n    rgb : ndarray\n        Must be of shape (h,w,3)\n    dtype : dtype, optional \n        What dtype to return. Default will be floats\n\n    Returns\n    -------\n    lab : ndarray\n    '''\n    return xyz2lab(rgb2xyz(rgb), dtype=dtype)\n\ndef rgb2sepia(rgb):\n    '''\n    sepia = rgb2sepia(rgb)\n\n    Parameters\n    ----------\n    rgb : ndarray\n        Must be of shape (h,w,3)\n\n    Returns\n    -------\n    sepia : ndarray\n        Output is of same shape as ``rgb``\n    '''\n    rgb2sepia_weights = np.array([\n                [.393,.769,.189],\n                [.349,.686,.168],\n                [.272,.534,.131]])\n    sepia = _convert(rgb, rgb2sepia_weights, dtype=np.float32, funcname='rgb2sepia')\n    sepia = np.minimum(sepia,255)\n    sepia = np.maximum(sepia,0)\n    return sepia.astype(np.uint8)\n\n"""
mahotas/convolve.py,21,"b'# Copyright (C) 2010-2019, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# License: MIT (see COPYING file)\n\n\nimport numpy as np\nfrom . import _convolve\nfrom . import morph\nfrom .internal import _get_output, _normalize_sequence, _verify_is_floatingpoint_type, _as_floating_point_array\nfrom ._filters import mode2int, modes, _check_mode\n\n__all__ = [\n    \'convolve\',\n    \'convolve1d\',\n    \'daubechies\',\n    \'idaubechies\',\n    \'find\',\n    \'haar\',\n    \'ihaar\',\n    \'median_filter\',\n    \'rank_filter\',\n    \'template_match\',\n    \'gaussian_filter1d\',\n    \'gaussian_filter\',\n    \'wavelet_center\',\n    \'wavelet_decenter\',\n    \'laplacian_2D\'\n    ]\n\ndef convolve(f, weights, mode=\'reflect\', cval=0.0, out=None, output=None):\n    \'\'\'\n    convolved = convolve(f, weights, mode=\'reflect\', cval=0.0, out={new array})\n\n    Convolution of `f` and `weights`\n\n    Convolution is performed in `doubles` to avoid over/underflow, but the\n    result is then cast to `f.dtype`. **This conversion may result in\n    over/underflow when using small integer types or unsigned types (if the\n    output is negative).** Converting to a floating point representation avoids\n    this issue::\n\n        c = convolve(f.astype(float), kernel)\n\n    Parameters\n    ----------\n    f : ndarray\n        input. Any dimension is supported\n    weights : ndarray\n        weight filter. If not of the same dtype as `f`, it is cast\n    mode : {\'reflect\' [default], \'nearest\', \'wrap\', \'mirror\', \'constant\', \'ignore\'}\n        How to handle borders\n    cval : double, optional\n        If `mode` is constant, which constant to use (default: 0.0)\n    out : ndarray, optional\n        Output array. Must have same shape and dtype as `f` as well as be\n        C-contiguous.\n\n    Returns\n    -------\n    convolved : ndarray of same dtype as `f`\n    \'\'\'\n    weights = weights.astype(f.dtype, copy=False)\n    if f.ndim != weights.ndim:\n        raise ValueError(\'mahotas.convolve: `f` and `weights` must have the same dimensions\')\n    output = _get_output(f, out, \'convolve\', output=output)\n    _check_mode(mode, cval, \'convolve\')\n    return _convolve.convolve(f, weights, output, mode2int[mode])\n\n\ndef convolve1d(f, weights, axis, mode=\'reflect\', cval=0., out=None):\n    \'\'\'\n    convolved = convolve1d(f, weights, axis, mode=\'reflect\', cval=0.0, out={new array})\n\n    Convolution of `f` and `weights` along axis `axis`.\n\n    Convolution is performed in `doubles` to avoid over/underflow, but the\n    result is then cast to `f.dtype`.\n\n    Parameters\n    ----------\n    f : ndarray\n        input. Any dimension is supported\n    weights : 1-D ndarray\n        weight filter. If not of the same dtype as `f`, it is cast\n    axis : int\n        Axis along which to convolve\n    mode : {\'reflect\' [default], \'nearest\', \'wrap\', \'mirror\', \'constant\', \'ignore\'}\n        How to handle borders\n    cval : double, optional\n        If `mode` is constant, which constant to use (default: 0.0)\n    out : ndarray, optional\n        Output array. Must have same shape and dtype as `f` as well as be\n        C-contiguous.\n\n    Returns\n    -------\n    convolved : ndarray of same dtype as `f`\n\n    See Also\n    --------\n    convolve : function\n        generic convolution\n    \'\'\'\n    weights = np.asanyarray(weights)\n    weights = weights.squeeze()\n    if weights.ndim != 1:\n        raise ValueError(\'mahotas.convolve1d: only 1-D sequences allowed\')\n    _check_mode(mode, cval, \'convolve1d\')\n    if f.flags.contiguous and len(weights) < f.shape[axis]:\n        weights = weights.astype(np.double, copy=False)\n        indices = [a for a in range(f.ndim) if a != axis] + [axis]\n        rindices = [indices.index(a) for a in range(f.ndim)]\n        oshape = f.shape\n        f = f.transpose(indices)\n        tshape = f.shape\n        f = f.reshape((-1, f.shape[-1]))\n\n        out = _get_output(f, out, \'convolve1d\')\n        _convolve.convolve1d(f, weights, out, mode2int[mode])\n        out = out.reshape(tshape)\n        out = out.transpose(rindices)\n        out = out.reshape(oshape)\n        return out\n    else:\n        index = [None] * f.ndim\n        index[axis] = slice(0, None)\n        weights = weights[tuple(index)]\n        return convolve(f, weights, mode=mode, cval=cval, out=out)\n\n\ndef median_filter(f, Bc=None, mode=\'reflect\', cval=0.0, out=None, output=None):\n    \'\'\'\n    median = median_filter(f, Bc={square}, mode=\'reflect\', cval=0.0, out={np.empty(f.shape, f.dtype})\n\n    Median filter\n\n    Parameters\n    ----------\n    f : ndarray\n        input. Any dimension is supported\n    Bc : ndarray or int, optional\n        Defines the neighbourhood, default is a square of side 3.\n    mode : {\'reflect\' [default], \'nearest\', \'wrap\', \'mirror\', \'constant\', \'ignore\'}\n        How to handle borders\n    cval : double, optional\n        If `mode` is constant, which constant to use (default: 0.0)\n    out : ndarray, optional\n        Output array. Must have same shape and dtype as `f` as well as be\n        C-contiguous.\n\n    Returns\n    -------\n    median : ndarray of same type and shape as ``f``\n        median[i,j] is the median value of the points in f close to (i,j)\n    \'\'\'\n    if Bc is None:\n        Bc = np.ones((3,) * len(f.shape), f.dtype)\n    elif f.dtype != Bc.dtype:\n        Bc = Bc.astype(f.dtype)\n    if f.ndim != Bc.ndim:\n        raise ValueError(\'mahotas.median_filter: `f` and `Bc` must have the same number of dimensions\')\n    rank = Bc.sum()//2\n    output = _get_output(f, out, \'median_filter\', output=output)\n    _check_mode(mode, cval, \'median_filter\')\n    return _convolve.rank_filter(f, Bc, output, int(rank), mode2int[mode])\n\ndef mean_filter(f, Bc, mode=\'ignore\', cval=0.0, out=None):\n    \'\'\'mean = mean_filter(f, Bc, mode=\'ignore\', cval=0.0, out=None)\n\n    Mean filter. The value at ``mean[i,j]`` will be the mean of the values in\n    the neighbourhood defined by ``Bc``.\n\n    Parameters\n    ----------\n    f : ndarray\n        input. Any dimension is supported\n    Bc : ndarray\n        Defines the neighbourhood. Must be explicitly passed, no default.\n    mode : {\'reflect\', \'nearest\', \'wrap\', \'mirror\', \'constant\', \'ignore\' [ignore]}\n        How to handle borders. The default is to ignore points beyond the\n        border, so that the means computed near the border include fewer elements.\n    cval : double, optional\n        If `mode` is constant, which constant to use (default: 0.0)\n    out : ndarray, optional\n        Output array. Must be a double array with the same shape as `f` as well\n        as be C-contiguous.\n\n    Returns\n    -------\n    mean : ndarray of type double and same shape as ``f``\n\n    See Also\n    --------\n    median_filter : An alternative filtering method\n    \'\'\'\n    Bc = morph.get_structuring_elem(f, Bc)\n    out = _get_output(f, out, \'mean_filter\', dtype=np.float64)\n    _check_mode(mode, cval, \'mean_filter\')\n    return _convolve.mean_filter(f, Bc, out, mode2int[mode], cval)\n\n\ndef rank_filter(f, Bc, rank, mode=\'reflect\', cval=0.0, out=None, output=None):\n    \'\'\'\n    ranked = rank_filter(f, Bc, rank, mode=\'reflect\', cval=0.0, out=None)\n\n    Rank filter. The value at ``ranked[i,j]`` will be the ``rank``\\ th largest in\n    the neighbourhood defined by ``Bc``.\n\n    Parameters\n    ----------\n    f : ndarray\n        input. Any dimension is supported\n    Bc : ndarray\n        Defines the neighbourhood. Must be explicitly passed, no default.\n    rank : integer\n    mode : {\'reflect\' [default], \'nearest\', \'wrap\', \'mirror\', \'constant\', \'ignore\'}\n        How to handle borders\n    cval : double, optional\n        If `mode` is constant, which constant to use (default: 0.0)\n    out : ndarray, optional\n        Output array. Must have same shape and dtype as `f` as well as be\n        C-contiguous.\n\n    Returns\n    -------\n    ranked : ndarray of same type and shape as ``f``\n        ranked[i,j] is the ``rank``\\ th value of the points in f close to (i,j)\n\n    See Also\n    --------\n    median_filter : A special case of rank_filter\n    \'\'\'\n    Bc = morph.get_structuring_elem(f, Bc)\n    output = _get_output(f, out, \'rank_filter\', output=output)\n    _check_mode(mode, cval, \'rank_filter\')\n    return _convolve.rank_filter(f, Bc, output, rank, mode2int[mode])\n\n\ndef template_match(f, template, mode=\'reflect\', cval=0., out=None, output=None):\n    \'\'\'Match template to image\n\n    match = template_match(f, template, mode=\'reflect\', cval=0., out={np.empty_like(f)})\n\n    The value at ``match[i,j]`` will be the difference (in squared euclidean\n    terms), between `template` and a same sized window on `f` centered on that\n    point.\n\n    Note that the computation is performed using the same dtype as ``f``. Thus\n    is may overflow if the template is large.\n\n    Parameters\n    ----------\n    f : ndarray\n        input. Any dimension is supported\n    template : ndarray\n        Template to match. Must be explicitly passed, no default.\n    mode : {\'reflect\' [default], \'nearest\', \'wrap\', \'mirror\', \'constant\', \'ignore\'}\n        How to handle borders\n    cval : double, optional\n        If `mode` is constant, which constant to use (default: 0.0)\n    out : ndarray, optional\n        Output array. Must have same shape and dtype as `f` as well as be\n        C-contiguous.\n\n    Returns\n    -------\n    match : ndarray of same type and shape as ``f``\n        match[i,j] is the squared euclidean distance between\n        ``f[i-s0:i+s0,j-s1:j+s1]`` and ``template`` (for appropriately defined\n        ``s0`` and ``s1``).\n    \'\'\'\n    template = template.astype(f.dtype, copy=False)\n    output = _get_output(f, out, \'template_match\', output=output)\n    _check_mode(mode, cval, \'template_match\')\n    return _convolve.template_match(f, template, output, mode2int[mode], 0)\n\ndef find(f, template):\n    \'\'\'Match template to image exactly\n\n    coordinates = find(f, template)\n\n    The output is in the same format as the ``np.where`` function.\n\n    Parameters\n    ----------\n    f : ndarray\n        input. Currently, only 2-dimensional images are supported.\n    template : ndarray\n        Template to match. Must be explicitly passed, no default.\n\n    Returns\n    -------\n    match : np.array\n    coordinates : np.array\n        These are the coordinates of the match. The format is similar to the\n        output of ``np.where``, but in an ndarray.\n\n    \'\'\'\n    if f.ndim != 2:\n        raise ValueError(\'mahotas.find: Cannot handle multi-dimensional images\')\n    template = template.astype(f.dtype)\n    out = np.empty(f.shape, bool)\n    return _convolve.find2d(f, template, out)\n\n\ndef gaussian_filter1d(array, sigma, axis=-1, order=0, mode=\'reflect\', cval=0., out=None, output=None):\n    """"""\n    filtered = gaussian_filter1d(array, sigma, axis=-1, order=0, mode=\'reflect\', cval=0., out={np.empty_like(array)})\n\n    One-dimensional Gaussian filter.\n\n    Parameters\n    ----------\n    array : ndarray\n        input array of a floating-point type\n\n    sigma : float\n        standard deviation for Gaussian kernel (in pixel units)\n    axis : int, optional\n        axis to operate on\n    order : {0, 1, 2, 3}, optional\n        An order of 0 corresponds to convolution with a Gaussian\n        kernel. An order of 1, 2, or 3 corresponds to convolution with\n        the first, second or third derivatives of a Gaussian. Higher\n        order derivatives are not implemented\n    mode : {\'reflect\' [default], \'nearest\', \'wrap\', \'mirror\', \'constant\', \'ignore\'}\n        How to handle borders\n    cval : double, optional\n        If `mode` is constant, which constant to use (default: 0.0)\n    out : ndarray, optional\n        Output array. Must have same shape and dtype as `array` as well as be\n        C-contiguous.\n\n    Returns\n    -------\n    filtered : ndarray\n        Filtered version of `array`\n\n    """"""\n    _verify_is_floatingpoint_type(array, \'gaussian_filter1d\')\n    sigma = float(sigma)\n    s2 = sigma*sigma\n    # make the length of the filter equal to 4 times the standard\n    # deviations:\n    lw = int(4.0 * sigma + 0.5)\n    if lw <= 0:\n        raise ValueError(\'mahotas.gaussian_filter1d: sigma must be greater or equal to 0.125 [1/8]\')\n    x = np.arange(2*lw+1, dtype=float)\n    x -= lw\n    weights = np.exp(x*x/(-2.*s2))\n    weights /= np.sum(weights)\n    # implement first, second and third order derivatives:\n    if order == 0:\n        pass\n    elif order == 1 : # first derivative\n        weights *= -x/s2\n    elif order == 2: # second derivative\n        weights *= (x*x/s2-1.)/s2\n    elif order == 3: # third derivative\n        weights *= (3.0 - x*x/s2)*x/(s2*s2)\n    else:\n        raise ValueError(\'mahotas.convolve.gaussian_filter1d: Order outside 0..3 not implemented\')\n    return convolve1d(array, weights, axis, mode, cval, out=output)\n\n\ndef gaussian_filter(array, sigma, order=0, mode=\'reflect\', cval=0., out=None, output=None):\n    """"""\n    filtered = gaussian_filter(array, sigma, order=0, mode=\'reflect\', cval=0., out={np.empty_like(array)})\n\n    Multi-dimensional Gaussian filter.\n\n    Parameters\n    ----------\n    array : ndarray\n        input array, any dimension is supported. If the array is an integer\n        array, it will be converted to a double array.\n    sigma : scalar or sequence of scalars\n        standard deviation for Gaussian kernel. The standard\n        deviations of the Gaussian filter are given for each axis as a\n        sequence, or as a single number, in which case it is equal for\n        all axes.\n    order : {0, 1, 2, 3} or sequence from same set, optional\n        The order of the filter along each axis is given as a sequence\n        of integers, or as a single number.  An order of 0 corresponds\n        to convolution with a Gaussian kernel. An order of 1, 2, or 3\n        corresponds to convolution with the first, second or third\n        derivatives of a Gaussian. Higher order derivatives are not\n        implemented\n    mode : {\'reflect\' [default], \'nearest\', \'wrap\', \'mirror\', \'constant\', \'ignore\'}\n        How to handle borders\n    cval : double, optional\n        If `mode` is constant, which constant to use (default: 0.0)\n    out : ndarray, optional\n        Output array. Must have same shape as `array` as well as be\n        C-contiguous. If `array` is an integer array, this must be a double\n        array; otherwise, it must have the same type as `array`.\n\n    Returns\n    -------\n    filtered : ndarray\n        Filtered version of `array`\n\n    Notes\n    -----\n    The multi-dimensional filter is implemented as a sequence of\n    one-dimensional convolution filters. The intermediate arrays are\n    stored in the same data type as the output. Therefore, for output\n    types with a limited precision, the results may be imprecise\n    because intermediate results may be stored with insufficient\n    precision.\n    """"""\n    array = _as_floating_point_array(array)\n    output = _get_output(array, out, \'gaussian_filter\', output=output)\n    orders = _normalize_sequence(array, order, \'gaussian_filter\')\n    sigmas = _normalize_sequence(array, sigma, \'gaussian_filter\')\n    output[...] = array[...]\n    noutput = None\n    for axis in range(array.ndim):\n        sigma = sigmas[axis]\n        order = orders[axis]\n        noutput = gaussian_filter1d(output, sigma, axis, order, mode, cval, noutput)\n        output,noutput = noutput,output\n    return output\n\ndef _wavelet_array(f, inline, func):\n    f = _as_floating_point_array(f)\n    if f.ndim != 2:\n        raise ValueError(\'mahotas.convolve.%s: Only works for 2D images\' % func)\n    if not inline:\n        return f.copy()\n    return f\n\n\n\ndef _wavelet_center_compute(oshape, border=0, dtype=None, cval=0.0):\n    for c in range(1, 16+border):\n        nshape = 2**(np.floor(np.log2(oshape))+c)\n        nshape = nshape.astype(int, copy=False)\n        delta = nshape - oshape\n        delta //= 2\n        if np.min(delta) <= border:\n            continue\n        position = []\n        for d,e in zip(delta, oshape):\n            position.append( slice(d, d + e) )\n        return nshape, position\n\ndef wavelet_center(f, border=0, dtype=float, cval=0.0):\n    \'\'\'\n    fc = wavelet_center(f, border=0, dtype=float, cval=0.0)\n\n    ``fc`` is a centered version of ``f`` with a shape that is composed of\n    powers of 2.\n\n    Parameters\n    ----------\n    f : ndarray\n        input image\n    border : int, optional\n        The border to use (default is no border)\n    dtype : type, optional\n        Type of ``fc``\n    cval : float, optional\n        Which value to fill the border with (default is 0)\n\n    Returns\n    -------\n    fc : ndarray\n\n    See Also\n    --------\n    wavelet_decenter : function\n        Reverse function\n    \'\'\'\n    nshape, position = _wavelet_center_compute(f.shape, border)\n    nimage = np.zeros(nshape, dtype=dtype)\n    nimage += cval\n    nimage[position] = f\n    return nimage\n\n\ndef wavelet_decenter(w, oshape, border=0):\n    \'\'\'\n    f = wavelet_decenter(w, oshape, border=0)\n\n    Undoes the effect of ``wavelet_center``\n\n    Parameters\n    ----------\n    w : ndarray\n        Wavelet array\n    oshape : tuple\n        Desired shape\n    border : int, optional\n        The desired border. This **must** be the same value as was used for\n        ``wavelet_center`` \n\n    Returns\n    -------\n    f : ndarray\n        This will have shape ``oshape``\n\n    See Also\n    --------\n    wavelet_center : function\n        Forward function\n    \'\'\'\n    nshape, position = _wavelet_center_compute(oshape, border)\n    return w[position]\n\n\n\ndef haar(f, preserve_energy=True, inline=False):\n    \'\'\'\n    t = haar(f, preserve_energy=True, inline=False)\n\n    Haar transform\n\n    Parameters\n    ----------\n    f : 2-D ndarray\n        Input image\n    preserve_energy : bool, optional\n        Whether to normalise the result so that energy is preserved (the\n        default).\n    inline : bool, optional\n        Whether to write the results to the input image. By default, a new\n        image is returned. Integer images are always converted to floating\n        point and copied.\n\n    See Also\n    --------\n    ihaar : function\n        Reverse Haar transform\n    \'\'\'\n    f = _wavelet_array(f, inline, \'haar\')\n    _convolve.haar(f)\n    _convolve.haar(f.T)\n    if preserve_energy:\n        f /= 2.0\n    return f\n\n_daubechies_codes = [(\'D%s\' % ci) for ci in range(2,21,2)]\ndef _daubechies_code(c):\n    try:\n        return _daubechies_codes.index(c)\n    except:\n        raise ValueError(\'mahotas.convolve: Known daubechies codes are {0}. You passed in {1}.\'.format(_daubechies_codes, c))\n\ndef daubechies(f, code, inline=False):\n    \'\'\'\n    filtered = daubechies(f, code, inline=False)\n\n    Daubechies wavelet transform\n\n    This function works best if the image sizes are powers of 2!\n\n    Parameters\n    ----------\n    f : ndarray\n        2-D image\n    code : str\n        One of \'D2\', \'D4\', ... \'D20\'\n    inline : bool, optional\n        Whether to write the results to the input image. By default, a new\n        image is returned. Integer images are always converted to floating\n        point and copied.\n\n    See Also\n    --------\n    haar : function\n        Haar transform (equivalent to D2)\n    \'\'\'\n    f = _wavelet_array(f, inline, \'daubechies\')\n    code = _daubechies_code(code)\n    _convolve.daubechies(f, code)\n    _convolve.daubechies(f.T, code)\n    return f\n\n\ndef idaubechies(f, code, inline=False):\n    \'\'\'\n    rfiltered = idaubechies(f, code, inline=False)\n\n    Daubechies wavelet inverse transform\n\n    Parameters\n    ----------\n    f : ndarray\n        2-D image\n    code : str\n        One of \'D2\', \'D4\', ... \'D20\'\n    inline : bool, optional\n        Whether to write the results to the input image. By default, a new\n        image is returned. Integer images are always converted to floating\n        point and copied.\n\n    See Also\n    --------\n    haar : function\n        Haar transform (equivalent to D2)\n    \'\'\'\n    f = _wavelet_array(f, inline, \'idaubechies\')\n    code = _daubechies_code(code)\n    _convolve.idaubechies(f.T, code)\n    _convolve.idaubechies(f, code)\n    return f\n\n\ndef ihaar(f, preserve_energy=True, inline=False):\n    \'\'\'\n    t = ihaar(f, preserve_energy=True, inline=False)\n\n    Reverse Haar transform\n\n    ``ihaar(haar(f))`` is more or less equal to ``f`` (equal, except for\n    possible rounding issues).\n\n    Parameters\n    ----------\n    f : 2-D ndarray\n        Input image. If it is an integer image, it is converted to floating\n        point (double).\n    preserve_energy : bool, optional\n        Whether to normalise the result so that energy is preserved (the\n        default).\n    inline : bool, optional\n        Whether to write the results to the input image. By default, a new\n        image is returned. Integer images are always converted to floating\n        point and copied.\n\n    Returns\n    -------\n    f : ndarray\n\n    See Also\n    --------\n    haar : function\n        Forward Haar transform\n    \'\'\'\n    f = _wavelet_array(f, inline, \'ihaar\')\n    _convolve.ihaar(f)\n    _convolve.ihaar(f.T)\n    if preserve_energy:\n        f *= 2.0\n    return f\n\ndef laplacian_2D(array, alpha = 0.2):\n    """"""\n    filtered = laplacian_2D(array, alpha = 0.2)\n\n    2D Laplacian filter.\n\n    Parameters\n    ----------\n    array : ndarray\n        input 2D array. If the array is an integer array, it will be converted \n        to a double array.\n    alpha : scalar or sequence of scalars\n        controls the shape of Laplacian operator. Must be 0-1. A larger values \n        makes the operator empahsize the diagonal direction.\n\n    Returns\n    -------\n    filtered : ndarray\n        Filtered version of `array`\n    """"""\n    array = np.array(array, dtype=np.float)\n    if array.ndim != 2:\n        raise ValueError(\'mahotas.laplacian_2D: Only available for 2-dimensional arrays\')\n        \n    alpha = max(0, min(alpha,1));\n    ver_hor_weight = (1. - alpha) / (alpha + 1.)\n    diag_weight = alpha / (alpha + 1.)\n    center = -4. / (alpha + 1.)\n    weights = np.array([\n    [diag_weight, ver_hor_weight, diag_weight],\n    [ver_hor_weight, center, ver_hor_weight],\n    [diag_weight, ver_hor_weight, diag_weight]])\n    \n    output = convolve(array, weights, mode=\'nearest\')\n    return output\n'"
mahotas/distance.py,4,"b""# Copyright (C) 2010-2013, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# \n# License: MIT (see COPYING file)\n\nfrom . import _distance\nfrom . import _morph\nimport numpy as np\n\n__all__ = [\n    'distance',\n    ]\n\ndef distance(bw, metric='euclidean2'):\n    '''\n    dmap = distance(bw, metric='euclidean2')\n\n    Computes the distance transform of image `bw`::\n\n        dmap[i,j] = min_{i', j'} { (i-i')**2 + (j-j')**2 | !bw[i', j'] }\n\n    That is, at each point, compute the distance to the background.\n\n    If there is no background, then a very high value will be returned in all\n    pixels (this is a sort of infinity).\n\n    Parameters\n    ----------\n    bw : ndarray\n        If boolean, ``False`` will denote the background and ``True`` the\n        foreground. If not boolean, this will be interpreted as ``bw != 0``\n        (this way you can use labeled images without any problems).\n    metric : str, optional\n        one of 'euclidean2' (default) or 'euclidean'\n\n    Returns\n    -------\n    dmap : ndarray\n        distance map\n\n    References\n    ----------\n    For 2-D images, the following algorithm is used:\n\n    Felzenszwalb P, Huttenlocher D. *Distance transforms of sampled functions.\n    Cornell Computing and Information.* 2004.\n\n    Available at:\n    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.1647&rep=rep1&type=pdf.\n\n    For n-D images (with n > 2), a slower hand-craft method is used.\n    '''\n    if bw.dtype != np.bool_:\n        bw = (bw != 0)\n    f = np.zeros(bw.shape, np.double)\n    if bw.ndim == 2:\n        f[bw] = len(f.shape)*max(f.shape)**2+1\n        _distance.dt(f, None)\n    else:\n        f.fill(f.size*2)\n        Bc = np.ones([3 for _ in bw.shape], bool)\n        _morph.distance_multi(f, bw, Bc)\n    if metric == 'euclidean':\n        np.sqrt(f,f)\n    return f\n\n\n"""
mahotas/edge.py,35,"b""# -*- coding: utf-8 -*-\n# Copyright (C) 2008-2014, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# \n# License: MIT (see COPYING file)\n\nfrom __future__ import division\nimport numpy as np\nimport mahotas as mh\nfrom . import convolve, gaussian_filter\n\n_hsobel_filter = np.array([\n    [-1, 0, 1],\n    [-2, 0, 2],\n    [-1, 0, 1]])/8.\n\n_vsobel_filter = np.array([\n    [-1, -2, -1],\n    [ 0,  0,  0],\n    [ 1,  2,  1]])/8.\n\n__all__ = [\n    'sobel',\n    'dog',\n    ]\n\ndef sobel(img, just_filter=False):\n    '''\n    edges = sobel(img, just_filter=False)\n\n    Compute edges using Sobel's algorithm\n\n    `edges` is a binary image of edges computed according to Sobel's algorithm.\n\n    This implementation is tuned to match MATLAB's implementation.\n\n    Parameters\n    ----------\n    img : Any 2D-ndarray\n    just_filter : boolean, optional\n        If true, then return the result of filtering the image with the sobel\n        filters, but do not threashold (default is False).\n\n    Returns\n    -------\n    edges : ndarray\n        Binary image of edges, unless `just_filter`, in which case it will be\n        an array of floating point values.\n    '''\n    # This is based on Octave's implementation,\n    # but with some reverse engineering to match Matlab exactly\n    img = np.array(img, dtype=np.float)\n    if img.ndim != 2:\n        raise ValueError('mahotas.sobel: Only available for 2-dimensional images')\n    img -= img.min()\n    ptp = img.ptp()\n    if ptp == 0:\n        return img\n    img /= ptp\n    # Using 'nearest' seems to be MATLAB's implementation\n    vfiltered = convolve(img, _vsobel_filter, mode='nearest')\n    hfiltered = convolve(img, _hsobel_filter, mode='nearest')\n    vfiltered **= 2\n    hfiltered **= 2\n    filtered = vfiltered\n    filtered += hfiltered\n    if just_filter:\n        return filtered\n    thresh = 2*np.sqrt(filtered.mean())\n    return mh.regmax(filtered) * (np.sqrt(filtered) > thresh)\n\ndef dog(img, sigma1 = 2, multiplier = 1.001, just_filter = False):\n    '''\n    edges = dog(img, sigma1 = 2, thresh= None, just_filter = False)\n\n    Compute edges using the Difference of Gaussian (DoG) operator.\n\n    `edges` is a binary image of edges.\n\n    Parameters\n    ----------\n    img : Any 2D-ndarray\n    sigma1 : the sigma value of the first Gaussian filter. The second filter \n        will have sigma value 1.001*sigma1\n    multiplier : the multiplier to get sigma2. sigma2 = sigma1 * multiplier\n    just_filter : boolean, optional\n        If true, then return the result of filtering the image with the DoG\n        filters, no zero-crossing is detected (default is False).\n      \n    Returns\n    -------\n    edges : ndarray\n        Binary image of edges, unless `just_filter`, in which case it will be\n        an array of floating point values.\n    '''\n    img = np.array(img, dtype=np.float)\n    if img.ndim != 2:\n        raise ValueError('mahotas.dog: Only available for 2-dimensional images')\n\n    sigma2 = sigma1 * multiplier\n    \n    G1 = gaussian_filter(img, sigma1, mode = 'nearest')\n    G2 = gaussian_filter(img, sigma2, mode = 'nearest')\n    DoG = G2 - G1\n    \n    (m, n) = img.shape\n    if not just_filter:\n        e = np.zeros((m, n), dtype=bool)\n    else:\n        return DoG\n        \n    thresh = .75 * np.mean(abs(DoG))\n\n    \n    # Look for the zero crossings:  +-, -+ and their transposes\n    # Choose the edge to be the negative point\n    rr = np.arange(1, m-2)\n    cc = np.arange(1, n-2)\n\n    (rx,cx) = np.nonzero(\n        np.logical_and(np.logical_and(DoG[np.ix_(rr,cc)] < 0, DoG[np.ix_(rr,cc+1)] > 0), \n                       abs( DoG[np.ix_(rr,cc)] - DoG[np.ix_(rr,cc+1)]) > thresh) )   # [- +]\n    e[(rx,cx)] = 1\n    (rx,cx) = np.nonzero(\n        np.logical_and(np.logical_and(DoG[np.ix_(rr,cc-1)] > 0, DoG[np.ix_(rr,cc+1)] < 0), \n                       abs( DoG[np.ix_(rr,cc-1)] - DoG[np.ix_(rr,cc)]) > thresh) )   # [+ -]\n    e[(rx,cx)] = 1\n    (rx,cx) = np.nonzero(\n        np.logical_and(np.logical_and(DoG[np.ix_(rr,cc)] < 0, DoG[np.ix_(rr+1,cc)] > 0), \n                       abs( DoG[np.ix_(rr,cc)] - DoG[np.ix_(rr+1,cc)]) > thresh) )   # [- +]'\n    e[(rx,cx)] = 1    \n    (rx,cx) = np.nonzero(\n        np.logical_and(np.logical_and(DoG[np.ix_(rr-1,cc)] > 0, DoG[np.ix_(rr,cc)] < 0), \n                       abs( DoG[np.ix_(rr-1,cc)] - DoG[np.ix_(rr,cc)]) > thresh) )   # [+ -]'\n    e[(rx,cx)] = 1\n    \n    # Another case: DoG can be precisely zero\n    (rz,cz) = np.nonzero(DoG[np.ix_(rr,cc)] == 0)\n    if rz.size != 0:\n        # Look for the zero crossings: +0-, -0+ and their transposes\n        # The edge lies on the Zero point\n        \n        (rx,cx) = np.nonzero(\n            np.logical_and(np.logical_and(DoG[np.ix_(rz,cz-1)] < 0, DoG[np.ix_(rz,cz+1)] > 0), \n                           abs( DoG[np.ix_(rz,cz+1)] - DoG[np.ix_(rz,cz-1)]) > thresh) )   # [- 0 +]\n        e[(rx,cx)] = 1  \n        (rx,cx) = np.nonzero(\n            np.logical_and(np.logical_and(DoG[np.ix_(rz,cz-1)] > 0, DoG[np.ix_(rz,cz+1)] < 0), \n                           abs( DoG[np.ix_(rz,cz-1)] - DoG[np.ix_(rz,cz+1)]) > thresh) )   # [+ 0 -]\n        e[(rx,cx)] = 1\n        (rx,cx) = np.nonzero(\n            np.logical_and(np.logical_and(DoG[np.ix_(rz-1,cz)] < 0, DoG[np.ix_(rz+1,cz)] > 0), \n                           abs( DoG[np.ix_(rz+1,cz)] - DoG[np.ix_(rz-1,cz)]) > thresh) )   # [- 0 +]'\n        e[(rx,cx)] = 1\n        (rx,cx) = np.nonzero(\n            np.logical_and(np.logical_and(DoG[np.ix_(rz-1,cz)] > 0, DoG[np.ix_(rz+1,cz)] < 0), \n                           abs( DoG[np.ix_(rz-1,cz)] - DoG[np.ix_(rz+1,cz)]) > thresh) )   # [+ 0 -]'\n        e[(rx,cx)] = 1\n        \n    return e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"""
mahotas/euler.py,5,"b""# Copyright (C) 2008-2019, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# License: MIT\n\nimport numpy as np\nfrom .convolve import convolve\n\n_euler_lookup4 = np.array([\n            0,  1,  1,  0,\n            1,  0,  2, -1,\n            1,  2,  0, -1,\n            0, -1, -1,  0,\n            ])/4.\n_euler_lookup8 = np.array([\n            0,  1,  1,  0,\n            1,  0, -2, -1,\n            1, -2,  0, -1,\n            0, -1, -1,  0,\n            ])/4.\n_powers = np.array([\n    [1, 2],\n    [4, 8]\n    ])\n\n__all__ = ['euler']\n\ndef euler(f, n=8, mode='constant'):\n    '''\n    euler_nr = euler(f, n=8)\n\n    Compute the Euler number of image f\n\n    The Euler number is also known as the Euler characteristic given that many\n    other mathematical objects are also known as Euler numbers.\n\n    Parameters\n    ----------\n    f : ndarray\n        A 2-D binary image\n    n : int, optional\n        Connectivity, one of (4,8). default: 8\n    mode : {'reflect', 'nearest', 'wrap', 'mirror', 'constant' [default]}\n        How to handle borders        \n\n    Returns\n    -------\n    euler_nr : int\n        Euler number\n\n    References\n    ----------\n    http://en.wikipedia.org/wiki/Euler_characteristic\n\n    References\n    ----------\n    The following algorithm is used:\n\n    *A Fast Algorithm for Computing the Euler Number of an Image and its VLSI\n    Implementation*, doi: 10.1109/ICVD.2000.812628\n    '''\n    if n == 8:\n        lookup = _euler_lookup8\n    elif n == 4:\n        lookup = _euler_lookup4\n    else:\n        raise ValueError('mahotas.euler: Connectivity must be 4 or 8')\n    if f.dtype is not np.bool:\n        assert np.all( (f == 0) | (f == 1)), 'mahotas.euler: Non-binary image'\n        f = (f != 0)\n    value = convolve(f.astype(_powers.dtype, copy=False), _powers, mode=mode)\n    return lookup[value].sum()\n\n"""
mahotas/features_cli.py,1,"b'#!/usr/bin/env python\n\nimport sys\nfrom os import path\nimport numpy as np\nimport mahotas as mh\nimport argparse\nfrom itertools import chain\n\nRED = \'\\033[91m\'\nGREEN = \'\\033[92m\'\nYELLOW = \'\\033[93m\'\nLIGHT_PURPLE = \'\\033[94m\'\nPURPLE = \'\\033[95m\'\nEND = \'\\033[0m\'\n\ndef print_error(text, color=True):\n    \'\'\'Prints error message\n\n    Arguments\n    ---------\n    text : str\n        Error message\n    color : bool, optional\n        Whether to print in colour.\n    \'\'\'\n    if color and sys.stderr.isatty():\n        sys.stderr.write(""{}ERROR: {}{}\\n"".format(RED, text, END))\n    else:\n        sys.stderr.write(""ERROR: {}\\n"".format(text))\n\n\ndef read_bw(fname, options):\n    \'\'\'Read image `fname` as greyscale\n\n    Parameters\n    ----------\n    fname : str, file-name\n    options : argparse result\n\n    Returns\n    -------\n    image : ndarray\n        Two dimensional ndarray\n    \'\'\'\n    im = mh.imread(fname)\n    if im.ndim == 2:\n        return im\n    if im.ndim == 3:\n        if options.convert_to_bw == \'max\' or im.ptp(2).max() == 0:\n            # This is a greyscale image, saved as colour\n            return im.max(2)\n        if options.convert_to_bw == \'yes\':\n            return mh.colors.rgb2grey(im, dtype=np.uint8)\n    print_error(""{} is not a greyscale image (and --convert-to-bw was not specified)"".format(fname), not options.no_color)\n    sys.exit(1)\n\ndef _write_row(output, items, header=None):\n    if header:\n        output.write(header)\n    for it in items:\n        output.write(\'\\t\')\n        output.write(str(it))\n    output.write(\'\\n\')\n\ndef main():\n    sys.stderr.write(mh.citation(print_out=False, short=True))\n    sys.stderr.write(\'\\n\\n\')\n    parser = argparse.ArgumentParser(\n            description=\'Compute features using mahotas\')\n    parser.add_argument(\n                    \'fnames\', metavar=\'input_file_name\', nargs=\'+\', type=str,\n                            help=\'Image files names\')\n    parser.add_argument(\n                    \'--output\', default=\'features.tsv\', type=str,\n                            help=\'Output file for feature files\')\n    parser.add_argument(\n                    \'--clobber\', default=False, action=\'store_true\',\n                            help=\'Overwrite output file (if it exists)\')\n    parser.add_argument(\n                    \'--convert-to-bw\', default=\'no\',\n                    help=\'Convert color images to greyscale.\\nAcceptable values:\\n\\tno: raises an error (default)\' +\n                        \'\\n\\tmax: use max projection\' +\n                        \'\\n\\tyes: use rgb2gray\')\n    parser.add_argument(\n                    \'--no-color\', default=False, action=\'store_true\',\n                            help=\'Do not print in color (for error and warning messages)\')\n    parser.add_argument(\n                    \'--haralick\', default=False, action=\'store_true\',\n                            help=\'Compute Haralick features\')\n    parser.add_argument(\n                    \'--lbp\', default=False, action=\'store_true\',\n                            help=\'Compute LBP (linear binary patterns) features\')\n    parser.add_argument(\n                    \'--lbp-radius\', default=8, action=\'store\', type=int,\n                            help=\'Radius to use for LBP features\')\n    parser.add_argument(\n                    \'--lbp-points\', default=6, action=\'store\', type=int,\n                            help=\'Nr of points to use for LBP features\')\n    args = parser.parse_args()\n    if not (args.haralick or args.lbp):\n        sys.stderr.write(\'\'\'\\\nNo features selected. Doing nothing.\n\nFor example, use --haralick switch to compute Haralick features\\n\'\'\')\n        sys.exit(1)\n\n    if not args.clobber and path.exists(args.output):\n        print_error(\'Output file ({}) already exists. Refusing to overwrite results without --clobber argument.\'.format(args.output))\n        sys.exit(2)\n\n    output = open(args.output, \'w\')\n    colnames = []\n    if args.haralick:\n        hlabels = mh.features.texture.haralick_labels[:-1]\n        colnames.extend([""mean:{}"".format(ell) for ell in hlabels])\n        colnames.extend([""ptp:{}"".format(ell) for ell in hlabels])\n    if args.lbp:\n        from mahotas.features.lbp import lbp_names\n        colnames.extend(lbp_names(args.lbp_radius, args.lbp_points))\n    _write_row(output, colnames)\n\n    for fname in args.fnames:\n        cur = []\n        im = read_bw(fname, args)\n        if args.haralick:\n            har = mh.features.haralick(im, return_mean_ptp=True)\n            cur.append(har)\n        if args.lbp:\n            cur.append(mh.features.lbp(im, args.lbp_radius, args.lbp_points))\n\n        _write_row(output, chain.from_iterable(cur), fname)\n    output.close()\n\nif __name__ == \'__main__\':\n    main()\n'"
mahotas/freeimage.py,0,b'from .io.freeimage import *\n'
mahotas/histogram.py,5,"b'# -*- coding: utf-8 -*-\n# Copyright (C) 2009-2010, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n#  of this software and associated documentation files (the ""Software""), to deal\n#  in the Software without restriction, including without limitation the rights\n#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n#  copies of the Software, and to permit persons to whom the Software is\n#  furnished to do so, subject to the following conditions:\n# \n# The above copyright notice and this permission notice shall be included in\n#  all copies or substantial portions of the Software.\n# \n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n#  THE SOFTWARE.\n\n\'\'\'\nHistogram\n\n:fullhistogram():\n    Compute the full histogram for an image.\n\n\n\'\'\'\n\nfrom __future__ import division\nimport numpy as np\nfrom . import _histogram\nfrom .internal import _verify_is_integer_type\n\n__all__ = [\'fullhistogram\']\n\ndef fullhistogram(img):\n    """"""\n    hist = fullhistogram(img)\n\n    Return a histogram with bins *0, 1, ..., ``img.max()``*.\n\n    After calling this function, it will be true that\n    ``hist[i] == (img == i).sum()``, for all ``i``.\n\n    Notes\n    -----\n    Only handles unsigned integer arrays.\n\n    Parameters\n    ----------\n    img : array-like of an unsigned type\n        input image.\n\n    Returns\n    -------\n    hist : an dnarray of type np.uint32\n        This will be of size ``img.max() + 1``.\n    """"""\n    _verify_is_integer_type(img, \'fullhistogram\')\n    img = np.ascontiguousarray(img)\n    if img.dtype == np.bool:\n        ones = img.sum()\n        zeros = img.size - ones\n        return np.array([zeros, ones], np.uintc)\n\n    histogram = np.zeros(int(img.max()) + 1, np.uintc)\n    _histogram.histogram(img, histogram)\n    return histogram\n\n\n'"
mahotas/internal.py,8,"b'# Copyright (C) 2011-2019, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# License: MIT (see COPYING file)\nimport numpy as np\n\ndef _get_output(array, out, fname, dtype=None, output=None):\n    \'\'\'\n    output = _get_output(array, out, fname, dtype=None, output=None)\n\n    Implements the mahotas output convention:\n        (1) if `out` is None, return np.empty(array.shape, array.dtype)\n        (2) else verify that output is of right size, shape, and contiguous\n\n    Parameters\n    ----------\n    array : ndarray\n    out : ndarray or None\n    fname : str\n        Function name. Used in error messages\n\n    Returns\n    -------\n    output : ndarray\n    \'\'\'\n    detail = \'.\\nWhen an output argument is used, the checking is very strict as this is a performance feature.\'\n    if dtype is None:\n        dtype = array.dtype\n    if output is not None: # pragma: no cover\n        import warnings\n        warnings.warn(\'Using deprecated `output` argument in function `%s`. Please use `out` in the future. It has exactly the same meaning and it matches what numpy uses.\' % fname, DeprecationWarning)\n        if out is not None:\n            warnings.warn(\'Using both `out` and `output` in function `%s`.\\nMahotas is going to ignore the `output` argument and use the `out` version exclusively.\' % fname)\n        else:\n            out = output\n    if out is None:\n        return np.empty(array.shape, dtype)\n    if out.dtype != dtype:\n        raise ValueError(\n            \'mahotas.%s: `out` has wrong type (out.dtype is %s; expected %s)%s\' %\n                (fname, out.dtype, dtype, detail))\n    if out.shape != array.shape:\n        raise ValueError(\'mahotas.%s: `out` has wrong shape (got %s, while expecting %s)%s\' % (fname, out.shape, array.shape, detail))\n    if not out.flags.contiguous:\n        raise ValueError(\'mahotas.%s: `out` is not c-array%s\' % (fname,detail))\n    return out\n\ndef _get_axis(array, axis, fname):\n    \'\'\'\n    axis = _get_axis(array, axis, fname)\n\n    Checks that ``axis`` is a valid axis of ``array`` and normalises it.\n\n    Parameters\n    ----------\n    array : ndarray\n    axis : int\n    fname : str\n        Function name. Used in error messages\n\n    Returns\n    -------\n    axis : int\n        The positive index of the axis to use\n    \'\'\'\n    if axis < 0:\n        axis += len(array.shape)\n    if not (0 <= axis < len(array.shape)):\n        raise ValueError(\'mahotas.%s: `axis` is out of bounds (maximum was %s, got %s)\' % (fname, array.ndim, axis))\n    return axis\n\ndef _normalize_sequence(array, value, fname):\n    \'\'\'\n    values = _normalize_sequence(array, value, fname)\n\n    If `value` is a sequence, checks that it has an element for each dimension\n    of `array`. Otherwise, returns a sequence that repeats `value` once for\n    each dimension of array.\n\n    Parameters\n    ----------\n    array : ndarray\n    value : sequence or scalar\n    fname : str\n        Function name. Used in error messages\n\n    Returns\n    -------\n    values : sequence\n    \'\'\'\n    try:\n        value = list(value)\n    except TypeError:\n        return [value for s in array.shape]\n    if len(value) != array.ndim:\n        raise ValueError(\'mahotas.%s: argument is sequence, but has wrong size (%s for an array of %s dimensions)\' % (fname, len(value), array.ndim))\n    return value\n\ndef _verify_is_floatingpoint_type(A, function_name):\n    \'\'\'\n    _verify_is_integer_type(array, ""function"")\n\n    Checks that ``A`` is a floating-point array. If it is not, it raises\n    ``TypeError``.\n\n    Parameters\n    ----------\n    A : ndarray\n    function_name : str\n        Used for error messages\n    \'\'\'\n    if not np.issubdtype(A.dtype, np.floating):\n        raise TypeError(\'mahotas.{}: This function only accepts floating-point types (passed array of type {})\'.format(function_name, A.dtype))\n\ndef _verify_is_integer_type(A, function_name):\n    \'\'\'\n    _verify_is_integer_type(array, ""function"")\n\n    Checks that ``A`` is an integer array. If it is not, it raises\n    ``TypeError``.\n\n    Parameters\n    ----------\n    A : ndarray\n    function_name : str\n        Used for error messages\n    \'\'\'\n    k = A.dtype.kind\n    if k not in ""iub"": # integer, unsigned integer, boolean\n        raise TypeError(\'mahotas.%s: This function only accepts integer types (passed array of type %s)\' % (function_name, A.dtype))\n\ndef _verify_is_nonnegative_integer_type(A, function_name):\n    \'\'\'\n    _verify_is_nonnegative_integer_type(array, ""function"")\n\n    Checks that ``A`` is an unsigned integer array. If it is not, it raises\n    ``TypeError``.\n\n    Parameters\n    ----------\n    A : ndarray\n    function_name : str\n        Used for error messages\n    \'\'\'\n    _verify_is_integer_type(A, function_name)\n    if A.dtype.kind == \'i\' and not np.all(A >= 0):\n        raise ValueError(\'mahotas.{0}: This function only accepts positive integer types (passed array of type {1})\'.format(function_name, A.dtype))\n\ndef _make_binary(array):\n    \'\'\'\n    bin = _make_binary(array)\n\n    Returns (possibly a copy) of array as a boolean array\n    \'\'\'\n    array = np.asanyarray(array)\n    if array.dtype != bool:\n        return (array != 0)\n    return array\n\ndef _as_floating_point_array(array):\n    \'\'\'\n    array = _as_floating_point_array(array)\n\n    Returns (possibly a copy) of array as a floating-point array\n    \'\'\'\n    array = np.asanyarray(array)\n    if not np.issubdtype(array.dtype, np.floating):\n        return array.astype(np.double)\n    return array\n\n\ndef _check_3(arr, funcname):\n    if arr.ndim != 3 or arr.shape[2] != 3:\n        raise ValueError(\'mahotas.%s: this function expects an array of shape (h, w, 3), received an array of shape %s.\' % (funcname, arr.shape))\n\ndef _check_2(arr, funcname):\n    if arr.ndim != 2:\n        raise ValueError(\'mahotas.%s: this function can only handle 2D arrays (passed array with shape %s).\' % (funcname, arr.shape))\n'"
mahotas/interpolate.py,18,"b'# This module was adapted from scipy.ndimage and retains its license\n# Copyright (C) 2003-2005 Peter J. Verveer\n# Copyright (C) 2011-2019 Luis Pedro Coelho\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above\n#    copyright notice, this list of conditions and the following\n#    disclaimer in the documentation and/or other materials provided\n#    with the distribution.\n#\n# 3. The name of the author may not be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS\'\' AND ANY EXPRESS\n# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\'\'\'\nInterpolation\n-------------\n\nThis module was adapted from scipy.ndimage\n\'\'\'\n\nimport numpy as np\nfrom . import internal\nfrom . import _interpolate\nfrom ._filters import mode2int, modes, _check_mode\n\ndef _check_interpolate(array, order, funcname):\n    if not (0 < order < 5):\n        raise ValueError(\'mahotas.interpolate.%s: spline order not supported\' % funcname)\n\n    array = np.asarray(array)\n    if np.iscomplexobj(array):\n        raise TypeError(\'mahotas.interpolate.%s: Complex type not supported\' % funcname)\n    return array\n\ndef spline_filter1d(array, order=3, axis=-1, out=None, dtype=np.float64, output=None):\n    """"""\n    Calculates a one-dimensional spline filter along the given axis.\n\n    The lines of the array along the given axis are filtered by a\n    spline filter. The order of the spline must be >= 2 and <= 5.\n\n    Parameters\n    ----------\n    array : array_like\n        The input array.\n    order : int, optional\n        The order of the spline, default is 3.\n    axis : int, optional\n        The axis along which the spline filter is applied. Default is the last\n        axis.\n    out : ndarray, optional\n        The array in which to place the output\n    dtype : dtype, optional\n        The dtype to use for computation (default: np.float64)\n\n    For compatibility with scipy.ndimage, you can pass a dtype as the\n    ``output`` argument. This will work as having passed it as a dtype.\n    However, this is deprecated and should not be used in new code.\n\n    Returns\n    -------\n    return_value : ndarray or None\n        The filtered input.\n    """"""\n    array = _check_interpolate(array, order, \'spline_filter1d\')\n    if isinstance(out, type): # pragma: no cover\n        import warnings\n        warnings.warn(\'mahotas.interpolate.spline_filter1d: Use `dtype` for type instead of `out`\', DeprecationWarning)\n        dtype = out\n        out = None\n    if isinstance(output, type): # pragma: no cover\n        import warnings\n        warnings.warn(\'mahotas.interpolate.spline_filter1d: Use `dtype` for type instead of `output`\', DeprecationWarning)\n        dtype = output\n        output = None\n    output = internal._get_output(array, out, \'interpolate.spline_filter1d\', dtype=dtype, output=output)\n    output[...] = array\n    axis = internal._get_axis(array, axis, \'interpolate.spline_filter1d\')\n    _interpolate.spline_filter1d(output, order, axis)\n    return output\n\n\ndef spline_filter(array, order=3, out=None, dtype=np.float64, output=None):\n    """"""\n    Multi-dimensional spline filter.\n\n    Parameters\n    ----------\n    array : array_like\n        The input array.\n    order : int, optional\n        The order of the spline, default is 3.\n        axis.\n    out : ndarray, optional\n        The array in which to place the output\n    dtype : dtype, optional\n        The dtype to use for computation (default: np.float64)\n\n    For compatibility with scipy.ndimage, you can pass a dtype as the\n    ``out`` argument. This will work as having passed it as a dtype.  However,\n    this is deprecated and should not be used in new code.\n\n    Returns\n    -------\n    return_value : ndarray or None\n        The filtered input.\n\n    See Also\n    --------\n    spline_filter1d\n\n    Notes\n    -----\n    The multi-dimensional filter is implemented as a sequence of\n    one-dimensional spline filters. The intermediate arrays are stored\n    in the same data type as the output. Therefore, for output types\n    with a limited precision, the results may be imprecise because\n    intermediate results may be stored with insufficient precision.\n\n    """"""\n    array = _check_interpolate(array, order, \'spline_filter\')\n    if isinstance(out, type): # pragma: no cover\n        import warnings\n        warnings.warn(\'mahotas.interpolate.spline_filter: Use `dtype` for type instead of `out`\', DeprecationWarning)\n        dtype = out\n        out = None\n    if isinstance(output, type): # pragma: no cover\n        import warnings\n        warnings.warn(\'mahotas.interpolate.spline_filter: Use `dtype` for type instead of `output`\', DeprecationWarning)\n        dtype = output\n        output = None\n    output = internal._get_output(array, out, \'interpolate.spline_filter\', dtype=dtype, output=output)\n    output[...] = array\n    for axis in range(array.ndim):\n        _interpolate.spline_filter1d(output, order, axis)\n    return output\n\n\n\ndef _maybe_filter(array, order, func, prefilter, dtype):\n    array = _check_interpolate(array, order, func)\n    if array.ndim < 1:\n        raise ValueError(func+\': array rank must be > 0\')\n    if prefilter and order > 1:\n        return spline_filter(array, order, dtype=dtype)\n    else:\n        return array.astype(dtype, copy=False)\n\ndef zoom(array, zoom, out=None, order=3, mode=\'constant\', cval=0.0, prefilter=True, output=None):\n    """"""\n    Zoom an array.\n\n    The array is zoomed using spline interpolation of the requested order.\n\n    Parameters\n    ----------\n    array : ndarray\n        The input array.\n    zoom : float or sequence, optional\n        The zoom factor along the axes. If a float, `zoom` is the same for each\n        axis. If a sequence, `zoom` should contain one value for each axis.\n    out : ndarray or dtype, optional\n        The array in which to place the output, or the dtype of the returned\n        array.\n    order : int, optional\n        The order of the spline interpolation, default is 3.\n        The order has to be in the range 0-5.\n    mode : str, optional\n        Points outside the boundaries of the input are filled according\n        to the given mode (\'constant\', \'nearest\', \'reflect\' or \'wrap\').\n        Default is \'constant\'.\n    cval : scalar, optional\n        Value used for points outside the boundaries of the input if\n        ``mode=\'constant\'``. Default is 0.0\n    prefilter : bool, optional\n        The parameter prefilter determines if the input is pre-filtered with\n        `spline_filter` before interpolation (necessary for spline\n        interpolation of order > 1).  If False, it is assumed that the input is\n        already filtered. Default is True.\n\n    Returns\n    -------\n    return_value : ndarray\n    """"""\n    array = _maybe_filter(array, order, \'interpolate.zoom\', prefilter, dtype=np.float64)\n    zoom = np.array(zoom)\n    if zoom.ndim == 0:\n        zoom = np.array([zoom]*array.ndim)\n    elif zoom.ndim != 1:\n        raise ValueError(\'mahotas.interpolation.zoom: zoom should be a 1-d array\')\n    if len(zoom) != array.ndim:\n        raise ValueError(\'mahotas.interpolation.zoom: zoom should have one element for each dimension of array\')\n\n    if out is None and output is not None: # pragma: no cover\n        import warnings\n        warnings.warn(\'mahotas.interpolate.zoom: Use `out` for output parameter instead of `output`\', DeprecationWarning)\n        out = output\n\n    if out is None:\n        output_shape = tuple([int(s * z) for s,z in zip(array.shape, zoom)])\n        out = np.empty(output_shape, dtype=array.dtype)\n    zoom_div = np.array(out.shape, float) - 1\n    zoom = (np.array(array.shape) - 1) / zoom_div\n    zoom = np.ascontiguousarray(zoom)\n\n    # Zooming to infinity is unpredictable, so just choose\n    # zoom factor 1 instead\n    zoom[np.isinf(zoom)] = 1\n\n    _check_mode(mode, cval, \'interpolation.zoom\')\n\n    # zooming is always done in floats, but the user may want the output in\n    # another type, so handle this case here:\n    o_out = None\n    if out.dtype != array.dtype:\n        o_out = out\n        out = np.empty(out.shape, array.dtype)\n    _interpolate.zoom_shift(array, zoom, None, out, order, mode2int[mode], cval)\n    if o_out is not None:\n        o_out[:] = out[:]\n        out = o_out\n    return out\n\n\ndef shift(array, shift, out=None, order=3, mode=\'constant\', cval=0.0,\n          prefilter=True, output=None):\n    """"""\n    Shift an array.\n\n    The array is shifted using spline interpolation of the requested order.\n    Points outside the boundaries of the input are filled according to the\n    given mode.\n\n    Parameters\n    ----------\n    array : ndarray\n        The input array.\n    shift : float or sequence, optional\n        The shift along the axes. If a float, `shift` is the same for each\n        axis. If a sequence, `shift` should contain one value for each axis.\n    out : ndarray or dtype, optional\n        The array in which to place the output, or the dtype of the returned\n        array.\n    order : int, optional\n        The order of the spline interpolation, default is 3.\n        The order has to be in the range 0-5.\n    mode : str, optional\n        Points outside the boundaries of the input are filled according\n        to the given mode (\'constant\', \'nearest\', \'reflect\' or \'wrap\').\n        Default is \'constant\'.\n    cval : scalar, optional\n        Value used for points outside the boundaries of the input if\n        ``mode=\'constant\'``. Default is 0.0\n    prefilter : bool, optional\n        The parameter prefilter determines if the input is pre-filtered with\n        `spline_filter` before interpolation (necessary for spline\n        interpolation of order > 1).  If False, it is assumed that the input is\n        already filtered. Default is True.\n\n    Returns\n    -------\n    return_value : ndarray\n        The shifted input.\n\n    """"""\n    array = _maybe_filter(array, order, \'interpolate.shift\', prefilter, dtype=np.float64)\n    _check_mode(mode, cval, \'interpolation.shift\')\n    output = internal._get_output(array, out, \'interpolate.shift\', dtype=np.float64, output=output)\n    shift = np.ascontiguousarray(shift, dtype=np.float64)\n    shift *= -1\n    _interpolate.zoom_shift(array, None, shift, output, order, mode2int[mode], cval)\n    return output\n\n\n'"
mahotas/labeled.py,32,"b'# Copyright (C) 2008-2019, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# LICENSE: MIT\n\nfrom __future__ import division\nimport numpy as np\nfrom .morph import get_structuring_elem\nfrom . import _labeled\nfrom .internal import _get_output\nfrom ._filters import _checked_mode2int\nimport mahotas as mh\n\n__all__ = [\n    \'bbox\',\n    \'borders\',\n    \'border\',\n    \'bwperim\',\n    \'filter_labeled\',\n    \'label\',\n    \'labeled_sum\',\n    \'labeled_max\',\n    \'labeled_size\',\n    \'relabel\',\n    \'is_same_labeling\',\n    \'perimeter\',\n    \'remove_bordering\',\n    \'remove_regions\',\n    \'remove_regions_where\',\n    ]\n\ndef label(array, Bc=None, out=None, output=None):\n    \'\'\'\n    labeled, nr_objects = label(array, Bc={3x3 cross}, output={new array})\n\n    Label the array, which is interpreted as a binary array\n\n    This is also called *connected component labeled*, where the connectivity\n    is defined by the structuring element ``Bc``.\n\n    See: http://en.wikipedia.org/wiki/Connected-component_labeling\n\n    Parameters\n    ----------\n    array : ndarray\n        This will be interpreted as binary array\n    Bc : ndarray, optional\n        This is the structuring element to use\n    out : ndarray, optional\n        Output array. Must be a C-array, of type np.int32\n\n    Returns\n    -------\n    labeled : ndarray\n        Labeled result\n    nr_objects : int\n        Number of objects\n    \'\'\'\n    output = _get_output(array, out, \'labeled.label\', np.int32, output=output)\n    output[:] = (array != 0)\n    Bc = get_structuring_elem(output, Bc)\n    nr_objects = _labeled.label(output, Bc)\n    return output, nr_objects\n\ndef relabel(labeled, inplace=False):\n    \'\'\'\n    relabeled, nr_objs = relabel(labeled, inplace=False)\n\n    Relabeling ensures that ``relabeled`` is a labeled image such that every\n    label from 1 to ``relabeled.max()`` is used (0 is reserved for the\n    background and is passed through).\n\n    Example::\n\n        labeled,n = label(some_binary_map)\n        for region in range(n):\n            if not good_region(labeled, region + 1):\n                # This deletes the region:\n                labeled[labeled == (region + 1)] = 0\n        relabel(labeled, inplace=True)\n\n    Parameters\n    ----------\n    relabeled : ndarray of int\n        A labeled array\n    inplace : boolean, optional\n        Whether to perform relabeling inplace, erasing the values in\n        ``labeled`` (default: False)\n\n    Returns\n    -------\n    relabeled: ndarray\n    nr_objs : int\n        Number of objects\n\n    See Also\n    --------\n    label : function\n    \'\'\'\n    labeled = _as_labeled(labeled, labeled, \'relabel\', inplace=inplace)\n    n = _labeled.relabel(labeled)\n    return labeled, n\n\ndef is_same_labeling(labeled0, labeled1):\n    \'\'\'\n    same = is_same_labeling(labeled0, labeled1)\n\n    Checks whether ``labeled0`` and ``labeled1`` represent the same labeling\n    (i.e., whether they are the same except for a possible change of label\n    values).\n\n    Note that the background (value 0) is treated differently. Namely\n\n    is_same_labeling(a, b) implies np.all( (a == 0) == (b == 0) )\n\n    Parameters\n    ----------\n    labeled0 : ndarray of int\n        A labeled array\n    labeled1 : ndarray of int\n        A labeled array\n\n    Returns\n    -------\n    same : bool\n        True if the labelings passed as argument are equivalent\n\n    See Also\n    --------\n    label : function\n    relabel : function\n    \'\'\'\n    labeled0 = _convert_labeled(labeled0)\n    labeled1 = _convert_labeled(labeled1)\n    return _labeled.is_same_labeling(labeled0, labeled1)\n\n\ndef remove_regions(labeled, regions, inplace=False):\n    \'\'\'\n    removed = remove_regions(labeled, regions, inplace=False):\n\n    Removes the regions in ``regions``. If an elementwise ``in`` operator\n    existed, this would be equivalent to the following::\n\n        labeled[ labeled element-wise-in regions ] = 0\n\n    This function **does not** relabel its arguments. You can use the\n    ``relabel`` function for that::\n\n        removed = relabel(remove_regions(labeled, regions))\n\n    Or, saving one image allocation::\n\n        removed = relabel(remove_regions(labeled, regions), inplace=True)\n\n    This is the same, but reuses the memory in the relabeling operation.\n\n    Parameters\n    ----------\n    relabeled : ndarray of int\n        A labeled array\n    regions : sequence of int\n        These regions will be removed\n    inplace : boolean, optional\n        Whether to perform removal inplace, erasing the values in\n        ``labeled`` (default: False)\n\n    Returns\n    -------\n    removed : ndarray\n\n    See Also\n    --------\n    relabel : function\n        After removing unecessary regions, it is often a good idea to relabel\n        your label image.\n    \'\'\'\n    labeled = _as_labeled(labeled, labeled, \'remove_regions\', inplace=inplace)\n    regions = np.asarray(regions, dtype=np.intc)\n    regions = np.unique(regions)\n    _labeled.remove_regions(labeled, regions)\n    return labeled\n\n\ndef remove_regions_where(labeled, conditions, inplace=False):\n    \'\'\'Remove regions based on a boolean array\n\n    A region is removed if ``conditions[region-id]`` evaluates true.\n\n    This function **does not** relabel its arguments. You can use the\n    ``relabel`` function for that::\n\n        removed = relabel(remove_regions_where(labeled, conditions))\n\n    Or, saving one image allocation::\n\n        removed = relabel(remove_regions(labeled, conditions), inplace=True)\n\n    This is the same, but reuses the memory in the relabeling operation.\n\n\n    See Also\n    --------\n    remove_regions : function\n        Variation of this function which uses integer indexing\n    \'\'\'\n    regions, = np.where(conditions)\n    return remove_regions(labeled, regions, inplace=inplace)\n\n\ndef remove_bordering(labeled, rsize=1, out=None, output=None):\n    \'\'\'\n    slabeled = remove_bordering(labeled, rsize=1, out={np.empty_like(im)})\n\n    Remove objects that are touching the border.\n\n    Pass ``labeled`` as ``out`` to achieve in-place operation.\n\n    Parameters\n    ----------\n    labeled : ndarray\n        Labeled array\n    rsize : int or tuple, optional\n        Minimum distance to the border (in Manhatan distance) to allow an\n        object to survive. May be int or tuple with len == labeled.ndim.\n    out : ndarray, optional\n        If ``im`` is passed as ``out``, then it operates inline.\n\n    Returns\n    -------\n    slabeled : ndarray\n        Subset of ``labeled``\n    \'\'\'\n    im = labeled\n    invalid = set()\n    index = [slice(None,None,None) for _ in range(im.ndim)]\n    if type(rsize) is not tuple:\n        rsize = (rsize,)*im.ndim\n    for dim in range(im.ndim):\n        for bordering in (\n                    slice(rsize[dim]),\n                    slice(im.shape[dim]-rsize[dim], None)\n                        ):\n            index[dim] = bordering\n            for val in np.unique(im[tuple(index)].ravel()):\n                if val != 0:\n                    invalid.add(val)\n        index[dim] = slice(None,None,None)\n    if out is None and output is not None: #pragma: no cover\n        import warnings\n        warnings.warn(\'Using deprecated `output` argument in function `%s`. Please use `out` in the future.\' % \'remove_bordering\', DeprecationWarning)\n        out = output\n    if out is None:\n        out = im.copy()\n    elif out is not im:\n        out[:] = im\n    for val in invalid:\n        out *= (im != val)\n    return out\n\n\ndef border(labeled, i, j, Bc=None, out=None, always_return=True, output=None):\n    \'\'\'\n    border_img = border(labeled, i, j, Bc={3x3 cross}, out={np.zeros(labeled.shape, bool)}, always_return=True)\n\n    Compute the border region between `i` and `j` regions.\n\n    A pixel is on the border if it has value `i` (or `j`) and a pixel in its\n    neighbourhood (defined by `Bc`) has value `j` (or `i`).\n\n    Parameters\n    ----------\n    labeled : ndarray of integer type\n        input labeled array\n    i : integer\n    j : integer\n    Bc : structure element, optional\n    out : ndarray of same shape as `labeled`, dtype=bool, optional\n        where to store the output. If ``None``, a new array is allocated\n    always_return : bool, optional\n        if false, then, in the case where there is no pixel on the border,\n        returns ``None``. Otherwise (the default), it always returns an array\n        even if it is empty.\n\n    Returns\n    -------\n    border_img : boolean ndarray\n        Pixels are True exactly where there is a border between `i` and `j` in `labeled`\n    \'\'\'\n    Bc = get_structuring_elem(labeled, Bc)\n    output = _get_output(labeled, out, \'labeled.border\', bool, output=output)\n    output.fill(False)\n    return _labeled.border(labeled, Bc, output, i, j, bool(always_return))\n\ndef borders(labeled, Bc=None, out=None, output=None, mode=\'constant\'):\n    \'\'\'\n    border_img = borders(labeled, Bc={3x3 cross}, out={np.zeros(labeled.shape, bool)})\n\n    Compute border pixels\n\n    A pixel is on a border if it has value `i` and a pixel in its neighbourhood\n    (defined by `Bc`) has value `j`, with ``i != j``.\n\n    Parameters\n    ----------\n    labeled : ndarray of integer type\n        input labeled array\n    Bc : structure element, optional\n    out : ndarray of same shape as `labeled`, dtype=bool, optional\n        where to store the output. If ``None``, a new array is allocated\n    mode : {\'reflect\', \'nearest\', \'wrap\', \'mirror\', \'constant\' [default], \'ignore\'}\n        How to handle borders\n\n    Returns\n    -------\n    border_img : boolean ndarray\n        Pixels are True exactly where there is a border in `labeled`\n    \'\'\'\n    Bc = get_structuring_elem(labeled, Bc)\n    output = _get_output(labeled, out, \'labeled.borders\', bool, output=output)\n    output.fill(False)\n    return _labeled.borders(labeled, Bc, output, _checked_mode2int(mode, 0.0, \'borders\'))\n\n\ndef bwperim(bw, n=4, mode=""constant""):\n    \'\'\'\n    perim = bwperim(bw, n=4)\n\n    Find the perimeter of objects in binary images.\n\n    A pixel is part of an object perimeter if its value is one and there\n    is at least one zero-valued pixel in its neighborhood.\n\n    By default the neighborhood of a pixel is 4 nearest pixels, but\n    if `n` is set to 8 the 8 nearest pixels will be considered.\n\n    Parameters\n    ----------\n    bw : ndarray\n        A black-and-white image (any other image will be converted to black & white)\n    n : int, optional\n        Connectivity. Must be 4 or 8 (default: 4)\n    mode : {\'reflect\', \'nearest\', \'wrap\', \'mirror\', \'constant\' [default], \'ignore\'}\n        How to handle borders\n\n    Returns\n    -------\n    perim : ndarray\n        A boolean image\n\n    See Also\n    --------\n    borders : function\n        This is a more generic function\n    \'\'\'\n    bw = (bw != 0)\n    return bw&borders(bw, n, mode=mode)\n\ndef _as_labeled(array, labeled, funcname, inplace=\'unused\'):\n    \'\'\'\n\n    labeled = _as_labeled(array, labeled, funcname, inplace=\'unused\')\n\n    Parameters\n    ----------\n    array : ndarray\n    labeled : ndarray\n    funcname : str\n    inplace : bool or str, optional\n        handles ``inplace`` arguments\n    \'\'\'\n    if inplace == \'unused\':\n        labeled = np.require(labeled, dtype=np.intc, requirements=""CW"")\n    elif not inplace:\n        labeled = np.array(labeled, dtype=np.intc)\n    elif labeled.dtype != np.intc or not labeled.flags.carray:\n        raise ValueError(\'mahotas.labeled.%s: labeled must be a C-array of type int\' % funcname)\n\n    if array.shape != labeled.shape:\n        raise ValueError(\'mahotas.labeled.%s: `array` is not the same size as `labeled`\' % funcname)\n    return labeled\n\n\ndef _convert_labeled(labeled):\n    return np.require(labeled, dtype=np.intc, requirements=""CW"")\n\ndef labeled_sum(array, labeled, minlength=None):\n    \'\'\'\n    sums = labeled_sum(array, labeled, minlength=None)\n\n    Labeled sum. sum will be an array of size ``labeled.max() + 1``, where\n    ``sum[i]`` is equal to ``np.sum(array[labeled == i])``.\n\n    Parameters\n    ----------\n    array : ndarray of any type\n    labeled : int ndarray\n        Label map. This is the same type as returned from ``mahotas.label()``\n    minlength : int, optional\n        Minimum size of return array. If labeled has fewer than ``minlength``\n        regions, 0s are added to the result.  (optional)\n\n    Returns\n    -------\n    sums : 1-d ndarray of ``array.dtype``\n    \'\'\'\n    labeled = _as_labeled(array, labeled, \'labeled_sum\')\n    maxv = labeled.max() + 1\n    if minlength is not None:\n        maxv = max(maxv, minlength)\n    output = np.empty(maxv, dtype=array.dtype)\n    _labeled.labeled_sum(array, labeled, output)\n    return output\n\n\ndef labeled_max(array, labeled):\n    \'\'\'\n    mins = labeled_max(array, labeled, minlength=None)\n\n    Labeled minimum. ``mins`` will be an array of size ``labeled.max() + 1``, where\n    ``mins[i]`` is equal to ``np.min(array[labeled == i])``.\n\n    Parameters\n    ----------\n    array : ndarray of any type\n    labeled : int ndarray\n        Label map. This is the same type as returned from ``mahotas.label()``\n\n    Returns\n    -------\n    mins : 1-d ndarray of ``array.dtype``\n    \'\'\'\n    labeled = _as_labeled(array, labeled, \'labeled_max\')\n    maxv = labeled.max() + 1\n    output = np.empty(maxv, dtype=array.dtype)\n    _labeled.labeled_max_min(array, labeled, output, True)\n    return output\n\n\ndef labeled_min(array, labeled):\n    \'\'\'\n    maxs = labeled_min(array, labeled)\n\n    Labeled maximum. ``maxs`` will be an array of size ``labeled.max() + 1``, where\n    ``maxs[i]`` is equal to ``np.max(array[labeled == i])``.\n\n    Parameters\n    ----------\n    array : ndarray of any type\n    labeled : int ndarray\n        Label map. This is the same type as returned from ``mahotas.label()``\n\n    Returns\n    -------\n    maxs : 1-d ndarray of ``array.dtype``\n    \'\'\'\n    labeled = _as_labeled(array, labeled, \'labeled_min\')\n    maxv = labeled.max() + 1\n    output = np.empty(maxv, dtype=array.dtype)\n    _labeled.labeled_max_min(array, labeled, output, False)\n    return output\n\ndef labeled_size(labeled):\n    \'\'\'\n    sizes = labeled_size(labeled)\n\n    Equivalent to::\n\n        for i in range(...):\n            sizes[i] = np.sum(labeled == i)\n\n    but, naturally, much faster.\n\n    Parameters\n    ----------\n    labeled : int ndarray\n\n    Returns\n    -------\n    sizes : 1-d ndarray of int\n\n    See Also\n    --------\n    mahotas.fullhistogram : almost same function by another name (the only\n    difference is that that function only accepts unsigned integer types).\n    \'\'\'\n    from .histogram import fullhistogram\n    return fullhistogram(labeled.astype(np.uint32, copy=False))\n\n\n_perimeter_magic = np.array([\n                [10, 2, 10],\n                [ 2, 1,  2],\n                [10, 2, 10]], np.uint8)\n_perimeter_values = None\n\n# This implementation was adapted from scikit-image\'s implementation\ndef perimeter(bwimage, n=4, mode=""constant""):\n    """"""\n    p = perimeter(bwimage, n=4, mode=""constant"")\n\n    Calculate total perimeter of all objects in binary image.\n\n    Parameters\n    ----------\n    bwimage : array\n        binary image\n    n : int, optional\n        passed to ``bwperim`` as is\n    mode : str, optional\n        passed to ``bwperim`` as is\n\n    Returns\n    -------\n    p : float\n        total perimeter of all objects in binary image\n\n    See Also\n    --------\n    bwperim : function\n        Finds the perimeter region\n\n    References\n    ----------\n    .. [1] K. Benkrid, D. Crookes. Design and FPGA Implementation of\n           a Perimeter Estimator. The Queen\'s University of Belfast.\n           http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc\n    """"""\n    global _perimeter_values\n    perim = bwperim(bwimage, n, mode)\n    perim = perim.astype(np.uint8, copy=False)\n\n    histogram = mh.fullhistogram(\n                    mh.convolve(perim, _perimeter_magic))\n\n    if _perimeter_values is None:\n        _perimeter_values = np.zeros(34, float)\n        _perimeter_values[[5, 7, 15, 17, 25, 27]] = 1\n        _perimeter_values[[21, 33]] = np.sqrt(2)\n        _perimeter_values[[13, 23]] = (1 + np.sqrt(2)) / 2\n\n    size = min(34, len(histogram))\n    return np.dot(histogram[:size], _perimeter_values[:size])\n\n\ndef bbox(f, as_slice=False):\n    \'\'\'\n    Bounding boxes of all objects in a labeled array.\n\n    After::\n\n        bboxes = mh.labeled.bbox(f)\n\n    ``bboxes[34]`` will contain the bounding box of ``(f == 34)``.\n\n    Parameters\n    ----------\n    f : integer ndarray\n    as_slice : boolean, optional\n        Whether to return slice objects instead of integer coordinates\n        (default: False).\n\n    Returns\n    -------\n    bboxes : ndarray\n\n    See Also\n    --------\n    mh.bbox : the binary version of this function\n    \'\'\'\n    import mahotas._bbox\n    n = f.max()\n    output = np.empty( f.ndim * 2 * (n+1), np.intp)\n    output = mahotas._bbox.bbox_labeled(f, output)\n    output = output.reshape((n+1, 2*f.ndim))\n    if as_slice:\n        output = [tuple([slice(s,e) for s,e in r.reshape((-1,2))]) for r in output]\n    return output\n\ndef filter_labeled(labeled, remove_bordering=False, min_size=None, max_size=None):\n    \'\'\'Filter labeled regions based on a series of conditions\n\n    .. versionadded :: 1.4.1\n\n    Parameters\n    ----------\n    labeled : labeled array\n    remove_bordering : bool, optional\n        whether to remove regions that touch the border\n    min_size : int, optional\n        Minimum size (in pixels) of objects to keep (default is no minimum)\n    max_size : int, optional\n        Maximum size (in pixels) of objects to keep (default is no maximum)\n\n    Returns\n    -------\n    filtered : labeled array\n    nr : int\n        number of new labels\n    \'\'\'\n    from mahotas.labeled import remove_regions, labeled_size\n    labeled = _as_labeled(labeled, labeled, \'filter_labeled\')\n    if remove_bordering:\n        labeled = mh.labeled.remove_bordering(labeled)\n        labeled,nr = mh.labeled.relabel(labeled)\n    else:\n        nr = labeled.max()\n\n    to_keep = np.ones(nr+1, bool)\n\n    if min_size is not None or max_size is not None:\n        sizes = labeled_size(labeled)\n        if min_size:\n            to_keep &= (sizes >= min_size)\n        if max_size:\n            to_keep &= (sizes <= max_size)\n    to_keep[0] = True\n    to_remove = np.where(~to_keep)\n    labeled = remove_regions(labeled, to_remove)\n    labeled,nr = mh.labeled.relabel(labeled, inplace=True)\n    return labeled, nr\n'"
mahotas/lbp.py,0,"b""import warnings\nwarnings.warn(\n'''Use\n\nfrom mahotas.features import lbp\n''', DeprecationWarning)\n\nfrom mahotas.features.lbp import *\n"""
mahotas/mahotas_version.py,0,"b""__version__ = '1.4.9'\n"""
mahotas/moments.py,0,"b""import warnings\nwarnings.warn(\n'''Use\n\nfrom mahotas.features import moments\n''', DeprecationWarning)\n\nfrom mahotas.features.moments import *\n"""
mahotas/morph.py,45,"b'# Copyright (C) 2008-2019, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# License: MIT\n\nfrom __future__ import division\nimport numpy as np\n\nfrom .internal import _get_output, _verify_is_integer_type, _check_2\nfrom . import _morph\n\n__all__ = [\n        \'close\',\n        \'close_holes\',\n        \'cwatershed\',\n        \'cerode\',\n        \'dilate\',\n        \'disk\',\n        \'cdilate\',\n        \'erode\',\n        \'get_structuring_elem\',\n        \'hitmiss\',\n        \'locmax\',\n        \'locmin\',\n        \'majority_filter\',\n        \'open\',\n        \'regmax\',\n        \'regmin\',\n        \'tophat_open\',\n        \'tophat_close\',\n        \'subm\',\n        ]\n\ndef get_structuring_elem(A,Bc):\n    \'\'\'\n    Bc_out = get_structuring_elem(A, Bc)\n\n    Retrieve appropriate structuring element\n\n    Parameters\n    ----------\n    A : ndarray\n        array which will be operated on\n    Bc : None, int, or array-like\n        :None: Then Bc is taken to be 1\n        :An integer: There are two associated semantics:\n            connectivity\n              ``Bc[y,x] = [[ is |y - 1| + |x - 1| <= Bc_i ]]``\n            count\n              ``Bc.sum() == Bc_i``\n              This is the more traditional meaning (when one writes that\n              ""4-connected"", this is what one has in mind).\n\n          Fortunately, the value itself allows one to distinguish between the\n          two semantics and, if used correctly, no ambiguity should ever occur.\n        :An array: This should be of the same nr. of dimensions as A and will\n            be passed through if of the right type. Otherwise, it will be cast.\n\n    Returns\n    -------\n    Bc_out : ndarray\n        Structuring element. This array will be of the same type as A,\n        C-contiguous.\n\n    \'\'\'\n    translate_sizes = {\n            (2, 4) : 1,\n            (2, 8) : 2,\n            (3, 6) : 1,\n    }\n    if Bc is None:\n        Bc = 1\n    elif type(Bc) == int and (len(A.shape), Bc) in translate_sizes:\n        Bc = translate_sizes[len(A.shape),Bc]\n    elif type(Bc) != int:\n        if A.ndim != Bc.ndim:\n            raise ValueError(\'morph.get_structuring_elem: Bc does not have the correct number of dimensions. [array has {} coordinates; Bc has {}.]\'.format(A.ndim, Bc.ndim))\n        Bc = np.asanyarray(Bc, A.dtype)\n        if not Bc.flags.contiguous:\n            return Bc.copy()\n        return Bc\n\n    # Special case typical case:\n    if len(A.shape) == 2 and Bc == 1:\n        return np.array([\n                [0,1,0],\n                [1,1,1],\n                [0,1,0]], dtype=A.dtype)\n    max1 = Bc\n    Bc = np.zeros((3,)*len(A.shape), dtype=A.dtype)\n    centre = np.ones(len(A.shape))\n    # This is pretty slow, but this should be a tiny array, so who cares\n    for i in range(Bc.size):\n        pos = np.unravel_index(i, Bc.shape)\n        pos -= centre\n        if np.sum(np.abs(pos)) <= max1:\n            Bc.flat[i] = 1\n    return Bc\n\ndef disk(radius, dim=2):\n    \'\'\'\n    D = disk(radius, dim=2)\n\n    Return a binary disk structuring element of radius ``radius`` and dimension ``dim``\n\n    Parameters\n    ----------\n    radius : int\n        Radius (in pixels) of returned disk\n    dim : int, optional\n        Dimension of returned array (default: 2)\n\n    Returns\n    -------\n    D : boolean ndarray\n    \'\'\'\n    import numpy as np\n    if dim <= 0:\n        raise ValueError(\'mahotas.morph.disk: dimension must be positive\')\n    shape = [(radius*2+1) for _ in range(dim)]\n    if dim == 2:\n        return _morph.disk_2d(np.zeros(shape, bool), radius)\n    indices = np.indices(shape, float)\n    indices -= radius\n    indices **= 2\n    return (indices.sum(0) < (radius**2))\n\ndef dilate(A, Bc=None, out=None, output=None):\n    \'\'\'\n    Morphological dilation.\n\n    The type of operation depends on the ``dtype`` of ``A``! If boolean, then\n    the dilation is binary, else it is greyscale dilation. In the case of\n    greyscale dilation, the smallest value in the domain of ``Bc`` is\n    interpreted as +Inf.\n\n    Parameters\n    ----------\n    A : ndarray of bools\n        input array\n    Bc : ndarray, optional\n        Structuring element. By default, use a cross (see\n        ``get_structuring_elem`` for details on the default).\n    out : ndarray, optional\n        output array. If used, this must be a C-array of the same ``dtype`` as\n        ``A``. Otherwise, a new array is allocated.\n    output : deprecated\n        Do not use\n\n    Returns\n    -------\n    dilated : ndarray\n        dilated version of ``A``\n\n    See Also\n    --------\n    erode\n    \'\'\'\n    _verify_is_integer_type(A, \'dilate\')\n    Bc = get_structuring_elem(A,Bc)\n    output = _get_output(A, out, \'dilate\', output=output)\n    return _morph.dilate(A, Bc, output)\n\ndef erode(A, Bc=None, out=None, output=None):\n    \'\'\'\n    eroded = erode(A, Bc={3x3 cross}, out={np.empty_as(A)})\n\n    Morphological erosion.\n\n    The type of operation depends on the ``dtype`` of ``A``! If boolean, then\n    the erosion is binary, else it is greyscale erosion. In the case of\n    greyscale erosion, the smallest value in the domain of ``Bc`` is\n    interpreted as -Inf.\n\n    Parameters\n    ----------\n    A : ndarray\n        input image\n    Bc : ndarray, optional\n        Structuring element. By default, use a cross (see\n        ``get_structuring_elem`` for details on the default).\n    out : ndarray, optional\n        output array. If used, this must be a C-array of the same ``dtype`` as\n        ``A``. Otherwise, a new array is allocated.\n\n    Returns\n    -------\n    erosion : ndarray\n        eroded version of ``A``\n\n    See Also\n    --------\n    dilate\n    \'\'\'\n    _verify_is_integer_type(A,\'erode\')\n    Bc = get_structuring_elem(A,Bc)\n    output = _get_output(A, out, \'erode\', output=output)\n    return _morph.erode(A, Bc, output)\n\n\ndef cerode(f, g, Bc=None, out=None, output=None):\n    \'\'\'\n    conditionally_eroded = cerode(f, g, Bc={3x3 cross}, out={np.empty_as(A)})\n\n    Conditional morphological erosion.\n\n    The type of operation depends on the ``dtype`` of ``A``! If boolean, then\n    the erosion is binary, else it is greyscale erosion. In the case of\n    greyscale erosion, the smallest value in the domain of ``Bc`` is\n    interpreted as -Inf.\n\n    Parameters\n    ----------\n    f : ndarray\n        input image\n    g : ndarray\n        conditional image\n    Bc : ndarray, optional\n        Structuring element. By default, use a cross (see\n        ``get_structuring_elem`` for details on the default).\n\n    Returns\n    -------\n    conditionally_eroded : ndarray\n        eroded version of ``f`` conditioned on ``g``\n\n    See Also\n    --------\n    erode : function\n        Unconditional version of this function\n    dilate\n    \'\'\'\n    f = np.maximum(f, g)\n    _verify_is_integer_type(f, \'cerode\')\n    Bc = get_structuring_elem(f, Bc)\n    out = _get_output(f, out, \'cerode\', output=output)\n    f = _morph.erode(f, Bc, out)\n    return np.maximum(f, g, out=f)\n\ndef cdilate(f, g, Bc=None, n=1):\n    """"""\n    y = cdilate(f, g, Bc={3x3 cross}, n=1)\n\n    Conditional dilation\n\n    `cdilate` creates the image `y` by dilating the image `f` by the\n    structuring element `Bc` conditionally to the image `g`. This\n    operator may be applied recursively `n` times.\n\n    Parameters\n    ----------\n    f : Gray-scale (uint8 or uint16) or binary image.\n    g : Conditioning image. (Gray-scale or binary).\n    Bc : Structuring element (default: 3x3 cross)\n    n : Number of iterations (default: 1)\n\n    Returns\n    -------\n    y : Image\n    """"""\n    _verify_is_integer_type(f, \'cdilate\')\n    Bc = get_structuring_elem(f, Bc)\n    f = np.minimum(f, g)\n    for i in range(n):\n        prev = f\n        f = dilate(f, Bc)\n        f = np.minimum(f, g)\n        if np.all(f == prev):\n            break\n    return f\n\n\ndef cwatershed(surface, markers, Bc=None, return_lines=False):\n    \'\'\'\n    W = cwatershed(surface, markers, Bc=None, return_lines=False)\n    W,WL = cwatershed(surface, markers, Bc=None, return_lines=True)\n\n    Seeded watershed in n-dimensions\n\n    This function computes the watershed transform on the input surface (which\n    may actually be an n-dimensional volume).\n\n    This function requires initial seed points. A traditional way of\n    initializing watershed is to use regional minima::\n\n        minima = mh.regmin(f)\n        markers,nr_markers = mh.label(minima)\n        W = cwatershed(f, minima)\n\n    Parameters\n    ----------\n    surface : image\n    markers : image\n        initial markers (must be a labeled image, i.e., one where 0 represents\n        the background and higher integers represent different regions)\n    Bc : ndarray, optional\n        structuring element (default: 3x3 cross)\n    return_lines : boolean, optional\n        whether to return separating lines (in addition to regions)\n\n    Returns\n    -------\n    W : integer ndarray (int64 ints)\n        Regions image (i.e., W[i,j] == region for pixel (i,j))\n    WL : Lines image (`if return_lines==True`)\n    \'\'\'\n    _verify_is_integer_type(markers, \'cwatershed\')\n    if surface.shape != markers.shape:\n        raise ValueError(\'morph.cwatershed: Markers array should have the same shape as value array.\')\n    markers = np.asanyarray(markers, np.int64)\n    Bc = get_structuring_elem(surface, Bc)\n    return _morph.cwatershed(surface, markers, Bc, bool(return_lines))\n\ndef hitmiss(input, Bc, out=None, output=None):\n    \'\'\'\n    filtered = hitmiss(input, Bc, out=np.zeros_like(input))\n\n    Hit & Miss transform\n\n    For a given pixel position, the hit&miss is ``True`` if, when ``Bc`` is\n    overlaid on ``input``, centered at that position, the ``1`` values line up\n    with ``1``\\ s, while the ``0``\\ s line up with ``0``\\ s (``2``\\ s correspond to\n    *don\'t care*).\n\n    Examples\n    --------\n\n    ::\n\n        print(hitmiss(np.array([\n                    [0,0,0,0,0],\n                    [0,1,1,1,1],\n                    [0,0,1,1,1]]),\n                np.array([\n                    [0,0,0],\n                    [2,1,1],\n                    [2,1,1]])))\n\n        prints::\n\n            [[0 0 0 0 0]\n             [0 0 1 1 0]\n             [0 0 0 0 0]]\n\n\n\n    Parameters\n    ----------\n    input : input ndarray\n        This is interpreted as a binary array.\n    Bc : ndarray\n        hit & miss template, values must be one of (0, 1, 2)\n    out : ndarray, optional\n        Used for output. Must be Boolean ndarray of same size as ``input``\n    output : deprecated\n        Do not use\n\n    Returns\n    -------\n    filtered : ndarray\n    \'\'\'\n    _verify_is_integer_type(input, \'hitmiss\')\n    _verify_is_integer_type(Bc, \'hitmiss\')\n    if input.dtype != Bc.dtype:\n        if input.dtype == np.bool_:\n            input = input.view(np.uint8)\n            if Bc.dtype == np.bool_:\n                Bc = Bc.view(np.uint8)\n            else:\n                Bc = Bc.astype(np.uint8)\n        else:\n            Bc = Bc.astype(input.dtype)\n\n    if out is None and output is not None: # pragma: no cover\n        out = output\n\n    # We cannot call internal._get_output here because the conditions around\n    # dtypes are different from those implemented in `internal._get_output`\n\n    if out is None:\n        out = np.empty_like(input)\n    else:\n        if out.shape != input.shape:\n            raise ValueError(\'mahotas.hitmiss: out must be of same shape as input\')\n        if out.dtype != input.dtype:\n            if out.dtype == np.bool_ and input.dtype == np.uint8:\n                out = out.view(np.uint8)\n            else:\n                raise TypeError(\'mahotas.hitmiss: out must be of same type as input\')\n    return _morph.hitmiss(input, Bc, out)\n\n\ndef open(f, Bc=None, out=None, output=None):\n    """"""\n    y = open(f, Bc={3x3 cross}, out={np.empty_like(f)})\n\n    Morphological opening.\n\n    `open` creates the image y by the morphological opening of the\n    image `f` by the structuring element `Bc`.\n\n    In the binary case, the opening by the structuring element `Bc` may be\n    interpreted as the union of translations of `b` included in `f`. In the\n    gray-scale case, there is a similar interpretation taking the functions\n    umbra.\n\n    Parameters\n    ----------\n    f : ndarray\n        Gray-scale (uint8 or uint16) or binary image.\n    Bc : ndarray, optional\n        Structuring element (default: 3x3 elementary cross).\n    out : ndarray, optional\n        Output array\n    output : deprecated\n        Do not use\n\n    Returns\n    -------\n    y : ndarray\n\n    See Also\n    --------\n    open : function\n    """"""\n    _verify_is_integer_type(f, \'open\')\n    Bc = get_structuring_elem(f, Bc)\n    eroded = erode(f, Bc, out=out)\n    # We need to copy for the simple reason that otherwise, the image will be\n    # modified in place, which can mess up the implementation\n    return dilate(eroded.copy(), Bc, out=eroded)\n\n\ndef close(f, Bc=None, out=None, output=None):\n    """"""\n    y = close(f, Bc={3x3 cross}, out={np.empty_like(f)})\n\n    Morphological closing.\n\n    `close` creates the image `y` by the morphological closing of the\n    image `f` by the structuring element `Bc`. In the binary case, the\n    closing by a structuring element `Bc` may be interpreted as the\n    intersection of all the binary images that contain the image `f`\n    and have a hole equal to a translation of `Bc`. In the gray-scale\n    case, there is a similar interpretation taking the functions\n    umbra.\n\n    Parameters\n    ----------\n    f : ndarray\n        Gray-scale (uint8 or uint16) or binary image.\n    Bc : ndarray, optional\n        Structuring element. (Default: 3x3 elementary cross).\n    out : ndarray, optional\n        Output array\n    output : deprecated\n        Do not use\n\n    Returns\n    -------\n    y : ndarray\n\n    See Also\n    --------\n    open : function\n    """"""\n    _verify_is_integer_type(f, \'close\')\n    Bc = get_structuring_elem(f, Bc)\n    dilated = dilate(f, Bc, out=out)\n    # We need to copy for the simple reason that otherwise, the image will be\n    # modified in place, which can mess up the implementation\n    return erode(dilated.copy(), Bc, out=dilated)\n\n\ndef close_holes(ref, Bc=None):\n    \'\'\'\n    closed = close_holes(ref, Bc=None):\n\n    Close Holes\n\n    Parameters\n    ----------\n    ref : ndarray\n        Reference image. This should be a binary image.\n    Bc : structuring element, optional\n        Default: 3x3 cross\n\n    Returns\n    -------\n    closed : ndarray\n        superset of `ref` (i.e. with closed holes)\n    \'\'\'\n    _check_2(ref, \'close_holes\')\n    ref = np.ascontiguousarray(ref, dtype=np.bool_)\n    Bc = get_structuring_elem(ref, Bc)\n    return _morph.close_holes(ref, Bc)\n\n\ndef majority_filter(img, N=3, out=None, output=None):\n    \'\'\'\n    filtered = majority_filter(img, N=3, out={np.empty(img.shape, np.bool)})\n\n    Majority filter\n\n    filtered[y,x] is positive if the majority of pixels in the squared of size\n    `N` centred on (y,x) are positive.\n\n    Parameters\n    ----------\n    img : ndarray\n        input img (currently only 2-D images accepted)\n    N : int, optional\n        size of filter (must be odd integer), defaults to 3.\n    out : ndarray, optional\n        Used for output. Must be Boolean ndarray of same size as `img`\n    output : deprecated\n        Do not use\n\n    Returns\n    -------\n    filtered : ndarray\n        boolean image of same size as img.\n    \'\'\'\n    img = np.asanyarray(img, dtype=np.bool_)\n    output = _get_output(img, out, \'majority_filter\', np.bool_, output=output)\n    if N <= 1:\n        raise ValueError(\'mahotas.majority_filter: filter size must be positive\')\n    if not N&1:\n        import warnings\n        warnings.warn(\'mahotas.majority_filter: size argument must be odd. Adding 1.\')\n        N += 1\n    return _morph.majority_filter(img, N, output)\n\n\ndef _remove_centre(Bc):\n    index = [s//2 for s in Bc.shape]\n    Bc[tuple(index)] = False\n    return Bc\n\ndef locmax(f, Bc=None, out=None, output=None):\n    \'\'\'\n    filtered = locmax(f, Bc={3x3 cross}, out={np.empty(f.shape, bool)})\n\n    Local maxima\n\n    Parameters\n    ----------\n    f : ndarray\n    Bc : ndarray, optional\n        structuring element\n    out : ndarray, optional\n        Used for output. Must be Boolean ndarray of same size as `f`\n    output : deprecated\n        Do not use\n\n    Returns\n    -------\n    filtered : ndarray\n        boolean image of same size as f.\n\n    See Also\n    --------\n    regmax : function\n        Regional maxima. This is a stricter criterion than the local maxima as\n        it takes the whole object into account and not just the neighbourhood\n        defined by ``Bc``::\n\n            0 0 0 0 0\n            0 0 2 0 0\n            0 0 2 0 0\n            0 0 3 0 0\n            0 0 3 0 0\n            0 0 0 0 0\n\n        The top 2 is a local maximum because it has the maximal value in its\n        neighbourhood, but it is not a regional maximum.\n\n    locmin : function\n        Local minima\n    \'\'\'\n    Bc = get_structuring_elem(f, Bc)\n    output = _get_output(f, out, \'locmax\', np.bool_, output=output)\n    Bc = _remove_centre(Bc.copy())\n    return _morph.locmin_max(f, Bc, output, False)\n\n\ndef locmin(f, Bc=None, out=None, output=None):\n    \'\'\'\n    filtered = locmin(f, Bc={3x3 cross}, out={np.empty(f.shape, bool)})\n\n    Local minima\n\n    Parameters\n    ----------\n    f : ndarray\n    Bc : ndarray, optional\n        structuring element\n    out : ndarray, optional\n        Used for output. Must be Boolean ndarray of same size as `f`\n    output : deprecated\n        Do not use\n\n    Returns\n    -------\n    filtered : ndarray\n        boolean image of same size as f.\n\n    See Also\n    --------\n    locmax : function\n        Regional maxima\n    \'\'\'\n    Bc = get_structuring_elem(f, Bc)\n    Bc = _remove_centre(Bc.copy())\n    output = _get_output(f, out, \'locmin\', np.bool_, output=output)\n    return _morph.locmin_max(f, Bc, output, True)\n\n\ndef regmin(f, Bc=None, out=None, output=None):\n    \'\'\'\n    filtered = regmin(f, Bc={3x3 cross}, out={np.empty(f.shape, bool)})\n\n    Regional minima. See the documentation for ``regmax`` for more details.\n\n    Parameters\n    ----------\n    f : ndarray\n    Bc : ndarray, optional\n        structuring element\n    out : ndarray, optional\n        Used for output. Must be Boolean ndarray of same size as `f`\n    output : deprecated\n        Do not use\n\n    Returns\n    -------\n    filtered : ndarray\n        boolean image of same size as f.\n\n    See Also\n    --------\n    locmin : function\n        Local minima\n    \'\'\'\n    Bc = get_structuring_elem(f, Bc)\n    Bc = _remove_centre(Bc.copy())\n    output = _get_output(f, out, \'regmin\', np.bool_, output=output)\n    return _morph.regmin_max(f, Bc, output, True)\n\n\ndef regmax(f, Bc=None, out=None, output=None):\n    \'\'\'\n    filtered = regmax(f, Bc={3x3 cross}, out={np.empty(f.shape, bool)})\n\n    Regional maxima. This is a stricter criterion than the local maxima as\n    it takes the whole object into account and not just the neighbourhood\n    defined by ``Bc``::\n\n        0 0 0 0 0\n        0 0 2 0 0\n        0 0 2 0 0\n        0 0 3 0 0\n        0 0 3 0 0\n        0 0 0 0 0\n\n    The top 2 is a local maximum because it has the maximal value in its\n    neighbourhood, but it is not a regional maximum.\n\n\n    Parameters\n    ----------\n    f : ndarray\n    Bc : ndarray, optional\n        structuring element\n    out : ndarray, optional\n        Used for output. Must be Boolean ndarray of same size as `f`\n    output : deprecated\n        Do not use\n\n    Returns\n    -------\n    filtered : ndarray\n        boolean image of same size as f.\n\n    See Also\n    --------\n    locmax : function\n        Local maxima. The local maxima are a superset of the regional maxima\n    \'\'\'\n    Bc = get_structuring_elem(f, Bc)\n    Bc = _remove_centre(Bc.copy())\n    output = _get_output(f, out, \'regmax\', np.bool_, output=output)\n    return _morph.regmin_max(f, Bc, output, False)\n\ndef subm(a, b, out=None):\n    \'\'\'\n    c = subm(a, b, out={None})\n\n    Subtract (with saturation).\n\n    This is similar to:\n\n    c = a - b\n\n    but with saturation instead of underflow.\n\n    Examples\n    --------\n\n    ::\n\n        a = np.array([10, 10, 10], np.uint8)\n        b = np.array([ 5, 10, 15], np.uint8)\n\n        print subm(a,b)\n\n    Prints out::\n\n        [5, 0, 0]\n\n    Parameters\n    ----------\n    a : ndarray\n    b : ndarray\n    out : ndarray, optional\n        Pass ``a`` as output to subtract in-place.\n\n    Returns\n    -------\n    c : ndarray\n        Result of subtraction\n    \'\'\'\n    if a.dtype != b.dtype:\n        raise ValueError(\'mahotas.subm: This is only well-defined if both arguments are of the same type\')\n    out = _get_output(a, out, \'subm\')\n    if out is not a:\n        out[:] = a\n    return _morph.subm(out, b)\n\n\ndef tophat_close(f, Bc=None, out=None):\n    \'\'\'\n    fclosed = tophat_close(f, Bc={3x3 cross}, out={new array})\n\n    Closed top-hat transform (aka black tophat transform)\n\n    This returns objects that are smaller than ``Bc`` and contain lower values\n    than their surroundings.\n\n    See: http://en.wikipedia.org/wiki/Top-hat_transform\n\n    Parameters\n    ----------\n    f : ndarray\n    Bc : ndarray, optional\n        structuring element\n    out : ndarray, optional\n        output array\n\n    Returns\n    -------\n    fclosed : ndarray\n        Of same type and shape as ``f``\n\n    See Also\n    --------\n    tophat_close : function\n        Sister function to this one\n    \'\'\'\n    Bc = get_structuring_elem(f, Bc)\n    out = _get_output(f, out, \'tophat_close\')\n    fc = close(f, Bc)\n    return subm(fc, f, out=out)\n\ndef tophat_open(f, Bc=None, out=None):\n    \'\'\'\n    fopen = tophat_open(f, Bc={3x3 cross}, out={new array})\n\n    Open top-hat transform (aka white tophat transform)\n\n    This returns objects that are smaller than ``Bc`` and contain higher values\n    than their surroundings.\n\n    See: http://en.wikipedia.org/wiki/Top-hat_transform\n\n    Parameters\n    ----------\n    f : ndarray\n    Bc : ndarray, optional\n        structuring element\n    out : ndarray, optional\n        output array\n\n    Returns\n    -------\n    fopened : ndarray\n        Of same type and shape as ``f``\n\n    See Also\n    --------\n    tophat_close : function\n        Sister function to this one\n    \'\'\'\n    Bc = get_structuring_elem(f, Bc)\n    out = _get_output(f, out, \'tophat_open\')\n    fo = open(f,Bc)\n    return subm(f, fo, out=out)\n\n\ndef circle_se(radius):\n    \'\'\'\n    circle = circle_se(radius)\n\n    Build a circular structuring element of a given radius\n\n    Parameters\n    ----------\n    radius : int\n        Radius of circle\n\n    Returns\n    -------\n    circle : boolean ndarray\n    \'\'\'\n    if not (radius > 0):\n        raise ValueError(\'mahotas.morph.circle: radius must be positive\')\n    X = np.arange(-radius, +radius+1)\n    X,Y = np.meshgrid(X,X)\n    return (X**2 + Y**2) < radius**2\n'"
mahotas/polygon.py,3,"b""# Copyright (C) 2010-2013, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# \n# License: MIT (see COPYING file)\n\nfrom __future__ import division\nimport numpy as np\nfrom . import _convex\n\n__all__ = [\n    'line',\n    'fill_polygon',\n    'convexhull',\n    'fill_convexhull',\n    ]\n\n\ndef line(p0, p1, canvas, color=1):\n    '''\n    line((y0,x0), (y1,x1), canvas, color=1)\n\n    Draw a line\n\n    Parameters\n    ----------\n    p0 : pair of integers\n        first point\n    p1 : pair of integers\n        second point\n    canvas : ndarray\n        where to draw, will be modified in place\n    color : integer, optional\n        which value to store on the pixels (default: 1)\n\n    notes\n    -----\n    `Implementation Reference <http://en.wikipedia.org/wiki/Bresenham's_line_algorithm>`__\n    '''\n    y0,x0 = p0\n    y1,x1 = p1\n    steep = abs(y1-y0) > abs(x1 -x0)\n    if steep:\n        x0,y0 = y0,x0\n        x1,y1 = y1,x1\n    if x0 > x1:\n        x0,x1 = x1,x0\n        y0,y1 = y1,y0\n    dx = x1 - x0\n    dy = abs(y1-y0)\n    error = dx/2.\n    y = y0\n    ystep = (+1 if y0 < y1 else -1)\n    for x in range(x0,x1+1):\n        if steep:\n            canvas[x,y] = color\n        else:\n            canvas[y,x] = color\n        error -= dy\n        if error < 0:\n            y += ystep\n            error += dx\n\n\ndef fill_polygon(polygon, canvas, color=1):\n    '''\n    fill_polygon([(y0,x0), (y1,x1),...], canvas, color=1)\n\n    Draw a filled polygon in canvas\n\n    Parameters\n    ----------\n    polygon : list of pairs\n        a list of (y,x) points\n    canvas : ndarray\n        where to draw, will be modified in place\n    color : integer, optional\n        which colour to use (default: 1)\n    '''\n# algorithm adapted from: http://www.alienryderflex.com/polygon_fill/\n    if not len(polygon):\n        return\n    min_y = min(y for y,x in polygon)\n    max_y = max(y for y,x in polygon)\n    polygon = [(float(y),float(x)) for y,x in polygon]\n    if max_y < canvas.shape[0]:\n        max_y += 1\n    for y in range(min_y, max_y):\n        nodes = []\n        j = -1\n        for i,p in enumerate(polygon):\n            pj = polygon[j]\n            if p[0] < y and pj[0] >= y or pj[0] < y and p[0] >= y:\n                dy = pj[0] - p[0]\n                if dy:\n                    nodes.append( (p[1] + (y-p[0])/(pj[0]-p[0])*(pj[1]-p[1])) )\n                elif p[0] == y:\n                    nodes.append(p[1])\n            j = i\n        nodes.sort()\n        for n,nn in zip(nodes[::2],nodes[1::2]):\n            nn += 1\n            canvas[y, int(n):int(nn)] = color\n\ndef convexhull(bwimg):\n    '''\n    hull = convexhull(bwimg)\n\n    Compute the convex hull as a polygon\n\n    This is an implementation of the Graham Scan:\n    http://en.wikipedia.org/wiki/Graham_scan\n\n    Parameters\n    ----------\n    bwimg : ndarray\n        input image (interpreted as boolean). Only 2D arrays are supported.\n\n    Returns\n    -------\n    hull : ndarray\n        Set of (y,x) coordinates of hull corners\n    '''\n    bwimg = np.ascontiguousarray(bwimg, dtype=np.bool_)\n    if bwimg.ndim != 2:\n        raise ValueError('mahotas.polygon.convexhull: Only two-dimensional images supported')\n    return _convex.convexhull(bwimg)\n\ndef fill_convexhull(bwimg):\n    '''\n    hull = fill_convexhull(bwimg)\n\n    Compute the convex hull and return it as a binary mask\n\n    Parameters\n    ----------\n    bwimage : input image (interpreted as boolean)\n\n    Returns\n    -------\n    hull : image of same size and dtype as `bwimg` with the hull filled in.\n    '''\n\n    points = convexhull(bwimg)\n    canvas = np.zeros_like(bwimg)\n    black = (1 if bwimg.dtype == np.bool_ else 255)\n    fill_polygon(points, canvas, black)\n    canvas[bwimg] = black\n    return canvas\n\n"""
mahotas/resize.py,4,"b""# Copyright (C) 2010-2013, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# License: MIT (see COPYING file)\n\nfrom __future__ import division\nimport numpy as np\n\n__all__ = [\n    'imresize',\n    'resize_to',\n    'resize_rgb_to',\n    ]\n\ndef resize_to(im, nsize, order=3):\n    '''Resize image to a specified new size\n\n    Parameters\n    ----------\n    im : ndarray\n    nsize : sequence of numbers\n        Will be the new size of the array\n    order : integer, optional\n        Spline order to use (default: 3)\n\n    Returns\n    -------\n    im' : ndarray\n\n    See Also\n    --------\n    zoom : Similar function\n    imresize : A more flexible, but also confusing, version of this function\n    resize_rgb_to : A version appropriate for resize RGB images\n    '''\n    from .interpolate import zoom\n    if len(nsize) != im.ndim:\n        raise ValueError('mahotas.resize_to: new size does not have the same dimension as old one')\n    out = np.empty(nsize, dtype=im.dtype)\n    nsize = np.array(nsize, dtype=float)\n    nsize /= im.shape\n    return zoom(im, nsize, order=order, out=out)\n\n\ndef resize_rgb_to(im, nsize, order=3):\n    '''Resize an RGB image to size ``nsize``\n\n    Parameters\n    ----------\n    im : ndarray\n    nsize : sequence of 2 numbers\n        if nsize is ``(h,w)``, the new image will be ``(h,w,3)``\n    order : integer, optional\n        Spline order to use (default: 3)\n\n    Returns\n    -------\n    im' : ndarray\n\n    See Also\n    --------\n    zoom : Similar function\n    imresize : A more flexible, but also confusing, version of this function\n    resize_to : A generic version of this function\n    '''\n    from .internal import _check_3\n    _check_3(im, 'resize_rgb_to')\n    return np.dstack([resize_to(ch, nsize, order) for ch in im.transpose((2,0,1))])\n\ndef imresize(img, nsize, order=3):\n    '''Resizes image\n\n    This function works in two ways: if ``nsize`` is a tuple or list of\n    integers, then the result will be of this size; otherwise, this function\n    behaves the same as ``mh.interpolate.zoom``\n\n    Parameters\n    ----------\n    img : ndarray\n    nsize : float or tuple(float) or tuple(integers)\n        Size of return. Meaning depends on the type\n            float: img'.shape[i] = nsize * img.shape[i]\n            tuple of float: img'.shape[i] = nsize[i] * img.shape[i]\n            tuple of int: img'.shape[i] = nsize[i]\n    order : integer, optional\n        Spline order to use (default: 3)\n\n    Returns\n    -------\n    img' : ndarray\n\n    See Also\n    --------\n    zoom : Similar function\n    scipy.misc.pilutil.imresize : Similar function\n    '''\n    from .interpolate import zoom\n    if type(nsize) == tuple or type(nsize) == list:\n        if type(nsize[0]) == int:\n            nsize = np.array(nsize, dtype=float)\n            nsize /= img.shape\n    return zoom(img, nsize, order=order)\n"""
mahotas/segmentation.py,5,"b""# -*- coding: utf-8 -*-\n# Copyright (C) 2008-2013 Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# Carnegie Mellon University\n#\n# License: MIT (see COPYING file)\n\nfrom __future__ import division\nimport numpy as np\n\nfrom .internal import _check_3\nfrom . import _distance\nfrom . import _labeled\n\n__all__ = [\n    'gvoronoi',\n    'slic'\n    ]\n\ndef gvoronoi(labeled):\n    '''\n    segmented = gvoronoi(labeled)\n\n    Generalised Voronoi Transform.\n\n    The generalised Voronoi diagram assigns to the pixel (i,j) the label of the\n    nearest object (i.e., the value of the nearest non-zero pixel in labeled).\n\n    Parameters\n    ----------\n    labeled : ndarray\n        a labeled array, of a form similar to one returned by\n        ``mahotas.label()``\n\n    Returns\n    -------\n    segmented : is of the same size and type as labeled and\n                `segmented[y,x]` is the label of the object at position `y,x`.\n    '''\n    labeled = np.ascontiguousarray(labeled)\n    bw = (labeled == 0)\n    f = np.zeros(bw.shape, np.double)\n    f[bw] = len(f.shape)*max(f.shape)**2+1\n    orig = np.arange(f.size, dtype=np.intc).reshape(f.shape)\n    _distance.dt(f, orig)\n    return labeled.flat[orig]\n\n\ndef slic(array, spacer=16, m=1.0, max_iters=128):\n    '''Compute SLIC superpixel oversegmentation\n\n    Note: This function operates on the array values. In the original\n    publication, SLIC was applied in L*a*b* space.\n\n    To use the original mode, use::\n\n        rgb = mh.demos.load('lena')\n        lab = mh.colors.rgb2lab(rgb)\n        superseg,nr = mh.segmentation.slic(lab)\n\n    See the mahotas.color module for color space transformations\n\n    Parameters\n    ----------\n    array : ndarray\n    spacer : int, optional\n        x/y spacing between initial seeds. Initial seeds will be placed at\n        ``array[spacer/2::spacer,spacer/::spacer]``\n    m : float, optional\n        tradeoff between colour space and spatial distance.\n    max_iters : int, optional\n        Maximum number of k-means iterations. Generally this does not need to\n        be very large because the search is only local and convergence is\n        very fast, in which case, the algorithm will exit early. (default: 128)\n\n    Returns\n    -------\n    segmented : ndarray\n        A segmented area numbered 1..N. The general mahotas convention is that\n        region 0 is background. Thus, 1..N is used here.\n    n_segments : int\n        Number of segments\n\n    References\n    ----------\n    .. [1] Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi,\n        Pascal Fua, and Sabine S\xc3\xbcsstrunk, SLIC Superpixels Compared to\n        State-of-the-art Superpixel Methods, TPAMI, May 2012.\n    '''\n    array = np.ascontiguousarray(array, dtype=np.float32)\n    _check_3(array, 'slic')\n    labels = np.zeros((array.shape[0], array.shape[1]), dtype=np.intc)\n    labels = labels.copy()\n    n = _labeled.slic(array, labels, int(spacer), float(m), int(max_iters))\n    return labels, n\n"""
mahotas/stretch.py,27,"b'# -*- coding: utf-8 -*-\n# Copyright (C) 2009-2019, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n#  of this software and associated documentation files (the ""Software""), to deal\n#  in the Software without restriction, including without limitation the rights\n#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n#  copies of the Software, and to permit persons to whom the Software is\n#  furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n#  all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n#  THE SOFTWARE.\n\nfrom __future__ import division\nimport numpy as np\nfrom .internal import _check_2\n\n__all__ = [\n        \'as_rgb\',\n        \'overlay\',\n        \'stretch\',\n        \'stretch_rgb\',\n        ]\n\ndef stretch_rgb(img, arg0=None, arg1=None, dtype=np.uint8):\n    \'\'\'Variation of stretch() function that works per-channel on an RGB image\n\n    Parameters\n    ----------\n    img : ndarray\n        input image. It is *not modified* by this function\n    min : integer, optional\n        minimum value for output [default: 0]\n    max : integer, optional\n        maximum value for output [default: 255]\n    dtype : dtype of output,optional\n         [default: np.uint8]\n\n    Returns\n    -------\n    img\': ndarray\n        resulting image. ndarray of same shape as `img` and type `dtype`.\n\n    See Also\n    --------\n    stretch : function\n    \'\'\'\n    if img.ndim == 2:\n        return stretch(img, arg0, arg1, dtype)\n    elif img.ndim == 3:\n        return np.dstack([stretch(img[:,:,i], arg0, arg1, dtype) for i in range(img.shape[2])])\n    else:\n        raise ValueError(\'mahotas.stretch_rgb: Only works for RGB images\')\n\n\ndef stretch(img, arg0=None, arg1=None, dtype=np.uint8):\n    \'\'\'\n    img\' = stretch(img, [dtype=np.uint8])\n    img\' = stretch(img, max, [dtype=np.uint8])\n    img\' = stretch(img, min, max, [dtype=np.uint8])\n\n    Contrast stretch the image to the range [0, max] (first form) or [min, max]\n    (second form). The method is simple linear stretching according to the\n    formula::\n\n        p\' = max * (p - img.min())/img.ptp() + min\n\n    Parameters\n    ----------\n    img : ndarray\n        input image. It is *not modified* by this function\n    min : integer, optional\n        minimum value for output [default: 0]\n    max : integer, optional\n        maximum value for output [default: 255]\n    dtype : dtype of output,optional\n         [default: np.uint8]\n\n    Returns\n    -------\n    img\': ndarray\n        resulting image. ndarray of same shape as `img` and type `dtype`.\n\n    Notes\n    -----\n    If max > 255, then it truncates the values if dtype is not specified.\n    \'\'\'\n    if arg0 is None:\n        min = 0\n        max = 255\n    elif arg1 is None:\n        min = 0\n        max = arg0\n    else:\n        min = arg0\n        max = arg1\n    img = img.astype(np.double, copy=True)\n    img -= img.min()\n    ptp = img.ptp()\n    if not ptp:\n        img = np.zeros(img.shape, dtype)\n        if min:\n            img += min\n        return img\n    img *= float(max - min)/ptp\n    if min: img += min\n    return img.astype(dtype, copy=False)\n\ndef as_rgb(r, g, b):\n    \'\'\'\n    rgb = as_rgb(r, g, b)\n\n    Returns an RGB image with ``r`` in the red channel, ``g`` in the green, and\n    ``b`` in the blue. The channels are contrast stretched.\n\n    If any of the channels is `None`, that channel is set to zero. The same can\n    be achieved by passing ``0`` as that channels value. In fact, passing a\n    number as a channel value will set the whole channel to that value.\n\n    Examples\n    --------\n\n    This shows a nice looking picture::\n\n        z1 = np.linspace(0, np.pi)\n        X,Y = np.meshgrid(z1, z1)\n        red = np.sin(X)\n        green = np.cos(4*Y)\n        blue = X*Y\n\n        plt.imshow(mahotas.as_rgb(red, green, blue))\n\n    Notice that the scaling on the ``blue`` channel is so different from the\n    other channels (from 0..2500 compared with 0..1), but ``as_rgb`` stretches\n    each channel independently.\n\n    Parameters\n    ----------\n    r,g,b : array-like or int, optional\n        The channels can be of any type or None.\n        At least one must be not None and all must have the same shape.\n\n    Returns\n    -------\n    rgb : ndarray\n        RGB ndarray\n    \'\'\'\n    for c in (r,g,b):\n        if c is not None:\n            c = np.array(c)\n            shape = c.shape\n            if shape != ():\n                break\n    else:\n        raise ValueError(\'mahotas.as_rgb: Not all arguments can be None\')\n    def s(c):\n        if c is None:\n            return np.zeros(shape, np.uint8)\n        c = np.asanyarray(c)\n        if c.shape == ():\n            c = np.tile(c, shape)\n            return c.astype(np.uint8, copy=False)\n        elif c.shape != shape:\n            sh = lambda c : (c.shape if c is not None else \' . \')\n            raise ValueError(\'mahotas.as_rgb: Not all arguments have the same shape. Shapes were : %s\' % [sh(r), sh(g), sh(b)])\n        return stretch(c)\n    return np.dstack([s(r), s(g), s(b)])\n\n\ndef overlay(gray, red=None, green=None, blue=None, if_gray_dtype_not_uint8=\'stretch\'):\n    \'\'\'\n    Create an image which is greyscale, but with possible boolean overlays.\n\n    Parameters\n    ----------\n    gray: ndarray of type np.uint8\n        Should be a greyscale image of type np.uint8\n\n    red,green,blue : ndarray, optional\n        boolean arrays\n\n    if_gray_dtype_not_uint8 : str, optional\n        What to do if ``gray`` is not of type ``np.uint8``, must be one of\n            \'stretch\' (default): the function ``stretch`` is called.\n            \'error\' : in this case, an error is raised\n\n    Returns\n    -------\n    overlaid : ndarray\n        Colour image\n    \'\'\'\n    _check_2(gray, \'overlay\')\n    if gray.dtype != np.uint8:\n        if if_gray_dtype_not_uint8 == \'stretch\':\n            gray = stretch(gray)\n        else:\n            raise ValueError(\'mahotas.overlay: first argument should be of dtype np.uint8\')\n    def _v(ch):\n        if ch is None:\n            return gray\n        ch = ch.astype(bool, copy=False)\n        ch = 255*ch\n        return np.maximum(gray, ch)\n    r = _v(red)\n    g = _v(green)\n    b = _v(blue)\n    return np.dstack([r,g,b]).astype(gray.dtype, copy=False)\n'"
mahotas/surf.py,0,"b""import warnings\nwarnings.warn(\n'''Use\n\nfrom mahotas.features import surf\n''', DeprecationWarning)\n\nfrom mahotas.features.surf import *\n"""
mahotas/tas.py,0,"b""import warnings\nwarnings.warn(\n'''Use\n\nfrom mahotas.features import tas\n''', DeprecationWarning)\n\nfrom mahotas.features.tas import *\n"""
mahotas/texture.py,0,"b""import warnings\nwarnings.warn(\n'''Use\n\nfrom mahotas.features import texture\n''', DeprecationWarning)\n\nfrom mahotas.features.texture import *\n"""
mahotas/thin.py,3,"b'# -*- coding: utf-8 -*-\n# Copyright (C) 2006-2015  Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# License: MIT (see COPYING file)\n\nfrom __future__ import division\nimport numpy as np\n\n__all__ = [\'thin\']\n\ndef thin(binimg, max_iter=-1):\n    """"""\n    skel = thin(binimg)\n\n    Skeletonisation by thinning\n\n    Parameters\n    ----------\n    binimg : ndarray\n        Binary input image\n    max_iter : int, optional\n        Maximum number of iterations (set to a negative number, the default, to\n        run full skeletonization)\n\n    Returns\n    -------\n    skel : Skeletonised version of `binimg`\n    """"""\n    from .bbox import bbox\n    from ._thin import thin as _thin\n\n    res = np.zeros_like(binimg)\n    min0,max0,min1,max1 = bbox(binimg)\n    r,c = (max0-min0,max1-min1)\n\n    image_exp = np.zeros((r+2, c+2), bool)\n    image_exp[1:r+1, 1:c+1] = binimg[min0:max0,min1:max1]\n    imagebuf = np.empty((r+2,c+2), bool)\n\n    _thin(image_exp, imagebuf, int(max_iter))\n    res[min0:max0,min1:max1] = image_exp[1:r+1, 1:c+1]\n    return res\n\n'"
mahotas/thresholding.py,7,"b'# -*- coding: utf-8 -*-\n# Copyright (C) 2008-2019, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n#  of this software and associated documentation files (the ""Software""), to deal\n#  in the Software without restriction, including without limitation the rights\n#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n#  copies of the Software, and to permit persons to whom the Software is\n#  furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n#  all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n#  THE SOFTWARE.\n\n\'\'\'\nThresholding Module\n===================\n\nThresholding functions.\n\nThese functions return **the numeric threshold**. In order to obtain a\n*thresholded image*, you can do the following::\n\n    T_otsu = mh.otsu(image)\n    binarized_image = (image > T_otsu)\n\nFunctions which have an ``ignore_zeros`` parameters will only consider non-zero\npixels when computing the thresholding.\n\n:otsu(): Otsu method\n:rc(): Riddler-Calvard\'s method\n:bernsen: Bernsen thresholding\n:gbernsen: Generalized Bernsen thresholding\n\'\'\'\n\nfrom __future__ import division\nimport numpy as np\nfrom .histogram import fullhistogram\nfrom . import _histogram\nfrom .internal import _verify_is_integer_type\n__all__ = [\n        \'otsu\',\n        \'rc\',\n        \'soft_threshold\',\n        \'bernsen\',\n        \'gbernsen\',\n    ]\n\n\ndef otsu(img, ignore_zeros=False):\n    """"""\n    T = otsu(img, ignore_zeros=False)\n\n    Calculate a threshold according to the Otsu method.\n\n    Example::\n\n        import mahotas as mh\n        import mahotas.demos\n\n        im = mahotas.demos.nuclear_image()\n        # im is stored as RGB, let\'s convert to single 2D format:\n        im = im.max(2)\n\n        #Now, we compute Otsu:\n        t = mh.otsu(im)\n\n        # finally, we use the value to form a binary image:\n        bin = (im > t)\n\n    See Wikipedia for details on methods:\n    http://en.wikipedia.org/wiki/Otsu\'s_method\n\n    Parameters\n    ----------\n    img : an image as a numpy array.\n        This should be of an unsigned integer type.\n    ignore_zeros : Boolean\n        whether to ignore zero-valued pixels\n        (default: False)\n\n    Returns\n    -------\n    T : integer\n        the threshold\n    """"""\n    _verify_is_integer_type(img, \'otsu\')\n    hist = fullhistogram(img)\n    hist = np.asanyarray(hist, dtype=np.double)\n    if ignore_zeros:\n        hist[0] = 0\n    return _histogram.otsu(hist)\n\n\ndef rc(img, ignore_zeros=False):\n    """"""\n    T = rc(img, ignore_zeros=False)\n\n    Calculate a threshold according to the Riddler-Calvard method.\n\n    Example::\n\n        import mahotas as mh\n        import mahotas.demos\n\n        im = mahotas.demos.nuclear_image()\n        # im is stored as RGB, let\'s convert to single 2D format:\n        im = im.max(2)\n\n        #Now, we compute a threshold:\n        t = mh.rc(im)\n\n        # finally, we use the value to form a binary image:\n        bin = (im > t)\n\n    Parameters\n    ----------\n    img : ndarray\n        Image of any type\n    ignore_zeros : boolean, optional\n        Whether to ignore zero valued pixels (default: False)\n\n    Returns\n    -------\n    T : float\n        threshold\n    """"""\n    hist = fullhistogram(img)\n    if ignore_zeros:\n        if hist[0] == img.size:\n            return 0\n        hist[0] = 0\n    N = hist.size\n\n    # Precompute most of what we need:\n    first_moment = np.cumsum(np.arange(N) * hist)\n    cumsum = np.cumsum(hist)\n\n    r_first_moment = np.flipud(np.cumsum(np.flipud(np.arange(N) * hist)))\n    r_cumsum = np.flipud(np.cumsum(np.flipud(hist)))\n\n    maxt = N-1\n    while hist[maxt] == 0:\n        maxt -= 1\n\n    res = maxt\n    t = 0\n    while t < min(maxt, res):\n        if cumsum[t] and r_cumsum[t+1]:\n            res = (first_moment[t]/cumsum[t] + r_first_moment[t+1]/r_cumsum[t+1])/2\n        t += 1\n    return res\n\ndef soft_threshold(f, tval):\n    \'\'\'\n    thresholded = soft_threshold(f, tval)\n\n    Soft threshold function::\n\n                             ^\n                             |           /\n                             |          /\n                             |         /\n                             |        /\n                             |       /\n         - - - - - - - - - - - - - - - - - ->\n                      /      |\n                     /       |\n                    /        |\n                   /         |\n                  /          |\n                 /           |\n\n    Parameters\n    ----------\n    f : ndarray\n    tval : scalar\n\n    Returns\n    -------\n    thresholded : ndarray\n    \'\'\'\n\n    f = f * (np.abs(f) > tval)\n    f -= tval * (f > tval)\n    f += tval * (f < -tval)\n    return f\n\ndef bernsen(f, radius, contrast_threshold, gthresh=None):\n    \'\'\'\n    thresholded = bernsen(f, radius, contrast_threshold, gthresh={128})\n\n    Bernsen local thresholding\n\n    Parameters\n    ----------\n    f : ndarray\n        input image\n    radius : integer\n        radius of circle (to consider ""local"")\n    contrast_threshold : integer\n        contrast threshold\n    gthresh : numeric, optional\n        global threshold to fall back in low contrast regions\n\n    Returns\n    -------\n    thresholded : binary ndarray\n\n    See Also\n    --------\n    gbernsen : function\n        Generalised Bernsen thresholding\n    \'\'\'\n    from mahotas.morph import circle_se\n    if gthresh is None:\n        gthresh = 128\n    return gbernsen(f, circle_se(radius), contrast_threshold, gthresh)\n\ndef gbernsen(f, se, contrast_threshold, gthresh):\n    \'\'\'\n    thresholded = gbernsen(f, se, contrast_threshold, gthresh)\n\n    Generalised Bernsen local thresholding\n\n    Parameters\n    ----------\n    f : ndarray\n        input image\n    se : boolean ndarray\n        structuring element to use for ""locality""\n    contrast_threshold : integer\n        contrast threshold\n    gthresh : numeric, optional\n        global threshold to fall back in low contrast regions\n\n    Returns\n    -------\n    thresholded : binary ndarray\n\n    See Also\n    --------\n    bernsen : function\n        Bernsen thresholding with a circular region\n    \'\'\'\n    from mahotas.convolve import rank_filter\n    fmax = rank_filter(f, se, se.sum()-1)\n    fmin = rank_filter(f, se, 0)\n    fptp = fmax - fmin\n    fmean = fmax/2. + fmin/2. # Do not use (fmax + fmin) as that may overflow\n    return np.choose(fptp < contrast_threshold, (fmean < gthresh, fmean > f))\n\n'"
mahotas/zernike.py,0,"b""import warnings\nwarnings.warn(\n'''Use\n\nfrom mahotas.features import zernike\n''', DeprecationWarning)\n\nfrom mahotas.features.zernike import *\n"""
docs/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# The contents of this file are pickled, so don\'t put values in the namespace\n# that aren\'t pickleable (module imports are okay, they\'re removed automatically).\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nfrom mahotas import __version__ as mahotas_version\n\nextensions = [\n        \'sphinx.ext.autodoc\',\n        \'sphinx.ext.imgmath\',\n        \'sphinx.ext.intersphinx\',\n        \'sphinx.ext.coverage\',\n        \'sphinx.ext.doctest\',\n        \'numpydoc\',\n        \'matplotlib.sphinxext.only_directives\',\n        \'matplotlib.sphinxext.plot_directive\',\n        ]\n\n\n# General configuration\n# ---------------------\n\n# Necessary for imgmath\nneeds_sphinx = \'1.4.3\'\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\nsource_encoding = \'utf-8\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'mahotas\'\ncopyright = u\'2008-2016, Luis Pedro Coelho\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = mahotas_version[:3]\n# The full version, including alpha/beta/rc tags.\nrelease = mahotas_version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\nlanguage = \'en\'\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of documents that shouldn\'t be included in the build.\n#unused_docs = []\n\n# List of directories, relative to source directory, that shouldn\'t be searched\n# for source files.\nexclude_trees = []\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n\n# Options for HTML output\n# -----------------------\n\n# The style sheet to use for HTML and HTML Help pages. A file of that name\n# must exist either in Sphinx\' static/ path, or in one of the custom paths\n# given in html_static_path.\n#html_style = \'default.css\'\nhtml_theme = \'default\'\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\n# html_static_path = [\'_static\']\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n    \'*\': [\'searchbox.html\', \'sidebar.html\'],\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_use_modindex = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, the reST sources are included in the HTML build as _sources/<name>.\n#html_copy_source = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# If nonempty, this is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = \'\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'mahotas\'\n\n\n# Options for plot output\n# -----------------------\nplot_include_source = True\n \n# Options for LaTeX output\n# ------------------------\n\n# The paper size (\'letter\' or \'a4\').\n#latex_paper_size = \'letter\'\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#latex_font_size = \'10pt\'\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, document class [howto/manual]).\nlatex_documents = [\n  (\'index\', \'mahotas.tex\', ur\'mahotas Documentation\',\n   ur\'Luis Pedro Coelho\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# Additional stuff for the LaTeX preamble.\n#latex_preamble = \'\'\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_use_modindex = True\n'"
mahotas/demos/__init__.py,0,"b'\'\'\'Demo Module\n\nIncludes functions to load demo images:\n\nwally\n    Colour image of ""Find Wally""    \nlena\n    The classic Lena image\nluispedro\n    A colour photograph\nnuclear\n    A fluorescent microscopy image of cell nuclei\n\'\'\'\ndef image_path(name):\n    from os import path\n    import mahotas as mh\n    return path.join(path.abspath(path.dirname(__file__)),\n                \'data\',\n                name)\n\n\ndef load(image_name, as_grey=None):\n    \'\'\'\n    Loads a demo image\n\n    Parameters\n    ----------\n    image_name : str\n        Name of one of the demo images\n    as_grey : bool, optional\n        Whether to convert to greyscale\n\n    Returns\n    -------\n    im : ndarray\n        Image\n    \'\'\'\n    from os import path\n    import mahotas as mh\n    _demo_images  = {\n        \'wally\' : \'DepartmentStore.jpg\',\n        \'departmentstore\' : \'DepartmentStore.jpg\',\n        \'lenna\' : \'lena.jpg\',\n        \'lena\' : \'lena.jpg\',\n        \'luispedro\' : \'luispedro.jpg\',\n        \'nuclear\' : \'nuclear.png\',\n    }\n    if image_name.lower() not in _demo_images:\n        raise KeyError(\'mahotas.demos.load: Unknown demo image ""{}"", known images are {}\'.format(image_name, list(_demo_images.keys())))\n\n    image_name = image_path(_demo_images[image_name.lower()])\n    return mh.imread(image_name, as_grey=as_grey)\n\ndef nuclear_image():\n    \'\'\'\n    Loads the nuclear example image\n\n    Returns\n    -------\n    im : ndarray\n        nuclear image\n    \'\'\'\n    return load(\'nuclear\')\n    \n'"
mahotas/demos/distance.py,1,"b'from __future__ import print_function\n\nimport pylab as p\nimport numpy as np\nimport mahotas\n\nf = np.ones((256,256), bool)\nf[200:,240:] = False\nf[128:144,32:48] = False\n# f is basically True with the exception of two islands: one in the lower-right\n# corner, another, middle-left\n\ndmap = mahotas.distance(f)\np.imshow(dmap)\np.show()\n'"
mahotas/demos/edge_demo.py,1,"b""import mahotas\nimport numpy as np\nfrom pylab import imshow, gray, show, subplot\nfrom os import path\n\nlena_image = path.join(\n                    path.dirname(path.abspath(__file__)),\n                    'data',\n                    'lena.jpg')\n\nphoto = mahotas.imread(lena_image, as_grey=True)\nphoto = photo.astype(np.uint8)\n\ngray()\nsubplot(131)\nimshow(photo)\n\nedge_sobel = mahotas.sobel(photo)\nsubplot(132)\nimshow(edge_sobel)\n\nedge_dog = mahotas.dog(photo)\nsubplot(133)\nimshow(edge_dog)\nshow()\n"""
mahotas/demos/morphology.py,0,"b""from __future__ import print_function\nimport mahotas as mh\nfrom pylab import gray, imshow, show\n\n\nluispedro = mh.demos.load('luispedro')\nluispedro = luispedro.max(2)\nT = mh.otsu(luispedro)\nlpbin = (luispedro > T)\neye = lpbin[112:180,100:190]\ngray()\nimshow(eye)\nshow()\nimshow(~mh.morph.close(~eye))\nshow()\nimshow(~mh.morph.open(~eye))\nshow()\n"""
mahotas/demos/nuclear.py,1,"b""import mahotas\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\nplt.subplot(3,2,1)\nf = mahotas.demos.load('nuclear')\nf = f[:,:,0]\nplt.title('input image, first channel')\nplt.imshow(f)\n\n\nplt.subplot(3,2,2)\nf = mahotas.gaussian_filter(f, 4)\nf = (f> f.mean())\nplt.title('gaussian_filter')\nplt.imshow(f)\n\n\nplt.subplot(3,2,3)\nlabeled, n_nucleus  = mahotas.label(f)\nplt.title('Found {} nuclei.'.format(n_nucleus))\nplt.imshow(labeled)\n\n\nplt.subplot(3,2,4)\nsizes = mahotas.labeled.labeled_size(labeled)\ntoo_big = np.where(sizes > 10000)\nlabeled = mahotas.labeled.remove_regions(labeled, too_big)\nplt.title('remove_regions')\nplt.imshow(labeled)\n\n\nplt.subplot(3,2,5)\nlabeled = mahotas.labeled.remove_bordering(labeled)\nplt.title('remove_bordering')\nplt.imshow(labeled)\n\n\nplt.subplot(3,2,6)\nrelabeled, n_left = mahotas.labeled.relabel(labeled)\nplt.title('After filtering and relabeling, there are {} nuclei left.'.format(n_left))\nplt.imshow(relabeled)\n\n\nplt.tight_layout()\nplt.show()\n"""
mahotas/demos/nuclear_distance_watershed.py,1,"b""import mahotas as mh\nfrom os import path\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nnuclear = mh.demos.load('nuclear')\nnuclear = nuclear[:,:,0]\nnuclear = mh.gaussian_filter(nuclear, 1.)\nthreshed  = (nuclear > nuclear.mean())\ndistances = mh.stretch(mh.distance(threshed))\nBc = np.ones((9,9))\n\nmaxima = mh.morph.regmax(distances, Bc=Bc)\nspots,n_spots = mh.label(maxima, Bc=Bc)\nsurface = (distances.max() - distances)\nareas = mh.cwatershed(surface, spots)\nareas *= threshed\n\n\n\nimport random\nfrom matplotlib import colors\nfrom matplotlib import cm\ncols = [cm.jet(c) for c in range(0, 256, 4)]\nrandom.shuffle(cols)\ncols[0] = (0.,0.,0.,1.)\nrmap = colors.ListedColormap(cols)\nplt.imshow(areas, cmap=rmap)\nplt.show()\n"""
mahotas/demos/superpixels.py,0,"b""import random\nimport matplotlib\nfrom matplotlib import pyplot as plt\n\nimport mahotas\n\nf = mahotas.imread('mahotas/demos/data/luispedro.jpg')\ncolors = [plt.cm.jet(c) for c in  range(256)]\nrandom.seed(23)\nrandom.shuffle(colors)\ncmap = matplotlib.colors.ListedColormap (colors)\n\nsegmented, _ = mahotas.segmentation.slic(f, 16)\nplt.imshow(segmented, cmap=cmap)\nplt.show()\n\nsegmented, _ = mahotas.segmentation.slic(f, 64)\nplt.imshow(segmented, cmap=cmap)\nplt.show()\n\nsegmented, _ = mahotas.segmentation.slic(f, 128)\nplt.imshow(segmented, cmap=cmap)\nplt.show()\n\n"""
mahotas/demos/surf_gaussians.py,4,"b'from __future__ import print_function\nfrom pylab import imshow, show\nimport numpy as np\nfrom mahotas.features import surf\n\nf = np.zeros((1024,1024))\nY,X = np.indices(f.shape)\nY -= 768\nX -= 768\nf += 120*np.exp(-Y**2/2048.-X**2/480.)\nY += 512\nX += 512\nrho = .7\nf += 120*np.exp(-1./( 2*(1-rho**2)) *( Y**2/32/32.+X**2/24/24. + 2*rho*X*Y/32./24.))\nfi = surf.integral(f.copy())\nspoints = surf.surf(f, 6, 24, 1)\n\nf2 = surf.show_surf(f, spoints)\nimshow(f2)\nshow()\n'"
mahotas/demos/surf_luispedro.py,4,"b'from __future__ import print_function\nimport numpy as np\nimport mahotas as mh\nfrom mahotas.features import surf\nfrom matplotlib import pyplot as plt\n\nf = mh.demos.load(\'luispedro\', as_grey=True)\nf = f.astype(np.uint8)\nspoints = surf.surf(f, 4, 6, 2)\nprint(""Nr points:"", len(spoints))\n\ntry:\n    from sklearn.cluster import KMeans\n    descrs = spoints[:,5:]\n    k = 5\n    values = KMeans(n_clusters=k).fit(descrs).labels_\n    colors = np.array([(255-52*i,25+52*i,37**i % 101) for i in range(k)])\nexcept:\n    values = np.zeros(100, int)\n    colors = np.array([(255,0,0)])\n\nf2 = surf.show_surf(f, spoints[:100], values, colors)\nfig,ax = plt.subplots()\nax.imshow(f2)\nfig.show()\n'"
mahotas/demos/thresholding.py,1,"b""import mahotas\nimport numpy as np\nfrom pylab import imshow, gray, show, subplot\nfrom os import path\n\nluispedro_image = path.join(\n                    path.dirname(path.abspath(__file__)),\n                    'data',\n                    'luispedro.jpg')\n\nphoto = mahotas.imread(luispedro_image, as_grey=True)\nphoto = photo.astype(np.uint8)\n\ngray()\nsubplot(131)\nimshow(photo)\n\nT_otsu = mahotas.otsu(photo)\nprint(T_otsu)\nsubplot(132)\nimshow(photo > T_otsu)\n\nT_rc = mahotas.rc(photo)\nprint(T_rc)\nsubplot(133)\nimshow(photo > T_rc)\nshow()\n\n"""
mahotas/demos/wally.py,3,"b""from pylab import imshow\nimport mahotas as mh\nimport numpy as np\n\nwally = mh.demos.load('DepartmentStore')\nwfloat = wally.astype(float)\nr,g,b = wfloat.transpose((2,0,1))\nw = wfloat.mean(2)\npattern = np.ones((24,16), float)\nfor i in range(2):\n    pattern[i::4] = -1\nv = mh.convolve(r-w, pattern)\nmask = (v == v.max())\nmask = mh.dilate(mask, np.ones((48,24)))\nwally -= np.array(.8*wally * ~mask[:,:,None], dtype=wally.dtype)\nimshow(wally)\n\n\n"""
mahotas/demos/wavelet_compress.py,6,"b'from __future__ import print_function\nimport numpy as np\nimport mahotas\nfrom mahotas.thresholding import soft_threshold\nfrom matplotlib import pyplot as plt\nfrom os import path\n\n# Let us load the data first:\nluispedro_image = path.join(\n                    path.dirname(path.abspath(__file__)),\n                    \'data\',\n                    \'luispedro.jpg\')\n\nf = mahotas.imread(luispedro_image, as_grey=True)\nf = f[:256,:256]\nplt.gray()\n# Show the data:\nplt.imshow(f)\nprint(""Fraction of zeros in original image:"", np.mean(f==0))\n\n# A baseline compression method: save every other pixel and only high-order bits:\ndirect = f[::2,::2].copy()\ndirect /= 8\ndirect = direct.astype(np.uint8)\nprint(""Fraction of zeros in original image (after division by 8):"", np.mean(direct==0))\nplt.imshow(direct)\n\n\n# Transform using D8 Wavelet to obtain transformed image t:\nt = mahotas.daubechies(f,\'D8\')\nplt.imshow(t)\n\n# Discard low-order bits:\nt /= 8\nt = t.astype(np.int8)\nprint(""Fraction of zeros in transform (after division by 8):"", np.mean(t==0))\nplt.imshow(t)\n\n# Let us look at what this looks like\nr = mahotas.idaubechies(t, \'D8\')\nplt.imshow(r)\n\n# Go further, discard small values in the transformed space:\ntt = soft_threshold(t, 12)\nprint(""Fraction of zeros in transform (after division by 8 & soft thresholding):"", np.mean(tt==0))\n\n# Let us look again at what we have:\nrt = mahotas.idaubechies(tt, \'D8\')\nplt.imshow(rt)\n'"
mahotas/features/__init__.py,0,"b""# -*- coding: utf-8 -*-\n# Copyright (C) 2012-2014, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n\nfrom .texture import haralick\nfrom .tas import tas, pftas\nfrom .zernike import zernike, zernike_moments\nfrom .lbp import lbp\nfrom .shape import roundness, eccentricity, ellipse_axes\n\n__all__ = [\n    'eccentricity',\n    'ellipse_axes',\n    'haralick',\n    'lbp',\n    'pftas',\n    'roundness',\n    'tas',\n    'zernike',\n    'zernike_moments',\n    ]\n"""
mahotas/features/lbp.py,20,"b""# -*- coding: utf-8 -*-\n# Copyright (C) 2008-2009 Robert Webb and Luis Pedro Coelho <luis@luispedro.org>\n# Copyright (C) 2011-2013 Luis Pedro Coelho <luis@luispedro.org>\n#\n# License: MIT (see COPYING file)\n\nimport numpy as np\nfrom ..histogram import fullhistogram\n\n__all__ = [\n    'lbp',\n    'lbp_transform',\n    ]\n\ndef lbp_transform(image, radius, points, ignore_zeros=False, preserve_shape=True):\n    '''\n    transformed = lbp(image, radius, points, ignore_zeros=False, preserve_shape=True)\n\n    Compute Linear Binary Pattern Transform\n\n    The return value are the transformed pixel values  **histogram** of feature counts, where position ``i``\n    corresponds to the number of pixels that had code ``i``. The codes are\n    compressed so that impossible codes are not used. Therefore, this is the\n    ``i``th feature, not just the feature with binary code ``i``.\n\n    Parameters\n    ----------\n    image : ndarray\n        input image (2-D numpy ndarray)\n    radius : number (integer or floating point)\n        radius (in pixels)\n    points : integer\n        nr of points to consider\n    ignore_zeros : boolean, optional\n        whether to ignore zeros. Note that if you set this to ``True``, you\n        will need to set ``preserve_shape`` to False. (default: False)\n    preserve_shape : boolean, optional\n        whether to return an array with the same shape as ``image``. (default:\n        True)\n\n    Returns\n    -------\n    features : 1-D numpy ndarray\n        histogram of features. See above for a caveat on the interpretation of\n        these.\n\n    References\n    ----------\n    Gray Scale and Rotation Invariant Texture Classification with Local Binary Patterns\n        Ojala, T. Pietikainen, M. Maenpaa, T. Lecture Notes in Computer Science (Springer)\n        2000, ISSU 1842, pages 404-420\n    '''\n    from ..interpolate import shift\n    from mahotas.features import _lbp\n\n    if ignore_zeros and preserve_shape:\n        raise ValueError('mahotas.features.lbp_transform: *ignore_zeros* and *preserve_shape* cannot both be used together')\n\n    image = np.asanyarray(image, dtype=np.float64)\n    if image.ndim != 2:\n        raise ValueError('mahotas.features.lbp_transform: This function is only defined for two dimensional images')\n\n    if ignore_zeros:\n        Y,X = np.nonzero(image)\n        def select(im):\n            return im[Y,X].ravel()\n    else:\n        select = np.ravel\n\n    pixels = select(image)\n    angles = np.linspace(0, 2*np.pi, points+1)[:-1]\n    data = []\n    for dy,dx in zip(np.sin(angles), np.cos(angles)):\n        data.append(\n            select(shift(image, [radius*dy,radius*dx], order=1)))\n    data = np.array(data)\n    codes = (data > pixels).astype(np.int32)\n    codes *= (2**np.arange(points)[:,np.newaxis])\n    codes = codes.sum(0)\n    codes = _lbp.map(codes.astype(np.uint32), points)\n    if preserve_shape:\n        codes = codes.reshape(image.shape)\n    return codes\n\ndef count_binary1s(array):\n    '''\n    one_count = count_binary1s(array)\n\n    Count the number of 1s in the binary representation of integer values\n\n    Definition::\n\n        one_count.flat[i] == nr_of_1s_in_binary_representation_of(array.flat[i])\n\n    Parameters\n    ----------\n    array : ndarray\n        input array\n\n    Returns\n    -------\n    one_count : ndarray\n        output array of same type & shape as array\n    '''\n    from ..internal import _verify_is_integer_type\n    array = np.array(array)\n    _verify_is_integer_type(array, 'mahotas.features.lbp.count_binary1s')\n    maxv = 1+int(np.log2(1+array.max()))\n    counts = np.zeros_like(array)\n    for _ in range(maxv):\n        counts += (array & 1)\n        array >>= 1\n    return counts\n\n\ndef lbp(image, radius, points, ignore_zeros=False):\n    '''\n    features = lbp(image, radius, points, ignore_zeros=False)\n\n    Compute Linear Binary Patterns\n\n    The return value is a **histogram** of feature counts, where position ``i``\n    corresponds to the number of pixels that had code ``i``. The codes are\n    compressed so that impossible codes are not used. Therefore, this is the\n    ``i``th feature, not just the feature with binary code ``i``.\n\n    Parameters\n    ----------\n    image : ndarray\n        input image (2-D numpy ndarray)\n    radius : number (integer or floating point)\n        radius (in pixels)\n    points : integer\n        nr of points to consider\n    ignore_zeros : boolean, optional\n        whether to ignore zeros (default: False)\n\n    Returns\n    -------\n    features : 1-D numpy ndarray\n        histogram of features. See above for a caveat on the interpretation of\n        these.\n\n    References\n    ----------\n    Gray Scale and Rotation Invariant Texture Classification with Local Binary Patterns\n        Ojala, T. Pietikainen, M. Maenpaa, T. Lecture Notes in Computer Science (Springer)\n        2000, ISSU 1842, pages 404-420\n    '''\n    from mahotas.features import _lbp\n    codes = lbp_transform(image, radius, points, ignore_zeros=ignore_zeros, preserve_shape=False)\n    final = fullhistogram(codes.astype(np.uint32))\n\n    codes = np.arange(2**points, dtype=np.uint32)\n    iters = codes.copy()\n    codes = _lbp.map(codes.astype(np.uint32), points)\n    pivots = (codes == iters)\n    npivots = np.sum(pivots)\n    compressed = final[pivots[:len(final)]]\n    compressed = np.append(compressed, np.zeros(npivots - len(compressed)))\n    return compressed\n\ndef lbp_names(radius, points):\n    '''Return list of names (string) for LBP features\n\n    Parameters\n    ----------\n    radius : number (integer or floating point)\n        radius (in pixels)\n    points : integer\n        nr of points to consider\n\n    Returns\n    -------\n    names : list of str\n\n    See Also\n    --------\n    lbp : function\n        Compute LBP features\n    '''\n    from mahotas.features import _lbp\n    codes = np.arange(2**points, dtype=np.uint32)\n    iters = codes.copy()\n    codes = _lbp.map(codes.astype(np.uint32), points)\n    pivots = (codes == iters)\n    npivots = np.sum(pivots)\n    return ['lbp_r{}_p{}_{}'.format(radius, points, i) for i in range(npivots)]\n\n"""
mahotas/features/moments.py,7,"b""# Copyright (C) 2008-2018, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# \n# License: MIT (see COPYING file)\n\nfrom __future__ import division\nimport numpy as np\n\n__all__ = ['moments']\ndef moments(img, p0, p1, cm=None, convert_to_float=True, normalize=False, normalise=False):\n    '''\n    m = moments(img, p0, p1, cm=(0, 0), convert_to_float=True)\n\n    Returns the p0-p1 moment of image `img`\n\n    The formula computed is\n\n    \\sum_{ij} { img[i,j] (i - c0)**p0 (j - c1)**p1 }\n\n    where cm = (c0,c1). If `cm` is not given, then (0,0) is used.\n\n    If image is of an integer type, then it is internally converted to\n    np.float64, unlesss `convert_to_float` is False. The reason is that,\n    otherwise, overflow is likely except for small images. Since this\n    conversion takes longer than the computation, you can turn it off in case\n    you are sure that your images are small enough for overflow to be an issue.\n    Note that no conversion is made if `img` is of any floating point type.\n\n    Parameters\n    ----------\n    img : 2-ndarray\n        An 2-d ndarray\n    p0 : float\n        Power for first dimension\n    p1 : float\n        Power for second dimension\n    cm : (int,int), optional\n        center of mass (default: 0,0)\n    convert_to_float : boolean, optional\n        whether to convert to floating point (default: True)\n    normalize : boolean, optional\n        whether to normalize to size of image (default: False)\n\n    Returns\n    -------\n    moment: float\n        floating point number\n\n    Notes\n    -----\n    It only works for 2-D images\n    '''\n    if normalise:\n        normalize = True\n    if not np.issubdtype(img.dtype, np.floating) and convert_to_float:\n        img = img.astype(np.float64)\n    r,c = img.shape\n    p = np.arange(c, dtype=float)\n    if cm is not None:\n        p -= cm[1]\n    p **= p1\n    if normalize:\n        p /= p.sum()\n    inter = np.dot(img, p)\n    p = np.arange(r, dtype=float)\n    if cm is not None:\n        p -= cm[0]\n    p **= p0\n    if normalize:\n        p /= p.sum()\n    return np.dot(inter, p)\n\n"""
mahotas/features/shape.py,9,"b'# -*- coding: utf-8 -*-\n# Copyright (C) 2012-2014, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\nfrom __future__ import division\nimport numpy as np\nimport mahotas as mh\nfrom ..labeled import bwperim\nfrom ..internal import _make_binary\n\n__all__ = [\n    \'roundness\',\n    \'eccentricity\',\n    \'ellipse_axes\',\n    ]\n\ndef roundness(bw):\n    \'\'\'\n    r = roundness(bw)\n\n    Roundness\n\n    Parameters\n    ----------\n    bw : ndarray\n        Interpreted as a boolean image\n\n    Returns\n    -------\n    r : float\n    \'\'\'\n    bw = _make_binary(bw)\n    area = np.sum(bw)\n    perim = np.sum(bwperim(bw))\n    if area == 0:\n        return 0.\n    return float(perim)*perim/4./np.pi/area\n\n\ndef ellipse_axes(bwimage):\n    \'\'\' Parameters of the \'image ellipse\'\n\n    semimajor,semiminor = ellipse_axes(bwimage)\n\n    Returns the parameters of the constant intensity ellipse with the same mass\n    and second order moments as the original image.\n\n    Parameters\n    ----------\n    bwimage : ndarray\n        Interpreted as a boolean image\n\n    Returns\n    -------\n    semimajor : float\n    semiminor : float\n\n    References\n    ----------\n    Prokop, RJ, and Reeves, AP.  1992. CVGIP: Graphical Models and Image\n    Processing 54(5):438-460\n\n    \'\'\'\n    from .moments import moments\n    bwimage = _make_binary(bwimage)\n\n    if not np.any(bwimage):\n        return 0.,0.\n\n    cof = mh.center_of_mass(bwimage)\n    hull_mu00 = moments(bwimage, 0, 0, cof)\n    hull_mu11 = moments(bwimage, 1, 1, cof)\n    hull_mu02 = moments(bwimage, 0, 2, cof)\n    hull_mu20 = moments(bwimage, 2, 0, cof)\n\n    semimajor = np.sqrt((2 * (hull_mu20 + hull_mu02 + \\\n                    np.sqrt((hull_mu20 - hull_mu02)**2 + \\\n                    4 * hull_mu11**2)))/hull_mu00)\n\n    semiminor = np.sqrt((2 * (hull_mu20 + hull_mu02 - \\\n                    np.sqrt((hull_mu20 - hull_mu02)**2 + \\\n                    4 * hull_mu11**2)))/hull_mu00)\n    return semimajor, semiminor\n\ndef eccentricity(bwimage):\n    """"""\n    ecc = eccentricity(bwimage)\n\n    Compute eccentricity\n\n    Parameters\n    ----------\n    bwimage : ndarray\n        Interpreted as a boolean image\n\n    Returns\n    -------\n    r : float\n        Eccentricity measure\n    """"""\n    semimajor, semiminor = ellipse_axes(bwimage)\n    if semimajor == 0.:\n        return 0.\n    return  np.sqrt(semimajor**2 - semiminor**2) / semimajor\n\n'"
mahotas/features/surf.py,19,"b'# Copyright (C) 2010-2015, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# License: MIT (see COPYING file)\n\nfrom __future__ import division\nimport numpy as np\nfrom . import _surf\n\n__all__ = [\n        \'dense\',\n        \'integral\',\n        \'surf\',\n        ]\n\ndef integral(f, in_place=False, dtype=np.double):\n    \'\'\'\n    fi = integral(f, in_place=False, dtype=np.double):\n\n    Compute integral image\n\n    Parameters\n    ----------\n    f : ndarray\n        input image. Only 2-D images are supported.\n    in_place : bool, optional\n        Whether to overwrite `f` (default: False).\n    dtype : dtype, optional\n        dtype to use (default: double)\n\n    Returns\n    -------\n    fi : ndarray of `dtype` of same shape as `f`\n        The integral image\n    \'\'\'\n    if f.ndim != 2:\n        raise ValueError(\'mahotas.surf.integral: Can only handle 2D-images (i.e., greyscale images).\')\n    if not in_place:\n        if dtype != f.dtype:\n            f = f.astype(dtype)\n        else:\n            f = f.copy()\n    return _surf.integral(f)\n\ndef surf(f, nr_octaves=4, nr_scales=6, initial_step_size=1, threshold=0.1, max_points=1024, descriptor_only=False):\n    \'\'\'\n    points = surf(f, nr_octaves=4, nr_scales=6, initial_step_size=1, threshold=0.1, max_points=1024, descriptor_only=False):\n\n    Run SURF detection and descriptor computations\n\n    Speeded-Up Robust Features (SURF) are fast local features computed at\n    automatically determined keypoints.\n\n    References\n    ----------\n\n    Herbert Bay, Andreas Ess, Tinne Tuytelaars, Luc Van Gool ""SURF: Speeded Up\n    Robust Features"", Computer Vision and Image Understanding (CVIU), Vol. 110,\n    No. 3, pp. 346--359, 2008\n\n    Parameters\n    ----------\n    f : ndarray\n        input image\n    nr_octaves : integer, optional\n        Nr of octaves (default: 4)\n    nr_scales : integer, optional\n        Nr of scales (default: 6)\n    initial_step_size : integer, optional\n        Initial step size in pixels (default: 1)\n    threshold : float, optional\n        Threshold of the strength of the interest point (default: 0.1)\n    max_points : integer, optional\n        Maximum number of points to return. By default, return at most 1024\n        points. Note that the number may be smaller even in the case where\n        there are that many points. This is a side-effect of the way the\n        threshold is implemented: only ``max_points`` are considered, but some\n        of those may be filtered out.\n    descriptor_only : boolean, optional\n        If ``descriptor_only``, then returns only the 64-element descriptors\n        (default is ``False``).\n\n    Returns\n    -------\n    points : ndarray of double, shape = (N, 6 + 64)\n        `N` is nr of points. Each point is represented as\n        *(y,x,scale,score,laplacian,angle, D_0,...,D_63)* where *y,x,scale* is\n        the position, *angle* the orientation, *score* and *laplacian* the\n        score and sign of the detector; and *D_i* is the descriptor\n\n        If ``descriptor_only``, then only the *D_i*\\ s are returned and the array\n        has shape (N, 64)!\n    \'\'\'\n    surfs = _surf.surf(integral(f), nr_octaves, nr_scales, initial_step_size, threshold, max_points)\n    if descriptor_only:\n        surfs = surfs[:,6:]\n    return surfs\n\n\ndef interest_points(f, nr_octaves=4, nr_scales=6, initial_step_size=1, threshold=0.1, max_points=None, is_integral=False):\n    \'\'\'\n    desc_array = interest_points(f, nr_octaves=4, nr_scales=6, initial_step_size=1, threshold=0.1, max_points={all}, is_integral=False)\n\n    SURF Detector\n\n    Parameters\n    ----------\n    f : ndarray\n        input image or integral image (if `is_integral`)\n    nr_octaves : integer, optional\n        Nr of octaves (default: 4)\n    nr_scales : integer, optional\n        Nr of scales (default: 6)\n    initial_step_size : integer, optional\n        Initial step size in pixels (default: 1)\n    threshold : float, optional\n        Threshold of the strength of the interest point (default: 0.1)\n    max_points : integer, optional\n        Maximum number of points to return. By default, return all.\n    is_integral : boolean, optional\n        Whether `f` is an integral image\n\n    Returns\n    -------\n    points : ndarray of double, shape = (N, 5)\n        `N` is nr of points. Each point is represented as\n        *(y,x,scale,score,laplacian)* where *y,x,scale* is\n        the position, *score* and *laplacian* the score and sign of the\n        detector.\n\n    See Also\n    --------\n    surf : SURF detection and descriptors\n    descriptors : SURF descriptors\n    \'\'\'\n    if not is_integral:\n        f = integral(f)\n    else:\n        if f.dtype != np.double:\n            raise TypeError(\'mahotas.surf: integral image must be of dtype double\')\n    if max_points is None:\n        max_points = -1\n    return _surf.interest_points(f, nr_octaves, nr_scales, initial_step_size, threshold, max_points)\n\n\ndef descriptors(f, interest_points, is_integral=False, descriptor_only=False):\n    \'\'\'\n    desc_array = descriptors(f, interest_points, is_integral=False, descriptor_only=False)\n\n    Compute SURF descriptors\n\n    Parameters\n    ----------\n    f : ndarray\n        input image or integral image (if `is_integral`)\n    interest_points : ndarray\n        interest points in the format returned by the ``interest_points()`` function\n    is_integral : boolean, optional\n        Whether ``f`` is an integral image\n    descriptor_only : boolean, optional\n        If ``descriptor_only``, then returns only the 64-element descriptors\n\n    Returns\n    -------\n    points : ndarray of double, shape = (N, 6 + 64)\n        `N` is nr of points. Each point is represented as\n        *(y,x,scale,score,laplacian,angle, D_0,...,D_63)* where *y,x,scale* is\n        the position, *angle* the orientation, *score* and *laplacian* the\n        score and sign of the detector; and *D_i* is the descriptor.\n        If ``descriptor_only`` is true, then returns only *(D_0,...,D_63)*\n    \'\'\'\n    if not is_integral:\n        f = integral(f)\n    else:\n        if f.dtype != np.double:\n            raise TypeError(\'mahotas.surf: integral image must be of dtype double\')\n    interest_points = np.ascontiguousarray(interest_points, dtype=np.float64)\n    surfs = _surf.descriptors(f, interest_points)\n    if descriptor_only:\n        surfs = surfs[:,6:]\n    return surfs\n\ndef dense(f, spacing, scale=None, is_integral=False, include_interest_point=False):\n    \'\'\'\n    desc_array = dense(f, spacing, scale={np.sqrt(spacing)}, is_integral=False, include_interest_point=False)\n\n    Parameters\n    ----------\n    f : image\n        original image\n    spacing : integer\n        Distance between points\n    scale : float, optional\n        Scale of interest points. By default, it is set to ``np.sqrt(spacing)``\n    is_integral : boolean, optional\n        Whether `f` is an integral image\n    include_interest_point : bool, optional\n        Whether to return interest point information. Default is False\n\n    Returns\n    -------\n    descriptors : ndarray\n        Descriptors at dense points. Note that the interest point is **not\n        returned by default**.\n\n    See Also\n    --------\n    surf : function\n        Find interest points and then compute descriptors\n    descriptors : function\n        Compute descriptors at user provided interest points\n    \'\'\'\n    if scale is None:\n        scale = np.sqrt(spacing)\n    s0,s1 = f.shape\n    x = np.arange(int(spacing/2), s0, int(spacing))\n    y = np.arange(int(spacing/2), s1, int(spacing))\n    X,Y = np.meshgrid(x,y)\n    S = np.zeros(X.shape, dtype=float)\n    S += scale\n    ips = np.vstack([X.ravel(), Y.ravel(), S.ravel(), np.ones(X.size), np.ones(X.size)])\n    return descriptors(f, ips.T, is_integral=is_integral, descriptor_only=(not include_interest_point))\n\n\ndef show_surf(f, spoints, values=None, colors=None):\n    \'\'\'\n    f2 = show_surf(f, spoints, values=None, colors={[(255,0,0)]}):\n\n    Note that this function does not actually display anything, it just builds\n    a colour image for you. In order to visualise the image, you will need to\n    use another tool such as ``matplotlib``. Alternatively, you can use\n    ``mahotas.imsave`` to save it to a file.\n\n    Parameters\n    ----------\n    f : image\n        original image\n    spoints : ndarray\n        output of `surf`\n    values : ndarray, same length as `spoints`, optional\n        You can pass classes for each point here. If it is not used, then all\n        the points are displayed the same way (or, equivalently,\n        ``values=np.zeros(len(spoints))``).\n    colors : ndarray, length must be same as ``values.max()``, optional\n        points with values ``vi`` will have colour ``colors[vi]``.\n\n    Returns\n    -------\n    f2 : ndarray\n        Colour (Height x Width x 3-Colours) image\n    \'\'\'\n    import mahotas.polygon\n    if values is None:\n        values = np.zeros(len(spoints), int)\n        if colors is None:\n            colors = [(255,0,0)]\n    if colors is None:\n        raise NotImplementedError(\'mahotas.surf.show_surf: colors is None, but values is not\')\n    def rotate(y,x, a):\n        sa = np.sin(a)\n        ca = np.cos(a)\n        return (ca*x-sa*y, sa*x+ca*y)\n\n    f2 = np.dstack([f,f,f])\n\n    for p,vi in zip(spoints, values):\n        y = p[0]\n        x = p[1]\n        scale = p[2]\n        angle = p[5]\n        size = int(scale*10)\n        y0 = int(y) - size//2\n        x0 = int(x) - size//2\n        x1 = x + size\n        y1 = y + size\n        def rotate_around(p, c, a):\n            p0,p1 = p\n            c0,c1 = c\n            d0 = p0-c0\n            d1 = p1 - c1\n            d0,d1 = rotate(d0,d1,a)\n            return int(c0+d0), int(c1+d1)\n        polygon = [(y0,x0), (y0,x1), (y1,x1), (y1,x0), (y0,x0)]\n        polygon = [rotate_around(p, (y,x), angle) for p in polygon]\n        for p0,p1 in zip(polygon[:-1], polygon[1:]):\n            mahotas.polygon.line(p0,p1, f2, color=colors[vi])\n    return f2.astype(np.uint8)\n'"
mahotas/features/tas.py,8,"b'# Copyright (C) 2008-2012, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n# Carnegie Mellon University\n#\n# License: MIT (see COPYING file)\n\nimport numpy as np\nfrom ..convolve import convolve\nfrom ..thresholding import otsu\n\n__all__ = [\'pftas\', \'tas\']\n\n_M2 = np.ones((3, 3))\n_M2[1, 1] = 10\n_bins2 = np.arange(11)\n\n_M3 = np.ones((3, 3, 3))\n_M3[1,1,1] = _M3.sum() + 1\n_bins3 = np.arange(28)\n\ndef _tas(img, thresh, margin):\n    if len(img.shape) == 2:\n        M = _M2\n        bins = _bins2\n        saved = 9\n    elif len(img.shape) == 3:\n        M = _M3\n        bins = _bins3\n        saved = 27\n    else:\n        raise ValueError(\'mahotas.tas: Cannot compute TAS for image of %s dimensions\' % len(img.shape))\n\n    def _ctas(img):\n        V = convolve(img.astype(np.uint8), M)\n        values,_ = np.histogram(V, bins=bins)\n        values = values[:saved]\n        s = values.sum()\n        if s > 0:\n            return values/float(s)\n        return values\n\n    def _compute(bimg):\n        alltas.append(_ctas(bimg))\n        allntas.append(_ctas(~bimg))\n\n    alltas = []\n    allntas = []\n    total = np.sum(img > thresh)\n    mu = ((img > thresh)*img).sum() / (total + 1e-8)\n    _compute( (img > mu - margin) * (img < mu + margin) )\n    _compute(img > mu - margin)\n    _compute(img > mu)\n\n    return np.concatenate(alltas + allntas)\n\ndef tas(img):\n    \'\'\'\n    values = tas(img)\n\n    Compute Threshold Adjacency Statistics\n\n    TAS were presented by Hamilton et al.  in ""Fast automated cell phenotype\n    image classification"" (http://www.biomedcentral.com/1471-2105/8/110)\n\n    Also returns a version computed on the negative of the binarisation defined\n    by Hamilton et al.\n\n    See also pftas() for a variation without any hardcoded parameters.\n\n    Parameters\n    ----------\n    img : ndarray, 2D or 3D\n        input image\n\n    Returns\n    -------\n    values : ndarray\n        A 1-D ndarray of feature values\n\n    See Also\n    --------\n    pftas : Parameter free TAS\n    \'\'\'\n    return _tas(img, 30, 30)\n\ndef pftas(img, T=None):\n    \'\'\'\n    values = pftas(img, T={mahotas.threshold.otsu(img)})\n\n    Compute parameter free Threshold Adjacency Statistics\n\n    TAS were presented by Hamilton et al.  in ""Fast automated cell phenotype\n    image classification"" (http://www.biomedcentral.com/1471-2105/8/110)\n\n    The current version is an adapted version which is free of parameters. The\n    thresholding is done by using Otsu\'s algorithm (or can be pre-computed and\n    passed in by setting `T`), the margin around the mean of pixels to be\n    included is the standard deviation. This was first published by Coelho et\n    al. in ""Structured Literature Image Finder: Extracting Information from\n    Text and Images in Biomedical Literature""\n    (http://www.springerlink.com/content/60634778710577t0/)\n\n    Also returns a version computed on the negative of the binarisation defined\n    by Hamilton et al.\n\n    Use tas() to get the original version of the features.\n\n    Parameters\n    ----------\n    img : ndarray, 2D or 3D\n        input image\n    T : integer, optional\n        Threshold to use (default: compute with otsu)\n\n    Returns\n    -------\n    values : ndarray\n        A 1-D ndarray of feature values\n    \'\'\'\n    if T is None:\n        T = otsu(img)\n    pixels = img[img > T].ravel()\n    if len(pixels) == 0:\n        std = 0\n    else:\n        std = pixels.std()\n    return _tas(img, T, std)\n\n'"
mahotas/features/texture.py,38,"b'# Copyright (C) 2008-2016, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# License: MIT (see COPYING file)\n\n\nimport numpy as np\nfrom . import _texture\nfrom ..internal import _verify_is_integer_type\n\n__all__ = [\n    \'haralick\',\n    \'haralick_labels\',\n    \'cooccurence\',\n    ]\n\ndef _entropy(p):\n    p = p.ravel()\n    p1 = p.copy()\n    p1 += (p==0)\n    return -np.dot(np.log2(p1), p)\n\n\ndef haralick(f,\n            ignore_zeros=False,\n            preserve_haralick_bug=False,\n            compute_14th_feature=False,\n            return_mean=False,\n            return_mean_ptp=False,\n            use_x_minus_y_variance=False,\n            distance=1\n            ):\n    \'\'\'\n    feats = haralick(f,\n            ignore_zeros=False,\n            preserve_haralick_bug=False,\n            compute_14th_feature=False,\n            return_mean=False,\n            return_mean_ptp=False,\n            use_x_minus_y_variance=False,\n            distance=1\n            )\n\n    Compute Haralick texture features\n\n    Computes the Haralick texture features for the four 2-D directions or\n    thirteen 3-D directions (depending on the dimensions of `f`).\n\n    ``ignore_zeros`` can be used to have the function ignore any zero-valued\n    pixels (as background). If there are no-nonzero neighbour pairs in all\n    directions, an exception is raised. Note that this can happen even with\n    some non-zero pixels, e.g.::\n\n         0 0 0 0\n         0 1 0 0\n         0 1 0 0\n         0 0 0 0\n\n    would trigger an error when ``ignore_zeros=True`` as there are no\n    horizontal non-zero pairs!\n\n    Notes\n    -----\n    Haralick\'s paper has a typo in one of the equations. This function\n    implements the correct feature unless `preserve_haralick_bug` is True. The\n    only reason why you\'d want the buggy behaviour is if you want to match\n    another implementation.\n\n    References\n    ----------\n\n    Cite the following reference for these features::\n\n        @article{Haralick1973,\n            author = {Haralick, Robert M. and Dinstein, Its\'hak and Shanmugam, K.},\n            journal = {Ieee Transactions On Systems Man And Cybernetics},\n            number = {6},\n            pages = {610--621},\n            publisher = {IEEE},\n            title = {Textural features for image classification},\n            url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4309314},\n            volume = {3},\n            year = {1973}\n        }\n\n    Parameters\n    ----------\n    f : ndarray of integer type\n        input image. 2-D and 3-D images are supported.\n    distance: int, optional (default=1)\n        The distance to consider while computing the cooccurence matrix.\n    ignore_zeros : bool, optional\n        Whether to ignore zero pixels (default: False).\n\n    Other Parameters\n    ----------------\n    preserve_haralick_bug : bool, optional\n        whether to replicate Haralick\'s typo (default: False).\n        You probably want to always set this to ``False`` unless you want to\n        replicate someone else\'s wrong implementation.\n    compute_14th_feature : bool, optional\n        whether to compute & return the 14-th feature\n    return_mean : bool, optional\n        When set, the function returns the mean across all the directions\n        (default: False).\n    return_mean_ptp : bool, optional\n        When set, the function returns the mean and ptp (point-to-point, i.e.,\n        difference between max() and min()) across all the directions (default:\n        False).\n    use_x_minus_y_variance : bool, optional\n        Feature 10 (index 9) has two interpretations, as the variance of \\|x-y\\|\n        or as the variance of P(\\|x-y\\|). In order to achieve compatibility with\n        other software and previous versions of mahotas, mahotas defaults to\n        using ``VAR[P(\\|x-y\\|)]``; if this argument is True, then it uses\n        ``VAR[\\|x-y\\|]`` (default: False)\n\n\n    Returns\n    -------\n    feats : ndarray of np.double\n        A 4x13 or 4x14 feature vector (one row per direction) if `f` is 2D,\n        13x13 or 13x14 if it is 3D. The exact number of features depends on the\n        value of ``compute_14th_feature`` Also, if either ``return_mean`` or\n        ``return_mean_ptp`` is set, then a single dimensional array is\n        returned.\n    \'\'\'\n    _verify_is_integer_type(f, \'mahotas.haralick\')\n\n    if len(f.shape) == 2:\n        nr_dirs = len(_2d_deltas)\n    elif len(f.shape) == 3:\n        nr_dirs = len(_3d_deltas)\n    else:\n        raise ValueError(\'mahotas.texture.haralick: Can only handle 2D and 3D images.\')\n    fm1 = f.max() + 1\n    cmat = np.empty((fm1, fm1), np.int32)\n    def all_cmatrices():\n        for dir in range(nr_dirs):\n            cooccurence(f, dir, cmat, symmetric=True, distance=distance)\n            yield cmat\n    return haralick_features(all_cmatrices(),\n                        ignore_zeros=ignore_zeros,\n                        preserve_haralick_bug=preserve_haralick_bug,\n                        compute_14th_feature=compute_14th_feature,\n                        return_mean=return_mean,\n                        return_mean_ptp=return_mean_ptp,\n                        use_x_minus_y_variance=use_x_minus_y_variance,\n                        )\n\ndef haralick_features(cmats,\n                    ignore_zeros=False,\n                    preserve_haralick_bug=False,\n                    compute_14th_feature=False,\n                    return_mean=False,\n                    return_mean_ptp=False,\n                    use_x_minus_y_variance=False,\n                    ):\n    \'\'\'\n    features = haralick_features(cmats,\n                    ignore_zeros=False,\n                    preserve_haralick_bug=False,\n                    compute_14th_feature=False,\n                    return_mean=False,\n                    return_mean_ptp=False,\n                    use_x_minus_y_variance=False,\n                    )\n\n    Computers Haralick features for the given cooccurrence matrices.\n\n    This function is not usually necessary, as you can call ``haralick`` with\n    an image to obtain features for that image. Use only if you know what you\n    are doing.\n\n    Notes\n    -----\n    Haralick\'s paper has a typo in one of the equations. This function\n    implements the correct feature unless `preserve_haralick_bug` is True. The\n    only reason why you\'d want the buggy behaviour is if you want to match\n    another implementation.\n\n    References\n    ----------\n\n    Cite the following reference for these features::\n\n        @article{Haralick1973,\n            author = {Haralick, Robert M. and Dinstein, Its\'hak and Shanmugam, K.},\n            journal = {Ieee Transactions On Systems Man And Cybernetics},\n            number = {6},\n            pages = {610--621},\n            publisher = {IEEE},\n            title = {Textural features for image classification},\n            url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4309314},\n            volume = {3},\n            year = {1973}\n        }\n\n\n    Parameters\n    ----------\n    cmats : sequence of ndarrays\n        This should be a sequence of ndarrays, all square and all of the same\n        shape.\n    ignore_zeros : bool, optional\n        Whether to ignore zero pixels (default: False).\n\n    Other Parameters\n    ----------------\n    preserve_haralick_bug : bool, optional\n        whether to replicate Haralick\'s typo (default: False).\n        You probably want to always set this to ``False`` unless you want to\n        replicate someone else\'s wrong implementation.\n    compute_14th_feature : bool, optional\n        whether to compute & return the 14-th feature\n    return_mean : bool, optional\n        When set, the function returns the mean across all the directions\n        (default: False).\n    return_mean_ptp : bool, optional\n        When set, the function returns the mean and ptp (point-to-point, i.e.,\n        difference between max() and min()) across all the directions (default:\n        False).\n    use_x_minus_y_variance : bool, optional\n        Feature 10 (index 9) has two interpretations, as the variance of |x-y|\n        or as the variance of P(|x-y|). In order to achieve compatibility with\n        other software and previous versions of mahotas, mahotas defaults to\n        using ``VAR[P(|x-y|)]``; if this argument is True, then it uses\n        ``VAR[|x-y|]`` (default: False)\n\n    Returns\n    -------\n    feats : ndarray of np.double\n        A 4x13 or 4x14 feature vector (one row per direction) if `f` is 2D,\n        13x13 or 13x14 if it is 3D. The exact number of features depends on the\n        value of ``compute_14th_feature`` Also, if either ``return_mean`` or\n        ``return_mean_ptp`` is set, then a single dimensional array is\n        returned.\n\n    See Also\n    --------\n    haralick : function\n        compute Haralick features for an image\n    \'\'\'\n    if return_mean and return_mean_ptp:\n        raise ValueError(""mahotas.haralick_features: Cannot set both `return_mean` and `return_mean_ptp`"")\n    features = []\n    for cmat in cmats:\n        feats = np.zeros(13 + bool(compute_14th_feature), np.double)\n        if ignore_zeros:\n            cmat[0] = 0\n            cmat[:,0] = 0\n        T = cmat.sum()\n        if not T:\n            raise ValueError(\'mahotas.haralick_features: the input is empty. Cannot compute features!\\n\' +\n                                \'This can happen if you are using `ignore_zeros`\' )\n        if not len(features):\n            maxv = len(cmat)\n            k = np.arange(maxv)\n            k2 = k**2\n            tk = np.arange(2*maxv)\n            tk2 = tk**2\n            i,j = np.mgrid[:maxv,:maxv]\n            ij = i*j\n            i_j2_p1 = (i - j)**2\n            i_j2_p1 += 1\n            i_j2_p1 = 1. / i_j2_p1\n            i_j2_p1 = i_j2_p1.ravel()\n            px_plus_y = np.empty(2*maxv, np.double)\n            px_minus_y = np.empty(maxv, np.double)\n        elif maxv != len(cmat):\n            raise ValueError(\'mahotas.haralick_features: All cmatrices must be of the same size\')\n\n        p = cmat / float(T)\n        pravel = p.ravel()\n        px = p.sum(0)\n        py = p.sum(1)\n\n        ux = np.dot(px, k)\n        uy = np.dot(py, k)\n        vx = np.dot(px, k2) - ux**2\n        vy = np.dot(py, k2) - uy**2\n\n        sx = np.sqrt(vx)\n        sy = np.sqrt(vy)\n        px_plus_y.fill(0)\n        px_minus_y.fill(0)\n        _texture.compute_plus_minus(p, px_plus_y, px_minus_y)\n\n        feats[0] = np.dot(pravel, pravel)\n        feats[1] = np.dot(k2, px_minus_y)\n\n        if sx == 0. or sy == 0.:\n            feats[2] = 1.\n        else:\n            feats[2] = (1. / sx / sy) * (np.dot(ij.ravel(), pravel) - ux * uy)\n\n        feats[3] = vx\n        feats[4] = np.dot(i_j2_p1, pravel)\n        feats[5] = np.dot(tk, px_plus_y)\n\n        feats[7] = _entropy(px_plus_y)\n\n        # There is some confusion w.r.t. feats[6].\n        #\n        # Haralick\'s paper uses feats[7] in its computation, but it is\n        # clear that feats[5] should be used (i.e., it computes a\n        # variance).\n        #\n        if preserve_haralick_bug:\n            feats[6] = ((tk-feats[7])**2*px_plus_y).sum()\n        else:\n            feats[6] = np.dot(tk2, px_plus_y) - feats[5]**2\n\n        feats[ 8] = _entropy(pravel)\n        if use_x_minus_y_variance:\n            mu_x_minus_y = np.dot(px_minus_y, k)\n            mu_x_minus_y_sq = np.dot(px_minus_y, k2)\n            feats[ 9] = mu_x_minus_y_sq - mu_x_minus_y**2\n        else:\n            feats[ 9] = px_minus_y.var()\n        feats[10] = _entropy(px_minus_y)\n\n        HX = _entropy(px)\n        HY = _entropy(py)\n        crosspxpy = np.outer(px,py)\n        crosspxpy += (crosspxpy == 0) # This makes log(0) become log(1), and thus evaluate to zero, such that everything works below:\n        crosspxpy = crosspxpy.ravel()\n        HXY1 = -np.dot(pravel, np.log2(crosspxpy))\n        HXY2 = _entropy(crosspxpy)\n\n        if max(HX, HY) == 0.:\n            feats[11] = (feats[8]-HXY1)\n        else:\n            feats[11] = (feats[8]-HXY1)/max(HX,HY)\n        feats[12] = np.sqrt(max(0,1 - np.exp( -2. * (HXY2 - feats[8]))))\n\n        if compute_14th_feature:\n            # Square root of the second largest eigenvalue of the correlation matrix\n            # Probably the faster way to do this is just SVD the whole (likely rank deficient) matrix\n            # grab the second highest singular value . . . Instead, we just amputate the empty rows/cols and move on.\n            nzero_rc = px != 0\n            nz_pmat = p[nzero_rc,:][:,nzero_rc] # Symmetric, so this is ok!\n            if nz_pmat.shape[0] > 2:\n                ccm = np.corrcoef(nz_pmat)\n                e_vals = np.linalg.eigvalsh(ccm)\n                e_vals.sort()\n                feats[13] = np.sqrt(e_vals[-2])\n            else:\n                feats[13] = 0\n        features.append(feats)\n\n    features = np.array(features)\n    if return_mean:\n        return features.mean(axis=0)\n    if return_mean_ptp:\n        mean = features.mean(axis=0)\n        ptp = features.ptp(axis=0)\n        return np.concatenate((mean,ptp))\n\n    return features\n\n\nharalick_labels = [""Angular Second Moment"",\n                   ""Contrast"",\n                   ""Correlation"",\n                   ""Sum of Squares: Variance"",\n                   ""Inverse Difference Moment"",\n                   ""Sum Average"",\n                   ""Sum Variance"",\n                   ""Sum Entropy"",\n                   ""Entropy"",\n                   ""Difference Variance"",\n                   ""Difference Entropy"",\n                   ""Information Measure of Correlation 1"",\n                   ""Information Measure of Correlation 2"",\n                   ""Maximal Correlation Coefficient""]\n\n_2d_deltas= [\n    (0,1),\n    (1,1),\n    (1,0),\n    (1,-1)]\n\n_3d_deltas = [\n    (1, 0, 0),\n    (1, 1, 0),\n    (0, 1, 0),\n    (1,-1, 0),\n    (0, 0, 1),\n    (1, 0, 1),\n    (0, 1, 1),\n    (1, 1, 1),\n    (1,-1, 1),\n    (1, 0,-1),\n    (0, 1,-1),\n    (1, 1,-1),\n    (1,-1,-1) ]\n\ndef cooccurence(f, direction, output=None, symmetric=True, distance=1):\n    \'\'\'\n    cooccurence_matrix = cooccurence(f,\n                            direction,\n                            output={new matrix},\n                            symmetric=True,\n                            distance=1)\n\n    Compute grey-level cooccurence matrix\n\n    Parameters\n    ----------\n    f : ndarray of integer type\n        The input image\n    direction : integer\n        Direction as index into (horizontal [default], diagonal\n        [nw-se], vertical, diagonal [ne-sw])\n    output : np.long 2 ndarray, optional\n        preallocated result.\n    symmetric : boolean, optional\n        whether return a symmetric matrix (default: True)\n    distance : integer, optional (default=1)\n        Distance to the central pixel to consider.\n\n    Returns\n    -------\n      cooccurence_matrix : cooccurence matrix\n    \'\'\'\n    _verify_is_integer_type(f, \'mahotas.cooccurence\')\n    if len(f.shape) == 2 and not (0 <= direction < 4):\n        raise ValueError(\'mahotas.texture.cooccurence: `direction` {0} is not in range(4).\'.format(direction))\n    elif len(f.shape) == 3 and not (0 <= direction < 13):\n        raise ValueError(\'mahotas.texture.cooccurence: `direction` {0} is not in range(13).\'.format(direction))\n    elif len(f.shape) not in (2,3):\n        raise ValueError(\'mahotas.texture.cooccurence: cannot handle images of %s dimensions.\' % len(f.shape))\n\n    if output is None:\n        mf = f.max()\n        output = np.zeros((mf+1, mf+1), np.int32)\n    else:\n        assert np.min(output.shape) >= f.max(), \'mahotas.texture.cooccurence: output is not large enough\'\n        assert output.dtype == np.int32, \'mahotas.texture.cooccurence: output is not of type np.int32\'\n        output.fill(0)\n\n    if len(f.shape) == 2:\n        mask_size = 2 * distance + 1\n        Bc = np.zeros((mask_size, mask_size), f.dtype)\n        y, x = tuple(distance * i for i in _2d_deltas[direction])\n        Bc[y + distance, x + distance] = 1\n    else:\n        mask_size = 2 * distance + 1\n        Bc = np.zeros((mask_size, mask_size, mask_size), f.dtype)\n        y, x, z = tuple(distance * i for i in _3d_deltas[direction])\n        Bc[y + distance, x + distance, z + distance] = 1\n    _texture.cooccurence(f, output, Bc, symmetric)\n    return output\n\n'"
mahotas/features/zernike.py,8,"b'# -*- coding: utf-8 -*-\n# Copyright (C) 2006-2014, Luis Pedro Coelho <luis@luispedro.org>\n# vim: set ts=4 sts=4 sw=4 expandtab smartindent:\n#\n# License: MIT (see COPYING file)\n\nfrom __future__ import division\nimport numpy as np\n\nfrom ..center_of_mass import center_of_mass\nfrom . import _zernike\n\n__all__ = [\'zernike\', \'zernike_moments\']\n\ndef zernike(im, degree, radius, cm=None): # pragma: no cover\n    """"""\n    zvalues = zernike(im, degree, radius, cm={center_of_mass(im)})\n    """"""\n    import warnings\n    warnings.warn(\'mahotas.zernike.zernike: This interface is deprecated. Switch the order of your arguments and use ``zernike_moments``\', DeprecationWarning)\n    return zernike_moments(im, radius, degree, cm)\n\ndef zernike_moments(im, radius, degree=8, cm=None):\n    """"""\n    zvalues = zernike_moments(im, radius, degree=8, cm={center_of_mass(im)})\n\n    Zernike moments through ``degree``. These are computed on a circle of\n    radius ``radius`` centered around ``cm`` (or the center of mass of the\n    image, if the ``cm`` argument is not used).\n\n    Returns a vector of absolute Zernike moments through ``degree`` for the\n    image ``im``.\n\n    Parameters\n    ----------\n    im : 2-ndarray\n        input image\n    radius : integer\n        the maximum radius for the Zernike polynomials, in pixels. Note that\n        the area outside the circle (centered on center of mass) defined by\n        this radius is ignored.\n    degree : integer, optional\n        Maximum degree to use (default: 8)\n    cm : pair of floats, optional\n        the centre of mass to use. By default, uses the image\'s centre of mass.\n\n    Returns\n    -------\n    zvalues : 1-ndarray of floats\n        Zernike moments\n\n    References\n    ----------\n    Teague, MR. (1980). Image Analysis via the General Theory of Moments.  J.\n    Opt. Soc. Am. 70(8):920-930.\n    """"""\n    zvalues = []\n    if cm is None:\n        c0,c1 = center_of_mass(im)\n    else:\n        c0,c1 = cm\n\n    Y,X = np.mgrid[:im.shape[0],:im.shape[1]]\n    P = im.ravel()\n\n    def rescale(C, centre):\n        Cn = C.astype(np.double)\n        Cn -= centre\n        Cn /= radius\n        return Cn.ravel()\n    Yn = rescale(Y, c0)\n    Xn = rescale(X, c1)\n\n    Dn = Xn**2\n    Dn += Yn**2\n    np.sqrt(Dn, Dn)\n    np.maximum(Dn, 1e-9, out=Dn)\n    k = (Dn <= 1.)\n    k &= (P > 0)\n\n    frac_center = np.array(P[k], np.double)\n    frac_center = frac_center.ravel()\n    frac_center /= frac_center.sum()\n    Yn = Yn[k]\n    Xn = Xn[k]\n    Dn = Dn[k]\n    An = np.empty(Yn.shape, np.complex)\n    An.real = (Xn/Dn)\n    An.imag = (Yn/Dn)\n\n    Ans = [An**p for p in range(2,degree+2)]\n    Ans.insert(0, An) # An**1\n    Ans.insert(0, np.ones_like(An)) # An**0\n    for n in range(degree+1):\n        for l in range(n+1):\n            if (n-l)%2 == 0:\n                z = _zernike.znl(Dn, Ans[l], frac_center, n, l)\n                zvalues.append(abs(z))\n    return np.array(zvalues)\n\n'"
mahotas/io/__init__.py,0,"b""\n_error_message = '''\nmahotas.%%s depends on one of (in order of preference):\n\n1. imread\n2. freeimage\n3. pillow (PIL)\n\nNone of which could be found!\n\nEverything else will work, though, so this error is only triggered when you\nattempt to use these optional functions.\n\nTo install imread:\n\nOn **Ubuntu**, run the following commands::\n\n    sudo apt-get install libpng12-dev libtiff4-dev libwebp-dev python-pip python-dev g++\n    sudo pip install imread\n\nOn **Mac OS**, if using ``port``, run the following commands::\n\n    sudo port install libpng tiff webp\n    sudo pip install imread\n\nOn **Windows**, use Christoph Gohlke's packages. See:\n\nhttp://www.lfd.uci.edu/~gohlke/pythonlibs/#imread\n\n\n\n\nTo install FreeImage:\n\nYou need to have the freeimage installed for imread/imsave (everything else\nwill work, though, so this error is only triggered when you attempt to use\nthese optional functions). Freeimage is not a Python package, but a regular\npackage.\n\nUnder Linux, look for a package called `freeimage` in your distribution (it is\nactually called `libfreeimage3` in debian/ubuntu, for example).\n\nUnder Windows, consider using the third-party mahotas packages at\nhttp://www.lfd.uci.edu/~gohlke/pythonlibs/ (kindly maintained by Christoph\nGohlke), which already package freeimage.\n\nFull error was: %s'''\ndef error_imread(*args, **kwargs):\n    raise ImportError(_error_message % 'imread')\ndef error_imsave(*args, **kwargs):\n    raise ImportError(_error_message % 'imsave')\n\n__all__ = [\n    'imread',\n    'imsave',\n    ]\ntry:\n    try:\n        from imread import imread, imsave\n    except ImportError: # pragma: no cover\n        try:\n            from .pil import imread, imsave\n        except ImportError:\n            from .freeimage import imread, imsave\n# Importing freeimage can throw both ImportError and OSError, so check for both\nexcept (OSError, ImportError): # pragma: no cover\n    import sys\n    _,e,_ = sys.exc_info()\n    _error_message %= e\n    imread = error_imread\n    imsave = error_imsave\n\n"""
mahotas/io/freeimage.py,39,"b'import sys\nimport os\nimport ctypes\nimport ctypes.util\n\nimport numpy as np\n\n\n_API = {\n    \'FreeImage_AllocateT\': (\n        ctypes.c_void_p,\n        [ctypes.c_int,  # type\n         ctypes.c_int,  # width\n         ctypes.c_int,  # height\n         ctypes.c_int,  # bpp\n         ctypes.c_uint,  # red_mask\n         ctypes.c_uint,  # green_mask\n         ctypes.c_uint]),  # blue_mask\n    \'FreeImage_Save\': (\n        ctypes.c_int,\n        [ctypes.c_int,  # type\n         ctypes.c_void_p,  # bitmap\n         ctypes.c_char_p,  # filename\n         ctypes.c_int]),  # flags\n    \'FreeImage_SetOutputMessage\': (\n        None,\n        [ctypes.c_void_p]),  # callback\n    \'FreeImage_ConvertToGreyscale\': (\n        ctypes.c_void_p,  # FIBITMAP * new_bitmap\n        [ctypes.c_void_p]),  # FIBITMAP* bitmap\n    \'FreeImage_GetFIFFromFilename\': (\n        ctypes.c_int,  # FREE_IMAGE_FORMAT\n        [ctypes.c_char_p]),  # const char* filename\n    \'FreeImage_IsLittleEndian\': (\n        ctypes.c_int,  # BOOL\n        []),\n    \'FreeImage_FIFSupportsExportBPP\': (\n        ctypes.c_int,  # BOOL\n        [ctypes.c_int,  # FREE_IMAGE_FORMAT format\n         ctypes.c_int]),  # int bpp\n    \'FreeImage_FIFSupportsExportType\': (\n        ctypes.c_int,  # BOOL\n        [ctypes.c_int,  # FREE_IMAGE_FORMAT fif\n         ctypes.c_int]),  # FREE_IMAGE_TYPE type\n    \'FreeImage_Load\': (\n        ctypes.c_void_p,\n        [ctypes.c_int, ctypes.c_char_p, ctypes.c_int]),\n    \'FreeImage_Unload\': (\n        None,\n        [ctypes.c_void_p]),\n    \'FreeImage_GetWidth\': (\n        ctypes.c_uint,\n        [ctypes.c_void_p]),\n    \'FreeImage_GetHeight\': (\n        ctypes.c_uint,\n        [ctypes.c_void_p]),\n    \'FreeImage_GetImageType\': (\n        ctypes.c_uint,\n        [ctypes.c_void_p]),\n    \'FreeImage_GetFileTypeFromMemory\': (\n        ctypes.c_int,\n        [ctypes.c_void_p, ctypes.c_int]),\n    \'FreeImage_GetFileType\': (\n        ctypes.c_int,\n        [ctypes.c_char_p, ctypes.c_int]),\n    \'FreeImage_GetBPP\': (\n        ctypes.c_uint,\n        [ctypes.c_void_p]),\n    \'FreeImage_GetPitch\': (\n        ctypes.c_uint,\n        [ctypes.c_void_p]),\n    \'FreeImage_OpenMultiBitmap\': (\n        ctypes.c_void_p,  # FIMULTIBITMAP*\n        [ctypes.c_int,  # FREE_IMAGE_FORMAT format\n         ctypes.c_char_p,  # filename\n         ctypes.c_int,  # BOOL create_new\n         ctypes.c_int,  # BOOL read_only\n         ctypes.c_int,  # BOOL keep_cache_in_memory\n         ctypes.c_int]),  # int flags\n    \'FreeImage_GetPageCount\': (\n        ctypes.c_int,\n        [ctypes.c_void_p]),\n    \'FreeImage_AppendPage\': (\n        None,\n        [ctypes.c_void_p,  # FIMULTIBITMAP*\n         ctypes.c_void_p]),  # BITMAP\n    \'FreeImage_LockPage\': (\n        ctypes.c_void_p,  # FIBITMAP*\n        [ctypes.c_void_p,  # FIMULTIBITMAP\n         ctypes.c_int]),  # int page\n    \'FreeImage_UnlockPage\': (\n        None,\n        [ctypes.c_void_p,  # FIMULTIBITMAP*\n         ctypes.c_void_p,  # FIBITMAP* data\n         ctypes.c_int]),  # BOOL changed\n    \'FreeImage_CloseMultiBitmap\': (\n        ctypes.c_int,  # BOOL\n        [ctypes.c_void_p,  # FIMULTIBITMAP* bitmap\n         ctypes.c_int]),  # int flags\n    \'FreeImage_GetBits\': (\n        ctypes.c_void_p,\n        [ctypes.c_void_p]),\n    \'FreeImage_OpenMemory\': (\n        ctypes.c_void_p,\n        [ctypes.c_void_p, ctypes.c_uint32]),\n    \'FreeImage_AcquireMemory\': (\n        ctypes.c_int,\n        [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p),\n         ctypes.POINTER(ctypes.c_int)]),\n    \'FreeImage_CloseMemory\': (\n        None,\n        [ctypes.c_void_p]),\n    \'FreeImage_LoadFromMemory\': (\n        ctypes.c_void_p,\n        [ctypes.c_int, ctypes.c_void_p, ctypes.c_int]),\n    \'FreeImage_SaveToMemory\': (\n        ctypes.c_int,\n        [ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int]),\n    }\n\n\nclass _ctypes_wrapper(object):\n    pass\n\n\n# Albert\'s ctypes pattern\ndef _register_api(lib, api):\n    nlib = _ctypes_wrapper()\n    for f, (restype, argtypes) in api.items():\n        try:\n            func = getattr(lib, f)\n            func.restype = restype\n            func.argtypes = argtypes\n            setattr(nlib, f, func)\n        except Exception:\n\n            def error_raise(*args):\n                raise RuntimeError(\n                    \'mahotas.freeimage: Function `%s` not found in your\'\n                    \' version of FreeImage. It might be an older version\' % f)\n            setattr(nlib, f, error_raise)\n    return nlib\n\nif sys.platform == \'win32\':\n\n    def _load_library(dllname, loadfunction, dllpaths=(\'\', )):\n        """"""Load a DLL via ctypes load function. Return None on failure.\n\n        Try loading the DLL from the current package directory first,\n        then from the Windows DLL search path.\n\n        """"""\n        try:\n            dllpaths = (os.path.abspath(os.path.dirname(__file__)),\n                        ) + dllpaths\n        except NameError:\n            pass  # no __file__ attribute on PyPy and some frozen distributions\n        for path in dllpaths:\n            if path:\n                # temporarily add the path to the PATH environment variable\n                # so Windows can find additional DLL dependencies.\n                try:\n                    oldenv = os.environ[\'PATH\']\n                    os.environ[\'PATH\'] = path + \';\' + oldenv\n                except KeyError:\n                    oldenv = None\n            try:\n                return loadfunction(os.path.join(path, dllname))\n            except (WindowsError, OSError):\n                pass\n            finally:\n                if path and oldenv is not None:\n                    os.environ[\'PATH\'] = oldenv\n        return None\n\n    _FI = _load_library(\'FreeImage.dll\', ctypes.windll.LoadLibrary)\n    if not _FI:\n        raise OSError(""mahotas.freeimage: could not find FreeImage.dll"")\n\nelse:\n    libname = ctypes.util.find_library(\'freeimage\')\n    if libname:\n        _FI = ctypes.CDLL(libname)\n    else:\n        _FI = None\n        _lib_dirs = os.environ.get(\'LD_LIBRARY_PATH\', \'\').split(\':\')\n        _lib_dirs = [_f for _f in _lib_dirs if _f]\n        _lib_dirs.extend([\n            os.path.dirname(__file__),\n            \'/lib\',\n            \'/usr/lib\',\n            \'/usr/local/lib\',\n            \'/opt/local/lib\',\n            ])\n        _possible_filenames = (\n            \'libfreeimage\',\n            \'libFreeImage\',\n            )\n        for d in _lib_dirs:\n            for libname in _possible_filenames:\n                try:\n                    _FI = np.ctypeslib.load_library(libname, d)\n                except OSError:\n                    pass\n                else:\n                    break\n            if _FI is not None:\n                break\n    if not _FI:\n        raise OSError(\n            \'mahotas.freeimage: could not find libFreeImage in any of the\'\n            \'following directories: \\\'%s\\\'\' % \'\\\', \\\'\'.join(_lib_dirs))\n\n_FI = _register_api(_FI, _API)\n\nif sys.platform == \'win32\':\n    _functype = ctypes.WINFUNCTYPE\nelse:\n    _functype = ctypes.CFUNCTYPE\n\n\n@_functype(None, ctypes.c_int, ctypes.c_char_p)\ndef _error_handler(fif, message):\n    raise RuntimeError(\'mahotas.freeimage: FreeImage error: %s\' % message)\n\n_FI.FreeImage_SetOutputMessage(_error_handler)\n\n\nclass FI_TYPES(object):\n    FIT_UNKNOWN = 0\n    FIT_BITMAP = 1\n    FIT_UINT16 = 2\n    FIT_INT16 = 3\n    FIT_UINT32 = 4\n    FIT_INT32 = 5\n    FIT_FLOAT = 6\n    FIT_DOUBLE = 7\n    FIT_COMPLEX = 8\n    FIT_RGB16 = 9\n    FIT_RGBA16 = 10\n    FIT_RGBF = 11\n    FIT_RGBAF = 12\n\n    dtypes = {\n        FIT_BITMAP: np.uint8,\n        FIT_UINT16: np.uint16,\n        FIT_INT16: np.int16,\n        FIT_UINT32: np.uint32,\n        FIT_INT32: np.int32,\n        FIT_FLOAT: np.float32,\n        FIT_DOUBLE: np.float64,\n        FIT_COMPLEX: np.complex128,\n        FIT_RGB16: np.uint16,\n        FIT_RGBA16: np.uint16,\n        FIT_RGBF: np.float32,\n        FIT_RGBAF: np.float32}\n\n    fi_types = {\n        (np.uint8, 1): FIT_BITMAP,\n        (np.uint8, 3): FIT_BITMAP,\n        (np.uint8, 4): FIT_BITMAP,\n        (np.uint16, 1): FIT_UINT16,\n        (np.int16, 1): FIT_INT16,\n        (np.uint32, 1): FIT_UINT32,\n        (np.int32, 1): FIT_INT32,\n        (np.float32, 1): FIT_FLOAT,\n        (np.float64, 1): FIT_DOUBLE,\n        (np.complex128, 1): FIT_COMPLEX,\n        (np.uint16, 3): FIT_RGB16,\n        (np.uint16, 4): FIT_RGBA16,\n        (np.float32, 3): FIT_RGBF,\n        (np.float32, 4): FIT_RGBAF}\n\n    extra_dims = {\n        FIT_UINT16: [],\n        FIT_INT16: [],\n        FIT_UINT32: [],\n        FIT_INT32: [],\n        FIT_FLOAT: [],\n        FIT_DOUBLE: [],\n        FIT_COMPLEX: [],\n        FIT_RGB16: [3],\n        FIT_RGBA16: [4],\n        FIT_RGBF: [3],\n        FIT_RGBAF: [4]}\n\n    @classmethod\n    def get_type_and_shape(cls, bitmap):\n        w = _FI.FreeImage_GetWidth(bitmap)\n        h = _FI.FreeImage_GetHeight(bitmap)\n        fi_type = _FI.FreeImage_GetImageType(bitmap)\n        if not fi_type:\n            raise ValueError(\'mahotas.freeimage: unknown image pixel type\')\n        dtype = cls.dtypes[fi_type]\n        if fi_type == cls.FIT_BITMAP:\n            bpp = _FI.FreeImage_GetBPP(bitmap)\n            if bpp == 1:\n                # This is a special case\n                return \'bit\', None\n            elif bpp == 8:\n                extra_dims = []\n            elif bpp == 16:\n                extra_dims = []\n                dtype = np.uint16\n            elif bpp == 24:\n                extra_dims = [3]\n            elif bpp == 32:\n                extra_dims = [4]\n            else:\n                raise ValueError(\n                    \'mahotas.freeimage: cannot convert %d BPP bitmap\' % bpp)\n        else:\n            extra_dims = cls.extra_dims[fi_type]\n        return np.dtype(dtype), extra_dims + [w, h]\n\n\nclass IO_FLAGS(object):\n    #Bmp\n    BMP_DEFAULT = 0\n    BMP_SAVE_RLE = 1\n\n    #Png\n    PNG_DEFAULT = 0\n    PNG_IGNOREGAMMA = 1\n\n    #Gif\n    GIF_DEFAULT = 0\n    GIF_LOAD256 = 1\n    GIF_PLAYBACK = 2\n\n    #Ico\n    ICO_DEFAULT = 0\n    ICO_MAKEALPHA = 1\n\n    #Tiff\n    TIFF_DEFAULT = 0\n    TIFF_CMYK = 0x0001\n    TIFF_NONE = 0x0800\n    TIFF_PACKBITS = 0x0100\n    TIFF_DEFLATE = 0x0200\n    TIFF_ADOBE_DEFLATE = 0x0400\n    TIFF_CCITTFAX3 = 0x1000\n    TIFF_CCITTFAX4 = 0x2000\n    TIFF_LZW = 0x4000\n    TIFF_JPEG = 0x8000\n\n    #Jpeg\n    JPEG_DEFAULT = 0\n    JPEG_FAST = 1\n    JPEG_ACCURATE = 2\n    JPEG_QUALITYSUPERB = 0x80\n    JPEG_QUALITYGOOD = 0x100\n    JPEG_QUALITYNORMAL = 0x200\n    JPEG_QUALITYAVERAGE = 0x400\n    JPEG_QUALITYBAD = 0x800\n    JPEG_CMYK = 0x1000\n    JPEG_PROGRESSIVE = 0x2000\n\n    #Others...\n    CUT_DEFAULT = 0\n    DDS_DEFAULT = 0\n    HDR_DEFAULT = 0\n    IFF_DEFAULT = 0\n    KOALA_DEFAULT = 0\n    LBM_DEFAULT = 0\n    MNG_DEFAULT = 0\n    PCD_DEFAULT = 0\n    PCD_BASE = 1\n    PCD_BASEDIV4 = 2\n    PCD_BASEDIV16 = 3\n    PCX_DEFAULT = 0\n    PNM_DEFAULT = 0\n    PNM_SAVE_RAW = 0\n    PNM_SAVE_ASCII = 1\n    PSD_DEFAULT = 0\n    RAS_DEFAULT = 0\n    TARGA_DEFAULT = 0\n    TARGA_LOAD_RGB888 = 1\n    WBMP_DEFAULT = 0\n    XBM_DEFAULT = 0\n\n\nclass METADATA_MODELS(object):\n    FIMD_NODATA = -1\n    FIMD_COMMENTS = 0\n    FIMD_EXIF_MAIN = 1\n    FIMD_EXIF_EXIF = 2\n    FIMD_EXIF_GPS = 3\n    FIMD_EXIF_MAKERNOTE = 4\n    FIMD_EXIF_INTEROP = 5\n    FIMD_IPTC = 6\n    FIMD_XMP = 7\n    FIMD_GEOTIFF = 8\n    FIMD_ANIMATION = 9\n    FIMD_CUSTOM = 10\n\n\nclass FI_FORMAT(object):\n    FIF_UNKNOWN = -1\n    FIF_BMP = 0\n    FIF_ICO = 1\n    FIF_JPEG = 2\n    FIF_JNG = 3\n    FIF_KOALA = 4\n    FIF_LBM = 5\n    FIF_IFF = FIF_LBM\n    FIF_MNG = 6\n    FIF_PBM = 7\n    FIF_PBMRAW = 8\n    FIF_PCD = 9\n    FIF_PCX = 10\n    FIF_PGM = 11\n    FIF_PGMRAW = 12\n    FIF_PNG = 13\n    FIF_PPM = 14\n    FIF_PPMRAW = 15\n    FIF_RAS = 16\n    FIF_TARGA = 17\n    FIF_TIFF = 18\n    FIF_WBMP = 19\n    FIF_PSD = 20\n    FIF_CUT = 21\n    FIF_XBM = 22\n    FIF_XPM = 23\n    FIF_DDS = 24\n    FIF_GIF = 25\n    FIF_HDR = 26\n    FIF_FAXG3 = 27\n    FIF_SGI = 28\n    FIF_EXR = 29\n    FIF_J2K = 30\n    FIF_JP2 = 31\n    FIF_PFM = 32\n    FIF_PICT = 33\n    FIF_RAW = 34\n\n\ndef read(filename, flags=0):\n    """"""Read an image to a numpy array of shape (width, height) for\n    greyscale images, or shape (width, height, nchannels) for RGB or\n    RGBA images.\n\n    """"""\n    bitmap = _read_bitmap(filename, flags)\n    try:\n        return _array_from_bitmap(bitmap)\n    finally:\n        _FI.FreeImage_Unload(bitmap)\n\n\ndef read_multipage(filename, flags=0):\n    """"""Read a multipage image to a list of numpy arrays, where each\n    array is of shape (width, height) for greyscale images, or shape\n    (nchannels, width, height) for RGB or RGBA images.\n\n    """"""\n    ftype = _FI.FreeImage_GetFileType(_bytestr(filename), 0)\n    if ftype == -1:\n        raise ValueError(\n            \'mahotas.freeimage: cannot determine type of file %s\'%filename)\n    create_new = False\n    read_only = True\n    keep_cache_in_memory = True\n    multibitmap = _FI.FreeImage_OpenMultiBitmap(\n        ftype, _bytestr(filename), create_new, read_only, keep_cache_in_memory,\n        flags)\n    if not multibitmap:\n        raise ValueError(\n            \'mahotas.freeimage: could not open %s\'\n            \' as multi-page image.\' % filename)\n    try:\n        pages = _FI.FreeImage_GetPageCount(multibitmap)\n        arrays = []\n        for i in range(pages):\n            bitmap = _FI.FreeImage_LockPage(multibitmap, i)\n            try:\n                arrays.append(_array_from_bitmap(bitmap))\n            finally:\n                _FI.FreeImage_UnlockPage(multibitmap, bitmap, False)\n        return arrays\n    finally:\n        _FI.FreeImage_CloseMultiBitmap(multibitmap, 0)\n\n\ndef _read_bitmap(filename, flags):\n    """"""Load a file to a FreeImage bitmap pointer""""""\n    ftype = _FI.FreeImage_GetFileType(_bytestr(filename), 0)\n    if ftype == -1:\n        raise ValueError(\n            \'mahotas.freeimage: cannot determine type of file %s\' % filename)\n    bitmap = _FI.FreeImage_Load(ftype, _bytestr(filename), flags)\n    if not bitmap:\n        raise ValueError(\n            \'mahotas.freeimage: could not load file %s\' % filename)\n    return bitmap\n\n\ndef _wrap_bitmap_bits_in_array(bitmap, shape, dtype):\n    """"""Return an ndarray view on the data in a FreeImage bitmap. Only\n    valid for as long as the bitmap is loaded (if single page) / locked\n    in memory (if multipage).\n\n    """"""\n    pitch = _FI.FreeImage_GetPitch(bitmap)\n    itemsize = dtype.itemsize\n\n    if len(shape) == 3:\n        strides = (itemsize, shape[0]*itemsize, pitch)\n    else:\n        strides = (itemsize, pitch)\n    bits = _FI.FreeImage_GetBits(bitmap)\n\n    class DummyArray(object):\n        __array_interface__ = {\n            \'data\': (bits, False),\n            \'strides\': strides,\n            \'typestr\': dtype.str,\n            \'shape\': tuple(shape),\n            \'version\': 3,\n            }\n\n    return np.array(DummyArray(), copy=False)\n\n\ndef _array_from_bitmap(bitmap):\n    """"""Convert a FreeImage bitmap pointer to a numpy array\n\n    """"""\n    dtype, shape = FI_TYPES.get_type_and_shape(bitmap)\n    if type(dtype) == str and dtype == \'bit\':\n        bitmap8 = _FI.FreeImage_ConvertToGreyscale(bitmap)\n        try:\n            return _array_from_bitmap(bitmap8).astype(np.bool)\n        finally:\n            _FI.FreeImage_Unload(bitmap8)\n    array = _wrap_bitmap_bits_in_array(bitmap, shape, dtype)\n\n    # swizzle the color components and flip the scanlines to go from\n    # FreeImage\'s BGR[A] and upside-down internal memory format to something\n    # more normal\n    def n(arr):\n        return arr[..., ::-1].T\n\n    if (len(shape) == 3 and _FI.FreeImage_IsLittleEndian() and\n        dtype.type == np.uint8):\n        b = n(array[0])\n        g = n(array[1])\n        r = n(array[2])\n        if shape[0] == 3:\n            return np.dstack((r, g, b))\n        elif shape[0] == 4:\n            a = n(array[3])\n            return np.dstack((r, g, b, a))\n        else:\n            raise ValueError(\n                \'mahotas.freeimage: cannot handle images of\'\n                \' this shape (%s)\' % shape)\n\n    # We need to copy because array does *not* own its memory\n    # after bitmap is freed.\n    return n(array).copy()\n\n\ndef string_tag(bitmap, key, model=METADATA_MODELS.FIMD_EXIF_MAIN):\n    """"""Retrieve the value of a metadata tag with the given string key as a\n    string.""""""\n    tag = ctypes.c_int()\n    if not _FI.FreeImage_GetMetadata(model, bitmap, _bytestr(key),\n                                     ctypes.byref(tag)):\n        return\n    char_ptr = ctypes.c_char * _FI.FreeImage_GetTagLength(tag)\n    return char_ptr.from_address(_FI.FreeImage_GetTagValue(tag)).raw()\n\n\ndef write(array, filename, flags=0):\n    """"""Write a (width, height) or (width, height, nchannels) array to\n    a greyscale, RGB, or RGBA image, with file type deduced from the\n    filename.\n\n    """"""\n    filename = _bytestr(filename)\n    ftype = _FI.FreeImage_GetFIFFromFilename(filename)\n    if ftype == -1:\n        raise ValueError(\n            \'mahotas.freeimage: cannot determine type for %s\' % filename)\n    bitmap, fi_type = _array_to_bitmap(array)\n    try:\n        if fi_type == FI_TYPES.FIT_BITMAP:\n            can_write = _FI.FreeImage_FIFSupportsExportBPP(ftype,\n                                      _FI.FreeImage_GetBPP(bitmap))\n        else:\n            can_write = _FI.FreeImage_FIFSupportsExportType(ftype, fi_type)\n        if not can_write:\n            raise TypeError(\n                \'mahotas.freeimage: cannot save image of this type (%s) \'\n                \'to this file type\' % array.dtype)\n        res = _FI.FreeImage_Save(ftype, bitmap, filename, flags)\n        if not res:\n            raise RuntimeError(\n                \'mahotas.freeimage: could not save image properly.\')\n    finally:\n        _FI.FreeImage_Unload(bitmap)\n\n\ndef write_multipage(arrays, filename, flags=0, keep_cache_in_memory=True):\n    """"""Write a list of (width, height) or (nchannels, width, height)\n    arrays to a multipage greyscale, RGB, or RGBA image, with file type\n    deduced from the filename.\n\n    """"""\n    ftype = _FI.FreeImage_GetFIFFromFilename(_bytestr(filename))\n    if ftype == -1:\n        raise ValueError(\n            \'mahotas.freeimage: cannot determine type of file %s\' % filename)\n    create_new = True\n    read_only = False\n    multibitmap = _FI.FreeImage_OpenMultiBitmap(\n        ftype, _bytestr(filename), create_new, read_only,\n        keep_cache_in_memory, 0)\n    if not multibitmap:\n        raise ValueError(\n            \'mahotas.freeimage: could not open %s \'\n            \'for writing multi-page image.\' % filename)\n    try:\n        for array in arrays:\n            bitmap, _ = _array_to_bitmap(array)\n            _FI.FreeImage_AppendPage(multibitmap, bitmap)\n            _FI.FreeImage_Unload(bitmap)\n    finally:\n        _FI.FreeImage_CloseMultiBitmap(multibitmap, flags)\n\n\ndef _array_to_bitmap(array):\n    """"""Allocate a FreeImage bitmap and copy a numpy array into it.\n\n    """"""\n    shape = array.shape\n    dtype = array.dtype\n    r, c = shape[:2]\n    if len(shape) == 2:\n        n_channels = 1\n        w_shape = (c, r)\n    elif len(shape) == 3:\n        n_channels = shape[2]\n        w_shape = (n_channels, c, r)\n    else:\n        raise ValueError(\n            \'mahotas.freeimage: cannot handle image of 4 dimensions\')\n    try:\n        fi_type = FI_TYPES.fi_types[(dtype.type, n_channels)]\n    except KeyError:\n        raise ValueError(\n            \'mahotas.freeimage: cannot write arrays of given type and shape.\')\n\n    itemsize = array.dtype.itemsize\n    bpp = 8 * itemsize * n_channels\n    bitmap = _FI.FreeImage_AllocateT(fi_type, c, r, bpp, 0, 0, 0)\n    if not bitmap:\n        raise RuntimeError(\n            \'mahotas.freeimage: could not allocate image for storage\')\n    try:\n\n        def n(arr):  # normalise to freeimage\'s in-memory format\n            return arr.T[:, ::-1]\n\n        wrapped_array = _wrap_bitmap_bits_in_array(bitmap, w_shape, dtype)\n        # swizzle the color components and flip the scanlines to go to\n        # FreeImage\'s BGR[A] and upside-down internal memory format\n        if (len(shape) == 3 and _FI.FreeImage_IsLittleEndian() and\n            dtype.type == np.uint8):\n            wrapped_array[0] = n(array[:, :, 2])\n            wrapped_array[1] = n(array[:, :, 1])\n            wrapped_array[2] = n(array[:, :, 0])\n            if shape[2] == 4:\n                wrapped_array[3] = n(array[:, :, 3])\n        else:\n            wrapped_array[:] = n(array)\n\n        return bitmap, fi_type\n    except:\n        _FI.FreeImage_Unload(bitmap)\n        raise\n\n\ndef imsavetoblob(img, filetype, flags=0):\n    """"""\n    s = imsavetoblob(img, filetype, flags=0)\n\n    Save `img` to a `str` object\n\n    Parameters\n    ----------\n    img : ndarray\n        input image\n    filetype : str or integer\n        A file name like string, used only to determine the file type.\n        Alternatively, an integer flag (from FI_FORMAT).\n    flags : integer, optional\n\n    Returns\n    -------\n    s : str\n        byte representation of `img` in format `filetype`\n    """"""\n    if type(filetype) == str:\n        ftype = _FI.FreeImage_GetFIFFromFilename(_bytestr(filetype))\n    else:\n        ftype = filetype\n    try:\n        bitmap, fi_type = _array_to_bitmap(img)\n        mem = _FI.FreeImage_OpenMemory(0, 0)\n        if not _FI.FreeImage_SaveToMemory(ftype, bitmap, mem, flags):\n            raise IOError(\n                \'mahotas.freeimage.imsavetoblob: Cannot save to memory.\')\n        data = ctypes.c_void_p()\n        size = ctypes.c_int()\n        _FI.FreeImage_AcquireMemory(\n            mem, ctypes.byref(data), ctypes.byref(size))\n        return ctypes.string_at(data, size)\n    finally:\n        _FI.FreeImage_CloseMemory(mem)\n\n\ndef imreadfromblob(blob, ftype=None, as_grey=False):\n    """"""\n    arr = imreadfromblob(blob, ftype={auto}, as_grey=False)\n\n    Read an image from a blob (string)\n\n    Parameters\n    ----------\n    blob : str\n        Input\n    filetype : integer, optional\n        input type. By default, infer from image.\n    as_grey : boolean, optional\n        whether to convert colour images to grey scale\n\n    Returns\n    -------\n    arr : ndarray\n    """"""\n    try:\n        mem = _FI.FreeImage_OpenMemory(blob, len(blob))\n        if ftype is None:\n            ftype = _FI.FreeImage_GetFileTypeFromMemory(mem, 0)\n        bitmap = _FI.FreeImage_LoadFromMemory(ftype, mem, 0)\n        img = _array_from_bitmap(bitmap)\n        if as_grey and len(img.shape) == 3:\n            # these are the values that wikipedia says are typical\n            transform = np.array([0.30, 0.59, 0.11])\n            return np.dot(img, transform)\n        return img\n    finally:\n        _FI.FreeImage_CloseMemory(mem)\n\n\ndef imread(filename, as_grey=False):\n    """"""\n    img = imread(filename, as_grey=False)\n\n    Reads an image from file `filename`\n\n    Implementation is based on FreeImage.\n\n    Parameters\n    ----------\n      filename : file name\n      as_grey : Whether to convert to grey scale image (default: no)\n\n    Returns\n    -------\n      img : ndarray\n    """"""\n    img = read(filename)\n    if as_grey and len(img.shape) == 3:\n        # these are the values that wikipedia says are typical\n        transform = np.array([0.30, 0.59, 0.11])\n        return np.dot(img, transform)\n    return img\n\n\ndef imsave(filename, img):\n    """"""\n    imsave(filename, img)\n\n    Save image to disk\n\n    Image type is inferred from filename\n\n    Implementation is based on FreeImage.\n\n    Parameters\n    ----------\n      filename : file name\n      img : image to be saved as nd array\n    """"""\n    write(img, filename)\n\n\nif sys.version_info[0] > 2:\n    import locale\n    _, _encoding = locale.getdefaultlocale()\n    if _encoding is None:\n        _encoding = \'UTF-8\'\n    _bytestr = lambda x: x.encode(_encoding)\nelse:\n    _bytestr = str\n'"
mahotas/io/pil.py,1,"b""import numpy as np\nimport mahotas as mh\nfrom PIL import Image\n\ndef imread(filename, as_grey=False):\n    '''Read an image into a ndarray from a file.\n\n    This function depends on PIL (or Pillow) being installed.\n\n    Parameters\n    ----------\n    filename : str\n        filename\n    as_grey : boolean, optional\n        Whether to convert to grey scale image (default: no)\n    '''\n    im = Image.open(filename)\n    array = np.array(im)\n    if as_grey and array.ndim != 2:\n        array = mh.colors.rgb2grey(array)\n    return array\n\ndef imsave(filename, array):\n    '''\n    Writes `array` into file `filename`\n\n    This function depends on PIL (or Pillow) being installed.\n\n    Parameters\n    ----------\n    filename : str\n        path on file system\n    array : ndarray-like\n    '''\n    im = Image.fromarray(array)\n    im.save(filename)\n\n"""
mahotas/tests/__init__.py,0,"b""def run(verbose=False):\n    import nose\n    from os import path\n    currentdir = path.dirname(__file__)\n    updir = path.join(currentdir, '..')\n    argv = ['', '--exe', '-w', updir]\n    if verbose:\n        argv.append('--verbose')\n    return nose.run('mahotas', argv=argv)\n"""
mahotas/tests/pymorph_copy.py,3,"b""# This is from Pymorph.\n# Partial copy\nimport numpy as np\n\ndef add4dilate(f, c):\n    from numpy import asarray, minimum, maximum, float64\n\n    if not c:\n        return f\n    y = asarray(f,float64) + c\n    k1,k2 = limits(f)\n    y = ((f==k1) * k1) + ((f!=k1) * y)\n    y = maximum(minimum(y,k2),k1)\n    return y.astype(f.dtype)\ndef mat2set(A):\n    from numpy import take, ravel, nonzero, transpose, newaxis\n\n    if len(A.shape) == 1: A = A[newaxis,:]\n    offsets = nonzero(ravel(A) - limits(A)[0])[0]\n    if len(offsets) == 0: return ([],[])\n    h,w = A.shape\n    x = [0,1]\n    x[0] = offsets//w - (h-1)//2\n    x[1] = offsets%w - (w-1)//2\n    x = transpose(x)\n    return x,take(ravel(A),offsets)\n\ndef dilate(f, B):\n    from numpy import maximum, newaxis, ones, int32\n    h,w = f.shape\n    x,v = mat2set(B)\n    mh,mw = max(abs(x)[:,0]),max(abs(x)[:,1])\n    y = (ones((h+2*mh,w+2*mw),int32) * limits(f)[0]).astype(f.dtype)\n    for i in range(x.shape[0]):\n        if v[i] > -2147483647:\n            y[mh+x[i,0]:mh+x[i,0]+h, mw+x[i,1]:mw+x[i,1]+w] = maximum(\n                y[mh+x[i,0]:mh+x[i,0]+h, mw+x[i,1]:mw+x[i,1]+w], add4dilate(f,v[i]))\n    y = y[mh:mh+h, mw:mw+w]\n    return y\n\ndef sereflect(Bi):\n    return Bi[::-1, ::-1]\ndef limits(f):\n    from numpy import array, bool, uint8, uint16, int32, int64\n    code = f.dtype\n    if code == bool: return 0,1\n    if code == uint8: return 0,255\n    if code == uint16: return 0,65535\n    if code == int32: return -2147483647,2147483647\n    if code == int64: return -2**63,2**63-1\n\n    raise ValueError('pymorph.limits: does not accept this typecode: %s' % code)\n\ndef neg(f):\n    y = limits(f)[0] + limits(f)[1] - f\n    return y.astype(f.dtype)\n\ndef erode(f, b):\n    return neg(dilate(neg(f),sereflect(b)))\n\n\ndef cdilate(f, g, Bc, n=1):\n    f = np.minimum(f,g)\n    for i in range(n):\n        prev = f\n        f = np.minimum(dilate(f, Bc), g)\n        if np.all(f == prev): break\n    return f\n\n\n"""
mahotas/tests/test_bbox.py,22,"b""import numpy as np\nimport mahotas\nimport mahotas as mh\nfrom mahotas import bbox\nfrom nose.tools import raises\n\ndef test_croptobbox():\n    X,Y = np.meshgrid(np.arange(16)-8,np.arange(16)-8)\n    ball = ((X**2+Y**2) < 32).astype(np.uint8)\n    assert mahotas.croptobbox(ball).sum() == ball.sum()\n    assert mahotas.croptobbox(ball,border=2).sum() == ball.sum()\n    assert mahotas.croptobbox(ball,border=256).sum() == ball.sum()\n    assert mahotas.croptobbox(ball,border=256).size == ball.size\n    assert mahotas.croptobbox(ball.T).sum() == ball.sum()\n\n    assert mahotas.croptobbox(ball[::2]).sum() == ball[::2].sum()\n    assert mahotas.croptobbox(ball[::2].T).sum() == ball[::2].sum()\n    assert mahotas.croptobbox(ball.T, border=2).sum() == ball.sum()\n    assert mahotas.croptobbox(ball.T, border=256).sum() == ball.sum()\n    assert mahotas.croptobbox(ball.T, border=256).size == ball.size\n\ndef test_croptobbox_3d():\n    YXZ = np.indices((32,32,64), float)\n    YXZ -= 8\n    Y,X,Z = YXZ\n    ball = ((X**2+Y**2+Z**2) < 64).astype(np.uint8)\n    assert np.sum(ball) == np.sum(mh.croptobbox(ball))\n\n\ndef test_bbox_empty():\n    assert mahotas.bbox(np.zeros((), np.bool)).shape == (0,)\n\ndef test_bbox_3():\n    YXZ = np.indices((32,32,64), float)\n    YXZ -= 8\n    Y,X,Z = YXZ\n    ball = ((X**2+Y**2+Z**2) < 64).astype(np.uint8)\n    m0,M0,m1,M1,m2,M2 = mahotas.bbox(ball)\n\n    Y,X,Z = np.where(ball)\n    assert np.all(m0 <= Y)\n    assert np.all(m1 <= X)\n    assert np.all(m2 <= Z)\n    assert np.all(M0 > Y)\n    assert np.all(M1 > X)\n    assert np.all(M2 > Z)\n\n\ndef test_bbox():\n    img = np.zeros((10,10), np.uint16)\n    \n    a0,b0,a1,b1 = bbox(img)\n    assert a0 == b0\n    assert a1 == b1\n\n    img[4,2]=1\n    a0,b0,a1,b1=bbox(img)\n    assert a0 == 4\n    assert b0 == 5\n    assert a1 == 2\n    assert b1 == 3\n\n    img[6,8]=1\n    a0,b0,a1,b1=bbox(img)\n    assert a0 == 4 \n    assert b0 == 7 \n    assert a1 == 2 \n    assert b1 == 9 \n\n    img[7,7]=1\n    a0,b0,a1,b1=bbox(img)\n    assert a0 == 4\n    assert b0 == 8\n    assert a1 == 2\n    assert b1 == 9\n\n    c0,d0,c1,d1=bbox(img, 0)\n    assert c0 == a0\n    assert b0 == d0\n    assert c1 == a1\n    assert b1 == d1\n\n    c0,d0,c1,d1=bbox(img, 1)\n    assert c0 != a0\n    assert b0 != d0\n    assert c1 != a1\n    assert b1 != d1\n\ndef test_as_slice():\n    YXZ = np.indices((32,32,64), float)\n    YXZ -= 8\n    Y,X,Z = YXZ\n    ball = ((X**2+Y**2+Z**2) < 64).astype(np.uint8)\n    s = bbox(ball, as_slice=True)\n    assert ball[s].sum() == ball.sum()\n\ndef test_slice_border():\n    'Test bbox(slice=True, border=6) in 2D & 3D'\n    f = np.zeros((32,32), bool)\n    f[8:8] = 1\n    m0,M0, m1,M1 = mh.bbox(f, border=6, as_slice=False)\n    sl = mh.bbox(f, border=6, as_slice=True)\n\n    assert np.all(f[sl] == f[m0:M0, m1:M1])\n\n    f = np.zeros((32,32, 32), bool)\n    f[8:8,12:15] = 1\n    m0,M0, m1,M1, m2, M2 = mh.bbox(f, border=6, as_slice=False)\n    sl = mh.bbox(f, border=6, as_slice=True)\n\n    assert np.all(f[sl] == f[m0:M0, m1:M1, m2:M2])\n\n"""
mahotas/tests/test_bwperim.py,5,"b'from mahotas import bwperim\nimport numpy as np\n\ndef _neighbours(bwimg, y, x, n):\n    s0 = max(0, y-1)\n    e0 = min(y+2, bwimg.shape[0])\n    s1 = max(0, x-1)\n    e1 = min(x+2, bwimg.shape[1])\n    if n == 8:\n        return bwimg[s0:e0, s1:e1]\n    return np.concatenate([bwimg[s0:e0,x], bwimg[y,s1:e1]])\n\ndef _slow_bwperim(bwimg, n=4):\n    r,c = bwimg.shape\n    res = np.zeros_like(bwimg)\n    for y in range(r):\n        for x in range(c):\n            res[y,x] = bwimg[y,x] and np.any(~_neighbours(bwimg,y,x,n))\n    return res\n\ndef _compare_slow(img):\n    for n in (4,8):\n        assert np.all(_slow_bwperim(img, n) == bwperim(img, n))\n\ndef test_bwperim():\n    img = np.zeros((8,8), np.bool)\n    img[3:7,3:7] = 1\n    _compare_slow(img)\n\n    assert img[3:7,3:7].all()\n    assert img[3:7,3:7].sum() == img.sum()\n    img[2,2:4] = 1\n    _compare_slow(img)\n'"
mahotas/tests/test_center_of_mass.py,18,"b""import numpy as np\nfrom scipy import ndimage\nimport mahotas.center_of_mass\n\nnp.random.seed(2321)\ndef _mean_out(img, axis):\n    if len(img.shape) == 2: return img.mean(1-axis)\n    if axis == 0:\n        return _mean_out(img.mean(1), 0)\n    return _mean_out(img.mean(0), axis - 1)\n\ndef slow_center_of_mass(img):\n    '''\n    Returns the center of mass of img.\n    '''\n    xs = []\n    for axis,si in enumerate(img.shape):\n        xs.append(np.mean(_mean_out(img, axis) * np.arange(si)))\n    xs = np.array(xs)\n    xs /= img.mean()\n    return xs\n\n\ndef test_cmp_ndimage():\n    R = (255*np.random.rand(128,256)).astype(np.uint16)\n    R += np.arange(256, dtype=np.uint16)\n    m0,m1 = mahotas.center_of_mass(R)\n    n0,n1 = ndimage.center_of_mass(R)\n    assert np.abs(n0 - m0) < 1.\n    assert np.abs(n1 - m1) < 1.\n\ndef test_cmp_ndimage3():\n    R = (255*np.random.rand(32,128,8,16)).astype(np.uint16)\n    R += np.arange(16, dtype=np.uint16)\n    m = mahotas.center_of_mass(R)\n    n = ndimage.center_of_mass(R)\n    p = slow_center_of_mass(R)\n    assert np.abs(n - m).max() < 1.\n    assert np.abs(p - m).max() < 1.\n\ndef test_simple():\n    R = (255*np.random.rand(128,256)).astype(np.uint16)\n    R += np.arange(256, dtype=np.uint16)\n    m0,m1 = mahotas.center_of_mass(R)\n\n    assert 0 < m0 < 128\n    assert 0 < m1 < 256\n\n\ndef test_labels():\n    R = (255*np.random.rand(128,256)).astype(np.uint16)\n    labels = np.zeros(R.shape, np.intc)\n    labels[100:,:] += 1\n    labels[100:,100:] += 1\n    centres =  mahotas.center_of_mass(R, labels)\n    for label,cm in enumerate(centres):\n        assert np.all(cm == mahotas.center_of_mass(R * (labels == label)))\n\n\n\ndef test_labels_not_intc():\n    img = np.arange(256).reshape((16,16))\n    labels = img.copy()\n    labels %= 3\n    cm = mahotas.center_of_mass(img, labels)\n    assert cm.shape == (3,2)\n\n    labels = labels.T.copy()\n    cm = mahotas.center_of_mass(img, labels.T)\n    assert cm.shape == (3,2)\n\n    labels = labels.T.copy()\n    labels = labels.astype(np.uint16)\n    cm = mahotas.center_of_mass(img, labels)\n    assert cm.shape == (3,2)\n\n"""
mahotas/tests/test_citation.py,0,"b'import mahotas as mh\ndef test_citation():\n    from sys import stdout\n    t = mh.citation(False)\n    assert len(stdout.getvalue()) == 0\n    t2 = mh.citation(True)\n    assert len(stdout.getvalue()) != 0\n    assert t == t2\n\n    ts = mh.citation(False, short=True)\n    assert t != ts\n'"
mahotas/tests/test_close_holes.py,4,"b'import numpy as np\nimport mahotas\nimport sys\n\ndef test_close_holes_simple():\n    img = np.zeros((64,64),bool)\n    img[16:48,16:48] = True\n    holed =  np.logical_xor(img, mahotas.erode(mahotas.erode(img)))\n    assert np.all( mahotas.close_holes(holed) == img)\n    holed[12,12] = True\n    img[12,12] = True\n    assert np.all( mahotas.close_holes(holed) == img)\n    assert sys.getrefcount(holed) == 2\n'"
mahotas/tests/test_colors.py,9,"b'import mahotas\nimport numpy as np\nfrom mahotas.tests.utils import luispedro_jpg\nfrom mahotas.colors import rgb2xyz, rgb2lab, xyz2rgb, rgb2grey, rgb2sepia\n\ndef test_colors():\n    f = luispedro_jpg()\n    lab = rgb2lab(f)\n    assert np.max(np.abs(lab)) <= 100.\n    assert np.max(np.abs(xyz2rgb(rgb2xyz(f)) - f)) < 1.\n\n    lab8 = rgb2lab(f, dtype=np.uint8)\n    assert lab.dtype != np.uint8\n    assert lab8.dtype == np.uint8\n\n    xyz = rgb2xyz(f, dtype=np.uint8)\n    assert xyz.shape == f.shape\n    assert xyz.dtype == np.uint8\n\n\ndef test_rgb2grey():\n    f = luispedro_jpg()\n    fg = rgb2grey(f)\n    fg8 = rgb2grey(f, dtype=np.uint8)\n    assert f.ndim == 3\n    assert fg.ndim == 2\n    assert fg8.ndim == 2\n    assert fg.shape[0] == f.shape[0]\n    assert fg.shape[1] == f.shape[1]\n    assert fg.shape == fg8.shape\n    assert fg8.dtype == np.uint8\n\n\ndef test_sepia():\n    f = luispedro_jpg()\n    sepia= mahotas.colors.rgb2sepia(f)\n    assert sepia.shape == f.shape\n'"
mahotas/tests/test_convolve.py,66,"b""import numpy as np\nimport mahotas\nimport mahotas.convolve\nimport mahotas as mh\nfrom mahotas.convolve import convolve1d, gaussian_filter\nimport mahotas._filters\nfrom os import path\nfrom nose.tools import raises\nfrom mahotas.tests.utils import luispedro_jpg\n\ndef test_compare_w_ndimage():\n    from scipy import ndimage\n    A = np.arange(34*340, dtype='float64').reshape((34,340))%3\n    B = np.ones((3,3), A.dtype)\n    for mode in mahotas._filters.modes:\n        if mode == 'ignore':\n            continue\n        assert np.all(mahotas.convolve(A, B, mode=mode) == ndimage.convolve(A, B, mode=mode))\n\ndef test_22():\n    A = np.arange(1024).reshape((32,32))\n    B = np.array([\n        [0,1],\n        [2,3],\n        ])\n    C = np.array([\n        [0,1,0],\n        [2,3,0],\n        [0,0,0],\n        ])\n    AB = mahotas.convolve(A,B)\n    AC = mahotas.convolve(A,C)\n    assert AB.shape == AC.shape\n    assert np.all(AB == AC)\n\n\n@raises(ValueError)\ndef test_mismatched_dims():\n    f = np.arange(128*128, dtype=float).reshape((128,128))\n    filter = np.arange(17,dtype=float)-8\n    filter **= 2\n    filter /= -16\n    np.exp(filter,filter)\n    mahotas.convolve(f,filter)\n\ndef test_convolve1d_shape():\n    f = np.arange(64*4).reshape((16,-1))\n    n = [.5,1.,.5]\n    for axis in (0,1):\n        g = convolve1d(f, n, axis)\n        assert g.shape == f.shape\n\n@raises(ValueError)\ndef test_convolve1d_2d():\n    f = np.arange(64*4).reshape((16,-1))\n    n = np.array([[.5,1.,.5],[0.,2.,0.]])\n    convolve1d(f, n, 0)\n\n\ndef test_gaussian_filter():\n    from scipy import ndimage\n    f = luispedro_jpg(1)\n    for s in (4.,8.,12.):\n        g = gaussian_filter(f, s)\n        n = ndimage.gaussian_filter(f, s)\n        assert np.max(np.abs(n - g)) < 1.e-5\n\ndef test_gaussian_order():\n    im = np.arange(64*64).reshape((64,64))\n    for order in (1,2,3):\n        g_mat = mahotas.gaussian_filter(im, 2., order=order)\n\ndef test_gaussian_order_high():\n    im = np.arange(64*64).reshape((64,64))\n    @raises(ValueError)\n    def gaussian_order(order):\n        mahotas.gaussian_filter(im, 2., order=order)\n    yield gaussian_order, 4\n    yield gaussian_order, 5\n    yield gaussian_order, -3\n    yield gaussian_order, -1\n    yield gaussian_order, 1.5\n\ndef test_haar():\n    image = luispedro_jpg(1)\n    image = image[:256,:256]\n    wav = mahotas.haar(image)\n\n    assert wav.shape == image.shape\n    assert np.allclose((image[0].reshape((-1,2)).mean(1)+image[1].reshape((-1,2)).mean(1))/2, wav[0,:128]/2.)\n    assert np.abs(np.mean(image**2) - np.mean(wav**2)) < 1.\n\n    image = luispedro_jpg(1)\n    wav =  mahotas.haar(image, preserve_energy=False)\n    assert np.abs(np.mean(image**2) - np.mean(wav**2)) > 16.\n    wav =  mahotas.haar(image, inline=True)\n    assert id(image) == id(wav)\n\ndef test_ihaar():\n    image = luispedro_jpg(1)\n    image = image[:256,:256]\n    wav = mahotas.haar(image)\n    iwav = mahotas.ihaar(wav)\n    assert np.allclose(image, iwav)\n    iwav = mahotas.ihaar(wav, preserve_energy=False)\n    assert not np.allclose(wav, iwav)\n    iwav =  mahotas.ihaar(wav, inline=True)\n    assert id(iwav) == id(wav)\n\n\ndef test_daubechies_D2_haar():\n    image = luispedro_jpg(1)\n    image = image[:256,:256]\n    wav = mahotas.haar(image, preserve_energy=False)\n    dau = mahotas.daubechies(image, 'D2')\n\n    assert wav.shape == dau.shape\n    assert np.allclose(dau, wav)\n\ndef test_3d_wavelets_error():\n    @raises(ValueError)\n    def call_f(f):\n        f(np.arange(4*4*4).reshape((4,4,4)))\n\n    yield call_f, mahotas.haar\n    yield call_f, mahotas.ihaar\n    yield call_f, lambda im: mahotas.daubechies(im, 'D4')\n\n@raises(ValueError)\ndef test_non_valid_daubechies():\n    image = luispedro_jpg()\n    mahotas.daubechies(image, 'D-4')\n\ndef test_wavelets_inline():\n    def inline(f):\n        im = np.arange(16, dtype=float).reshape((4,4))\n        t = f(im, inline=True)\n        assert id(im) == id(t)\n\n    yield inline, mahotas.haar\n    yield inline, lambda im,inline: mahotas.daubechies(im, 'D4', inline=inline)\n\ndef test_wavelet_iwavelet():\n    f = luispedro_jpg(1)\n    f = f[:256,:256]\n    fo = f.copy()\n    D4 = np.array([0.6830127,  1.1830127,  0.3169873, -0.1830127], dtype=np.float32)\n    D4_high = D4[::-1].copy()\n    D4_high[1::2] *= -1\n    f = f[34]\n    low = np.convolve(f, D4)\n    high = np.convolve(f,D4_high)\n    low[::2] = 0\n    high[::2] = 0\n    rec = (np.convolve(high, D4_high[::-1])+np.convolve(low, D4[::-1]))\n    rec /= 2\n    f2 = np.array([f])\n    mahotas._convolve.wavelet(f2,D4)\n\n    hand = np.concatenate((low[3::2],high[3::2]))\n    wav = f2.ravel()\n    assert np.allclose(hand,wav)\n    mahotas._convolve.iwavelet(f2,D4)\n    assert np.allclose(rec[3:-3],f)\n    assert np.allclose(f2.ravel()[3:-3],f[3:-3])\n\n    \ndef test_daubechies_idaubechies():\n    f = luispedro_jpg(1)\n    f = f[:256,:256]\n    fo = f.copy()\n\n    d = mahotas.daubechies(f, 'D8')\n    r = mahotas.idaubechies(d, 'D8')\n    assert np.mean( (r[4:-4,4:-4] - fo[4:-4,4:-4])**2) < 1.\n\n\ndef _is_power2(x):\n    if x in (0,1,2,4,8,16,32,64,128): return True\n    if (x & 1) != 0: return False\n    return _is_power2(x // 2)\n\ndef test_center_decenter():\n    from mahotas import wavelet_decenter\n    from mahotas import wavelet_center\n    np.random.seed(12)\n    for border in (0, 1, 17):\n        f = np.random.rand(51,100)\n        fc = wavelet_center(f, border=border)\n        assert all(map(_is_power2, fc.shape))\n        \n        fd = wavelet_decenter(fc, f.shape, border=border)\n\n        assert fd.shape == f.shape\n        assert np.all(fd == f)\n\n\ndef test_center_border():\n    from mahotas import wavelet_center\n    np.random.seed(12)\n    for border in (16, 24):\n        f = np.random.rand(51,100)\n        fc = wavelet_center(f, border=border)\n        assert np.all(fc[:border] == 0)\n        assert np.all(fc[-border:] == 0)\n        assert np.all(fc.T[:border] == 0)\n        assert np.all(fc.T[-border:] == 0)\n\ndef test_center_wavelet_iwavelet_decenter():\n    from mahotas import wavelet_center, wavelet_decenter\n    import mahotas\n    import numpy as np\n\n    f = luispedro_jpg(1)\n    f = f[:100,:250]\n    fo = f.copy()\n\n    for wav in ('D2', 'D4', 'D6', 'D8', 'D10', 'D12', 'D16'):\n        fc = mahotas.wavelet_center(fo, border=24)\n        t = mahotas.daubechies(fc, wav)\n        r = mahotas.idaubechies(t, wav)\n        rd = mahotas.wavelet_decenter(r, fo.shape, border=24)\n        assert np.allclose(fo, rd)\n\n\ndef test_convolve1d():\n    ws = [\n        np.array([-.1, .5,.7,.7,.5]),\n        np.array([.1,.7,.5]),\n        ]\n    for i in range(8):\n        for w in ws:\n            f = np.random.random((128,96))\n            ww = np.atleast_2d(w)\n            fw = mh.convolve(f, ww)\n            fww = mh.convolve(f, ww.T)\n\n            f0w = mh.convolve1d(f, w, 0)\n            f1w = mh.convolve1d(f, w, 1)\n\n            assert np.all(fw == f1w)\n            assert np.all(fww == f0w)\n\n@raises(ValueError)\ndef test_gaussian_small_sigma():\n    im =  np.arange(128*4).reshape((16,-1))\n    mh.gaussian_filter(im, .01)\n\n\ndef test_gaussian_small_image():\n    np.random.seed(123)\n    f = (np.random.random((10,141))*255).astype(np.uint8)\n    ff = mh.gaussian_filter(f, 2.)\n    assert f.shape == ff.shape\n\n\ndef test_convolve1d_axis():\n    f = np.random.random((128,32))\n    w = np.array([.1, .2, .4])\n    fw = mh.convolve1d(f, w, 0)\n    for i in range(32):\n        assert np.allclose(np.correlate(f.T[i], w, 'same')[1:-1], fw[1:-1,i])\n\ndef test_convolve_1d_axis_3d():\n    f = np.random.random((128,32,6))\n    w = np.array([.1, .2, .4])\n    fw = mh.convolve1d(f, w, 0)\n    for i in range(f.shape[1]):\n        for j in range(f.shape[2]):\n            assert np.allclose(np.correlate(f[:,i,j], w,'same')[1:-1:] , fw[:,i,j][1:-1])\n\n\ndef test_gaussian_filter1d_higher_dims():\n    a = np.zeros((120,120))\n    a[:60] = 2\n    a1 = mh.gaussian_filter1d(a, 1., axis=0)\n\n    for a3 in ([a], [a,a], [a,a,a]):\n        a1_3d = mh.gaussian_filter1d(np.array(a3), 1., axis=1)\n        a1_3dm = a1_3d.max(0)\n        assert np.allclose(a1, a1_3dm)\n        assert np.abs(a1-a1_3dm).max() < 0.01\n\n    a1_4d = mh.gaussian_filter1d(np.array([[a], [a], [a]]), 1., axis=2)\n    a1_4dm = a1_4d.max(0).max(0)\n    assert np.allclose(a1, a1_4dm)\n    assert np.abs(a1-a1_4dm).max() < 0.01\n\n"""
mahotas/tests/test_demos.py,0,"b""import mahotas.demos\nfrom os import path\n\ndef test_image_path():\n    assert path.exists(mahotas.demos.image_path('luispedro.jpg'))\n    assert not path.exists(mahotas.demos.image_path('something-that-does-not-exist'))\n\n"""
mahotas/tests/test_dilate_erode.py,51,"b""import numpy as np\nimport mahotas as mh\nimport mahotas\n\ndef test_grey_erode():\n    from mahotas.tests.pymorph_copy import erode as slow_erode\n    from mahotas.tests.pymorph_copy import dilate as slow_dilate\n    np.random.seed(334)\n    for i in range(8):\n        f = np.random.random_sample((128,128))\n        f *= 255\n        f = f.astype(np.uint8)\n        B = (np.random.random_sample((3,3))*255).astype(np.uint8)\n        B //= 4\n        fast = mahotas.erode(f,B)\n        slow = slow_erode(f,B)\n        # mahotas & pymorph use different border conventions.\n        assert np.all(fast[1:-1,1:-1] == slow[1:-1,1:-1])\n\n        fast = mahotas.dilate(f,B)\n        slow = slow_dilate(f,B)\n        # mahotas & pymorph use different border conventions.\n        assert np.all(fast[1:-1,1:-1] == slow[1:-1,1:-1])\n\n\ndef test_dilate_erode():\n    A = np.zeros((128,128), dtype=bool)\n    Bc = np.array([\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 1, 0]], bool)\n    A[32,32] = True\n    origs = []\n    for i in range(12):\n        origs.append(A.copy())\n        A = mahotas.dilate(A, Bc)\n    for i in range(12):\n        A = mahotas.erode(A, Bc)\n        assert np.all(A == origs[-i-1])\n\n\n\ndef test_dilate_1():\n    A = np.zeros((16,16), dtype=np.uint8)\n    B = np.array([\n        [0,1,0],\n        [2,2,1],\n        [1,3,0]], dtype=np.uint8)\n    A[8,8] = 1\n    D = mahotas.dilate(A, B)\n    assert np.sum(D) == np.sum(B+(B>0))\n\ndef test_signed():\n    A = np.array([0,0,1,1,1,0,0,0], dtype=np.int32)\n    B = np.array([0,1,0])\n    assert np.min(mahotas.erode(A,B)) == -1\n\n\ndef test_cerode():\n    from mahotas.tests.pymorph_copy import erode as slow_erode\n    from mahotas.tests.pymorph_copy import dilate as slow_dilate\n    np.random.seed(334)\n    f = np.random.random_sample((128,128))\n    f = (f > .9)\n    assert np.all(mahotas.erode(f) == mahotas.cerode(f, np.zeros_like(f)))\n\ndef test_cdilate():\n    from mahotas.tests.pymorph_copy import cdilate as slow_cdilate\n    np.random.seed(332)\n    Bc = np.zeros((3,3),bool)\n    Bc[1] = 1\n    Bc[:,1] = 1\n    for n in range(8):\n        f = np.random.random_sample((128,128))\n        f = (f > .9)\n        g = np.random.random_sample((128,128))\n        g = (g > .7)\n        assert np.all(mahotas.cdilate(f,g,Bc,n+1) == slow_cdilate(f,g,Bc,n+1))\n\n\ndef test_cdilate_large():\n    f = np.zeros((8,8),bool)\n    f[4,4] = 1\n    assert np.all(mh.cdilate(f, 12))\n\n\ndef test_erode_slice():\n    np.random.seed(30)\n    for i in range(16):\n        f = (np.random.random_sample((256,256))*255).astype(np.uint8)\n        assert np.all(mahotas.erode(f[:3,:3]) == mahotas.erode(f[:3,:3].copy()))\n\ndef test_dilate_slice():\n    np.random.seed(30)\n    for i in range(16):\n        f = (np.random.random_sample((256,256))*255).astype(np.uint8)\n        assert np.all(mahotas.dilate(f[:3,:3]) == mahotas.dilate(f[:3,:3].copy()))\n\ndef test_fast_binary():\n    # This test is based on an internal code decision: the fast code is only triggered for CARRAYs\n    # Therefore, we test to see if both paths lead to the same result\n    np.random.seed(34)\n    for i in range(8):\n        f = np.random.random((128,128)) > .9\n        f2 = np.dstack([f,f,f])\n\n        SEs = [\n            np.ones((3,3)),\n            np.ones((5,5)),\n            np.array([\n                    [0,1,0],\n                    [0,0,0],\n                    [0,0,0]]),\n            np.array([\n                    [0,0,0],\n                    [1,0,0],\n                    [0,0,0]]),\n            np.array([\n                    [1,0,0],\n                    [1,0,0],\n                    [0,0,0]]),\n            np.array([\n                    [1,1,1],\n                    [1,1,1],\n                    [1,1,0]]),\n            np.array([\n                    [1,1,1],\n                    [0,1,1],\n                    [1,1,0]]),\n            ]\n        for Bc in SEs:\n            assert np.all(mahotas.erode(f,Bc=Bc) == mahotas.erode(f2[:,:,1],Bc=Bc))\n            # For dilate, the border conditions are different;\n            # This is not great, but it's actually the slow implementation\n            # which has the most unsatisfactory behaviour:\n            assert np.all(mahotas.dilate(f,Bc=Bc)[1:-1,1:-1] == mahotas.dilate(f2[:,:,1],Bc=Bc)[1:-1,1:-1])\n\ndef test_se_zeros():\n    np.random.seed(35)\n    f = np.random.random((128,128)) > .9\n    f2 = np.dstack([f,f,f])\n    mahotas.erode(f, np.zeros((3,3)))\n    mahotas.dilate(f, np.zeros((3,3)))\n    mahotas.erode(f2[:,:,1], np.zeros((3,3)))\n    mahotas.dilate(f2[:,:,1], np.zeros((3,3)))\n"""
mahotas/tests/test_distance.py,21,"b""from mahotas import distance\nimport numpy as np\ndef _slow_dist(bw, metric):\n    sd = np.empty(bw.shape, np.double)\n    sd.fill(np.inf)\n    Y,X = np.indices(bw.shape)\n    for y,x in zip(*np.where(~bw)):     \n        sd = np.minimum(sd, (Y-y)**2 + (X-x)**2)\n    if metric == 'euclidean':\n        sd = np.sqrt(sd)\n    return sd\n\ndef _slow_dist4d(bw, metric):\n    sd = np.empty(bw.shape, np.double)\n    sd.fill(np.inf)\n    Y,X,W,Z = np.indices(bw.shape)\n    for y,x,w,z in zip(*np.where(~bw)):     \n        sd = np.minimum(sd, (Y-y)**2 + (X-x)**2 + (W-w)**2 + (Z-z)**2)\n    if metric == 'euclidean':\n        sd = np.sqrt(sd)\n    return sd\n\n\ndef compare_slow(bw):\n    for metric in ('euclidean', 'euclidean2'):\n        f = distance(bw, metric)\n        sd = _slow_dist(bw, metric)\n        assert np.all(f == sd)\n\ndef test_distance():\n    bw = np.ones((256, 256), bool)\n    bw[100, 100] = 0\n    yield compare_slow, bw\n\n    bw[100:110, 100:110] = 0\n    yield compare_slow, bw\n\n    bw[200:210, 200:210] = 0\n    yield compare_slow, bw\n\n\ndef test_uint8():\n    # This did not work correctly in 0.9.5\n    a8 = np.zeros((5,5), dtype=np.uint8)\n    ab = np.zeros((5,5), dtype=bool)\n    assert np.all(distance(a8) == distance(ab))\n\n\ndef test_4d():\n    np.random.seed(324)\n    for _ in range(16):\n        binim = np.random.random((4,8,4,6)) > .5\n        dist = distance(binim)\n        assert dist.shape == binim.shape\n        assert np.all(dist[~binim] == 0)\n        assert np.all(dist == _slow_dist4d(binim, 'euclidean2'))\n"""
mahotas/tests/test_edge.py,10,"b""from mahotas.edge import sobel\nfrom nose.tools import raises\nimport mahotas as mh\nimport numpy as np\n\ndef test_sobel_shape():\n    A = np.arange(100*100)\n    A = (A % 15)\n    A = A.reshape((100,100))\n    assert sobel(A).shape == A.shape\n    assert sobel(A, just_filter=True).shape == A.shape\n\ndef test_sobel_zeros():\n    A = np.zeros((15,100))\n    assert sobel(A).shape == A.shape\n    assert sobel(A).sum() == 0\n\ndef test_sobel():\n    I = np.array([\n            [0,0,0,0,0,0],\n            [0,0,0,1,0,0],\n            [0,0,0,1,0,0],\n            [0,0,0,1,0,0],\n            [0,0,0,1,0,0],\n            [0,0,0,0,0,0]])\n    E = sobel(I)\n    r,c = I.shape\n    for y,x in zip(*np.where(E)):\n        N = [I[y,x]]\n        if y > 0: N.append(I[y-1,x])\n        if x > 0: N.append(I[y,x-1])\n        if y < (r-1): N.append(I[y+1,x])\n        if x < (c-1): N.append(I[y,x+1])\n        assert len(set(N)) > 1\n\ndef test_zero_images():\n    assert np.isnan(sobel(np.zeros((16,16)))).sum() == 0\n    assert sobel(np.zeros((16,16)), just_filter=True).sum() == 0\n\n\ndef test_sobel_pure():\n    f = np.random.random((64, 128))\n    f2 = f.copy()\n    _ = mh.sobel(f)\n    assert np.all(f == f2)\n\n\n@raises(ValueError)\ndef test_3d_error():\n    f = np.zeros((32,16,3))\n    sobel(f)\n\n\ndef test_dog():\n    im = mh.demos.load('lena')\n    im = im.mean(2)\n    edges = mh.dog(im)\n    assert edges.shape == im.shape\n    assert edges.any()\n    edges1 = mh.dog(im, sigma1=1.)\n    assert np.any(edges != edges1)\n"""
mahotas/tests/test_euler.py,5,"b'import numpy as np\nfrom mahotas.euler import euler, _euler_lookup4, _euler_lookup8\nfrom nose.tools import raises\n\ndef test_lookup():\n    Q1 = [np.array(q, np.bool) for q in ([[0,0],[1,0]], [[0,0],[0,1]], [[0,1],[0,0]], [[1,0],[0,0]]) ]\n    Q2 =  [(~q) for q in Q1]\n    Q3 = [np.array(q, np.bool) for q in ([[0,1],[1,0]], [[1,0],[0,1]]) ]\n\n    def _value(q, lookup):\n        q = q.ravel()\n        value = np.dot(q, (1,2,4,8))\n        return lookup[value]\n\n    for q in Q1:\n        assert _value(q, _euler_lookup8) == .25\n        assert _value(q, _euler_lookup4) == .25\n    for q in Q2:\n        assert _value(q, _euler_lookup8) == -.25\n        assert _value(q, _euler_lookup4) == -.25\n    for q in Q3:\n        assert _value(q, _euler_lookup8) == -.5\n        assert _value(q, _euler_lookup4) ==  .5\n\ndef test_euler():\n    f = np.zeros((16,16), np.bool)\n    f[4:8,4:8] = 1\n    assert euler(f) == 1\n    assert euler(f, 4) == 1\n\n    f[6:7,5:7] = 0\n\n    assert euler(f) == 0\n    assert euler(f, 4) == 0\n\n@raises(ValueError)\ndef test_euler7():\n    f = np.arange(100)\n    f = (f % 5) == 1\n    f = f.reshape((10,10))\n    euler(f, 7)\n\n'"
mahotas/tests/test_features_shape.py,10,"b'import mahotas.features.shape\nimport numpy as np\nimport mahotas as mh\nfrom mahotas.features.shape import roundness, eccentricity\n\ndef test_eccentricity():\n    D = mh.disk(32, 2)\n    ecc = mahotas.features.shape.eccentricity(D)\n    assert 0 <= ecc < .01\n\n    Index = np.indices((33,33)).astype(float)\n    Index -= 15\n    X,Y = Index\n    ellipse = ((X**2+2*Y**2) < 12**2)\n    assert 0 < mahotas.features.shape.eccentricity(ellipse) < 1\n\ndef test_roundness():\n    Y,X = -24 + np.indices((48,48)).astype(float)\n    r = roundness( (Y ** 2. + X**2.) < 4**2. )\n    assert r > 0\n    r2 = roundness( (Y ** 2. + 2* X**2.) < 4**2. )\n    assert r2 > 0\n    assert r2 < r\n\ndef test_zeros():\n    assert roundness(np.zeros((10,10))) == 0\n    assert eccentricity(np.zeros((10,10))) == 0\n    I = np.zeros((16,16))\n    I[8:4:12] = 1\n    assert eccentricity(I) == 0\n\ndef test_ellipse_axes():\n    Y,X = np.mgrid[:1024,:1024]\n    Y = Y/1024.\n    X = X/1024.\n    im = ((2.*(Y - .5)**2 + (X - .5)**2) < .2)\n    maj,min = mh.features.ellipse_axes(im)\n    assert np.abs(2 - (maj/min)**2) < .01\n\n    maj2,min2 = mh.features.ellipse_axes(im.T)\n\n    assert np.abs(maj - maj2) < .001\n    assert np.abs(min - min2) < .001\n\n    im = (((Y - .5)**2 + (X - .5)**2) < .2)\n    maj,min = mh.features.ellipse_axes(im)\n    assert np.abs(1 - (maj/min)**2) < .01\n'"
mahotas/tests/test_filters.py,0,"b""from mahotas import _filters\nfrom nose.tools import raises\n\n@raises(ValueError)\ndef test_bad_mode():\n    _filters._check_mode('nayrest', 0., 'f')\n\n@raises(NotImplementedError)\ndef test_cval_not_zero():\n    _filters._check_mode('constant', 1.2, 'f')\n\ndef test_good_mode():\n    for mode in _filters.modes:\n        _filters._check_mode(mode, 0., 'f')\n\n"""
mahotas/tests/test_find.py,7,"b'import numpy as np\nimport mahotas as mh\ndef test_find():\n    for _ in range(16):\n        f = np.random.random((128,128))\n        c0,c1 = 43,23\n        for h,w in [(12,56),\n                    (11,7),\n                    (12,7)]:\n            matches = mh.find(f, f[c0:c0+h, c1:c1+w])\n            coords = np.array(np.where(matches))\n            assert np.all(coords.T == np.array((c0,c1)), 1).any()\n\ndef test_negative():\n    f = 255*np.random.random((228,228))\n    f = f.astype(np.uint8)\n    h,w = 12,6\n    t = f[:h,:w]\n    matches = mh.find(f, t)\n    coords = np.array(np.where(matches))\n    for y,x in zip(*coords):\n        if y < 0 or x < 0:\n            continue\n        assert np.all(f[y:y+h, x:x+w] == t)\n'"
mahotas/tests/test_freeimage.py,14,"b'import numpy as np\nfrom os import path\nfrom nose.tools import with_setup\n\n_test_dir = None\n_testimgname = None\n\ntry:\n    from mahotas.io import freeimage\nexcept OSError:\n    from nose import SkipTest\n    raise SkipTest(""FreeImage not found"")\n\ndef _create_tempdir():\n    import tempfile\n    global _test_dir, _testimgname\n    _test_dir = tempfile.mkdtemp(prefix=\'mh_test\')\n    _testimgname = path.join(_test_dir, ""mahotas_test.png"")\n\ndef _remove_tempdir():\n    from shutil import rmtree\n    rmtree(_test_dir)\n\ncreate_remove = with_setup(setup=_create_tempdir, teardown=_remove_tempdir)\n\n@create_remove\ndef test_freeimage():\n    img = np.arange(256).reshape((16,16)).astype(np.uint8)\n\n    freeimage.imsave(_testimgname, img)\n    img_ = freeimage.imread(_testimgname)\n    assert img.shape == img_.shape\n    assert np.all(img == img_)\n\n\n@create_remove\ndef test_as_grey():\n    colour = np.arange(16*16*3).reshape((16,16,3))\n    freeimage.imsave(_testimgname, colour.astype(np.uint8))\n    c2 = freeimage.imread(_testimgname, as_grey=True)\n    assert len(c2.shape) == 2\n    assert c2.shape == colour.shape[:-1]\n\ndef test_rgba():\n    rgba = path.join(\n                path.dirname(__file__),\n                \'data\',\n                \'rgba.png\')\n    rgba = freeimage.imread(rgba)\n    assert np.all(np.diff(rgba[:,:,3].mean(1)) < 0 ) # the image contains an alpha gradient\n\n\n@create_remove\ndef test_save_load_rgba():\n    img = np.arange(256).reshape((8,8,4)).astype(np.uint8)\n    freeimage.imsave(_testimgname, img)\n    img_ = freeimage.imread(_testimgname)\n    assert img.shape == img_.shape\n    assert np.all(img == img_)\n\ndef test_fromblob():\n    img = np.arange(100, dtype=np.uint8).reshape((10,10))\n    s = freeimage.imsavetoblob(img, \'t.png\')\n    assert np.all(freeimage.imreadfromblob(s) == img)\n\n    s = freeimage.imsavetoblob(img, \'t.bmp\')\n    assert np.all(freeimage.imreadfromblob(s) == img)\n\n\ndef test_1bpp():\n    bpp = path.join(\n                path.dirname(__file__),\n                \'data\',\n                \'1bpp.bmp\')\n    bpp = freeimage.imread(bpp)\n    assert bpp.sum()\n    assert bpp.sum() < bpp.size\n\n@create_remove\ndef test_multi():\n    testtif = _test_dir + \'/mahotas_test.tif\'\n    f = np.zeros((16,16), np.uint8)\n    fs = []\n    for t in range(8):\n      f[:t,:t] = t\n      fs.append(f.copy())\n    freeimage.write_multipage(fs, testtif)\n    fs2 = freeimage.read_multipage(testtif)\n    for f,f2 in zip(fs,fs2):\n        assert np.all(f == f2)\n\n\n@create_remove\ndef test_uint16():\n    img = np.zeros((32,32), dtype=np.uint16)\n    freeimage.imsave(_testimgname, img)\n    img_ = freeimage.imread(_testimgname)\n\n    assert img.shape == img_.shape\n    assert img.dtype == img_.dtype\n    assert np.all(img == img_)\n\n'"
mahotas/tests/test_gvoronoi.py,8,"b'import numpy as np\nfrom mahotas.segmentation import gvoronoi\n\ndef scipy_gvoronoi(labeled):\n    from scipy import ndimage\n    L1,L2 = ndimage.distance_transform_edt(labeled== 0, return_distances=False, return_indices=True)\n    return labeled[L1,L2]\n\n\ndef test_compare_w_scipy():\n    np.random.seed(2322)\n    for i in range(8):\n        labeled = np.zeros((128,128))\n        for p in range(16):\n            y = np.random.randint(128)\n            x = np.random.randint(128)\n            labeled[y,x] = p+1\n        sp = scipy_gvoronoi(labeled)\n        mh = gvoronoi(labeled)\n        assert np.all(sp == mh)\n\ndef test_gvoronoi():\n    labeled = np.zeros((128,128))\n    labeled[0,0] = 1\n    labeled[-1,-1] = 2\n    regions = gvoronoi(labeled)\n    Y,X = np.where(regions == 1)\n    assert np.all(Y+X < 128)\n\n'"
mahotas/tests/test_histogram.py,16,"b'import numpy as np\nfrom mahotas.histogram import fullhistogram\nfrom nose.tools import raises\n\ndef test_fullhistogram():\n    A100 = np.arange(100).reshape((10,10)).astype(np.uint32)\n    assert fullhistogram(A100).shape == (100,)\n    assert np.all(fullhistogram(A100) == np.ones(100))\n\n    A1s = np.ones((12,12), np.uint8)\n    assert fullhistogram(A1s).shape == (2,)\n    assert np.all(fullhistogram(A1s) == np.array([0,144]))\n\n    A1s[0] = 0\n    A1s[1] = 2\n    assert fullhistogram(A1s).shape == (3,)\n    assert np.all(fullhistogram(A1s) == np.array([12,120,12]))\n\ndef test_fullhistogram_random():\n    np.random.seed(122)\n    A = np.random.rand(12,3,44,33)*1000\n    A = A.astype(np.uint16)\n    hist = fullhistogram(A)\n    for i in range(len(hist)):\n        assert hist[i] == (A == i).sum()\n    assert len(hist.shape) == 1\n\n    A = A[::2,:,2::3,1:-2:2]\n    hist = fullhistogram(A)\n    for i in range(len(hist)):\n        assert hist[i] == (A == i).sum()\n    assert hist.sum() == A.size\n    assert len(hist.shape) == 1\n\ndef test_fullhistogram_boolean():\n    np.random.seed(123)\n    A = (np.random.rand(128,128) > .5)\n    H = fullhistogram(A)\n    assert H[0] == (~A).sum()\n    assert H[1] == A.sum()\n\ndef test_types():\n    A100 = np.arange(100).reshape((10,10)).astype(np.uint32)\n    assert np.all(fullhistogram(A100.astype(np.uint8)) == fullhistogram(A100))\n    assert np.all(fullhistogram(A100.astype(np.uint16)) == fullhistogram(A100))\n    assert np.all(fullhistogram(A100.astype(np.uint32)) == fullhistogram(A100))\n    assert np.all(fullhistogram(A100.astype(np.uint64)) == fullhistogram(A100))\n\n@raises(TypeError)\ndef test_float():\n    fullhistogram(np.arange(16.*4., dtype=float).reshape((16,4)))\n\n'"
mahotas/tests/test_hitmiss.py,13,"b'import mahotas\nimport numpy as np\n\n\ndef slow_hitmiss(A, Bc):\n    res = np.zeros_like(A)\n    for y in range(1,A.shape[0]-1):\n        for x in range(1,A.shape[1]-1):\n            value = 1\n            for dy in (-1,0,1):\n                for dx in (-1,0,1):\n                    ny = y + dy\n                    nx = x + dx\n                    if Bc[dy+1, dx + 1] != 2 and Bc[dy+1, dx+1] != A[ny, nx]:\n                        value = 0\n            res[y,x] = value\n    return res\n\ndef test_hitmiss():\n    A = np.zeros((100,100), np.bool_)\n    Bc = np.array([\n        [0,1,2],\n        [0,1,1],\n        [2,1,1]])\n    mahotas.morph.hitmiss(A,Bc)\n    assert not mahotas.morph.hitmiss(A,Bc).sum()\n\n    A[4:7,4:7] = np.array([\n        [0,1,1],\n        [0,1,1],\n        [0,1,1]])\n    assert mahotas.morph.hitmiss(A,Bc).sum() == 1\n    assert mahotas.morph.hitmiss(A,Bc)[5,5]\n\n\ndef test_hitmiss_against_slow():\n    np.random.seed(222)\n    for i in range(4):\n        A = np.random.rand(100,100)\n        A = (A > .3)\n        Bc = np.array([\n            [0,1,2],\n            [0,1,1],\n            [2,1,1]])\n        W = mahotas.morph.hitmiss(A,Bc)\n        assert np.all(W == slow_hitmiss(A, Bc))\n\n\ndef test_hitmiss_types():\n    f = np.zeros((16,16), np.uint8)\n    f[8:12,8:12] = 1\n    Bc = np.array([[1, 1, 2],[1,1,2],[0,0,0]], dtype=np.int32)\n    assert np.sum(mahotas.morph.hitmiss(f,Bc))\n    Bc = np.array([[1, 1, 2],[1,1,2],[0,0,0]], dtype=np.int64)\n    assert np.sum(mahotas.morph.hitmiss(f,Bc))\n\n'"
mahotas/tests/test_imresize.py,3,"b""import mahotas as mh\nfrom mahotas import imresize\nimport numpy as np\ndef test_imresize():\n    img = np.repeat(np.arange(100), 10).reshape((100,10))\n    assert imresize(img, (1024,104)).shape == (1024,104)\n    assert imresize(img, (10.,10.)).shape == (1000,100)\n    assert imresize(img, .2,).shape == (20,2)\n    assert imresize(img, (10.,2.)).shape == (1000,20)\n\n\ndef test_resize_to():\n    lena  = mh.demos.load('lena')\n    im = mh.resize.resize_rgb_to(lena, [256,256])\n    assert im.shape == (256,256,3)\n    im = im.max(2)\n    im  = mh.resize.resize_to(im, [512,256])\n    assert im.shape == (512,256)\n\ndef test_resize_edge_cases():\n    for start,target in [\n            ((128,128), (64,64)),\n            ((127,128), (64,64)),\n            ((125,128), (64,64)),\n            ((120,128), (64,64)),\n            ((117,128), (64,64)),\n            ((115,128), (61,64)),\n            ((116,129), (59,65)),\n            ]:\n        assert mh.resize_to(np.zeros(start), target).shape == target\n    start = np.zeros((65,31))\n    for t0 in range(7,29):\n        assert mh.resize_to(start, (t0, 17)).shape == (t0, 17)\n"""
mahotas/tests/test_internal.py,43,"b""import numpy as np\nfrom mahotas.internal import _get_output, _get_axis\nfrom mahotas.internal import _normalize_sequence, _verify_is_integer_type, _verify_is_floatingpoint_type, _as_floating_point_array\nfrom mahotas.internal import _check_3\nfrom nose.tools import raises\n\ndef test_get_output():\n    f = np.arange(256).reshape((32,8))\n    output = _get_output(f, None, 'test')\n    assert output.dtype == f.dtype\n    assert output.shape == f.shape\n    out2 = _get_output(f, output, 'test')\n    assert out2 is output\n\ndef test_dtype():\n    f = np.arange(256).reshape((32,8))\n    output = _get_output(f, None, 'test', np.float32)\n    assert output.dtype == np.float32\n\n@raises(ValueError)\ndef test_get_output_bad_shape():\n    f = np.arange(256).reshape((32,8))\n    output = np.zeros((16,16), f.dtype)\n    _get_output(f, output, 'testing')\n\n@raises(ValueError)\ndef test_get_output_non_contiguous():\n    f = np.arange(256).reshape((32,8))\n    output = np.zeros((32,16), f.dtype)\n    output = output[:,::2]\n    assert output.shape == f.shape\n    _get_output(f, output, 'testing')\n\n@raises(ValueError)\ndef test_get_output_explicit_dtype():\n    f = np.arange(256).reshape((32,8))\n    output = np.zeros_like(f)\n    _get_output(f, output, 'testing', bool)\n\n\ndef test_get_axis_good():\n    f = np.zeros((3,4,5,3,2,2,5,3,2,4,1))\n    for i in range(len(f.shape)):\n        assert i == _get_axis(f, i, 'test')\n    for i in range(len(f.shape)):\n        assert len(f.shape)-1-i == _get_axis(f, -1-i, 'test')\n\ndef test_get_axis_off():\n    f = np.zeros((3,4,5,3,2,2,5,3,2,4,1))\n    @raises(ValueError)\n    def index(i):\n        _get_axis(f, i, 'test')\n    yield index, 12\n    yield index, 13\n    yield index, 14\n    yield index, 67\n    yield index, -67\n    yield index, -len(f.shape)-1\n    yield raises\n\n\n\ndef test_normalize():\n    f = np.arange(64)\n    assert len(_normalize_sequence(f, 1, 'test')) == f.ndim\n    f = f.reshape((2,2,2,-1))\n    assert len(_normalize_sequence(f, 1, 'test')) == f.ndim\n    f = f.reshape((2,2,2,1,1,-1))\n    assert len(_normalize_sequence(f, 1, 'test')) == f.ndim\n\ndef test_normalize_sequence():\n    f = np.arange(64)\n    assert len(_normalize_sequence(f, [1], 'test')) == f.ndim\n    f = f.reshape((16,-1))\n    assert _normalize_sequence(f, [2,4], 'test') == [2,4]\n\ndef test_normalize_wrong_size():\n    @raises(ValueError)\n    def check(ns, val):\n        _normalize_sequence(f.reshape(ns), val, 'test')\n    f = np.arange(64)\n\n    check((64,),[1,2])\n    check((64,),[1,1])\n    check((64,),[1,2,3,4])\n    check((4,-1),[1,2,3,4])\n    check((4,-1),[1])\n    check((4,2,-1),[1,2])\n\ndef test_verify_int():\n    @raises(TypeError)\n    def check_fp(arr):\n        _verify_is_integer_type(arr, 'test')\n\n    def check_int(arr):\n        _verify_is_integer_type(arr, 'test')\n\n    yield check_fp, np.arange(1., dtype=np.float)\n    yield check_fp, np.arange(1., dtype=np.float32)\n    yield check_fp, np.arange(1., dtype=np.float64)\n\n    yield check_int, np.arange(1, dtype=np.int32)\n    yield check_int, np.arange(1, dtype=np.uint16)\n    yield check_int, np.arange(1, dtype=np.int64)\n\ndef test_verify_fp():\n    def check_fp(arr):\n        _verify_is_floatingpoint_type(arr, 'test')\n\n    @raises(TypeError)\n    def check_int(arr):\n        _verify_is_floatingpoint_type(arr, 'test')\n\n    yield check_fp, np.arange(1., dtype=np.float)\n    yield check_fp, np.arange(1., dtype=np.float32)\n    yield check_fp, np.arange(1., dtype=np.float64)\n\n    yield check_int, np.arange(1, dtype=np.int32)\n    yield check_int, np.arange(1, dtype=np.uint16)\n    yield check_int, np.arange(1, dtype=np.int64)\n\ndef test_as_floating_point_array():\n    def check_arr(data):\n        array = _as_floating_point_array(data)\n        assert np.issubdtype(array.dtype, np.floating)\n\n    yield check_arr, np.arange(8, dtype=np.int8)\n    yield check_arr, np.arange(8, dtype=np.int16)\n    yield check_arr, np.arange(8, dtype=np.uint32)\n    yield check_arr, np.arange(8, dtype=np.double)\n    yield check_arr, np.arange(8, dtype=np.float32)\n    yield check_arr, [1,2,3]\n    yield check_arr, [[1,2],[2,3],[3,4]]\n    yield check_arr, [[1.,2.],[2.,3.],[3.,4.]]\n\ndef test_check_3():\n    _check_3(np.zeros((14,24,3), np.uint8), 'testing')\n\n@raises(ValueError)\ndef test_check_3_dim4():\n    _check_3(np.zeros((14,24,3,5), np.uint8), 'testing')\n\n@raises(ValueError)\ndef test_check_3_not3():\n    _check_3(np.zeros((14,24,5), np.uint8), 'testing')\n\n@raises(ValueError)\ndef test_check_3_not3_dim4():\n    _check_3(np.zeros((14,24,5,5), np.uint8), 'testing')\n\n\ndef test_make_binary():\n    from mahotas.internal import _make_binary\n    np.random.seed(34)\n    binim = np.random.random_sample((32,64)) > .25\n    assert _make_binary(binim) is binim\n    assert np.all( _make_binary(binim.astype(int)) == binim )\n    assert np.all( _make_binary(binim.astype(int)*4) == binim )\n    assert np.all( _make_binary(binim.astype(float)*3.4) == binim )\n    assert np.all( _make_binary(binim* np.random.random_sample(binim.shape)) == binim )\n\n"""
mahotas/tests/test_interpolate.py,16,"b""from mahotas import interpolate\nimport numpy as np\nfrom nose.tools import raises\n\ndef test_spline_filter1d_smoke():\n    f  = (np.arange(64*64, dtype=np.intc) % 64).reshape((64,64)).astype(np.float64)\n    f2 =interpolate.spline_filter1d(f,2,0)\n    assert f.shape == f2.shape\n\ndef test_spline_filter_smoke():\n    f  = (np.arange(64*64, dtype=np.intc) % 64).reshape((64,64)).astype(np.float64)\n    f2 = interpolate.spline_filter(f,3)\n    assert f.shape == f2.shape\n\ndef test_zoom_ratio():\n    f = np.zeros((128,128))\n    f[32:64,32:64] = 128\n    for z in [.7,.5,.2,.1]:\n        output = interpolate.zoom(f,z)\n        ratio = output.sum()/f.sum()\n        assert np.abs(ratio - z*z) < .1\n\ndef test_zoom_ratio_2():\n    f = np.zeros((128,128))\n    f[32:64,32:64] = 128\n    z0,z1  = .7,.5\n    output = interpolate.zoom(f,[z0,z1])\n    ratio = output.sum()/f.sum()\n    assert np.abs(ratio - z0*z1) < .1\n\ndef test_shift_ratio():\n    f = np.zeros((128,128))\n    f[32:64,32:64] = 128\n    for s in [0,1,2,3]:\n        output = interpolate.shift(f,(s,s))\n        ratio = output.sum()/f.sum()\n        assert np.abs(ratio - 1.) < .01\n\ndef test_order():\n    f = np.arange(16*16).reshape((16,16))\n    @raises(ValueError)\n    def call_f(f, *args):\n        f(*args)\n    yield call_f, interpolate.spline_filter1d, f, -6\n    yield call_f, interpolate.spline_filter1d, f, 6\n    yield call_f, interpolate.spline_filter, f, 0\n\ndef test_complex():\n    f = -np.arange(16.*16).reshape((16,16))\n    f = np.lib.scimath.sqrt(f)\n\n    @raises(TypeError)\n    def call_f(f, *args):\n        f(*args)\n    yield call_f, interpolate.spline_filter1d, f, 3\n    yield call_f, interpolate.spline_filter, f, 3\n\n\n@raises(ValueError)\ndef test_maybe_filter_error():\n    interpolate._maybe_filter(np.array(3), 1, 'testing', False, np.float32)\n\n@raises(ValueError)\ndef test_short_shift():\n    im = np.arange(256).reshape((16,4,-1))\n    interpolate.shift(im, [1,0])\n\ndef test_shift_uint8():\n    im = np.arange(256).reshape((16,-1))\n    im = im.astype(np.uint8)\n    interpolate.shift(im, [0, np.pi/2], order=1)\n"""
mahotas/tests/test_io.py,2,"b""import numpy as np\nfrom mahotas.io import error_imread, error_imsave\nfrom nose.tools import raises\nfrom os import path\nimport mahotas as mh\n\n\nfilename = path.join(\n            path.dirname(__file__),\n            'data',\n            'rgba.png')\n\ndef skip_on(etype):\n    from functools import wraps\n    def skip_on2(test):\n        @wraps(test)\n        def execute(*args, **kwargs):\n            try:\n                test(*args, **kwargs)\n            except Exception as e:\n                if isinstance(e, etype):\n                    from nose import SkipTest\n                    raise SkipTest\n                raise\n        return execute\n    return skip_on2\n\n\n@raises(ImportError)\ndef test_error_imread():\n    error_imread(filename)\n\n@raises(ImportError)\ndef test_error_imsave():\n    error_imsave('/tmp/test_mahotas.png', np.arange(16, dtype=np.uint8).reshape((4,4)))\n\n@skip_on(IOError)\ndef test_as_grey():\n    filename = path.join(\n            path.dirname(__file__),\n            '..',\n            'demos',\n            'data',\n            'luispedro.jpg')\n    im = mh.imread(filename, as_grey=1)\n    assert im.ndim == 2\n\n\n@skip_on(ImportError)\ndef test_pil():\n    import mahotas as mh\n    import numpy as np\n    from mahotas.io import pil\n    lena = mh.demos.load('lena')\n    filename = path.join(\n            path.dirname(__file__),\n            '..',\n            'demos',\n            'data',\n            'lena.jpg')\n    assert np.all( pil.imread(filename) == lena )\n    assert pil.imread(filename, as_grey=1).ndim == 2\n"""
mahotas/tests/test_label.py,7,"b'from mahotas import label\nimport numpy as np\ndef test_label():\n    A = np.zeros((128,128), np.int)\n    L,n = label(A)\n    assert not L.max()\n    assert n == 0\n\n    A[2:5, 2:5] = 34\n    A[10:50, 10:50] = 34\n    L,n = label(A)\n    assert L.max() == 2\n    assert L.max() == n\n    assert np.sum(L > 0) == (40*40 + 3*3)\n    assert np.all( (L > 0) == (A > 0) )\n    assert set(L.ravel()) == set([0,1,2])\n\n\ndef test_all_ones():\n    labeled, nr = label(np.ones((32,32)))\n    assert nr == 1\n    assert np.all(labeled == 1)\n\ndef test_random():\n    np.random.seed(33)\n    A = np.random.rand(128,128) > .8\n    labeled,nr = label(A)\n    assert len(set(labeled.ravel())) == (nr+1)\n    assert labeled.max() == nr\n'"
mahotas/tests/test_labeled.py,88,"b""import numpy as np\nimport mahotas as mh\nimport mahotas.labeled\nfrom nose.tools import raises\n\ndef test_border():\n    labeled = np.zeros((32,32), np.uint8)\n    labeled[8:11] = 1\n    labeled[11:14] = 2\n    labeled[14:17] = 3\n    labeled[10,8:] = 0\n    b12 = mahotas.labeled.border(labeled, 1, 2)\n    YX = np.where(b12)\n    YX = np.array(YX).T\n    b13 = mahotas.labeled.border(labeled, 1, 3)\n\n    assert not np.any(b13)\n    assert np.any(b12)\n    assert (11,0) in YX\n    assert (11,1) in YX\n    assert (12,1) in YX\n    assert (12,9) not in YX\n\n    b13 = mahotas.labeled.border(labeled, 1, 3, always_return=0)\n    assert b13 is None\n\ndef _included(a,b):\n    assert np.sum(a&b) == a.sum()\n\ndef test_borders():\n    labeled = np.zeros((32,32), np.uint8)\n    labeled[8:11] = 1\n    labeled[11:14] = 2\n    labeled[14:17] = 3\n    labeled[10,8:] = 0\n    borders = mahotas.labeled.borders(labeled)\n    _included(mahotas.labeled.border(labeled,1,2), borders)\n    _included(mahotas.labeled.border(labeled,1,23), borders)\n    _included(mahotas.labeled.border(labeled,1,3), borders)\n    _included(mahotas.labeled.border(labeled,2,3), borders)\n\n    union = np.zeros_like(borders)\n    for i in range(4):\n        for j in range(4):\n            if i != j:\n                union |= mahotas.labeled.border(labeled, i, j)\n\n    assert np.all(union == borders)\n\n\ndef slow_labeled_sum(array, labeled):\n    return np.array([\n            np.sum(array * (labeled == i))\n            for i in range(labeled.max()+1)\n        ])\n\ndef slow_labeled_max(array, labeled):\n    return np.array([\n            np.max(array * (labeled == i))\n            for i in range(labeled.max()+1)\n        ])\n\ndef slow_labeled_min(array, labeled):\n    return np.array([\n            np.min(array * (labeled == i))\n            for i in range(labeled.max()+1)\n        ])\n\ndef test_sum_labeled():\n    np.random.seed(334)\n    for i in range(16):\n        f = np.random.random_sample((64,128))\n        labeled = np.zeros(f.shape, dtype=np.intc)\n        labeled += 8 * np.random.random_sample(labeled.shape).astype(np.intc)\n        fast = mahotas.labeled.labeled_sum(f, labeled)\n        slow = slow_labeled_sum(f, labeled)\n        assert np.allclose(fast, slow)\n\ndef test_sum_minlength_arg():\n    for _ in range(8):\n        f = mh.dilate(np.random.random_sample((64,64)) > .8)\n        labeled, n = mh.labeled.label(f)\n        sizes = mh.labeled.labeled_sum(f, labeled)\n        sizes2 = mh.labeled.labeled_sum(f, labeled, minlength=(n+23))\n        assert len(sizes) == (n+1)\n        assert len(sizes2) == (n+23)\n        assert np.all(sizes == sizes2[:n+1])\n\n\ndef test_max_labeled():\n    np.random.seed(334)\n    for i in range(16):\n        f = np.random.random_sample((64,128))\n        labeled = np.zeros(f.shape, dtype=np.intc)\n        labeled += 8 * np.random.random_sample(labeled.shape).astype(np.intc)\n        fast = mahotas.labeled.labeled_max(f, labeled)\n        slow = slow_labeled_max(f, labeled)\n        assert np.allclose(fast, slow)\n\ndef test_min_labeled():\n    np.random.seed(334)\n    for i in range(16):\n        f = np.random.random_sample((64,128))\n        labeled = np.zeros(f.shape, dtype=np.intc)\n        labeled += 8 * np.random.random_sample(labeled.shape).astype(np.intc)\n        fast = mahotas.labeled.labeled_min(f, labeled)\n        slow = slow_labeled_min(f, labeled)\n        assert np.allclose(fast, slow)\n\ndef slow_labeled_size(labeled):\n    return np.array([\n            np.sum(labeled == i)\n            for i in range(labeled.max()+1)\n        ])\n\n\ndef test_size_labeled():\n    np.random.seed(334)\n    for i in range(16):\n        labeled = np.zeros((64,125), dtype=np.intc)\n        labeled += 8 * np.random.random_sample(labeled.shape).astype(np.intc)\n        fast = mahotas.labeled.labeled_size(labeled)\n        slow = slow_labeled_size(labeled)\n        assert np.all(fast == slow)\n\ndef test_remove_bordering():\n    np.random.seed(343)\n    for i in range(4):\n        labeled,_ = mahotas.label(np.random.random_sample((128,64)) > .7)\n        removed = mahotas.labeled.remove_bordering(labeled)\n        assert np.all(removed[0] == 0)\n        assert np.all(removed[-1] == 0)\n        assert np.all(removed[:,0] == 0)\n        assert np.all(removed[:,-1] == 0)\n\n        removed2 = np.zeros_like(removed)\n        mahotas.labeled.remove_bordering(labeled, out=removed2)\n        assert np.all(removed2 == removed)\n\n@raises(ValueError)\ndef test_check_array_labeled_not_same_shape():\n    arr = np.zeros((4,7))\n    lab = np.zeros((4,3), dtype=np.intc)\n    mahotas.labeled._as_labeled(arr, lab, 'testing')\n\ndef _nelems(arr):\n    return len(set(map(int, arr.ravel())))\n\ndef test_relabel():\n    np.random.seed(24)\n    for i in range(8):\n        f = np.random.random_sample((128,128)) > .8\n        labeled, n = mahotas.labeled.label(f)\n        labeled *= ( (labeled % 7) != 4)\n        relabeled,new_n = mahotas.labeled.relabel(labeled)\n        assert relabeled.max() == new_n\n        assert (relabeled.max()+1) == _nelems(labeled)\n        assert np.all( (relabeled > 0) == (labeled > 0) )\n        assert not np.all(labeled == relabeled)\n\n        for a in (8, 23, 35, 13, 213):\n            assert _nelems(labeled[relabeled == a]) == 1\n            assert _nelems(relabeled[labeled == a]) == 1\n        mahotas.labeled.relabel(labeled, inplace=True)\n        assert np.all( labeled == relabeled )\n\n\ndef test_remove_regions():\n    np.random.seed(34)\n    f = np.random.random_sample((128,128)) > .92\n    labeled, n = mahotas.labeled.label(f)\n    regions = [23,55,8]\n    removed = mahotas.labeled.remove_regions(labeled, regions)\n\n    for r in regions:\n        assert not  np.any(removed == r)\n        assert      np.any(labeled == r)\n    mahotas.labeled.remove_regions(labeled, regions, inplace=True)\n    assert np.all(labeled == removed)\n    removed = mahotas.labeled.remove_regions(labeled, [])\n    assert np.all(labeled == removed)\n\ndef test_is_same_labeling():\n    np.random.seed(143)\n    ell = (np.random.random((256,256))*16).astype(np.intc)\n    order = np.arange(1,16)\n    np.random.shuffle(order)\n    order = np.insert(order, 0, 0)\n    assert mh.labeled.is_same_labeling(ell, order[ell])\n    ell2 = order[ell]\n    ell2[ell == 0] = 1\n    \n    assert not mh.labeled.is_same_labeling(ell, ell2)\n\ndef test_perimeter():\n    for r in (40,80,160):\n        disk = mh.disk(r, 2)\n        p = mahotas.labeled.perimeter(disk)\n        p_exact = r*np.pi*2\n        assert .9 < (p/p_exact)  < 1.1\n\n\n\ndef test_remove_regions_where():\n    np.random.seed(34)\n    for _ in range(4):\n        f = np.random.random_sample((128,128)) > .82\n        labeled, n = mh.labeled.label(f)\n        relabeled = mh.labeled.remove_regions_where(labeled, mh.labeled.labeled_size(labeled) < 2)\n        relabeled,_ = mh.labeled.relabel(relabeled)\n        sizes = mh.labeled.labeled_size(relabeled)\n        assert sizes[1:].min() >= 2\n\ndef test_remove_bordering_tuple():\n    import mahotas as mh\n    import numpy as np\n    f = np.zeros((32,32))\n    f[0,0] = 1\n    f[2,4] = 2\n    f.T[4,2] = 3\n    f[8,8] = 4\n    assert np.any(mh.labeled.remove_bordering(f) == 3)\n    assert np.any(mh.labeled.remove_bordering(f, (2,4)) == 4)\n    assert np.any(mh.labeled.remove_bordering(f, (2,4)) == 3)\n    assert not np.any(mh.labeled.remove_bordering(f, (4,2)) == 3)\n\ndef test_as_labeled():\n\n    from mahotas.labeled import _as_labeled\n    arr = np.zeros((64,64))\n    labeled = np.zeros((64,64), dtype=np.intc)\n    funcname = 'testing'\n\n    assert _as_labeled(arr, labeled, funcname, inplace=True) is labeled\n    assert _as_labeled(arr, labeled, funcname) is labeled\n\n    lab2 = _as_labeled(arr, labeled, funcname, inplace=False)\n    assert lab2 is not labeled\n    assert np.all(labeled == lab2)\n\n    assert _as_labeled(arr[::2], labeled[::2], funcname, inplace=False) is not labeled\n    assert _as_labeled(arr[::2], labeled[::2], funcname, inplace=None) is not labeled\n    assert _as_labeled(arr[::2], labeled[::2], funcname) is not labeled\n\n    @raises(ValueError)\n    def t():\n        _as_labeled(arr[::2], labeled[::2], funcname, inplace=True)\n    t()\n\n    @raises(ValueError)\n    def t():\n        _as_labeled(arr[::2], labeled, funcname)\n    t()\n\n\ndef test_labeled_bbox():\n    f = np.random.random((128,128))\n    f = f > .8\n    f,n = mh.label(f)\n\n\n    result = mh.labeled.bbox(f)\n    result_as = mh.labeled.bbox(f, as_slice=True)\n    for _ in range(32):\n        ix = np.random.randint(n+1)\n        assert np.all(result[ix] == mh.bbox(f == ix))\n        assert np.all(result_as[ix] == mh.bbox(f == ix, as_slice=True))\n\ndef test_labeled_bbox_zeros():\n    'Issue #61'\n    def nozeros_test(f):\n        result = mh.labeled.bbox(f)\n        result_as = mh.labeled.bbox(f, as_slice=True)\n        assert not np.all(result == 0)\n        for ix in range(4):\n            assert np.all(result[ix] == mh.bbox(f == ix))\n            assert np.all(result_as[ix] == mh.bbox(f == ix, as_slice=True))\n\n    f = np.array([\n        [2,1,1],\n        [2,2,1],\n        [2,2,3]])\n    f3 = np.array([f])\n    yield nozeros_test, f\n    yield nozeros_test, f3\n\n\ndef test_filter_labeled():\n\n    f = np.random.random(size=(256,256)) > .66\n    labeled, nr = mh.label(f)\n    no_change,no_nr = mh.labeled.filter_labeled(labeled)\n    assert no_nr == nr\n    assert np.all(no_change == labeled)\n\n    no_border, border_nr = mh.labeled.filter_labeled(labeled, remove_bordering=True)\n    assert nr > border_nr\n    assert not np.all(no_border == labeled)\n\n    min_size_3,nr3 = mh.labeled.filter_labeled(labeled, min_size=3)\n    assert nr > nr3\n    assert mh.labeled.labeled_size(min_size_3).min() == 3\n\n    max_size_3,_ = mh.labeled.filter_labeled(labeled, max_size=3)\n    assert mh.labeled.labeled_size(max_size_3)[1:].max() == 3\n\n\n    all_size_3,_ = mh.labeled.filter_labeled(labeled, max_size=3, min_size=3)\n    assert np.all(mh.labeled.labeled_size(all_size_3)[1:] == 3)\n"""
mahotas/tests/test_lbp.py,24,"b'from nose.tools import raises\nimport numpy as np\nfrom mahotas.features import _lbp\nimport mahotas.thresholding\nfrom mahotas.features import lbp\nfrom mahotas.features.lbp import lbp_transform, lbp_names\nfrom mahotas.tests.utils import luispedro_jpg\n\ndef test_shape():\n    A = np.arange(32*32).reshape((32,32))\n    B = np.arange(64*64).reshape((64,64))\n    features0 = lbp(A, 3, 12)\n    features1 = lbp(B, 3, 12)\n    assert features0.shape == features1.shape\n\ndef test_nonzero():\n    A = np.arange(32*32).reshape((32,32))\n    features = lbp(A, 3, 12)\n    features_ignore_zeros = lbp(A * (A> 256), 3, 12, ignore_zeros=True)\n    assert features.sum() > 0\n    assert not np.all(features == features_ignore_zeros)\n\ndef test_histogram():\n    A = np.arange(32*32).reshape((32,32))\n    for r in (2,3,4,5):\n        assert lbp(A,r,8).sum() == A.size\n\ndef test_histogram_large():\n    A = np.arange(32*32).reshape((32,32))\n    for r in (2,3,4,5):\n        assert lbp(A,r,12).sum() == A.size\n\n\ndef test_map():\n    assert len(set(_lbp.map(np.arange(256,dtype=np.uint32), 8))) == 36\n\n\ndef test_positives():\n    np.random.seed(23)\n    f = np.random.random_sample((256,256))\n    lbps = lbp(f, 4, 8)\n    assert len(np.where(lbps == 0)[0]) < 2\n    assert lbps.sum() == f.size\n\ndef test_lbp_transform():\n\n    im = luispedro_jpg().max(2)\n    transformed = lbp_transform(im, 8, 4, preserve_shape=True)\n    assert transformed.shape == im.shape\n    assert transformed.min() >= 0\n    assert transformed.max() < 2**4\n    transformed = lbp_transform(im, 8, 4, preserve_shape=False)\n    assert len(transformed.shape) == 1\n    assert transformed.size == im.size\n\n    np.random.seed(234)\n    im *= np.random.random(im.shape) > .1\n    transformed = lbp_transform(im, 8, 4, preserve_shape=False, ignore_zeros=True)\n    assert len(transformed.shape) == 1\n    assert transformed.size == (im.size - (im==0).sum())\n\n\ndef test_count_binary1s():\n    from mahotas.features.lbp import count_binary1s\n    assert np.all(count_binary1s(np.zeros((23,23), np.uint8)) == np.zeros((23,23)))\n\n    np.random.seed(3499)\n    arr = np.random.randint(45,size=(23,23))\n    c = count_binary1s(arr)\n    assert np.all((c == 0) == (arr == 0))\n    assert c.shape == arr.shape\n    assert np.all(c[arr == 5] == 2)\n    assert np.all(c[arr == 7] == 3)\n    assert np.all(c[arr == 8] == 1)\n    assert np.all(c[arr == 32] == 1)\n\n    assert np.all(count_binary1s([128]) == [1])\n\n@raises(ValueError)\ndef test_lbp_3d():\n    im = np.arange(10*20*3).reshape((10,20,3))\n    lbp_transform(im, 1, 8)\n\ndef test_lbp_names():\n    f = np.random.random(size=(64,72))\n    f *= 255\n    f = f.astype(np.uint8)\n\n    for radius,points in [(8,6),\n            (8,8),(6,6),(8,4),(12,6)]:\n        assert len(lbp(f, radius, points)) == len(lbp_names(radius, points))\n'"
mahotas/tests/test_mahotas.py,0,b'def test_import():\n    import mahotas\n'
mahotas/tests/test_majority.py,10,"b'import numpy as np\nimport mahotas.morph\nfrom scipy import ndimage\nfrom nose.tools import raises\n\ndef slow_majority(img, N):\n    img = (img > 0)\n    r,c = img.shape\n    output = np.zeros_like(img)\n    for y in range(r-N):\n        for x in range(c-N):\n            count = 0\n            for dy in range(N):\n                for dx in range(N):\n                    count += img[y+dy, x+dx]\n            if count >= (N*N)//2:\n                output[y+dy//2,x+dx//2] = 1\n    return output\n\ndef compare_w_slow(R):\n    for N in (3,5,7):\n        assert np.all(mahotas.morph.majority_filter(R, N) == slow_majority(R, N))\n\ndef test_majority():\n\n    np.random.seed(22)\n    R = np.random.rand(64, 64) > .68\n    yield compare_w_slow, R\n\n    R = np.random.rand(32, 64) > .68\n    yield compare_w_slow, R\n\n    R = np.random.rand(64, 64) > .68\n    yield compare_w_slow, R[:32,:]\n\n    R = np.random.rand(64, 64) > .68\n    yield compare_w_slow, R[:23,:]\n\n\n@raises(ValueError)\ndef test_N0():\n    mahotas.morph.majority_filter(np.zeros((20,20), np.bool_), 0)\n\n\ndef test_not_bool():\n    np.random.seed(22)\n    R = np.random.rand(64, 64) > .68\n    yield compare_w_slow, R*24.\n\n'"
mahotas/tests/test_mean_filter.py,5,"b'import numpy as np\nimport mahotas as mh\nfrom mahotas.convolve import mean_filter\ndef test_smoke():\n    f = np.random.random((512,1024))\n    se = np.ones((2,2))\n    ff = mean_filter(f, se)\n    for _ in range(128):\n        a = np.random.randint(1, f.shape[0] - 1)\n        b = np.random.randint(1, f.shape[1] - 1)\n        assert np.allclose(ff[a,b], np.mean(f[a-1:a+1, b-1:b+1]))\n'"
mahotas/tests/test_median_filter.py,11,"b""import numpy as np\nfrom mahotas.convolve import median_filter, rank_filter\nfrom nose.tools import raises\n\ndef test_median_filter():\n    A = np.zeros((128,128), bool)\n    A[3::3,3::3] = 1\n    Am = median_filter(A)\n    assert not Am.any()\n    assert Am.shape == A.shape\n\n\ndef _slow_rank_filter(A,r):\n    B = np.zeros_like(A)\n    for i in range(A.shape[0]):\n        for j in range(A.shape[1]):\n            s0 = max(0, i - 1)\n            s1 = max(0, j - 1)\n            e0 = min(A.shape[0], i + 2)\n            e1 = min(A.shape[1], j + 2)\n            pixels = list(A[s0:e0, s1:e1].ravel())\n            pixels.extend([0] * (9-len(pixels)))\n            pixels.sort()\n            B[i,j] = pixels[r]\n    return B\n\ndef test_rank_filter():\n    np.random.seed(22)\n    A = np.random.randint(0, 256, (32,32))\n    Bc = np.ones((3,3))\n    for r in range(9):\n        B1 = rank_filter(A, Bc, r, mode='constant')\n        B2 = _slow_rank_filter(A,r)\n        assert np.all(B1 == B2)\n\ndef test_uint8():\n    # This used to raise an exception in 0.7.1\n    f = np.arange(64*4).reshape((16,-1))\n    median_filter(f.astype(np.uint8), np.ones((5,5)))\n\n@raises(ValueError)\ndef test_mismatched_ndim():\n    a = np.zeros((8,8))\n    a[:2] = 2\n    a = np.array([a])\n    median_filter(a > 0, np.ones((3,3)))\n"""
mahotas/tests/test_moments.py,13,"b'import numpy as np\nimport mahotas as mh\nfrom mahotas.features.moments import moments\n\ndef _slow(A, p0, p1, cm):\n    c0,c1 = cm\n    I,J = np.meshgrid(np.arange(A.shape[0],dtype=float), np.arange(A.shape[1], dtype=float))\n    I -= c0\n    J -= c1\n    I **= p0\n    J **= p1\n    return (I.T * J.T * A).sum()\n\ndef test_smoke():\n    assert moments(np.zeros((100,23)), 2, 2) == 0.0\n    assert moments(np.ones((100,23)), 2, 2) != 0.0\n    assert moments(np.ones((100,23)), 0, 0) == 100*23\n    assert moments(np.ones((100,23)), 2, 2) != moments(np.ones((100,23)), 2, 2, cm=(50,12))\n\ndef test_against_slow():\n    def perform(p0, p1, cm, A):\n        assert moments(A, p0, p1, cm) == _slow(A, p0,p1,cm)\n\n    A = (np.arange(2048) % 14).reshape((32, -1))\n    yield perform, 2, 2, (22, 22), A\n    yield perform, 2, 2, (20, 22), A\n    yield perform, 2, 2, (0, 0), A\n    yield perform, 1, 2, (0, 0), A\n    yield perform, 1, 0, (0, 0), A\n\n\ndef test_normalize():\n    A,B = np.meshgrid(np.arange(128),np.arange(128))\n    for p0,p1 in [(1,1), (1,2), (2,1), (2,2)]:\n        def f(im):\n            return moments(im, p0, p1, cm=mh.center_of_mass(im), normalize=1)\n        im = A+B\n        fs = [f(im), f(im[::2]), f(im[:,::2]), f(im[::2, ::2])]\n        assert np.var(fs) < np.mean(np.abs(fs))/10\n\ndef test_moments01():\n    im = np.zeros((16,16))\n    im += np.arange(16)\n    im -= im.mean()\n    assert np.abs(mh.moments(im , 1, 0)) < 0.1\n\ndef test_expression():\n    import mahotas as mh\n    import numpy as np\n    im = (np.zeros((12,16)) + np.arange(16))\n    im -= im.mean()\n    c0,c1 = 4,7\n    p0,p1 = 2, 3\n    for p0,p1 in [(0,1),\n                    (1,0),\n                    (1,2),\n                    (3,2),\n                    (2,0)]:\n        sum_r = sum((im[i,j] * (i - c0)**p0 * (j - c1)**p1) for i in range(im.shape[0]) for j in range(im.shape[1]))\n        mm_r = mh.moments(im , p0, p1, cm=(c0,c1))\n        assert np.abs(mm_r - sum_r) < 1.\n'"
mahotas/tests/test_morph.py,67,"b""import mahotas as mh\nimport numpy as np\nfrom mahotas.morph import get_structuring_elem, subm, tophat_open, tophat_close\nfrom nose.tools import raises\n\n\ndef test_get_structuring_elem():\n    A = np.zeros((10,10), np.bool)\n    Bc = np.ones((4,4), dtype=np.bool)\n    Bc[0,2] = 0\n\n    assert np.all(get_structuring_elem(A, None) == [[0,1,0],[1,1,1],[0,1,0]])\n    assert np.all(get_structuring_elem(A, 4) == [[0,1,0],[1,1,1],[0,1,0]])\n    assert np.all(get_structuring_elem(A, 4) == get_structuring_elem(A, 1))\n    assert np.all(get_structuring_elem(A, 8) == get_structuring_elem(A, 2))\n    assert np.all(get_structuring_elem(A, 8) == np.ones((3,3), dtype=np.bool))\n    assert np.all(get_structuring_elem(A, Bc) == Bc)\n    assert np.all(get_structuring_elem(A, Bc.T) == Bc.T)\n    assert get_structuring_elem(A, Bc.T).flags['C_CONTIGUOUS']\n    assert np.all(get_structuring_elem(A, Bc.astype(np.float).T).flags['C_CONTIGUOUS'])\n    assert np.all(get_structuring_elem(A, Bc.astype(np.float).T) == Bc.T)\n\n    @raises(ValueError)\n    def bad_dims():\n        Bc = np.ones((3,3,3), dtype=np.bool)\n        get_structuring_elem(A, Bc)\n\n    bad_dims()\n\n\ndef test_open():\n    from mahotas.morph import open\n    np.random.seed(123)\n    A = np.random.random_sample((16,16)) > .345\n    assert open(A).shape == (16,16)\n\ndef test_close():\n    from mahotas.morph import close\n    np.random.seed(123)\n    A = np.random.random_sample((16,16)) > .345\n    assert close(A).shape == (16,16)\n\n\ndef slow_reg(A, agg):\n    def get(i, j):\n        vals = []\n        def try_this(i,j):\n            if 0 <= i < A.shape[0] and \\\n                0 <= j < A.shape[1]:\n                    vals.append( A[i,j] )\n        try_this(i,j)\n        try_this(i-1,j)\n        try_this(i+1,j)\n        try_this(i,j-1)\n        try_this(i,j+1)\n        return vals\n\n\n    res = np.zeros(A.shape, bool)\n    for i in range(A.shape[0]):\n        for j in range(A.shape[0]):\n            res[i,j] = (A[i,j] == agg(get(i,j)))\n    return res\n\ndef test_locmin_max():\n    from mahotas.morph import locmax, locmin\n    np.random.seed(123)\n    for i in range(8):\n        A = np.random.random_sample((64,64))\n        A *= 255\n        if (i % 2) == 0:\n            A = A.astype(np.uint8)\n        fast = locmax(A)\n        assert np.all(fast == slow_reg(A, max))\n\n        fast = locmin(A)\n        assert np.all(fast == slow_reg(A, min))\n\n\ndef test_regmax_min():\n    from mahotas.morph import locmax, locmin, regmax, regmin\n    np.random.seed(123)\n    for i in range(8):\n        A = np.random.random_sample((64,64))\n        A *= 255\n        if (i % 2) == 1:\n            A = A.astype(np.uint8)\n\n        loc = locmax(A)\n        reg = regmax(A)\n        assert not np.any(reg & ~loc)\n\n        loc = locmin(A)\n        reg = regmin(A)\n        assert not np.any(reg & ~loc)\n\ndef test_dilate_crash():\n    # There was a major bug in dilate, that caused this to crash\n    from mahotas.morph import dilate\n    large = np.random.random_sample((512,512)) > .5\n    small = large[128:256,128:256]\n    dilate(small)\n\ndef slow_subm_uint8(a, b):\n    a = a.astype(np.int64)\n    b = b.astype(np.int64)\n    c = a - b\n    return np.clip(c, 0, 255).astype(np.uint8)\n\ndef slow_subm_uint16(a, b):\n    a = a.astype(np.int64)\n    b = b.astype(np.int64)\n    c = a - b\n    return np.clip(c, 0, 2**16-1).astype(np.uint16)\n\ndef slow_subm_int16(a, b):\n    a = a.astype(np.int64)\n    b = b.astype(np.int64)\n    c = a - b\n    return np.clip(c, -2**15, 2**15-1).astype(np.int16)\n\ndef test_subm():\n    np.random.seed(34)\n    for j in range(8):\n        s = (128, 256)\n        a = np.random.randint(0,255, size=s)\n        b = np.random.randint(0,255, size=s)\n        a = a.astype(np.uint8)\n        b = b.astype(np.uint8)\n        assert np.all(slow_subm_uint8(a,b) == subm(a,b))\n\n        a = 257*np.random.randint(0,255, size=s)\n        b = 257*np.random.randint(0,255, size=s)\n        a = a.astype(np.uint16)\n        b = b.astype(np.uint16)\n        assert np.all(slow_subm_uint16(a,b) == subm(a,b))\n\n        a2 = 257*np.random.randint(0,255, size=s)\n        b2 = 257*np.random.randint(0,255, size=s)\n        a = a.astype(np.int16)\n        b = b.astype(np.int16)\n        a -= a2\n        b -= b2\n        assert np.all(slow_subm_int16(a,b) == subm(a,b))\n\n\n\ndef test_subm_out():\n    np.random.seed(32)\n    for j in range(8):\n        s = (128, 256)\n        a = np.random.randint(0,255, size=s)\n        b = np.random.randint(0,255, size=s)\n\n        c = subm(a,b)\n        assert c is not a\n        assert c is not b\n        assert not np.all(c == a)\n\n\n        c = subm(a,b, out=a)\n        assert c is  a\n        assert c is not b\n        assert np.all(c == a)\n\ndef test_tophat():\n    np.random.seed(32)\n    for j in range(8):\n        s = (128, 256)\n        f = np.random.randint(0,255, size=s)\n        f = f.astype(np.uint8)\n        g = tophat_close(f)\n        assert f.shape == g.shape\n\n        g = tophat_open(f)\n        assert f.shape == g.shape\n\n\ndef test_circle_se():\n    from mahotas.morph import circle_se\n    for r in (4,5):\n        c = circle_se(r)\n        assert len(c) == (2*r + 1)\n        assert len(c) == len(c.T)\n        assert not c.all()\n        assert c.any()\n\n    @raises(ValueError)\n    def circle_1():\n        circle_se(-1)\n    circle_1()\n\ndef test_distance_multi():\n    import mahotas._morph\n    np.random.seed(20)\n    binim = np.random.random((12,18)) > .1\n    f = (binim * 0 + 26 *27).astype(float)\n    Bc = np.ones((3,3), bool)\n    mahotas._morph.distance_multi(f, binim, Bc)\n    f2 = mahotas.distance(binim)\n    assert np.all(f == f2)\n\n\n\ndef test_disk():\n    from mahotas.morph import disk\n    D2 = disk(2)\n    assert D2.shape[0] == D2.shape[1]\n    assert D2.shape == (5,5)\n    assert not D2[0,0]\n    assert len(D2.shape) == 2\n    D3 = disk(2,3)\n\n    assert np.all(D3[2] == D2)\n\n    D3 = disk(4,3)\n    assert len(D3.shape) == 3\n    assert D3.shape[0] == D3.shape[1]\n    assert D3.shape[0] == D3.shape[2]\n\n    # Simple regression\n    D = disk(32, 2)\n    assert D[32,2]\n\n    @raises(ValueError)\n    def test_negative_dim(dim):\n        disk(3, dim)\n\n    test_negative_dim(-2)\n    test_negative_dim(-1)\n    test_negative_dim(0)\n\n\n@raises(ValueError)\ndef test_close_holes_3d():\n    'Close holes should raise exception with 3D inputs'\n    f = np.random.rand(100,100,3) > .9\n    mh.close_holes(f)\n"""
mahotas/tests/test_polygon.py,14,"b""import numpy as np\nimport mahotas as mh\nimport mahotas.polygon\nfrom mahotas.polygon import fill_polygon, fill_convexhull\nfrom nose.tools import raises\n\ndef test_polygon():\n    polygon = [(10,10), (10,20), (20,20)]\n    canvas = np.zeros((40,40), np.bool)\n    fill_polygon(polygon, canvas)\n    assert canvas.sum() == (10*10+10)/2\n    canvas2 = canvas.copy()\n    fill_polygon([], canvas2)\n    assert np.all(canvas == canvas2)\n\n\ndef test_convex():\n    polygon = [(100,232), (233,222), (234,23), (555,355), (343,345), (1000,800)]\n    canvas = np.zeros((1024, 1024), np.bool)\n    mahotas.polygon.fill_polygon(polygon, canvas)\n    canvas2 = mahotas.polygon.fill_convexhull(canvas)\n    # The overlap isn't perfect. There is a slight sliver. Fixing it is not\n    # worth the trouble for me (LPC), but I'd take a patch\n    assert (canvas & ~canvas2).sum() < 1024\n\ndef test_convex3():\n    f = np.array([\n        [False, False, False, False],\n        [False,  True,  True, False],\n        [False,  True, False, False],\n        [False, False, False, False]], dtype=bool)\n    assert np.all(fill_convexhull(f) == f)\n\ndef test_fill3():\n    canvas = np.zeros((4,4), bool)\n    # This polygon also has a horizontal and a vertical edge\n    polygon = [(1, 1), (1, 2), (2, 1)]\n    mahotas.polygon.fill_polygon(polygon, canvas)\n    assert canvas.sum()\n\ndef test_line():\n    canvas = np.zeros((32,32), int)\n    polygon = [(8,8), (8,16),(16,16),(16,8), (8,8)]\n    for p0,p1 in zip(polygon[:-1], polygon[1:]):\n        mahotas.polygon.line(p0,p1, canvas, color=2)\n    assert set(canvas.ravel()) == set([0,2])\n    assert canvas.sum() == 2*(8*4) # 8*4 is perim size, 2 is value\n\ndef test_line_non_square():\n    A = np.zeros((128, 64))\n    mahotas.polygon.line((0,0),(127,63), A)\n    assert A.sum()\n\n\n\ndef test_fill_line():\n    # This is a regression test\n    # https://github.com/luispedro/mahotas/issues/3\n    canvas = np.zeros((50,30))\n    poly = [( 0,10),\n            (10, 0),\n            (40,20),\n            ( 0,10)]\n    fill_polygon(poly, canvas)\n    assert np.all(canvas[10,1:10])\n\n@raises(ValueError)\ndef test_convex_in_3d():\n    canvas = np.zeros((12,8,8))\n    canvas[3,4,2] = 1\n    canvas[5,4,2] = 1\n    canvas[3,6,2] = 1\n    mahotas.polygon.fill_convexhull(canvas)\n\n\ndef test_border():\n    canvas = np.zeros((32,32))\n    polygon = np.array([(0,0),(0,32),(32,0)])\n    fill_polygon(polygon, canvas)\n    assert not np.all(canvas)\n"""
mahotas/tests/test_segmentation.py,0,"b'import mahotas.segmentation\nimport numpy as np\nimport mahotas\nfrom .utils import luispedro_jpg\n\ndef test_slic():\n    f = luispedro_jpg()\n    segmented, n = mahotas.segmentation.slic(f)\n    assert segmented.shape == (f.shape[0], f.shape[1])\n    assert segmented.max() == n\n    segmented2, n2 = mahotas.segmentation.slic(f, 128)\n    assert n2 < n\n'"
mahotas/tests/test_stretch.py,27,"b""from mahotas.stretch import stretch\nimport mahotas\nimport mahotas as mh\nfrom nose.tools import raises\nimport numpy as np\n\ndef test_stretch():\n    np.random.seed(2323)\n    A = np.random.randint(12, 121, size=(100,100))\n    A = stretch(A, 255)\n    assert A.max() > 250\n    assert A.min() == 0\n    A = stretch(A,20)\n    assert A.max() <= 20\n    A = stretch(A, 10, 20)\n    assert A.min() >= 10\n    A = stretch(A * 0, 10, 20)\n    assert A.min() >= 10\n\ndef test_neg_numbers():\n    A = np.arange(-10,10)\n    scaled = stretch(A, 255)\n    assert scaled.shape == A.shape\n    assert scaled.min() <= 1\n    assert scaled.max() >= 254\n\n\n\ndef test_as_rgb():\n    np.random.seed(2323)\n    r = np.random.randint(12, 121, size=(8,8))\n    g = np.random.randint(12, 121, size=(8,8))\n    b = np.random.randint(12, 121, size=(8,8))\n    assert mahotas.as_rgb(r,g,b).max() >= 254\n    assert mahotas.as_rgb(r,None,b).shape == (8,8,3)\n    assert mahotas.as_rgb(r,None,b)[:,:,1].sum() == 0\n\n\n@raises(ValueError)\ndef test_as_rgb_Nones():\n    mahotas.as_rgb(None,None,None)\n\n@raises(ValueError)\ndef test_as_rgb_shape_mismatch():\n    np.random.seed(2323)\n    r = np.random.randint(12, 121, size=(8,8))\n    g = np.random.randint(12, 121, size=(8,8))\n    b = np.random.randint(12, 121, size=(8,6))\n    mahotas.as_rgb(r,g,b)\n\n\n\ndef test_as_rgb_integer():\n    int_rgb = mh.as_rgb(1,2,np.zeros((8,6)))\n    assert int_rgb.dtype == np.uint8\n    assert int_rgb.shape == (8,6,3)\n    assert np.all( int_rgb[0,0] == (1,2,0) )\n    assert np.all( int_rgb[-1,3] == (1,2,0) )\n    assert np.all( int_rgb[-2,4] == (1,2,0) )\n\ndef test_stretch_rgb():\n    r = np.arange(256).reshape((32,-1))\n    g = 255-r\n    b = r/2\n    s = mh.stretch(np.dstack([r,g,b]))\n    s_rgb = mh.stretch_rgb(np.dstack([r,g,b]))\n    assert not np.all(s == s_rgb)\n    assert np.all(s[:,:,0] == s_rgb[:,:,0])\n    assert np.all(mh.stretch(b) == mh.stretch_rgb(b))\n\n@raises(ValueError)\ndef test_stretch_rgb4():\n    mh.stretch_rgb(np.zeros((8,8,3,2)))\n\n\ndef test_overlay():\n    im = mh.demos.load('luispedro', as_grey=1)\n    im = mh.stretch(im)\n    assert np.all(mh.overlay(im).max(2) == im)\n    edges = mh.sobel(im)\n\n    im3 = mh.overlay(im, green=edges)\n    assert np.all(im3[:,:,0] == im)\n    assert np.all(im3[:,:,2] == im)\n    assert np.all(im3[:,:,1] >= im )\n"""
mahotas/tests/test_surf.py,43,"b'import numpy as np\nimport mahotas as mh\nimport mahotas.features.surf as surf\nfrom mahotas.features import _surf\nfrom .utils import luispedro_jpg\nfrom nose.tools import raises\n\ndef test_integral():\n    f = np.arange(8*16).reshape((8,16)) % 8\n    fi = surf.integral(f.copy())\n    assert fi[-1,-1] == f.sum()\n    for y,x in np.indices(f.shape).reshape((2,-1)).T:\n        assert fi[y,x] == f[:y+1,:x+1].sum()\n\ndef test_integral2():\n    f = np.arange(80*16).reshape((80,16)) % 7\n    fi = surf.integral(f.copy())\n    assert fi[-1,-1] == f.sum()\n    for y,x in np.indices(f.shape).reshape((2,-1)).T:\n        assert fi[y,x] == f[:y+1,:x+1].sum()\n\n\ndef test_sum_rect():\n    f = np.arange(800*160).reshape((800,160)) % 7\n    fi = surf.integral(f.copy())\n\n    np.random.seed(22)\n    for i in range(100):\n        y0 = np.random.randint(1,780)\n        y1 = np.random.randint(y0+1,799)\n        x0 = np.random.randint(1,150)\n        x1 = np.random.randint(x0+1, 159)\n        assert _surf.sum_rect(fi, y0, x0, y1, x1) == f[y0:y1, x0:x1].sum()\n\ndef test_sum_rect_edge():\n    # regression\n    # https://github.com/luispedro/mahotas/issues/58\n    f = np.arange(80*60).reshape((80,60)) % 7\n    fi = surf.integral(f.copy())\n    _surf.sum_rect(fi, 0, 0, 81, 61)\n\ndef test_surf_guassians():\n    f = np.zeros((1024,1024))\n    Y,X = np.indices(f.shape)\n    Y -= 768\n    X -= 768\n    f += 120*np.exp(-Y**2/2048.-X**2/480.)\n    Y += 512\n    X += 512\n    f += 120*np.exp(-Y**2/2048.-X**2/480.)\n    spoints = surf.surf(f, 1, 24, 2)\n\n    YX = np.array([spoints[:,0],spoints[:,1]]).T\n    is_256 = False\n    is_768 = False\n    for y,x in YX:\n        if (np.abs(y-256) < 8 and np.abs(x-256) < 8): is_256 = True\n        if (np.abs(y-768) < 8 and np.abs(x-768) < 8): is_768 = True\n    assert is_256\n    assert is_768\n\ndef test_interest_points_descriptors():\n    np.random.seed(22)\n    f = np.random.rand(256,256)*230\n    f = f.astype(np.uint8)\n    fi = surf.integral(f)\n    spoints = surf.surf(f, 6, 24, 1)\n    for arr, is_integral in zip([f,fi], [False, True]):\n        points = surf.interest_points(arr, 6, 24, 1, is_integral=is_integral)\n        points = list(points)\n        points.sort(key=(lambda p: -p[3]))\n        points = np.array(points, dtype=np.float64)\n        descs = surf.descriptors(arr, points, is_integral)\n        assert np.all(descs[:len(spoints)] == spoints)\n\n\ndef test_show_surf():\n    np.random.seed(22)\n    f = np.random.rand(256,256)*230\n    f = f.astype(np.uint8)\n    spoints = surf.surf(f, 6, 24, 1)\n    f2 = surf.show_surf(f, spoints)\n    assert f2.shape == (f.shape + (3,))\n\n\ndef test_interest_points_descriptor_only():\n    np.random.seed(22)\n    f = np.random.rand(256,256)*230\n    f = f.astype(np.uint8)\n    full = surf.surf(f, 6, 24, 1)\n    only = surf.surf(f, 6, 24, 1, descriptor_only=True)\n    assert full.size > only.size\n\ndef test_descriptors_descriptor_only():\n    np.random.seed(22)\n    f = np.random.rand(256,256)*230\n    f = f.astype(np.uint8)\n    points = surf.interest_points(f, 6, 24, 1)\n    full = surf.descriptors(f, points)\n    only = surf.descriptors(f, points, descriptor_only=True)\n    assert full.size > only.size\n\n@raises(ValueError)\ndef test_3d_image():\n    surf.surf(np.arange(8*8*16).reshape((16,8,8)), 6, 24, 1)\n\n@raises(TypeError)\ndef test_integral_intested_points():\n    np.random.seed(22)\n    f = np.random.rand(16,16)*230\n    f = f.astype(np.uint8)\n    f = surf.integral(f)\n    surf.interest_points(f.astype(np.int32), is_integral=True)\n\n\n@raises(TypeError)\ndef test_integral_descriptors():\n    np.random.seed(22)\n    f = np.random.rand(16,16)*230\n    f = f.astype(np.uint8)\n    f = surf.integral(f)\n    points = surf.interest_points(f, is_integral=True)\n    surf.descriptors(f.astype(np.int32), points, is_integral=True)\n\ndef test_dense():\n    f = np.arange(280*360).reshape((280,360)) % 25\n    d16 = surf.dense(f, 16)\n    d16_s = surf.dense(f, 16, 3.)\n    d32 = surf.dense(f, 32)\n\n    assert len(d16) > len(d32)\n    assert d16.shape[1] == d32.shape[1]\n    assert d16.shape[1] == d16_s.shape[1]\n\n\ndef test_dense_scale():\n    im = luispedro_jpg(True)\n    surf.dense(im, spacing=32)\n    s5 = surf.dense(im, spacing=32, scale=5)\n    s51 = surf.dense(im, spacing=32, scale=5.1)\n    assert not np.all(s5 == s51)\n'"
mahotas/tests/test_surf_regression.py,3,"b""import mahotas\nimport numpy as np\nfrom mahotas.features.surf import surf\nfrom os import path\n\n# Originally, the file `determinant_zero.png` contained a PNG which FreeImage\n# was opening incorrectly (it returned the palette instead of mapping through\n# to the colours).\n#\n# If correctly mapped, the image was actually full of zeros (i.e., all colours\n# in the palette were (0,0,0)!)\n#\n# Therefore, there are actually two tests here:\n#     with a zero image\n#     with the values of the palette in determinant_zero.png\n#\n# The file `determinant_zero.png` now contains what was originally the palette\n# values.\n\ndef test_determinant_zero():\n    img = mahotas.imread(path.join(\n        path.abspath(path.dirname(__file__)),\n                    'data',\n                    'determinant_zero.png'))\n    points = surf(img, threshold=.0)\n    assert type(points) == np.ndarray\n\ndef test_determinant_zero2():\n    img = np.zeros((128,28), np.uint8)\n    points = surf(img, threshold=.0)\n    assert type(points) == np.ndarray\n\n"""
mahotas/tests/test_tas.py,19,"b'import numpy as np\nfrom mahotas.features import tas, pftas\nfrom nose.tools import raises\n\ndef test_tas():\n    np.random.seed(22)\n    f = np.random.rand(1024, 1024)\n    f = (f * 255).astype(np.uint8)\n    assert np.abs(tas(f).sum()-6) < 0.0001\n    assert np.abs(pftas(f).sum()-6) < 0.0001\n\ndef test_tas3d():\n    np.random.seed(22)\n    f = np.random.rand(512, 512, 8)\n    f = (f * 255).astype(np.uint8)\n    assert np.abs(tas(f).sum()-6) < 0.0001\n    assert np.abs(pftas(f).sum()-6) < 0.0001\n\ndef test_regression():\n    np.random.seed(220)\n    img = np.random.random_sample((1024,1024))\n    img *= 255\n    img = img.astype(np.uint8)\n    features = pftas(img)\n    assert not np.any(features == 0.)\n\ndef test_zero_image():\n    features = pftas(np.zeros((64,64), np.uint8))\n    assert not np.any(np.isnan(features))\n\n@raises(ValueError)\ndef test_4d():\n    np.random.seed(22)\n    f = np.random.rand(16,16,16,16)\n    f = (f * 255).astype(np.uint8)\n    tas(f)\n'"
mahotas/tests/test_template_match.py,5,"b'import numpy as np\nimport mahotas.convolve\nfrom mahotas.convolve import template_match\n\ndef test_template_match():\n    np.random.seed(33)\n    A = 255*np.random.random((1024, 512))\n    t = A[8:12,8:12]+1\n    m = template_match(A, t)\n\n    assert m[10,10] == 16\n    # I had tried testing over the whole image, but that took too long.\n    for i in range(100):\n        y = np.random.randint(m.shape[0]-4)\n        x = np.random.randint(m.shape[1]-4)\n        assert np.allclose(m[y+2,x+2], np.sum( (A[y:y+4, x:x+4] - t) ** 2))\n'"
mahotas/tests/test_texture.py,68,"b'import numpy as np\nfrom mahotas.features import texture\nimport mahotas as mh\nimport mahotas.features._texture\nfrom nose.tools import raises\n\ndef test__cooccurence():\n    cooccurence = mahotas.features._texture.cooccurence\n    f = np.array([\n          [0,1,1,1],\n          [0,0,1,1],\n          [2,2,2,2],\n        ])\n    Bc = np.zeros((3,3), f.dtype)\n    Bc[1,2] = 1\n    res = np.zeros((5,5), np.int32)\n    cooccurence(f, res, Bc, 0)\n    assert res[0,0] == 1\n    assert res[0,1] == 2\n    assert res[1,0] == 0\n    assert res[1,1] == 3\n    assert res[2,2] == 3\n    assert not np.any(res[2,:2])\n    assert not np.any(res[:2,2])\n    res[:3,:3] = 0\n    assert not np.any(res)\n\n    res = np.zeros((5,5), np.int32)\n    Bc = np.zeros((3,3), f.dtype)\n    Bc[2,2] = 1\n    cooccurence(f, res, Bc, 0)\n    assert res[0,0] == 1\n    assert res[0,1] == 0\n    assert res[0,2] == 2\n    assert res[1,0] == 0\n    assert res[1,1] == 2\n    assert res[1,2] == 1\n    res[:3,:3] = 0\n    assert not np.any(res)\n\ndef test_cooccurence_errors():\n    f2 = np.zeros((6,6), np.uint8)\n    f3 = np.zeros((6,6,6), np.uint8)\n    f4 = np.zeros((6,6,6,6), np.uint8)\n    @raises(ValueError)\n    def c_1():\n        texture.cooccurence(f2, -2, distance=1)\n    yield c_1\n\n    @raises(ValueError)\n    def c_1():\n        texture.cooccurence(f3, -2, distance=1)\n    yield c_1\n\n    @raises(ValueError)\n    def c_2_10():\n        texture.cooccurence(f2, 10, distance=1)\n    yield c_2_10\n\n    @raises(ValueError)\n    def c_3_17():\n        texture.cooccurence(f3, 17, distance=1)\n    yield c_3_17\n\n    @raises(ValueError)\n    def c_4_1():\n        texture.cooccurence(f4, 1, distance=1)\n    yield c_4_1\n\n\n\ndef brute_force(f, dy, dx):\n    res = np.zeros((f.max()+1, f.max() + 1), np.double)\n    for y in range(f.shape[0]):\n        for x in range(f.shape[1]):\n            if 0 <= y + dy < f.shape[0] and \\\n                0 <= x + dx < f.shape[1]:\n                res[f[y,x], f[y +dy,x+dx]] += 1\n    return res\n\ndef brute_force3(f, dy, dx, dz):\n    res = np.zeros((f.max()+1, f.max() + 1), np.double)\n    for y in range(f.shape[0]):\n        for x in range(f.shape[1]):\n            for z in range(f.shape[2]):\n                if 0 <= y + dy < f.shape[0] and \\\n                    0 <= x + dx < f.shape[1] and \\\n                    0 <= z + dz < f.shape[2]:\n                    res[f[y,x,z], f[y +dy,x+dx,z+dz]] += 1\n    return res\n\n\ndef brute_force_sym(f, dy, dx):\n    cmat = brute_force(f, dy, dx)\n    return (cmat + cmat.T)\n\ndef test_cooccurence():\n    np.random.seed(222)\n    f = np.random.rand(32, 32)\n    f = (f * 255).astype(np.int32)\n\n    assert np.all(texture.cooccurence(f, 0, distance=1, symmetric=False) == brute_force(f, 0, 1))\n    assert np.all(texture.cooccurence(f, 1, distance=1, symmetric=False) == brute_force(f, 1, 1))\n    assert np.all(texture.cooccurence(f, 2, distance=1, symmetric=False) == brute_force(f, 1, 0))\n    assert np.all(texture.cooccurence(f, 3, distance=1, symmetric=False) == brute_force(f, 1, -1))\n\n    assert np.all(texture.cooccurence(f, 0, distance=1, symmetric=1) == brute_force_sym(f, 0, 1))\n    assert np.all(texture.cooccurence(f, 1, distance=1, symmetric=1) == brute_force_sym(f, 1, 1))\n    assert np.all(texture.cooccurence(f, 2, distance=1, symmetric=1) == brute_force_sym(f, 1, 0))\n    assert np.all(texture.cooccurence(f, 3, distance=1, symmetric=1) == brute_force_sym(f, 1, -1))\n\ndef test_cooccurence3():\n    np.random.seed(222)\n    f = np.random.rand(32, 32, 8)\n    f = (f * 255).astype(np.int32)\n\n    for di, (d0,d1,d2) in enumerate(texture._3d_deltas):\n        assert np.all(texture.cooccurence(f, di, distance=1, symmetric=False) == brute_force3(f, d0, d1, d2))\n\ndef test_haralick():\n    np.random.seed(123)\n    f = np.random.rand(1024, 1024)\n    f = (f * 255).astype(np.int32)\n    feats = texture.haralick(f)\n    assert not np.any(np.isnan(feats))\n\ndef test_haralick3():\n    np.random.seed(123)\n    f = np.random.rand(34, 12, 8)\n    f = (f * 255).astype(np.int32)\n    feats = texture.haralick(f)\n    assert not np.any(np.isnan(feats))\n\n\ndef test_single_point():\n    A = np.zeros((5,5), np.uint8)\n    A[2,2]=12\n    assert not np.any(np.isnan(texture.cooccurence(A, 0, distance=1)))\n\n@raises(TypeError)\ndef test_float_cooccurence():\n    A = np.zeros((5,5), np.float32)\n    A[2,2]=12\n    texture.cooccurence(A, 0, distance=1)\n\n@raises(TypeError)\ndef test_float_haralick():\n    A = np.zeros((5,5), np.float32)\n    A[2,2]=12\n    texture.haralick(A)\n\ndef test_haralick3d():\n    np.random.seed(22)\n    img = mahotas.stretch(255*np.random.rand(20,20,4))\n    features = texture.haralick(img)\n    assert features.shape == (13,13)\n\n    features = texture.haralick(img[:,:,0])\n    assert features.shape == (4,13)\n\n    features = texture.haralick(img.max(0), ignore_zeros=True, preserve_haralick_bug=True, compute_14th_feature=True)\n    assert features.shape == (4,14)\n\n\ndef test_zeros():\n    zeros = np.zeros((64,64), np.uint8)\n    feats = texture.haralick(zeros)\n    assert not np.any(np.isnan(feats))\n\n@raises(ValueError)\ndef test_ignore_zeros_raise():\n    zeros = np.zeros((64,64), np.uint8)\n    texture.haralick(zeros, ignore_zeros=True)\n\n@raises(ValueError)\ndef test_4d_image():\n    texture.haralick(np.arange(4**5).reshape((4,4,4,4,4)))\n\n\ndef rand_haralick():\n    f = 255*np.random.random((128,128))\n    f = f.astype(np.uint8)\n    f = mh.features.haralick(f)\n    return f.mean(0)\ndef test_feature_non_zero():\n    np.random.seed(23)\n    assert any(np.all(rand_haralick() != 0) for i in range(12))\n\ndef test_feature_not_same():\n    np.random.seed(26)\n\n    multiple = np.array([rand_haralick() for i in range(8)])\n    assert np.all(multiple.ptp(0) > 0)\n\n\n\ndef test_return_mean_ptp():\n    f = 255*np.random.random((128,128))\n    f = f.astype(np.uint8)\n    fs = mh.features.haralick(f)\n    fs_mean = mh.features.haralick(f, return_mean=1)\n    fs_mean_ptp = mh.features.haralick(f, return_mean_ptp=1)\n    assert np.all(fs.mean(0) == fs_mean)\n    assert np.all(fs.mean(0) == fs_mean_ptp[:fs.shape[1]])\n    assert np.all(fs.ptp(0) == fs_mean_ptp[fs.shape[1]:])\n\n@raises(ValueError)\ndef test_return_mean_ptp_xor():\n    f = 255*np.random.random((128,128))\n    f = f.astype(np.uint8)\n    fs = mh.features.haralick(f, return_mean=1, return_mean_ptp=1)\n\n\ndef test_x_minus_y():\n    f = 255*np.random.random((128,128))\n    f = f.astype(np.uint8)\n    h = mh.features.haralick(f, use_x_minus_y_variance=False)\n    h2 = mh.features.haralick(f, use_x_minus_y_variance=True)\n    assert np.sum(h != h2) == 4\n\n\n@raises(ValueError)\ndef test_negative_values_haralick():\n    # https://github.com/luispedro/mahotas/issues/72\n    f = 255*np.random.random((16,16))\n    f = f.astype(np.int8)\n    mh.features.haralick(f)\n\n\ndef test_int8_positive_haralick():\n    # https://github.com/luispedro/mahotas/issues/72\n    f = 64*np.random.random((16,16))\n    f = f.astype(np.int8)\n    mh.features.haralick(f) # this should be fine: all the values are positive\n'"
mahotas/tests/test_thin.py,10,"b'import numpy as np\nimport mahotas.thin\n\ndef slow_thin(binimg, n=-1):\n    """"""\n    This was the old implementation\n    """"""\n    from mahotas.bbox import bbox\n    from mahotas._morph import hitmiss\n\n    _struct_elems = []\n    _struct_elems.append([\n            [0,0,0],\n            [2,1,2],\n            [1,1,1]])\n    _struct_elems.append([\n            [2,0,0],\n            [1,1,0],\n            [1,1,2]])\n    _struct_elems.append([\n            [1,2,0],\n            [1,1,0],\n            [1,2,0]])\n    _struct_elems.append([\n            [1,1,2],\n            [1,1,0],\n            [2,0,0]])\n    _struct_elems.append([\n            [1,1,1],\n            [2,1,2],\n            [0,0,0]])\n    _struct_elems.append([\n            [2,1,1],\n            [0,1,1],\n            [0,0,2]])\n    _struct_elems.append([\n            [0,2,1],\n            [0,1,1],\n            [0,2,1]])\n    _struct_elems.append([\n            [0,0,2],\n            [0,1,1],\n            [2,1,1]])\n\n    _struct_elems = [np.array(elem, np.uint8) for elem in _struct_elems]\n    res = np.zeros_like(binimg)\n    min0,max0,min1,max1 = bbox(binimg)\n\n    r,c = (max0-min0,max1-min1)\n\n    image_exp = np.zeros((r+2, c+2), np.uint8)\n    imagebuf = np.zeros((r+2,c+2), np.uint8)\n    prev = np.zeros((r+2,c+2), np.uint8)\n    image_exp[1:r+1, 1:c+1] = binimg[min0:max0,min1:max1]\n    n_iter = 0\n    while True:\n        prev[:] = image_exp[:]\n        for elem in _struct_elems:\n            newimg = hitmiss(image_exp, elem, imagebuf)\n            image_exp -= newimg\n        if np.all(prev == image_exp):\n            break\n        n_iter += 1\n        if (n > 0) and (n_iter == n):\n            break\n    res[min0:max0,min1:max1] = image_exp[1:r+1, 1:c+1]\n    return res\n\n\ndef test_thin():\n    A = np.zeros((100,100), bool)\n    A[20:40] = 1\n    W = mahotas.thin(A)\n    assert mahotas.erode(W).sum() == 0\n    assert (W & A).sum() == W.sum()\n\ndef test_compare():\n    def compare(A):\n        W = mahotas.thin(A)\n        W2 = slow_thin(A)\n        assert np.all(W == W2)\n    A = np.zeros((100,100), bool)\n    yield compare, A\n    A[20:40] = 1\n    yield compare, A\n    A[:,20:40] = 1\n    yield compare, A\n\n    A[60:80,60:80] = 1\n    yield compare, A\n\n    W = mahotas.thin(A, 2)\n    W2 = slow_thin(A, 2)\n    assert np.all(W == W2)\n\n\n'"
mahotas/tests/test_thresholding.py,30,"b""# Copyright 2011-2013 Luis Pedro Coelho <luis@luispedro.org>\n# License: MIT\n\nimport numpy as np\nfrom mahotas.thresholding import otsu, rc, bernsen, gbernsen\nfrom mahotas.histogram import fullhistogram\n\ndef slow_otsu(img, ignore_zeros=False):\n    hist = fullhistogram(img)\n    hist = hist.astype(np.double)\n    Hsum = img.size - hist[0]\n    if ignore_zeros:\n        hist[0] = 0\n    if Hsum == 0:\n        return 0\n    Ng = len(hist)\n\n    nB = np.cumsum(hist)\n    nO = nB[-1]-nB\n    mu_B = 0\n    mu_O = np.dot(np.arange(Ng), hist)/ Hsum\n    best = nB[0]*nO[0]*(mu_B-mu_O)*(mu_B-mu_O)\n    bestT = 0\n\n    for T in range(1, Ng):\n        if nB[T] == 0: continue\n        if nO[T] == 0: break\n        mu_B = (mu_B*nB[T-1] + T*hist[T]) / nB[T]\n        mu_O = (mu_O*nO[T-1] - T*hist[T]) / nO[T]\n        sigma_between = nB[T]*nO[T]*(mu_B-mu_O)*(mu_B-mu_O)\n        if sigma_between > best:\n            best = sigma_between\n            bestT = T\n    return bestT\n\ndef test_otsu_fast():\n    np.random.seed(120)\n    for i in range(12):\n        A = 32*np.random.rand(128,128)\n        A = A.astype(np.uint8)\n        fast = otsu(A)\n        slow = slow_otsu(A)\n        assert fast == slow\n\ndef test_thresholding():\n    np.random.seed(123)\n    A = np.random.rand(128,128)\n    A[24:48,24:48] += 4 * np.random.rand(24,24)\n    A *= 255//A.max()\n    A = A.astype(np.uint8)\n    def tm(method):\n        T = method(A)\n        assert (A > T)[24:48,24:48].mean() > .5\n        assert (A > T)[:24,:24].mean() < .5\n        assert (A > T)[48:,:].mean() < .5\n        assert (A > T)[:,48:].mean() < .5\n    yield tm, otsu\n    yield tm, rc\n\n\ndef test_nozeros():\n    np.seterr(all='raise')\n    np.random.seed(22)\n    A = (np.random.rand(100,100)*50).astype(np.uint8)+201\n    assert rc(A) > 200\n    assert otsu(A) > 200\n\ndef test_ignore_zeros():\n    np.seterr(all='raise')\n    np.random.seed(22)\n    A = np.zeros((1024,24), np.uint8)\n    A[:24,:24] = np.random.randint(100, 200, size=(24,24))\n    assert rc(A) < 100\n    assert otsu(A) < 100\n    assert rc(A, ignore_zeros=1) > 100\n    assert otsu(A, ignore_zeros=1) > 100\n\ndef test_zero_image():\n    A = np.zeros((16,16), np.uint8)\n    def tm(method):\n        assert method(A, ignore_zeros=0) == 0\n        assert method(A, ignore_zeros=1) == 0\n    yield tm, rc\n    yield tm, otsu\n\ndef test_soft_threhold():\n    from mahotas.thresholding import soft_threshold\n\n    np.random.seed(223)\n    for i in range(4):\n        f = np.random.randint(-256,256, size=(128,128,4))\n        fo = f.copy()\n        t = soft_threshold(f, 16)\n\n        assert not np.all(fo == t)\n        assert np.all(t[np.abs(f) < 16] == 0)\n        assert t.max() == f.max()-16\n        assert t.min() == f.min()+16\n        assert np.all( (np.abs(f) <= 16) | (np.abs(f)-16 == np.abs(t)))\n\n\ndef test_bernsen():\n    np.random.seed(120)\n    for i in range(4):\n        f = 32*np.random.rand(40,68)\n        f = f.astype(np.uint8)\n        b = bernsen(f, 8, 15)\n        assert f.shape == b.shape\n        b = bernsen(f, 8, 15, 34)\n        assert f.shape == b.shape\n\ndef test_gbernsen():\n    np.random.seed(120)\n    for i in range(4):\n        f = 32*np.random.rand(64,96)\n        f = f.astype(np.uint8)\n        b = gbernsen(f, np.ones((3,3), bool), 15, 145)\n        assert f.shape == b.shape\n"""
mahotas/tests/test_watershed.py,26,"b'import numpy as np\nimport mahotas\nimport mahotas as mh\nimport sys\nfrom nose.tools import raises\nS = np.array([\n    [0,0,0,0],\n    [0,1,2,1],\n    [1,1,1,1],\n    [0,0,1,0],\n    [1,1,1,1],\n    [1,2,2,1],\n    [1,1,2,2]\n    ])\nM = np.array([\n    [0,0,0,0],\n    [0,0,1,0],\n    [0,0,0,0],\n    [0,0,0,0],\n    [0,0,0,0],\n    [0,2,0,0],\n    [0,0,0,0],\n    ])\n\ndef test_watershed():\n    def cast_test(dtype):\n        St = S.astype(dtype)\n        Mt = M.astype(int)\n        W = mahotas.cwatershed(2-St,Mt)\n        assert sys.getrefcount(W) == 2\n        assert np.all(W == np.array([[1, 1, 1, 1],\n               [1, 1, 1, 1],\n               [1, 1, 1, 1],\n               [2, 2, 1, 1],\n               [2, 2, 2, 2],\n               [2, 2, 2, 2],\n               [2, 2, 2, 2]]))\n    types = [np.uint8, np.int8, np.uint16, np.int16, np.int32, np.uint32,int,\n                 np.float32, np.float64, float]\n    if hasattr(np, \'float128\'):\n        types.append(np.float128)\n    for d in types:\n        yield cast_test, d\n\n\n@raises(TypeError)\ndef test_float16():\n    dtype = np.float16\n    St = S.astype(dtype)\n    Mt = M.astype(int)\n    mh.cwatershed(2-St,Mt)\n\n\ndef test_watershed2():\n    S = np.zeros((100,10), np.uint8)\n    markers = np.zeros_like(S)\n    markers[20,2] = 1\n    markers[80,2] = 2\n    W = mahotas.cwatershed(S, markers)\n    assert np.all( (W == 1) | (W == 2) )\n\n@raises(ValueError)\ndef test_mismatched_array_markers():\n    S = np.zeros((10,12), np.uint8)\n    markers = np.zeros((8,12), np.uint8)\n    markers[2,2] = 1\n    markers[6,2] = 2\n    mahotas.cwatershed(S, markers)\n\ndef test_mix_types():\n    ""[watershed regression]: Mixing types of surface and marker arrays used to cause crash""\n    f = np.zeros((64,64), np.uint16)\n    f += (np.indices(f.shape)[1]**2).astype(np.uint16)\n    f += ((np.indices(f.shape)[0]-23)**2).astype(np.uint16)\n    markers = np.zeros((64,64), np.int64)\n    markers[32,32] = 1\n# Below used to force a crash (at least in debug mode)\n    a,b = mahotas.cwatershed(f, markers, return_lines=1)\n\n\ndef test_overflow():\n    \'\'\'[watershed regression]: Try to force overflow on the output\n\n    This was reported as issue #41 on github:\n\n    https://github.com/luispedro/mahotas/issues/41\n    \'\'\'\n    f = np.random.random((128,64))\n    f *= 255\n    f = f.astype(np.uint8)\n    for max_n in [127, 240, 280]:\n        markers = np.zeros(f.shape, np.int)\n        for i in range(max_n):\n            while True:\n                a = np.random.randint(f.shape[0])\n                b = np.random.randint(f.shape[1])\n                if markers[a,b] == 0:\n                    markers[a,b] = i + 1\n                    break\n\n        r = mh.cwatershed(f, markers)\n        assert markers.max() == max_n\n        assert r.max() == max_n\n\n\ndef test_watershed_labeled():\n    import mahotas as mh\n    S = np.array([\n        [0,0,0,0],\n        [0,1,2,1],\n        [1,1,1,1],\n        [0,0,1,0],\n        [1,1,1,1],\n        [1,2,2,1],\n        [1,1,2,2]\n        ])\n    M = np.array([\n        [0,0,0,0],\n        [0,0,1,0],\n        [0,0,0,0],\n        [0,0,0,0],\n        [0,0,0,0],\n        [0,2,0,0],\n        [0,0,0,0],\n        ])\n    labeled = mh.cwatershed(S, M)\n    sizes = mh.labeled.labeled_sum(S, labeled)\n    assert len(sizes) == labeled.max() + 1\n\n\ndef test_float_input():\n    ""[watershed]: Compare floating point input with integer input""\n    f = np.random.random((128,64))\n    f = mh.gaussian_filter(f, 8.)\n    f = mh.gaussian_filter(f, 8.)\n    markers,_ = mh.label(mh.regmin(f))\n    f = np.round(f * 2**30)\n    wf = mh.cwatershed(f / 2**30., markers)\n    w32 = mh.cwatershed(f.astype(np.int32), markers)\n    assert (wf == w32).mean() > .999\n'"
mahotas/tests/test_zernike.py,14,"b'import numpy as np\nfrom mahotas.features import zernike_moments\nfrom mahotas.center_of_mass import center_of_mass\nimport mahotas as mh\nfrom math import atan2, ceil\nfrom numpy import cos, sin, conjugate, pi, sqrt\n\ndef _slow_znl(Y,X,P,n,l):\n    def _polar(r,theta):\n        x = r * cos(theta)\n        y = r * sin(theta)\n        return 1.*x+1.j*y\n\n    v = 0.+0.j\n    def _factorial(n):\n        if n == 0: return 1.\n        return n * _factorial(n - 1)\n    y,x = Y[0],X[0]\n    for x,y,p in zip(X,Y,P):\n        Vnl = 0.\n        for m in range( int( (n-l)//2 ) + 1 ):\n            Vnl += (-1.)**m * _factorial(n-m) /  \\\n                ( _factorial(m) * _factorial((n - 2*m + l) // 2) * _factorial((n - 2*m - l) // 2) ) * \\\n                ( sqrt(x*x + y*y)**(n - 2*m) * _polar(1.0, l*atan2(y,x)) )\n        v += p * conjugate(Vnl)\n    v *= (n+1)/pi\n    return v \n\ndef _slow_zernike(img, radius, D, cof=None):\n    zvalues = []\n\n    Y,X = np.where(img > 0)\n    P = img[Y,X].ravel()\n    if cof is None:\n        cofy,cofx = center_of_mass(img)\n    else:\n        cofy,cofx = cof\n    Yn = ( (Y -cofy)/radius).ravel()\n    Xn = ( (X -cofx)/radius).ravel()\n    k = (np.sqrt(Xn**2 + Yn**2) <= 1.)\n    frac_center = np.array(P[k], np.double)\n    frac_center /= frac_center.sum()\n    Yn = Yn[k]\n    Xn = Xn[k]\n    frac_center = frac_center.ravel()\n\n    for n in range(D+1):\n        for l in range(n+1):\n            if (n-l)%2 == 0:\n                z = _slow_znl(Yn, Xn, frac_center, float(n), float(l))\n                zvalues.append(abs(z))\n    return np.array(zvalues)\n\ndef test_zernike():\n    A = (np.arange(256) % 14).reshape((16, 16))\n    slow = _slow_zernike(A, 8., 12)\n    fast = zernike_moments(A, 8., 12)\n    delta = np.array(slow) - fast\n    assert np.abs(delta).max() < 0.001\n\ndef test_zernike_cm():\n    A = (np.arange(256) % 14).reshape((16, 16))\n    cm = (8.9,12.4)\n    slow = _slow_zernike(A, 8., 12, cm)\n    fast = zernike_moments(A, 8., 12, cm=cm)\n    delta = np.array(slow) - fast\n    assert np.abs(delta).max() < 0.001\n\ndef test_not_nan():\n    im = np.array([\n           [  0,   0,  38, 168,  78,   0,   0,   0, 126, 168, 126,   0,   0],\n           [  0,   0, 104, 168,  78,   0,   0,  78, 168, 169, 169,  78,   0],\n           [  0,  38, 169, 169,  78,   0,   0, 142, 169, 169, 169, 162,   0],\n           [ 26, 156, 169, 168,  78,   0,   0, 169, 142,   0, 126, 169,  38],\n           [142, 169, 156, 166,  78,   0,  38, 169, 104,   0,  78, 169,  64],\n           [126, 142, 104, 168,  78,   0,  64, 168,  78,   0,  64, 168,  78],\n           [104,   0,  78, 169,  78,   0,  78, 168,  78,   0,  52, 169,  78],\n           [  0,   0,  78, 169,  78,   0,  78, 166,  78,   0,  52, 169,  78],\n           [  0,   0,  78, 166,  78,   0,  78, 166,  78,   0,  52, 169,  78],\n           [  0,   0,  78, 169,  78,   0,  78, 166,  78,   0,  52, 169,  78],\n           [  0,   0,  78, 169,  78,   0,  78, 166,  78,   0,  52, 169,  78],\n           [  0,   0,  78, 169,  78,   0,  78, 166,  78,   0,  64, 169,  78],\n           [  0,   0,  78, 166,  78,   0,  52, 166, 104,   0,  78, 169,  64],\n           [  0,   0,  78, 169,  78,   0,   0, 169, 142,   0, 126, 169,  38],\n           [  0,   0,  78, 169,  78,   0,   0, 142, 169, 169, 169, 156,   0],\n           [  0,   0,  78, 169,  78,   0,   0,  78, 168, 169, 169,  78,   0],\n           [  0,   0,  78, 166,  78,   0,   0,   0, 104, 169, 126,   0,   0]], dtype=np.uint8)\n\n    yy, xx = np.nonzero(im)\n    (cx, cy), r = (6., 8.), 9.212599754333496 # cv2.minEnclosingCircle(points)\n    zms = mh.features.zernike_moments(im, r, 8, cm=(cx, cy))\n    assert not np.any(np.isnan(zms))\n'"
mahotas/tests/utils.py,3,"b""import mahotas as mh\nimport numpy as np\ndef luispedro_jpg(as_grey=False):\n    from os import path\n    path = path.join(\n                path.abspath(path.dirname(__file__)),\n                'data',\n                'luispedro.npy')\n    im = np.load(path)\n    if as_grey:\n        transform = np.array([0.30, 0.59, 0.11])\n        return np.dot(im, transform)\n    return im\n"""
docs/source/figures/distance.py,1,"b""import numpy as np\nimport mahotas\nfrom pylab import imshow, savefig\nA = np.zeros((100,100), bool)\nA[40:60] = 1\nW = mahotas.thin(A)\nD = mahotas.distance(~W)\nimshow(D)\nsavefig('distance.png')\n\n"""
