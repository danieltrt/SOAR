file_path,api_count,code
setup.py,0,"b'# -*- coding: utf-8 -*-\nimport setuptools\nfrom numpy.distutils.core import setup\nfrom numpy.distutils.core import Extension\nfrom numpy.distutils.system_info import get_info\nfrom numpy.distutils.ccompiler import new_compiler\nfrom numpy.distutils.fcompiler import new_fcompiler\n\n\nlapack = get_info(\'lapack\')\nfftw = get_info(\'fftw\')\nqueue = dict(\n    libraries=[\'queue\'], library_dirs=[\'build\'], include_dirs=[\'build\'])\n\n\ndef merge_libs(*libs):\n    lib = {}\n    for k in set(k for l in libs for k in l):\n        for l in libs:\n            v = l.get(k)\n            if isinstance(v, list):\n                lib.setdefault(k, []).extend(v)\n    return lib\n\n\nextra_compile_args=[\n    \'-Wall\', \'-Wextra\', \'-pedantic\', \'-funroll-loops\', \'-O2\']\nfastbulk_ext = Extension(name=\'fastoverlap.f90.fastbulk\',\n                         sources=[\'fastoverlap/f90/fastbulk.f90\'],\n                         extra_compile_args=extra_compile_args,\n                         **merge_libs(fftw, lapack))\nfastcluster_ext = Extension(name=\'fastoverlap.f90.fastclusters\',\n                            sources=[\'fastoverlap/f90/fastclusters.f90\'],\n                            extra_compile_args=extra_compile_args,\n                            **merge_libs(fftw, lapack))\nbnb_ext = Extension(name=\'fastoverlap.f90.libbnb\',\n                    sources=[\'fastoverlap/f90/bnbalign.f90\'],\n                    extra_compile_args=extra_compile_args,\n                    **merge_libs(lapack, queue))\n\n\nif __name__ == ""__main__"":\n    # compiling static fortran priority queue library\n    fcompiler = new_fcompiler(compiler=\'gfortran\')\n    ccompiler = new_compiler()\n    fcompiler.customize()\n    queue_objs = fcompiler.compile(\n        sources=[""fastoverlap/f90/priorityqueue.f90""],\n        output_dir=\'build\',\n        extra_preargs=[\'-c\', \'-fPIC\'])\n    ccompiler.create_static_lib(\n        queue_objs, ""queue"",\n        output_dir=\'build\', debug=1)\n\n    setup(name                 = \'fastoverlap\',\n          version              = \'0.1\',\n          description          = (\n              \'Algorithms for fast alignment of atomic\'\n              \'structures in finite and periodic systems\'),\n          url                  = \'https://github.com/matthewghgriffiths/fastoverlap\',\n          author               = \'Matthew Griffiths\',\n          author_email         =\'matthewghgriffiths@gmail.com\',\n          license              =\'GNU General Public License\',\n          packages             = setuptools.find_packages(),\n          package_data         = {\'\': [\'*.f90\']},\n          include_package_data = True,\n          ext_modules=[fastbulk_ext, fastcluster_ext, bnb_ext])\n'"
examples/alignPeriodic.py,3,"b'# -*- coding: utf-8 -*-\n\nimport os\nimport csv\nimport numpy as np\nfrom fastoverlap import PeriodicAlign\ntry:\n    from fastoverlap import PeriodicAlignFortran, BranchnBoundAlignment\n    fortran=True\nexcept ImportError:\n    fortran=False\n\ndatafolder = ""BLJ256/""\n\ndef readFile(filename):\n    with open(filename, \'rb\') as f:\n        reader = csv.reader(f, delimiter=\' \')\n        dist = [map(float, row) for row in reader]\n    return np.array(dist)\n\npos1 = readFile(os.path.join(datafolder, \'coords\'))\npos2 = readFile(os.path.join(datafolder, \'finish\'))\n\nnatoms = 256\nntypeA = 204\nshape = (natoms, 3)\nboxVec = np.ones(3)*5.975206329 #(natoms/1.2)**(1./3.)\npermlist = [np.arange(ntypeA), np.arange(ntypeA, natoms)]\nalign = PeriodicAlign(natoms, boxVec, permlist)\n\nif fortran:\n    alignf = PeriodicAlignFortran(natoms, boxVec, permlist)\n    bnb = BranchnBoundAlignment(invert=False,boxSize=boxVec, perm=permlist)\n\nc1, c2 = (align.calcFourierCoeff(p) for p in (pos1, pos2))\n\ndef quickAlign(c1, c2):\n    """"""\n    If fourier coefficients, c1 and c2 are precalculated the algorithm\n    runs faster\n    """"""\n    return align.align(pos1, pos2, [c1,c2])\n\nif __name__ == ""__main__"":\n    permRMS = align.Hungarian(pos1, pos2)[0]*natoms**-0.5\n    print \'Performing permutational alignment with Hungarian algorithm\'\n    print \'RMSD = {:0.4f}\'.format(permRMS)\n\n    print \'Performing fastoverlap alignment\'\n    dist, X1, X2, perm, disp = align(pos1, pos2)\n    fastRMS = dist*natoms**-0.5\n    print \'RMSD = {:0.4f}\'.format(fastRMS)\n\n    if fortran:\n        print \'Performing fortran fastoverlap alignment\'\n        dist, X1, X2, perm = alignf(pos1, pos2)\n        fastRMS = dist*natoms**-0.5\n        print \'RMSD = {:0.4f}\'.format(fastRMS)\n\n        print \'Performing branch and bound alignment\'\n        dist, X1, X2 = bnb(pos1, pos2, niter=100)\n        bnbRMS = dist*natoms**-0.5\n        print \'RMSD = {:0.4f}\'.format(bnbRMS)\n\n    import timeit\n    print \'Timing fastoverlap alignment:\'\n\n    alignTimer = timeit.Timer(stmt=""palign.align(palign.pos1, palign.pos2)"",\n                     setup=""import alignPeriodic as palign"")\n    aligntime =  alignTimer.timeit(10)/10.\n\n    fastTimer = timeit.Timer(stmt=""palign.quickAlign(palign.c1, palign.c2)"",\n                     setup=""import alignPeriodic as palign"")\n    fasttime = fastTimer.timeit(10)/10.\n\n    print \'Average time to align for fast overlap {:0.3} s\'.format(aligntime)\n    print \'Average time to align with precalculated coefficients {:0.3} s\'.format(fasttime)\n\n    if fortran:\n        fTimer = timeit.Timer(stmt=""palign.alignf(palign.pos1, palign.pos2,1)"",\n                         setup=""import alignPeriodic as palign"")\n        ftime =  alignTimer.timeit(10)/10.\n\n        bnbTimer = timeit.Timer(stmt=""palign.bnb(palign.pos1, palign.pos2, niter=100)"",\n                         setup=""import alignPeriodic as palign"")\n        bnbtime = bnbTimer.timeit(10)/10.\n\n        print \'Average time to align for fortran fast overlap {:0.3} s\'.format(ftime)\n        print \'Average time to align for branch and bound alignment {:0.3} s\'.format(bnbtime)\n\n'"
examples/alignSpherical.py,1,"b'# -*- coding: utf-8 -*-\nimport os\nimport csv\nimport numpy as np\nfrom fastoverlap import SphericalAlign\n\ntry:\n    from fastoverlap import BranchnBoundAlignment\n    alignbnb = True\nexcept ImportError:\n    alignbnb = False\n\ndatafolder = ""LJ38/""\n\ndef readFile(filename):\n    with open(filename, \'rb\') as f:\n        reader = csv.reader(f, delimiter=\' \')\n        dist = [map(float, row) for row in reader]\n    return np.array(dist)\n\npos1 = readFile(os.path.join(datafolder, \'coords\'))\npos2 = readFile(os.path.join(datafolder, \'finish\'))\n\nnatoms = 38\nscale = 0.3 # Set this to be ~ half interatomic separation\nmaxl = 15 # Max degree of spherical harmonic\n\nalign = SphericalAlign(scale, maxl)\n\nif alignbnb:\n    bnb = BranchnBoundAlignment()\n\n\n\nif __name__ == ""__main__"":\n\n    print \'Performing permutational alignment with Hungarian algorithm\'\n    permRMS = align.Hungarian(pos1, pos2)[0]*natoms**-0.5\n    print \'RMSD = {:0.4f}\'.format(permRMS)\n\n    print \'Performing fastoverlap alignment\'\n    fastdist = align(pos1, pos2)[0]\n    fastRMS = fastdist*natoms**-0.5\n    print \'RMSD = {:0.4f}\'.format(fastRMS)\n    if alignbnb:\n        print \'Performing branch and bound alignment\'\n        bnbdist = bnb(pos1, pos2)[0]\n        bnbRMS = bnbdist*natoms**-0.5\n        print \'RMSD = {:0.4f}\'.format(bnbRMS)\n\n    import timeit\n    print \'Timing fastoverlap alignment:\'\n    alignTimer = timeit.Timer(stmt=""salign.align(salign.pos1, salign.pos2)"",\n                     setup=""import alignSpherical as salign"")\n    aligntime =  alignTimer.timeit(10)/10.\n\n    print \'Average time to align for fastoverlap {:0.3} s\'.format(aligntime)\n\n    if alignbnb:\n        bnbTimer = timeit.Timer(stmt=""salign.bnb(salign.pos1, salign.pos2)"",\n                         setup=""import alignSpherical as salign"")\n        bnbtime =  bnbTimer.timeit(10)/10.\n        print \'Average time to align for branch and bound alignment {:0.3} s\'.format(bnbtime)\n\n\n'"
fastoverlap/__init__.py,0,"b""\n__all__ = ['SphericalAlign', 'PeriodicAlign', 'BranchnBoundAlignment', 'SOFT']\n\nfrom .sphericalAlignment import SphericalHarmonicAlign, SphericalAlign\nfrom .periodicAlignment import PeriodicAlign\nfrom .soft import SOFT\n\n# Import fortran modules if we can\nimport f90 as _f90\nif _f90.have_fastclusters:\n    from .sphericalAlignment import SphericalHarmonicAlignFortran, \\\n        SphericalAlignFortran\nif _f90.have_fastbulk:\n    from .periodicAlignment import PeriodicAlignFortran\nif _f90.have_libbnb:\n    from .bnbAlignment import BranchnBoundAlignment\n"""
fastoverlap/bnbAlignment.py,53,"b'# -*- coding: utf-8 -*-\n\n\nfrom itertools import product, izip\nfrom heapq import heappop, heappush\n\nimport numpy as np\nfrom numpy import sin, sqrt, cos, pi\nfrom numpy.linalg import norm\n\nfrom scipy.spatial import cKDTree\n\nfrom hungarian import lap\n\nfrom utils import angle_axis2mat, mat2angle_axis, PriorityQueueHeap\n\nimport f90\nif f90.have_libbnb:\n    from f90 import libbnb\n\nclass BranchandBoundMaster(object):\n    def __init__(self, initialNodes=[], rtol=5e-2, atol=1e-3):\n        self.queue = PriorityQueueHeap()\n        self.nodes = 0\n        self.ncalc = 0\n        self.quickcount = 0\n        self.rtol = rtol\n        self.atol = atol\n        self.record = []\n        if len(initialNodes):\n            self.best = initialNodes[0]\n            initialNodes[0].addtoQueue(self.queue)\n        for node in initialNodes[1:]:\n            if node.upperbound < self.best.upperbound:\n                self.best = node\n            if node.lowerbound < self.best.upperbound:\n                node.addtoQueue(self.queue)\n\n    def run(self, niter=10000, force=False, iprint=0):\n        while(not self.queue.empty()):\n            node = self.queue.get()[-1]\n            self.nodes += 1\n            if (node.lowerbound <\n                self.best.upperbound - self.rtol*self.best.upperbound - self.atol):\n                self.record.append((\n                    self.nodes, self.ncalc, self.queue.qsize(), self.quickcount, node.rot, node.width,\n                    node.lowerbound, node.upperbound, self.best.upperbound))\n                if iprint:\n                    if self.nodes%iprint == 0:\n                        print self.record[-1]\n                newnodes = node.branch()\n                for new in newnodes:\n                    self.ncalc += 1\n                    new.calcbounds(self.best.upperbound, force=force)\n                    if new.quick:\n                        self.quickcount += 1\n                    if new.lowerbound < self.best.upperbound:\n                        if new.upperbound < self.best.upperbound:\n                            self.best = new\n                            self.best.iter = self.nodes\n                        new.addtoQueue(self.queue)\n                if self.nodes > niter:\n                    break\n        return self.best\n\n    def __call__(self, pos1, pos2, invert=True, niter=np.inf,\n                 extra_inputs=None, force=False, iprint=0):\n\n        pos1 = np.array(pos1)\n        pos2 = np.array(pos2)\n        cm1 = pos1.mean(0)[None,:]\n        cm2 = pos2.mean(0)[None,:]\n        pos1 -= cm1\n        pos2 -= cm2\n\n        rot = np.zeros(3)\n\n        r1 = norm(pos1, axis=1)\n        r2 = norm(pos2, axis=1)\n\n        r1tr2 = (r1[:,None]*r2[None,:])\n        r1pr2 = r1[:,None]**2 + r2[None,:]**2\n        pos1tree = cKDTree(pos1, 10)\n\n        startNode = BranchNodeCluster(rot, 2*np.pi, pos1, pos2,\n                               r1, r2, r1tr2, r1pr2, pos1tree)\n        startNode.calcbounds(force=True)\n\n        inputs = [startNode]\n        if invert:\n            inputs.append(BranchNodeCluster(rot, 2*np.pi, pos1, -pos2,\n                                     r1, r2, r1tr2, r1pr2, pos1tree))\n            inputs[-1].calcbounds(force=True)\n        if extra_inputs is not None:\n            inputs.extend(extra_inputs)\n\n        self.nodes=0\n        self.__init__(inputs, self.rtol, self.atol)\n        self.run(niter, force=force, iprint=iprint)\n\n        bestNode = self.best\n        return bestNode.upperbound, pos1+cm1, bestNode.rpos2+cm1\n\n    def plot(self):\n        import matplotlib.pyplot as plt\n        n, ncalc, qsize, quick, vs, widths, lower, upper, best = \\\n            map(np.array, zip(*self.record))\n\n        fig, axes = plt.subplots(3,1, sharex=True)\n\n        axes[0].plot(n, best)\n        axes[0].plot(n, lower)\n        axes[0].scatter(n, upper, marker=\'+\')\n\n        bestNode = self.best\n\n        axes[1].plot(n, -np.ones_like(n)*pi, lw=1, c=\'k\')\n        axes[1].scatter(n, vs[:,0], marker=\'+\', c=\'r\')\n        axes[1].plot(n, np.ones_like(n)*bestNode.rot[0], lw=2, c=\'r\')\n        axes[1].plot(n, np.ones_like(n)*pi, lw=1, c=\'k\')\n        axes[1].scatter(n, vs[:,1] + 2*np.pi, marker=\'+\', c=\'b\')\n        axes[1].plot(n, np.ones_like(n)*bestNode.rot[1] + 2*np.pi, lw=2, c=\'b\')\n        axes[1].plot(n, np.ones_like(n)*3*pi, lw=1, c=\'k\')\n        axes[1].scatter(n, vs[:,2] + 4*np.pi, marker=\'+\', c=\'g\')\n        axes[1].plot(n, np.ones_like(n)*bestNode.rot[2] + 4*np.pi, lw=2, c=\'g\')\n        axes[1].plot(n, np.ones_like(n)*5*pi, lw=1, c=\'k\')\n        axes[1].plot(n, widths + 5*np.pi)\n        axes[1].plot(n, np.ones_like(n)*5*np.pi)\n\n        axes[2].plot(n, ncalc)\n        axes[2].plot(n, qsize)\n        axes[2].plot(n, quick)\n\n        axes[0].set_xlim(min(n)-10, max(n)+10)\n        fig.tight_layout(h_pad=0.1)\n        return fig, axes\n\n\nclass BranchNode(object):\n    def addtoQueue(self, queue):\n        queue.put((self.lowerbound, self))\n    def branch(self):\n        raise NotImplementedError\n    def calcbounds(self, bestupper=np.inf):\n        raise NotImplementedError\n\n\nclass BranchNodeBulk(BranchNode):\n    branchvects = np.array(list(product([1,-1],repeat=3)))\n    def __init__(self, disp, width, pos1, pos2, boxvec, perm):\n        self.disp = disp\n        self.width = width\n        self.pos1, self.pos2 = pos1, pos2\n        self.boxvec = boxvec\n        self.perm = perm\n\n    def branch(self):\n        newdisps = self.branchvects*self.width*0.25\n        newnodes = [BranchNodeBulk(disp, self.width*0.5, self.pos1, self.pos2,\n                                   self.boxvec, self.perm)\n                    for disp in newdisps]\n        return newnodes\n\n    def calcbounds(self, bestupper=np.inf, force=False):\n        tpos2 = self.pos2 - np.atleast_2d(self.disp)\n        disps = [self.pos1[p[:,None],:] - tpos2[p[None,:],:]\n                 for p in self.perm]\n        for d in disps:\n            d -= np.round(d/self.boxvec) * self.boxvec\n        dists = [np.norm(d, axis=2) for d in disps]\n        ldists = [np.clip(d-0.5*self.width*sqrt(3),0,np.inf)**2 for d in dists]\n        dists = [d**2 for d in dists]\n        if not force:\n            upperbound = sqrt(sum(d.min(0).sum() for d in dists))\n        else:\n            upperbound = 0.\n\n        if upperbound < bestupper or force:\n            self.quick = False\n            lowerperm = [lap(ld)[0] for ld in ldists]\n            self.lowerbound = sqrt(\n                sum(ldists[p,lp] for p,lp in izip(self.perm, lowerperm)))\n            if self.lowerbound < bestupper:\n                upperperm = [lap(d)[0] for d in dists]\n                self.upperbound = sqrt(\n                    sum(dists[p,lp] for p,lp in izip(self.perm, upperperm)))\n            else:\n                upperperm = lowerperm\n                self.upperbound = np.inf\n        else:\n            self.quick = True\n            self.lowerbound = sqrt(sum(d.min(0).sum() for d in ldists))\n            upperperm = None\n        return self.lowerbound, self.upperbound, upperperm\n\nclass BranchNodeCluster(BranchNode):\n    branchvects = np.array(list(product([1,-1],repeat=3)))\n    def __init__(self, rot, width, pos1, pos2,\n                 r1, r2, r1tr2, r1pr2, pos1tree):\n        self.rot = rot\n        self.width = width\n        self.pos1, self.pos2 = pos1, pos2\n        #self.rpos2 = self.pos2.dot(angle_axis2mat(self.rot))\n        self.r1, self.r2 = r1, r2\n        self.r1tr2 = r1tr2\n        self.r1pr2 = r1pr2\n        self.pos1tree = pos1tree\n        self.n = 2\n\n    def branch(self):\n        n = self.n\n        n = 2\n        newrots = np.indices((n,n,n), dtype=float).reshape(3,-1).T\n        newrots *= 2\n        newrots -= (n-1.)\n        newrots *= 0.5 * self.width / n\n        newrots += self.rot[None,:]\n        newnodes = [BranchNodeCluster(rot, self.width/n,\n                               self.pos1, self.pos2, self.r1, self.r2,\n                               self.r1tr2, self.r1pr2, self.pos1tree)\n                    for rot in newrots]\n        return newnodes\n\n    def calcbounds(self, bestupper=np.inf, force=False):\n        rpos2 = self.pos2.dot(angle_axis2mat(self.rot))\n\n        if not force:\n            d, p = self.pos1tree.query(rpos2)\n            upperbound = norm(d)\n        else:\n            upperbound = 0\n\n        if upperbound < bestupper or force:\n            self.quick = False\n            dists = ((self.pos1[:,None,:]-rpos2[None,:,:])**2).sum(2)\n\n            cosa = 0.5*(self.r1pr2 - dists)/self.r1tr2\n            sina = sqrt(np.clip(1.-cosa**2,0.,1.))\n            theta = min((sqrt(3) * self.width / 2),np.pi)\n            cosd = cos(theta)\n            sind = abs(sin(theta))\n            cosdm = np.where(cosa>cosd, 1., cosa*cosd + sina*sind)\n\n            lowerbounddists = np.clip(self.r1pr2 - 2*self.r1tr2*cosdm, 0., np.inf)\n            lowerperm = lap(lowerbounddists.copy())[0]\n            self.lowerbound = sqrt(sum(lowerbounddists[i,j] for i,j in enumerate(lowerperm)))\n\n            if self.lowerbound < bestupper:\n                upperperm = lap(dists)[0]\n                self.upperbound = norm(self.pos1 - rpos2[upperperm])\n            else:\n                upperperm = lowerperm\n                self.upperbound = np.inf\n        else:\n            self.quick = True\n            cosa = 0.5*(self.r1[p]**2 + self.r2**2 - d**2)/self.r1[p]/self.r2\n            sina = sqrt(np.clip(1.-cosa**2,0.,1.))\n            theta = min((sqrt(3) * self.width / 2),np.pi)\n            cosd = cos(theta)\n            sind = abs(sin(theta))\n            cosdm = np.where(cosa>cosd, 1., cosa*cosd + sina*sind)\n            lowerbounddists = np.clip(self.r1[p]**2 + self.r2**2 - 2*self.r1[p]*self.r2*cosdm, 0., np.inf)\n            lowerbound = lowerbounddists.sum()**0.5\n            self.upperbound = upperbound\n            self.lowerbound = lowerbound\n            upperperm = p\n\n        self.rpos2 = rpos2\n        return self.lowerbound, self.upperbound, upperperm\n\nclass BranchnBoundAlignment(object):\n\n    def __init__(self,invert=True,boxSize=None,perm=None):\n        self.invert = invert\n        self.libbnb = libbnb\n        self.gopermdist = libbnb.gopermdist\n        self.qlen = self.gopermdist.queuelen\n        self.commons = libbnb.commons\n        if boxSize is None:\n            self.bulk = False\n            self.boxvec = np.zeros(3)\n            self.gopermdist.setcluster(invert)\n        else:\n            self.bulk = True\n            self.boxvec = np.array(boxSize, dtype=float)\n            self.gopermdist.setbulk(invert)\n        if perm is not None:\n            self.setPerm(perm)\n        self.Natoms = None\n\n    def setPerm(self, perm):\n        self.Natoms = sum(map(len,perm))\n        self.perm = perm\n        self.nperm = len(perm)\n        self.npermsize = map(len, perm)\n        self.permgroup = np.concatenate([np.asanyarray(p)+1 for p in perm])\n        self.gopermdist.setperm(self.Natoms, self.permgroup, self.npermsize)\n\n    def initialise(self, pos1, pos2, perm=None, debug=False):\n        pos1 = np.asanyarray(pos1).reshape(-1,3)\n        pos2 = np.asanyarray(pos2).reshape(-1,3)\n\n        if perm is not None:\n            self.setPerm(perm)\n        elif len(pos1) != self.Natoms:\n            self.Natoms = len(pos1)\n            self.setPerm([np.arange(self.Natoms)])\n\n        self.coordsb = np.array(pos1).flatten()\n        self.coordsa = np.array(pos2).flatten()\n        self.gopermdist.initialise(\n            self.coordsb, self.coordsa, self.boxvec[0], self.boxvec[1],\n            self.boxvec[2], self.bulk)\n        self.libbnb.alignutils.debug = debug\n\n    def __call__(self, pos1, pos2, perm=None, invert=None, debug=False,\n                 force=False, niter=1000, iprint=1):\n        if invert is None:\n            invert = self.invert\n        if invert:\n            self.invert = invert\n            if self.bulk:\n                self.gopermdist.setbulk(invert)\n            else:\n                self.gopermdist.setcluster(invert)\n        self.initialise(pos1, pos2, perm=perm, debug=debug)\n        self.libbnb.alignutils.nstored = 0\n        bestupper = np.array(np.inf)\n        if self.bulk:\n            width = max(self.boxvec)\n        else:\n            width = 2*pi\n        self.gopermdist.addnode(np.zeros(3),width,1,bestupper,True)\n        if self.bulk and self.invert:\n            for i in xrange(2,49):\n                self.gopermdist.addnode(np.zeros(3),width,i,bestupper,force)\n        elif self.invert:\n            self.gopermdist.addnode(np.zeros(3),width,2,bestupper,force)\n        self.gopermdist.run(niter,force,iprint,bestupper)\n        bestid = self.gopermdist.bestid.item()-1\n        coordsb = self.gopermdist.savecoordsb.reshape(pos1.shape)\n        coordsa = self.gopermdist.bestcoordsa[:,bestid].reshape(pos2.shape)\n        if self.bulk:\n            return bestupper.item(), coordsb, coordsa\n        else:\n            rmat = self.gopermdist.bestrmat[:,:,bestid]\n            return bestupper.item(), coordsb, coordsa, rmat\n\n\nif __name__ == ""__main__"":\n    import os\n    import csv\n\n    # Turn debug on if you want status messages\n    # You will get A LOT of print statements!\n    debug=False\n    # Turn periodic alignment on, much slower...\n    periodic = True\n    # Turn octahedral symmetry searching on, 48 times slower!\n    ohcell = False #True\n\n\n    def readFile(filename):\n        with open(filename, \'rb\') as f:\n            reader = csv.reader(f, delimiter=\' \')\n            dist = [map(float, row) for row in reader]\n        return np.array(dist)\n\n    datafolder = ""../examples/LJ38""\n    natoms = 38\n    pos1 = readFile(os.path.join(datafolder, \'coords\'))\n    pos2 = readFile(os.path.join(datafolder, \'finish\'))\n\n    bnbpy = BranchandBoundMaster()\n\n\n    if not f90.have_libbnb:\n        # Much slower!\n        dpyclus, coordsb, coordsa = bnbpy(pos1, pos2)\n        fig, axes = bnbpy.plot()\n\n    if f90.have_libbnb:\n        bnbcluster = BranchnBoundAlignment()\n        dcluster, coordsb, coordsa, rmat = bnbcluster(pos1, pos2, debug=debug, niter=100)\n\n    print \'Cluster alignment:\'\n    print \'On example LJ38 data, distance should = 1.4767\'\n    if not f90.have_libbnb:\n        print \'Branch and bound python alignment: \', dpyclus\n    if f90.have_libbnb:\n        print \'Branch and bound Fortran alignment: \', dcluster\n\n    if f90.have_libbnb and periodic:\n        datafolder = ""../examples/BLJ256""\n\n        pos1 = readFile(os.path.join(datafolder, \'coords\'))\n        pos2 = readFile(os.path.join(datafolder, \'finish\'))\n\n        natoms = 256\n        ntypeA = 204\n        shape = (natoms, 3)\n        boxSize = np.ones(3)*5.975206329\n        permlist = [np.arange(ntypeA), np.arange(ntypeA, natoms)]\n        bnbbulk = BranchnBoundAlignment(invert=False, boxSize=boxSize)\n\n        dbulk, coordsab, coordsa = bnbbulk(pos1, pos2, debug=debug, niter=50)\n\n        print \'\\nPeriodic alignment:\'\n        print \'On example BLJ256 data, distance should = 1.559\'\n        print \'Branch and bound alignment: \', dbulk\n\n        # Testing for octahderal symetries will take ~48 times longer!\n\n        if ohcell:\n            bnbbulk = BranchnBoundAlignment(boxSize=boxSize)\n            dbulk, coordsab, coordsa = bnbbulk(pos1, pos2.dot([[0,1,0],[1,0,0],[0,0,1]]),\n                                               debug=False, niter=2000, invert=True)\n            print ""Octahedral alignment: "", dbulk\n'"
fastoverlap/periodicAlignment.py,77,"b'\'\'\'\nCreated on 19 Jan 2017\n\n@author: mg542\n\'\'\'\n\nfrom itertools import product, combinations_with_replacement, chain, izip\n\nimport numpy as np\nfrom numpy.linalg import norm\nfrom scipy import median\n\nfrom utils import find_best_permutation, findMax, _next_fast_len, findPeaks\n\nimport f90\nif f90.have_fastbulk:\n    fastbulk = f90.fastbulk\n\nclass BasePeriodicAlignment(object):\n    def findDisps(self, pos1, pos2):\n        raise NotImplementedError\n    ##\n    def align(self, pos1, pos2):\n        disps = self.findDisps(pos1, pos2)\n        return self.refine(pos1, pos2, disps)\n    ##\n    def refine(self, x, y, disps,niter=10):\n        """"""Given a displacement vector between two non-permutationally aligned\n        configurations, this will refine the displacement vector by\n        performing a permutational alignment followed by a calculation of the median\n        displacement, followed by a second permutational alignment, and\n        then finally setting the mean displacement to 0.\n\n        Parameters\n        ----------\n        pos1 : (Natoms, 3) array_like\n            Coordinate array.\n        pos2 : (Natoms, 3) array_like\n            Coordinate array to align with pos1.\n        disps : (...,3) array_like, optional\n            Number of different displacements to test\n        niter : integer, optional\n            Number of iterations of alignment refinement.\n\n        Returns\n        -------\n        distance : float\n            Euclidean distance between X1 and X2\n        X1 : (Natoms, 3) array_like\n            pos1, clipped so all points lie with in boxVec/2 of origin\n        X2 : (Natoms, 3) array_like\n            Aligned coordinates of pos2\n        perm : rank-1 array(\'i\') with bounds (Natoms)\n            permutation list of pos2\n        disp : (3)\n            displacement\n\n        Notes:\n        -------\n        0 = self.get_dist(pos1, X1)\n        0 = self.get_dist(X2, pos2[perm] - disp[None,:])\n        """"""\n        disps = np.atleast_2d(disps)\n        distperm = [self.Hungarian(x, y - disp[None,:]) + (disp,)\n                    for disp in disps]\n        dist, saveperm, disp = min(distperm, key=lambda x: x[0])\n        for i in range(niter):\n            dxs = self.get_disp(x, (y-disp)[saveperm])\n            disp -= dxs.mean(0)\n            perm = self.Hungarian(x, y - disp[None,:])[1]\n            if all(p1==p2 for p1, p2 in zip(saveperm, perm)):\n                break\n            else:\n                saveperm = perm\n        dxs = self.get_disp(x, (y-disp)[perm])\n        disp -= dxs.mean(0)\n        pos1 = self.periodic(x, True)\n        pos2 = self.periodic(y[perm] - disp)\n        dist = self.get_dist(pos1, pos2)\n        return dist, pos1, pos2, perm, disp\n\n    def periodic(self, x, copy=False):\n        if copy:\n            x = x.copy()\n        x -= np.round(x / self.boxvec) * self.boxvec\n        return x\n\n    def get_disp(self, X1, X2):\n        return self.periodic(X1 - X2)\n\n    def get_dist(self, X1, X2):\n        return norm(self.get_disp(X1, X2))\n\n    def cost_matrix(self, X1, X2):\n        """"""\n        Calculating this matrix is most of the computational cost associated\n        with this algorithm for large databases, might be worth reimplementing\n        this in c++/fortran?\n        """"""\n        disps = X1[None,:,:] - X2[:,None,:]\n        disps -= np.round(disps / self.boxvec[None,None,:]) * self.boxvec[None,None,:]\n        return norm(disps, axis=2)\n\n    def Hungarian(self, X1, X2):\n        _, permlist = find_best_permutation(X1, X2, self.perm, user_cost_matrix=self.cost_matrix)\n        dist = self.get_dist(X1, X2[permlist])\n        return dist, permlist\n\n    def __call__(self, pos1, pos2, *args, **kwargs):\n        return self.align(pos1, pos2, *args, **kwargs)\n\nclass FourierAlign(BasePeriodicAlignment):\n    """"""\n    Alignment procedure based on a maximum likelihood method.\n    It\'s probably better to use the PeriodicGaussian class to align\n    periodic systems, this is included for completeness.\n\n    Parameters\n    ----------\n    Natoms : int\n    boxvec : array like floats\n        defines periodicity of system being aligned\n    permlist : optional\n        list of allowed permutations. If nothing is given, all atoms will be\n        considered as permutable. For no permutations give an empty list []\n\n\n    For two structures $\\vec{R}^0_j$ and $\\vec{R}^1_j$\n\n    We want to find the optimal alignment such that we have a permutation matrix\n    $\\vec{P}$, global displacement $\\vec{d}$ such that the local displacement\n    $\\sum |\\vec{e}_j|^2$ is minimized.\n\n    \\begin{equation}\n    \\vec{R}^0_j = \\vec{P}(\\vec{R}^1_j + \\vec{e}_j + \\vec{d}\n    \\end{equation}\n\n    We can define fourier coefficients for both structures as follows,\n\n    \\begin{align}\n    \\tilde{C}_\\vec{k}^0 = \\frac{1}{L^3} \\sum_j e^{-i\\vec{k}\\cdot\\vec{R}_j}\n    \\tilde{C}_\\vec{k}^1 = \\frac{1}{L^3} \\sum_j e^{-i\\vec{k}\\cdot\\vec{R}\'_j}\n    \\end{align}\n\n    The ratio of these coefficients will be,\n\n    \\begin{equation}\n    \\frac{\\tilde{C}_{\\vec{k}}^1}{\\tilde{C}_{\\vec{k}}^0}=\n    e^{i\\vec{k}\\cdot\\vec{d}} \\frac\n    {\\sum_{j=1}^N e^{-i\\vec{k}\\cdot(\\vec{R}_j+\\vec{e}_j)}}\n    {\\sum_{j=1}^N e^{-i\\vec{k}\\cdot\\vec{R}_j}}.\n    \\end{equation}\n\n    Taking a first order approximation of the local displacements we find\n\n    \\begin{equation}\n    \\vec{k}\\cdot\\vec{d} = -i \\textrm{log}\n    \\left(\\frac{\\tilde{C}_{\\vec{k}}^1}{\\tilde{C}_{\\vec{k}}^0} \\right)\n    + i \\log{\\left( 1 - \\frac{i\\vec{k}\\cdot\\tilde{\\vec{e}}_{\\vec{k}}}{\\tilde{C}_{\\vec{k}}^0} \\right)}\n    +  2\\pi n_\\vec{k}\n    \\end{equation}\n\n    To find $\\vec{d}$ we define $\\vec{d}=\\vec{d}_0+\\vec{d}_1$ so\n\n    \\begin{align}\n    \\theta_{\\vec{k}}^{\\vec{d}_0} &=\n    \\Re{\\left[\n    - i\n    \\textrm{log}\n    \\left(\n    \\frac{\\tilde{C}_{\\vec{k}}^1}{\\tilde{C}_{\\vec{k}}^0} e^{i\\vec{k}\\cdot\\vec{d}_0}\n    \\right)\\right]} \\\\\n    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n    \\frac{|\\vec{k}|}{|\\tilde{C}_{\\vec{k}}^0|} \\hat{e}_{\\vec{k}}\n    &=\n    \\Re{\\left[\n    \\frac{\\vec{k}\\cdot\\tilde{\\vec{e}}_{\\vec{k}}}\n    {\\tilde{C}_{\\vec{k}}^0}\n    \\right]},\n    \\end{align}\n\n    This means we can assume that $2 \\pi n_\\vec{k}$ is 0.\n    If we assume that the standard deviation of $\\hat{e}_{\\vec{k}}$\n    can be estimated to be,\n    $\\sigma(\\hat{e}_{\\vec{k}}) \\approx F(1+|\\vec{p}|^{-3})$,\n    and we define $\\sigma_\\vec{k} = \\sigma(\\hat{e}_{\\vec{k}})\n    |\\vec{k}|\\left/|\\tilde{C}_{\\vec{k}}^0|\\right.$\n    then the log-likelihood of $\\vec{d}$ can be calculated.\n\n    \\begin{align}\n    \\log{\\Pr(\\vec{d}_1|\\tilde{C}_{\\vec{k}}^1,\\tilde{C}_{\\vec{k}}^0,\n    \\vec{d}_0,\\sigma_\\vec{k})} &= -\n    \\sum_{\\vec{k}\\,\\epsilon\\,\\vec{K}}\n    \\frac{(\\vec{k}\\cdot\\vec{d_1}-\\theta_\\vec{k}^{\\vec{d}_0})^2}\n    {2\\sigma_{\\vec{k}}^2}\n    + \\frac{1}{2}\\log{2\\pi} + \\log{\\sigma_{\\vec{k}}}.\n    \\end{align}\n\n    At the maximum likelihood the gradient of \\ref{eqn:dloglikelihoodFull}\n    will be zero which  we can solve to find,\n\n    \\begin{align}\n    \\vec{d}_1 &=\n    \\left(\n    \\sum_{\\vec{k}\\,\\epsilon\\,\\vec{K}}  \\frac{\\vec{k}\\otimes\\vec{k}}{\\sigma_{\\vec{k}}^2}\n    \\right)^{-1}\n    \\sum_{\\vec{k}\\,\\epsilon\\,\\vec{K}}  \\vec{k}\n    \\frac{\\theta_\\vec{k}^{\\vec{d}_0}}\n    {\\sigma_{\\vec{k}}^2},\n    \\end{align}\n    """"""\n    def __init__(self, Natoms, box, permlist=None, dim=3, origin=None,\n                 maxd=None, tol=None, maxdisps=10, likeThresh=2.):\n        self.Natoms = Natoms\n        self.boxvec = np.asanyarray(box, dtype=float)\n        self.dim = dim\n        self.likeThresh = likeThresh\n        if permlist is None:\n            self.perm = [np.arange(self.Natoms)]\n        else:\n            self.perm = permlist\n        self.permlist = [[p] for p in self.perm] + [self.perm] + [[np.arange(self.Natoms)]]\n        if tol is None:\n            self.tol = (np.prod(self.boxvec)/self.Natoms)**(1./self.dim) * 1e-2\n        else:\n            self.tol = tol\n        self.maxdisps = maxdisps\n        ####\n        if maxd is None:\n            maxd = np.prod(self.boxvec)**(1./self.dim)/5.\n        self.setMaxDisplacment(maxd)\n        ###\n        if origin is None:\n            self.origin=np.zeros_like(self.boxvec)\n        else:\n            self.origin = np.asanyarray(origin)\n        self.minVals = self.origin - 0.5 * self.boxvec\n        self.maxVals = self.origin + 0.5 * self.boxvec\n    @classmethod\n    def calcWaveVectors(cls, n, p):\n        def setindex(inds):\n            out = [0]*n\n            for i in inds:\n                out[i] += 1\n            return out\n        def negIndices(out):\n            nonzero = [i for i, a in enumerate(out) if a!=0]\n            ret = [out]\n            for i in nonzero[1:]:\n                extend = []\n                for inds in ret:\n                    extend.append([-a if i==j else a for j, a in enumerate(inds)])\n                ret.extend(extend)\n            return ret\n        indices =  list(chain(*(negIndices(setindex(combin)) for r in range(1,p+1)\n                                for combin in combinations_with_replacement(range(n), r))))\n        return indices\n    @classmethod\n    def removeDuplicates(cls, disps, tol, *args):\n        n = len(disps)\n        triu = np.triu_indices(n,1)\n        dists = norm(disps[triu[0]]-disps[triu[1]], axis=1)\n        remove = (dists<tol).nonzero()[0]\n        tokeep = np.setdiff1d(np.arange(n), triu[1][remove])\n        if args:\n            return [disps[tokeep]] + [a[tokeep] for a in args]\n        else:\n            return disps[tokeep]\n    ##\n    def setMaxDisplacment(self, maxd):\n        # This routines calculates, for a given threshold distance move the set of\n        # starting displacements to calculate the MLE of the displacements.\n        self.n = int(np.ceil(self.boxvec.max()/maxd))\n        ps = np.array(self.calcWaveVectors(self.dim, self.n))\n        ks = 2.*np.pi/self.boxvec[None,:]*ps\n        absks = norm(ks, axis=1)\n        argsort = absks.argsort()\n        maxI = np.searchsorted(absks[argsort], 2.*np.pi/maxd)\n        self.ps = ps[argsort[:maxI]]\n        self.permps = np.r_[(self.ps,)*len(self.perm)]\n        self.absps = norm(self.ps, axis=1)\n        self.ks = ks[argsort[:maxI]]\n        self.permks = np.r_[(self.ks,)*len(self.perm)]\n        self.splits = np.diff(self.absps).nonzero()[0]+1\n        self.psplit = np.split(self.ps, self.splits)\n        maxp = int(np.ceil(self.absps.max()))\n        self.startDisps = np.array(list(product(*[xrange(-maxp, maxp+1)]*self.dim)),dtype=float)\n        self.startDisps *= 0.5 * self.boxvec[None,:] / self.absps.max()\n    ##\n    def FourierShift(self, pos1, pos2):\n        disps, logLikes = [np.concatenate(a) for a in\n                           zip(*[self.removeDuplicates(disp[:self.maxdisps], self.tol, likes[:self.maxdisps])\n                                 for disp, likes in ((d[like-like[0]<self.likeThresh],\n                                                      like[like-like[0]<self.likeThresh])\n                                 for d, like in (self.calcDispLogLike(pos1, pos2, self.startDisps, p)\n                                                 for p in self.permlist))])]\n        disps, logLikes = self.removeDuplicates(disps, self.tol, logLikes)\n        return disps, logLikes\n    ##\n    def calcDispLogLike(self, pos1, pos2, startDisps, perm=None):\n        startDisps = np.atleast_2d(startDisps)\n        if perm is None:\n            perm = [np.arange(len(pos1))]\n        nperm = len(perm)\n        C1s = [np.exp(-1j * (pos1[p,None,:] * self.ks[None,...]).sum(2))\n               for p in perm]\n        C2s = [np.exp(-1j * (pos2[p,None,:] * self.ks[None,...]).sum(2))\n               for p in perm]\n        C1 = np.concatenate([C.sum(0) for C in C1s])\n        C2 = np.concatenate([C.sum(0) for C in C2s])\n        absC1, absC2 = np.abs(C1), np.abs(C2)\n        angC1, angC2 = np.angle(C1), np.angle(C2)\n        theta = (angC1-angC2)\n        ## Estimating distribution of displacement vector\n        nk = len(self.ks)\n        Fs = [2*(np.abs(absC1[i*nk:(i+1)*nk] - absC2[i*nk:(i+1)*nk])).mean()+1e-6\n             for i in xrange(nperm)]\n        std = np.concatenate([F*(norm(self.ps,axis=1)**-3.+1.)\n                              for F in Fs])\n        absC1C2 = 2*(absC1**-1+absC2**-1)**-1\n        permks = np.r_[(self.ks,)*nperm]\n        stdk = std * norm(permks,axis=1) / absC1C2\n        fs = stdk**-2\n        ##\n        A = (permks[:,None,:]*permks[:,:,None]*fs[:,None,None]).sum(0)\n        invA = np.linalg.inv(A)\n        dtheta = theta[:,None]-permks.dot(startDisps.T)\n        dtheta -= np.round(dtheta / (2*np.pi)) * 2 * np.pi\n        disps = np.einsum(""jk,li,l,lk->ij"", invA, dtheta, fs, permks)\n        logLikes = (fs[:,None]*(permks.dot(disps.T)-dtheta)**2).sum(0) - np.log(stdk[:,None]).sum(0)\n        argsort = logLikes.argsort()\n        disps[:] = (startDisps+disps)[argsort]\n        logLikes[:] = logLikes[argsort]/nperm\n        disps -= np.round((disps-self.origin)/self.boxvec) * self.boxvec[None,:]\n        return disps, logLikes\n\n    def findDisps(self, pos1, pos2):\n        return self.FourierShift(pos1, pos2)[0]\n\n\nclass PeriodicAlign(BasePeriodicAlignment):\n    """"""\n    Finds the best alignment between two configurations of a periodic system\n\n    Parameters\n    ----------\n    Natoms : int\n    boxvec : array like floats\n        defines periodicity of system being aligned\n    permlist : sequence of arrays,optional\n        list of allowed permutations. If nothing is given, all atoms will be\n        considered as permutable.\n    scale : float, optional\n        determins the size of the Gaussian kernels, automatically set to be\n        1/3 of interatomic separation if not given\n    maxk : float, optional\n        the value of wavevector at which the calculation is truncated\n        the higher this is set the more accurate the overlap calculation\n    dim : int, optional\n        dimensionality of the system TODO: TEST\n    """"""\n    def __init__(self, Natoms, boxvec, permlist=None, dim=3,\n                 scale=None, n=None):\n        self.Natoms = Natoms\n        self.boxvec = np.array(boxvec, dtype=float)\n        self.dim = dim\n\n        if permlist is None:\n            self.perm = [np.arange(self.Natoms)]\n        else:\n            self.perm = map(np.array, permlist)\n        self.pos1 = np.zeros((self.Natoms, self.dim))\n        self.pos2 = np.zeros((self.Natoms, self.dim))\n\n        if scale is None:\n            scale = (np.prod(self.boxvec)/self.Natoms)**(1./self.dim)/3.\n\n        self.n = int(np.ceil(1.3*Natoms**(1./3.))) if n is None else n\n        self.scale = scale\n        self.factor = 2 * (np.pi*self.scale**2)**(-self.dim*0.5)*self.scale**2 / np.prod(self.boxvec)\n        self.setks()\n        self.setPos(self.pos1, self.pos2)\n\n    def setks(self):\n        ps = np.indices((self.n*2+1,)*self.dim) - self.n\n        self.ks = 2.*np.pi/self.boxvec[(slice(None),)+(None,)*self.dim]*ps\n        self.absks = norm(self.ks, axis=0)\n        self.C1 = np.empty((len(self.perm),)+self.absks.shape, dtype=complex)\n        self.C2 = np.empty((len(self.perm),)+self.absks.shape, dtype=complex)\n        self.C = np.empty_like(self.absks, dtype=np.complex128)\n        shape = np.array(self.C.shape)*2+1\n        self.fshape = tuple(_next_fast_len(int(d)) for d in shape)\n        self.f = np.empty(self.fshape, dtype=complex)\n        self.fabs = np.empty(self.fshape, dtype=float)\n\n    def setScale(self, scale):\n        self.scale = scale\n        self.factor = 2 * (np.pi*self.scale**2)**(-self.dim*0.5)*self.scale**2 / np.prod(self.boxvec)\n\n    def calcFourierCoeff(self, pos, out=None):\n        if out is None:\n            out = np.empty((len(self.perm),)+self.absks.shape, dtype=complex)\n        for p, C in izip(self.perm, out):\n            np.exp(-1j * np.tensordot(pos[p,:], self.ks, [1,0])).sum(0, out=C)\n            # C[(self.n,)*self.dim] = 0\n        return out\n\n    def setPos(self, pos1=None, pos2=None, Cs=None):\n        """""" Calculates Fourier coefficients and overlap arrays of two\n        structures, if pos1 or pos2 are not specified then uses the last\n        coordinates tested, ff the fourier coefficients have already been\n        calculated then these can be passed\n\n        Parameters\n        ----------\n        pos1 : (Natoms, 3) array_like\n            Coordinate array.\n        pos2 : (Natoms, 3) array_like\n            Coordinate array to align with pos1.\n        Cs : ((nperm,2*n+1,2*n+1,2*n+1), (nperm,2*n+1,2*n+1,2*n+1)) array_like,\n                optional\n            List/Tuple of the Fourier Coefficients of pos1 and pos2\n        """"""\n        if pos1 is not None:\n            self.pos1[:] = np.asanyarray(pos1)\n        if pos2 is not None:\n            self.pos2[:] = np.asanyarray(pos2)\n        if Cs is None:\n            self.calcFourierCoeff(self.pos1, self.C1)\n            self.calcFourierCoeff(self.pos2, self.C2)\n        else:\n            self.C1, self.C2 = Cs\n        self.Csum = (((self.C1*self.C1.conj()).real +\n                      (self.C2*self.C2.conj()).real) *\n                      np.exp(-self.absks[None,:]**2 *\n                      (self.scale**2))).real.sum() * 0.5 * self.factor\n        (self.C1 * self.C2.conj() *\n         np.exp(-self.absks**2 * (self.scale**2))).sum(0, out=self.C)\n        self.f[:] = np.fft.fftn(self.C, self.fshape)\n        np.abs(self.f, out=self.fabs)\n\n    def findDisps(self, pos1, pos2, Cs=None, npeaks=1, width=2):\n        self.setPos(pos1, pos2, Cs)\n        if npeaks > 1:\n            # Do Gaussian fit, fair bit slower!\n            disps = findPeaks(self.fabs, npeaks, width)[0]\n            if len(disps):\n                disps *= self.boxvec / self.fabs.shape\n            else:\n                disp = findMax(self.fabs) * self.boxvec / self.fabs.shape\n                disps = disp[None,:]\n            return disps\n        else:\n            # Do simple quadratic fit\n            disp = findMax(self.fabs) * self.boxvec / self.fabs.shape\n            return disp[None,:]\n\n    def align(self, pos1, pos2, Cs=None, npeaks=1, width=2):\n        disps = self.findDisps(pos1, pos2, Cs, npeaks, width)\n        return self.refine(self.pos1, self.pos2, disps)\n\n    def alignGroup(self, coords, keepCoords=False, npeaks=1, width=2):\n        n = len(coords)\n        if keepCoords:\n            aligned = np.empty((2, n, n, self.Natoms, self.dim))\n        coeffs = [self.calcFourierCoeff(p) for p in coords]\n        dists = np.zeros((n, n))\n        for i, (pos1, c1) in enumerate(izip(coords, coeffs)):\n            for j, (pos2, c2) in enumerate(izip(coords, coeffs)):\n                dist, x1, x2 = self.align(pos1, pos2, [c1,c2],\n                                          npeaks, width)[:3]\n                if keepCoords:\n                    aligned[0,i,j,...] = x1\n                    aligned[1,i,j,...] = x2\n                dists[i,j] = dist\n        if keepCoords:\n            return dists, aligned\n        else:\n            return dists\n\n\nclass PeriodicAlignFortran(BasePeriodicAlignment):\n    """""" Class for aligning two periodic structures in a cubic cell,\n    wrapper for FORTRAN subroutines to do the numerical heavy-lifting\n\n    Parameters:\n    ----------\n    Natoms : int\n        Number of atoms\n    boxVec : (3,) array_like\n        Lengths of the cubic super cell\n    scale : float, optional\n        The width of the Gaussian kernels, if left out, the Fortran subroutine\n        automatically calculates it.\n    permlist : sequence of arrays,optional\n        Each array in perm represents a different permutation group\n    """"""\n\n    def __init__(self, Natoms, boxVec=None, scale=0, perm=None):\n        self.Natoms = 1 if Natoms is None else Natoms\n        self.boxvec = np.array(boxVec, dtype=float)\n        self.scale = scale\n        self.fast = fastbulk\n        self.bulk = self.fast.bulkfastoverlap\n        if perm is None:\n            self.setPerm([np.arange(self.Natoms)])\n        else:\n            self.setPerm(perm)\n\n    def setPerm(self, perm):\n        if len(perm):\n            self.perm = perm\n            self.nperm = len(perm)\n            self.npermsize = map(len, perm)\n            self.permgroup = np.concatenate([np.asanyarray(p)+1\n                                             for p in perm])\n            self.Natoms = len(self.permgroup)\n        else:\n            self.nperm = 1\n            self.npermsize = [self.Natoms]\n            self.permgroup = np.arange(self.Natoms) + 1\n            self.perm = [self.permgroup]\n        self.fast.fastoverlaputils.setperm(self.Natoms, self.permgroup,\n                                           self.npermsize)\n\n    def align(self, pos1, pos2, ndisps=10, perm=None, ohcell=False, debug=False):\n        """""" Align two periodic structures, aligns and permutes pos2 to match\n        pos1 as closely as possible.\n\n        Parameters\n        ----------\n        pos1 : (Natoms, 3) array_like\n            Coordinate array.\n        pos2 : (Natoms, 3) array_like\n            Coordinate array to align with pos1.\n        ndisps : int, optional\n            Number of different displacements to test\n        perm : sequence of arrays, optional\n            Each array in perm represents a different permutation group\n        ohcell : bool\n            If true tests all 48 possible octahedral symmetries\n\n        Returns\n        -------\n        distance : float\n            Euclidean distance between X1 and X2\n        X1 : (Natoms, 3) array_like\n            Copy of pos1\n        X2 : (Natoms, 3) array_like\n            Aligned coordinates of pos2\n        perm : rank-1 array(\'i\') with bounds (Natoms)\n            This won\'t give the correct permutation!\n        """"""\n        coordsb = np.asanyarray(pos1).flatten()\n        coordsa = np.asanyarray(pos2).flatten()\n        if perm is not None:\n            self.setPerm(perm)\n        if coordsa.size != 3 * self.Natoms:\n            self.setPerm([np.arange(coordsa.size/3)])\n\n        self.fast.commons.ohcellt = ohcell\n        args = (coordsb, coordsa, debug,\n                self.boxvec[0], self.boxvec[1], self.boxvec[2],\n                self.scale, ndisps)\n        dist = self.fast.bulkfastoverlap.align(*args)[0]\n        perm = self.fast.commons.bestperm.copy()\n        return dist, coordsb.reshape(self.Natoms, 3),\\\n            coordsa.reshape(self.Natoms, 3), perm\n\n    def alignGroup(self, coords, ndisps=1):\n        """""" Aligns a list of coordinates with themselves,\n\n        Parameters\n        ----------\n        coords : (nlist, Natoms, 3) array_like\n            list of coordinates that are being compared\n        ndisps : int, optional\n            number of displacements to test, runtime approximately\n            proportional to ndisps\n\n        Returns\n        -------\n        dists : (nlist, nlist) array_like\n            Matrix of pair wise displacements\n            (only calculated for the upper half)\n            of the matrix\n        aligned : (Natoms, 3, nlist, nlist) array_like\n            Matrix of the aligned coordinates\n        """"""\n        coordslist = np.asanyarray(coords)\n        nlist, natoms, dim = coordslist.shape\n        assert dim == 3\n        assert natoms == self.Natoms\n        coordslist = coordslist.reshape(nlist, -1).T\n        s, nwave, ncoeff = self.bulk.calcdefaults(natoms, *self.boxvec)\n        if self.scale == 0:\n            scale = s\n        else:\n            scale = s\n        dists, aligned = self.bulk.aligngroup(\n            coordslist, coordslist, False,\n            self.boxvec[0], self.boxvec[1], self.boxvec[2],\n            scale, ndisps, nwave, ncoeff, True)\n        aligned = aligned.reshape(natoms, 3, nlist, nlist)\n        return dists, aligned\n\n\nif __name__ == ""__main__"":\n    print \'testing alignment on example data, distance should = 1.559\'\n    import os\n    import csv\n    datafolder = ""../examples/BLJ256""\n\n    def readFile(filename):\n        with open(filename, \'rb\') as f:\n            reader = csv.reader(f, delimiter=\' \')\n            dist = [map(float, row) for row in reader]\n        return np.array(dist)\n\n    pos1 = readFile(os.path.join(datafolder, \'coords\'))\n    pos2 = readFile(os.path.join(datafolder, \'finish\'))\n\n    natoms = 256\n    ntypeA = 204\n    shape = (natoms, 3)\n    boxSize = np.ones(3)*5.975206329\n    permlist = [np.arange(ntypeA), np.arange(ntypeA, natoms)]\n    overlap = PeriodicAlign(256, boxSize, permlist)\n    align = FourierAlign(256, boxSize, permlist)\n    if f90.have_fortran:\n        overlap_f = PeriodicAlignFortran(256, boxSize, perm=permlist)\n\n    print \'PeriodicAlign aligment:\', overlap(pos1, pos2)[0]\n    if f90.have_fortran:\n        print \'PeriodicAlignFortran aligment:\', overlap_f(pos1, pos2)[0]\n\n\nif False:\n    import timeit\n    print \'Timing python implementation\'\n    print timeit.timeit(""overlap(pos1, pos2)"",\n                        setup=""from __main__ import overlap, pos1, pos2"")\n    if have_fortran:\n        print \'Timing Fortran implementation\'\n        print timeit.timeit(""overlap_f.align(pos1, pos2,1)"",\n                            setup=\n                            ""from __main__ import overlap_f, pos1, pos2"")\n'"
fastoverlap/soft.py,17,"b'# -*- coding: utf-8 -*-\n\n""""""\n    FASTOVERLAP\n    Copyright (C) 2017  Matthew Griffiths\n    \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n    \n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n    \n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n    This code is a FORTRAN reimplementation of the SOFT C++ library from\n    http://www.cs.dartmouth.edu/~geelong/soft/ under the GNU GPL licence\n\n    Citation:\n    Kostelec, P. J., & Rockmore, D. N. (2008). FFTs on the rotation group. \n    Journal of Fourier Analysis and Applications, 14(2), 145\xe2\x80\x93179. \n    http://doi.org/10.1007/s00041-008-9013-5\n""""""\n\nimport numpy as np\n\nfrom numpy import sin, cos, sqrt, pi\nfrom scipy.special import eval_jacobi\n\ntry:\n    from scipy.special.basic import factorial\nexcept ImportError:\n    from scipy.misc import factorial\n\nclass SOFT(object):\n    """"""\n    Class for calculating the \n    Special Orthogonal group (SO(3)) Fourier Transform (SOFT)\n    This algorithm is based on the C++ library written by \n    \n    http://www.cs.dartmouth.edu/~geelong/soft/\n    """"""\n    def __init__(self, bw):\n        self.bw = bw\n        self.bws = np.arange(0, bw*2)\n        self.n = 2*bw\n        self.Jmax = bw-1\n        self.weights = self.makeweights(bw)\n        self.a = pi/bw * self.bws\n        self.b = pi/4/bw * (2*self.bws+1)\n        self.y = pi/bw * self.bws\n        self.Js, self.m1s, self.m2s = map(np.array, zip(*[(l,m1,m2) for l in xrange(self.Jmax+1) \n                                         for m1 in xrange(-l, l+1) \n                                         for m2 in xrange(-l, l+1)]))\n        self.Ds = self.calcWignerMatrices()\n        self.indFactor = np.array([2*pi/self.n, pi/self.n, 2*pi/self.n])\n    ##\n    @classmethod\n    def makeweights(cls, bw):\n        j = np.arange(0,2*bw).astype(float)[:,None]\n        k = np.arange(0,bw).astype(float)[None,:]\n        fudge = pi/4/bw\n        weights = (2/(2*k+1) * \n                   sin((2*j+1)*(2*k+1)*fudge) * \n                   sin((2*j+1)*fudge)/bw).sum(1)\n        return weights\n    ##\n    def calcWignerMatrices(self):\n        bw = self.bw\n        bws = self.bws\n        beta = self.b\n        sinb2 = sin(beta/2)\n        cosb2 = cos(beta/2)\n        cosb = cos(beta)\n        Js, m1s, m2s = self.Js, self.m1s, self.m2s\n        Dfull = np.zeros((bw, 2*bw-1, 2*bw-1, 2*bw))\n        mu = abs(m1s-m2s)\n        nu = abs(m1s+m2s)\n        s = Js - (mu + nu)/2\n        xi = np.ones_like(s)\n        xi[m2s<m1s] = (-1)**(m1s-m2s)[m2s<m1s]\n        factor = sqrt(factorial(s)*factorial(s+mu+nu)/\n                      factorial(s+mu)/factorial(s+nu)) * xi\n        jac = eval_jacobi(s[:,None], mu[:,None], nu[:,None],\n                     cosb[None,:])\n        Dfull[Js[:,None],m1s[:,None],m2s[:,None],\n              bws[None,:]] = (((2.*Js[:,None]+1.)/2.)**0.5 *\n                              factor[:,None] * jac *\n                              sinb2[None,:] ** mu[:,None] * \n                              cosb2[None,:] ** nu[:,None])\n        return Dfull\n    ##\n    def SOFT(self, data):\n        """"""\n        Compute forward transform\n        """"""\n        Jmax=self.Jmax\n        bw=self.bw\n        data = np.asanyarray(data)\n        assert all(n==self.n for n in data.shape)\n        S1 =  np.fft.fft(data, axis=0)\n        S2 = np.fft.fft(S1, axis=2) * (2.*bw)**-2\n        flmm = np.zeros((bw, bw*2 - 1, bw*2 - 1), np.complex128)\n        for m1 in xrange(-Jmax,Jmax+1):\n            for m2 in xrange(-Jmax,Jmax+1):\n                l = max(np.abs([m1,m2]))\n                flmm[l:,m1,m2] = self.Ds[l:,m1,m2].dot(self.weights*S2[m1,:,m2])\n        return flmm\n    ##\n    def iSOFT(self, flmm):\n        Jmax=self.Jmax\n        bw=self.bw\n        assert flmm.shape == (bw, bw*2 - 1, bw*2 - 1)\n        S2out = np.zeros((2*bw,2*bw,2*bw), np.complex128)\n        for m1 in xrange(-Jmax,Jmax+1):\n            for m2 in xrange(-Jmax,Jmax+1):\n                l = max(np.abs([m1,m2]))\n                S2out[m1,:,m2] = self.Ds[l:,m1,m2].T.dot(flmm[l:,m1,m2])\n        S1out = np.fft.ifft(S2out, axis=2)\n        return np.fft.ifft(S1out, axis=0) * (2*bw)**2\n    ##\n    def indtoEuler(self, ind):\n        R = self.indFactor * np.atleast_2d(ind)\n        R[:,1] += 0.5 * pi / self.n\n        return R.squeeze()\n'"
fastoverlap/sphericalAlignment.py,59,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Sun Feb 12 16:15:14 2017\n\n@author: mg542\n""""""\n\nimport numpy as np\nfrom itertools import izip\n\nfrom numpy import sin, cos, sqrt, pi, exp\nfrom numpy.linalg import norm\nfrom scipy.special import sph_harm, iv, eval_jacobi, gamma, hyp1f1\ntry:\n    from scipy.special.basic import factorial\nexcept ImportError:\n    from scipy.misc import factorial\nfrom scipy.optimize import minimize\n\nfrom utils import find_best_permutation, EulerM, coeffs_harmonicBasis,\\\nfindMax, findPeaks, findrotation, eval_grad_jacobi, calcThetaPhiR\n\nfrom soft import SOFT\n\nimport f90\nif f90.have_fastclusters:\n    fastclusters = f90.fastclusters\n\nclass BaseSphericalAlignment(object):\n    calcScale = True\n\n    def calcSO3Coeffs(self, pos1, pos2):\n        raise NotImplementedError\n\n    def averageSeparation(self, pos):\n        pos = np.asanyarray(pos).reshape(-1,3)\n        triu = np.triu_indices(len(pos), 1)\n        dists = np.linalg.norm(pos[triu[0]] - pos[triu[1]],axis=1)\n        closest = sum(dists[np.logical_or(triu[0]==i,triu[1]==i)].min()\n                      for i in xrange(len(pos)))\n        return closest/len(pos)\n\n    ##\n    def setJ(self, Jmax):\n        self.Jmax = Jmax\n        self.J = np.arange(Jmax+1)\n        ## Needed for Spherical Harmonic Calcualtion\n        self.Jinds = np.array([j for j in xrange(Jmax+1) for _ in xrange(-j, j+1)])\n        self.Minds = np.array([m for j in xrange(Jmax+1) for m in xrange(-j, j+1)])\n        self.soft = SOFT(Jmax+1)\n        ## Needed for Wigner Matrix Calculation\n        self.Js, self.m1s, self.m2s = map(np.array,\n                                          zip(*[(l,m1,m2) for l in xrange(Jmax+1)\n                                                for m1 in xrange(-l, l+1)\n                                                for m2 in xrange(-l, l+1)]))\n    ##\n    def sphHarm(self, theta, phi):\n        theta = np.atleast_1d(theta)\n        phi = np.atleast_1d(phi)\n        assert theta.shape == phi.shape\n        Y = np.zeros((self.Jmax+1, 2*self.Jmax+1)+theta.shape, np.complex128)\n        Y[self.Jinds,self.Minds] = sph_harm(self.Minds[:,None],\n                                            self.Jinds[:,None],\n                                            phi[None,:], theta[None,:])\n        return Y\n    ##\n    def calcWignerMatrices(self, rot):\n        a,b,y = rot\n        sinb2 = sin(b/2)\n        cosb2 = cos(b/2)\n        cosb = cos(b)\n        sinb = sin(b)\n        Jmax = self.Jmax\n        Js, m1s, m2s = self.Js, self.m1s, self.m2s\n        Ds = np.zeros((Jmax+1, 2*Jmax+1, 2*Jmax+1), np.complex128)\n        grad = np.zeros((3, Jmax+1, 2*Jmax+1, 2*Jmax+1), np.complex128)\n        mu = abs(m1s-m2s)\n        nu = abs(m1s+m2s)\n        s = Js - (mu + nu)/2\n        xi = np.ones_like(s)\n        xi[m2s<m1s] = (-1)**(m1s-m2s)[m2s<m1s]\n        factor = sqrt(factorial(s)*factorial(s+mu+nu)/\n                          factorial(s+mu)/factorial(s+nu)) * xi\n        jac = eval_jacobi(s, mu, nu, cosb)\n        d = (factor * jac * sinb2 ** mu * cosb2 ** nu)\n        ##\n        gradjac = eval_grad_jacobi(s, mu, nu, cosb) * - sinb\n        gradd = (factor * gradjac * sinb2 ** mu * cosb2 ** nu +\n                     factor * jac * sinb2 ** (mu-1) * cosb2 ** (nu+1) * mu/2 -\n                     factor * jac * sinb2 ** (mu+1) * cosb2 ** (nu-1) * nu/2)\n        ##\n        Ds[Js, m1s, m2s] = exp(-1j*m1s*a) * d * exp(-1j*m2s*y)\n        grad[0,Js, m1s, m2s] = -1j*m1s * Ds[Js, m1s, m2s]\n        grad[1,Js, m1s, m2s] = exp(-1j*m1s*a) * gradd * exp(-1j*m2s*y)\n        grad[2,Js, m1s, m2s] = -1j*m2s * Ds[Js, m1s, m2s]\n        return Ds, grad\n    ##\n    def getEnergyGradient(self, rot, Ilmm):\n        D, gradD = self.calcWignerMatrices(rot)\n        return -(Ilmm*D).real.sum(), -(Ilmm[None,...]*gradD).real.sum((1,2,3))\n    ##\n    def Hungarian(self, pos1, pos2, perm=None):\n        if perm is None:\n            if self.perm is None:\n                perm = [np.arange(len(pos1))]\n            else:\n                perm = self.perm\n        return find_best_permutation(pos1, pos2, permlist=perm)\n    ##\n    def maxOverlap(self, R, Ilmm):\n        res = minimize(self.getEnergyGradient, R, jac=True, args=(Ilmm,),\n                       method=\'L-BFGS-B\')\n        return res.x, res\n    ##\n    def rotate(self, X, R):\n        return X.dot(EulerM(*R))\n    ##\n    def refine(self, X1, X2, R, permlist=None):\n        if permlist is None:\n            if self.perm is None:\n                permlist = [np.arange(len(X1))]\n            else:\n                permlist = self.perm\n        X2 = np.dot(X2, EulerM(*R))\n        _, perm = self.Hungarian(X1, X2, permlist)\n        dist, MR = findrotation(X1, X2[perm])\n        return dist, X1, X2[perm].dot(MR.T)\n    ##\n    def COM_shift(self, pos1, pos2):\n        """"""\n        Center the centroid of the particle positions at the origin\n        """"""\n        X1 = np.array(pos1, float)\n        X2 = np.array(pos2, float)\n        X1 -= X1.mean(axis=0)[None,:]\n        X2 -= X2.mean(axis=0)[None,:]\n        return X1, X2\n    ##\n    def _align(self, pos1, pos2, perm=None, invert=True):\n        if perm is None:\n            if self.perm is None:\n                perm = [np.arange(len(pos1))]\n            else:\n                perm = self.perm\n        if self.calcScale:\n            self.scale = (self.averageSeparation(pos1) +\n                          self.averageSeparation(pos2))/6\n\n        X1, X2 = self.COM_shift(pos1, pos2)\n        Ilmm = sum(self.calcSO3Coeffs(X1[p], X2[p]) for p in perm)\n        R, res = self.findRotation(Ilmm)\n        if invert:\n            Ilmm = sum(self.calcSO3Coeffs(X1[p], -X2[p]) for p in perm)\n            invR, invres = self.findRotation(Ilmm)\n            if invres < res:\n                R = invR\n                X2 *= -1\n        return self.refine(X1, X2, R, perm)\n    ##\n    def align(self, pos1, pos2, perm=None, invert=True, calcCoeffs=None):\n        pos1 = np.asanyarray(pos1).reshape(-1,3)\n        pos2 = np.asanyarray(pos2).reshape(-1,3)\n\n        if self.calcScale:\n            self.scale = (self.averageSeparation(pos1) +\n                          self.averageSeparation(pos2))/6\n        if perm is None:\n            if self.perm is None:\n                perm = [np.arange(len(pos1))]\n            else:\n                perm = self.perm\n\n        X1, X2 = self.COM_shift(pos1, pos2)\n        if calcCoeffs is None:\n            Ilmm = sum(self.calcSO3Coeffs(X1[p], X2[p]) for p in perm)\n        else:\n            Ilmm = calcCoeffs(False)\n        R, res = self.findRotation(Ilmm)\n        if invert:\n            if calcCoeffs is None:\n                Ilmm = sum(self.calcSO3Coeffs(X1[p], -X2[p]) for p in perm)\n            else:\n                Ilmm = calcCoeffs(True)\n            invR, invres = self.findRotation(Ilmm)\n            if invres < res:\n                R = invR\n                X2 *= -1\n        return self.refine(X1, X2, R, perm)\n    ##\n    def findRotation(self, Ilmm):\n        overlap = self.soft.iSOFT(Ilmm)\n        R = self.soft.indtoEuler(findMax(overlap))\n        R, res = self.maxOverlap(R, Ilmm.conj())\n        return R, res.fun\n    ##\n    def findRotations(self, Ilmm, nrot=10, width=2):\n        overlap = self.soft.iSOFT(Ilmm).real\n        peaks = []\n        while len(peaks)==0:\n            peaks, amplitude, mean, sigma, f = findPeaks(overlap,\n                                                         npeaks=nrot,\n                                                         width=width)\n            width += 1\n        return np.atleast_2d(self.soft.indtoEuler(peaks)), amplitude, mean, sigma, f\n    ##\n    def malign(self, pos1, pos2, perm=None, invert=True, calcCoeffs=None, nrot=10):\n\n        if self.calcScale:\n            self.scale = (self.averageSeparation(pos1) +\n                          self.averageSeparation(pos2))/6\n        if perm is None:\n            if self.perm is None:\n                perm = [np.arange(len(pos1))]\n            else:\n                perm = self.perm\n\n        X1, X2 = self.COM_shift(pos1, pos2)\n        if calcCoeffs is None:\n            Ilmm = sum(self.calcSO3Coeffs(X1[p], X2[p]) for p in perm)\n        else:\n            Ilmm = calcCoeffs(False)\n        Rs = self.findRotations(Ilmm, nrot)[0]\n        dist, rX1, rX2 = min((self.refine(X1, X2, R, perm) for R in Rs),\n                             key=lambda x: x[0])\n        if invert:\n            if calcCoeffs is None:\n                Ilmm = sum(self.calcSO3Coeffs(X1[p], -X2[p]) for p in perm)\n            else:\n                Ilmm = calcCoeffs(True)\n            Rs = self.findRotations(Ilmm, nrot)[0]\n            idist, iX1, iX2 = min((self.refine(X1, X2, R, perm) for R in Rs),\n                                  key=lambda x: x[0])\n            if idist<dist:\n                return idist, iX1, iX2\n        return dist, rX1, rX2\n    ##\n    def __call__(self, pos1, pos2, perm=None, invert=True, calcCoeffs=None, \n\t\t\t\t nrot=10, niter=None):\n        dist, X1, X2 = self.align(pos1, pos2, perm, invert, calcCoeffs)\n        if (norm(X1-X2,axis=1)>self.scale).sum() > len(X1)/3:\n            try:\n                mdist, mX1, mX2 = self.malign(pos1, pos2, perm, invert, calcCoeffs, nrot)\n                if mdist < dist:\n                    return mdist, mX1, mX2\n            except:\n                pass\n        return dist, X1, X2\n\n\nclass SphericalAlign(BaseSphericalAlignment):\n    def __init__(self, scale=None, Jmax=15, perm=None):\n        if scale is not None:\n            self.scale = scale\n            self.calcScale = False\n        else:\n            self.calcScale = True\n        self.setJ(Jmax)\n        self.perm = perm\n    ##\n    def calcSO3Coeffs(self, pos1, pos2):\n        pos1 = np.atleast_2d(pos1)\n        pos2 = np.atleast_2d(pos2)\n        assert pos1.shape == pos2.shape\n        theta1, phi1, r1 = calcThetaPhiR(pos1)\n        Y1 = self.sphHarm(theta1, phi1)\n        ##\n        theta2, phi2, r2 = calcThetaPhiR(pos2)\n        Y2 = self.sphHarm(theta2, phi2).conj()\n        r1r2 = r1[:,None]*r2[None,:]/self.scale**2/2\n        il = iv(np.arange(self.Jmax+1)[:,None,None] + 0.5, r1r2[None,...])\n        il *= np.sqrt(pi/2/r1r2[None,...])\n        il *= exp(-(r1[None,:,None]**2+r2[None,None,:]**2)/4/self.scale**2)\n        return np.einsum(""ijk,ilj,imk->ilm"",il,Y1,Y2) * 4 * np.pi**2.5 * self.scale**3\n\n\nclass SphericalHarmonicAlign(BaseSphericalAlignment):\n    def __init__(self, scale=None, harmscale=1.0, nmax=15, Jmax=15, perm=None):\n        if scale is not None:\n            self.scale = scale\n            self.calcScale = False\n        else:\n            self.calcScale = True\n        self.harmscale = harmscale\n        self.setCoeffs(nmax, Jmax, harmscale)\n        self.perm = perm\n    ##\n    @classmethod\n    def radialIntegralHarmonic(cls, n,l,rj,sigma,r0):\n        """"""\n        Returns the result of the integral,\n        \\int_0^{\\infty} \\exp{\\left(-\\frac{r^2+{r_j}^2}{2\\sigma^2}\\right)}\n                        \\exp{\\left(-\\frac{r^2}{2r_0^2}\\right)}\n                        i_l \\left( \\frac{r r_{j}}{\\sigma^2} \\right) r^n r^2\n                        \\; \\mathrm{d}r\n        """"""\n        return ((2.**(3+n-l)*pi**3)**0.5 * rj**l *\n                (sigma**-2 + r0**-2)**(-0.5*(3+n+l)) * sigma**(-2*l) *\n                hyp1f1(0.5*(3+n+l),1.5+l,0.5* rj**2 *r0**2/(r0**2 * sigma**2 +sigma**4)) *\n                gamma(0.5*(3 + l + n))/gamma(1.5+l)) * exp(-0.5*rj**2*sigma**-2)\n    ##\n    @classmethod\n    def HarmInt(cls, n, l, r0):\n        """"""\n        Gives the result of the integral\n        \\int_0^{\\infty}\n        N_{nl} r^l \\exp{\\left(-\\frac{r^2}{2r^2_0}\\right)}\n        L^{l+1/2}_n\\left(\\frac{r^2}{r^2_0}\\right)\n        \\; \\mathrm{d}r\n        """"""\n        coeffs = coeffs_harmonicBasis(n, l, r0)\n        ns = np.arange(2*n+l+1)\n        intn =  gamma(0.5*(ns+3)) * 2**(0.5*(ns+1)) * r0**(3+ns)\n        return coeffs.dot(intn)\n    ##\n    @classmethod\n    def HarmCoeffs(cls, nmax, lmax, r0):\n        coeffs = np.zeros((nmax+1, lmax+1, 2*nmax+lmax+1))\n        for n in xrange(nmax+1):\n            for l in xrange(lmax+1):\n                coeffs[n,l,:2*n+l+1] = coeffs_harmonicBasis(n,l,r0)\n        return coeffs\n    ##\n    @classmethod\n    def HarmInts(cls, nmax, lmax, r0):\n        coeffs = cls.HarmCoeffs(nmax, lmax, r0)\n        ns = np.arange(2*nmax+lmax+1)\n        intn =  gamma(0.5*(ns+3)) * 2**(0.5*(ns+1)) * r0**(3+ns)\n        return coeffs.dot(intn)\n    ##\n    def setCoeffs(self, nmax=None, Jmax=None, harmscale=None):\n        if nmax is None:\n            nmax = self.nmax\n        else:\n            self.nmax = nmax\n        if Jmax is None:\n            Jmax = self.Jmax\n        else:\n            self.setJ(Jmax)\n        if harmscale is None:\n            harmscale = self.harmscale\n        else:\n            self.harmscale = harmscale\n        self.coeffs = self.HarmCoeffs(nmax, Jmax, harmscale)\n    ##\n    def calcHarmCoeff(self, pos):\n        """"""\n        Returns the harmonic basis coefficients for a set of gaussians\n        at positions specified by pos, with widths set by self.scale and the\n        lengthscale of the harmonic basis set by self.harmonicscale\n        """"""\n        theta, phi, r = calcThetaPhiR(pos)\n        Y = self.sphHarm(theta, phi)\n        dslj = self.radialIntegralHarmonic(np.arange(2*self.nmax+\n                                                     self.Jmax+1)[:,None,None],\n                                           self.J[None,:,None],\n                                           r[None,None,:],\n                                           self.scale,\n                                           self.harmscale)\n        dnlj = np.einsum(""nls,slj->nlj"",self.coeffs, dslj)\n        cnlm = np.einsum(""nlj,lmj->nlm"", dnlj, Y.conj())\n        return cnlm\n    ##\n    def calcSO3Coeffs(self, pos1, pos2):\n        c1nlm = self.calcHarmCoeff(pos1)\n        c2nlm = self.calcHarmCoeff(pos2)\n        return np.einsum(""nlm,nlo->lmo"", c1nlm.conj(), c2nlm)\n    ##\n    def calcSO3Harm(self, c1nlms, c2nlms, invert=False):\n        if invert:\n            c2nlms = (c2*(-1)**self.J[None,:,None] for c2 in c2nlms)\n        return sum( np.einsum(""nlm,nlo->lmo"", c1.conj(), c2)\n                    for c1, c2 in izip(c1nlms, c2nlms))\n    ##\n    def _align(self, pos1, pos2, perm=None, invert=True, cnlms=None):\n        X1, X2 = self.COM_shift(pos1, pos2)\n        if perm is None:\n            if self.perm is None:\n                perm = [np.arange(len(pos1))]\n            else:\n                perm = self.perm\n        if cnlms is None:\n            c1nlms = [self.calcHarmCoeff(X1[p]) for p in perm]\n            c2nlms = [self.calcHarmCoeff(X2[p]) for p in perm]\n        else:\n            c1nlms, c2nlms = cnlms\n        Ilmm = self.calcSO3Harm(c1nlms, c2nlms)\n        R, res = self.findRotation(Ilmm)\n        if invert:\n            c2nlms = [c2*(-1)**self.J[None,:,None] for c2 in c2nlms]\n            Ilmm = self.calcSO3Harm(c1nlms, c2nlms)\n            invR, invres = self.findRotation(Ilmm)\n            if invres < res:\n                R = invR\n                X2 *= -1\n        return self.refine(X1, X2, R, perm)\n    ##\n    def alignGroup(self, coords, keepCoords=False):\n        n = len(coords)\n        if keepCoords:\n            aligned = np.empty((2, n, n) + coords[0].shape)\n        coeffs = [[self.calcHarmCoeff(p)] for p in coords]\n        dists = np.zeros((n, n))\n        for i, (pos1, c1) in enumerate(izip(coords, coeffs)):\n            for j, (pos2, c2) in enumerate(izip(coords, coeffs)):\n                calcCoeffs = lambda b: self.calcSO3Harm(c1, c2, b)\n                dist, x1, x2 = self.align(pos1, pos2, calcCoeffs=calcCoeffs)[:3]\n                if keepCoords:\n                    aligned[0,i,j,...] = x1\n                    aligned[1,i,j,...] = x2\n                dists[i,j] = dist\n        if keepCoords:\n            return dists, aligned\n        else:\n            return dists\n\nclass VarSphericalHarmonicAlign(SphericalHarmonicAlign):\n    def __init__(self, scale, harmscale=1.0, nmax=15, Jmax=7, perm=None):\n        self.scale = scale\n        self.harmscale = harmscale\n        self.setCoeffs(nmax, Jmax, harmscale)\n        self.perm = perm\n    ##\n    def calcHarmCoeff(self, pos):\n        """"""\n        Returns the harmonic basis coefficients for a set of gaussians\n        at positions specified by pos, with widths set by self.scale and the\n        lengthscale of the harmonic basis set by self.harmonicscale\n        """"""\n        theta, phi, r = calcThetaPhiR(pos)\n        Y = self.sphHarm(theta, phi)\n        scale = self.scale * r\n        dslj = self.radialIntegralHarmonic(np.arange(2*self.nmax+\n                                                     self.Jmax+1)[:,None,None],\n                                           self.J[None,:,None],\n                                           r[None,None,:],\n                                           scale[None,None,:],\n                                           self.harmscale) ** scale[None,None,:]**-0.5\n        cnlm = np.einsum(""nls,slj,lmj->nlm"",self.coeffs, dslj, Y.conj())\n        return cnlm\n\nclass SphericalAlignFortran(BaseSphericalAlignment):\n    """""" Class for aligning two isolated structures, wrapper for FORTRAN\n    subroutines to do the numerical heavy-lifting\n\n    Parameters:\n    ----------\n    scale : float, optional\n        The width of the Gaussian kernels.\n    Jmax : int, optional\n        Specifies the maximum angular momentum degree up to which SO(3) coefficients\n        will be calculated\n    permlist : sequence of arrays, optional\n        Each array in perm represents a different permutation group\n    Natoms : int, optional\n        Number of atoms\n\n    Notes:\n    ---------\n\n    Be very careful about setting perm/Natoms, as if this is not properly set\n    then you will get segfaults. Also be careful about using this object in\n    tandem\n    """"""\n    def __init__(self, scale=0.3, Jmax=15, perm=None, Natoms=None):\n        self.scale=scale\n        self.Jmax=Jmax\n        self.fast = fastclusters\n        self.Natoms = Natoms\n        if perm is not None:\n            self.setPerm(perm)\n        elif Natoms is not None:\n            self.setPerm(perm)\n        else:\n            self.perm = perm\n        self.malign = self.__call__\n    ##\n    def setPerm(self, perm):\n        self.Natoms = sum(map(len,perm))\n        self.perm = perm\n        self.nperm = len(perm)\n        self.npermsize = map(len, perm)\n        self.permgroup = np.concatenate([np.asanyarray(p)+1 for p in perm])\n        self.fast.fastoverlaputils.setperm(self.Natoms, self.permgroup, self.npermsize)\n    ##\n#    def malign(self, pos1, pos2, perm=None, invert=False, nrot=10, debug=False):\n#        return self(pos1, pos2, perm, invert, nrot, debug)\n    ##\n    def align(self, pos1, pos2, perm=None, invert=True, debug=False):\n        return self(pos1, pos2, perm, invert, 1, debug)\n    ##\n    def __call__(self, pos1, pos2, perm=None, invert=True, nrot=10, debug=False):\n        """""" Aligns two isolated structures, aligns and permutes pos2 to match\n        pos1 as closely as possible. Returns the distance between the aligned\n        structures, and the rotated and centred coordinates of the two structures\n\n        Parameters\n        ----------\n        pos1 : (Natoms, 3) array_like\n            Coordinate array.\n        pos2 : (Natoms, 3) array_like\n            Coordinate array to align with pos1.\n        nrot : int, optional\n            Number of different displacements to test\n        perm : sequence of arrays, optional\n            Each array in perm represents a different permutation group\n        invert : bool\n            If true tests inverted configurations as well\n        debug : bool, optional\n            If true prints debug information\n\n        Returns\n        -------\n        distance : float\n            Euclidean distance between X1 and X2\n        X1 : (Natoms, 3) array\n            pos1 centred on the origin\n        X2 : (Natoms, 3) array\n            Aligned coordinates of pos2\n        rmatbest : (3,3) array\n            the rotation matrix that maps centred pos2 onto X2\n        """"""\n        if perm is not None:\n            self.setPerm(perm)\n        elif len(pos1) != self.Natoms:\n            self.Natoms = len(pos1)\n            self.setPerm([np.arange(self.Natoms)])\n\n        coordsb = np.asanyarray(pos1).flatten()\n        coordsa = np.asanyarray(pos2).flatten()\n        self.fast.commons.perminvopt = invert\n        args = (coordsb,coordsa,debug,self.Jmax,self.scale,nrot)\n        dist, _, rmatbest = self.fast.clusterfastoverlap.align(*args)\n        return dist, coordsb.reshape(self.Natoms,3), coordsa.reshape(self.Natoms,3), rmatbest\n\nclass SphericalHarmonicAlignFortran(BaseSphericalAlignment):\n    """""" Class for aligning two isolated structures, wrapper for FORTRAN\n    subroutines to do the numerical heavy-lifting\n\n    Parameters:\n    ----------\n    scale : float, optional\n        The width of the Gaussian kernels.\n    Jmax : int, optional\n        Specifies the maximum angular momentum degree up to which SO(3) coefficients\n        will be calculated\n    permlist : sequence of arrays, optional\n        Each array in perm represents a different permutation group\n    Natoms : int, optional\n        Number of atoms\n    """"""\n    def __init__(self, scale=0.3, Jmax=15, harmscale=1.0, nmax=20, perm=None, Natoms=None):\n        self.scale=scale\n        self.Jmax=Jmax\n        self.harmscale=harmscale\n        self.nmax=nmax\n        self.fast = fastclusters\n        self.clus = fastclusters.clusterfastoverlap\n        self.Natoms = Natoms\n        if perm is not None:\n            self.setPerm(perm)\n        elif Natoms is not None:\n            self.setPerm(perm)\n        else:\n            self.perm = perm\n        self.malign = self.__call__\n    ##\n    def setPerm(self, perm):\n        self.Natoms = sum(map(len,perm))\n        self.perm = perm\n        self.nperm = len(perm)\n        self.npermsize = map(len, perm)\n        self.permgroup = np.concatenate([np.asanyarray(p)+1 for p in perm])\n        self.fast.fastoverlaputils.setperm(self.Natoms, self.permgroup, self.npermsize)\n    ##\n    def align(self, pos1, pos2, perm=None, invert=True, debug=False):\n        return self(pos1, pos2, perm, invert, 1, debug)\n    ##\n    def __call__(self, pos1, pos2, perm=None, invert=True, nrot=10, debug=False):\n        """""" Aligns two isolated structures, aligns and permutes pos2 to match\n        pos1 as closely as possible. Returns the distance between the aligned\n        structures, and the rotated and centred coordinates of the two structures\n\n        Parameters\n        ----------\n        pos1 : (Natoms, 3) array_like\n            Coordinate array.\n        pos2 : (Natoms, 3) array_like\n            Coordinate array to align with pos1.\n        nrot : int, optional\n            Number of different displacements to test\n        perm : sequence of arrays, optional\n            Each array in perm represents a different permutation group\n        invert : bool\n            If true tests inverted configurations as well\n        debug : bool, optional\n            If true prints debug information\n\n        Returns\n        -------\n        distance : float\n            Euclidean distance between X1 and X2\n        X1 : (Natoms, 3) array\n            pos1 centred on the origin\n        X2 : (Natoms, 3) array\n            Aligned coordinates of pos2\n        rmatbest : (3,3) array\n            the rotation matrix that maps centred pos2 onto X2\n        """"""\n        if perm is not None:\n            self.setPerm(perm)\n        elif len(pos1) != self.Natoms:\n            self.Natoms = len(pos1)\n            self.setPerm([np.arange(self.Natoms)])\n\n        coordsb = np.asanyarray(pos1).flatten()\n        coordsa = np.asanyarray(pos2).flatten()\n        self.fast.commons.perminvopt = invert\n        args = (coordsb,coordsa,debug,self.nmax,self.Jmax,self.harmscale,self.scale,nrot)\n        dist, _, rmatbest = self.clus.alignharm(*args)\n        return dist, coordsb.reshape(self.Natoms,3), coordsa.reshape(self.Natoms,3), rmatbest\n    ##\n    def compareList(self, poslist, perm=None):\n        """""" Calculates the maximum and average overlap of a list of coordinates\n\n        Parameters\n        ----------\n        poslist : (nlist, Natoms, 3) array_like\n            list of coordinates that are being compared\n        perm : sequence of arrays, optional\n            Each array in perm represents a different permutation group\n\n        Returns\n        -------\n        avgoverlap : (nlist,nlist) array\n            Array storing the array of average overlaps of the poslist\n        maxoverlap : (nlist,nlist) array\n            Array storing the array of maximum overlaps of the poslist\n        navgoverlap : (nlist,nlist) array\n            geometric mean normalised avgoverlap so,\n            navgoverlap[i,j] = avgoverlap[i,j]/sqrt(avgoverlap[i,i]*avgoverlap[j,j])\n        nmaxoverlap : (nlist,nlist) array\n            geometric mean normalised avgoverlap so,\n            nmaxoverlap[i,j] = maxoverlap[i,j]/sqrt(maxoverlap[i,i]*maxoverlap[j,j])\n        """"""\n        coords = np.array(poslist)\n        nlist, Natoms, dim = coords.shape\n        assert dim == 3\n        if perm is None:\n            if Natoms != self.Natoms:\n                self.Natoms = Natoms\n                self.setPerm([np.arange(self.Natoms)])\n        else:\n            self.setPerm(perm)\n        # Center coordinates\n        coords -= coords.mean(1)[:,None,:]\n        coordslist = np.rollaxis(coords.reshape(nlist,-1),-1)\n        avgoverlap, maxoverlap = self.clus.calcoverlapmatrices(\n            coordslist,self.nmax,self.Jmax,self.harmscale,self.scale)\n        diagavg = avgoverlap.diagonal()\n        diagmax = maxoverlap.diagonal()\n        navgoverlap = avgoverlap / sqrt(diagavg[:,None]*diagavg[None,:])\n        nmaxoverlap = maxoverlap / sqrt(diagmax[:,None]*diagmax[None,:])\n        return avgoverlap, maxoverlap, navgoverlap, nmaxoverlap\n\n\n\nif __name__ == ""__main__"":\n    import os\n    import csv\n    datafolder = ""../examples/LJ38""\n    def readFile(filename):\n        with open(filename, \'rb\') as f:\n            reader = csv.reader(f, delimiter=\' \')\n            dist = [map(float, row) for row in reader]\n        return np.array(dist)\n\n    pos1 = readFile(os.path.join(datafolder, \'coords\'))\n    pos2 = readFile(os.path.join(datafolder, \'finish\'))\n\n    natoms = 38\n    scale = 0.3\n    Jmax = 14\n    Nmax = 20\n    harmscale = 1.0\n\n    soap = SphericalAlign(scale, Jmax)\n    harm = SphericalHarmonicAlign(scale, harmscale, Nmax, Jmax)\n    if f90.have_fortran:\n        soapf = SphericalAlignFortran(scale, Jmax)\n        harmf = SphericalHarmonicAlignFortran(scale, Jmax=Jmax, harmscale=harmscale, nmax=Nmax)\n\n    print \'testing alignment on example LJ38 data, distance should = 1.4767\'\n    print \'SphericalAlign                Alignment:\', soap(pos1, pos2)[0]\n    print \'SphericalHarmonicAlign        Alignment:\', harm(pos1, pos2)[0]\n    if f90.have_fortran:\n        print \'SphericalAlignFortran         Alignment:\', soapf(pos1, pos2)[0]\n        print \'SphericalHarmonicAlignFortran Alignment:\', harmf(pos1, pos2)[0]\n\n    print \'\'\n    print \'Checking inversion isomers\'\n\n    print \'SphericalAlign                Alignment:\', soap(pos1, -pos2)[0]\n    print \'SphericalHarmonicAlign        Alignment:\', harm(pos1, -pos2)[0]\n    if f90.have_fortran:\n        print \'SphericalAlignFortran         Alignment:\', soapf(pos1, -pos2)[0]\n        print \'SphericalHarmonicAlignFortran Alignment:\', harmf(pos1, -pos2)[0]\n\n    ###########################################################################\n\n    print \'\'\n    print \'testing alignment on randomly generated data, distance should ~ 0\'\n    # Testing on synthetic data\n    rot = np.random.random((3,)) * np.array([2*pi, pi, 2*pi])\n    rotM = EulerM(*rot)\n    pos3 = np.random.normal(size=(50,3))*2\n    pos3 -= pos3.mean(0)[None,:]\n    pos4 = pos3.dot(rotM.T)\n\n    print \'SphericalAlign                Alignment:\', soap(pos3, pos4)[0]\n    print \'SphericalHarmonicAlign        Alignment:\', harm(pos3, pos4)[0]\n    if f90.have_fortran:\n        print \'SphericalAlignFortran         Alignment:\', soapf(pos3, pos4)[0]\n        print \'SphericalHarmonicAlignFortran Alignment:\', harmf(pos3, pos4)[0]\n\n    print \'\'\n    print \'Checking inversion isomers\'\n\n    print \'SphericalAlign                Alignment:\', soap(pos3, -pos4)[0]\n    print \'SphericalHarmonicAlign        Alignment:\', harm(pos3, -pos4)[0]\n    if f90.have_fortran:\n        print \'SphericalAlignFortran         Alignment:\', soapf(pos3, -pos4)[0]\n        print \'SphericalHarmonicAlignFortran Alignment:\', harmf(pos3, -pos4)[0]\n\n    print \'\'\n    print \'Comparing rotation angles, Euler angles:\'\n    print rot\n    print \'Rotation matrix:\'\n    print rotM.T\n    soft = SOFT(Jmax+1)\n    res = soap.calcSO3Coeffs(pos3, pos4)\n    fout = soft.iSOFT(res).real\n    R = soft.indtoEuler(findMax(fout))\n    print \'Euler angles from obtained from SOFT\'\n    print R\n    if f90.have_fortran:\n        print \'Rotation matrix from minpermdist\'\n        print soapf(pos3, -pos4)[3]\n\n#if  __name__ == \'__main__\':\n#    scale = 0.3\n#    Jmax = 7\n#    Nmax = 15\n#    rot = np.random.random((3,)) * np.array([2*pi, pi, 2*pi])\n#    pos1 = np.random.normal(size=(60,3))*2\n#    pos1 -= pos1.mean(0)[None,:]\n#    pos2 = pos1.dot(EulerM(*rot).T)\n#    #\n#    soap = SphericalAlign(scale, Jmax)\n#    harm = SphericalHarmonicAlign(scale, 1.0, Nmax, Jmax)\n#    if have_fortran:\n#        soapf = SphericalAlignFortran(scale, Jmax)\n#        harmf = SphericalHarmonicAlignFortran(scale, Jmax=Jmax, harmscale=1.0, nmax=Nmax)\n#    soft = SOFT(Jmax+1)\n#    # res = soap.calcCoeff(pos1, pos2)\n#    # fout = soft.iSOFT(res.conj()).real\n#    res = soap.calcSO3Coeffs(pos1, pos2)\n#    fout = soft.iSOFT(res).real\n#    R = soft.indtoEuler(findMax(fout))\n#    print rot, R\n#    #\n#    print soap(pos1, pos2)[0], harm(pos1, pos2)[0]\n#    print soap(pos1, -pos2)[0], harm(pos1, -pos2)[0]\n'"
fastoverlap/sphericalFourierAlignment.py,9,"b'# -*- coding: utf-8 -*-\r\n\r\nimport numpy as np\r\nfrom itertools import izip\r\n\r\nfrom scipy import (sin, cos, sqrt, pi, exp, arange, zeros, float32)\r\nfrom numpy.linalg import norm\r\nfrom scipy.special import sph_harm, gamma, jn_zeros, jn#, spherical_jn\r\ntry:\r\n    from scipy.special.basic import factorial\r\nexcept ImportError:\r\n    from scipy.misc import factorial\r\nfrom scipy.optimize import minimize, brentq\r\n\r\nfrom utils import find_best_permutation, EulerM, coeffs_harmonicBasis,\\\r\nfindMax, findPeaks, findrotation, eval_grad_jacobi, calcThetaPhiR\r\n    \r\nfrom soft import SOFT\r\n\r\nfrom sphericalAlignment import BaseSphericalAlignment, SphericalAlign,\\\r\n    SphericalHarmonicAlign\r\n\r\ndef spherical_jn(n, z):\r\n    return sqrt(pi/z/2) * jn(n+0.5,z)\r\n\r\ndef spherical_jn_zeros(n,nt):\r\n  zerosj = zeros((n+1, nt), dtype=float32)\r\n  zerosj[0] = arange(1,nt+1)*pi\r\n  points = arange(1,nt+n+1)*pi\r\n  racines = zeros(nt+n, dtype=float32)\r\n  Jn = lambda r, n: spherical_jn(n, r)\r\n  for i in xrange(1,n+1):\r\n    for j in xrange(nt+n-i):\r\n      foo = brentq(Jn, points[j], points[j+1], (i,))\r\n      racines[j] = foo\r\n    points = racines\r\n    zerosj[i][:nt] = racines[:nt]\r\n  return (zerosj)\r\n\r\nclass SphericalFourierAlign(BaseSphericalAlignment):\r\n    def __init__(self, scale, rcut=None, nmax=15, Jmax=15, perm=None):\r\n        self.scale = scale\r\n        self.nmax = nmax\r\n        self.Jmax = Jmax\r\n        self.rcut = rcut\r\n        if self.rcut is not None:\r\n            self.setCoeffs(nmax, Jmax, rcut)\r\n        self.perm = perm\r\n    \r\n    def setCoeffs(self, nmax=None, Jmax=None, rcut=None):\r\n        \r\n        if nmax is None:\r\n            nmax = self.nmax\r\n        else:\r\n            self.nmax = nmax\r\n            \r\n        if Jmax is None:\r\n            Jmax = self.Jmax\r\n        else:\r\n            self.setJ(Jmax)\r\n            \r\n        if rcut is None:\r\n            rcut = self.rcut\r\n        else:\r\n            self.rcut = rcut\r\n        \r\n        # zeros of the spherical bessel function\r\n        self.kln = spherical_jn_zeros(self.Jmax, self.nmax)\r\n        self.jn1 = spherical_jn(np.arange(1,self.nmax+1)[None,:], self.kln)\r\n        self.normf = (2*self.kln*self.rcut**-3*self.jn1**-2)**0.5\r\n        self.expksr = exp(- self.kln**2 * self.scale**2 / self.rcut**2 / 2)\r\n        \r\n    def calcFourierCoeffs(self, pos):\r\n        \r\n        theta, phi, r = calcThetaPhiR(pos)\r\n        Y = self.sphHarm(theta, phi)\r\n        \r\n        Clmn = ((2*self.scale**2)**(3/2) * \r\n                self.kln[:,None,:] * self.expksr[:,None,:] * \r\n                (spherical_jn(\r\n                        np.arange(self.Jmax + 1)[:,None,None], \r\n                        self.kln[:,:,None] * \r\n                        r[None,None,:] / self.rcut )[:,None,:,:] * \r\n                 Y[:,:,None,:]).sum(3) )\r\n        return Clmn\r\n        \r\n    def calcSO3Coeffs(self, pos1, pos2):\r\n        c1lmn = self.calcFourierCoeffs(pos1)\r\n        c2lmn = self.calcFourierCoeffs(pos2)\r\n        return np.einsum(""lmn,lon->lmo"", c1lmn, c2lmn.conj())\r\n\r\n    def calcSO3Harm(self, c1nlms, c2nlms, invert=False):\r\n        if invert:\r\n            c2nlms = (c2*(-1)**self.J[None,:,None] for c2 in c2nlms)\r\n        return sum( np.einsum(""nlm,nlo->lmo"", c1, c2.conj())\r\n                    for c1, c2 in izip(c1nlms, c2nlms))\r\n    \r\n    def alignGroup(self, coords, keepCoords=False):\r\n        n = len(coords)\r\n        if keepCoords:\r\n            aligned = np.empty((2, n, n) + coords[0].shape)\r\n        coeffs = [[self.calcHarmCoeff(p)] for p in coords]\r\n        dists = np.zeros((n, n))\r\n        for i, (pos1, c1) in enumerate(izip(coords, coeffs)):\r\n            for j, (pos2, c2) in enumerate(izip(coords, coeffs)):\r\n                calcCoeffs = lambda b: self.calcSO3Harm(c1, c2, b)\r\n                dist, x1, x2 = self.align(pos1, pos2, calcCoeffs=calcCoeffs)[:3]\r\n                if keepCoords:\r\n                    aligned[0,i,j,...] = x1\r\n                    aligned[1,i,j,...] = x2\r\n                dists[i,j] = dist\r\n        if keepCoords:\r\n            return dists, aligned\r\n        else:\r\n            return dists\r\n        \r\n        \r\n\r\nimport os\r\nimport csv\r\n\r\nimport matplotlib as mpl\r\nimport matplotlib.pyplot as plt\r\nfrom mpl_toolkits.mplot3d import Axes3D\r\n\r\nimport seaborn as sns\r\n\r\nplt.ion()\r\n\r\ndatafolder = ""../examples/LJ38""\r\ndef readFile(filename):\r\n    with open(filename, \'rb\') as f:\r\n        reader = csv.reader(f, delimiter=\' \')\r\n        dist = [map(float, row) for row in reader]\r\n    return np.array(dist)\r\n\r\npos1 = readFile(os.path.join(datafolder, \'coords\'))\r\npos2 = readFile(os.path.join(datafolder, \'finish\'))\r\n\r\nnatoms = 38\r\nscale = 0.3\r\nJmax = 14\r\nNmax = 20\r\nharmscale = 1.0\r\n\r\nsoap = SphericalAlign(scale, Jmax)\r\nharm = SphericalHarmonicAlign(scale, harmscale, Nmax, Jmax)\r\n\r\nrcut = 4.0\r\n\r\nfourier = SphericalFourierAlign(scale, rcut, 30, Jmax)\r\nself = fourier\r\n\r\nrs = np.linspace(0,5,256)\r\n\r\n#for l in xrange(self.Jmax):\r\n#    for n in xrange(self.nmax):\r\n#        plt.plot(rs, spherical_jn(l, self.kln[l,n] * rs / rcut))\r\n\r\nIlmm = soap.calcSO3Coeffs(pos1, pos2)\r\nhIlmm = harm.calcSO3Coeffs(pos1, pos2)\r\n\r\nc1lmn = self.calcFourierCoeffs(pos1)\r\nc2lmn = self.calcFourierCoeffs(pos2)\r\nfIlmm = np.einsum(""lmn,lon->lmo"", c1lmn, c2lmn.conj())\r\n\r\nfIlmm *= norm(Ilmm)/norm(fIlmm)\r\n\r\nprint norm(Ilmm-hIlmm)\r\n\r\n'"
fastoverlap/utils.py,46,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Wed Feb 15 19:06:01 2017\n\n@author: mg542\n""""""\nfrom itertools import izip\nfrom heapq import heappop, heappush\n\nimport numpy as np\nfrom numpy.linalg import norm\nfrom numpy import sin, cos, sqrt, pi, exp\nfrom scipy.special import eval_jacobi, gamma\nfrom scipy.special.orthogonal import genlaguerre, eval_genlaguerre\n\ntry:\n    from scipy.special.basic import factorial, comb\nexcept ImportError:\n    from scipy.misc import factorial, comb\n\n\nfrom scipy.optimize import curve_fit\n\n""""""\nTries to import code from pele:\nDocumentation: http://pele-python.github.io/pele/\n\nSource Code: https://github.com/pele-python/pele\n\nIf it can\'t import the code from pele, manually redefine needed functions\nthese functions are direct copies from pele\n""""""\n\n\n\ntry:\n    from pele.mindist.rmsfit import findrotation\n    from pele.mindist import find_best_permutation\n    \nexcept ImportError:\n    \n    import hungarian\n    def _make_cost_matrix(X1, X2):\n        """"""\n        return the cost matrix for use in the hungarian algorithm.\n        \n        the cost matrix is the distance matrix (squared) for all atoms \n        in atomlist\n        """"""\n        cost = (((X1[np.newaxis,:] - X2[:,np.newaxis,:])**2).sum(2))\n        return cost\n    \n    def find_permutations_hungarian( X1, X2, \n                                    make_cost_matrix=_make_cost_matrix ):\n        cost = make_cost_matrix(X1, X2)\n        #########################################\n        # run the hungarian algorithm\n        #########################################\n        newind1 = hungarian.lap(cost)\n        perm = newind1[1]\n        #########################################\n        # apply the permutation\n        #########################################\n        # TODO: how to get new distance?\n        dist = -1\n        return dist, perm\n        \n    def find_best_permutation(X1, X2, permlist=None, user_algorithm=None, \n                                 reshape=True, \n                                 user_cost_matrix=_make_cost_matrix,\n                                 **kwargs):\n        """"""\n        find the permutation of the atoms which minimizes the distance |X1-X2|\n        \n        With all the default parameters, findBestPermutation assumes that \n        X1, X2 are arrays of atoms in 3d space and performs reshaping on the \n        coordinates. However, if you want to pass a 2D system or a custom \n        array with own cost function, you can turn automatic reshaping off. \n        \n        Parameters\n        ----------\n        X1, X2 : \n            the structures to align\n        permlist : a list of lists\n            A list of lists of atoms which are interchangable.\n            e.g. for a 50/50 binary mixture::\n            \n                permlist = [range(1,natoms/2), range(natoms/2,natoms)]\n            \n            If permlist is None all atoms are assumed to be permutable.\n    \n        user_algoriithm : None or callable\n            you can optionally pass which algorithm to use.\n        gen_cost_matrix : None or callable\n            user function to generate the cost matrix\n        reshape : boolean\n            shall coordinate reshaping be performed.\n        box_lengths : float array\n            array of floats giving the box lengths for periodic boundary conditions.\n            Set to None for no periodic boundary conditions.\n        \n        Returns\n        -------\n        dist : float\n            the minimum distance WARNING: THIS IS NOT NECESSARILY CORRECT, IT SHOULD BE \n            RECALCULATED.  THIS WILL BE REMOVED IN THE FUTURE.\n        perm:\n            a permutation which will best align coords2 with coords1\n        \n        Notes\n        -----\n        For each list of interchangeable atoms in permlist the permutation\n        which minimizes the distance between the two structures is found.  This minimimization\n        is done by mapping the problem onto the linear assignment problem which can then be solved\n        using graph theoretic techniques.  \n        \n        http://en.wikipedia.org/wiki/Linear_assignment_problem\n        http://en.wikipedia.org/wiki/Hungarian_algorithm\n    \n        there are several packages in pypi which solve the linear assignment problem\n        \n        hungarian : c++ code wrapped in python.  scales roughly like natoms**2.5\n        \n        munkres : completely in python. scales roughly like natoms**3.  very slow for natoms > 10\n        \n        in addition we have wrapped the OPTIM version for use in pele.  It uses the sparse \n        version of the Jonker-Volgenant algorithm.  Furthermore the cost matrix calculated in \n        a compiled language for an additional speed boost. It scales roughly like natoms**2\n    \n        """"""\n        if reshape:\n            X1 = X1.reshape([-1,3])\n            X2 = X2.reshape([-1,3])\n        \n        if permlist is None:\n            permlist = [range(len(X1))]\n        \n        newperm = range(len(X1))\n        disttot = 0.\n        \n        for atomlist in permlist:\n            if len(atomlist) == 0:\n                continue\n            if user_algorithm is not None:\n                dist, perm = user_algorithm(X1[atomlist], X2[atomlist], make_cost_matrix=user_cost_matrix, **kwargs)\n            else:\n                dist, perm = find_permutations_hungarian(X1[atomlist], X2[atomlist], make_cost_matrix=user_cost_matrix, **kwargs)\n\n            disttot += dist**2\n            for atom, i in zip(atomlist,xrange(len(atomlist))):\n                newperm[atom] = atomlist[perm[i]]\n        dist = sqrt(disttot)\n        return dist, newperm\n\n    def findrotation(x1, x2, align_com=True):\n        """"""\n        Return the rotation matrix which aligns XB with XA\n        #\n        Return the matrix which\n        aligns structure XB to be as similar as possible to structure XA.\n        To be precise, rotate XB, so as to minimize the distance |XA - XB|.\n        #\n        Rotations will be done around the origin, not the center of mass\n        #\n        Rotational alignment follows the prescription of\n        Kearsley, Acta Cryst. A, 45, 208-210, 1989\n        http://dx.doi.org/10.1107/S0108767388010128\n        """"""\n        if x1.size != x2.size:\n            raise ValueError(""dimension of arrays does not match"")\n        # reshape the arrays\n        x1 = x1.reshape([-1,3]).copy()\n        x2 = x2.reshape([-1,3]).copy()\n        # determine number of atoms\n        natoms = x1.shape[0]\n        # set both com to zero\n        if align_com:\n            com1 = np.sum(x1,axis=0) / float(natoms)\n            com2 = np.sum(x2,axis=0) / float(natoms)\n            x1 -= com1\n            x2 -= com2\n        x1 = x1.ravel() \n        x2 = x2.ravel()\n        # TODO: this is very dirty!\n        #########################################\n        # Create matrix QMAT\n        #########################################\n        QMAT = np.zeros([4,4], np.float64)\n        for J1 in xrange(natoms):\n            J2 = 3* J1 -1\n            XM = x1[J2+1] - x2[J2+1]\n            YM = x1[J2+2] - x2[J2+2]\n            ZM = x1[J2+3] - x2[J2+3]\n            XP = x1[J2+1] + x2[J2+1]\n            YP = x1[J2+2] + x2[J2+2]\n            ZP = x1[J2+3] + x2[J2+3]\n            QMAT[0,0] = QMAT[0,0] + XM**2 + YM**2 + ZM**2\n            QMAT[0,1] = QMAT[0,1] - YP*ZM + YM*ZP\n            QMAT[0,2] = QMAT[0,2] - XM*ZP + XP*ZM\n            QMAT[0,3] = QMAT[0,3] - XP*YM + XM*YP\n            QMAT[1,1] = QMAT[1,1] + YP**2 + ZP**2 + XM**2\n            QMAT[1,2] = QMAT[1,2] + XM*YM - XP*YP\n            QMAT[1,3] = QMAT[1,3] + XM*ZM - XP*ZP\n            QMAT[2,2] = QMAT[2,2] + XP**2 + ZP**2 + YM**2\n            QMAT[2,3] = QMAT[2,3] + YM*ZM - YP*ZP\n            QMAT[3,3] = QMAT[3,3] + XP**2 + YP**2 + ZM**2\n        #\n        QMAT[1,0] = QMAT[0,1]\n        QMAT[2,0] = QMAT[0,2]\n        QMAT[2,1] = QMAT[1,2]\n        QMAT[3,0] = QMAT[0,3]\n        QMAT[3,1] = QMAT[1,3]\n        QMAT[3,2] = QMAT[2,3]\n        ###########################################\n        """"""\n        Find eigenvalues and eigenvectors of QMAT.  The eigenvector corresponding\n        to the smallest eigenvalue is the quaternion which rotates XB into best\n        alignment with XA.  The smallest eigenvalue is the squared distance between\n        the resulting structures.\n        """"""\n        ###########################################\n        (eigs, vecs) = np.linalg.eig(QMAT)\n    \n        imin = np.argmin(eigs)\n        eigmin = eigs[imin] # the minimum eigenvector\n        Q2 = vecs[:,imin]  # the eigenvector corresponding to the minimum eigenvalue\n        if eigmin < 0.:\n            if abs(eigmin) < 1e-6:\n                eigmin = 0.\n            else:\n                print \'minDist> WARNING minimum eigenvalue is \',eigmin,\' change to absolute value\'\n                eigmin = -eigmin\n        #\n        dist = sqrt(eigmin) # this is the minimized distance between the two structures\n        #\n        Q2 = np.real_if_close(Q2, 1e-10)\n        if np.iscomplexobj(Q2):\n            raise ValueError(""Q2 is complex"")\n        return dist, q2mx(Q2)\n        \n    def q2mx(qin):\n        """"""quaternion to rotation matrix""""""\n        Q = qin / np.linalg.norm(qin)\n        RMX = np.zeros([3, 3], np.float64)\n        Q2Q3 = Q[1] * Q[2]\n        Q1Q4 = Q[0] * Q[3]\n        Q2Q4 = Q[1] * Q[3]\n        Q1Q3 = Q[0] * Q[2]\n        Q3Q4 = Q[2] * Q[3]\n        Q1Q2 = Q[0] * Q[1]\n        #\n        RMX[0, 0] = 2. * (0.5 - Q[2] * Q[2] - Q[3] * Q[3])\n        RMX[1, 1] = 2. * (0.5 - Q[1] * Q[1] - Q[3] * Q[3])\n        RMX[2, 2] = 2. * (0.5 - Q[1] * Q[1] - Q[2] * Q[2])\n        RMX[0, 1] = 2. * (Q2Q3 - Q1Q4)\n        RMX[1, 0] = 2. * (Q2Q3 + Q1Q4)\n        RMX[0, 2] = 2. * (Q2Q4 + Q1Q3)\n        RMX[2, 0] = 2. * (Q2Q4 - Q1Q3)\n        RMX[1, 2] = 2. * (Q3Q4 - Q1Q2)\n        RMX[2, 1] = 2. * (Q3Q4 + Q1Q2)\n        return RMX\n    \n\ndef _next_fast_len(target):\n    if target <= 6:\n        return target\n    # Quickly check if it\'s already a power of 2\n    if not (target & (target-1)):\n        return target\n    match = float(\'inf\')  # Anything found will be smaller\n    p5 = 1\n    while p5 < target:\n        p35 = p5\n        while p35 < target:\n            # Ceiling integer division, avoiding conversion to float\n            # (quotient = ceil(target / p35))\n            quotient = -(-target // p35)\n            # Quickly find next power of 2 >= quotient\n            try:\n                p2 = 2**((quotient - 1).bit_length())\n            except AttributeError:\n                # Fallback for Python <2.7\n                p2 = 2**(len(bin(quotient - 1)) - 2)\n            N = p2 * p35\n            if N == target:\n                return N\n            elif N < match:\n                match = N\n            p35 *= 3\n            if p35 == target:\n                return p35\n        if p35 < match:\n            match = p35\n        p5 *= 5\n        if p5 == target:\n            return p5\n    if p5 < match:\n        match = p5\n    return match\n\ndef multiargmax(a):\n    a = np.asanyarray(a)\n    return np.unravel_index(a.argmax(), a.shape)\n    \ndef findMax(a):\n    """"""\n    This finds the interpolated max of multidimensional array\n    result given as fractional coordinates of array size\n    """"""\n    a = np.asanyarray(a)\n    shape = a.shape\n    dim = len(shape)\n    ind = np.unravel_index(a.argmax(), a.shape)\n    i1 = tuple(tuple((i0+1)%shape[i] if i==j else i0 for j in xrange(dim))\n               for i, i0 in enumerate(ind))\n    i2 = tuple(tuple(i0 for j in xrange(dim))\n               for i, i0 in enumerate(ind))\n    i3 = tuple(tuple(i0-1 if i==j else i0 for j in xrange(dim))\n               for i, i0 in enumerate(ind))\n    y1 = np.abs(a[i1])\n    y2 = np.abs(a[i2])\n    y3 = np.abs(a[i3])\n    d = (y3 - y1) / (2 * (2 * y2 - y1 - y3))\n    return (np.array(ind) - d)\n    \ndef indtoEuler(ind, n):\n    ind = np.atleast_2d(ind)\n    indFactor = np.array([2*pi/n, pi/n, 2*pi/n])\n    rot = indFactor*ind\n    rot[:,1] += 0.5*pi/n\n    return rot.squeeze()\n\ndef _gaussian(x, A, mu, *alphax0):\n    x = np.atleast_2d(x)\n    dim = len(x)\n    sigma = np.zeros((dim,dim), float)\n    sigma[np.triu_indices(dim)] = alphax0[:-dim]\n    x0 = x - np.array(alphax0[-dim:])[:,None]\n    return A * np.exp(-np.einsum(""ik,jk,ij->k"",x0,x0,sigma)) + mu\n\ndef fitPeak(f, ind, n=2):\n    dim = len(f.shape)\n    peak = f[np.ix_(*[np.arange(i-n,i+n+1)%s for i,s in izip(ind,f.shape)])]\n    flatindices = np.indices((2*n+1,)*dim).reshape((dim,-1))\n    flatpeak = peak.flatten()\n    p0 = ([peak[(n,)*dim], 0.] + \n          [1. if i==j else 0. for i in xrange(dim) for j in xrange(i, dim)] + \n          [0.]*dim)\n    popt, pcov = curve_fit(_gaussian, flatindices-n, flatpeak, p0=p0)\n    return popt, pcov                   \n    \ndef findPeaks(a, npeaks=10, width=2):\n    f = np.array(a)\n    f -= f.min()\n    dim = len(f.shape)\n    indices = np.indices(f.shape).reshape((dim,-1))\n    tupinds = tuple(indices)\n    peaks = []\n    amplitude = []\n    mean = []\n    sigma = []\n    for i in xrange(npeaks):\n        ind = multiargmax(f)\n        try:\n            popt = fitPeak(f, ind, width)[0]\n            peaks.append((popt[-dim:] + ind))\n            amplitude.append(popt[0])\n            mean.append(popt[1])\n            sigma.append((2*popt[2:-dim])**-0.5)\n            popt[-dim:] += ind \n            f[tupinds] -= _gaussian(indices, *popt)\n        except RuntimeError:\n            break\n        except ValueError:\n            break\n    peaks = np.array(peaks)\n    if len(peaks) == 0:\n        peaks = findMax(a)[None,:]\n        amplitude.append(a.max())\n        mean.append(0)\n        sigma.append(np.NaN)\n    return peaks, amplitude, mean, sigma, f\n    \ndef eval_grad_jacobi(n, alpha, beta, x, out=None):\n    fact = gamma(alpha + beta + n + 2)/2/gamma(alpha+beta+n+1)\n    return eval_jacobi(n-1, alpha+1, beta+1, x, out) * fact\n    \ndef BruteOverlap(pos1, pos2, scale):\n    pos2, pos1 = map(np.atleast_2d, sorted([pos2, pos1], key=len))\n    inds = np.indices((len(pos1),len(pos2))).reshape((2,-1))\n    rs = norm(pos1[inds[0]]-pos2[inds[1]], axis=1)\n    return exp(-rs**2 / 4 / scale**2).sum() * (pi * scale**2)**(1.5)\n    \ndef norm_harmonicBasis(n, l, r0):\n    """"""\n    returns the normalisaton constant of the harmonic basis function\n    """"""\n    return (2 * factorial(n) * r0**(-2*l-3) / gamma(1.5+n+l))**0.5\n    \ndef coeffs_harmonicBasis(n, l, r0):\n    """"""\n    Calculates the coefficients of the polynomial that defines the\n    radial harmonic basis function of degree n and angular momentum order l\n    r0 is the scale of the harmonic basis function\n    \n    returns \\tilde{g}^{nl}_s given the following    \n    r^l L^{l+1/2}_n = \\sum_{s=l}^{n+l} \\tilde{g}^{nl}_s r^s,\n    """"""\n    N = norm_harmonicBasis(n, l, r0)\n    coeffs = np.zeros(2*n+l+1)\n    coeffs[l::2] = genlaguerre(n, l+0.5).coeffs[::-1]\n    coeffs *= N\n    return coeffs\n    \ndef eval_harmonicBasis(n, l, r, r0=1.):\n    """""" \n    For testing purposes \n    \n    Evaluates the harmonic basis function at positions r\n    """"""\n    N = norm_harmonicBasis(n, l, r0)\n    return (N*r**l* exp(-0.5*r**2/r0**2) * \n            eval_genlaguerre(n, l+0.5, r**2/r0**2))\n\ndef calcThetaPhiR(pos):\n    pos = np.atleast_2d(pos)\n    X, Y, Z = pos.T\n    R = norm(pos, axis=1)\n    phi = np.arctan2(Y, X)\n    theta = np.arccos(Z/R)\n    return theta, phi, R\n    \ndef EulerM(a, b, y):\n    sina, cosa = sin(a), cos(a)\n    sinb, cosb = sin(b), cos(b)\n    siny, cosy = sin(y), cos(y)\n    Ma = np.array(((cosa, -sina, 0),\n                   (sina, cosa, 0),\n                   (0,0,1)))\n    Mb = np.array(((cosb, 0, -sinb),\n                   (0, 1, 0),\n                   (sinb, 0, cosb)))\n    My = np.array(((cosy, -siny, 0),\n                   (siny, cosy, 0),\n                   (0,0,1)))\n    return My.dot(Mb).dot(Ma)\n    \ndef angle_axis2mat(vector):\n    \'\'\' Rotation matrix of angle `theta` around `vector`\n    Parameters\n    ----------\n    vector : 3 element sequence\n       vector specifying axis for rotation. Norm of vector gives angle of\n       rotation.\n    Returns\n    -------\n    mat : array shape (3,3)\n       rotation matrix for specified rotation\n    Notes\n    -----\n    From: https://en.wikipedia.org/wiki/Rotation_matrix#Axis_and_angle\n    \'\'\'\n    vector = np.asanyarray(vector)\n    theta = norm(vector)\n    if theta==0.:\n        return np.eye(3)\n    x, y, z = vector/theta\n    c, s = cos(theta), sin(theta)\n    C = 1 - c\n    xs, ys, zs = x * s, y * s, z * s\n    xC, yC, zC = x * C, y * C, z * C\n    xyC, yzC, zxC = x * yC, y * zC, z * xC\n    return np.array([[x * xC + c, xyC - zs, zxC + ys],\n                     [xyC + zs, y * yC + c, yzC - xs],\n                     [zxC - ys, yzC + xs, z * zC + c]])\n                     \ndef mat2angle_axis(M):\n    \'\'\' Calculates rotation vector where the norm of the rotation vector\n    indicates the angle of rotation from a rotation matrix M\n    \n    Parameters\n    ----------\n    M : (3,3) array like\n        matrix encoding rotation matrix\n        \n    Returns\n    -------\n    v: array shape (3)\n        rotation vector\n    \'\'\'\n    M = np.asanyarray(M)\n    theta = np.arccos(0.5*np.trace(M)-0.5)\n    v = np.array([M[2,1]-M[1,2],M[0,2]-M[2,0],M[1,0]-M[0,1]])\n    v *= 0.5*theta/sin(theta)\n    return v\n    \nclass PriorityQueueHeap(object):\n    def __init__(self):\n        self.heap = []\n        \n    def get(self):\n        return heappop(self.heap)\n        \n    def put(self, item):\n        heappush(self.heap, item)\n        \n    def empty(self):\n        return len(self.heap) == 0\n        \n    def qsize(self):\n        return len(self.heap)'"
fastoverlap/f90/__init__.py,0,"b'# -*- coding: utf-8 -*-\n\ntry:\n    import fastbulk\n    have_fastbulk = True\nexcept ImportError:\n    have_fastbulk = False\n\ntry:\n    import fastclusters\n    have_fastclusters = True\nexcept ImportError:\n    have_fastclusters = False\n\ntry:\n    import libbnb\n    have_libbnb = True\nexcept ImportError:\n    have_libbnb = False\n\nhave_fortran = all((have_fastbulk,have_fastclusters,have_libbnb))\n'"
