file_path,api_count,code
sentiments/analyzer.py,0,"b'import nltk\n\nclass Analyzer():\n\t""""""Implements sentiment analysis.""""""\n\tdef __init__(self, positives, negatives):\n\t\t""""""Initialize Analyzer.""""""\n\t\tself.pos = self.read_file(positives)\n\t\tself.neg = self.read_file(negatives)\n\n\tdef read_file(self, file_name):\n\t\t\n\t\tfileop = open(file_name, \'r\')\n\t\t# Skip comments\n\t\tdelim = \';\'\n\t\t\n\t\tline = fileop.readline()\n\t\t\n\t\twhile delim in line:\n\t\t\tline = fileop.readline()\n\n\t\t# read file and save the words in list\n\t\tline_list = self.strip_newline(fileop.readlines())\n\t\t\n\t\tfileop.close()\n\n\t\treturn line_list\n\n\tdef strip_newline(self, word_list):\n\n\t\tstripped_list = []\n\t\tfor item in word_list:\n\t\t\tstripped_list.append(item.rstrip(\'\\n\'))\n\n\t\treturn stripped_list\n\n\tdef analyze(self, text):\n\t\t""""""Analyze text for sentiment, returning its score.""""""\n\t\ttokenizer = nltk.tokenize.TweetTokenizer()\n\t\ttokens = tokenizer.tokenize(text)\n\t \t\n\t\tscore = []\n\t\tfor item in tokens:\n\t\t\titem_l = item.lower()\n\t\t\t\n\t\t\tif item_l in list(self.neg):\n\t\t\t\tscore.append(-1)     \n\t\t\telif item_l in list(self.pos):\n\t\t\t\tscore.append(1)\n\t\t\telse:\n\t\t\t\tscore.append(0)\n\t\t\n\t\treturn sum(score)\n'"
sentiments/application.py,0,"b'from flask import Flask, redirect, render_template, request, url_for\n\nimport helpers\nimport os\nimport sys\nfrom analyzer import Analyzer\n\napp = Flask(__name__)\n\n@app.route(""/"")\ndef index():\n    return render_template(""index.html"")\n\n@app.route(""/search"")\ndef search():\n\n    # validate screen_name\n    screen_name = request.args.get(""screen_name"", """")\n    if not screen_name:\n        return redirect(url_for(""index""))\n\n    # get screen_name\'s tweets\n    tweets = helpers.get_user_timeline(screen_name, 100)\n    \n    # return to index if screen_name doesn\'t exist\n    if tweets == None:\n        return redirect(url_for(""index""))\n\n    # absolute paths to lists\n    positives = os.path.join(sys.path[0], ""positive-words.txt"")\n    negatives = os.path.join(sys.path[0], ""negative-words.txt"")\n\n    # instantiate analyzer\n    analyzer = Analyzer(positives, negatives)\n\n    positive, negative, neutral = 0.0, 0.0, 0.0\n\n    # TODO\n    for tweet in tweets:\n        score = analyzer.analyze(tweet)\n        \n        if score > 0.0:\n            positive += 1\n        elif score < 0.0:\n            negative += 1\n        else:\n            neutral += 1\n        \n    # generate chart\n    chart = helpers.chart(positive, negative, neutral)\n\n    # render results\n    return render_template(""search.html"", chart=chart, screen_name=screen_name)\n'"
sentiments/helpers.py,0,"b'import html\nimport os\nimport plotly\nimport socket\n\nfrom twython import Twython\nfrom twython import TwythonAuthError, TwythonError, TwythonRateLimitError\n\ndef chart(positive, negative, neutral):\n    """"""Return a pie chart for specified sentiments as HTML.""""""\n\n    # offline plot\n    # https://plot.ly/python/pie-charts/\n    # https://plot.ly/python/reference/#pie\n    figure = {\n        ""data"": [\n            {\n                ""labels"": [""positive"", ""negative"", ""neutral""],\n                ""hoverinfo"": ""none"",\n                ""marker"": {\n                    ""colors"": [\n                        ""rgb(0,255,00)"",\n                        ""rgb(255,0,0)"",\n                        ""rgb(255,255,0)""\n                    ]\n                },\n                ""type"": ""pie"",\n                ""values"": [positive, negative, neutral]\n            }\n        ],\n        ""layout"": {\n            ""showlegend"": True\n            }\n    }\n    return plotly.offline.plot(figure, output_type=""div"", show_link=False, link_text=False)\n\ndef get_user_timeline(screen_name, count=200):\n    """"""Return list of most recent tweets posted by screen_name.""""""\n\n    # ensure count is valid\n    if count < 1 or count > 200:\n        raise RuntimeError(""invalid count"")\n\n    # ensure environment variables are set\n    if not os.environ.get(""API_KEY""):\n        raise RuntimeError(""API_KEY not set"")\n    if not os.environ.get(""API_SECRET""):\n        raise RuntimeError(""API_SECRET not set"")\n\n    # get screen_name\'s (or @screen_name\'s) most recent tweets\n    # https://dev.twitter.com/rest/reference/get/users/lookup\n    # https://dev.twitter.com/rest/reference/get/statuses/user_timeline\n    # https://github.com/ryanmcgrath/twython/blob/master/twython/endpoints.py\n    try:\n        twitter = Twython(os.environ.get(""API_KEY""), os.environ.get(""API_SECRET""))\n        user = twitter.lookup_user(screen_name=screen_name.lstrip(""@""))\n        if user[0][""protected""]:\n            return None\n        tweets = twitter.get_user_timeline(screen_name=screen_name, count=count)\n        return [html.unescape(tweet[""text""].replace(""\\n"", "" "")) for tweet in tweets]\n    except TwythonAuthError:\n        raise RuntimeError(""invalid API_KEY and/or API_SECRET"") from None\n    except TwythonRateLimitError:\n        raise RuntimeError(""you\'ve hit a rate limit"") from None\n    except TwythonError:\n        return None\n'"
