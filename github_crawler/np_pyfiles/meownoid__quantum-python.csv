file_path,api_count,code
example-deutsch-jozsa.py,0,"b""from quantum import QRegister, H, I, U\n\n\ndef is_constant(f, n):\n    q = QRegister(n + 1, '0' * n + '1')\n    q.apply(H ** (n + 1))\n    q.apply(U(f, n))\n    q.apply(H ** n @ I)\n\n    return q.measure()[:~0] == '0' * n\n\n\ndef f1(x):\n    return x\n\n\ndef f2(x):\n    return 1\n\n\ndef f3(x, y):\n    return x ^ y\n\n\ndef f4(x, y, z):\n    return 0\n\n\nprint('f(x) = x is {}'.format('constant' if is_constant(f1, 1) else 'balansed'))\nprint('f(x) = 1 is {}'.format('constant' if is_constant(f2, 1) else 'balansed'))\nprint('f(x, y) = x ^ y is {}'.format('constant' if is_constant(f3, 2) else 'balansed'))\nprint('f(x, y, z) = 0 is {}'.format('constant' if is_constant(f4, 3) else 'balansed'))\n"""
example-randbit.py,0,"b""from quantum import QRegister, H\n\n\ndef quantum_randbit():\n    a = QRegister(1, '0')\n    a.apply(H)\n\n    return a.measure()\n\n\nfor i in range(32):\n    print(quantum_randbit(), end='')\nprint()\n"""
quantum.py,10,"b""import numpy as np\nfrom itertools import product\n\n\nclass QRegister:\n    def __init__(self, n_qbits, init):\n        self._n = n_qbits\n        assert len(init) == self._n\n\n        self._data = np.zeros((2 ** self._n), dtype=np.complex64)\n        self._data[int('0b' + init, 2)] = 1\n\n    def measure(self):\n        probs = np.real(self._data) ** 2 + np.imag(self._data) ** 2\n        states = np.arange(2 ** self._n)\n        mstate = np.random.choice(states, size=1, p=probs)[0]\n        return f'{mstate:>0{self._n}b}'\n\n    def apply(self, gate):\n        assert isinstance(gate, QGate)\n        assert self._n == gate._n\n        self._data = gate._data @ self._data\n\n\nclass QGate:\n    def __init__(self, matrix):\n        self._data = np.array(matrix, dtype=np.complex64)\n\n        assert len(self._data.shape) == 2\n        assert self._data.shape[0] == self._data.shape[1]\n\n        self._n = np.log2(self._data.shape[0])\n\n        assert self._n.is_integer()\n\n        self._n = int(self._n)\n\n    def __matmul__(self, other):\n        return QGate(np.kron(self._data, other._data))\n\n    def __pow__(self, n, modulo=None):\n        x = self._data.copy()\n\n        for _ in range(n - 1):\n            x = np.kron(x, self._data)\n\n        return QGate(x)\n\n\nI = QGate([[1, 0], [0, 1]])\nH = QGate(np.array([[1, 1], [1, -1]]) / np.sqrt(2))\nX = QGate([[0, 1], [1, 0]])\nY = QGate([[0, -1j], [1j, 0]])\nZ = QGate([[1, 0], [0, -1]])\n\n\ndef U(f, n):\n    m = n + 1\n\n    U = np.zeros((2**m, 2**m), dtype=np.complex64)\n\n    def bin2int(xs):\n        r = 0\n        for i, x in enumerate(reversed(xs)):\n            r += x * 2 ** i\n        return r\n\n    for xs in product({0, 1}, repeat=m):\n        x = xs[:~0]\n        y = xs[~0]\n\n        z = y ^ f(*x)\n\n        instate = bin2int(xs)\n        outstate = bin2int(list(x) + [z])\n        U[instate, outstate] = 1\n\n    return QGate(U)\n"""
