file_path,api_count,code
ekf.py,11,"b""import numpy as np\nimport numpy.matlib\nfrom math import pi, sqrt\n\nfrom utils import cart_2_polar, state_vector_to_scalars\n\nclass ExtendedKalmanFilter:\n    def __init__(self):\n        '''\n        Each object being tracked will result in the creation of a new ExtendedKalmanFilter instance.\n\n        TODO: consider making these just class methods; that way we don't have many instances and instead\n        each tracker will just call to these methods with the matrices to update.\n        '''\n\n        #do this once do we don't keep redoing in update step\n        self.__xI = np.matlib.identity(4)\n\n        self.__x = None\n        self.__F = None\n        self.__Q = None\n\n        self.__P = np.matrix([[1,0,0,0],\n                              [0,1,0,0],\n                              [0,0,1000,0],\n                              [0,0,0,1000]])\n\n        self.__HL = np.matrix([[1,0,0,0],\n                               [0,1,0,0]])\n\n        self.__HR = np.matlib.zeros((3,4))\n\n        self.__RL = np.matrix([[0.0225,0],\n                               [0,0.0225]])\n\n        self.__RR = np.matrix([[0.09,0,0],\n                               [0,0.0009,0],\n                               [0,0,0.09]])\n\n        #we can adjust these to get better accuracy\n        self.__noise_ax = 9\n        self.__noise_ay = 9\n\n    @property\n    def current_estimate(self):\n        return (self.__x, self.__P)\n\n    def init_state_vector(self, x,y, vx, vy):\n        self.__x = np.matrix([[x,y,vx,vy]]).T\n\n    def recompute_F_and_Q(self, dt):\n        '''\n        updates the motion model and process covar based on delta time from last measurement.\n        '''\n\n        #set F\n        self.__F = np.matrix([[1,0,dt,0],\n                              [0,1,0,dt],\n                              [0,0,1,0],\n                              [0,0,0,1]])\n        #set Q\n        dt2 = dt**2\n        dt3 = dt**3\n        dt4 = dt**4\n\n        e11 = dt4 * self.__noise_ax / 4\n        e13 = dt3 * self.__noise_ax / 2\n        e22 = dt4 * self.__noise_ay / 4\n        e24 = dt3 * self.__noise_ay /  2\n        e31 = dt3 * self.__noise_ax / 2\n        e33 = dt2 * self.__noise_ax\n        e42 = dt3 * self.__noise_ay / 2\n        e44 = dt2 * self.__noise_ay\n\n        self.__Q = np.matrix([[e11, 0, e13, 0],\n                              [0, e22, 0, e24],\n                              [e31, 0, e33, 0],\n                              [0, e42, 0, e44]])\n\n    def recompute_HR(self):\n        '''\n        calculate_jacobian of the current state.\n        '''\n        px,py,vx,vy = state_vector_to_scalars(self.__x)\n\n        pxpy_squared = px**2+py**2\n        pxpy_squared_sqrt = sqrt(pxpy_squared)\n        pxpy_cubed = (pxpy_squared*pxpy_squared_sqrt)\n\n        if pxpy_squared < 1e-4:\n            self.__HR = np.matlib.zeros((3,4))\n            return\n\n        e11 = px/pxpy_squared_sqrt\n        e12 = py/pxpy_squared_sqrt\n        e21 = -py/pxpy_squared\n        e22 = px/pxpy_squared\n        e31 = py*(vx*py - vy*px)/pxpy_cubed\n        e32 = px*(px*vy - py*vx)/pxpy_cubed\n\n        self.__HR = np.matrix([[e11, e12, 0, 0],\n                               [e21, e22, 0, 0],\n                               [e31, e32, e11, e12]])\n\n    def predict(self):\n        '''\n        This is a projection step. we predict into the future.\n        '''\n        self.__x = self.__F * self.__x\n        self.__P = (self.__F * self.__P * self.__F.T) + self.__Q\n\n    def updateLidar(self,measurement_packet):\n        '''\n        This is the projection correction; after we predict we use the sensor data\n        and use the kalman gain to figure out how much of the correction we need.\n        '''\n\n        #this is the error of our prediction to the sensor readings\n        y = measurement_packet.z - self.__HL*self.__x\n\n        #pre compute for the kalman gain K\n        PHLt = self.__P * self.__HL.T\n        S = self.__HL * PHLt + self.__RL\n        K = PHLt*S.I\n\n        #now we update our prediction using the error and kalman gain.\n        self.__x += K*y\n        self.__P = (self.__xI - K*self.__HL) * self.__P\n\n    def updateRadar(self,measurement_packet):\n        '''\n        This is the projection correction; after we predict we use the sensor data\n        and use the kalman gain to figure out how much of the correction we need.\n\n        This is a special case as we will need a Jocabian matrix to have a linear\n        approximation of the transformation function h(x)\n        '''\n\n        y = measurement_packet.z - cart_2_polar(self.__x)\n        #make sure the phi in y is -pi <= phi <= pi\n        while (y[1] > pi): y[1] -= 2.*pi\n        while (y[1] < -pi): y[1] += 2.*pi\n\n        #recompute Jacobian\n        self.recompute_HR()\n\n        #pre compute for the kalman gain K\n        #TODO: this code is not DRY should refactor here.\n        S = self.__HR * self.__P * self.__HR.T + self.__RR\n        K = self.__P*self.__HR.T*S.I\n\n        #now we update our prediction using the error and kalman gain.\n        self.__x += K*y\n        self.__P = (self.__xI - K*self.__HR) * self.__P\n"""
main.py,0,"b'import pandas as pd\nfrom utils import MeasurementPacket, calculate_rmse, passing_rmse\nfrom tracker import Tracker\n\ndef runTracker(data_path):\n    \'\'\'\n    This is simulating our sensors data stream.\n\n    ***Note***\n        This is not a generator so if your sample log file is huge it\'ll load it\n        all into memory. For now this is acceptable ;)\n    \'\'\'\n    data_packets = pd.read_csv(data_path,\n                    header=None,\n                    sep=\'\\t\',\n                    names=[\'x\'+str(x) for x in range(9)])\n\n    \'\'\'\n    For now we are only tracking one object, hence we only need one Tracker.\n    If the vehicle seen for example three people and three cars we\'d need six trackers.\n    So you\'d ideally have a list of trackers going at once. However, I could be wrong!\n    \'\'\'\n    tracker = Tracker()\n\n    \'\'\'\n    This is the main loop that updates and tracks the objects.\n    EKF style!\n    \'\'\'\n\n    estimations = []\n    measurements = []\n\n    for _ , raw_measurement_packet in data_packets.iterrows():\n        measurement_packet = MeasurementPacket(raw_measurement_packet)\n        measurements.append(measurement_packet)\n        tracker.process_measurement(measurement_packet)\n        estimations.append(tracker.state)\n\n    return estimations, measurements\n\n\nif __name__ == \'__main__\':\n    print(""Started Tracker for sample-laser-radar-measurement-data-1.txt"")\n    estimations, measurements = runTracker(\'./data/sample-laser-radar-measurement-data-1.txt\')\n    print(""estimations count: "", len(estimations))\n    print(""measurements count: "", len(measurements))\n\n    rmse = calculate_rmse(estimations, [m.ground_truth for m in measurements]).flatten()\n    print(""RMSE: "", rmse)\n    #check if we passed metric for data1 log file.\n    passing_rmse(rmse, [0.08, 0.08, 0.60, 0.60])\n\n\n    print(""\\n\\nStarted Tracker for sample-laser-radar-measurement-data-2.txt"")\n    estimations, measurements = runTracker(\'./data/sample-laser-radar-measurement-data-2.txt\')\n    print(""estimations count: "", len(estimations))\n    print(""measurements count: "", len(measurements))\n\n    rmse = calculate_rmse(estimations, [m.ground_truth for m in measurements]).flatten()\n    print(""RMSE: "", rmse)\n    #check if we passed metric for data2 log file.\n    passing_rmse(rmse, [0.20, 0.20, .50, .85])\n'"
tracker.py,0,"b""from utils import SensorType, polar_2_cart\nfrom ekf import ExtendedKalmanFilter\nimport numpy as np\n\nclass Tracker:\n    '''\n    The Tracker class is created everytime we detect a new object during our analysis from either\n    the LIDAR point cloud or the RADAR doppler. It contains the entire state of the tracked object.\n    '''\n    def __init__(self):\n        #ideally we'd be given this ID from the measurement_packets coming in.\n        #However, I currently don't know how multiple objects are Identified.\n        self.id  = None\n\n        #this is where the magic happens.\n        self.__ekf = ExtendedKalmanFilter()\n        self.__is_initialized = False\n        self.__previous_timestamp = 0.\n\n    @property\n    def state(self):\n        return self.__ekf.current_estimate[0]\n\n    def process_measurement(self,measurement_packet):\n        # if this is first measurement_packet, then setup state vector.\n        if not self.__is_initialized:\n            x, y, vx, vy = 0,0,0,0\n            if measurement_packet.sensor_type == SensorType.LIDAR:\n                x, y, vx, vy = measurement_packet.x_measured,measurement_packet.y_measured,0,0\n\n            elif measurement_packet.sensor_type == SensorType.RADAR:\n                #we have the polar space measurements; we need to transform to cart space.\n                x,y, vx, vy = polar_2_cart(measurement_packet.rho_measured,\n                                 measurement_packet.phi_measured,\n                                 measurement_packet.rhodot_measured)\n\n            if abs(x+y) <= 1e-4:\n                x = 1e-4\n                y = 1e-4\n\n            self.__ekf.init_state_vector(x,y, vx, vy)\n            self.__previous_timestamp = measurement_packet.timestamp\n            self.__is_initialized = True\n            return\n\n\n        #1st we calculate how much time has passed since our last measurement_packet in seconds\n        dt =( measurement_packet.timestamp - self.__previous_timestamp) / 1000000.0\n        self.__previous_timestamp = measurement_packet.timestamp\n\n        #2nd set new F and Q using new dt\n        self.__ekf.recompute_F_and_Q(dt)\n\n        #3rd make a prediction\n        self.__ekf.predict()\n\n        #4th update prediction\n        if measurement_packet.sensor_type == SensorType.LIDAR:\n            self.__ekf.updateLidar(measurement_packet)\n        elif measurement_packet.sensor_type == SensorType.RADAR:\n            self.__ekf.updateRadar(measurement_packet)\n"""
utils.py,7,"b'\'\'\'\nutils provides helper classes and methods.\n\'\'\'\n\nfrom enum import Enum\nimport numpy as np\nimport numpy.matlib\n\nfrom math import sin, cos, sqrt, atan2\n\ndef state_vector_to_scalars(state_vector):\n    \'\'\'\n    Returns the elements from the state_vector as a tuple of scalars.\n    \'\'\'\n    return (state_vector[0][0,0],state_vector[1][0,0],state_vector[2][0,0],state_vector[3][0,0])\n\ndef cart_2_polar(state_vector):\n    \'\'\'\n    Transforms the state vector into the polar space.\n    \'\'\'\n\n    px,py,vx,vy = state_vector_to_scalars(state_vector)\n    ro      = sqrt(px**2 + py**2)\n\n    phi     = atan2(py,px)\n    ro_dot  = (px*vx + py*vy)/ro\n\n    return np.matrix([ro, phi, ro_dot]).T\n\ndef polar_2_cart(ro, phi, ro_dot):\n    \'\'\'\n    ro: range\n    phi: bearing\n    ro_dot: range rate\n\n    Takes the polar coord based radar reading and convert to cart coord x,y, vx, vy\n    return (x,y, vx, vy)\n    \'\'\'\n    return (cos(phi) * ro, sin(phi) * ro, ro_dot * cos(phi) , ro_dot * sin(phi))\n\ndef passing_rmse(rmse, metric):\n    print(""Metric: "", metric)\n    for index, threshold in enumerate(metric):\n        if rmse[0,index] > threshold:\n            print(""RMSE FAILED metric @ index "", index)\n            return False\n\n    print(""RMSE PASSED metric"")\n    return True\n\ndef calculate_rmse(estimations, ground_truth):\n    \'\'\'\n    Root Mean Squared Error.\n    \'\'\'\n    if len(estimations) != len(ground_truth) or len(estimations) == 0:\n        raise ValueError(\'calculate_rmse () - Error - estimations and ground_truth must match in length.\')\n\n    rmse = np.matrix([0.,0.,0.,0.]).T\n\n    for est, gt in zip(estimations, ground_truth):\n        rmse += np.square(est - gt)\n\n    rmse /= len(estimations)\n    return np.sqrt(rmse)\n\n\nclass SensorType(Enum):\n    \'\'\'\n    Enum types for the sensors. Future sensors would be added here.\n    \'\'\'\n    LIDAR = \'L\'\n    RADAR = \'R\'\n\nclass MeasurementPacket:\n    \'\'\'\n    Defines a measurement datapoint for multiple sensor types.\n    \'\'\'\n    def __init__(self, packet):\n        self.sensor_type = SensorType.LIDAR if packet[0] == \'L\' else SensorType.RADAR\n\n        if self.sensor_type == SensorType.LIDAR:\n            self.setup_lidar(packet)\n        elif self.sensor_type == SensorType.RADAR:\n            self.setup_radar(packet)\n\n    def setup_radar(self, packet):\n        self.rho_measured       = packet[1]\n        self.phi_measured       = packet[2]\n        self.rhodot_measured    = packet[3]\n        self.timestamp          = packet[4]\n        self.x_groundtruth      = packet[5]\n        self.y_groundtruth      = packet[6]\n        self.vx_groundtruth     = packet[7]\n        self.vy_groundtruth     = packet[8]\n\n    def setup_lidar(self, packet):\n        self.x_measured         = packet[1]\n        self.y_measured         = packet[2]\n        self.timestamp          = packet[3]\n        self.x_groundtruth      = packet[4]\n        self.y_groundtruth      = packet[5]\n        self.vx_groundtruth     = packet[6]\n        self.vy_groundtruth     = packet[7]\n\n    @property\n    def z(self):\n        \'\'\'\n        Returns a vectorized version of the measurement for EKF typically called z.\n        \'\'\'\n        if self.sensor_type == SensorType.LIDAR:\n            return np.matrix([[self.x_measured,self.y_measured]]).T\n        elif self.sensor_type == SensorType.RADAR:\n            return np.matrix([[self.rho_measured,self.phi_measured,self.rhodot_measured]]).T\n\n    @property\n    def ground_truth(self):\n        return np.matrix([[self.x_groundtruth,\n                         self.y_groundtruth,\n                         self.vx_groundtruth,\n                         self.vy_groundtruth]]).T\n\n    def __str__(self):\n        if self.sensor_type == SensorType.LIDAR:\n            return ""LIDAR (timestamp: {:>8}) \\n MEASUREMENT [{:>4} || {:>4}] \\n GROUND TRUTH [{:>4} || {:>4} || {:>4} || {:>4}]"".format(\n                    self.timestamp,\n\n                    self.x_measured,\n                    self.y_measured ,\n\n                    self.x_groundtruth ,\n                    self.y_groundtruth,\n                    self.vx_groundtruth,\n                    self.vy_groundtruth)\n\n        elif self.sensor_type == SensorType.RADAR:\n            return ""RADAR (timestamp: {:>8}) \\n MEASUREMENT [{:>4} || {:>4} <> {:>4}] \\n GROUND TRUTH [{:>4} || {:>4} || {:>4} || {:>4}]"".format(\n                    self.timestamp    ,\n\n                    self.rho_measured,\n                    self.phi_measured ,\n                    self.rhodot_measured,\n\n                    self.x_groundtruth,\n                    self.y_groundtruth ,\n                    self.vx_groundtruth,\n                    self.vy_groundtruth )\n'"
