file_path,api_count,code
__init__.py,0,"b'from .benford import *\n\n__version__ = ""0.2.6""'"
setup.py,0,"b""from setuptools import setup\n\nsetup(name='benford_py',\n      version='0.2.7',\n      description='A library for testing data sets with Bendford\\'s Law',\n      url='https://github.com/milcent/benford_py',\n      download_url='https://github.com/milcent/benford_py/archive/v0.2.7.tar.gz',\n      author='Marcel Milcent',\n      author_email='marcelmilcent@gmail.com',\n      license='GPLv3.0',\n      packages=['benford'],\n      install_requires=[\n      \t'pandas',\n      \t'numpy',\n      \t'matplotlib',\n      ],\n      zip_safe=False,\n      classifiers=[\n            'Programming Language :: Python :: 3',\n            'License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)',\n            'Natural Language :: English',\n            'Operating System :: OS Independent',\n            'Development Status :: 2 - Pre-Alpha',\n            'Intended Audience :: Financial and Insurance Industry',\n            'Intended Audience :: Science/Research',\n            'Intended Audience :: Education',\n            'Intended Audience :: Other Audience',\n            'Topic :: Office/Business :: Financial :: Accounting',\n            'Topic :: Scientific/Engineering :: Mathematics',\n            \n      ],)\n"""
benford/__init__.py,0,"b'""""""\nBenford_py for Python is a module for application of Benford\'s Law\nto a sequence of numbers.\n\nDependent on pandas, numpy and matplotlib\n\nAll logarithms ar in base 10: ""log10""\n\nAuthor:  Marcel Milcent\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n""""""\n\nfrom .benford import *\n\n__version__ = \'0.2.7\'\n\n'"
benford/benford.py,0,"b'from pandas import Series, DataFrame\nfrom numpy import array, arange, log10, ones, abs, cos, sin, pi, sqrt, mean \nimport warnings\nfrom .constants import confs, digs_dict, sec_order_dict, rev_digs, names, \\\n    mad_dict, colors, crit_chi2, KS_crit\nfrom .checks import _check_digs_, _check_confidence_, _check_test_, \\\n    _check_num_array_, _check_high_Z_\nfrom .utils import  _set_N_, input_data, prepare, \\\n    subtract_sorted, prep_to_roll, mad_to_roll, mse_to_roll, \\\n     get_mantissas\nfrom .expected import First, Second, LastTwo, _test_\nfrom .viz import _get_plot_args, plot_digs, plot_sum, plot_ordered_mantissas,\\\n    plot_mantissa_arc_test, plot_roll_mse, plot_roll_mad\nfrom .reports import _inform_, _report_mad_, _report_test_, _deprecate_inform_,\\\n    _report_mantissa_\nfrom .stats import Z_score, chi_sq, chi_sq_2, kolmogorov_smirnov,\\\n    kolmogorov_smirnov_2\n\nclass Base(DataFrame):\n    """"""Internalizes and prepares the data for Analysis.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.`\n    \n    Raises:\n        TypeError: if not receiving `int` or `float` as input.\n    """"""\n    def __init__(self, data, decimals, sign=\'all\', sec_order=False):\n        \n        DataFrame.__init__(self, {\'Seq\': data})\n\n        if (self.Seq.dtypes != \'float64\') & (self.Seq.dtypes != \'int64\'):\n            raise TypeError(""The sequence dtype was not pandas int64 nor ""\n                            ""float64. Convert it to whether int of float, ""\n                            ""and try again."")\n\n        if sign == \'all\':\n            self.Seq = self.Seq.loc[self.Seq != 0]\n        elif sign == \'pos\':\n            self.Seq = self.Seq.loc[self.Seq > 0]\n        else:\n            self.Seq = self.Seq.loc[self.Seq < 0]\n\n        self.dropna(inplace=True)\n\n        ab = self.Seq.abs()\n\n        if self.Seq.dtypes == \'int64\':\n            self[\'ZN\'] = ab\n        else:\n            if decimals == \'infer\':\n                self[\'ZN\'] = ab.astype(str).str\\\n                               .replace(\'.\', \'\')\\\n                               .str.lstrip(\'0\')\\\n                               .str[:5].astype(int)\n            else:\n                self[\'ZN\'] = (ab * (10 ** decimals)).astype(int)\n        # First digits\n        for col in [\'F1D\', \'F2D\', \'F3D\']:\n            temp = self.ZN.loc[self.ZN >= 10 ** (rev_digs[col] - 1)]\n            self[col] = (temp // 10 ** ((log10(temp).astype(int)) -\n                                        (rev_digs[col] - 1)))\n            # fill NANs with -1, which is a non-usable value for digits,\n            # to be discarded later.\n            self[col] = self[col].fillna(-1).astype(int)\n        # Second digit\n        temp_sd = self.loc[self.ZN >= 10]\n        self[\'SD\'] = (temp_sd.ZN // 10**((log10(temp_sd.ZN)).astype(int) -\n                                         1)) % 10\n        self[\'SD\'] = self[\'SD\'].fillna(-1).astype(int)\n        # Last two digits\n        temp_l2d = self.loc[self.ZN >= 1000]\n        self[\'L2D\'] = temp_l2d.ZN % 100\n        self[\'L2D\'] = self[\'L2D\'].fillna(-1).astype(int)\n\n\nclass Test(DataFrame):\n    """"""Transforms the original number sequence into a DataFrame reduced\n    by the ocurrences of the chosen digits, creating other computed\n    columns\n\n    Args:\n        base: The Base object with the data prepared for Analysis\n        digs: Tells which test to perform: 1: first digit; 2: first two digits;\n            3: furst three digits; 22: second digit; -2: last two digits.\n        confidence: confidence level to draw lower and upper limits when\n            plotting and to limit the top deviations to show.\n        limit_N: sets a limit to N as the sample size for the calculation of\n                the Z scores if the sample is too big. Defaults to None.\n    \n    Attributes:\n        N: Number of records in the sample to consider in computations\n        ddf: Degrees of Freedom to look up for the critical chi-square value\n        chi_square: Chi-square statistic for the given test\n        KS: Kolmogorov-Smirnov statistic for the given test\n        MAD: Mean Absolute Deviation for the given test\n        confidence: Confidence level to consider when setting some critical values\n        digs (int): numerical representation of the test at hand. 1: F1D; 2: F2D;\n            3: F3D; 22: SD; -2: L2D.\n        sec_order (bool): True if the test is a Second Order one \n    """"""\n\n    def __init__(self, base, digs, confidence, limit_N=None, sec_order=False):\n        # create a separated Expected distributions object\n        super(Test, self).__init__(_test_(digs))\n        # create column with occurrences of the digits in the base\n        self[\'Counts\'] = base[digs_dict[digs]].value_counts()\n        # create column with relative frequencies\n        self[\'Found\'] = base[digs_dict[digs]].value_counts(normalize=True)\n        self.fillna(0, inplace=True)\n        # create column with absolute differences\n        self[\'Dif\'] = self.Found - self.Expected\n        self[\'AbsDif\'] = self.Dif.abs()\n        self.N = _set_N_(len(base), limit_N)\n        self[\'Z_score\'] = Z_score(self, self.N)\n        self.ddf = len(self) - 1\n        self.chi_square = chi_sq_2(self)\n        self.KS = kolmogorov_smirnov_2(self)\n        self.MAD = self.AbsDif.mean()\n        self.MSE = (self.AbsDif ** 2).mean()\n        self.confidence = confidence\n        self.digs = digs\n        self.sec_order = sec_order\n\n        if sec_order:\n            self.name = names[sec_order_dict[digs]]\n        else:\n            self.name = names[digs_dict[digs]]\n    \n    def update_confidence(self, new_conf, check=True):\n        """"""Sets a new confidence level for the Benford object, so as to be used to\n        produce critical values for the tests\n\n        Args:\n            new_conf: new confidence level to draw lower and upper limits when\n                plotting and to limit the top deviations to show, as well as to\n                calculate critical values for the tests\' statistics.\n            check: checks the value provided for the confidence. Defaults to True\n        """"""\n        if check:\n            self.confidence = _check_confidence_(new_conf)\n        else:\n            self.confidence = new_conf\n\n    @property\n    def critical_values(self):\n        """"""dict: a dictionary with the critical values for the test at hand,\n            according to the current confidence level.""""""\n        return {\'Z\': confs[self.confidence],\n                \'KS\': KS_crit[self.confidence] / (self.N ** 0.5),\n                \'chi2\': crit_chi2[self.ddf][self.confidence],\n                \'MAD\': mad_dict[self.digs]\n                }\n\n    def show_plot(self):\n        """"""Draws the test plot.\n        """"""\n        x, figsize, text_x = _get_plot_args(self.digs)\n        plot_digs(self, x=x, y_Exp=self.Expected, y_Found=self.Found,\n                    N=self.N, figsize=figsize, conf_Z=confs[self.confidence],\n                    text_x=text_x\n                    )\n\n    def report(self, high_Z=\'pos\', show_plot=True):\n        """"""Handles the report especific to the test, considering its statistics\n        and according to the current confidence level.\n\n        Args:\n            high_Z: chooses which Z scores to be used when displaying results,\n                according to the confidence level chosen. Defaluts to \'pos\',\n                which will highlight only values higher than the expexted\n                frequencies; \'all\' will highlight both extremes (positive and\n                negative); and an integer, which will use the first n entries,\n                positive and negative, regardless of whether Z is higher than\n                the critical value or not.\n            show_plot: calls the show_plot method, to draw the test plot\n        """"""\n        high_Z = _check_high_Z_(high_Z)\n        _report_test_(self, high_Z, self.critical_values)\n        if show_plot:\n            self.show_plot()\n\nclass Summ(DataFrame):\n    """"""Gets the base object and outputs a Summation test object\n\n    Args:\n       base: The Base object with the data prepared for Analysis\n       test: The test for which to compute the summation\n    """"""\n    def __init__(self, base, test):\n        super(Summ, self).__init__(base.abs()\n                                   .groupby(test)[[\'Seq\']]\n                                   .sum())\n        self[\'Percent\'] = self.Seq / self.Seq.sum()\n        self.columns.values[0] = \'Sum\'\n        self.expected = 1 / len(self)\n        self[\'AbsDif\'] = (self.Percent - self.expected).abs()\n        self.index = self.index.astype(int)\n        #: Mean Absolute Deviation for the test\n        self.MAD = self.AbsDif.mean()\n        self.MSE = (self.AbsDif ** 2).mean()\n        #: Confidence level to consider when setting some critical values\n        self.confidence = None\n        # (int): numerical representation of the test at hand \n        self.digs = rev_digs[test]\n        # (str): the name of the Summation test. \n        self.name = names[f\'{test}_Summ\']\n\n    def show_plot(self):\n        """"""Draws the Summation test plot""""""\n        figsize=(2 * (self.digs ** 2 + 5), 1.5 * (self.digs ** 2 + 5))\n        plot_sum(self, figsize, self.expected)\n    \n    def report(self, high_diff=None, show_plot=True):\n        """"""Gives the report on the Summation test.\n        \n        Args:\n            high_diff: Number of records to show after ordering by the absolute\n                differences between the found and the expected proportions      \n            show_plot: calls the show_plot method, to draw the Summation test plot\n        """"""\n        _report_test_(self, high_diff)\n        if show_plot:\n            self.show_plot()\n\nclass Mantissas(object):\n    """"""Computes and holds the mantissas of the logarithms of the records\n\n    Args:\n        data: sequence to compute mantissas from. numpy 1D array, pandas\n            Series of pandas DataFrame column.\n    """"""\n\n    def __init__(self, data):\n\n        data = Series(_check_num_array_(data))\n        data = data.dropna().loc[data != 0].abs()\n        #: (DataFrame): pandas DataFrame with the mantissas\n        self.data = DataFrame({\'Mantissa\': get_mantissas(data.abs())})\n        # (dict): Dictionary with the mantissas statistics \n        self.stats = {\'Mean\': self.data.Mantissa.mean(),\n                      \'Var\': self.data.Mantissa.var(),\n                      \'Skew\': self.data.Mantissa.skew(),\n                      \'Kurt\': self.data.Mantissa.kurt()}\n\n    def report(self, show_plot=True):\n        """"""Displays the Mantissas test stats.\n\n        Args:\n            show_plot: shows the Ordered Mantissas plot and the Arc Test plot.\n                Defaults to True.\n        """"""\n        _report_mantissa_(self.stats)\n\n        if show_plot:\n            self.show_plot()\n            self.arc_test()\n\n    def show_plot(self, figsize=(12, 6)):\n        """"""Plots the ordered mantissas and a line with the expected\n        inclination.\n\n        Args:\n            figsize (tuple): figure size dimensions\n        """"""\n        plot_ordered_mantissas(self.data.Mantissa, figsize=figsize)\n\n    def arc_test(self, decimals=2, grid=True, figsize=12):\n        """"""Adds two columns to Mantissas\'s DataFrame equal to their ""X"" and ""Y""\n        coordinates, plots its to a scatter plot and calculates the gravity\n        center of the circle.\n\n        Args:\n            decimals: number of decimal places for displaying the gravity center.\n                Defaults to 2.\n            grid: show grid of the plot. Defaluts to True.\n            figsize (int): size of the figure to be displayed. Since it is a square,\n                there is no need to provide a tuple, like is usually the case with\n                matplotlib.\n        """"""\n        if self.stats.get(\'gravity_center\') is None:\n            self.data[\'mant_x\'] = cos(2 * pi * self.data.Mantissa)\n            self.data[\'mant_y\'] = sin(2 * pi * self.data.Mantissa)\n            self.stats[\'gravity_center\'] = (self.data.mant_x.mean(),\n                                            self.data.mant_y.mean())\n        \n        plot_mantissa_arc_test(self.data, self.stats, decimals=decimals, \n                               grid=grid, figsize=figsize)\n\nclass Benford(object):\n    """"""Initializes a Benford Analysis object and computes the proportions for\n    the digits. The tets dataFrames are atributes, i.e., obj.F1D is the First\n    Digit DataFrame, the obj.F2D,the First Two Digits one, and so one, F3D for\n    First Three Digits, SD for Second  Digit and L2D for Last Two Digits.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a tuple with a pandas DataFrame and the name (str)\n            of the chosen column. Values must be integers or floats.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.\n        confidence: confidence level to draw lower and upper limits when\n            plotting and to limit the top deviations to show, as well as to\n            calculate critical values for the tests\' statistics. Defaults to 95.\n        sec_order: runs the Second Order tests, which are the Benford\'s tests\n            performed on the differences between the ordered sample (a value minus\n            the one before it, and so on). If the original series is Benford-\n            compliant, this new sequence should aldo follow Beford. The Second\n            Order can also be called separately, through the method sec_order().\n        summation: creates the Summation DataFrames for the First, First Two, and\n            First Three Digits. The summation tests can also be called separately,\n            through the method summation().\n        limit_N: sets a limit to N as the sample size for the calculation of\n            the Z scores if the sample is too big. Defaults to None.\n        verbose: gives some information about the data and the registries used\n            and discarded for each test.\n\n    Attributes:\n        data: the raw data provided for the analysis\n        chosen: the column of the DataFrame to be analysed or the data itself\n        sign (str): which number sign(s) to include in the analysis\n        confidence: current confidence level\n        limit_N (int): sample size to use in computations\n        verbose (bool): verbose or not\n        base: the Base, pre-processed object\n        tests (:obj:`list` of :obj:`str`): keeps track of the tests the\n            instance has\n    """"""\n\n    def __init__(self, data, decimals=2, sign=\'all\', confidence=95,\n                 mantissas=False, sec_order=False, summation=False,\n                 limit_N=None, verbose=True):\n        self.data, self.chosen = input_data(data)\n        self.decimals = decimals\n        self.sign = sign\n        self.confidence = _check_confidence_(confidence)\n        self.limit_N = limit_N\n        self.verbose = verbose\n        self.base = Base(self.chosen, decimals, sign)\n        self.tests = []\n\n        # Create a DatFrame for each Test\n        for key, val in digs_dict.items():\n            test = Test(self.base.loc[self.base[val] != -1],\n                        digs=key, confidence=self.confidence,\n                        limit_N=self.limit_N)\n            setattr(self, val, test)\n            self.tests.append(val)\n        # dict with the numbers of discarded entries for each test column\n        self._discarded = {key: val for (key, val) in\n                           zip(digs_dict.values(),\n                               [len(self.base[col].loc[self.base[col] == -1])\n                                for col in digs_dict.values()])}\n\n        if self.verbose:\n            print(\'\\n\',\' Benford Object Instantiated \'.center(50, \'#\'),\'\\n\')\n            print(f\'Initial sample size: {len(self.chosen)}.\\n\')\n            print(f\'Test performed on {len(self.base)} registries.\\n\')\n            print(f\'Number of discarded entries for each test:\\n{self._discarded}\')\n\n        if mantissas:\n            self.mantissas()\n    \n        if sec_order:\n            self.sec_order()\n\n        if summation:\n            self.summation()\n    \n    def update_confidence(self, new_conf, tests=None):\n        """"""Sets (a) new confidence level(s) for the Benford object, so as to be\n        used to produce critical values for the tests.\n\n        Args:\n            new_conf: new confidence level to draw lower and upper limits when\n                plotting and to limit the top deviations to show, as well as to\n                calculate critical values for the tests\' statistics.\n            tests (:obj:`list` of :obj:`str`): list of tests names (strings) to\n                have their confidence updated. If only one, provide a one-element\n                list, like [\'F1D\']. Defauts to None, in which case it will use\n                the instance .test list attribute.\n        \n        Raises:\n            ValueError: if the test argument is not a `list` or `None`.\n        """"""\n        self.confidence = _check_confidence_(new_conf)\n        if tests is None:\n            tests = self.tests\n        else:\n            if not isinstance(tests, list):\n                raise ValueError(\'tests must be a list or None.\')\n        for test in tests:\n            try:\n                getattr(self, test).update_confidence(self.confidence, check=False)\n            except AttributeError:\n                if test in [\'Mantissas\', \'F1D_Summ\', \'F2D_Summ\', \'F3D_Summ\']:\n                    pass\n                else:\n                    print(f""{test} not in Benford instance tests - review test\'s name."")\n                    pass\n    \n    @property\n    def all_confidences(self):\n        """"""dict: a dictionary with a confidence level for each computed tests,\n        when applicable.""""""\n        con_dic= {}\n        for key in self.tests:\n            try:\n                con_dic[key] = getattr(self, key).confidence\n            except AttributeError:\n                pass\n        return con_dic\n\n    def mantissas(self):\n        """"""Adds a Mantissas object to the tests, with all its statistics and\n        plotting capabilities. \n        """"""\n        self.Mantissas = Mantissas(self.base.Seq)\n        self.tests.append(\'Mantissas\')\n        if self.verbose:\n            print(\'\\nAdded Mantissas test.\')\n\n    def sec_order(self):\n        """"""Runs the Second Order tests, which are the Benford\'s tests\n        performed on the differences between the ordered sample (a value minus\n        the one before it, and so on). If the original series is Benford-\n        compliant, this new sequence should aldo follow Beford. The Second\n        Order can also be called separately, through the method sec_order().\n        """"""\n        #: Base instance of the differences between the ordered sample\n        self.base_sec = Base(subtract_sorted(self.chosen),\n                             decimals=self.decimals, sign=self.sign)\n        for key, val in digs_dict.items():\n            test = Test(self.base_sec.loc[self.base_sec[val] != -1],\n                        digs=key, confidence=self.confidence,\n                        limit_N=self.limit_N, sec_order=True)\n            setattr(self, sec_order_dict[key], test)\n            self.tests.append(f\'{val}_sec\')\n            # No need to populate crit_vals dict, since they are the\n            # same and do not depend on N\n            self._discarded_sec = {key: val for (key, val) in zip(\n                                   sec_order_dict.values(),\n                                   [sum(self.base_sec[col] == -1) for col in\n                                    digs_dict.values()])}\n        if self.verbose:\n            print(f\'\\nSecond order tests run in {len(self.base_sec)} \'\n                  \'registries.\\n\\nNumber of discarded entries for second order\'\n                  f\' tests:\\n{self._discarded_sec}\')\n\n    def summation(self):\n        """"""Creates Summation test DataFrames from Base object""""""\n        for test in [\'F1D\', \'F2D\', \'F3D\']:\n            t =  f\'{test}_Summ\'\n            setattr(self, t, Summ(self.base, test))\n            self.tests.append(t)\n\n        if self.verbose:\n            print(\'\\nAdded Summation DataFrames to F1D, F2D and F3D Tests.\')\n\n\nclass Source(DataFrame):\n    """"""Prepares the data for Analysis. pandas DataFrame subclass.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.\n        sec_order: choice for the Second Order Test, which cumputes the\n            differences between the ordered entries before running the Tests.\n        verbose: tells the number of registries that are being subjected to\n            the analysis; defaults to True.\n    \n    Raises:\n        ValueError: if the `sign` arg is not in [\'all\', \'pos\', \'neg\']\n        TypeError: if not receiving `int` or `float` as input.\n    """"""\n\n    def __init__(self, data, decimals=2, sign=\'all\', sec_order=False,\n                 verbose=True, inform=None):\n\n        if sign not in [\'all\', \'pos\', \'neg\']:\n            raise ValueError(""The -sign- argument must be ""\n                             ""\'all\',\'pos\' or \'neg\'."")\n\n        DataFrame.__init__(self, {\'Seq\': data})\n\n        if self.Seq.dtypes != \'float64\' and self.Seq.dtypes != \'int64\':\n            raise TypeError(\'The sequence dtype was not pandas int64 nor float64.\\n\'\n                            \'Convert it to whether int64 of float64, and try again.\')\n\n        if sign == \'pos\':\n            self.Seq = self.Seq.loc[self.Seq > 0]\n        elif sign == \'neg\':\n            self.Seq = self.Seq.loc[self.Seq < 0]\n        else:\n            self.Seq = self.Seq.loc[self.Seq != 0]\n\n        self.dropna(inplace=True)\n        #: (bool): verbose or not\n        self.verbose = _deprecate_inform_(verbose, inform)\n        if self.verbose:\n            print(f""\\nInitialized sequence with {len(self)} registries."")\n\n        if sec_order:\n            self.Seq = subtract_sorted(self.Seq.copy())\n            self.dropna(inplace=True)\n            self.reset_index(inplace=True)\n            if verbose:\n                print(\'Second Order Test. Initial series reduced \'\n                      f\'to {len(self.Seq)} entries.\')\n\n        ab = self.Seq.abs()\n\n        if self.Seq.dtypes == \'int64\':\n            self[\'ZN\'] = ab\n        else:\n            if decimals == \'infer\':\n                # There is some numerical issue with Windows that required\n                # implementing it differently (and slower)\n                self[\'ZN\'] = ab.astype(str)\\\n                               .str.replace(\'.\', \'\')\\\n                               .str.lstrip(\'0\').str[:5]\\\n                               .astype(int)\n            else:\n                self[\'ZN\'] = (ab * (10 ** decimals)).astype(int)\n\n    def mantissas(self, report=True, plot=True, figsize=(15, 8)):\n        """"""Calculates the mantissas, their mean and variance, and compares them\n        with the mean and variance of a Benford\'s sequence.\n\n        Args:\n            report: prints the mamtissas mean, variance, skewness and kurtosis\n                for the sequence studied, along with reference values.\n            plot: plots the ordered mantissas and a line with the expected\n                inclination. Defaults to True.\n            figsize: tuple that sets the figure dimensions.\n        """"""\n        self[\'Mant\'] = get_mantissas(self.Seq.abs())\n        if report:\n            p = self[[\'Seq\', \'Mant\']]\n            p = p.loc[p.Seq > 0].sort_values(\'Mant\')\n            print(f""The Mantissas MEAN is {p.Mant.mean()}. Ref: 0.5."")\n            print(f""The Mantissas VARIANCE is {p.Mant.var()}. Ref: 0.083333."")\n            print(f""The Mantissas SKEWNESS is {p.Mant.skew()}. \\tRef: 0."")\n            print(f""The Mantissas KURTOSIS is {p.Mant.kurt()}. \\tRef: -1.2."")\n\n        if plot:\n            plot_ordered_mantissas(self.Mant, figsize=figsize)\n\n\n    def first_digits(self, digs, confidence=None, high_Z=\'pos\',\n                     limit_N=None, MAD=False, MSE=False, chi_square=False,\n                     KS=False, show_plot=True, simple=False, ret_df=False):\n        """"""Performs the Benford First Digits test with the series of\n        numbers provided, and populates the mapping dict for future\n        selection of the original series.\n\n        Args:\n            digs: number of first digits to consider. Must be 1 (first digit),\n                2 (first two digits) or 3 (first three digits).\n            verbose: tells the number of registries that are being subjected to\n                the analysis; defaults to True\n            digs: number of first digits to consider. Must be 1 (first digit),\n                2 (first two digits) or 3 (first three digits).\n            confidence: confidence level to draw lower and upper limits when\n                plotting and to limit the top deviations to show, as well as to\n                calculate critical values for the tests\' statistics. Defaults to None.\n            high_Z: chooses which Z scores to be used when displaying results,\n                according to the confidence level chosen. Defaluts to \'pos\',\n                which will highlight only values higher than the expexted\n                frequencies; \'all\' will highlight both extremes (positive and\n                negative); and an integer, which will use the first n entries,\n                positive and negative, regardless of whether Z is higher than\n                the confidence or not.\n            limit_N: sets a limit to N as the sample size for the calculation of\n                the Z scores if the sample is too big. Defaults to None.\n            MAD: calculates the Mean Absolute Difference between the\n                found and the expected distributions; defaults to False.\n            MSE: calculates the Mean Square Error of the sample; defaults to\n                False.\n            show_plot: draws the test plot. Defaults to True.\n            ret_df: returns the test DataFrame. Defaults to False. True if run by\n                the test function.\n\n        Returns:\n            DataFrame with the Expected and Found proportions, and the Z scores of\n                the differences\n        """"""\n        # Check on the possible values for confidence levels\n        confidence = _check_confidence_(confidence)\n        # Check on possible digits\n        _check_test_(digs)\n\n        temp = self.loc[self.ZN >= 10 ** (digs - 1)]\n        temp[digs_dict[digs]] = (temp.ZN // 10 ** ((log10(temp.ZN).astype(\n                                                   int)) - (digs - 1))).astype(\n                                                       int)\n        n, m = 10 ** (digs - 1), 10 ** (digs)\n        x = arange(n, m)\n\n        if simple:\n            self.verbose = False\n            show_plot = False\n            df = prepare(temp[digs_dict[digs]], digs, limit_N=limit_N,\n                        simple=True, confidence=None)\n        else:\n            N, df = prepare(temp[digs_dict[digs]], digs, limit_N=limit_N,\n                           simple=False, confidence=confidence)\n\n        if self.verbose:\n            print(f""\\nTest performed on {len(temp)} registries.\\n""\n                  f""Discarded {len(self) - len(temp)} records < {10 ** (digs - 1)}""\n                  "" after preparation."")\n            if confidence is not None:\n                _inform_(df, high_Z=high_Z, conf=confs[confidence])\n\n        # Mean absolute difference\n        if MAD:\n            self.MAD = df.AbsDif.mean()\n            if self.verbose:\n                _report_mad_(digs, self.MAD)\n\n        # Mean Square Error\n        if MSE:\n            self.MSE = (df.AbsDif ** 2).mean()\n\n        # Chi-square statistic\n        if chi_square:\n            self.chi_square = chi_sq(df, ddf=len(df) - 1,\n                                           confidence=confidence,\n                                           verbose=self.verbose)\n        # KS test\n        if KS:\n            self.KS = kolmogorov_smirnov(df, confidence=confidence, N=len(temp),\n                           verbose=self.verbose)\n\n        # Plotting the expected frequncies (line) against the found ones(bars)\n        if show_plot:\n            plot_digs(df, x=x, y_Exp=df.Expected, y_Found=df.Found, N=N,\n                       figsize=(2 * (digs ** 2 + 5), 1.5 * (digs ** 2 + 5)),\n                       conf_Z=confs[confidence])\n        if ret_df:\n            return df\n\n    def second_digit(self, confidence=None, high_Z=\'pos\',\n                     limit_N=None, MAD=False, MSE=False, chi_square=False,\n                     KS=False, show_plot=True, simple=False, ret_df=False):\n        """"""Performs the Benford Second Digit test with the series of\n        numbers provided.\n\n        Args:\n            verbose: tells the number of registries that are being subjected to\n                the analysis; defaults to True\n            MAD: calculates the Mean Absolute Difference between the\n                found and the expected distributions; defaults to False.\n            confidence: confidence level to draw lower and upper limits when\n                plotting and to limit the top deviations to show, as well as to\n                calculate critical values for the tests\' statistics. Defaults to None.\n            high_Z: chooses which Z scores to be used when displaying results,\n                according to the confidence level chosen. Defaluts to \'pos\',\n                which will highlight only values higher than the expexted\n                frequencies; \'all\' will highlight both extremes (positive and\n                negative); and an integer, which will use the first n entries,\n                positive and negative, regardless of whether Z is higher than\n                the confidence or not.\n            limit_N: sets a limit to N as the sample size for the calculation of\n                the Z scores if the sample is too big. Defaults to None.\n            MSE: calculates the Mean Square Error of the sample; defaults to\n                False.\n            show_plot: draws the test plot.\n            ret_df: returns the test DataFrame. Defaults to False. True if run by\n                the test function.\n        \n        Returns:\n            DataFrame with the Expected and Found proportions, and the Z scores of\n                the differences\n        """"""\n        confidence = _check_confidence_(confidence)\n\n        conf = confs[confidence]\n\n        temp = self.loc[self.ZN >= 10, :]\n        temp[\'SD\'] = (temp.ZN // 10 ** ((log10(temp.ZN)).astype(\n                      int) - 1)) % 10\n\n        if simple:\n            self.verbose = False\n            show_plot = False\n            df = prepare(temp[\'SD\'], 22, limit_N=limit_N, simple=True,\n                        confidence=None)\n        else:\n            N, df = prepare(temp[\'SD\'], 22, limit_N=limit_N, simple=False,\n                           confidence=confidence)\n\n        if self.verbose:\n            print(f""\\nTest performed on {len(temp)} registries.\\nDiscarded ""\n                  f""{len(self) - len(temp)} records < 10 after preparation."")\n            if confidence is not None:\n                _inform_(df, high_Z, conf)\n\n        # Mean absolute difference\n        if MAD:\n            self.MAD = df.AbsDif.mean()\n            if self.verbose:\n                _report_mad_(22, self.MAD)\n        # Mean Square Error\n        if MSE:\n            self.MSE = (df.AbsDif ** 2).mean()\n\n        # Chi-square statistic\n        if chi_square:\n            self.chi_square = chi_sq(df, ddf=9, confidence=confidence,\n                                           verbose=self.verbose)\n        # KS test\n        if KS:\n            self.KS = kolmogorov_smirnov(df, confidence=confidence, N=len(temp),\n                           verbose=self.verbose)\n\n        # Plotting the expected frequncies (line) against the found ones(bars)\n        if show_plot:\n            plot_digs(df, x=arange(0, 10), y_Exp=df.Expected,\n                       y_Found=df.Found, N=N, figsize=(10, 6), conf_Z=conf)\n        if ret_df:\n            return df\n\n    def last_two_digits(self, confidence=None, high_Z=\'pos\',\n                        limit_N=None, MAD=False, MSE=False, chi_square=False,\n                        KS=False, show_plot=True, simple=False, ret_df=False):\n        """"""Performs the Benford Last Two Digits test with the series of\n        numbers provided.\n\n        Args:\n            verbose: tells the number of registries that are being subjected to\n                the analysis; defaults to True\n            MAD: calculates the Mean Absolute Difference between the\n                found and the expected distributions; defaults to False.\n            confidence: confidence level to draw lower and upper limits when\n                plotting and to limit the top deviations to show, as well as to\n                calculate critical values for the tests\' statistics. Defaults to None.\n            high_Z: chooses which Z scores to be used when displaying results,\n                according to the confidence level chosen. Defaluts to \'pos\',\n                which will highlight only values higher than the expexted\n                frequencies; \'all\' will highlight both extremes (positive and\n                negative); and an integer, which will use the first n entries,\n                positive and negative, regardless of whether Z is higher than\n                the confidence or not.\n            limit_N: sets a limit to N as the sample size for the calculation of\n                the Z scores if the sample is too big. Defaults to None.\n            MSE: calculates the Mean Square Error of the sample; defaults to\n                False.\n            show_plot: draws the test plot.\n        \n        Returns:\n            DataFrame with the Expected and Found proportions, and the Z scores of\n                the differences\n        """"""\n        confidence = _check_confidence_(confidence)\n        conf = confs[confidence]\n\n        temp = self.loc[self.ZN >= 1000]\n        temp[\'L2D\'] = temp.ZN % 100\n\n        if simple:\n            self.verbose = False\n            show_plot = False\n            df = prepare(temp[\'L2D\'], -2, limit_N=limit_N, simple=True,\n                        confidence=None)\n        else:\n            N, df = prepare(temp[\'L2D\'], -2, limit_N=limit_N, simple=False,\n                           confidence=confidence)\n\n        if self.verbose:\n            print(f""\\nTest performed on {len(temp)} registries.\\n\\nDiscarded ""\n                  f""{len(self) - len(temp)} records < 1000 after preparation"")\n            if confidence is not None:\n                _inform_(df, high_Z, conf)\n\n        # Mean absolute difference\n        if MAD:\n            self.MAD = df.AbsDif.mean()\n            if self.verbose:\n                _report_mad_(-2, self.MAD)\n        # Mean Square Error\n        if MSE:\n            self.MSE = (df.AbsDif ** 2).mean()\n\n        # Chi-square statistic\n        if chi_square:\n            self.chi_square = chi_sq(df, ddf=99, confidence=confidence,\n                                           verbose=self.verbose)\n        # KS test\n        if KS:\n            self.KS = kolmogorov_smirnov(df, confidence=confidence, N=len(temp),\n                           verbose=self.verbose)\n\n        # Plotting expected frequencies (line) versus found ones (bars)\n        if show_plot:\n            plot_digs(df, x=arange(0, 100), y_Exp=df.Expected,\n                       y_Found=df.Found, N=N, figsize=(15, 5),\n                       conf_Z=conf, text_x=True)\n        if ret_df:\n            return df\n\n    def summation(self, digs=2, top=20, show_plot=True,\n                  ret_df=False):\n        """"""Performs the Summation test. In a Benford series, the sums of the\n        entries begining with the same digits tends to be the same.\n\n        Args:\n            digs: tells the first digits to use. 1- first; 2- first two;\n                3- first three. Defaults to 2.\n            top: choses how many top values to show. Defaults to 20.\n            show_plot: plots the results. Defaults to True.\n        \n        Returns:\n            DataFrame with the Expected and Found proportions, and their\n            absolute differences\n        """"""\n        _check_digs_(digs)\n\n        if digs == 1:\n            top = 9\n        # Call the dict for F1D, F2D, F3D\n        d = digs_dict[digs]\n        if d not in self.columns:\n            self[d] = self.ZN.astype(str).str[:digs].astype(int)\n        # Call the expected proportion according to digs\n        li = 1. / (9 * (10 ** (digs - 1)))\n\n        df = self.groupby(d).sum()\n        # s.drop(0, inplace=True)\n        df[\'Percent\'] = df.ZN / df.ZN.sum()\n        df.columns.values[1] = \'Summ\'\n        df = df[[\'Summ\', \'Percent\']]\n        df[\'AbsDif\'] = (df.Percent - li).abs()\n\n        if self.verbose:\n            # N = len(self)\n            print(f""\\nTest performed on {len(self)} registries.\\n"")\n            print(f""The top {top} diferences are:\\n"")\n            print(df[:top])\n\n        if show_plot:\n            plot_sum(df, figsize=(\n                       2 * (digs ** 2 + 5), 1.5 * (digs ** 2 + 5)), li=li)\n\n        if ret_df:\n            return df\n\n    def duplicates(self, top_Rep=20, inform=None):\n        """"""Performs a duplicates test and maps the duplicates count in descending\n        order.\n\n        Args:\n            verbose: tells how many duplicated entries were found and prints the\n                top numbers according to the top_Rep argument. Defaluts to True.\n            top_Rep: int or None. Chooses how many duplicated entries will be\n                shown withe the top repititions. Defaluts to 20. If None, returns\n                al the ordered repetitions.\n        \n        Returns:\n            DataFrame with the duplicated records and their occurrence counts,\n                in descending order (if verbose is False; if True, prints to\n                terminal).\n        \n        Raises:\n            ValueError: if the `top_Rep` arg is not int or None.\n        """"""\n        if top_Rep is not None and not isinstance(top_Rep, int):\n            raise ValueError(\'The top_Rep argument must be an int or None.\')\n\n        dup = self[[\'Seq\']][self.Seq.duplicated(keep=False)]\n        dup_count = dup.groupby(self.Seq).count()\n\n        dup_count.index.names = [\'Entries\']\n        dup_count.rename(columns={\'Seq\': \'Count\'}, inplace=True)\n\n        dup_count.sort_values(\'Count\', ascending=False, inplace=True)\n\n        # self.maps[\'dup\'] = dup_count.index[:top_Rep].values  # array\n\n        if self.verbose:\n            print(f\'\\nFound {len(dup_count)} duplicated entries.\\n\'\n                  f\'The entries with the {top_Rep} highest repitition counts are:\')\n            print(dup_count.head(top_Rep))\n        else:\n            return dup_count\n\n\nclass Mantissas(object):\n    """"""\n    Returns a Series with the data mantissas,\n\n    Args:\n        data: sequence to compute mantissas from, numpy 1D array, pandas\n            Series of pandas DataFrame column.\n    Attributes:\n        data (DataFrame): holds the computed mantissas and, if the arc_test\n            is also called, the respecttive x and Y coordinates for the plot.\n        stats (dict): holds the relevant statistics about the data mantissas.\n    """"""\n\n    def __init__(self, data):\n\n        data = Series(_check_num_array_(data))\n        data = data.dropna().loc[data != 0].abs()\n        \n        self.data = DataFrame({\'Mantissa\': get_mantissas(data.abs())})\n\n        self.stats = {\'Mean\': self.data.Mantissa.mean(),\n                      \'Var\': self.data.Mantissa.var(),\n                      \'Skew\': self.data.Mantissa.skew(),\n                      \'Kurt\': self.data.Mantissa.kurt()}\n\n    def report(self, show_plot=True):\n        """"""Displays the Mantissas stats.\n\n        Args:\n            show_plot: shows the ordered mantissas plot and the Arc Test plot.\n                Defaults to True.\n        """"""\n        print(""\\n"", \'  Mantissas Test  \'.center(52, \'#\'))\n        print(f""\\nThe Mantissas MEAN is      {self.stats[\'Mean\']:.6f}.""\n              ""\\tRef: 0.5"")\n        print(f""The Mantissas VARIANCE is  {self.stats[\'Var\']:.6f}.""\n              ""\\tRef: 0.08333"")\n        print(f""The Mantissas SKEWNESS is  {self.stats[\'Skew\']:.6f}.""\n              ""\\tRef: 0.0"")\n        print(f""The Mantissas KURTOSIS is  {self.stats[\'Kurt\']:.6f}.""\n              ""\\tRef: -1.2\\n"")\n        if show_plot:\n            self.show_plot()\n            self.arc_test()\n\n    def show_plot(self, figsize=(12, 12)):\n        """"""Plots the ordered mantissas and compares them to the expected, straight\n        line that should be formed in a Benford-cmpliant set.\n\n        Args:\n            figsize: tuple that sets the figure size.\n        """"""\n        plot_ordered_mantissas(self.data.Mantissa, figsize=figsize)\n \n    def arc_test(self, grid=True, figsize=12):\n        """"""\n        Add two columns to Mantissas\'s DataFrame equal to their ""X"" and ""Y""\n        coordinates, plots its to a scatter plot and calculates the gravity\n        center of the circle.\n\n        Args:\n            grid:show grid of the plot. Defaluts to True.\n            figsize: size of the figure to be displayed. Since it is a square,\n                there is no need to provide a tuple, like is usually the case with\n                matplotlib.\n        """"""\n        if self.stats.get(\'gravity_center\') is None:\n            self.data[\'mant_x\'] = cos(2 * pi * self.data.Mantissa)\n            self.data[\'mant_y\'] = sin(2 * pi * self.data.Mantissa)\n            self.stats[\'gravity_center\'] = (self.data.mant_x.mean(),\n                                            self.data.mant_y.mean())\n        plot_mantissa_arc_test(self.data, self.stats[\'gravity_center\'],\n                               figsize=figsize)\n\n\nclass Roll_mad(object):\n    """"""Applies the MAD to sequential subsets of the Series, returning another\n    Series.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        test: tells which test to use. 1: Fisrt Digits; 2: First Two Digits;\n            3: First Three Digits; 22: Second Digit; and -2: Last Two Digits.\n        window: size of the subset to be used.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.\n\n    """"""\n\n    def __init__(self, data, test, window, decimals=2, sign=\'all\'):\n\n        #: the test (F1D, SD, F2D...) used for the MAD calculation and critical values\n        self.test = _check_test_(test)\n\n        if not isinstance(data, Source):\n            start = Source(data, sign=sign, decimals=decimals, verbose=False)\n\n        Exp, ind = prep_to_roll(start, self.test)\n\n        self.roll_series = start[digs_dict[test]].rolling(\n                                window=window).apply(mad_to_roll, \n                                    args=(Exp, ind), raw=False)\n        self.roll_series.dropna(inplace=True)\n\n    def show_plot(self, figsize=(15, 8)):\n        """"""Shows the rolling MAD plot\n        \n        Args:\n            figsize: the figure dimensions.\n        """"""\n        plot_roll_mad(self, figsize=figsize)\n\n\nclass Roll_mse(object):\n    """"""Applies the MSE to sequential subsets of the Series, returning another\n    Series.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        test: tells which test to use. 1: Fisrt Digits; 2: First Two Digits;\n            3: First Three Digits; 22: Second Digit; and -2: Last Two Digits.\n        window: size of the subset to be used.\n            decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. \'pos\': only the positive\n            entries; \'neg\': only negative entries; \'all\': all entries but zeros.\n            Defaults to \'all\'.\n    """"""\n\n    def __init__(self, data, test, window, decimals=2, sign=\'all\'):\n\n        test = _check_test_(test)\n\n        if not isinstance(data, Source):\n            start = Source(data, sign=sign, decimals=decimals, verbose=False)\n\n        Exp, ind = prep_to_roll(start, test)\n\n        self.roll_series = start[digs_dict[test]].rolling(\n                                window=window).apply(mse_to_roll, \n                                    args=(Exp, ind), raw=False)\n        self.roll_series.dropna(inplace=True)\n\n    def show_plot(self, figsize=(15, 8)):\n        """"""Shows the rolling MSE plot\n        \n        Args:\n            figsize: the figure dimensions.\n        """"""\n        plot_roll_mse(self.roll_series, figsize=figsize)\n\n\n\ndef first_digits(data, digs, decimals=2, sign=\'all\', verbose=True,\n                 confidence=None, high_Z=\'pos\', limit_N=None,\n                 MAD=False, MSE=False, chi_square=False, KS=False,\n                 show_plot=True, inform=None):\n    """"""Performs the Benford First Digits test on the series of\n    numbers provided.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. \'pos\': only the positive\n            entries; \'neg\': only negative entries; \'all\': all entries but zeros.\n            Defaults to \'all\'.\n        digs: number of first digits to consider. Must be 1 (first digit),\n            2 (first two digits) or 3 (first three digits).\n        verbose: tells the number of registries that are being subjected to\n            the analysis and returns tha analysis DataFrame sorted by the\n            highest Z score down. Defaults to True.\n        MAD: calculates the Mean Absolute Difference between the\n            found and the expected distributions; defaults to False.\n        confidence: confidence level to draw lower and upper limits when\n            plotting and to limit the top deviations to show. Defaults to None.\n        high_Z: chooses which Z scores to be used when displaying results,\n            according to the confidence level chosen. Defaluts to \'pos\',\n            which will highlight only values higher than the expexted\n            frequencies; \'all\' will highlight both extremes (positive and\n            negative); and an integer, which will use the first n entries,\n            positive and negative, regardless of whether Z is higher than\n            the confidence or not.\n        limit_N: sets a limit to N as the sample size for the calculation of\n            the Z scores if the sample is too big. Defaults to None.\n        MSE: calculates the Mean Square Error of the sample; defaults to\n            False.\n        chi_square: calculates the chi_square statistic of the sample and\n            compares it with a critical value, according to the confidence\n            level chosen and the series\'s degrees of freedom. Defaults to\n            False. Requires confidence != None.\n        KS: calculates the Kolmogorov-Smirnov test, comparing the cumulative\n            distribution of the sample with the Benford\'s, according to the\n            confidence level chosen. Defaults to False. Requires confidence\n            != None.\n        show_plot: draws the test plot.\n    \n    Returns:\n        DataFrame with the Expected and Found proportions, and the Z scores of\n            the differences if the confidence is not None.\n    """"""\n    verbose = _deprecate_inform_(verbose, inform)\n\n    if not isinstance(data, Source):\n        data = Source(data, decimals=decimals, sign=sign, verbose=verbose)\n\n    data = data.first_digits(digs, confidence=confidence, high_Z=high_Z,\n                             limit_N=limit_N, MAD=MAD, MSE=MSE,\n                             chi_square=chi_square, KS=KS, show_plot=show_plot,\n                             ret_df=True)\n\n    if confidence is not None:\n        data = data[[\'Counts\', \'Found\', \'Expected\', \'Z_score\']]\n        return data.sort_values(\'Z_score\', ascending=False)\n    else:\n        return data[[\'Counts\', \'Found\', \'Expected\']]\n\n\ndef second_digit(data, decimals=2, sign=\'all\', verbose=True,\n                 confidence=None, high_Z=\'pos\', limit_N=None,\n                 MAD=False, MSE=False, chi_square=False, KS=False,\n                 show_plot=True, inform=None):\n    """"""Performs the Benford Second Digits test on the series of\n    numbers provided.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. \'pos\': only the positive\n            entries; \'neg\': only negative entries; \'all\': all entries but zeros.\n            Defaults to \'all\'.\n        verbose: tells the number of registries that are being subjected to\n            the analysis and returns tha analysis DataFrame sorted by the\n            highest Z score down. Defaults to True.\n        MAD: calculates the Mean Absolute Difference between the\n            found and the expected distributions; defaults to False.\n        confidence: confidence level to draw lower and upper limits when\n            plotting and to limit the top deviations to show. Defaults to None.\n        high_Z: chooses which Z scores to be used when displaying results,\n            according to the confidence level chosen. Defaluts to \'pos\',\n            which will highlight only values higher than the expexted\n            frequencies; \'all\' will highlight both extremes (positive and\n            negative); and an integer, which will use the first n entries,\n            positive and negative, regardless of whether Z is higher than\n            the confidence or not.\n        limit_N: sets a limit to N as the sample size for the calculation of\n            the Z scores if the sample is too big. Defaults to None.\n        MSE: calculates the Mean Square Error of the sample; defaults to\n            False.\n        chi_square: calculates the chi_square statistic of the sample and\n            compares it with a critical value, according to the confidence\n            level chosen and the series\'s degrees of freedom. Defaults to\n            False. Requires confidence != None.\n        KS: calculates the Kolmogorov-Smirnov test, comparing the cumulative\n            distribution of the sample with the Benford\'s, according to the\n            confidence level chosen. Defaults to False. Requires confidence\n            != None.\n        show_plot: draws the test plot.\n\n    Returns:\n        DataFrame with the Expected and Found proportions, and the Z scores of\n            the differences if the confidence is not None.\n    """"""\n    verbose = _deprecate_inform_(verbose, inform)\n\n    if not isinstance(data, Source):\n        data = Source(data, sign=sign, decimals=decimals, verbose=verbose)\n\n    data = data.second_digit(confidence=confidence, high_Z=high_Z,\n                             limit_N=limit_N, MAD=MAD, MSE=MSE,\n                             chi_square=chi_square, KS=KS, show_plot=show_plot,\n                             ret_df=True)\n    if confidence is not None:\n        data = data[[\'Counts\', \'Found\', \'Expected\', \'Z_score\']]\n        return data.sort_values(\'Z_score\', ascending=False)\n    else:\n        return data[[\'Counts\', \'Found\', \'Expected\']]\n\n\ndef last_two_digits(data, decimals=2, sign=\'all\', verbose=True,\n                    confidence=None, high_Z=\'pos\', limit_N=None,\n                    MAD=False, MSE=False, chi_square=False, KS=False,\n                    show_plot=True, inform=None):\n    """"""Performs the Last Two Digits test on the series of\n    numbers provided.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column,with values being\n            integers or floats.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. \'pos\': only the positive\n            entries; \'neg\': only negative entries; \'all\': all entries but zeros.\n            Defaults to \'all\'.\n        verbose: tells the number of registries that are being subjected to\n            the analysis and returns tha analysis DataFrame sorted by the\n            highest Z score down. Defaults to True.\n        confidence: confidence level to draw lower and upper limits when\n            plotting and to limit the top deviations to show. Defaults to None.\n        high_Z: chooses which Z scores to be used when displaying results,\n            according to the confidence level chosen. Defaluts to \'pos\',\n            which will highlight only values higher than the expexted\n            frequencies; \'all\' will highlight both extremes (positive and\n            negative); and an integer, which will use the first n entries,\n            positive and negative, regardless of whether Z is higher than\n            the confidence or not.\n        limit_N: sets a limit to N as the sample size for the calculation of\n            the Z scores if the sample is too big. Defaults to None.\n        MAD: calculates the Mean Absolute Difference between the\n            found and the expected distributions; defaults to False.\n        MSE: calculates the Mean Square Error of the sample; defaults to\n            False.\n        chi_square: calculates the chi_square statistic of the sample and\n            compares it with a critical value, according to the confidence\n            level chosen and the series\'s degrees of freedom. Defaults to\n            False. Requires confidence != None.\n        KS: calculates the Kolmogorov-Smirnov test, comparing the cumulative\n            distribution of the sample with the Benford\'s, according to the\n            confidence level chosen. Defaults to False. Requires confidence\n            != None.\n        show_plot: draws the test plot.\n\n    Returns:\n        DataFrame with the Expected and Found proportions, and the Z scores of\n            the differences if the confidence is not None.\n    """"""\n    verbose = _deprecate_inform_(verbose, inform)\n\n    if not isinstance(data, Source):\n        data = Source(data, decimals=decimals, sign=sign, verbose=verbose)\n\n    data = data.last_two_digits(confidence=confidence, high_Z=high_Z,\n                                limit_N=limit_N, MAD=MAD,\n                                MSE=MSE, chi_square=chi_square, KS=KS,\n                                show_plot=show_plot, ret_df=True)\n\n    if confidence is not None:\n        data = data[[\'Counts\', \'Found\', \'Expected\', \'Z_score\']]\n        return data.sort_values(\'Z_score\', ascending=False)\n    else:\n        return data[[\'Counts\', \'Found\', \'Expected\']]\n\n\ndef mantissas(data, report=True, show_plot=True, arc_test=True, inform=None):\n    """"""Extraxts the mantissas of the records logarithms\n\n    Args:\n        data: sequence to compute mantissas from, numpy 1D array, pandas Series\n            of pandas DataFrame column.\n        report: prints the mamtissas mean, variance, skewness and kurtosis\n            for the sequence studied, along with reference values.\n        show_plot: plots the ordered mantissas and a line with the expected\n            inclination. Defaults to True.\n        arc_test: draws the Arc Test plot. Defaluts to True.\n    \n    Returns:\n        Series with the data mantissas.\n    """"""\n    report = _deprecate_inform_(report, inform)\n\n    mant = Mantissas(data)\n    if report:\n        mant.report()\n    if show_plot:\n        mant.show_plot()\n    if arc_test:\n        mant.arc_test()\n    return mant\n\n\ndef summation(data, digs=2, decimals=2, sign=\'all\', top=20, verbose=True,\n              show_plot=True, inform=None):\n    """"""Performs the Summation test. In a Benford series, the sums of the\n    entries begining with the same digits tends to be the same.\n    Works only with the First Digits (1, 2 or 3) test.\n\n    Args:\n        digs: tells the first digits to use: 1- first; 2- first two;\n            3- first three. Defaults to 2.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        top: choses how many top values to show. Defaults to 20.\n        show_plot: plots the results. Defaults to True.\n    \n    Returns:\n        DataFrame with the Summation test, whether sorted in descending order\n            (if verbose == True) or not.\n    """"""\n    verbose = _deprecate_inform_(verbose, inform)\n\n    if not isinstance(data, Source):\n        data = Source(data, sign=sign, decimals=decimals, verbose=verbose)\n\n    data = data.summation(digs=digs, top=top, verbose=verbose,\n                          show_plot=show_plot, ret_df=True)\n    if verbose:\n        return data.sort_values(\'AbsDif\', ascending=False)\n    else:\n        return data\n\n\ndef mad(data, test, decimals=2, sign=\'all\', verbose=False):\n    """"""Calculates the Mean Absolute Deviation of the Series\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        test: informs which base test to use for the mad.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.\n    Returns:\n        float: the Mean Absolute Deviation of the Series\n    """"""\n    data = _check_num_array_(data)\n    test = _check_test_(test)\n    start = Source(data, sign=sign, decimals=decimals, verbose=verbose)\n    if test in [1, 2, 3]:\n        start.first_digits(digs=test, MAD=True, MSE=True, simple=True)\n    elif test == 22:\n        start.second_digit(MAD=True, MSE=False, simple=True)\n    else:\n        start.last_two_digits(MAD=True, MSE=False, simple=True)\n    return start.MAD\n\n\ndef mse(data, test, decimals=2, sign=\'all\', verbose=False):\n    """"""Calculates the Mean Squared Error of the Series\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        test: informs which base test to use for the mad.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.\n    Returns:\n        float: the Mean Squared Error of the Series\n    """"""\n    data = _check_num_array_(data)\n    test = _check_test_(test)\n    start = Source(data, sign=sign, decimals=decimals, verbose=verbose)\n    if test in [1, 2, 3]:\n        start.first_digits(digs=test, MAD=False, MSE=True, simple=True)\n    elif test == 22:\n        start.second_digit(MAD=False, MSE=True, simple=True)\n    else:\n        start.last_two_digits(MAD=False, MSE=True, simple=True)\n    return start.MSE\n\n\ndef mad_summ(data, test, decimals=2, sign=\'all\', verbose=False):\n    """"""Calculate the Mean Absolute Deviation of the Summation Test\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        test: informs which base test to use for the summation mad.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.\n    \n    Returns:\n        float: the Mean Absolute Deviation of the Summation Test\n    """"""\n    data = _check_num_array_(data)\n    test = _check_digs_(test)\n\n    start = Source(data, sign=sign, decimals=decimals, verbose=verbose)\n    temp = start.loc[start.ZN >= 10 ** (test - 1)]\n    temp[digs_dict[test]] = (temp.ZN // 10 ** ((log10(temp.ZN).astype(\n                                                int)) - (test - 1))).astype(\n                                                    int)\n    li = 1. / (9 * (10 ** (test - 1)))\n\n    df = temp.groupby(digs_dict[test]).sum()\n    return mean(abs(df.ZN / df.ZN.sum() - li))\n\n\ndef rolling_mad(data, test, window, decimals=2, sign=\'all\', show_plot=False):\n    """"""Applies the MAD to sequential subsets of the records.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        test: tells which test to use. 1: Fisrt Digits; 2: First Two Digits;\n            3: First Three Digits; 22: Second Digit; and -2: Last Two Digits.\n        window: size of the subset to be used.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.\n        show_plot: draws the test plot.\n    \n    Returns:\n        Series with sequentially computed MADs.\n    """"""\n    data = _check_num_array_(data)\n    r_mad = Roll_mad(data, test, window, decimals, sign)\n    if show_plot:\n        r_mad.show_plot()\n    return r_mad.roll_series\n\n\ndef rolling_mse(data, test, window, decimals=2, sign=\'all\', show_plot=False):\n    """"""Applies the MSE to sequential subsets of the records.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        test: tells which test to use. 1: Fisrt Digits; 2: First Two Digits;\n            3: First Three Digits; 22: Second Digit; and -2: Last Two Digits.\n        window: size of the subset to be used.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.\n        show_plot: draws the test plot.\n    \n    Returns:\n        Series with sequentially computed MSEs.\n    """"""\n    data = _check_num_array_(data)\n    r_mse = Roll_mse(data, test, window, decimals, sign)\n    if show_plot:\n        r_mse.show_plot()\n    return r_mse.roll_series\n\n\ndef duplicates(data, top_Rep=20, verbose=True, inform=None):\n    """"""Performs a duplicates test and maps the duplicates count in descending\n    order.\n\n    Args:\n        data: sequence to take the duplicates from. pandas Series or\n            numpy Ndarray.\n        verbose: tells how many duplicated entries were found and prints the\n            top numbers according to the top_Rep argument. Defaluts to True.\n        top_Rep: chooses how many duplicated entries will be\n            shown withe the top repititions. int or None. Defaluts to 20.\n            If None, returns al the ordered repetitions.\n    \n    Returns:\n        DataFrame with the duplicated records and their respective counts\n    \n    Raises:\n        ValueError: if the `top_Rep` arg is not int or None.\n    """"""\n    verbose = _deprecate_inform_(verbose, inform)\n\n    if top_Rep is not None and not isinstance(top_Rep, int):\n        raise ValueError(\'The top_Rep argument must be an int or None.\')\n\n    if not isinstance(data, Series):\n        try:\n            data = Series(data)\n        except ValueError:\n            print(\'\\ndata must be a numpy Ndarray or a pandas Series.\')\n\n    dup = data.loc[data.duplicated(keep=False)]\n    dup_count = dup.value_counts()\n\n    dup_count.index.names = [\'Entries\']\n    dup_count.name = \'Count\'\n\n    if verbose:\n        print(f\'\\nFound {len(dup_count)} duplicated entries.\\n\'\n              f\'The entries with the {top_Rep} highest repitition counts are:\')\n        print(dup_count.head(top_Rep))\n\n    return dup_count\n\n\ndef second_order(data, test, decimals=2, sign=\'all\', verbose=True, MAD=False,\n                 confidence=None, high_Z=\'pos\', limit_N=None, MSE=False,\n                 show_plot=True, inform=None):\n    """"""Performs the chosen test after subtracting the ordered sequence by itself.\n    Hence Second Order.\n\n    Args:\n        data: sequence of numbers to be evaluated. Must be a numpy 1D array,\n            a pandas Series or a pandas DataFrame column, with values being\n            integers or floats.\n        test: the test to be performed - 1 or \'F1D\': First Digit; 2 or \'F2D\':\n            First Two Digits; 3 or \'F3D\': First three Digits; 22 or \'SD\':\n            Second Digits; -2 or \'L2D\': Last Two Digits.\n        decimals: number of decimal places to consider. Defaluts to 2.\n            If integers, set to 0. If set to -infer-, it will remove the zeros\n            and consider up to the fifth decimal place to the right, but will\n            loose performance.\n        sign: tells which portion of the data to consider. pos: only the positive\n            entries; neg: only negative entries; all: all entries but zeros.\n            Defaults to all.\n        verbose: tells the number of registries that are being subjected to\n            the analysis and returns tha analysis DataFrame sorted by the\n            highest Z score down. Defaults to True.\n        MAD: calculates the Mean Absolute Difference between the\n            found and the expected distributions; defaults to False.\n        confidence: confidence level to draw lower and upper limits when\n            plotting and to limit the top deviations to show. Defaults to None.\n        high_Z: chooses which Z scores to be used when displaying results,\n            according to the confidence level chosen. Defaluts to \'pos\',\n            which will highlight only values higher than the expexted\n            frequencies; \'all\' will highlight both extremes (positive and\n            negative); and an integer, which will use the first n entries,\n            positive and negative, regardless of whether Z is higher than\n            the confidence or not.\n        limit_N: sets a limit to N as the sample size for the calculation of\n            the Z scores if the sample is too big. Defaults to None.\n        MSE: calculates the Mean Square Error of the sample; defaults to\n            False.\n        chi_square: calculates the chi_square statistic of the sample and\n            compares it with a critical value, according to the confidence\n            level chosen and the series\'s degrees of freedom. Defaults to\n            False. Requires confidence != None.\n        KS: calculates the Kolmogorov-Smirnov test, comparing the cumulative\n            distribution of the sample with the Benford\'s, according to the\n            confidence level chosen. Defaults to False. Requires confidence\n            != None.\n        show_plot: draws the test plot.\n    \n    Returns:\n        DataFrame of the test chosen, but applied on Second Order pre-\n            processed data.\n    """"""\n    test = _check_test_(test)\n\n    verbose = _deprecate_inform_(verbose, inform)\n\n    data = Source(data, decimals=decimals, sign=sign,\n                  sec_order=True, verbose=verbose)\n    if test in [1, 2, 3]:\n        data.first_digits(digs=test, MAD=MAD,\n                          confidence=confidence, high_Z=high_Z,\n                          limit_N=limit_N, MSE=MSE, show_plot=show_plot)\n    elif test == 22:\n        data.second_digit(MAD=MAD, confidence=confidence, high_Z=high_Z,\n                          limit_N=limit_N, MSE=MSE, show_plot=show_plot)\n    else:\n        data.last_two_digits(MAD=MAD, confidence=confidence, high_Z=high_Z,\n                             limit_N=limit_N, MSE=MSE, show_plot=show_plot)\n    return data\n'"
benford/checks.py,0,"b'from pandas import Series\nfrom numpy import array, ndarray\nfrom .constants import digs_dict, rev_digs, confs\n\ndef _check_digs_(digs):\n    """"""Checks the possible values for the digs parameter of the\n    First Digits tests\n    """"""\n    if digs not in [1, 2, 3]:\n        raise ValueError(""The value assigned to the parameter -digs- ""\n                         f""was {digs}. Value must be 1, 2 or 3."")\n\n\ndef _check_test_(test):\n    """"""Checks the test chosen, both for int or str values\n    """"""\n    if isinstance(test, int):\n        if test in digs_dict.keys():\n            return test\n        else:\n            raise ValueError(f\'Test was set to {test}. Should be one of \'\n                             f\'{digs_dict.keys()}\')\n    elif isinstance(test, str):\n        if test in rev_digs.keys():\n            return rev_digs[test]\n        else:\n            raise ValueError(f\'Test was set to {test}. Should be one of \'\n                             f\'{rev_digs.keys()}\')\n    else:\n        raise ValueError(\'Wrong value chosen for test parameter. Possible \'\n                         f\'values are\\n {list(digs_dict.keys())} for ints and\'\n                         f\'\\n {list(rev_digs.keys())} for strings.\')\n\ndef _check_decimals_(decimals):\n    """"""""""""\n    if isinstance(decimals, int):\n        if (decimals < 0):\n            raise ValueError(""Parameter -decimals- must be an int >= 0, or \'infer\'."")\n    else:\n        if decimals != \'infer\':\n            raise ValueError(""Parameter -decimals- must be an int >= 0, or \'infer\'."")\n    return decimals\n\ndef _check_sign_(sign):\n    """"""""""""\n    if sign not in [\'all\', \'pos\', \'neg\']:\n        raise ValueError(""Parameter -sign- must be one of the following: ""\n                         ""\'all\', \'pos\' or \'neg\'."")\n    return sign\n\n\ndef _check_confidence_(confidence):\n    """"""""""""\n    if confidence not in confs.keys():\n        raise ValueError(""Value of parameter -confidence- must be one of the ""\n                         f""following:\\n {list(confs.keys())}"")\n    return confidence\n\ndef _check_high_Z_(high_Z):\n    """"""""""""\n    if not high_Z in [\'pos\', \'all\']:\n        if not isinstance(high_Z, int):\n            raise ValueError(""The parameter -high_Z- should be \'pos\', ""\n                             ""\'all\' or an int."")\n    return high_Z\n\ndef _check_num_array_(data):\n    """"""""""""\n    if (not isinstance(data, ndarray)) & (not isinstance(data, Series)):\n        print(\'\\n`data` not a numpy NDarray nor a pandas Series.\'\n                \' Trying to convert...\')\n        try:\n            data = array(data)\n        except:\n            raise ValueError(\'Could not convert data. Check input.\')\n        print(\'\\nConversion successful.\')\n\n        try:\n            data = data.astype(float)\n        except:\n            raise ValueError(\'Could not convert data. Check input.\')\n    else:\n        if data.dtype not in [int, float]:\n            try:\n                data = data.astype(float)\n            except:\n                raise ValueError(\'Could not convert data. Check input.\')\n    return data\n'"
benford/constants.py,0,"b""digs_dict = {1: 'F1D', 2: 'F2D', 3: 'F3D', 22: 'SD', -2: 'L2D'}\n\nsec_order_dict = {key: f'{val}_sec' for key, val in digs_dict.items()}\n\nrev_digs = {'F1D': 1, 'F2D': 2, 'F3D': 3, 'SD': 22, 'L2D': -2}\n\nnames = {'F1D': 'First Digit Test', 'F2D': 'First Two Digits Test',\n         'F3D': 'First Three Digits Test', 'SD': 'Second Digit Test',\n         'L2D': 'Last Two Digits Test',\n         'F1D_sec': 'First Digit Second Order Test',\n         'F2D_sec': 'First Two Digits Second Order Test',\n         'F3D_sec': 'First Three Digits Second Order Test',\n         'SD_sec': 'Second Digit Second Order Test',\n         'L2D_sec': 'Last Two Digits Second Order Test',\n         'F1D_Summ': 'First Digit Summation Test',\n         'F2D_Summ': 'First Two Digits Summation Test',\n         'F3D_Summ': 'First Three Digits Summation Test',\n         'Mantissas': 'Mantissas Test'\n         }\n\n# Critical values for Mean Absolute Deviation\nmad_dict = {1: [0.006, 0.012, 0.015], 2: [0.0012, 0.0018, 0.0022],\n            3: [0.00036, 0.00044, 0.00050], 22: [0.008, 0.01, 0.012],\n            -2: None, 'F1D': 'First Digit', 'F2D': 'First Two Digits',\n            'F3D': 'First Three Digits', 'SD': 'Second Digits'}\n\n# Color for the plotting\ncolors = {'m': '#00798c', 'b': '#E2DCD8', 's': '#9c3848',\n          'af': '#edae49', 'ab': '#33658a', 'h': '#d1495b',\n          'h2': '#f64740', 't': '#16DB93'}\n\n# Critical Z-scores according to the confindence levels\nconfs = {None: None, 80: 1.285, 85: 1.435, 90: 1.645, 95: 1.96,\n         99: 2.576, 99.9: 3.29, 99.99: 3.89, 99.999: 4.417,\n         99.9999: 4.892, 99.99999: 5.327}\n\np_values = {None: 'None', 80: '0.2', 85: '0.15', 90: '0.1', 95: '0.05',\n            99: '0.01', 99.9: '0.001', 99.99: '0.0001', 99.999: '0.00001',\n            99.9999: '0.000001', 99.99999: '0.0000001'}\n\n# Critical Chi-Square values according to the tests degrees of freedom\n# and confidence levels\ncrit_chi2 = {8: {80: 11.03, 85: 12.027, 90: 13.362, 95: 15.507,\n                 99: 20.090, 99.9: 26.124, 99.99: 31.827, None: None,\n                 99.999: 37.332, 99.9999: 42.701, 99.99999: 47.972},\n             9: {80: 12.242, 85: 13.288, 90: 14.684, 95: 16.919,\n                 99: 21.666, 99.9: 27.877, 99.99: 33.72, None: None,\n                 99.999: 39.341, 99.9999: 44.811, 99.99999: 50.172},\n             89: {80: 99.991, 85: 102.826, 90: 106.469, 95: 112.022,\n                  99: 122.942, 99.9: 135.978, 99.99: 147.350,\n                  99.999: 157.702, 99.9999: 167.348, 99.99999: 176.471,\n                  None: None},\n             99: {80: 110.607, 85: 113.585, 90: 117.407,\n                  95: 123.225, 99: 134.642, 99.9: 148.230,\n                  99.99: 160.056, 99.999: 170.798, 99.9999: 180.792,\n                  99.99999: 190.23, None: None},\n             899: {80: 934.479, 85: 942.981, 90: 953.752, 95: 969.865,\n                   99: 1000.575, 99.9: 1035.753, 99.99: 1065.314,\n                   99.999: 1091.422, 99.9999: 1115.141,\n                   99.99999: 1137.082, None: None}\n             }\n\n# Critical Kolmogorov-Smirnov values according to the confidence levels \n# These values are yet to be divided by the square root of the sample size\nKS_crit = {80: 1.075, 85: 1.139, 90: 1.125, 95: 1.36, 99: 1.63,\n           99.9: 1.95, 99.99: 2.23, 99.999: 2.47,\n           99.9999: 2.7, 99.99999: 2.9, None: None}\n"""
benford/expected.py,0,"b'from pandas import DataFrame\nfrom numpy import array, arange, log10\nfrom .checks import _check_digs_\nfrom .viz import plot_expected\n\n\nclass First(DataFrame):\n    """"""Holds the expected probabilities of the First, First Two, or\n    First Three digits according to Benford\'s distribution.\n\n    Args:\n        digs: 1, 2 or 3 - tells which of the first digits to consider:\n            1 for the First Digit, 2 for the First Two Digits and 3 for\n            the First Three Digits.\n        plot: option to plot a bar chart of the Expected proportions.\n            Defaults to True.\n    """"""\n\n    def __init__(self, digs, plot=True):\n        _check_digs_(digs)\n        dig_name = f\'First_{digs}_Dig\'\n        Dig = arange(10 ** (digs - 1), 10 ** digs)\n        Exp = log10(1 + (1. / Dig))\n\n        DataFrame.__init__(self, {\'Expected\': Exp}, index=Dig)\n        self.index.names = [dig_name]\n\n        if plot:\n            plot_expected(self, digs)\n\n\nclass Second(DataFrame):\n    """"""Holds the expected probabilities of the Second Digits\n    according to Benford\'s distribution.\n\n    Args:\n        plot: option to plot a bar chart of the Expected proportions.\n            Defaults to True.\n    """"""\n    def __init__(self, plot=True):\n        a = arange(10, 100)\n        Expe = log10(1 + (1. / a))\n        Sec_Dig = array(list(range(10)) * 9)\n\n        df = DataFrame({\'Expected\': Expe, \'Sec_Dig\': Sec_Dig})\n\n        DataFrame.__init__(self, df.groupby(\'Sec_Dig\').sum())\n\n        if plot:\n            plot_expected(self, 22)\n\n\nclass LastTwo(DataFrame):\n    """"""Holds the expected probabilities of the Last Two Digits\n    according to Benford\'s distribution.\n\n    Args:\n        plot: option to plot a bar chart of the Expected proportions.\n            Defaults to True.\n    """"""\n    def __init__(self, num=False, plot=True):\n        exp = array([1 / 99.] * 100)\n        DataFrame.__init__(self, {\'Expected\': exp,\n                              \'Last_2_Dig\': _lt_(num=num)})\n        self.set_index(\'Last_2_Dig\', inplace=True)\n        if plot:\n            plot_expected(self, -2)\n\ndef _test_(digs):\n    """"""Chooses the Exxpected class to be used in a test\n\n    Args:\n        digs: the int corresponding to the Expected class to be instantiated\n    \n    Returns:\n        the Expected instance forthe propoer test to be performed\n    """"""\n    if digs in [1, 2, 3]:\n        return First(digs, plot=False)\n    elif digs == 22:\n        return Second(plot=False)\n    else:\n        return LastTwo(num=True, plot=False)\n\n\ndef _lt_(num=False):\n    """"""Creates an array with the possible last two digits\n\n    Args:\n        num: returns numeric (ints) values. Defaluts to False,\n            which returns strings.\n    \n    Returns:\n        Array of ints or str, in any case representing all 100 possible\n            combinations of last two digits\n    """"""\n    if num:\n        n = arange(0, 100)\n    else:\n        n = arange(0, 100).astype(str)\n        n[:10] = array([\'00\', \'01\', \'02\', \'03\', \'04\', \'05\',\n                           \'06\', \'07\', \'08\', \'09\'])\n    return n'"
benford/reports.py,0,"b'import warnings\nfrom .constants import mad_dict\n\ndef _inform_(df, high_Z, conf):\n    """"""Selects and sorts by the Z_stats chosen to be considered, informing or not.\n    """"""\n\n    if isinstance(high_Z, int):\n        if conf is not None:\n            dd = df[[\'Expected\', \'Found\', \'Z_score\'\n                     ]].sort_values(\'Z_score\', ascending=False).head(high_Z)\n            print(f\'\\nThe entries with the top {high_Z} Z scores are:\\n\')\n        # Summation Test\n        else:\n            dd = df[[\'Expected\', \'Found\', \'AbsDif\'\n                     ]].sort_values(\'AbsDif\', ascending=False\n                                    ).head(high_Z)\n            print(f\'\\nThe entries with the top {high_Z} absolute deviations \'\n                  \'are:\\n\')\n    else:\n        if high_Z == \'pos\':\n            m1 = df.Dif > 0\n            m2 = df.Z_score > conf\n            dd = df[[\'Expected\', \'Found\', \'Z_score\'\n                     ]].loc[m1 & m2].sort_values(\'Z_score\', ascending=False)\n            print(\'\\nThe entries with the significant positive \'\n                  \'deviations are:\\n\')\n        elif high_Z == \'neg\':\n            m1 = df.Dif < 0\n            m2 = df.Z_score > conf\n            dd = df[[\'Expected\', \'Found\', \'Z_score\'\n                     ]].loc[m1 & m2].sort_values(\'Z_score\', ascending=False)\n            print(\'\\nThe entries with the significant negative \'\n                  \'deviations are:\\n\')\n        else:\n            dd = df[[\'Expected\', \'Found\', \'Z_score\'\n                     ]].loc[df.Z_score > conf].sort_values(\'Z_score\',\n                                                           ascending=False)\n            print(\'\\nThe entries with the significant deviations are:\\n\')\n    print(dd)\n\ndef _report_mad_(digs, MAD):\n    """"""Reports the test Mean Absolut Deviation and compares it to critical values\n    """"""\n    print(f\'Mean Absolute Deviation: {MAD:.6f}\')\n    if digs != -2:\n        mads = mad_dict[digs]\n        if MAD <= mads[0]:\n            print(f\'MAD <= {mads[0]:.6f}: Close conformity.\\n\')\n        elif MAD <= mads[1]:\n            print(f\'{mads[0]:.6f} < MAD <= {mads[1]:.6f}: \'\n                  \'Acceptable conformity.\\n\')\n        elif MAD <= mads[2]:\n            print(f\'{mads[1]:.6f} < MAD <= {mads[2]:.6f}: \'\n                  \'Marginally Acceptable conformity.\\n\')\n        else:\n            print(f\'MAD > {mads[2]:.6f}: Nonconformity.\\n\')\n    else:\n        print(""There is no conformity check for this test\'s MAD.\\n"")\n\ndef _report_KS_(KS, crit_KS):\n    """"""Reports the test Kolmogorov-Smirnov statistic and compares it to critical\n    values, depending on the confidence level\n    """"""\n    result = \'PASS\' if KS <= crit_KS else \'FAIL\'\n    print(f""\\n\\tKolmogorov-Smirnov: {KS:.6f}"",\n          f""\\n\\tCritical value: {crit_KS:.6f} -- {result}"")\n\ndef _report_chi2_(chi2, crit_chi2):\n    """"""Reports the test Chi-square statistic and compares it to critical values,\n    depending on the confidence level\n    """"""\n    result = \'PASS\' if chi2 <= crit_chi2 else \'FAIL\'\n    print(f""\\n\\tChi square: {chi2:.6f}"",\n          f""\\n\\tCritical value: {crit_chi2:.6f} -- {result}"")\n\ndef _report_Z_(df, high_Z, crit_Z):\n    """"""Reports the test Z scores and compares them to a critical value,\n    depending on the confidence level\n    """"""\n    print(f""\\n\\tCritical Z-score:{crit_Z}."")\n    _inform_(df, high_Z, crit_Z)\n\ndef _report_summ_(test, high_diff):\n    """"""Reports the Summation Test Absolute Differences between the Found and\n    the Expected proportions\n\n    """"""\n    if high_diff is not None:\n        print(f\'\\nThe top {high_diff} Absolute Differences are:\\n\')\n        print(test.sort_values(\'AbsDif\', ascending=False).head(high_diff))\n    else:\n        print(\'\\nThe top Absolute Differences are:\\n\')\n        print(test.sort_values(\'AbsDif\', ascending=False))\n\n\ndef _report_test_(test, high=None, crit_vals=None):\n    """"""Main report function. Receives the Args: to report with, initiates\n    the process, and calls the right reporting helper function(s), depending\n    on the Test.\n    """"""\n    print(\'\\n\', f\'  {test.name}  \'.center(50, \'#\'), \'\\n\')\n    if not \'Summation\' in test.name:\n        _report_mad_(test.digs, test.MAD)\n        if test.confidence is not None:\n            print(f""For confidence level {test.confidence}%: "")\n            _report_KS_(test.KS, crit_vals[\'KS\'])\n            _report_chi2_(test.chi_square, crit_vals[\'chi2\'])\n            _report_Z_(test, high, crit_vals[\'Z\'])\n        else:\n            print(\'Confidence is currently `None`. Set the confidence level, \'\n                    \'so as to generate comparable critical values.\' )\n            if isinstance(high, int):\n                _inform_(test, high, None)\n    else:\n        _report_summ_(test, high)\n\ndef _report_mantissa_(stats):\n    """"""Prints the mantissas statistics and their respective reference values\n\n    Args:\n        stats (dict): \n    """"""\n    print(""\\n"", \'  Mantissas Test  \'.center(52, \'#\'))\n    print(f""\\nThe Mantissas MEAN is      {stats[\'Mean\']:.6f}.""\n            ""\\tRef: 0.5"")\n    print(f""The Mantissas VARIANCE is  {stats[\'Var\']:.6f}.""\n            ""\\tRef: 0.08333"")\n    print(f""The Mantissas SKEWNESS is  {stats[\'Skew\']:.6f}.""\n            ""\\tRef: 0.0"")\n    print(f""The Mantissas KURTOSIS is  {stats[\'Kurt\']:.6f}.""\n            ""\\tRef: -1.2\\n"")\n\n\ndef _deprecate_inform_(verbose, inform):\n    """"""\n    Raises:\n        FutureWarning: if the arg `inform` is used (to be deprecated).    \n    """"""\n    if inform is None:\n        return verbose\n    else:\n        warnings.warn(\'The parameter `inform` will be deprecated in future \'\n                      \'versions. Use `verbose` instead.\',\n                      FutureWarning)\n        return inform'"
benford/stats.py,0,"b'from numpy import sqrt\nfrom .constants import crit_chi2, KS_crit\n\n\ndef Z_score(frame, N):\n    """"""Computes the Z statistics for the proportions studied\n\n    Args:\n        frame: DataFrame with the expected proportions and the already calculated\n            Absolute Diferences between the found and expeccted proportions\n        N: sample size\n    \n    Returns:\n        Series of computed Z scores\n    """"""\n    return (frame.AbsDif - (1 / (2 * N))) / sqrt(\n           (frame.Expected * (1. - frame.Expected)) / N)\n\n\ndef chi_sq(frame, ddf, confidence, verbose=True):\n    """"""Comnputes the chi-square statistic of the found distributions and compares\n    it with the critical chi-square of such a sample, according to the\n    confidence level chosen and the degrees of freedom - len(sample) -1.\n\n    Args:\n        frame: DataFrame with Found, Expected and their difference columns.\n        ddf: Degrees of freedom to consider.\n        confidence: Confidence level to look up critical value.\n        verbose: prints the chi-squre result and compares to the critical\n            chi-square for the sample. Defaults to True.\n    \n    Returns:\n        The computed Chi square statistic and the critical chi square\n            (according) to the degrees of freedom and confidence level,\n            for comparison. None if confidence is None\n    """"""\n    if confidence is None:\n        print(\'\\nChi-square test needs confidence other than None.\')\n        return\n    else:\n        exp_counts = frame.Counts.sum() * frame.Expected\n        dif_counts = frame.Counts - exp_counts\n        found_chi = (dif_counts ** 2 / exp_counts).sum()\n        crit_chi = crit_chi2[ddf][confidence]\n        if verbose:\n            print(f""\\nThe Chi-square statistic is {found_chi:.4f}.\\n""\n                  f""Critical Chi-square for this series: {crit_chi}."")\n        return (found_chi, crit_chi)\n\n\ndef chi_sq_2(frame):\n    """"""Computes the chi-square statistic of the found distributions\n\n    Args:\n        frame: DataFrame with Found, Expected and their difference columns.\n\n    Returns:\n        The computed Chi square statistic \n    """"""\n    exp_counts = frame.Counts.sum() * frame.Expected\n    dif_counts = frame.Counts - exp_counts\n    return (dif_counts ** 2 / exp_counts).sum()\n\n\ndef kolmogorov_smirnov(frame, confidence, N, verbose=True):\n    """"""Computes the Kolmogorov-Smirnov test of the found distributions\n    and compares it with the critical chi-square of such a sample,\n    according to the confidence level chosen.\n\n    Args:\n        frame: DataFrame with Foud and Expected distributions.\n        confidence: Confidence level to look up critical value.\n        N: Sample size\n        verbose: prints the KS result and the critical value for the sample.\n            Defaults to True.\n    \n    Returns:\n        The Suprem, which is the greatest absolute difference between the\n            Found and the expected proportions, and the Kolmogorov-Smirnov\n            critical value according to the confidence level, for ccomparison\n    """"""\n    if confidence is None:\n        print(\'\\nKolmogorov-Smirnov test needs confidence other than None.\')\n        return\n    else:\n        # sorting and calculating the cumulative distribution\n        ks_frame = frame.sort_index()[[\'Found\', \'Expected\']].cumsum()\n        # finding the supremum - the largest cumul dist difference\n        suprem = ((ks_frame.Found - ks_frame.Expected).abs()).max()\n        # calculating the crittical value according to confidence\n        crit_KS = KS_crit[confidence] / sqrt(N)\n\n        if verbose:\n            print(f""\\nThe Kolmogorov-Smirnov statistic is {suprem:.4f}.\\n""\n                  f""Critical K-S for this series: {crit_KS:.4f}"")\n        return (suprem, crit_KS)\n\n\ndef kolmogorov_smirnov_2(frame):\n    """"""Computes the Kolmogorov-Smirnov test of the found distributions\n    \n    Args:\n        frame: DataFrame with Foud and Expected distributions.\n    \n    Returns:\n        The Suprem, which is the greatest absolute difference between the\n            Found end th expected proportions\n    """"""\n    # sorting and calculating the cumulative distribution\n    ks_frame = frame.sort_index()[[\'Found\', \'Expected\']].cumsum()\n    # finding the supremum - the largest cumul dist difference\n    return ((ks_frame.Found - ks_frame.Expected).abs()).max()\n'"
benford/utils.py,0,"b'from pandas import Series, DataFrame\nfrom numpy import array, arange, log10, ndarray\nfrom .expected import _test_\nfrom .constants import digs_dict, rev_digs\nfrom .stats import Z_score\nfrom .checks import _check_num_array_, _check_sign_, _check_decimals_\n\n\ndef _set_N_(len_df, limit_N):\n    """"""""""""\n    # Assigning to N the superior limit or the lenght of the series\n    if limit_N is None or limit_N > len_df:\n        return len_df\n    # Check on limit_N being a positive integer\n    else:\n        if limit_N < 0 or not isinstance(limit_N, int):\n            raise ValueError(""limit_N must be None or a positive integer."")\n        else:\n            return limit_N\n\n\ndef get_mantissas(arr):\n    """"""Computes the mantissas, the non-integer part of the log of a number.\n    \n    Args:\n        arr: array of integers or floats\n    \n    Returns:\n        Array of floats withe logs mantissas\n    """"""\n    log_a = abs(log10(arr))\n    return log_a - log_a.astype(int)  # the number - its integer part\n\n\ndef input_data(given):\n    """"""Internalizes and transforms the input data\n    \n    Args:\n        given: ndarray, Series or tuple with DataFrame and name of the\n            column to analyze\n    \n    Returns:\n        The raw inputed data and the result of its first pre-processing,\n            when required.\n    """"""\n    if type(given) == Series:\n        data = chosen = given\n    elif type(given) == ndarray:\n        data = given\n        chosen = Series(given)\n    elif type(given) == tuple:\n        if (type(given[0]) != DataFrame) | (type(given[1]) != str):\n            raise TypeError(\'The data tuple must be composed of a pandas \'\n                            \'DataFrame and the name (str) of the chosen \'\n                            \'column, in that order\')\n        data = given[0]\n        chosen = given[0][given[1]]\n    else:\n        raise TypeError(""Wrong data input type. Check docstring."")\n    return data, chosen\n\ndef set_sign(data, sign=""all""):\n    """"""\n    """"""\n    sign = _check_sign_(sign)\n\n    if sign == \'all\':\n        data.Seq = data.Seq.loc[data.Seq != 0]\n    elif sign == \'pos\':\n        data.Seq = data.Seq.loc[data.Seq > 0]\n    else:\n        data.Seq = data.Seq.loc[data.Seq < 0]\n\n    return data.dropna()\n\n\ndef get_times_10_power(data, decimals=2):\n    """"""""""""\n    decimals = _check_decimals_(decimals)\n\n    ab = data.Seq.abs()\n\n    if data.Seq.dtypes == \'int64\':\n        data[\'ZN\'] = ab\n    else:\n        if decimals == \'infer\':\n            data[\'ZN\'] = ab.astype(str).str\\\n                            .replace(\'.\', \'\')\\\n                            .str.lstrip(\'0\')\\\n                            .str[:5].astype(int)\n        else:\n            data[\'ZN\'] = (ab * (10 ** decimals)).astype(int)\n    return data\n\n\ndef extract_digs(data, decimals=2, sign=""all""):\n    """""" \n    """"""\n    df = DataFrame({\'Seq\': _check_num_array_(data)})\n\n    df = choose_sign(df, sign=sign)\n\n    df = get_times_10_power(df, decimals=decimals)\n\n    # First digits\n    for col in [\'F1D\', \'F2D\', \'F3D\']:\n        temp = df.ZN.loc[df.ZN >= 10 ** (rev_digs[col] - 1)]\n        df[col] = (temp // 10 ** ((log10(temp).astype(int)) -\n                                    (rev_digs[col] - 1)))\n        # fill NANs with -1, which is a non-usable value for digits,\n        # to be discarded later.\n        df[col] = df[col].fillna(-1).astype(int)\n    # Second digit\n    temp_sd = df.loc[df.ZN >= 10]\n    df[\'SD\'] = (temp_sd.ZN // 10**((log10(temp_sd.ZN)).astype(int) -\n                                        1)) % 10\n    df[\'SD\'] = df[\'SD\'].fillna(-1).astype(int)\n    # Last two digits\n    temp_l2d = df.loc[df.ZN >= 1000]\n    df[\'L2D\'] = temp_l2d.ZN % 100\n    df[\'L2D\'] = df[\'L2D\'].fillna(-1).astype(int)\n    return df\n\n\ndef prepare(data, digs, limit_N=None, simple=False, confidence=None):\n    """"""Transforms the original number sequence into a DataFrame reduced\n    by the ocurrences of the chosen digits, creating other computed\n    columns\n    """"""\n    N = _set_N_(len(data), limit_N=limit_N)\n\n    # get the number of occurrences of the digits\n    counts = data.value_counts()\n    # get their relative frequencies\n    proportions = data.value_counts(normalize=True)\n    # crate dataframe from them\n    dd = DataFrame({\'Counts\': counts, \'Found\': proportions}).sort_index()\n    # join the dataframe with the one of expected Benford\'s frequencies\n    dd = _test_(digs).join(dd).fillna(0)\n    # create column with absolute differences\n    dd[\'Dif\'] = dd.Found - dd.Expected\n    dd[\'AbsDif\'] = dd.Dif.abs()\n    print(dd.Found)\n    if simple:\n        del dd[\'Dif\']\n        return dd\n    else:\n        if confidence is not None:\n            dd[\'Z_score\'] = Z_score(dd, N)\n        return N, dd\n\ndef subtract_sorted(data):\n    """"""Subtracts the sorted sequence elements from each other, discarding zeros.\n    Used in the Second Order test\n    """"""\n    sec = data.copy()\n    sec.sort_values(inplace=True)\n    sec = sec - sec.shift(1)\n    sec = sec.loc[sec != 0]\n    return sec\n\ndef prep_to_roll(start, test):\n    """"""Used by the rolling mad and rolling mean, prepares each test and\n    respective expected proportions for later application to the Series subset\n    """"""\n    if test in [1, 2, 3]:\n        start[digs_dict[test]] = start.ZN // 10 ** ((\n            log10(start.ZN).astype(int)) - (test - 1))\n        start = start.loc[start.ZN >= 10 ** (test - 1)]\n\n        ind = arange(10 ** (test - 1), 10 ** test)\n        Exp = log10(1 + (1. / ind))\n\n    elif test == 22:\n        start[digs_dict[test]] = (start.ZN // 10 ** ((\n            log10(start.ZN)).astype(int) - 1)) % 10\n        start = start.loc[start.ZN >= 10]\n\n        Expec = log10(1 + (1. / arange(10, 100)))\n        temp = DataFrame({\'Expected\': Expec, \'Sec_Dig\':\n                             array(list(range(10)) * 9)})\n        Exp = temp.groupby(\'Sec_Dig\').sum().values.reshape(10,)\n        ind = arange(0, 10)\n\n    else:\n        start[digs_dict[test]] = start.ZN % 100\n        start = start.loc[start.ZN >= 1000]\n\n        ind = arange(0, 100)\n        Exp = array([1 / 99.] * 100)\n\n    return Exp, ind\n\ndef mad_to_roll(arr, Exp, ind):\n    """"""Mean Absolute Deviation used in the rolling function\n    """"""\n    prop = arr.value_counts(normalize=True).sort_index()\n\n    if len(prop) < len(Exp):\n        prop = prop.reindex(ind).fillna(0)\n\n    return abs(prop - Exp).mean()\n\ndef mse_to_roll(arr, Exp, ind):\n    """"""Mean Squared Error used in the rolling function\n    """"""\n    temp = arr.value_counts(normalize=True).sort_index()\n\n    if len(temp) < len(Exp):\n        temp = temp.reindex(ind).fillna(0)\n\n    return ((temp - Exp) ** 2).mean()\n'"
benford/viz.py,0,"b'from numpy import array, arange, maximum, sqrt, ones\nimport matplotlib.pyplot as plt\nfrom matplotlib.text import Annotation\nfrom .constants import colors, mad_dict\n\n\ndef plot_expected(df, digs):\n    """"""Plots the Expected Benford Distributions\n\n    Args:\n        df: DataFrame with the Expected Proportions\n        digs: Test\'s digit\n    """"""\n    if digs in [1, 2, 3]:\n        y_max = (df.Expected.max() + (10 ** -(digs) / 3)) * 100\n        fig, ax = plt.subplots(figsize=(2 * (digs ** 2 + 5), 1.5 *\n                                        (digs ** 2 + 5)))\n    elif digs == 22:\n        y_max = 13.\n        fig, ax = plt.subplots(figsize=(14, 10.5))\n    elif digs == -2:\n        y_max = 1.1\n        fig, ax = plt.subplots(figsize=(15, 8))\n    plt.title(\'Expected Benford Distributions\', size=\'xx-large\')\n    plt.xlabel(df.index.name, size=\'x-large\')\n    plt.ylabel(\'Distribution (%)\', size=\'x-large\')\n    ax.set_facecolor(colors[\'b\'])\n    ax.set_ylim(0, y_max)\n    ax.bar(df.index, df.Expected * 100, color=colors[\'t\'], align=\'center\')\n    ax.set_xticks(df.index)\n    ax.set_xticklabels(df.index)\n    plt.show(block=False)\n\ndef _get_plot_args(digs):\n    """"""Selects the correct arguments for the plotting functions, depending on the\n    the test (digs) chosen.\n    """"""\n    if digs in [1, 2, 3]:\n        text_x = False\n        n, m = 10 ** (digs - 1), 10 ** (digs)\n        x = arange(n, m)\n        figsize = (2 * (digs ** 2 + 5), 1.5 * (digs ** 2 + 5))\n    elif digs == 22:\n        text_x = False\n        x = arange(10)\n        figsize = (14, 10)\n    else:\n        text_x = True\n        x = arange(100)\n        figsize = (15, 7)\n    return x, figsize, text_x\n    \n\ndef plot_digs(df, x, y_Exp, y_Found, N, figsize, conf_Z, text_x=False):\n    """"""Plots the digits tests results\n\n    Args:\n        df: DataFrame with the data to be plotted\n        x: sequence to be used in the x axis\n        y_Exp: sequence of the expected proportions to be used in the y axis\n            (line)\n        y_Found: sequence of the found proportions to be used in the y axis\n            (bars)\n        N: lenght of sequence, to be used when plotting the confidence levels\n        figsize: tuple to state the size of the plot figure\n        conf_Z: Confidence level\n        text_x: Forces to show all x ticks labels. Defaluts to True.\n    """"""\n    if len(x) > 10:\n        rotation = 90\n    else:\n        rotation = 0\n    fig, ax = plt.subplots(figsize=figsize)\n    plt.title(\'Expected vs. Found Distributions\', size=\'xx-large\')\n    plt.xlabel(\'Digits\', size=\'x-large\')\n    plt.ylabel(\'Distribution (%)\', size=\'x-large\')\n    if conf_Z is not None:\n        sig = conf_Z * sqrt(y_Exp * (1 - y_Exp) / N)\n        upper = y_Exp + sig + (1 / (2 * N))\n        lower_zeros = array([0]*len(upper))\n        lower = maximum(y_Exp - sig - (1 / (2 * N)), lower_zeros)\n        u = (y_Found < lower) | (y_Found > upper)\n        c = array([colors[\'m\']] * len(u))\n        c[u] = colors[\'af\']\n        lower *= 100.\n        upper *= 100.\n        ax.plot(x, upper, color=colors[\'s\'], zorder=5)\n        ax.plot(x, lower, color=colors[\'s\'], zorder=5)\n        ax.fill_between(x, upper, lower, color=colors[\'s\'],\n                        alpha=.3, label=\'Conf\')\n    else:\n        c = colors[\'m\']\n    ax.bar(x, y_Found * 100., color=c, label=\'Found\', zorder=3, align=\'center\')\n    ax.plot(x, y_Exp * 100., color=colors[\'s\'], linewidth=2.5,\n            label=\'Benford\', zorder=4)\n    ax.set_xticks(x)\n    ax.set_xticklabels(x, rotation=rotation)\n    ax.set_facecolor(colors[\'b\'])\n    if text_x:\n        ind = array(df.index).astype(str)\n        ind[:10] = array([\'00\', \'01\', \'02\', \'03\', \'04\', \'05\',\n                             \'06\', \'07\', \'08\', \'09\'])\n        plt.xticks(x, ind, rotation=\'vertical\')\n    ax.legend()\n    ax.set_ylim(0, max([y_Exp.max() * 100, y_Found.max() * 100]) + 10 / len(x))\n    ax.set_xlim(x[0] - 1, x[-1] + 1)\n    plt.show(block=False)\n\n\ndef plot_sum(df, figsize, li, text_x=False):\n    """"""Plots the summation test results\n\n    Args:\n        df: DataFrame with the data to be plotted\n        figsize: sets the dimensions of the plot figure\n        li -> value with which to draw the horizontal line\n    """"""\n    x = df.index\n    rotation = 90 if len(x) > 10 else 0\n    fig = plt.figure(figsize=figsize)\n    ax = fig.add_subplot(111)\n    plt.title(\'Expected vs. Found Sums\')\n    plt.xlabel(\'Digits\')\n    plt.ylabel(\'Sums\')\n    ax.bar(x, df.Percent, color=colors[\'m\'],\n           label=\'Found Sums\', zorder=3, align=\'center\')\n    ax.set_xlim(x[0] - 1, x[-1] + 1)\n    ax.axhline(li, color=colors[\'s\'], linewidth=2, label=\'Expected\', zorder=4)\n    ax.set_xticks(x)\n    ax.set_xticklabels(x, rotation=rotation)\n    ax.set_facecolor(colors[\'b\'])\n    if text_x:\n        ind = array(x).astype(str)\n        ind[:10] = array([\'00\', \'01\', \'02\', \'03\', \'04\', \'05\',\n                             \'06\', \'07\', \'08\', \'09\'])\n        plt.xticks(x, ind, rotation=\'vertical\')\n    ax.legend()\n    plt.show(block=False)\n\ndef plot_ordered_mantissas(col, figsize=(12, 12)):\n    """"""Plots the ordered mantissas and compares them to the expected, straight\n        line that should be formed in a Benford-cmpliant set.\n    \n    Args:\n        col (Series): column of mantissas to plot.\n        figsize (tuple): sets the dimensions of the plot figure.\n    """"""\n    ld = len(col)\n    x = arange(1, ld + 1)\n    n = ones(ld) / ld\n    fig = plt.figure(figsize=figsize)\n    ax = fig.add_subplot(111)\n    ax.plot(x, col.sort_values(), linestyle=\'--\',\n            color=colors[\'s\'], linewidth=3, label=\'Mantissas\')\n    ax.plot(x, n.cumsum(), color=colors[\'m\'],\n            linewidth=2, label=\'Expected\')\n    plt.ylim((0, 1.))\n    plt.xlim((1, ld + 1))\n    ax.set_facecolor(colors[\'b\'])\n    ax.set_title(""Ordered Mantissas"")\n    plt.legend(loc=\'upper left\')\n    plt.show(block=False);\n\ndef plot_mantissa_arc_test(df, gravity_center, grid=True, figsize=12):\n    """"""Draws thee Mantissa Arc Test after computing X and Y circular coordinates\n    for every mantissa and the center of gravity for the set\n    \n    Args:\n        df (DataFrame): pandas DataFrame with the mantissas and the X and Y\n            coordinates.\n        gravity_center (tuple): coordinates for plottling the gravity center\n        grid (bool): show grid. Defaults to True.\n        figsize (int): figure dimensions. No need to be a tuple, since the\n            figure is a square.\n    """"""\n    fig = plt.figure(figsize=(figsize,figsize))\n    ax = plt.subplot()\n    ax.set_facecolor(colors[\'b\'])\n    ax.scatter(df.mant_x, df.mant_y, label= ""ARC TEST"",\n                color=colors[\'m\'])\n    ax.scatter(gravity_center[0], gravity_center[1],\n                color=colors[\'s\']) \n    text_annotation = Annotation(\n                ""  Gravity Center: ""\n                f""x({round(gravity_center[0], 3)}),""\n                f"" y({round(gravity_center[1], 3)})"", \n                xy=(gravity_center[0] - 0.65,\n                    gravity_center[1] - 0.1),\n                xycoords=\'data\')\n    ax.add_artist(text_annotation)\n    ax.grid(True, which=\'both\')\n    ax.axhline(y=0, color=\'k\')\n    ax.axvline(x=0, color=\'k\')\n    ax.legend(loc = \'lower left\')\n    ax.set_title(""Mantissas Arc Test"")\n    plt.show(block=False);\n\ndef plot_roll_mse(roll_series, figsize):\n    """"""Shows the rolling MSE plot\n    \n    Args:\n        figsize: the figure dimensions.\n    """"""\n    fig, ax = plt.subplots(figsize=figsize)\n    ax.set_facecolor(colors[\'b\'])\n    ax.plot(roll_series, color=colors[\'m\'])\n    plt.show(block=False)\n\ndef plot_roll_mad(roll_mad, figsize):\n    """"""Shows the rolling MAD plot\n    \n    Args:\n        figsize: the figure dimensions.\n    """"""\n    fig, ax = plt.subplots(figsize=figsize)\n    ax.set_facecolor(colors[\'b\'])\n    ax.plot(roll_mad.roll_series, color=colors[\'m\'])\n    if roll_mad.test != -2:\n        plt.axhline(y=mad_dict[roll_mad.test][0], color=colors[\'af\'], linewidth=3)\n        plt.axhline(y=mad_dict[roll_mad.test][1], color=colors[\'h2\'], linewidth=3)\n        plt.axhline(y=mad_dict[roll_mad.test][2], color=colors[\'s\'], linewidth=3)\n    plt.show(block=False)'"
tests/test_checks.py,5,"b'import pytest\nimport pandas as pd\nimport numpy as np\nfrom benford import checks as ch\n\ndef test_check_digs_zero():\n    with pytest.raises(ValueError) as context:\n        ch._check_digs_(0)\n    assert str(context.value) == ""The value assigned to the parameter -digs- was 0. Value must be 1, 2 or 3.""\n\ndef test_check_digs_float():\n    with pytest.raises(ValueError) as context:\n        ch._check_digs_(0.5)\n    assert str(context.value) == ""The value assigned to the parameter -digs- was 0.5. Value must be 1, 2 or 3.""\n\ndef test_check_digs_other_int():\n    with pytest.raises(ValueError) as context:\n        ch._check_digs_(22)\n    assert str (context.value) == ""The value assigned to the parameter -digs- was 22. Value must be 1, 2 or 3.""\n \ndef test_check_digs_str():\n    with pytest.raises(ValueError) as context:\n        ch._check_digs_(\'Two\')\n    assert str(context.value)  == ""The value assigned to the parameter -digs- was Two. Value must be 1, 2 or 3.""\n\n\ndef test_check_test_1():\n    assert ch._check_test_(1) == 1\n\ndef test_check_test_2():\n    assert ch._check_test_(2) == 2\n\ndef test_check_test_3():\n    assert ch._check_test_(3) == 3\n\ndef test_check_test_minus_2():\n    assert ch._check_test_(-2) == -2\n\ndef test_check_test_22():\n    assert ch._check_test_(22) == 22\n\ndef test_check_test_not_in_digs():\n    with pytest.raises(ValueError) as context:\n        ch._check_test_(4)\n\ndef test_check_test_F1D():\n    assert ch._check_test_(\'F1D\') == 1\n\ndef test_check_test_F2D():\n    assert ch._check_test_(\'F2D\') == 2\n\ndef test_check_test_F3D():\n    assert ch._check_test_(\'F3D\') == 3\n\ndef test_check_test_L2D():\n    assert ch._check_test_(\'L2D\') == -2\n\ndef test_check_test_SD():\n    assert ch._check_test_(\'SD\') == 22\n\ndef test_check_test_not_in_rev_digs():\n    with pytest.raises(ValueError) as context:\n        ch._check_test_(\'F4D\')\n\ndef test_check_test_float():\n    with pytest.raises(ValueError) as context:\n        ch._check_test_(2.0)\n        ch._check_test_(-3)\n\ndef test_check_test_bool():\n    with pytest.raises(ValueError) as context:\n        ch._check_test_(False)\n    with pytest.raises(ValueError) as context:\n        ch._check_test_(True)\n    with pytest.raises(ValueError) as context:\n        ch._check_test_(None)\n\n\ndef test_check_decimals_positive_int():\n    assert ch._check_decimals_(2) == 2\n    assert ch._check_decimals_(0) == 0\n    assert ch._check_decimals_(8) == 8\n\ndef test_check_decimals_negative_int():\n    with pytest.raises(ValueError) as context:\n        ch._check_decimals_(-2)\n    assert str(context.value) == ""Parameter -decimals- must be an int >= 0, or \'infer\'.""\n    with pytest.raises(ValueError):\n        ch._check_decimals_(-5)\n\ndef test_check_decimals_infer():\n    assert ch._check_decimals_(\'infer\') == \'infer\'\n\ndef test_check_decimals_other_str():\n    with pytest.raises(ValueError):\n        ch._check_decimals_(\'infe\')\n    with pytest.raises(ValueError):\n        ch._check_decimals_(\'Infer\')\n\ndef test_check_decimals_other_type():\n    with pytest.raises(ValueError):\n        assert ch._check_decimals_(-2)\n    with pytest.raises(ValueError) as context:\n        assert ch._check_decimals_(-2)\n    assert str(context.value) == ""Parameter -decimals- must be an int >= 0, or \'infer\'.""\n    with pytest.raises(ValueError):\n        assert ch._check_decimals_(None)\n    with pytest.raises(ValueError) as context:\n        assert ch._check_decimals_([])\n        \n        \n\ndef test_check_confidence_not_in_conf_keys():\n    with pytest.raises(ValueError) as context:\n        ch._check_confidence_(93)\n\ndef test_check_confidence_str():\n    with pytest.raises(ValueError) as context:\n        ch._check_confidence_(\'95\')\n\ndef test_check_confidence_None():\n    assert ch._check_confidence_(None) is None\n\ndef test_check_confidence_80():\n    assert ch._check_confidence_(80) == 80\n\ndef test_check_confidence_85():\n    assert ch._check_confidence_(85) == 85\n\ndef test_check_confidence_90():\n    assert ch._check_confidence_(90) == 90\n\ndef test_check_confidence_95():\n    assert ch._check_confidence_(95) == 95\n\ndef test_check_confidence_99():\n    assert ch._check_confidence_(99) == 99\n\ndef test_check_confidence_9999():\n    assert ch._check_confidence_(99.9) == 99.9\n\ndef test_check_confidence_99999():\n    assert ch._check_confidence_(99.99) == 99.99\n\ndef test_check_confidence_999999():\n    assert ch._check_confidence_(99.999) == 99.999\n\ndef test_check_confidence_9999999():\n    assert ch._check_confidence_(99.9999) == 99.9999\n\ndef test_check_confidence_99999999():\n    assert ch._check_confidence_(99.99999) == 99.99999\n\n\ndef test_check_high_Z_float():\n    with pytest.raises(ValueError) as context:\n        ch._check_high_Z_(5.0)\n        ch._check_high_Z_(0.3)\n\ndef test_check_high_Z_wrong_str():\n    with pytest.raises(ValueError) as context:\n        ch._check_high_Z_(\'al\')\n        ch._check_high_Z_(\'poss\')\n\ndef test_check_high_Z_int():\n    assert ch._check_high_Z_(10) == 10\n\ndef test_check_high_Z_pos():\n    assert ch._check_high_Z_(\'pos\') == \'pos\'\n    \ndef test_check_high_Z_all():\n    assert ch._check_high_Z_(\'all\') == \'all\'\n\n\ndef test_check_num_array_str():\n    with pytest.raises(ValueError) as context:\n        ch._check_num_array_(\'alocdwneceo;u\')\n\ndef test_check_num_array_list_str():\n    with pytest.raises(ValueError) as context:\n        ch._check_num_array_([\'foo\',\'baar\',\'baz\',\'jinks\'])\n\ndef test_check_num_array_list_of_str_num():\n    assert ch._check_num_array_([\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\']).dtype == float\n\ndef test_check_num_array_list_of_int():\n    assert ch._check_num_array_([1,2,3,4,5,6,7]).dtype == float\n\ndef test_check_num_array_list_of_float():\n    assert ch._check_num_array_([1,2,3,4,5.0,6.3,.17]).dtype == float\n\ndef test_check_num_array_npArray_float():\n    assert ch._check_num_array_(np.array([1,2,3,4,5.0,6.3,.17])).dtype == float\n\ndef test_check_num_array_npArray_int():\n    assert ch._check_num_array_(np.array([1,2,3,4,5,6,7])).dtype == int\n\ndef test_check_num_array_npArray_str_num():\n    assert ch._check_num_array_(np.array([\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\'])).dtype == float\n\ndef test_check_num_array_npArray_str():\n    with pytest.raises(ValueError) as context:\n        ch._check_num_array_(np.array([\'foo\',\'baar\',\'baz\',\'hixks\']))\n\ndef test_check_num_array_Series_float():\n    assert ch._check_num_array_(pd.Series([1,2,3,4,5.0,6.3,.17])).dtype == float\n\ndef test_check_num_array_Series_int():\n    assert ch._check_num_array_(pd.Series([1,2,3,4,5,6,7])).dtype == int\n\ndef test_check_num_array_Series_str_num():\n    assert ch._check_num_array_(pd.Series([\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\'])).dtype == float\n\ndef test_check_num_array_Series_str():\n    with pytest.raises(ValueError) as context:\n        ch._check_num_array_(pd.Series([\'foo\',\'baar\',\'baz\',\'hixks\']))\n    \ndef test_check_num_array_npArray_str_num():\n    assert ch._check_num_array_(np.array([\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\'])).dtype == float\n\ndef test_check_num_array_dict():\n    with pytest.raises(ValueError) as context:\n        ch._check_num_array_({\'a\':1,\'b\':2,\'c\':3,\'d\':4})\n\ndef test_check_num_array_tuple():\n    with pytest.raises(ValueError) as context:\n        ch._check_num_array_({1,2,3,4})\n\n\n'"
tests/test_utils.py,2,"b""import pytest\nimport numpy as np\nimport pandas as pd\nfrom benford import utils as ut\n\ndef test_set_N_Limit_None():\n    assert ut._set_N_(100, None) == 100\n\ndef test_set_N_Limit_greater():\n    assert ut._set_N_(100, 99) == 99\n    assert ut._set_N_(1000, 750) == 750\n\ndef test_set_N_negative():\n    with pytest.raises(ValueError) as context:\n        ut._set_N_(-250, -1000)\n\ndef test_set_N_float():\n    with pytest.raises(ValueError) as context:\n        ut._set_N_(127.8, -100)\n\n@pytest.fixture\ndef gen_array():\n    arr = np.random.rand(3000) * np.random.randn(3000) * 1000\n    return np.abs(arr)\n\n@pytest.fixture\ndef gen_series(gen_array):\n    return pd.Series(gen_array)\n\n@pytest.fixture\ndef gen_data_frame(gen_array):\n    return pd.DataFrame({'col1': gen_array,'col2': gen_array})\n\ndef test_get_mantissas_less_than_1(gen_array):\n    assert sum(ut.get_mantissas(gen_array) >= 1) == 0\n\ndef test_get_mantissas_less_than_0(gen_array):\n    assert sum(ut.get_mantissas(gen_array) < 0) == 0\n\ndef test_input_data_Series(gen_series):\n    tup = ut.input_data(gen_series)\n    assert tup[0] is tup[1]\n\ndef test_input_data_array(gen_array):\n    tup = ut.input_data(gen_array)\n    assert tup[0] is gen_array\n    assert type(tup[1]) == pd.Series\n\ndef test_input_data_wrong_tuple():\n    with pytest.raises(TypeError) as context:\n        ut.input_data((gen_array, 'col1'))\n        ut.input_data((gen_series, 'col1'))\n        ut.input_data((gen_data_frame, 2))\n\ndef test_input_data_df(gen_data_frame):\n    tup = ut.input_data((gen_data_frame, 'col1'))\n    assert type(tup[0]) == pd.DataFrame\n    assert type(tup[1]) == pd.Series\n\ndef test_input_data_wrong_input_type(gen_array):\n    with pytest.raises(TypeError) as context:\n        ut.input_data(gen_array.tolist())\n\ndef test_extract_digs(gen_array):\n    e_digs = ut.extract_digs(gen_array, decimals=8)\n    assert len(e_digs) == len(gen_array)\n    assert len(e_digs.columns) == 7\n\n# @pytest.fixture\n# def gen_input(gen_array):\n#     return ut.input_data(gen_array)\n\n\n\n# def test_prepare_1_simple_no_confidence(gen_series): \n#     df = ut.prepare(gen_series, 1, simple=True)\n#     assert type(df) == pd.DataFrame\n#     assert len(df.columns) == 4\n#     assert len(df) == 9\n#     print(df.Found)\n#     # assert df.Found.sum() > .999\n\n# def test_prepare_2__conf(gen_series):\n#     df = ut.prepare(gen_series, 2, confidence=95)\n#     assert type(df) == tuple\n#     assert len(df[1].columns) == 6\n#     assert len(df[1]) == 90\n#     # assert df[0] == len(gen_input[1])\n#     assert 'Z_score' in df[1].columns\n#     assert df[1].Found.sum() > .999\n\n# def test_prepare_22_conf(gen_series):\n#     N, df = ut.prepare(gen_series, 22, confidence=95)\n#     assert len(df) == 10\n#     assert df.Found.sum() == 0\n"""
docs/source/conf.py,0,"b'# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\nsys.path.insert(0, os.path.abspath(\'../..\'))\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \'benford_py\'\ncopyright = \'2020, Marcel Milcent\'\nauthor = \'Marcel Milcent\'\n\n# The full version, including alpha/beta/rc tags\nrelease = \'0.2.1\'\n\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx.ext.napoleon\'\n]\n\nmaster_doc = \'index\'\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = []\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Show in order of code source, not alphabetical\nautodoc_member_order = \'bysource\''"
