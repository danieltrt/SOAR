file_path,api_count,code
setup.py,2,"b'import re\nfrom subprocess import Popen\nfrom setuptools import setup, Extension, find_packages\nfrom setuptools.command.build_ext import build_ext\nfrom Cython.Build import cythonize\nimport numpy as np\n\nwith open(\'lumberjack/_version.py\', \'r\') as f:\n    __version__ = re.search(r""__version__?\\s=?\\s\'([^\']+)"", f.read()).groups()[0]\n\nsetup_requires = [\'pytest-runner\', ""Cython""]\ninstall_requires = [\'numpy\']\ntests_require = install_requires + [\'pytest==3.5.0\', \'pytest-benchmark\']\n\n\nclass BuildRustLib(build_ext):\n    """"""\n    Augment the setup.py build_ext command to creat the Rust shared object\n    """"""\n    def run(self):\n        print(\'running build of liblumberjack\')\n        process = Popen([\'cargo\', \'build\', \'--out-dir\', \'./lumberjack/rust/\', \'-Z\', \'unstable-options\', \'--release\'])\n        process.wait()\n        if process.returncode != 0:\n            raise RuntimeError(\'Failed building liblumberjack object, exit code: {}\'.format(process.returncode))\n        super().run()\n\n\nrust_core_ext = Extension(name=""*"",\n                          sources=[""lumberjack/cython/*.pyx""],\n                          libraries=[\'lumberjack\'],\n                          include_dirs=[\'./lumberjack/rust/\', np.get_include()],\n                          library_dirs=[\'./lumberjack/rust/\'])\n\nsetup(\n    name=\'lumber-jack\',\n    version=__version__,\n    maintainer=""Miles Granger"",\n    keywords=""pandas rust python data manipulation processing dataframe series"",\n    url=""https://github.com/milesgranger/lumber-jack"",\n    description=""Alpha work: Lightweight & efficient alternative to Pandas"",\n    long_description= \\\n        """"""""\n        Alpha work: Lightweight & efficient alternative to Pandas. \n        All data manipulation and acquisition is done within Rust. The only data transfers into Python are done upon\n        request (given as numpy arrays) and small subsets of the underlying data for visual representation from within \n        Python.\n        \n        The goal of the alpha work is mainly to help me better learn Rust, Cython and software craftsmanship in general.\n        \n        **If/when this breaks, you get to keep the sharp shiny pieces, but filing an issue is always welcome! ;)\n        """""",\n    cmdclass={\n      \'build_ext\': BuildRustLib\n    },\n    classifiers=[\n        \'License :: OSI Approved :: MIT License\',\n        \'Development Status :: 3 - Alpha\',\n        \'Intended Audience :: Developers\',\n        \'Intended Audience :: Financial and Insurance Industry\',\n        \'Intended Audience :: Information Technology\',\n        \'Intended Audience :: Science/Research\',\n        \'Programming Language :: Python\',\n        \'Programming Language :: Python :: 3.6\',\n        \'Programming Language :: Python :: 3.5\',\n        \'Programming Language :: Python :: 3 :: Only\',\n        \'Programming Language :: Rust\',\n        \'Operating System :: Microsoft :: Windows\',\n        \'Operating System :: POSIX\',\n        \'Operating System :: Unix\',\n        \'Operating System :: MacOS :: MacOS X\',\n    ],\n    packages=find_packages(),\n    include_dirs=[np.get_include(), \'lumberjack/rust/\'],\n    ext_modules=cythonize([rust_core_ext]),\n    install_requires=install_requires,\n    tests_require=tests_require,\n    test_suite=\'tests\',\n    setup_requires=setup_requires + install_requires,\n    include_package_data=True,\n    license=""OSI Approved :: BSD License"",\n    zip_safe=False\n)\n\n'"
lumberjack/__init__.py,0,b'# -*- coding: utf-8 -*-\nfrom ._version import __version__\nfrom .series import Series\n'
lumberjack/_version.py,0,"b""__version__ = '0.0.1'\n"""
lumberjack/alterations.py,1,"b'# -*- coding: utf-8 -*-\n\nimport numpy as np\nfrom collections import Iterable\nfrom lumberjack.rust import alterations  # rust compiled module\n\n\ndef split_n_one_hot_encode(raw_texts: Iterable, sep: str, cutoff: int):\n    """"""\n    Given array of raw texts where each instance is separated by <something> return one-hot encoded array where\n    each instance of the one-hot array indicates if the word was present in the instance of raw_text\n\n    :param raw_texts:\n    :param sep:\n    :param cutoff:\n    :return:\n    """"""\n\n    if not isinstance(raw_texts, Iterable):\n        raise ValueError(\'raw_texts should be an iterable with values string values\')\n\n    if not isinstance(sep, str):\n        raise ValueError(\'sep should be a str instance\')\n\n    if not isinstance(cutoff, int):\n        raise ValueError(\'cutoff should be an integer\')\n\n    words, array = alterations.split_n_one_hot_encode(raw_texts, sep, cutoff)\n    return words, np.array(array, dtype=np.uint8)\n'"
lumberjack/dataframe.py,0,b'# -*- coding: utf-8 -*-\n'
lumberjack/series.py,0,b'# -*- coding: utf-8 -*-\n\nimport logging\nimport cloudpickle\nimport pandas as pd\nfrom lumberjack.cython.series import LumberJackSeries\n\nlogger = logging.getLogger(__name__)\n\n\nclass Series(LumberJackSeries):\n    pass\n'
tests/test_rust_series.py,7,"b'# -*- coding: utf-8 -*-\n\nimport unittest\nimport logging\nimport timeit\nimport time\nimport pickle\nimport cloudpickle\nimport numpy as np\nimport pandas as pd\nimport lumberjack as lj\n\nfrom tests.utils import run_series_method_tests\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass RustSeriesTestCase(unittest.TestCase):\n\n    def test_from_numpy(self):\n        array = np.arange(0, 10, dtype=float)\n        series = lj.Series.from_numpy(array)\n        self.assertEqual(array.sum(), series.sum())\n\n    def test_astype(self):\n        """"""Test converting series from one type to another""""""\n        int_series = lj.Series.arange(0, 50)\n        float_series = int_series.astype(float)\n        self.assertEqual(int_series.to_numpy().dtype, np.int32)\n        self.assertEqual(float_series.to_numpy().dtype, np.float64)\n\n    def test_series_map(self):\n        lj_series = lj.Series.arange(0, 10, float)\n        variable = 2.0\n        self.assertNotEqual(lj_series.sum(), 0.0)\n        #result = lj_series.map(lambda v: v * 0.0, out_dtype=float)\n        #self.assertEqual(result.sum(), 0.0)\n        #logger.debug(\'Result values: {}\'.format(result.to_numpy().astype(int)))\n        #result1 = lj_series.map(lambda v: 2.0, out_dtype=float)\n        #result2 = lj_series.map(lambda v: 30, out_dtype=float)\n        #logger.debug(\'Result from .map() -> {}\'.format(result))\n        lj_time, pd_time, _ = run_series_method_tests(stmt=""series.map(lambda v: v)"", skip_numpy=True, n_iter=20)\n\n    def test_picklable(self):\n        """"""\n        Test ability to be pickled.\n        """"""\n        series = lj.Series.arange(0, 10)\n        pkl = pickle.dumps(series)\n        series_copy = pickle.loads(pkl)\n        self.assertEqual(series.sum(), series_copy.sum())\n        self.assertFalse(series_copy.is_owner)\n\n        # Assert deleting the copy doesn\'t affect the original\n        orig_sum = series.sum()\n        del series_copy\n        self.assertEqual(series.sum(), orig_sum)\n\n        # Do another pickle.. jbc\n        pkl = pickle.dumps(series)\n        series_copy = pickle.loads(pkl)\n        self.assertEqual(series.sum(), series_copy.sum())\n        self.assertFalse(series_copy.is_owner)\n\n    def test_mean(self):\n        """"""\n        Test average/mean of series\n        """"""\n        lj_series = lj.Series.arange(0, 10000)\n        pd_series = pd.Series(np.arange(0, 10000))\n        avg = lj_series.mean()\n        logger.debug(\'Mean of arange(0, 10000) -> {:.4f}\'.format(avg))\n        self.assertEqual(lj_series.mean(), pd_series.mean())\n\n        # Speed test\n        lj_time, pd_time, np_time = run_series_method_tests(\'series.mean()\')\n        self.assertLessEqual(lj_time, pd_time)\n\n    def test_cumsum(self):\n        """"""\n        Test cumulative sum of series\n        """"""\n        series = lj.Series.arange(0, 4)\n        _pd_series = pd.Series(np.arange(0, 4))\n        cumsum = series.cumsum()\n        logger.debug(\'Got cumsum of {}\'.format(cumsum))\n\n        # Ensure they sum to the same\n        lj_cumsum_sum = series.cumsum().sum()\n        pd_cumsum_sum = _pd_series.cumsum().sum()\n        self.assertEqual(lj_cumsum_sum, pd_cumsum_sum,\n                         msg=\'LumberJack and Pandas .cumsum().sum() does not match! -- LumberJack: {}, Pandas: {}\'\n                             .format(lj_cumsum_sum, pd_cumsum_sum)\n                         )\n        # Speed test\n        lj_time, pd_time, np_time = run_series_method_tests(\'series.cumsum()\')\n        self.assertLessEqual(lj_time, pd_time)\n\n\n    def test_sum(self):\n        """"""\n        Test the ability to sum a series\n        """"""\n        series = lj.Series.arange(0, 4)\n        total = series.sum()\n        logger.debug(\'Sum of arange(0, 4) is: {}\'.format(total))\n        self.assertEqual(total, 6)\n\n        # Speed test\n        lj_time, pd_time, np_time = run_series_method_tests(\'series.sum()\')\n        self.assertLessEqual(lj_time, np_time, msg=\'Expected LumberJack .sum() to be faster but it was not!\')\n\n    def test_arange(self):\n        """"""\n        Check creating an array from inside Rust and passing it to Python\n        """"""\n        series = lj.Series.arange(0, 4)\n        vec = series.to_numpy()\n        logger.debug(\'Vector type: {}, and it looks like: {}, sum is: {}\'.format(type(vec), vec, vec.sum()))\n        self.assertEqual(vec.sum(), 6)\n\n        # If we re-implement numpy function, they should be faster\n        lj_time = timeit.timeit(\'LumberJackSeries.arange(0, 10000)\',\n                                number=10000,\n                                setup=\'from lumberjack.cython.series import LumberJackSeries\')\n        np_time = timeit.timeit(\'np.arange(0, 10000)\',\n                                number=10000,\n                                setup=\'import numpy as np\')\n        logger.debug(\'.arange(0, 10000) speed: Avg LumberJack: {:4f}s -- Avg numpy: {:.4f}s\'.format(lj_time, np_time))\n        self.assertLess(lj_time, np_time,\n                        \'Expected LumberJack ({:.4f}) to be faster than numpy ({:.4f}), but it was not!\'\n                        .format(lj_time, np_time))\n\n    def test_describe(self):\n        """"""\n        Test that a call to a method not implemented in LumberJack will forward that call to Pandas\n        in this case \'.describe()\'\n\n        Additionally, ensure a call to a method with neither has, raises the same error as it would otherwise.\n        """"""\n        series = lj.Series.arange(0, 10)\n        descript = series.describe()\n        self.assertIsInstance(\n            obj=descript,\n            cls=pd.Series,\n            msg=\'Expected call to "".describe()"" to produce a pandas Series, it produced a {} instead!\'.format(descript)\n        )\n        with self.assertRaises(AttributeError):\n            series.THIS_METHOD_DOES_NOT_EXIST_IN_EITHER_PANDAS_OR_LUMBERJACK()\n    \'\'\'\n    def test_from_numpy(self):\n        """"""\n        Test creating a series from numpy array\n        """"""\n        from lumberjack.cython.series import LumberJackSeries\n\n        array = np.ones(shape=(10,), dtype=float)\n        series = LumberJackSeries.from_numpy(array)\n        logger.debug(\'Made series from numpy: {}\'.format(series))\n    \'\'\'\n'"
tests/test_rust_series_dunders.py,0,"b'# -*- coding: utf-8 -*-\n\nimport unittest\nimport logging\n\nimport lumberjack as lj\nfrom tests.utils import run_series_method_tests\n\nlogger = logging.getLogger(__name__)\n\n\nclass RustSeriesDundersTestCase(unittest.TestCase):\n    """"""\n    Test dunder impls.\n    """"""\n\n    def test_indexing_getitem(self):\n        """"""Depends on __getitem__""""""\n        series = lj.Series.arange(0, 5)\n        self.assertEqual(series[0], 0)\n        self.assertEqual(series[-1], 4)\n\n    def test_indexing_setitem(self):\n        """"""Depends on __setitem__""""""\n        series = lj.Series.arange(0, 5)\n\n        # Test basic capability\n        self.assertEqual(series[0], 0)\n        series[0] = 1\n        self.assertEqual(series[0], 1)\n\n        # Test adding float to Int32, should convert any decimal to it\'s base integer value as numpy does.\n        series[0] = 10.9\n        self.assertEqual(series[0], 10)\n\n        # Test adding string to int32 series raises a TypeError\n        with self.assertRaises(ValueError):\n            series[0] = \'String does not belong in this int32 series!\'\n\n    def test_sum(self):\n        """"""Depends on __iter__""""""\n        lj_series = lj.Series.arange(0, 5)\n        self.assertEqual(lj_series.sum(), sum(lj_series))\n\n    def test_add_by_scalar(self):\n        lj_series = lj.Series.arange(0, 5)\n        result = lj_series + 1\n        self.assertEqual(result.sum(), 15)\n\n        # Speed Test\n        run_series_method_tests(\'series + 1\')\n\n    def test_add_by_scalar_inplace(self):\n        lj_series = lj.Series.arange(0, 5)\n        lj_series += 1\n        self.assertEqual(lj_series.sum(), 15)\n\n        # Speed Test\n        run_series_method_tests(\'series += 1\')\n\n    def test_multiply_by_scalar(self):\n        lj_series = lj.Series.arange(0, 5)\n        result = lj_series * 2\n        self.assertEqual(result.sum(), 20)\n\n        # Speed Test\n        run_series_method_tests(\'series * 2\')\n\n    def test_multiply_by_scalar_inplace(self):\n        lj_series = lj.Series.arange(0, 5)\n        lj_series *= 2\n        self.assertEqual(lj_series.sum(), 20)\n\n        # Speed Test\n        run_series_method_tests(\'series *= 2\')\n\n    def test_len(self):\n        """"""\n        Test __len__, length check\n        """"""\n        series = lj.Series.arange(0, 5)\n        self.assertEqual(len(series), 5)\n\n    def test_iter(self):\n        """"""\n        Test appropriate iteration capability\n        """"""\n        series = lj.Series.arange(0, 5)\n        _list = list(range(5))\n\n        for v1, v2 in zip(series, _list):\n            self.assertEqual(v1, v2)\n'"
tests/utils.py,4,"b'# -*- coding: utf-8 -*-\n\nimport logging\nimport timeit\nimport numpy as np\n\nlogger = logging.getLogger(__name__)\n\n\ndef run_series_method_tests(stmt: str,\n                            alternate_numpy_stmt: str=None,\n                            alternate_pandas_stmt: str=None,\n                            skip_numpy: bool=False,\n                            n_iter: int=2500):\n    """"""\n    Run the timing tests for LumberJack, Numpy and Pandas\n    calling the same method on an arange of the series/array with an optional alternative\n    to numpy (ie. np.abs(array), array.abs() doesn\'t exist)\n    """"""\n    # Test speed\n    lj_time = timeit.timeit(stmt=stmt,\n                            number=n_iter,\n                            setup=\'import lumberjack as lj; series = lj.Series.arange(0, 50000)\')\n    pd_time = timeit.timeit(stmt=stmt if alternate_pandas_stmt is None else alternate_pandas_stmt,\n                            number=n_iter,\n                            setup=\'import numpy as np; import pandas as pd; series = pd.Series(np.arange(0, 50000))\')\n\n    if skip_numpy:\n        np_time = np.NaN\n    else:\n        np_time = timeit.timeit(stmt=stmt if alternate_numpy_stmt is None else alternate_numpy_stmt,\n                                number=n_iter,\n                                setup=\'import numpy as np; series = np.arange(0, 50000)\')\n\n    logger.debug(\'""{}"" speed: Avg LumberJack: {:.4f}s -- Pandas: {:.4f} -- Numpy: {:.4f}\'\n                 .format(stmt, lj_time, pd_time, np_time))\n    return lj_time, pd_time, np_time\n'"
lumberjack/cython/__init__.py,0,b''
lumberjack/rust/__init__.py,0,b''
