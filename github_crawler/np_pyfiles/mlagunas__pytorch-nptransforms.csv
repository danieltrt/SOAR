file_path,api_count,code
exr_data.py,5,"b'from torchvision.datasets import folder\n\n\ndef exr_loader(path, ndim=3):\n    """"""\n    loads an .exr file as a numpy array\n    :param path: path to the file\n    :param ndim: number of channels that the image has,\n                    if 1 the \'R\' channel is taken\n                    if 3 the \'R\', \'G\' and \'B\' channels are taken\n    :return: np.array containing the .exr image\n    """"""\n    import OpenEXR\n    import Imath\n    import numpy as np\n\n    # read image and its dataWindow to obtain its size\n    pic = OpenEXR.InputFile(path)\n    dw = pic.header()[\'dataWindow\']\n    size = (dw.max.x - dw.min.x + 1, dw.max.y - dw.min.y + 1)\n\n    pt = Imath.PixelType(Imath.PixelType.FLOAT)\n\n    if ndim == 1:\n        # transform data to numpy\n        channel = np.fromstring(channel=pic.channel(\'R\', pt), dtype=np.float32)\n        channel.shape = (size[1], size[0])  # Numpy arrays are (row, col)\n        return np.array(channel)\n    if ndim == 3:\n        # read channels indivudally\n        allchannels = []\n        for c in [\'R\', \'G\', \'B\']:\n            # transform data to numpy\n            channel = np.fromstring(pic.channel(c, pt), dtype=np.float32)\n            channel.shape = (size[1], size[0])\n            allchannels.append(channel)\n\n        # create array and transpose dimensions to match numpy style\n        return np.array(allchannels).transpose((1, 2, 0))\n\n\nclass ExrData(folder.ImageFolder):\n    def __init__(self, *args, **kwargs):\n        # add the \'.exr\' extension to load this type of files\n        folder.IMG_EXTENSIONS += [\'.exr\']\n\n        super(exrData, self).__init__(*args, **kwargs)\n'"
np_transforms.py,29,"b'from __future__ import division\n\nimport math\nimport random\n\nimport numpy as np\nimport torch\nfrom numpy import linalg\n\ntry:\n    import accimage\nexcept ImportError:\n    accimage = None\nimport numbers\nfrom scipy import misc, ndimage\nimport collections\nfrom torchvision import transforms\n\n\ndef _is_numpy_image(img):\n    return isinstance(img, np.ndarray)\n\n\ndef crop(pic, i, j, h, w):\n    if not _is_numpy_image(pic):\n        raise TypeError(\'img should be Numpy Image. Got {}\'.format(type(pic)))\n\n    return pic[i:i + h, j:j + w, :]\n\n\nclass BilateralFilter(object):\n    def __init__(self, sigma_s=0.05, sigma_r=0.6, n_iter=5):\n        self.sigma_s = sigma_s\n        self.sigma_r = sigma_r\n        self.n_iter = n_iter\n\n    def __call__(self, pic):\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n\n        # if image has only 2 channels make them 3\n        if len(pic.shape) != 3:\n            pic = pic.reshape(pic.shape[0], pic.shape[1], -1)\n\n        pic = self.bilateral(pic, self.sigma_s, self.sigma_r, self.n_iter)\n        return pic\n\n    def bilateral(self, img, sigma_s, sigma_r, num_iterations, J=None):\n        if img.ndim == 3:\n            img = img.copy()\n        else:\n            h, w = img.shape\n            img = img.reshape((h, w, 1))\n\n        if J is None:\n            J = img\n\n        if J.ndim == 2:\n            h, w = J.shape\n            J = np.reshape(J, (h, w, 1))\n\n        h, w, num_channels = J.shape\n\n        dIcdx = np.diff(J, n=1, axis=1)\n        dIcdy = np.diff(J, n=1, axis=0)\n\n        dIdx = np.zeros((h, w))\n        dIdy = np.zeros((h, w))\n\n        for c in range(num_channels):\n            dIdx[:, 1:] = dIdx[:, 1:] + np.abs(dIcdx[:, :, c])\n            dIdy[1:, :] = dIdy[1:, :] + np.abs(dIcdy[:, :, c])\n\n        dHdx = (1.0 + sigma_s / sigma_r * dIdx)\n        dVdy = (1.0 + sigma_s / sigma_r * dIdy)\n\n        dVdy = dVdy.T\n\n        N = num_iterations\n        F = img.copy()\n\n        sigma_H = sigma_s\n\n        for i in range(num_iterations):\n            sigma_H_i = sigma_H * math.sqrt(3.0) * (2.0 ** (N - (i + 1))) / math.sqrt(4.0 ** N - 1.0)\n\n            F = self.rec_filter_horizontal(F, dHdx, sigma_H_i)\n            F = np.swapaxes(F, 0, 1)\n            F = self.rec_filter_horizontal(F, dVdy, sigma_H_i)\n            F = np.swapaxes(F, 0, 1)\n\n        return F\n\n    @staticmethod\n    def rec_filter_horizontal(img, D, sigma):\n        a = math.exp(-math.sqrt(2.0) / sigma)\n\n        F = img.copy()\n        V = np.power(a, D)\n\n        h, w, num_channels = img.shape\n\n        for i in range(1, w):\n            for c in range(num_channels):\n                F[:, i, c] = F[:, i, c] + V[:, i] * (F[:, i - 1, c] - F[:, i, c])\n\n        for i in range(w - 2, -1, -1):\n            for c in range(num_channels):\n                F[:, i, c] = F[:, i, c] + V[:, i + 1] * (F[:, i + 1, c] - F[:, i, c])\n\n        return F\n\n\nclass MedianFilter(object):\n    def __init__(self, size):\n        self.size = size\n\n    def __call__(self, pic):\n\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n\n        # if image has only 2 channels make them 3\n        if len(pic.shape) != 3:\n            pic = pic.reshape(pic.shape[0], pic.shape[1], -1)\n\n        pic = ndimage.median_filter(pic, size=self.size)\n        return pic\n\n\nclass RotateImage(object):\n    def __init__(self, angles):\n        if isinstance(angles, tuple):\n            assert len(angles) == 2, \\\n                \'angles should be a list with the lower and upper bounds to sample the angle or a number\'\n            self.angles = np.float32(np.random.uniform(*angles))\n        else:\n            self.angles = angles\n\n    def __call__(self, pic):\n        from skimage.transform import rotate\n\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n\n        rot = pic.copy()\n        for index in range(3):\n            channel = rot[index, :, :]\n            channel = rotate(channel, self.angles, resize=False, preserve_range=True)\n            rot[index, :, :] = channel\n        return np.float32(rot)\n\n    def test(self):\n\n        from matplotlib import pyplot as plt\n        pic = np.zeros((3, 10, 10))\n        pic[:, 3:6, :] = 1\n\n        rot = self(pic)\n        f, axarr = plt.subplots(1, 2)\n        axarr[0].imshow(pic.transpose((1, 2, 0)))\n        axarr[1].imshow(rot.transpose((1, 2, 0)))\n\n        plt.show()\n\n\nclass RandomCrop(object):\n    """"""\n    Performs a random crop in a given numpy array using only the first two dimensions (width and height)\n    """"""\n\n    def __init__(self, size, ):\n        if isinstance(size, numbers.Number):\n            self.size = (int(size), int(size))\n        else:\n            self.size = size\n\n    @staticmethod\n    def get_params(pic, output_size):\n\n        # read dimensions (width, height, channels)\n        w, h, c = pic.shape\n\n        # read crop size\n        th, tw = output_size\n\n        # get crop indexes\n        i = random.randint(0, w - tw)\n        j = random.randint(0, h - th)\n\n        return i, j, th, tw\n\n    def __call__(self, pic):\n        """"""\n\n        :param input: numpy array\n        :return: numpy array croped using self.size\n        """"""\n\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n\n        # if image has only 2 channels make it three channel\n        if len(pic.shape) != 3:\n            pic = pic.reshape(pic.shape[0], pic.shape[1], -1)\n\n        # get crop params: starting pixels and size of the crop\n        i, j, th, tw = self.get_params(pic, self.size)\n\n        # perform cropping and return the new image\n        return pic[i:i + th, j:j + tw, :]\n\n\nclass CenterCrop(object):\n    """"""Crops the given PIL Image at the center.\n    Args:\n        size (sequence or int): Desired output size of the crop. If size is an\n            int instead of sequence like (h, w), a square crop (size, size) is\n            made.\n    """"""\n\n    def __init__(self, size):\n        if isinstance(size, numbers.Number):\n            self.size = (int(size), int(size))\n        else:\n            self.size = size\n\n    @staticmethod\n    def get_params(pic, output_size):\n        """"""Get parameters for ``crop`` for center crop.\n        Args:\n            pic (np array): Image to be cropped.\n            output_size (tuple): Expected output size of the crop.\n        Returns:\n            tuple: params (i, j, h, w) to be passed to the crop for center crop.\n        """"""\n\n        w, h, c = pic.shape\n        th, tw = output_size\n\n        i = int(round((h - th) / 2.))\n        j = int(round((w - tw) / 2.))\n\n        return i, j, th, tw\n\n    def __call__(self, pic):\n        """"""\n        Args:\n            pic (np array): Image to be cropped.\n        Returns:\n            np array: Cropped image.\n        """"""\n\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n\n        # if image has only 2 channels make them 3\n        if len(pic.shape) != 3:\n            pic = pic.reshape(pic.shape[0], pic.shape[1], -1)\n\n        # get crop params: starting pixels and size of the crop\n        i, j, h, w = self.get_params(pic, self.size)\n\n        return pic[i:i + h, j:j + w, :]\n\n\nclass FiveCrop(object):\n    """"""Crop the given PIL Image into four corners and the central crop\n    .. Note::\n         This transform returns a tuple of images and there may be a mismatch in the number of\n         inputs and targets your Dataset returns. See below for an example of how to deal with\n         this.\n    Args:\n         size (sequence or int): Desired output size of the crop. If size is an ``int``\n            instead of sequence like (h, w), a square crop of size (size, size) is made.\n    """"""\n\n    def __init__(self, size):\n        self.size = size\n        if isinstance(size, numbers.Number):\n            self.size = (int(size), int(size))\n        else:\n            assert len(size) == 2, ""Please provide only two dimensions (h, w) for size.""\n            self.size = size\n\n    def __call__(self, img):\n        w, h = img.shape[0], img.shape[1]\n        crop_h, crop_w = self.size\n\n        if crop_w > w or crop_h > h:\n            raise ValueError(""Requested crop size {} is bigger than input size {}"".format(self.size, (h, w)))\n\n        tl = crop(img, 0, 0, crop_w, crop_h)\n        tr = crop(img, w - crop_w, 0, w, crop_h)\n        bl = crop(img, 0, h - crop_h, crop_w, h)\n        br = crop(img, w - crop_w, h - crop_h, w, h)\n        center = CenterCrop(self.size)(img)\n\n        return (tl, tr, bl, br, center)\n\n    def __repr__(self):\n        return self.__class__.__name__ + \'(size={0})\'.format(self.size)\n\n\nclass Normalize_01(object):\n    """"""\n    Normalize the values of a numpy array between 0-1\n    """"""\n\n    def __init__(self, min=None, max=None):\n        """"""\n\n        :param min: minimum value, by default None. Useful to normalize 0-1 globally\n               max: maximum value, by default None. Useful to normalize 0-1 globally\n        """"""\n        self.min = min\n        self.max = max\n\n    def __call__(self, pic):\n        """"""\n        :param pic: numpy array\n        :return: same array with its values normalized between 0-1\n        """"""\n        min = self.min if self.min is not None else np.min(pic)\n        max = self.max if self.max is not None else np.max(pic)\n\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n        pic = (pic - min) / (max - min)\n        return pic\n\n\nclass RandomErasing(object):\n    \'\'\'\n    Class that performs Random Erasing in Random Erasing Data Augmentation by Zhong et al.\n    Code from git repo (I do not remember which one)\n    -------------------------------------------------------------------------------------\n    probability: The probability that the operation will be performed.\n    sl: min erasing area\n    sh: max erasing area\n    r1: min aspect ratio\n    mean: erasing value\n    -------------------------------------------------------------------------------------\n    \'\'\'\n\n    def __init__(self, probability=0.5, sl=0.02, sh=0.4, r1=0.3, mean=[0.4914, 0.4822, 0.4465]):\n        self.probability = probability\n        self.mean = mean\n        self.sl = sl\n        self.sh = sh\n        self.r1 = r1\n\n    def __call__(self, img):\n\n        if random.uniform(0, 1) > self.probability:\n            return img\n\n        for attempt in range(100):\n            area = img.size()[1] * img.size()[2]\n\n            target_area = random.uniform(self.sl, self.sh) * area\n            aspect_ratio = random.uniform(self.r1, 1 / self.r1)\n\n            h = int(round(math.sqrt(target_area * aspect_ratio)))\n            w = int(round(math.sqrt(target_area / aspect_ratio)))\n\n            if w <= img.size()[2] and h <= img.size()[1]:\n                x1 = random.randint(0, img.size()[1] - h)\n                y1 = random.randint(0, img.size()[2] - w)\n                if img.size()[0] == 3:\n                    img[0, x1:x1 + h, y1:y1 + w] = self.mean[0]\n                    img[1, x1:x1 + h, y1:y1 + w] = self.mean[1]\n                    img[2, x1:x1 + h, y1:y1 + w] = self.mean[2]\n                else:\n                    img[0, x1:x1 + h, y1:y1 + w] = self.mean[0]\n                return img\n\n        return img\n\n\nclass ToTensor(object):\n    """"""\n    Convert a ``numpy.ndarray`` to tensor.\n    """"""\n\n    def __call__(self, pic):\n        """"""\n        Args:\n            converts pic (numpy array) to Tensor\n\n        Returns:\n            Tensor: Converted image.\n        """"""\n\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n\n        if len(pic.shape) == 1: return torch.FloatTensor(pic.copy())\n\n        return torch.FloatTensor(pic.transpose((2, 0, 1)).copy())\n\n\nclass Scale(object):\n    """"""\n    Rescale the given numpy image to a specified size.\n    """"""\n\n    def __init__(self, size, interpolation=""bilinear""):\n        assert isinstance(size, int) or (isinstance(size, collections.Iterable) and len(size) == 2)\n        self.size = size\n        self.interpolation = interpolation\n\n    def __call__(self, pic):\n\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n\n        if isinstance(self.size, int):\n            # if size is specified with one dimension only get the second one keeping the\n            # aspect-ratio\n\n            # get the size of the original image\n            w, h = pic.shape[:2]\n            if (w <= h and w == self.size) or (h <= w and h == self.size):\n                return pic\n\n            # calculate the ouput size keeping the aspect-ratio\n            if w < h:\n                ow = self.size\n                oh = int(self.size * h / w)\n            else:\n                oh = self.size\n                ow = int(self.size * w / h)\n\n            # create the output array\n            img_out = np.zeros((ow, oh, pic.shape[2]))\n\n            if len(pic.shape) == 3:\n                # if 3D image, scale each channel individually\n                for i in range(pic.shape[2]):\n                    img_out[:, :, i] = misc.imresize(pic[:, :, i], (ow, oh), interp=self.interpolation, mode=\'F\')\n                return img_out\n            else:\n                # if 2D image, scale image\n                return misc.imresize(pic, (ow, oh), interp=self.interpolation, mode=\'F\')\n        else:\n            # if size is specified with 2 dimensions apply the scale directly\n            # create the output array\n\n            if len(pic.shape) == 3:\n                img_out = np.zeros((self.size[0], self.size[1], pic.shape[2]))\n\n                # if 3D image, scale each channel individually\n                for i in range(pic.shape[2]):\n                    img_out[:, :, i] = misc.imresize(pic[:, :, i], self.size, interp=self.interpolation, mode=\'F\')\n                return img_out\n            else:\n                # if 2D image, scale image\n                return misc.imresize(pic, self.size, interp=self.interpolation, mode=\'F\')\n\n\nclass rgb2xyz(object):\n    """"""\n    Transform a numpy array in the form [H, W, C] from RGB color space to XYZ color space.\n    """"""\n\n    def __init__(self):\n        self.matrix = np.array([[0.412453, 0.357580, 0.180423],\n                                [0.212671, 0.715160, 0.072169],\n                                [0.019334, 0.119193, 0.950227]])\n\n    def __call__(self, pic):\n        """"""\n\n        :param input: numpy array in RGB color space\n        :return: numpy array in XYZ color space\n        """"""\n        if isinstance(pic, np.ndarray):\n            # from skimage import color\n            # return color.rgb2lab(pic, self.illuminant, self.observer)\n\n            arr = np.asanyarray(pic)\n\n            if arr.ndim not in [3, 4] or arr.shape[-1] != 3:\n                msg = (""the input array must be have a shape == (.., ..,[ ..,] 3)), "" +\n                       ""got ("" + ("", "".join(map(str, arr.shape))) + "")"")\n                raise ValueError(msg)\n\n            return np.dot(arr, self.matrix.T.copy())\n\n            # out_img = np.zeros(pic.shape)\n            #\n            # for row in range(pic.shape[0]):\n            #     for col in range(pic.shape[1]):\n            #         out_img[row, col] = np.dot(self.matrix, pic[row, col])\n            #\n            # return out_img\n        else:\n            raise TypeError(""Tensor [pic] is not numpy array"")\n\n\nclass xyz2rgb(object):\n    def __init__(self):\n        self.matrix = linalg.inv(rgb2xyz().matrix)\n\n    def __call__(self, pic):\n        if isinstance(pic, np.ndarray):\n            # from skimage import color\n            # return color.rgb2lab(pic, self.illuminant, self.observer)\n\n            arr = np.asanyarray(pic)\n\n            if arr.ndim not in [3, 4] or arr.shape[-1] != 3:\n                msg = (""the input array must be have a shape == (.., ..,[ ..,] 3)), "" +\n                       ""got ("" + ("", "".join(map(str, arr.shape))) + "")"")\n                raise ValueError(msg)\n\n            return np.dot(arr, self.matrix.T.copy())\n\n            # out_img = np.zeros(pic.shape)\n            #\n            # for row in range(pic.shape[0]):\n            #     for col in range(pic.shape[1]):\n            #         out_img[row, col] = np.dot(self.matrix, pic[row, col])\n            #\n            # return out_img\n        else:\n            raise TypeError(""Tensor [pic] is not numpy array"")\n\n\nclass RandomHorizontalFlip(object):\n    """"""Horizontally flip the given numpy array randomly with a probability of 0.5.""""""\n\n    def __init__(self, prob=0.5):\n        self.prob = prob\n\n    def __call__(self, pic):\n        """"""\n        Args:\n            img (numpy array): Image to be flipped.\n        Returns:\n            numpy array: Randomly flipped image.\n        """"""\n\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n\n        # if image has only 2 channels make it three channel\n        if len(pic.shape) != 3:\n            pic = pic.reshape(pic.shape[0], pic.shape[1], -1)\n\n        if random.random() < self.prob:\n            return pic[:, ::-1, :]\n        return pic\n\n\nclass RandomVerticalFlip(object):\n    """"""Vertically flip the given numpy array randomly with a probability of 0.5 by default.""""""\n\n    def __init__(self, prob=0.5):\n        self.prob = prob\n\n    def __call__(self, pic):\n        """"""\n        Args:\n            img (numpy array): Image to be flipped.\n        Returns:\n            numpy array: Randomly flipped image.\n        """"""\n\n        # check type of [pic]\n        if not _is_numpy_image(pic):\n            raise TypeError(\'img should be numpy array. Got {}\'.format(type(pic)))\n\n        # if image has only 2 channels make it three channel\n        if len(pic.shape) != 3:\n            pic = pic.reshape(pic.shape[0], pic.shape[1], -1)\n\n        if random.random() < self.prob:\n            return pic[::-1, :, :]\n        return pic\n\n\nclass Lambda(transforms.Lambda):\n    pass\n\n\nclass Compose(transforms.Compose):\n    pass\n\n\nclass Normalize(transforms.Normalize):\n    pass\n'"
