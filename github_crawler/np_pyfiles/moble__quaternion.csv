file_path,api_count,code
__init__.py,84,"b'# Copyright (c) 2017, Michael Boyle\n# See LICENSE file for details: <https://github.com/moble/quaternion/blob/master/LICENSE>\n\nfrom __future__ import division, print_function, absolute_import\n\nimport numpy as np\n\nfrom .numpy_quaternion import (quaternion, _eps,\n                               slerp_evaluate, squad_evaluate,\n                               # slerp_vectorized, squad_vectorized,\n                               # slerp, squad,\n                               )\nfrom .quaternion_time_series import slerp, squad, integrate_angular_velocity, minimal_rotation, angular_velocity\nfrom .calculus import (\n    derivative, antiderivative, definite_integral, indefinite_integral,\n    fd_derivative, fd_definite_integral, fd_indefinite_integral,\n    spline_derivative, spline_definite_integral, spline_indefinite_integral)\ntry:\n    from .calculus import spline\nexcept:\n    pass\nfrom .means import mean_rotor_in_chordal_metric, optimal_alignment_in_chordal_metric\nfrom ._version import __version__\n\n__doc_title__ = ""Quaternion dtype for NumPy""\n__doc__ = ""Adds a quaternion dtype to NumPy.""\n\n__all__ = [\'quaternion\',\n           \'as_quat_array\', \'as_spinor_array\',\n           \'as_float_array\', \'from_float_array\',\n           \'as_rotation_matrix\', \'from_rotation_matrix\',\n           \'as_rotation_vector\', \'from_rotation_vector\',\n           \'as_euler_angles\', \'from_euler_angles\',\n           \'as_spherical_coords\', \'from_spherical_coords\',\n           \'rotate_vectors\', \'allclose\',\n           \'rotor_intrinsic_distance\', \'rotor_chordal_distance\',\n           \'rotation_intrinsic_distance\', \'rotation_chordal_distance\',\n           \'slerp_evaluate\', \'squad_evaluate\',\n           \'zero\', \'one\', \'x\', \'y\', \'z\', \'integrate_angular_velocity\',\n           \'squad\', \'slerp\', \'derivative\', \'definite_integral\', \'indefinite_integral\']\n\nif \'quaternion\' in np.__dict__:\n    raise RuntimeError(\'The NumPy package already has a quaternion type\')\n\nnp.quaternion = quaternion\nnp.typeDict[\'quaternion\'] = np.dtype(quaternion)\n\nzero = np.quaternion(0, 0, 0, 0)\none = np.quaternion(1, 0, 0, 0)\nx = np.quaternion(0, 1, 0, 0)\ny = np.quaternion(0, 0, 1, 0)\nz = np.quaternion(0, 0, 0, 1)\n\nrotor_intrinsic_distance = np.rotor_intrinsic_distance\nrotor_chordal_distance = np.rotor_chordal_distance\nrotation_intrinsic_distance = np.rotation_intrinsic_distance\nrotation_chordal_distance = np.rotation_chordal_distance\n\n\ndef as_float_array(a):\n    """"""View the quaternion array as an array of floats\n\n    This function is fast (of order 1 microsecond) because no data is\n    copied; the returned quantity is just a ""view"" of the original.\n\n    The output view has one more dimension (of size 4) than the input\n    array, but is otherwise the same shape.\n\n    """"""\n    return np.asarray(a, dtype=np.quaternion).view((np.double, 4))\n\n\ndef as_quat_array(a):\n    """"""View a float array as an array of quaternions\n\n    The input array must have a final dimension whose size is\n    divisible by four (or better yet *is* 4), because successive\n    indices in that last dimension will be considered successive\n    components of the output quaternion.\n\n    This function is usually fast (of order 1 microsecond) because no\n    data is copied; the returned quantity is just a ""view"" of the\n    original.  However, if the input array is not C-contiguous\n    (basically, as you increment the index into the last dimension of\n    the array, you just move to the neighboring float in memory), the\n    data will need to be copied which may be quite slow.  Therefore,\n    you should try to ensure that the input array is in that order.\n    Slices and transpositions will frequently break that rule.\n\n    We will not convert back from a two-spinor array because there is\n    no unique convention for them, so I don\'t want to mess with that.\n    Also, we want to discourage users from the slow, memory-copying\n    process of swapping columns required for useful definitions of\n    the two-spinors.\n\n    """"""\n    a = np.asarray(a, dtype=np.double)\n\n    # fast path\n    if a.shape == (4,):\n        return quaternion(a[0], a[1], a[2], a[3])\n\n    # view only works if the last axis is C-contiguous\n    if not a.flags[\'C_CONTIGUOUS\'] or a.strides[-1] != a.itemsize:\n        a = a.copy(order=\'C\')\n    try:\n        av = a.view(np.quaternion)\n    except ValueError as e:\n        message = (str(e) + \'\\n            \'\n                   + \'Failed to view input data as a series of quaternions.  \'\n                   + \'Please ensure that the last dimension has size divisible by 4.\\n            \'\n                   + \'Input data has shape {0} and dtype {1}.\'.format(a.shape, a.dtype))\n        raise ValueError(message)\n\n    # special case: don\'t create an axis for a single quaternion, to\n    # match the output of `as_float_array`\n    if av.shape[-1] == 1:\n        av = av.reshape(a.shape[:-1])\n\n    return av\n\n\ndef from_float_array(a):\n    return as_quat_array(a)\n\n\ndef as_spinor_array(a):\n    """"""View a quaternion array as spinors in two-complex representation\n\n    This function is relatively slow and scales poorly, because memory\n    copying is apparently involved -- I think it\'s due to the\n    ""advanced indexing"" required to swap the columns.\n\n    """"""\n    a = np.atleast_1d(a)\n    assert a.dtype == np.dtype(np.quaternion)\n    # I\'m not sure why it has to be so complicated, but all of these steps\n    # appear to be necessary in this case.\n    return a.view(np.float).reshape(a.shape + (4,))[..., [0, 3, 2, 1]].ravel().view(np.complex).reshape(a.shape + (2,))\n\n\ndef as_rotation_matrix(q):\n    """"""Convert input quaternion to 3x3 rotation matrix\n\n    Parameters\n    ----------\n    q: quaternion or array of quaternions\n        The quaternion(s) need not be normalized, but must all be nonzero\n\n    Returns\n    -------\n    rot: float array\n        Output shape is q.shape+(3,3).  This matrix should multiply (from\n        the left) a column vector to produce the rotated column vector.\n\n    Raises\n    ------\n    ZeroDivisionError\n        If any of the input quaternions have norm 0.0.\n\n    """"""\n    if q.shape == () and not isinstance(q, np.ndarray):  # This is just a single quaternion\n        n = q.norm()\n        if n == 0.0:\n            raise ZeroDivisionError(""Input to `as_rotation_matrix({0})` has zero norm"".format(q))\n        elif abs(n-1.0) < _eps:  # Input q is basically normalized\n            return np.array([\n                [1 - 2*(q.y**2 + q.z**2),   2*(q.x*q.y - q.z*q.w),      2*(q.x*q.z + q.y*q.w)],\n                [2*(q.x*q.y + q.z*q.w),     1 - 2*(q.x**2 + q.z**2),    2*(q.y*q.z - q.x*q.w)],\n                [2*(q.x*q.z - q.y*q.w),     2*(q.y*q.z + q.x*q.w),      1 - 2*(q.x**2 + q.y**2)]\n            ])\n        else:  # Input q is not normalized\n            return np.array([\n                [1 - 2*(q.y**2 + q.z**2)/n,   2*(q.x*q.y - q.z*q.w)/n,      2*(q.x*q.z + q.y*q.w)/n],\n                [2*(q.x*q.y + q.z*q.w)/n,     1 - 2*(q.x**2 + q.z**2)/n,    2*(q.y*q.z - q.x*q.w)/n],\n                [2*(q.x*q.z - q.y*q.w)/n,     2*(q.y*q.z + q.x*q.w)/n,      1 - 2*(q.x**2 + q.y**2)/n]\n            ])\n    else:  # This is an array of quaternions\n        n = np.norm(q)\n        if np.any(n == 0.0):\n            raise ZeroDivisionError(""Array input to `as_rotation_matrix` has at least one element with zero norm"")\n        else:  # Assume input q is not normalized\n            m = np.empty(q.shape + (3, 3))\n            q = as_float_array(q)\n            m[..., 0, 0] = 1.0 - 2*(q[..., 2]**2 + q[..., 3]**2)/n\n            m[..., 0, 1] = 2*(q[..., 1]*q[..., 2] - q[..., 3]*q[..., 0])/n\n            m[..., 0, 2] = 2*(q[..., 1]*q[..., 3] + q[..., 2]*q[..., 0])/n\n            m[..., 1, 0] = 2*(q[..., 1]*q[..., 2] + q[..., 3]*q[..., 0])/n\n            m[..., 1, 1] = 1.0 - 2*(q[..., 1]**2 + q[..., 3]**2)/n\n            m[..., 1, 2] = 2*(q[..., 2]*q[..., 3] - q[..., 1]*q[..., 0])/n\n            m[..., 2, 0] = 2*(q[..., 1]*q[..., 3] - q[..., 2]*q[..., 0])/n\n            m[..., 2, 1] = 2*(q[..., 2]*q[..., 3] + q[..., 1]*q[..., 0])/n\n            m[..., 2, 2] = 1.0 - 2*(q[..., 1]**2 + q[..., 2]**2)/n\n            return m\n\n\ndef from_rotation_matrix(rot, nonorthogonal=True):\n    """"""Convert input 3x3 rotation matrix to unit quaternion\n\n    By default, if scipy.linalg is available, this function uses\n    Bar-Itzhack\'s algorithm to allow for non-orthogonal matrices.\n    [J. Guidance, Vol. 23, No. 6, p. 1085 <http://dx.doi.org/10.2514/2.4654>]\n    This will almost certainly be quite a bit slower than simpler versions,\n    though it will be more robust to numerical errors in the rotation matrix.\n    Also note that Bar-Itzhack uses some pretty weird conventions.  The last\n    component of the quaternion appears to represent the scalar, and the\n    quaternion itself is conjugated relative to the convention used\n    throughout this module.\n\n    If scipy.linalg is not available or if the optional\n    `nonorthogonal` parameter is set to `False`, this function falls\n    back to the possibly faster, but less robust, algorithm of Markley\n    [J. Guidance, Vol. 31, No. 2, p. 440\n    <http://dx.doi.org/10.2514/1.31730>].\n\n    Parameters\n    ----------\n    rot: (...Nx3x3) float array\n        Each 3x3 matrix represents a rotation by multiplying (from the left)\n        a column vector to produce a rotated column vector.  Note that this\n        input may actually have ndims>3; it is just assumed that the last\n        two dimensions have size 3, representing the matrix.\n    nonorthogonal: bool, optional\n        If scipy.linalg is available, use the more robust algorithm of\n        Bar-Itzhack.  Default value is True.\n\n    Returns\n    -------\n    q: array of quaternions\n        Unit quaternions resulting in rotations corresponding to input\n        rotations.  Output shape is rot.shape[:-2].\n\n    Raises\n    ------\n    LinAlgError\n        If any of the eigenvalue solutions does not converge\n\n    """"""\n    try:\n        from scipy import linalg\n    except ImportError:\n        linalg = False\n\n    rot = np.array(rot, copy=False)\n    shape = rot.shape[:-2]\n\n    if linalg and nonorthogonal:\n        from operator import mul\n        from functools import reduce\n\n        K3 = np.empty(shape+(4, 4))\n        K3[..., 0, 0] = (rot[..., 0, 0] - rot[..., 1, 1] - rot[..., 2, 2])/3.0\n        K3[..., 0, 1] = (rot[..., 1, 0] + rot[..., 0, 1])/3.0\n        K3[..., 0, 2] = (rot[..., 2, 0] + rot[..., 0, 2])/3.0\n        K3[..., 0, 3] = (rot[..., 1, 2] - rot[..., 2, 1])/3.0\n        K3[..., 1, 0] = K3[..., 0, 1]\n        K3[..., 1, 1] = (rot[..., 1, 1] - rot[..., 0, 0] - rot[..., 2, 2])/3.0\n        K3[..., 1, 2] = (rot[..., 2, 1] + rot[..., 1, 2])/3.0\n        K3[..., 1, 3] = (rot[..., 2, 0] - rot[..., 0, 2])/3.0\n        K3[..., 2, 0] = K3[..., 0, 2]\n        K3[..., 2, 1] = K3[..., 1, 2]\n        K3[..., 2, 2] = (rot[..., 2, 2] - rot[..., 0, 0] - rot[..., 1, 1])/3.0\n        K3[..., 2, 3] = (rot[..., 0, 1] - rot[..., 1, 0])/3.0\n        K3[..., 3, 0] = K3[..., 0, 3]\n        K3[..., 3, 1] = K3[..., 1, 3]\n        K3[..., 3, 2] = K3[..., 2, 3]\n        K3[..., 3, 3] = (rot[..., 0, 0] + rot[..., 1, 1] + rot[..., 2, 2])/3.0\n\n        if not shape:\n            q = zero.copy()\n            eigvals, eigvecs = linalg.eigh(K3.T, eigvals=(3, 3))\n            q.components[0] = eigvecs[-1]\n            q.components[1:] = -eigvecs[:-1].flatten()\n            return q\n        else:\n            q = np.empty(shape+(4,), dtype=np.float)\n            for flat_index in range(reduce(mul, shape)):\n                multi_index = np.unravel_index(flat_index, shape)\n                eigvals, eigvecs = linalg.eigh(K3[multi_index], eigvals=(3, 3))\n                q[multi_index+(0,)] = eigvecs[-1]\n                q[multi_index+(slice(1,None),)] = -eigvecs[:-1].flatten()\n            return as_quat_array(q)\n\n    else:  # No scipy.linalg or not `nonorthogonal`\n        diagonals = np.empty(shape+(4,))\n        diagonals[..., 0] = rot[..., 0, 0]\n        diagonals[..., 1] = rot[..., 1, 1]\n        diagonals[..., 2] = rot[..., 2, 2]\n        diagonals[..., 3] = rot[..., 0, 0] + rot[..., 1, 1] + rot[..., 2, 2]\n\n        indices = np.argmax(diagonals, axis=-1)\n\n        q = diagonals  # reuse storage space\n        indices_i = (indices == 0)\n        if np.any(indices_i):\n            if indices_i.shape == ():\n                indices_i = Ellipsis\n            rot_i = rot[indices_i, :, :]\n            q[indices_i, 0] = rot_i[..., 2, 1] - rot_i[..., 1, 2]\n            q[indices_i, 1] = 1 + rot_i[..., 0, 0] - rot_i[..., 1, 1] - rot_i[..., 2, 2]\n            q[indices_i, 2] = rot_i[..., 0, 1] + rot_i[..., 1, 0]\n            q[indices_i, 3] = rot_i[..., 0, 2] + rot_i[..., 2, 0]\n        indices_i = (indices == 1)\n        if np.any(indices_i):\n            if indices_i.shape == ():\n                indices_i = Ellipsis\n            rot_i = rot[indices_i, :, :]\n            q[indices_i, 0] = rot_i[..., 0, 2] - rot_i[..., 2, 0]\n            q[indices_i, 1] = rot_i[..., 1, 0] + rot_i[..., 0, 1]\n            q[indices_i, 2] = 1 - rot_i[..., 0, 0] + rot_i[..., 1, 1] - rot_i[..., 2, 2]\n            q[indices_i, 3] = rot_i[..., 1, 2] + rot_i[..., 2, 1]\n        indices_i = (indices == 2)\n        if np.any(indices_i):\n            if indices_i.shape == ():\n                indices_i = Ellipsis\n            rot_i = rot[indices_i, :, :]\n            q[indices_i, 0] = rot_i[..., 1, 0] - rot_i[..., 0, 1]\n            q[indices_i, 1] = rot_i[..., 2, 0] + rot_i[..., 0, 2]\n            q[indices_i, 2] = rot_i[..., 2, 1] + rot_i[..., 1, 2]\n            q[indices_i, 3] = 1 - rot_i[..., 0, 0] - rot_i[..., 1, 1] + rot_i[..., 2, 2]\n        indices_i = (indices == 3)\n        if np.any(indices_i):\n            if indices_i.shape == ():\n                indices_i = Ellipsis\n            rot_i = rot[indices_i, :, :]\n            q[indices_i, 0] = 1 + rot_i[..., 0, 0] + rot_i[..., 1, 1] + rot_i[..., 2, 2]\n            q[indices_i, 1] = rot_i[..., 2, 1] - rot_i[..., 1, 2]\n            q[indices_i, 2] = rot_i[..., 0, 2] - rot_i[..., 2, 0]\n            q[indices_i, 3] = rot_i[..., 1, 0] - rot_i[..., 0, 1]\n\n        q /= np.linalg.norm(q, axis=-1)[..., np.newaxis]\n\n        return as_quat_array(q)\n\n\ndef as_rotation_vector(q):\n    """"""Convert input quaternion to the axis-angle representation\n\n    Note that if any of the input quaternions has norm zero, no error is\n    raised, but NaNs will appear in the output.\n\n    Parameters\n    ----------\n    q: quaternion or array of quaternions\n        The quaternion(s) need not be normalized, but must all be nonzero\n\n    Returns\n    -------\n    rot: float array\n        Output shape is q.shape+(3,).  Each vector represents the axis of\n        the rotation, with norm proportional to the angle of the rotation in\n        radians.\n\n    """"""\n    return as_float_array(2*np.log(np.normalized(q)))[..., 1:]\n\n\ndef from_rotation_vector(rot):\n    """"""Convert input 3-vector in axis-angle representation to unit quaternion\n\n    Parameters\n    ----------\n    rot: (Nx3) float array\n        Each vector represents the axis of the rotation, with norm\n        proportional to the angle of the rotation in radians.\n\n    Returns\n    -------\n    q: array of quaternions\n        Unit quaternions resulting in rotations corresponding to input\n        rotations.  Output shape is rot.shape[:-1].\n\n    """"""\n    rot = np.array(rot, copy=False)\n    quats = np.zeros(rot.shape[:-1]+(4,))\n    quats[..., 1:] = rot[...]/2\n    quats = as_quat_array(quats)\n    return np.exp(quats)\n\n\ndef as_euler_angles(q):\n    """"""Open Pandora\'s Box\n\n    If somebody is trying to make you use Euler angles, tell them no, and\n    walk away, and go and tell your mum.\n\n    You don\'t want to use Euler angles.  They are awful.  Stay away.  It\'s\n    one thing to convert from Euler angles to quaternions; at least you\'re\n    moving in the right direction.  But to go the other way?!  It\'s just not\n    right.\n\n    Assumes the Euler angles correspond to the quaternion R via\n\n        R = exp(alpha*z/2) * exp(beta*y/2) * exp(gamma*z/2)\n\n    The angles are naturally in radians.\n\n    NOTE: Before opening an issue reporting something ""wrong"" with this\n    function, be sure to read all of the following page, *especially* the\n    very last section about opening issues or pull requests.\n    <https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible>\n\n    Parameters\n    ----------\n    q: quaternion or array of quaternions\n        The quaternion(s) need not be normalized, but must all be nonzero\n\n    Returns\n    -------\n    alpha_beta_gamma: float array\n        Output shape is q.shape+(3,).  These represent the angles (alpha,\n        beta, gamma) in radians, where the normalized input quaternion\n        represents `exp(alpha*z/2) * exp(beta*y/2) * exp(gamma*z/2)`.\n\n    Raises\n    ------\n    AllHell\n        ...if you try to actually use Euler angles, when you could have\n        been using quaternions like a sensible person.\n\n    """"""\n    alpha_beta_gamma = np.empty(q.shape + (3,), dtype=np.float)\n    n = np.norm(q)\n    q = as_float_array(q)\n    alpha_beta_gamma[..., 0] = np.arctan2(q[..., 3], q[..., 0]) + np.arctan2(-q[..., 1], q[..., 2])\n    alpha_beta_gamma[..., 1] = 2*np.arccos(np.sqrt((q[..., 0]**2 + q[..., 3]**2)/n))\n    alpha_beta_gamma[..., 2] = np.arctan2(q[..., 3], q[..., 0]) - np.arctan2(-q[..., 1], q[..., 2])\n    return alpha_beta_gamma\n\n\ndef from_euler_angles(alpha_beta_gamma, beta=None, gamma=None):\n    """"""Improve your life drastically\n\n    Assumes the Euler angles correspond to the quaternion R via\n\n        R = exp(alpha*z/2) * exp(beta*y/2) * exp(gamma*z/2)\n\n    The angles naturally must be in radians for this to make any sense.\n\n    NOTE: Before opening an issue reporting something ""wrong"" with this\n    function, be sure to read all of the following page, *especially* the\n    very last section about opening issues or pull requests.\n    <https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible>\n\n    Parameters\n    ----------\n    alpha_beta_gamma: float or array of floats\n        This argument may either contain an array with last dimension of\n        size 3, where those three elements describe the (alpha, beta, gamma)\n        radian values for each rotation; or it may contain just the alpha\n        values, in which case the next two arguments must also be given.\n    beta: None, float, or array of floats\n        If this array is given, it must be able to broadcast against the\n        first and third arguments.\n    gamma: None, float, or array of floats\n        If this array is given, it must be able to broadcast against the\n        first and second arguments.\n\n    Returns\n    -------\n    R: quaternion array\n        The shape of this array will be the same as the input, except that\n        the last dimension will be removed.\n\n    """"""\n    # Figure out the input angles from either type of input\n    if gamma is None:\n        alpha_beta_gamma = np.asarray(alpha_beta_gamma, dtype=np.double)\n        alpha = alpha_beta_gamma[..., 0]\n        beta  = alpha_beta_gamma[..., 1]\n        gamma = alpha_beta_gamma[..., 2]\n    else:\n        alpha = np.asarray(alpha_beta_gamma, dtype=np.double)\n        beta  = np.asarray(beta, dtype=np.double)\n        gamma = np.asarray(gamma, dtype=np.double)\n\n    # Set up the output array\n    R = np.empty(np.broadcast(alpha, beta, gamma).shape + (4,), dtype=np.double)\n\n    # Compute the actual values of the quaternion components\n    R[..., 0] =  np.cos(beta/2)*np.cos((alpha+gamma)/2)  # scalar quaternion components\n    R[..., 1] = -np.sin(beta/2)*np.sin((alpha-gamma)/2)  # x quaternion components\n    R[..., 2] =  np.sin(beta/2)*np.cos((alpha-gamma)/2)  # y quaternion components\n    R[..., 3] =  np.cos(beta/2)*np.sin((alpha+gamma)/2)  # z quaternion components\n\n    return as_quat_array(R)\n\n\ndef as_spherical_coords(q):\n    """"""Return the spherical coordinates corresponding to this quaternion\n\n    Obviously, spherical coordinates do not contain as much information as a\n    quaternion, so this function does lose some information.  However, the\n    returned spherical coordinates will represent the point(s) on the sphere\n    to which the input quaternion(s) rotate the z axis.\n\n    Parameters\n    ----------\n    q: quaternion or array of quaternions\n        The quaternion(s) need not be normalized, but must be nonzero\n\n    Returns\n    -------\n    vartheta_varphi: float array\n        Output shape is q.shape+(2,).  These represent the angles (vartheta,\n        varphi) in radians, where the normalized input quaternion represents\n        `exp(varphi*z/2) * exp(vartheta*y/2)`, up to an arbitrary inital\n        rotation about `z`.\n\n    """"""\n    return as_euler_angles(q)[..., 1::-1]\n\n\ndef from_spherical_coords(theta_phi, phi=None):\n    """"""Return the quaternion corresponding to these spherical coordinates\n\n    Assumes the spherical coordinates correspond to the quaternion R via\n\n        R = exp(phi*z/2) * exp(theta*y/2)\n\n    The angles naturally must be in radians for this to make any sense.\n\n    Note that this quaternion rotates `z` onto the point with the given\n    spherical coordinates, but also rotates `x` and `y` onto the usual basis\n    vectors (theta and phi, respectively) at that point.\n\n    Parameters\n    ----------\n    theta_phi: float or array of floats\n        This argument may either contain an array with last dimension of\n        size 2, where those two elements describe the (theta, phi) values in\n        radians for each point; or it may contain just the theta values in\n        radians, in which case the next argument must also be given.\n    phi: None, float, or array of floats\n        If this array is given, it must be able to broadcast against the\n        first argument.\n\n    Returns\n    -------\n    R: quaternion array\n        If the second argument is not given to this function, the shape\n        will be the same as the input shape except for the last dimension,\n        which will be removed.  If the second argument is given, this\n        output array will have the shape resulting from broadcasting the\n        two input arrays against each other.\n\n    """"""\n    # Figure out the input angles from either type of input\n    if phi is None:\n        theta_phi = np.asarray(theta_phi, dtype=np.double)\n        theta = theta_phi[..., 0]\n        phi  = theta_phi[..., 1]\n    else:\n        theta = np.asarray(theta_phi, dtype=np.double)\n        phi = np.asarray(phi, dtype=np.double)\n\n    # Set up the output array\n    R = np.empty(np.broadcast(theta, phi).shape + (4,), dtype=np.double)\n\n    # Compute the actual values of the quaternion components\n    R[..., 0] =  np.cos(phi/2)*np.cos(theta/2)  # scalar quaternion components\n    R[..., 1] = -np.sin(phi/2)*np.sin(theta/2)  # x quaternion components\n    R[..., 2] =  np.cos(phi/2)*np.sin(theta/2)  # y quaternion components\n    R[..., 3] =  np.sin(phi/2)*np.cos(theta/2)  # z quaternion components\n\n    return as_quat_array(R)\n\n\ndef rotate_vectors(R, v, axis=-1):\n    """"""Rotate vectors by given quaternions\n\n    For simplicity, this function simply converts the input\n    quaternion(s) to a matrix, and rotates the input vector(s) by the\n    usual matrix multiplication.  However, it should be noted that if\n    each input quaternion is only used to rotate a single vector, it\n    is more efficient (in terms of operation counts) to use the\n    formula\n\n      v\' = v + 2 * r x (s * v + r x v) / m\n\n    where x represents the cross product, s and r are the scalar and\n    vector parts of the quaternion, respectively, and m is the sum of\n    the squares of the components of the quaternion.  If you are\n    looping over a very large number of quaternions, and just rotating\n    a single vector each time, you might want to implement that\n    alternative algorithm using numba (or something that doesn\'t use\n    python).\n\n\n    Parameters\n    ==========\n    R: quaternion array\n        Quaternions by which to rotate the input vectors\n    v: float array\n        Three-vectors to be rotated.\n    axis: int\n        Axis of the `v` array to use as the vector dimension.  This\n        axis of `v` must have length 3.\n\n    Returns\n    =======\n    vprime: float array\n        The rotated vectors.  This array has shape R.shape+v.shape.\n\n    """"""\n    R = np.asarray(R, dtype=np.quaternion)\n    v = np.asarray(v, dtype=float)\n    if v.ndim < 1 or 3 not in v.shape:\n        raise ValueError(""Input `v` does not have at least one dimension of length 3"")\n    if v.shape[axis] != 3:\n        raise ValueError(""Input `v` axis {0} has length {1}, not 3."".format(axis, v.shape[axis]))\n    m = as_rotation_matrix(R)\n    m_axes = list(range(m.ndim))\n    v_axes = list(range(m.ndim, m.ndim+v.ndim))\n    mv_axes = list(v_axes)\n    mv_axes[axis] = m_axes[-2]\n    mv_axes = m_axes[:-2] + mv_axes\n    v_axes[axis] = m_axes[-1]\n    return np.einsum(m, m_axes, v, v_axes, mv_axes)\n\n\ndef isclose(a, b, rtol=4*np.finfo(float).eps, atol=0.0, equal_nan=False):\n    """"""\n    Returns a boolean array where two arrays are element-wise equal within a\n    tolerance.\n\n    This function is essentially a copy of the `numpy.isclose` function,\n    with different default tolerances and one minor changes necessary to\n    deal correctly with quaternions.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN\'s as equal.  If True, NaN\'s in `a` will be\n        considered equal to NaN\'s in `b` in the output array.\n\n    Returns\n    -------\n    y : array_like\n        Returns a boolean array of where `a` and `b` are equal within the\n        given tolerance. If both `a` and `b` are scalars, returns a single\n        boolean value.\n\n    See Also\n    --------\n    allclose\n\n    Notes\n    -----\n    For finite values, isclose uses the following equation to test whether\n    two floating point values are equivalent:\n\n      absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    `isclose(a, b)` might be different from `isclose(b, a)` in\n    some rare cases.\n\n    Examples\n    --------\n    >>> quaternion.isclose([1e10*quaternion.x, 1e-7*quaternion.y], [1.00001e10*quaternion.x, 1e-8*quaternion.y],\n    ...     rtol=1.e-5, atol=1.e-8)\n    array([True, False])\n    >>> quaternion.isclose([1e10*quaternion.x, 1e-8*quaternion.y], [1.00001e10*quaternion.x, 1e-9*quaternion.y],\n    ...     rtol=1.e-5, atol=1.e-8)\n    array([True, True])\n    >>> quaternion.isclose([1e10*quaternion.x, 1e-8*quaternion.y], [1.0001e10*quaternion.x, 1e-9*quaternion.y],\n    ...     rtol=1.e-5, atol=1.e-8)\n    array([False, True])\n    >>> quaternion.isclose([quaternion.x, np.nan*quaternion.y], [quaternion.x, np.nan*quaternion.y])\n    array([True, False])\n    >>> quaternion.isclose([quaternion.x, np.nan*quaternion.y], [quaternion.x, np.nan*quaternion.y], equal_nan=True)\n    array([True, True])\n    """"""\n    def within_tol(x, y, atol, rtol):\n        with np.errstate(invalid=\'ignore\'):\n            result = np.less_equal(abs(x-y), atol + rtol * abs(y))\n        return result[()]\n\n    x = np.array(a, copy=False, subok=True, ndmin=1)\n    y = np.array(b, copy=False, subok=True, ndmin=1)\n\n    # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).\n    # This will cause casting of x later. Also, make sure to allow subclasses\n    # (e.g., for numpy.ma).\n    try:\n        dt = np.result_type(y, 1.)\n    except TypeError:\n        dt = np.dtype(np.quaternion)\n    y = np.array(y, dtype=dt, copy=False, subok=True)\n\n    xfin = np.isfinite(x)\n    yfin = np.isfinite(y)\n    if np.all(xfin) and np.all(yfin):\n        return within_tol(x, y, atol, rtol)\n    else:\n        finite = xfin & yfin\n        cond = np.zeros_like(finite, subok=True)\n        # Because we\'re using boolean indexing, x & y must be the same shape.\n        # Ideally, we\'d just do x, y = broadcast_arrays(x, y). It\'s in\n        # lib.stride_tricks, though, so we can\'t import it here.\n        x = x * np.ones_like(cond)\n        y = y * np.ones_like(cond)\n        # Avoid subtraction with infinite/nan values...\n        cond[finite] = within_tol(x[finite], y[finite], atol, rtol)\n        # Check for equality of infinite values...\n        cond[~finite] = (x[~finite] == y[~finite])\n        if equal_nan:\n            # Make NaN == NaN\n            both_nan = np.isnan(x) & np.isnan(y)\n            cond[both_nan] = both_nan[both_nan]\n\n        return cond[()]\n\n\ndef allclose(a, b, rtol=4*np.finfo(float).eps, atol=0.0, equal_nan=False, verbose=False):\n    """"""Returns True if two arrays are element-wise equal within a tolerance.\n\n    This function is essentially a wrapper for the `quaternion.isclose`\n    function, but returns a single boolean value of True if all elements\n    of the output from `quaternion.isclose` are True, and False otherwise.\n    This function also adds the option.\n\n    Note that this function has stricter tolerances than the\n    `numpy.allclose` function, as well as the additional `verbose` option.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN\'s as equal.  If True, NaN\'s in `a` will be\n        considered equal to NaN\'s in `b` in the output array.\n    verbose : bool\n        If the return value is False, all the non-close values are printed,\n        iterating through the non-close indices in order, displaying the\n        array values along with the index, with a separate line for each\n        pair of values.\n\n    See Also\n    --------\n    isclose, numpy.all, numpy.any, numpy.allclose\n\n    Returns\n    -------\n    allclose : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise.\n\n\n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.\n\n      absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    `allclose(a, b)` might be different from `allclose(b, a)` in\n    some rare cases.\n\n    """"""\n    close = isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan)\n    result = np.all(close)\n    if verbose and not result:\n        print(\'Non-close values:\')\n        for i in np.argwhere(close == False):\n            i = tuple(i)\n            print(\'\\n    a[{0}]={1}\\n    b[{0}]={2}\'.format(i, a[i], b[i]))\n    return result\n'"
calculus.py,17,"b'# Copyright (c) 2019, Michael Boyle\n# See LICENSE file for details: <https://github.com/moble/quaternion/blob/master/LICENSE>\n\nfrom __future__ import division, print_function, absolute_import\nimport numpy as np\nfrom quaternion.numba_wrapper import njit, jit, xrange\n\n\ndef fd_derivative(f, t):\n    """"""Fourth-order finite-differencing with non-uniform time steps\n\n    The formula for this finite difference comes from Eq. (A 5b) of ""Derivative formulas and errors for non-uniformly\n    spaced points"" by M. K. Bowen and Ronald Smith.  As explained in their Eqs. (B 9b) and (B 10b), this is a\n    fourth-order formula -- though that\'s a squishy concept with non-uniform time steps.\n\n    TODO: If there are fewer than five points, the function should revert to simpler (lower-order) formulas.\n\n    """"""\n    dfdt = np.empty_like(f)\n    if (f.ndim == 1):\n        _derivative(f, t, dfdt)\n    elif (f.ndim == 2):\n        _derivative_2d(f, t, dfdt)\n    elif (f.ndim == 3):\n        _derivative_3d(f, t, dfdt)\n    else:\n        raise NotImplementedError(""Taking derivatives of {0}-dimensional arrays is not yet implemented"".format(f.ndim))\n    return dfdt\n\n\n@njit\ndef _derivative(f, t, dfdt):\n    for i in xrange(2):\n        t_i = t[i]\n        t1 = t[0]\n        t2 = t[1]\n        t3 = t[2]\n        t4 = t[3]\n        t5 = t[4]\n        h1 = t1 - t_i\n        h2 = t2 - t_i\n        h3 = t3 - t_i\n        h4 = t4 - t_i\n        h5 = t5 - t_i\n        h12 = t1 - t2\n        h13 = t1 - t3\n        h14 = t1 - t4\n        h15 = t1 - t5\n        h23 = t2 - t3\n        h24 = t2 - t4\n        h25 = t2 - t5\n        h34 = t3 - t4\n        h35 = t3 - t5\n        h45 = t4 - t5\n        dfdt[i] = (-((h2 * h3 * h4 + h2 * h3 * h5 + h2 * h4 * h5 + h3 * h4 * h5) / (h12 * h13 * h14 * h15)) * f[0]\n                   + ((h1 * h3 * h4 + h1 * h3 * h5 + h1 * h4 * h5 + h3 * h4 * h5) / (h12 * h23 * h24 * h25)) * f[1]\n                   - ((h1 * h2 * h4 + h1 * h2 * h5 + h1 * h4 * h5 + h2 * h4 * h5) / (h13 * h23 * h34 * h35)) * f[2]\n                   + ((h1 * h2 * h3 + h1 * h2 * h5 + h1 * h3 * h5 + h2 * h3 * h5) / (h14 * h24 * h34 * h45)) * f[3]\n                   - ((h1 * h2 * h3 + h1 * h2 * h4 + h1 * h3 * h4 + h2 * h3 * h4) / (h15 * h25 * h35 * h45)) * f[4])\n\n    for i in xrange(2, len(t) - 2):\n        t1 = t[i - 2]\n        t2 = t[i - 1]\n        t3 = t[i]\n        t4 = t[i + 1]\n        t5 = t[i + 2]\n        h1 = t1 - t3\n        h2 = t2 - t3\n        h4 = t4 - t3\n        h5 = t5 - t3\n        h12 = t1 - t2\n        h13 = t1 - t3\n        h14 = t1 - t4\n        h15 = t1 - t5\n        h23 = t2 - t3\n        h24 = t2 - t4\n        h25 = t2 - t5\n        h34 = t3 - t4\n        h35 = t3 - t5\n        h45 = t4 - t5\n        dfdt[i] = (-((h2 * h4 * h5) / (h12 * h13 * h14 * h15)) * f[i - 2]\n                   + ((h1 * h4 * h5) / (h12 * h23 * h24 * h25)) * f[i - 1]\n                   - ((h1 * h2 * h4 + h1 * h2 * h5 + h1 * h4 * h5 + h2 * h4 * h5) / (h13 * h23 * h34 * h35)) * f[i]\n                   + ((h1 * h2 * h5) / (h14 * h24 * h34 * h45)) * f[i + 1]\n                   - ((h1 * h2 * h4) / (h15 * h25 * h35 * h45)) * f[i + 2])\n\n    for i in xrange(len(t) - 2, len(t)):\n        t_i = t[i]\n        t1 = t[-5]\n        t2 = t[-4]\n        t3 = t[-3]\n        t4 = t[-2]\n        t5 = t[-1]\n        h1 = t1 - t_i\n        h2 = t2 - t_i\n        h3 = t3 - t_i\n        h4 = t4 - t_i\n        h5 = t5 - t_i\n        h12 = t1 - t2\n        h13 = t1 - t3\n        h14 = t1 - t4\n        h15 = t1 - t5\n        h23 = t2 - t3\n        h24 = t2 - t4\n        h25 = t2 - t5\n        h34 = t3 - t4\n        h35 = t3 - t5\n        h45 = t4 - t5\n        dfdt[i] = (-((h2 * h3 * h4 + h2 * h3 * h5 + h2 * h4 * h5 + h3 * h4 * h5) / (h12 * h13 * h14 * h15)) * f[-5]\n                   + ((h1 * h3 * h4 + h1 * h3 * h5 + h1 * h4 * h5 + h3 * h4 * h5) / (h12 * h23 * h24 * h25)) * f[-4]\n                   - ((h1 * h2 * h4 + h1 * h2 * h5 + h1 * h4 * h5 + h2 * h4 * h5) / (h13 * h23 * h34 * h35)) * f[-3]\n                   + ((h1 * h2 * h3 + h1 * h2 * h5 + h1 * h3 * h5 + h2 * h3 * h5) / (h14 * h24 * h34 * h45)) * f[-2]\n                   - ((h1 * h2 * h3 + h1 * h2 * h4 + h1 * h3 * h4 + h2 * h3 * h4) / (h15 * h25 * h35 * h45)) * f[-1])\n\n    return\n\n\n@njit\ndef _derivative_2d(f, t, dfdt):\n    for i in xrange(2):\n        t_i = t[i]\n        t1 = t[0]\n        t2 = t[1]\n        t3 = t[2]\n        t4 = t[3]\n        t5 = t[4]\n        h1 = t1 - t_i\n        h2 = t2 - t_i\n        h3 = t3 - t_i\n        h4 = t4 - t_i\n        h5 = t5 - t_i\n        h12 = t1 - t2\n        h13 = t1 - t3\n        h14 = t1 - t4\n        h15 = t1 - t5\n        h23 = t2 - t3\n        h24 = t2 - t4\n        h25 = t2 - t5\n        h34 = t3 - t4\n        h35 = t3 - t5\n        h45 = t4 - t5\n        for k in xrange(f.shape[1]):\n            dfdt[i, k] = (\n            -((h2 * h3 * h4 + h2 * h3 * h5 + h2 * h4 * h5 + h3 * h4 * h5) / (h12 * h13 * h14 * h15)) * f[0, k]\n            + ((h1 * h3 * h4 + h1 * h3 * h5 + h1 * h4 * h5 + h3 * h4 * h5) / (h12 * h23 * h24 * h25)) * f[1, k]\n            - ((h1 * h2 * h4 + h1 * h2 * h5 + h1 * h4 * h5 + h2 * h4 * h5) / (h13 * h23 * h34 * h35)) * f[2, k]\n            + ((h1 * h2 * h3 + h1 * h2 * h5 + h1 * h3 * h5 + h2 * h3 * h5) / (h14 * h24 * h34 * h45)) * f[3, k]\n            - ((h1 * h2 * h3 + h1 * h2 * h4 + h1 * h3 * h4 + h2 * h3 * h4) / (h15 * h25 * h35 * h45)) * f[4, k])\n\n    for i in xrange(2, len(t) - 2):\n        t1 = t[i - 2]\n        t2 = t[i - 1]\n        t3 = t[i]\n        t4 = t[i + 1]\n        t5 = t[i + 2]\n        h1 = t1 - t3\n        h2 = t2 - t3\n        h4 = t4 - t3\n        h5 = t5 - t3\n        h12 = t1 - t2\n        h13 = t1 - t3\n        h14 = t1 - t4\n        h15 = t1 - t5\n        h23 = t2 - t3\n        h24 = t2 - t4\n        h25 = t2 - t5\n        h34 = t3 - t4\n        h35 = t3 - t5\n        h45 = t4 - t5\n        for k in xrange(f.shape[1]):\n            dfdt[i, k] = (-((h2 * h4 * h5) / (h12 * h13 * h14 * h15)) * f[i - 2, k]\n                          + ((h1 * h4 * h5) / (h12 * h23 * h24 * h25)) * f[i - 1, k]\n                          - ((h1 * h2 * h4 + h1 * h2 * h5 + h1 * h4 * h5 + h2 * h4 * h5) / (h13 * h23 * h34 * h35))\n                            * f[i, k]\n                          + ((h1 * h2 * h5) / (h14 * h24 * h34 * h45)) * f[i + 1, k]\n                          - ((h1 * h2 * h4) / (h15 * h25 * h35 * h45)) * f[i + 2, k])\n\n    for i in xrange(len(t) - 2, len(t)):\n        t_i = t[i]\n        t1 = t[-5]\n        t2 = t[-4]\n        t3 = t[-3]\n        t4 = t[-2]\n        t5 = t[-1]\n        h1 = t1 - t_i\n        h2 = t2 - t_i\n        h3 = t3 - t_i\n        h4 = t4 - t_i\n        h5 = t5 - t_i\n        h12 = t1 - t2\n        h13 = t1 - t3\n        h14 = t1 - t4\n        h15 = t1 - t5\n        h23 = t2 - t3\n        h24 = t2 - t4\n        h25 = t2 - t5\n        h34 = t3 - t4\n        h35 = t3 - t5\n        h45 = t4 - t5\n        for k in xrange(f.shape[1]):\n            dfdt[i, k] = (\n            -((h2 * h3 * h4 + h2 * h3 * h5 + h2 * h4 * h5 + h3 * h4 * h5) / (h12 * h13 * h14 * h15)) * f[-5, k]\n            + ((h1 * h3 * h4 + h1 * h3 * h5 + h1 * h4 * h5 + h3 * h4 * h5) / (h12 * h23 * h24 * h25)) * f[-4, k]\n            - ((h1 * h2 * h4 + h1 * h2 * h5 + h1 * h4 * h5 + h2 * h4 * h5) / (h13 * h23 * h34 * h35)) * f[-3, k]\n            + ((h1 * h2 * h3 + h1 * h2 * h5 + h1 * h3 * h5 + h2 * h3 * h5) / (h14 * h24 * h34 * h45)) * f[-2, k]\n            - ((h1 * h2 * h3 + h1 * h2 * h4 + h1 * h3 * h4 + h2 * h3 * h4) / (h15 * h25 * h35 * h45)) * f[-1, k])\n\n    return\n\n\n@njit\ndef _derivative_3d(f, t, dfdt):\n    for i in xrange(2):\n        t_i = t[i]\n        t1 = t[0]\n        t2 = t[1]\n        t3 = t[2]\n        t4 = t[3]\n        t5 = t[4]\n        h1 = t1 - t_i\n        h2 = t2 - t_i\n        h3 = t3 - t_i\n        h4 = t4 - t_i\n        h5 = t5 - t_i\n        h12 = t1 - t2\n        h13 = t1 - t3\n        h14 = t1 - t4\n        h15 = t1 - t5\n        h23 = t2 - t3\n        h24 = t2 - t4\n        h25 = t2 - t5\n        h34 = t3 - t4\n        h35 = t3 - t5\n        h45 = t4 - t5\n        for k in xrange(f.shape[1]):\n            for m in xrange(f.shape[1]):\n                dfdt[i, k, m] = (\n                -((h2 * h3 * h4 + h2 * h3 * h5 + h2 * h4 * h5 + h3 * h4 * h5) / (h12 * h13 * h14 * h15)) * f[0, k, m]\n                + ((h1 * h3 * h4 + h1 * h3 * h5 + h1 * h4 * h5 + h3 * h4 * h5) / (h12 * h23 * h24 * h25)) * f[1, k, m]\n                - ((h1 * h2 * h4 + h1 * h2 * h5 + h1 * h4 * h5 + h2 * h4 * h5) / (h13 * h23 * h34 * h35)) * f[2, k, m]\n                + ((h1 * h2 * h3 + h1 * h2 * h5 + h1 * h3 * h5 + h2 * h3 * h5) / (h14 * h24 * h34 * h45)) * f[3, k, m]\n                - ((h1 * h2 * h3 + h1 * h2 * h4 + h1 * h3 * h4 + h2 * h3 * h4) / (h15 * h25 * h35 * h45)) * f[4, k, m])\n\n    for i in xrange(2, len(t) - 2):\n        t1 = t[i - 2]\n        t2 = t[i - 1]\n        t3 = t[i]\n        t4 = t[i + 1]\n        t5 = t[i + 2]\n        h1 = t1 - t3\n        h2 = t2 - t3\n        h4 = t4 - t3\n        h5 = t5 - t3\n        h12 = t1 - t2\n        h13 = t1 - t3\n        h14 = t1 - t4\n        h15 = t1 - t5\n        h23 = t2 - t3\n        h24 = t2 - t4\n        h25 = t2 - t5\n        h34 = t3 - t4\n        h35 = t3 - t5\n        h45 = t4 - t5\n        for k in xrange(f.shape[1]):\n            for m in xrange(f.shape[1]):\n                dfdt[i, k, m] = (-((h2 * h4 * h5) / (h12 * h13 * h14 * h15)) * f[i - 2, k, m]\n                              + ((h1 * h4 * h5) / (h12 * h23 * h24 * h25)) * f[i - 1, k, m]\n                              - ((h1 * h2 * h4 + h1 * h2 * h5 + h1 * h4 * h5 + h2 * h4 * h5) / (h13 * h23 * h34 * h35))\n                                 * f[i, k, m]\n                              + ((h1 * h2 * h5) / (h14 * h24 * h34 * h45)) * f[i + 1, k, m]\n                              - ((h1 * h2 * h4) / (h15 * h25 * h35 * h45)) * f[i + 2, k, m])\n\n    for i in xrange(len(t) - 2, len(t)):\n        t_i = t[i]\n        t1 = t[-5]\n        t2 = t[-4]\n        t3 = t[-3]\n        t4 = t[-2]\n        t5 = t[-1]\n        h1 = t1 - t_i\n        h2 = t2 - t_i\n        h3 = t3 - t_i\n        h4 = t4 - t_i\n        h5 = t5 - t_i\n        h12 = t1 - t2\n        h13 = t1 - t3\n        h14 = t1 - t4\n        h15 = t1 - t5\n        h23 = t2 - t3\n        h24 = t2 - t4\n        h25 = t2 - t5\n        h34 = t3 - t4\n        h35 = t3 - t5\n        h45 = t4 - t5\n        for k in xrange(f.shape[1]):\n            for m in xrange(f.shape[1]):\n                dfdt[i, k, m] = (\n                -((h2 * h3 * h4 + h2 * h3 * h5 + h2 * h4 * h5 + h3 * h4 * h5) / (h12 * h13 * h14 * h15)) * f[-5, k, m]\n                + ((h1 * h3 * h4 + h1 * h3 * h5 + h1 * h4 * h5 + h3 * h4 * h5) / (h12 * h23 * h24 * h25)) * f[-4, k, m]\n                - ((h1 * h2 * h4 + h1 * h2 * h5 + h1 * h4 * h5 + h2 * h4 * h5) / (h13 * h23 * h34 * h35)) * f[-3, k, m]\n                + ((h1 * h2 * h3 + h1 * h2 * h5 + h1 * h3 * h5 + h2 * h3 * h5) / (h14 * h24 * h34 * h45)) * f[-2, k, m]\n                - ((h1 * h2 * h3 + h1 * h2 * h4 + h1 * h3 * h4 + h2 * h3 * h4) / (h15 * h25 * h35 * h45)) * f[-1, k, m])\n\n    return\n\n\n@jit\ndef fd_indefinite_integral(f, t):\n    Sfdt = np.empty_like(f)\n    Sfdt[0] = 0.0\n    for i in xrange(1, len(t)):\n        for j in xrange(f.shape[1]):\n            Sfdt[i, j] = Sfdt[i - 1, j] + (f[i, j] + f[i - 1, j]) * ((t[i] - t[i - 1]) / 2.0)\n    return Sfdt\n\n\ndef fd_definite_integral(f, t):\n    Sfdt = np.zeros_like(f)\n    Sfdt[1:, ...] = (f[1:, ...] + f[:-1, ...]) * ((t[1:] - t[:-1]) / 2.0)\n    return np.sum(Sfdt)\n\n\ndef spline_evaluation(f, t, t_out=None, axis=None, spline_degree=3,\n                      derivative_order=0, definite_integral_bounds=None):\n    """"""Approximate input data using a spline and evaluate\n\n    Note that this function is somewhat more general than it needs to be, so that it can be reused\n    for closely related functions involving derivatives, antiderivatives, and integrals.\n\n    Parameters\n    ==========\n    f: (..., N, ...) array_like\n        Real or complex function values to be interpolated.\n\n    t: (N,) array_like\n        An N-D array of increasing real values. The length of f along the interpolation axis must be\n        equal to the length of t.  The number of data points must be larger than the spline degree.\n\n    t_out: None or (M,) array_like [defaults to None]\n        The new values of `t` on which to evaluate the result.  If None, it is assumed that some\n        other feature of the data is needed, like a derivative or antiderivative, which are then\n        output using the same `t` values as the input.\n\n    axis: None or int [defaults to None]\n        The axis of `f` with length equal to the length of `t`.  If None, this function searches for\n        an axis of equal length in reverse order -- that is, starting from the last axis of `f`.\n        Note that this feature is helpful when `f` is one-dimensional or will always satisfy that\n        criterion, but is dangerous otherwise.  Caveat emptor.\n\n    spline_degree: int [defaults to 3]\n        Degree of the interpolating spline. Must be 1 <= spline_degree <= 5.\n\n    derivative_order: int [defaults to 0]\n        The order of the derivative to apply to the data.  Note that this may be negative, in which\n        case the corresponding antiderivative is returned.\n\n    definite_integral_bounds: None or (2,) array_like [defaults to None]\n        If this is not None, the `t_out` and `derivative_order` parameters are ignored, and the\n        returned values are just the (first) definite integrals of the splines between these limits,\n        along each remaining axis.\n\n    """"""\n    import numpy as np\n    from scipy.interpolate import InterpolatedUnivariateSpline\n\n    # Process input arguments and get data into correct shape\n    if not 1 <= spline_degree <= 5:\n        raise ValueError(\'The spline degree must be between 1 and 5 (inclusive); it is {0}.\'.format(spline_degree))\n    t = np.asarray(t, dtype=float, order=\'C\')\n    if t.ndim != 1:\n        raise ValueError(\'Input t values must be a one-dimensional array; this input has {0}.\'.format(t.ndim))\n    n = t.size\n    if spline_degree >= n:\n        raise ValueError(\'The spline degree ({0}) must be less than the number of data points ({1}).\'.format(spline_degree, n))\n    f = np.asanyarray(f)\n    if axis is None:\n        try:\n            axis = f.ndim - 1 - list(reversed(f.shape)).index(n)\n        except ValueError:\n            axis = None\n    if axis is None or f.shape[axis] != n:\n        raise ValueError((\n            ""Input function values `f` [shape {0}] should have at least one ""\n            ""axis with the same length as input `t` [{1}], or bad axis input.""\n            ).format(f.shape, n))\n    shape = list(f.shape)\n    if definite_integral_bounds is not None:\n        shape[axis] = 1  # We\'ll keep this axis for now (set to length 1) for uniform treatment, and remove it before returning\n        definite_integral_bounds = np.array(definite_integral_bounds, dtype=float)\n        if definite_integral_bounds.shape != (2,):\n            raise ValueError(""Expected exactly two bounds for the definite integral; got {0}."".format(definite_integral_bounds.shape))\n        f_out = np.empty(shape, dtype=f.dtype)\n        t_a, t_b = definite_integral_bounds\n        def evaluator(s):\n            return s.integral(t_a, t_b)\n        axis_slice = slice(max(0, np.argmin(np.abs(t-t_a))-10), min(n, np.argmin(np.abs(t-t_b))+11))\n    else:\n        if t_out is None:\n            t_out = t\n            axis_slice = slice(None)\n        else:\n            axis_slice = slice(max(0, np.argmin(np.abs(t-t_out[0]))-10), min(n, np.argmin(np.abs(t-t_out[-1]))+11))\n        shape[axis] = t_out.size\n        if derivative_order != 0 and derivative_order > spline_degree:\n            raise ValueError(""Order of derivative ({0}) must not be greater than degree of spline ({1})"".format(derivative_order, spline_degree))\n        f_out = np.empty(shape, dtype=f.dtype)\n        if derivative_order < 0:\n            def evaluator(s):\n                return s.antiderivative(n=-derivative_order)(t_out)\n        elif derivative_order > 0:\n            def evaluator(s):\n                return s.derivative(n=derivative_order)(t_out)\n        else:\n            def evaluator(s):\n                return s(t_out)\n    def spline(f, t):\n        return InterpolatedUnivariateSpline(t[axis_slice], f[axis_slice], k=spline_degree)\n\n    # Move the axis to the end so that we can just iterate over all but the last index\n    if axis != -1 and axis != n-1:\n        f = np.moveaxis(f, axis, -1)\n        f_out = np.moveaxis(f_out, axis, -1)\n\n    # Iterate over all extra axes and evaluate\n    complex_valued = np.iscomplexobj(f)\n    for index in np.ndindex(f.shape[:-1]):\n        if complex_valued:\n            f_out[index] = evaluator(spline(f[index].real, t)) + 1j * evaluator(spline(f[index].imag, t))\n        else:\n            f_out[index] = evaluator(spline(f[index], t))\n\n    # Undo the axis move we did previously to the output (input doesn\'t matter any more)\n    if axis != -1 and axis != n-1:\n        f_out = np.moveaxis(f_out, -1, axis)\n\n    # If this is a definite integral, remove that extraneous axis\n    if definite_integral_bounds is not None:\n        f_out = np.squeeze(f_out, axis=axis)\n\n    return f_out\n\n\ndef spline_derivative(f, t, derivative_order=1, axis=0):\n    return spline_evaluation(f, t, axis=axis, derivative_order=derivative_order)\n\n\ndef spline_indefinite_integral(f, t, integral_order=1, axis=0):\n    return spline_evaluation(f, t, axis=axis, derivative_order=-integral_order)\n\n\ndef spline_definite_integral(f, t, t1=None, t2=None, axis=0):\n    if t1 is None:\n        t1 = t[0]\n    if t2 is None:\n        t2 = t[-1]\n    return spline_evaluation(f, t, axis=axis, definite_integral_bounds=(t1, t2))\n\n\ntry:\n    from scipy.interpolate import InterpolatedUnivariateSpline\n    spline = spline_evaluation\n    derivative = spline_derivative\n    antiderivative = spline_indefinite_integral\n    indefinite_integral = spline_indefinite_integral\n    definite_integral = spline_definite_integral\nexcept ImportError:\n    import warnings\n    warning_text = (\n        ""\\n\\n"" + ""!"" * 57 + ""\\n"" +\n        ""Could not import from scipy, which means that derivatives\\n"" +\n        ""and integrals will use less accurate finite-differencing\\n"" +\n        ""techniques.  You may want to install scipy."" +\n        ""\\n"" + ""!"" * 57 + ""\\n""\n    )\n    warnings.warn(warning_text)\n    derivative = fd_derivative\n    antiderivative = fd_indefinite_integral\n    indefinite_integral = fd_indefinite_integral\n    definite_integral = fd_definite_integral\n'"
means.py,2,"b'# Copyright (c) 2017, Michael Boyle\n# See LICENSE file for details: <https://github.com/moble/quaternion/blob/master/LICENSE>\n\nfrom __future__ import division, print_function, absolute_import\n\n\n\ndef mean_rotor_in_chordal_metric(R, t=None):\n    """"""Return rotor that is closest to all R in the least-squares sense\n\n    This can be done (quasi-)analytically because of the simplicity of\n    the chordal metric function.  It is assumed that the input R values\n    all are normalized (or at least have the same norm).\n\n    Note that the `t` argument is optional.  If it is present, the\n    times are used to weight the corresponding integral.  If it is not\n    present, a simple sum is used instead (which may be slightly\n    faster).  However, because a spline is used to do this integral,\n    the number of input points must be at least 4 (one more than the\n    degree of the spline).\n\n    """"""\n    import numpy as np\n    from . import as_float_array\n    from .calculus import definite_integral\n    if t is None:\n        return np.sum(R).normalized()\n    if len(t) < 4 or len(R) < 4:\n        raise ValueError(\'Input arguments must have length greater than 3; their lengths are {0} and {1}.\'.format(len(R), len(t)))\n    mean = definite_integral(as_float_array(R), t)\n    return np.quaternion(*mean).normalized()\n\n\ndef optimal_alignment_in_chordal_metric(Ra, Rb, t=None):\n    """"""Return Rd such that Rd*Rb is as close to Ra as possible\n\n    This function simply encapsulates the mean rotor of Ra/Rb.\n\n    As in the `mean_rotor_in_chordal_metric` function, the `t`\n    argument is optional.  If it is present, the times are used to\n    weight the corresponding integral.  If it is not present, a simple\n    sum is used instead (which may be slightly faster).\n\n    """"""\n    return mean_rotor_in_chordal_metric(Ra / Rb, t)\n\n\ndef mean_rotor_in_intrinsic_metric(R, t=None):\n    raise NotImplementedError()\n'"
numba_wrapper.py,0,"b'# Copyright (c) 2017, Michael Boyle\n# See LICENSE file for details: <https://github.com/moble/quaternion/blob/master/LICENSE>\n\nfrom __future__ import division, print_function, absolute_import\nimport sys\n\nIS_PY3 = (sys.version_info[:2] >= (3, 0))\n\n## Allow the code to function without numba, but discourage it\ntry:\n    from numba import njit, jit, vectorize, int64, float64, complex128\n    GOT_NUMBA = True\nexcept ImportError:\n    import warnings\n    warning_text = \\\n        ""\\n\\n"" + ""!"" * 53 + ""\\n"" + \\\n        ""Could not import from numba, which means that some\\n"" + \\\n        ""parts of this code may run MUCH more slowly.  You\\n"" + \\\n        ""may wish to install numba."" + \\\n        ""\\n"" + ""!"" * 53 + ""\\n""\n    warnings.warn(warning_text)\n    def _identity_decorator_outer(*args, **kwargs):\n        def _identity_decorator_inner(fn):\n            return fn\n        return _identity_decorator_inner\n    njit = _identity_decorator_outer\n    jit = _identity_decorator_outer\n    vectorize = _identity_decorator_outer\n    int64 = int\n    float64 = float\n    complex128 = complex\n    GOT_NUMBA = False\n\nif IS_PY3:\n    xrange = range\nelse:\n    xrange = xrange\n'"
quaternion_time_series.py,46,"b'# Copyright (c) 2017, Michael Boyle\n# See LICENSE file for details: <https://github.com/moble/quaternion/blob/master/LICENSE>\n\nfrom __future__ import print_function, division, absolute_import\n\nimport numpy as np\nimport quaternion\nfrom quaternion.numba_wrapper import njit\n\n\ndef slerp(R1, R2, t1, t2, t_out):\n    """"""Spherical linear interpolation of rotors\n\n    This function uses a simpler interface than the more fundamental\n    `slerp_evaluate` and `slerp_vectorized` functions.  The latter\n    are fast, being implemented at the C level, but take input `tau`\n    instead of time.  This function adjusts the time accordingly.\n\n    Parameters\n    ----------\n    R1: quaternion\n        Quaternion at beginning of interpolation\n    R2: quaternion\n        Quaternion at end of interpolation\n    t1: float\n        Time corresponding to R1\n    t2: float\n        Time corresponding to R2\n    t_out: float or array of floats\n        Times to which the rotors should be interpolated\n\n\n    """"""\n    tau = (t_out-t1)/(t2-t1)\n    return np.slerp_vectorized(R1, R2, tau)\n\n\ndef squad(R_in, t_in, t_out):\n    """"""Spherical ""quadrangular"" interpolation of rotors with a cubic spline\n\n    This is the best way to interpolate rotations.  It uses the analog\n    of a cubic spline, except that the interpolant is confined to the\n    rotor manifold in a natural way.  Alternative methods involving\n    interpolation of other coordinates on the rotation group or\n    normalization of interpolated values give bad results.  The results\n    from this method are as natural as any, and are continuous in first\n    and second derivatives.\n\n    The input `R_in` rotors are assumed to be reasonably continuous (no\n    sign flips), and the input `t` arrays are assumed to be sorted.  No\n    checking is done for either case, and you may get silently bad\n    results if these conditions are violated.  The first dimension of\n    `R_in` must have the same size as `t_in`, but may have additional\n    axes following.\n\n    This function simplifies the calling, compared to `squad_evaluate`\n    (which takes a set of four quaternions forming the edges of the\n    ""quadrangle"", and the normalized time `tau`) and `squad_vectorized`\n    (which takes the same arguments, but in array form, and efficiently\n    loops over them).\n\n    Parameters\n    ----------\n    R_in: array of quaternions\n        A time-series of rotors (unit quaternions) to be interpolated\n    t_in: array of float\n        The times corresponding to R_in\n    t_out: array of float\n        The times to which R_in should be interpolated\n\n    """"""\n    from functools import partial\n\n    roll = partial(np.roll, axis=0)\n\n    if R_in.size == 0 or t_out.size == 0:\n        return np.array((), dtype=np.quaternion)\n\n    # This list contains an index for each `t_out` such that\n    # t_in[i-1] <= t_out < t_in[i]\n    # Note that `side=\'right\'` is much faster in my tests\n    # i_in_for_out = t_in.searchsorted(t_out, side=\'left\')\n    # np.clip(i_in_for_out, 0, len(t_in) - 1, out=i_in_for_out)\n    i_in_for_out = t_in.searchsorted(t_out, side=\'right\')-1\n\n    # Compute shapes used to broadcast `t` arrays against `R` arrays\n    t_in_broadcast_shape = t_in.shape + (1,)*len(R_in.shape[1:])\n    t_out_broadcast_shape = t_out.shape + (1,)*len(R_in.shape[1:])\n\n    # Now, for each index `i` in `i_in`, we need to compute the\n    # interpolation ""coefficients"" (`A_i`, `B_ip1`).\n    #\n    # I previously tested an explicit version of the loops below,\n    # comparing `stride_tricks.as_strided` with explicit\n    # implementation via `roll` (as seen here).  I found that the\n    # `roll` was significantly more efficient for simple calculations,\n    # though the difference is probably totally washed out here.  In\n    # any case, it might be useful to test again.\n    #\n    A = R_in * np.exp((- np.log((~R_in) * roll(R_in, -1))\n                       + np.log((~roll(R_in, 1)) * R_in)\n                       * np.reshape((roll(t_in, -1) - t_in) / (t_in - roll(t_in, 1)), t_in_broadcast_shape)\n                       ) * 0.25)\n    B = roll(R_in, -1) * np.exp((np.log((~roll(R_in, -1)) * roll(R_in, -2))\n                                    * np.reshape((roll(t_in, -1) - t_in) / (roll(t_in, -2) - roll(t_in, -1)), t_in_broadcast_shape)\n                                    - np.log((~R_in) * roll(R_in, -1))) * -0.25)\n\n    # Correct the first and last A time steps, and last two B time steps.  We extend R_in with the following wrap-around\n    # values:\n    # R_in[0-1] = R_in[0]*(~R_in[1])*R_in[0]\n    # R_in[n+0] = R_in[-1] * (~R_in[-2]) * R_in[-1]\n    # R_in[n+1] = R_in[0] * (~R_in[-1]) * R_in[0]\n    #           = R_in[-1] * (~R_in[-2]) * R_in[-1] * (~R_in[-1]) * R_in[-1] * (~R_in[-2]) * R_in[-1]\n    #           = R_in[-1] * (~R_in[-2]) * R_in[-1] * (~R_in[-2]) * R_in[-1]\n    # A[i] = R_in[i] * np.exp((- np.log((~R_in[i]) * R_in[i+1])\n    #                          + np.log((~R_in[i-1]) * R_in[i]) * ((t_in[i+1] - t_in[i]) / (t_in[i] - t_in[i-1]))\n    #                          ) * 0.25)\n    # A[0] = R_in[0] * np.exp((- np.log((~R_in[0]) * R_in[1]) + np.log((~R_in[0])*R_in[1]*(~R_in[0])) * R_in[0]) * 0.25)\n    #      = R_in[0]\n    A[0] = R_in[0]\n    # A[-1] = R_in[-1] * np.exp((- np.log((~R_in[-1]) * R_in[n+0])\n    #                          + np.log((~R_in[-2]) * R_in[-1]) * ((t_in[n+0] - t_in[-1]) / (t_in[-1] - t_in[-2]))\n    #                          ) * 0.25)\n    #       = R_in[-1] * np.exp((- np.log((~R_in[-1]) * R_in[n+0]) + np.log((~R_in[-2]) * R_in[-1])) * 0.25)\n    #       = R_in[-1] * np.exp((- np.log((~R_in[-1]) * R_in[-1] * (~R_in[-2]) * R_in[-1])\n    #                           + np.log((~R_in[-2]) * R_in[-1])) * 0.25)\n    #       = R_in[-1] * np.exp((- np.log((~R_in[-2]) * R_in[-1]) + np.log((~R_in[-2]) * R_in[-1])) * 0.25)\n    #       = R_in[-1]\n    A[-1] = R_in[-1]\n    # B[i] = R_in[i+1] * np.exp((np.log((~R_in[i+1]) * R_in[i+2]) * ((t_in[i+1] - t_in[i]) / (t_in[i+2] - t_in[i+1]))\n    #                            - np.log((~R_in[i]) * R_in[i+1])) * -0.25)\n    # B[-2] = R_in[-1] * np.exp((np.log((~R_in[-1]) * R_in[0]) * ((t_in[-1] - t_in[-2]) / (t_in[0] - t_in[-1]))\n    #                            - np.log((~R_in[-2]) * R_in[-1])) * -0.25)\n    #       = R_in[-1] * np.exp((np.log((~R_in[-1]) * R_in[0]) - np.log((~R_in[-2]) * R_in[-1])) * -0.25)\n    #       = R_in[-1] * np.exp((np.log((~R_in[-1]) * R_in[-1] * (~R_in[-2]) * R_in[-1])\n    #                            - np.log((~R_in[-2]) * R_in[-1])) * -0.25)\n    #       = R_in[-1] * np.exp((np.log((~R_in[-2]) * R_in[-1]) - np.log((~R_in[-2]) * R_in[-1])) * -0.25)\n    #       = R_in[-1]\n    B[-2] = R_in[-1]\n    # B[-1] = R_in[0]\n    # B[-1] = R_in[0] * np.exp((np.log((~R_in[0]) * R_in[1]) - np.log((~R_in[-1]) * R_in[0])) * -0.25)\n    #       = R_in[-1] * (~R_in[-2]) * R_in[-1]\n    #         * np.exp((np.log((~(R_in[-1] * (~R_in[-2]) * R_in[-1])) * R_in[-1] * (~R_in[-2]) * R_in[-1] * (~R_in[-2]) * R_in[-1])\n    #                  - np.log((~R_in[-1]) * R_in[-1] * (~R_in[-2]) * R_in[-1])) * -0.25)\n    #       = R_in[-1] * (~R_in[-2]) * R_in[-1]\n    #         * np.exp((np.log(((~R_in[-1]) * R_in[-2] * (~R_in[-1])) * R_in[-1] * (~R_in[-2]) * R_in[-1] * (~R_in[-2]) * R_in[-1])\n    #                  - np.log((~R_in[-1]) * R_in[-1] * (~R_in[-2]) * R_in[-1])) * -0.25)\n    #         * np.exp((np.log((~R_in[-2]) * R_in[-1])\n    #                  - np.log((~R_in[-2]) * R_in[-1])) * -0.25)\n    B[-1] = R_in[-1] * (~R_in[-2]) * R_in[-1]\n\n    # Use the coefficients at the corresponding t_out indices to\n    # compute the squad interpolant\n    # R_ip1 = np.array(roll(R_in, -1)[i_in_for_out])\n    # R_ip1[-1] = R_in[-1]*(~R_in[-2])*R_in[-1]\n    R_ip1 = roll(R_in, -1)\n    R_ip1[-1] = R_in[-1]*(~R_in[-2])*R_in[-1]\n    R_ip1 = np.array(R_ip1[i_in_for_out])\n    t_inp1 = roll(t_in, -1)\n    t_inp1[-1] = t_in[-1] + (t_in[-1] - t_in[-2])\n    tau = np.reshape((t_out - t_in[i_in_for_out]) / ((t_inp1 - t_in)[i_in_for_out]), t_out_broadcast_shape)\n    # tau = (t_out - t_in[i_in_for_out]) / ((roll(t_in, -1) - t_in)[i_in_for_out])\n    R_out = np.squad_vectorized(tau, R_in[i_in_for_out], A[i_in_for_out], B[i_in_for_out], R_ip1)\n\n    return R_out\n\n\n@njit\ndef frame_from_angular_velocity_integrand(rfrak, Omega):\n    import math\n    from numpy import dot, cross\n    from .numpy_quaternion import _eps\n    rfrakMag = math.sqrt(rfrak[0] * rfrak[0] + rfrak[1] * rfrak[1] + rfrak[2] * rfrak[2])\n    OmegaMag = math.sqrt(Omega[0] * Omega[0] + Omega[1] * Omega[1] + Omega[2] * Omega[2])\n    # If the matrix is really close to the identity, return\n    if rfrakMag < _eps * OmegaMag:\n        return Omega[0] / 2.0, Omega[1] / 2.0, Omega[2] / 2.0\n    # If the matrix is really close to singular, it\'s equivalent to the identity, so return\n    if abs(math.sin(rfrakMag)) < _eps:\n        return Omega[0] / 2.0, Omega[1] / 2.0, Omega[2] / 2.0\n\n    OmegaOver2 = Omega[0] / 2.0, Omega[1] / 2.0, Omega[2] / 2.0\n    rfrakHat = rfrak[0] / rfrakMag, rfrak[1] / rfrakMag, rfrak[2] / rfrakMag\n\n    return ((OmegaOver2 - rfrakHat * dot(rfrakHat, OmegaOver2)) * (rfrakMag / math.tan(rfrakMag))\n            + rfrakHat * dot(rfrakHat, OmegaOver2) + cross(OmegaOver2, rfrak))\n\n\nclass appending_array(object):\n    def __init__(self, shape, dtype=np.float, initial_array=None):\n        shape = list(shape)\n        if shape[0] < 4:\n            shape[0] = 4\n        self._a = np.empty(shape, dtype=dtype)\n        self.n = 0\n        if initial_array is not None:\n            assert initial_array.dtype == dtype\n            assert initial_array.shape[1:] == shape[1:]\n            assert initial_array.shape[0] <= shape[0]\n            self.n = initial_array.shape[0]\n            self._a[:self.n, ...] = initial_array[:]\n\n    def append(self, row):\n        self.n += 1\n        if self.n > self._a.shape[0]:\n            self._a = np.resize(self._a, (2*self._a.shape[0],)+self._a.shape[1:])\n        self._a[self.n-1, ...] = row\n\n    @property\n    def a(self):\n        return self._a[:self.n, ...]\n\n\ndef integrate_angular_velocity(Omega, t0, t1, R0=None, tolerance=1e-12):\n    """"""Compute frame with given angular velocity\n\n    Parameters\n    ==========\n    Omega: tuple or callable\n        Angular velocity from which to compute frame.  Can be\n          1) a 2-tuple of float arrays (t, v) giving the angular velocity vector at a series of times,\n          2) a function of time that returns the 3-vector angular velocity, or\n          3) a function of time and orientation (t, R) that returns the 3-vector angular velocity\n        In case 1, the angular velocity will be interpolated to the required times.  Note that accuracy\n        is poor in case 1.\n    t0: float\n        Initial time\n    t1: float\n        Final time\n    R0: quaternion, optional\n        Initial frame orientation.  Defaults to 1 (the identity orientation).\n    tolerance: float, optional\n        Absolute tolerance used in integration.  Defaults to 1e-12.\n\n    Returns\n    =======\n    t: float array\n    R: quaternion array\n\n    """"""\n    import warnings\n    from scipy.integrate import ode\n\n    if R0 is None:\n        R0 = quaternion.one\n\n    input_is_tabulated = False\n\n    try:\n        t_Omega, v = Omega\n        from scipy.interpolate import InterpolatedUnivariateSpline\n        Omega_x = InterpolatedUnivariateSpline(t_Omega, v[:, 0])\n        Omega_y = InterpolatedUnivariateSpline(t_Omega, v[:, 1])\n        Omega_z = InterpolatedUnivariateSpline(t_Omega, v[:, 2])\n        def Omega_func(t, R):\n            return [Omega_x(t), Omega_y(t), Omega_z(t)]\n        Omega_func(t0, R0)\n        input_is_tabulated = True\n    except (TypeError, ValueError):\n        def Omega_func(t, R):\n            return Omega(t, R)\n        try:\n            Omega_func(t0, R0)\n        except TypeError:\n            def Omega_func(t, R):\n                return Omega(t)\n            Omega_func(t0, R0)\n\n    def RHS(t, y):\n        R = quaternion.quaternion(*y)\n        return (0.5 * quaternion.quaternion(0.0, *Omega_func(t, R)) * R).components\n\n    y0 = R0.components\n\n    if input_is_tabulated:\n        from scipy.integrate import solve_ivp\n        t = t_Omega\n        t_span = [t_Omega[0], t_Omega[-1]]\n        solution = solve_ivp(RHS, t_span, y0, t_eval=t_Omega, atol=tolerance, rtol=100*np.finfo(float).eps)\n        R = quaternion.from_float_array(solution.y.T)\n    else:\n        solver = ode(RHS)\n        solver.set_initial_value(y0, t0)\n        solver.set_integrator(\'dop853\', nsteps=1, atol=tolerance, rtol=0.0)\n        solver._integrator.iwork[2] = -1  # suppress Fortran-printed warning\n        t = appending_array((int(t1-t0),))\n        t.append(solver.t)\n        R = appending_array((int(t1-t0), 4))\n        R.append(solver.y)\n        warnings.filterwarnings(""ignore"", category=UserWarning)\n        t_last = solver.t\n        while solver.t < t1:\n            solver.integrate(t1, step=True)\n            if solver.t > t_last:\n                t.append(solver.t)\n                R.append(solver.y)\n                t_last = solver.t\n        warnings.resetwarnings()\n        t = t.a\n        R = quaternion.as_quat_array(R.a)\n\n    return t, R\n\n\ndef minimal_rotation(R, t, iterations=2):\n    """"""Adjust frame so that there is no rotation about z\' axis\n\n    The output of this function is a frame that rotates the z axis onto the same z\' axis as the\n    input frame, but with minimal rotation about that axis.  This is done by pre-composing the input\n    rotation with a rotation about the z axis through an angle gamma, where\n\n        dgamma/dt = 2*(dR/dt * z * R.conjugate()).w\n\n    This ensures that the angular velocity has no component along the z\' axis.\n\n    Note that this condition becomes easier to impose the closer the input rotation is to a\n    minimally rotating frame, which means that repeated application of this function improves its\n    accuracy.  By default, this function is iterated twice, though a few more iterations may be\n    called for.\n\n    Parameters\n    ==========\n    R: quaternion array\n        Time series describing rotation\n    t: float array\n        Corresponding times at which R is measured\n    iterations: int [defaults to 2]\n        Repeat the minimization to refine the result\n\n    """"""\n    from scipy.interpolate import InterpolatedUnivariateSpline as spline\n    if iterations == 0:\n        return R\n    R = quaternion.as_float_array(R)\n    Rdot = np.empty_like(R)\n    for i in range(4):\n        Rdot[:, i] = spline(t, R[:, i]).derivative()(t)\n    R = quaternion.from_float_array(R)\n    Rdot = quaternion.from_float_array(Rdot)\n    halfgammadot = quaternion.as_float_array(Rdot * quaternion.z * np.conjugate(R))[:, 0]\n    halfgamma = spline(t, halfgammadot).antiderivative()(t)\n    Rgamma = np.exp(quaternion.z * halfgamma)\n    return minimal_rotation(R * Rgamma, t, iterations=iterations-1)\n\n\ndef angular_velocity(R, t):\n    from scipy.interpolate import InterpolatedUnivariateSpline as spline\n    R = quaternion.as_float_array(R)\n    Rdot = np.empty_like(R)\n    for i in range(4):\n        Rdot[:, i] = spline(t, R[:, i]).derivative()(t)\n    R = quaternion.from_float_array(R)\n    Rdot = quaternion.from_float_array(Rdot)\n    return quaternion.as_float_array(2*Rdot/R)[:, 1:]\n    \n'"
setup.py,0,"b'#!/usr/bin/env python\n\n# Copyright (c) 2018, Michael Boyle\n# See LICENSE file for details: <https://github.com/moble/quaternion/blob/master/LICENSE>\n\n# Construct the version number from the date and time this python version was created.\nfrom os import environ\nfrom sys import platform\nfrom warnings import warn\nversion = None\non_windows = (\'win\' in platform.lower() and not \'darwin\' in platform.lower())\nif ""package_version"" in environ:\n    version = environ[""package_version""]\n    print(""Setup.py using environment version=\'{0}\'"".format(version))\nelse:\n    print(""The variable \'package_version\' was not present in the environment"")\n    try:\n        # For cases where this is being installed from git.  This gives the true version number.\n        from subprocess import check_output\n        if on_windows:\n            version = check_output(""""""git log -1 --format=%cd --date=format:\'%Y.%m.%d.%H.%M.%S\'"""""", shell=False)\n            version = version.decode(\'ascii\').strip().replace(\'.0\', \'.\').replace(""\'"", """")\n        else:\n            try:\n                from subprocess import DEVNULL as devnull\n                version = check_output(""""""git log -1 --format=%cd --date=format:\'%Y.%-m.%-d.%-H.%-M.%-S\'"""""", shell=True, stderr=devnull)\n            except AttributeError:\n                from os import devnull\n                version = check_output(""""""git log -1 --format=%cd --date=format:\'%Y.%-m.%-d.%-H.%-M.%-S\'"""""", shell=True, stderr=devnull)\n            version = version.decode(\'ascii\').rstrip()\n        print(""Setup.py using git log version=\'{0}\'"".format(version))\n    except:\n        pass\nif version is not None:\n    with open(\'_version.py\', \'w\') as f:\n        f.write(\'__version__ = ""{0}""\'.format(version))\nelse:\n    try:\n        from ast import literal_eval\n        with open(\'_version.py\', \'r\') as f:\n            first_line = f.readline()\n        version_string = first_line.split(\'=\')[1].strip()\n        version = literal_eval(version_string)\n    except:\n        pass\n\n\n\n\nlong_description = """"""\\\nThis package creates a quaternion type in python, and further enables numpy to create and manipulate arrays of\nquaternions.  The usual algebraic operations (addition and multiplication) are available, along with numerous\nproperties like norm and various types of distance measures between two quaternions.  There are also\nadditional functions like ""squad"" and ""slerp"" interpolation, and conversions to and from axis-angle, matrix,\nand Euler-angle representations of rotations.  The core of the code is written in C for speed.\n""""""\n\n\nif __name__ == ""__main__"":\n    # Note: Because pip may try to install this package before numpy (on which it depends, and which\n    # it needs to use *during* setup), we need to try to fail gracefully when numpy is not\n    # installed.  The following mostly follows the strategy found in scipy\'s setup.py script, here:\n    # https://github.com/scipy/scipy/blob/9ccc68475fc431c4a44c120693cf6878cc4c14a7/setup.py#L180\n    \n    import sys\n\n    setup_metadata = dict(\n        name=\'numpy-quaternion\',  # Uploaded to pypi under this name\n        packages=[\'quaternion\'],  # This is the actual package name, as used in python\n        package_dir={\'quaternion\': \'\'},\n        url=\'https://github.com/moble/quaternion\',\n        author=\'Michael Boyle\',\n        author_email=\'mob22@cornell.edu\',\n        description=\'Add built-in support for quaternions to numpy\',\n        long_description=long_description,\n    )\n\n    if version is not None:\n        setup_metadata[\'version\'] = version\n\n    if len(sys.argv) >= 2 and (\'--help\' in sys.argv[1:] or sys.argv[1] in (\'--help-commands\', \'egg_info\', \'--version\', \'clean\')):\n        # For these actions, NumPy is not required.\n        #\n        # They are required to succeed without Numpy for example when\n        # pip is used to install Scipy when Numpy is not yet present in\n        # the system.\n        try:\n            from setuptools import setup\n            setup_metadata[\'install_requires\'] = [\'numpy>=1.13\',]\n            setup_metadata[\'setup_requires\'] = [\'setuptools\', \'wheel\', \'numpy>=1.13\',]\n        except ImportError:\n            from distutils.core import setup\n    else:\n        from setuptools import setup, Extension\n        from setuptools.command.build_ext import build_ext as _build_ext\n        setup_metadata[\'install_requires\'] = [\'numpy>=1.13\',]\n        setup_metadata[\'setup_requires\'] = [\'setuptools\', \'wheel\', \'numpy>=1.13\',]\n        extension = Extension(\n            name=\'quaternion.numpy_quaternion\',  # This is the name of the object file that will be compiled\n            sources=[\'quaternion.c\', \'numpy_quaternion.c\'],\n            extra_compile_args=[\'/O2\' if on_windows else \'-O3\'],\n            depends=[\'quaternion.c\', \'quaternion.h\', \'numpy_quaternion.c\'],\n        )\n        setup_metadata[\'ext_modules\'] = [extension]\n        class build_ext(_build_ext):\n            # This addition was suggested in https://stackoverflow.com/a/21621689/1194883\n            def finalize_options(self):\n                _build_ext.finalize_options(self)\n                # Prevent numpy from thinking it is still in its setup process:\n                try:\n                    __builtins__.__NUMPY_SETUP__ = False\n                except:\n                    try:\n                        # For python 3\n                        import builtins\n                        builtins.__NUMPY_SETUP__ = False\n                    except:\n                        warn(""Skipping numpy hack; if installation fails, try installing numpy first"")\n                import numpy\n                self.include_dirs.append(numpy.get_include())\n                if numpy.__dict__.get(\'quaternion\') is not None:\n                    from distutils.errors import DistutilsError\n                    raise DistutilsError(\'The target NumPy already has a quaternion type\')\n        setup_metadata[\'cmdclass\'] = {\'build_ext\': build_ext}\n\n    setup(**setup_metadata)\n'"
docs/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\nimport sphinx\n\nfrom recommonmark.parser import CommonMarkParser\n\n\n# -- Project information -----------------------------------------------------\n\ntry:\n    sys.path.insert(0, os.path.abspath(\'..\'))\n    import _version as quat_version\nexcept:\n    import quaternion._version as quat_version\n\nproject = \'quaternion\'\ncopyright = \'2019, Michael Boyle\'\nauthor = \'Michael Boyle\'\n\n# The short X.Y version\nversion = quat_version.__version__\n# The full version, including alpha/beta/rc tags\nrelease = version\n\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.autosummary\',\n    \'numpydoc\',\n    \'sphinx.ext.doctest\',\n    \'sphinx.ext.todo\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.ifconfig\',\n    \'sphinx.ext.viewcode\',\n    \'recommonmark\',\n]\n\nautosummary_generate = True\n\nautodoc_docstring_signature = True\nif sphinx.version_info < (1, 8):\n    autodoc_default_flags = [\'members\', \'undoc-members\']\nelse:\n    autodoc_default_options = {\'members\': None,\n                               \'undoc-members\': None,\n                               \'special-members\': \'__call__\'}\n\n# -- Try to auto-generate numba-decorated signatures -----------------\n\nimport numba\nimport inspect\n\ndef process_numba_docstring(app, what, name, obj, options, signature, return_annotation):\n    if type(obj) is not numba.targets.registry.CPUDispatcher:\n        return (signature, return_annotation)\n    else:\n        original = obj.py_func\n        orig_sig = inspect.signature(original)\n\n        if (orig_sig.return_annotation) is inspect._empty:\n            ret_ann = None\n        else:\n            ret_ann = orig_sig.return_annotation.__name__\n\n        return (str(orig_sig), ret_ann)\n\ndef setup(app):\n    app.connect(\'autodoc-process-signature\', process_numba_docstring)\n\n# --------------------------------------------------------------------\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\nif sphinx.version_info < (1, 8):\n    source_parsers = {\n        \'.md\': CommonMarkParser,\n    }\n    source_suffix = [\'.rst\', \'.md\']\nelse:\n    source_suffix = {\n        \'.rst\': \'restructuredtext\',\n        \'.txt\': \'markdown\',\n        \'.md\': \'markdown\',\n    }\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\']\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = None\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'quaterniondoc\'\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'quaternion.tex\', \'quaternion Documentation\',\n     \'Michael Boyle\', \'manual\'),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'quaternion\', \'quaternion Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'quaternion\', \'quaternion Documentation\',\n     author, \'quaternion\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n# -- Options for Epub output -------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#\n# epub_identifier = \'\'\n\n# A unique identification for the text.\n#\n# epub_uid = \'\'\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [\'search.html\']\n\n\n# -- Extension configuration -------------------------------------------------\n\n# -- Options for intersphinx extension ---------------------------------------\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\'https://docs.python.org/\': None}\n\n# -- Options for todo extension ----------------------------------------------\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = True\n'"
test/script.py,2,"b""#!/usr/bin/env python\n\nfrom __future__ import print_function, division, absolute_import\nimport sys\nimport numpy as np\nimport quaternion\nfrom numpy import *\n\n\neps = np.finfo(float).eps\n\n\nrot_mat_eps = 200*eps\n\n\nR1 = np.array([quaternion.quaternion(0, -math.sqrt(0.5), 0, -math.sqrt(0.5))])\nprint(R1)\nprint(quaternion.as_rotation_matrix(R1))\nR2 = quaternion.from_rotation_matrix(quaternion.as_rotation_matrix(R1))\nprint(R2)\nd = quaternion.rotation_intrinsic_distance(R1[0], R2[0])\nprint(d)\nprint()\nsys.stdout.flush()\nsys.stderr.flush()\nassert d < rot_mat_eps, (R1, R2, d)  # Can't use allclose here; we don't care about rotor sign\n"""
test/test_calculus.py,25,"b'#!/usr/bin/env python\n\nfrom __future__ import print_function, division, absolute_import\n\nimport math\nimport numpy as np\nimport quaternion\nfrom numpy import *\nimport pytest\n\ntry:\n    import scipy\n    has_scipy = True\nexcept:\n    has_scipy = False\n\neps = np.finfo(float).eps\n\n\n@pytest.mark.skipif(not has_scipy, reason=""Scipy is not installed"")\ndef test_subset_interpolation():\n    from quaternion.calculus import spline\n    t = np.linspace(0, 10, 100)\n    f = np.sin(t)\n\n    for i1, i2 in [[0, 100], [0, -1], [10, -10], [11, -10], [10, -11], [11, -11], [21, -21], [31, -31]]:\n        f_out = spline(f, t, t_out=t[i1:i2])\n        f_sub = f[i1:i2]\n        assert np.allclose(f_out, f_sub, atol=2*eps, rtol=2*eps)\n\n\n@pytest.mark.skipif(not has_scipy, reason=""Scipy is not installed"")\ndef test_differentiation():\n    from quaternion.calculus import spline\n    t = np.linspace(0, 10, 1000)\n\n    f = np.sin(t)\n    fprime = np.cos(t)\n    assert np.allclose(spline(f, t, spline_degree=5, derivative_order=1), fprime, atol=1e-11, rtol=1e-11)\n\n    f = np.exp(1j*t)\n    fprime = 1j*np.exp(1j*t)\n    assert np.allclose(spline(f, t, spline_degree=5, derivative_order=1), fprime, atol=1e-11, rtol=1e-11)\n\n\n@pytest.mark.skipif(not has_scipy, reason=""Scipy is not installed"")\ndef test_antiderivative():\n    from quaternion.calculus import spline\n    t = np.linspace(0, 10, 1000)\n\n    f = np.cos(t)\n    fint = np.sin(t)\n    assert np.allclose(spline(f, t, spline_degree=5, derivative_order=-1), fint, atol=1e-11, rtol=1e-11)\n\n    f = np.exp(1j*t)\n    fint = 1j*(1-np.exp(1j*t))\n    assert np.allclose(spline(f, t, spline_degree=5, derivative_order=-1), fint, atol=1e-11, rtol=1e-11)\n\n\n@pytest.mark.skipif(not has_scipy, reason=""Scipy is not installed"")\ndef test_integral():\n    from quaternion.calculus import spline\n    t = np.linspace(0, 10, 1000)\n\n    f = np.cos(t)\n    fint = np.sin(t)\n    assert np.allclose(spline(f, t, spline_degree=5, definite_integral_bounds=(t[0], t[-1])),\n                       fint[-1]-fint[0], atol=1e-11, rtol=1e-11)\n\n    f = np.exp(1j*t)\n    fint = 1j*(1-np.exp(1j*t))\n    # print(max(abs(spline(f, t, spline_degree=5, derivative_order=-1)-fint)))\n    assert np.allclose(spline(f, t, spline_degree=5, definite_integral_bounds=(t[0], t[-1])),\n                       fint[-1]-fint[0], atol=1e-11, rtol=1e-11)\n'"
test/test_quaternion.py,378,"b'#!/usr/bin/env python\n\nfrom __future__ import print_function, division, absolute_import\nimport os\nimport operator\n\nimport math\nimport numpy as np\nimport quaternion\nfrom numpy import *\nimport pytest\n\ntry:\n    import scipy\n    has_scipy = True\nexcept:\n    has_scipy = False\n\n\nfrom sys import platform\non_windows = (\'win\' in platform.lower() and not \'darwin\' in platform.lower())\n\n\neps = np.finfo(float).eps\n\n\ndef allclose(*args, **kwargs):\n    kwargs.update({\'verbose\': True})\n    return quaternion.allclose(*args, **kwargs)\n\n\ndef passer(b):\n    pass\n# Change this to strict_assert = assert_ to check for missing tests\nstrict_assert = passer\n\n\ndef ufunc_binary_utility(array1, array2, op, rtol=2*eps, atol=0.0):\n    """"""Make sure broadcasting is consistent with individual operations\n\n    Given two arrays, we expect a broadcast binary operation to be consistent with the individual operations.  This\n    utility function simply goes through and checks that that is true.  For example, if the input operation is `*`,\n    this function checks for each `i` that\n\n        array1[i] * array2  ==  np.array([array1[i]*array2[j] for j in range(len(array2))])\n\n    """"""\n    for arg1 in array1:\n        assert allclose(op(arg1, array2),\n                        np.array([op(arg1, arg2) for arg2 in array2]),\n                        rtol=rtol, atol=atol)\n    for arg2 in array2:\n        assert allclose(op(array1, arg2),\n                        np.array([op(arg1, arg2) for arg1 in array1]),\n                        rtol=rtol, atol=atol)\n\n    if array1.shape == array2.shape:\n        assert allclose(op(array1, array2),\n                        np.array([op(arg1, arg2) for arg1, arg2 in zip(array1, array2)]),\n                        rtol=rtol, atol=atol)\n\n\n# The following fixtures are used to establish some re-usable data\n# for the tests; they need to be re-constructed because some of the\n# tests will change the values, but we want the values to be constant\n# on every entry into a test.\n\n@pytest.fixture\ndef Qs():\n    return make_Qs()\n    \ndef make_Qs():\n    q_nan1 = quaternion.quaternion(np.nan, 0., 0., 0.)\n    q_inf1 = quaternion.quaternion(np.inf, 0., 0., 0.)\n    q_minf1 = quaternion.quaternion(-np.inf, 0., 0., 0.)\n    q_0 = quaternion.quaternion(0., 0., 0., 0.)\n    q_1 = quaternion.quaternion(1., 0., 0., 0.)\n    x = quaternion.quaternion(0., 1., 0., 0.)\n    y = quaternion.quaternion(0., 0., 1., 0.)\n    z = quaternion.quaternion(0., 0., 0., 1.)\n    Q = quaternion.quaternion(1.1, 2.2, 3.3, 4.4)\n    Qneg = quaternion.quaternion(-1.1, -2.2, -3.3, -4.4)\n    Qbar = quaternion.quaternion(1.1, -2.2, -3.3, -4.4)\n    Qnormalized = quaternion.quaternion(0.18257418583505537115232326093360,\n                                        0.36514837167011074230464652186720,\n                                        0.54772255750516611345696978280080,\n                                        0.73029674334022148460929304373440)\n    Qlog = quaternion.quaternion(1.7959088706354, 0.515190292664085,\n                                 0.772785438996128, 1.03038058532817)\n    Qexp = quaternion.quaternion(2.81211398529184, -0.392521193481878,\n                                 -0.588781790222817, -0.785042386963756)\n    return np.array([q_nan1, q_inf1, q_minf1, q_0, q_1, x, y, z, Q, Qneg, Qbar, Qnormalized, Qlog, Qexp],\n                    dtype=np.quaternion)\n\nQs_array = make_Qs()\n\n\nq_nan1, q_inf1, q_minf1, q_0, q_1, x, y, z, Q, Qneg, Qbar, Qnormalized, Qlog, Qexp, = range(len(Qs_array))\nQs_zero = [i for i in range(len(Qs_array)) if not Qs_array[i].nonzero()]\nQs_nonzero = [i for i in range(len(Qs_array)) if Qs_array[i].nonzero()]\nQs_nan = [i for i in range(len(Qs_array)) if Qs_array[i].isnan()]\nQs_nonnan = [i for i in range(len(Qs_array)) if not Qs_array[i].isnan()]\nQs_nonnannonzero = [i for i in range(len(Qs_array)) if not Qs_array[i].isnan() and Qs_array[i].nonzero()]\nQs_inf = [i for i in range(len(Qs_array)) if Qs_array[i].isinf()]\nQs_noninf = [i for i in range(len(Qs_array)) if not Qs_array[i].isinf()]\nQs_noninfnonzero = [i for i in range(len(Qs_array)) if not Qs_array[i].isinf() and Qs_array[i].nonzero()]\nQs_finite = [i for i in range(len(Qs_array)) if Qs_array[i].isfinite()]\nQs_nonfinite = [i for i in range(len(Qs_array)) if not Qs_array[i].isfinite()]\nQs_finitenonzero = [i for i in range(len(Qs_array)) if Qs_array[i].isfinite() and Qs_array[i].nonzero()]\n\n\n@pytest.fixture\ndef Rs():\n    ones = [0, -1., 1.]\n    rs = [np.quaternion(w, x, y, z).normalized() for w in ones for x in ones for y in ones for z in ones][1:]\n    np.random.seed(1842)\n    rs = rs + [r.normalized() for r in [np.quaternion(np.random.uniform(-1, 1), np.random.uniform(-1, 1),\n                                                      np.random.uniform(-1, 1), np.random.uniform(-1, 1)) for i in range(20)]]\n    return np.array(rs)\n\n\ndef test_quaternion_members():\n    Q = quaternion.quaternion(1.1, 2.2, 3.3, 4.4)\n    assert Q.real == 1.1\n    assert Q.w == 1.1\n    assert Q.x == 2.2\n    assert Q.y == 3.3\n    assert Q.z == 4.4\n\n\ndef test_quaternion_constructors():\n    Q = quaternion.quaternion(2.2, 3.3, 4.4)\n    assert Q.real == 0.0\n    assert Q.w == 0.0\n    assert Q.x == 2.2\n    assert Q.y == 3.3\n    assert Q.z == 4.4\n    \n    P = quaternion.quaternion(1.1, 2.2, 3.3, 4.4)\n    Q = quaternion.quaternion(P)\n    assert Q.real == 1.1\n    assert Q.w == 1.1\n    assert Q.x == 2.2\n    assert Q.y == 3.3\n    assert Q.z == 4.4\n\n    Q = quaternion.quaternion(1.1)\n    assert Q.real == 1.1\n    assert Q.w == 1.1\n    assert Q.x == 0.0\n    assert Q.y == 0.0\n    assert Q.z == 0.0\n\n    Q = quaternion.quaternion(0.0)\n    assert Q.real == 0.0\n    assert Q.w == 0.0\n    assert Q.x == 0.0\n    assert Q.y == 0.0\n    assert Q.z == 0.0\n\n    with pytest.raises(TypeError):\n        quaternion.quaternion(1.2, 3.4)\n\n    with pytest.raises(TypeError):\n        quaternion.quaternion(1.2, 3.4, 5.6, 7.8, 9.0)\n\n\ndef test_constants():\n    assert quaternion.one == np.quaternion(1.0, 0.0, 0.0, 0.0)\n    assert quaternion.x == np.quaternion(0.0, 1.0, 0.0, 0.0)\n    assert quaternion.y == np.quaternion(0.0, 0.0, 1.0, 0.0)\n    assert quaternion.z == np.quaternion(0.0, 0.0, 0.0, 1.0)\n\n\ndef test_isclose():\n    from quaternion import x, y\n\n    assert np.array_equal(quaternion.isclose([1e10*x, 1e-7*y], [1.00001e10*x, 1e-8*y], rtol=1.e-5, atol=2.e-8),\n                          np.array([True, False]))\n    assert np.array_equal(quaternion.isclose([1e10*x, 1e-8*y], [1.00001e10*x, 1e-9*y], rtol=1.e-5, atol=2.e-8),\n                          np.array([True, True]))\n    assert np.array_equal(quaternion.isclose([1e10*x, 1e-8*y], [1.0001e10*x, 1e-9*y], rtol=1.e-5, atol=2.e-8),\n                          np.array([False, True]))\n    assert np.array_equal(quaternion.isclose([x, np.nan*y], [x, np.nan*y]),\n                          np.array([True, False]))\n    assert np.array_equal(quaternion.isclose([x, np.nan*y], [x, np.nan*y], equal_nan=True),\n                          np.array([True, True]))\n\n    np.random.seed(1234)\n    a = quaternion.as_quat_array(np.random.random((3, 5, 4)))\n    assert quaternion.allclose(1e10 * a, 1.00001e10 * a, rtol=1.e-5, atol=2.e-8, verbose=True) == True\n    assert quaternion.allclose(1e-7 * a, 1e-8 * a, rtol=1.e-5, atol=2.e-8) == False\n    assert quaternion.allclose(1e10 * a, 1.00001e10 * a, rtol=1.e-5, atol=2.e-8, verbose=True) == True\n    assert quaternion.allclose(1e-8 * a, 1e-9 * a, rtol=1.e-5, atol=2.e-8, verbose=True) == True\n    assert quaternion.allclose(1e10 * a, 1.0001e10 * a, rtol=1.e-5, atol=2.e-8) == False\n    assert quaternion.allclose(1e-8 * a, 1e-9 * a, rtol=1.e-5, atol=2.e-8, verbose=True) == True\n    assert quaternion.allclose(np.nan * a, np.nan * a) == False\n    assert quaternion.allclose(np.nan * a, np.nan * a, equal_nan=True, verbose=True) == True\n\n\n@pytest.mark.parametrize(""q"", make_Qs())\ndef test_bad_conversions(q):\n    with pytest.raises(TypeError):\n        s = int(q)\n    with pytest.raises(TypeError):\n        s = float(q)\n    with pytest.raises(TypeError):\n        a = np.zeros(3, dtype=int)\n        a[0] = q\n    with pytest.raises(TypeError):\n        a = np.zeros(3)\n        a[0] = q\n\n\ndef test_as_float_quat(Qs):\n    qs = Qs[Qs_nonnan]\n    for quats in [qs, np.vstack((qs,)*3), np.vstack((qs,)*(3*5)).reshape((3, 5)+qs.shape),\n                  np.vstack((qs,)*(3*5*6)).reshape((3, 5, 6)+qs.shape)]:\n        floats = quaternion.as_float_array(quats)\n        assert floats.shape == quats.shape+(4,)\n        assert allclose(quaternion.as_quat_array(floats), quats)\n        assert allclose(quaternion.from_float_array(floats), quats)\n        # Test that we can handle a list just like an array\n        assert np.array_equal(quaternion.as_quat_array(floats), quaternion.as_quat_array(floats.tolist()))\n    a = np.arange(12).reshape(3, 4)\n    assert np.array_equal(quaternion.as_float_array(quaternion.as_quat_array(a)),\n                          a.astype(float))\n    assert quaternion.as_float_array(quaternion.x).ndim == 1\n\n\ndef test_as_rotation_matrix(Rs):\n    def quat_mat(quat):\n        return np.array([(quat * v * quat.inverse()).vec for v in [quaternion.x, quaternion.y, quaternion.z]]).T\n\n    def quat_mat_vec(quats):\n        mat_vec = np.array([quaternion.as_float_array(quats * v * np.reciprocal(quats))[..., 1:]\n                            for v in [quaternion.x, quaternion.y, quaternion.z]])\n        return np.transpose(mat_vec, tuple(range(mat_vec.ndim))[1:-1]+(-1, 0))\n\n    with pytest.raises(ZeroDivisionError):\n        quaternion.as_rotation_matrix(quaternion.zero)\n\n    for R in Rs:\n        # Test correctly normalized rotors:\n        assert allclose(quat_mat(R), quaternion.as_rotation_matrix(R), atol=2*eps)\n        # Test incorrectly normalized rotors:\n        assert allclose(quat_mat(R), quaternion.as_rotation_matrix(1.1*R), atol=2*eps)\n\n    Rs0 = Rs.copy()\n    Rs0[Rs.shape[0]//2] = quaternion.zero\n    with pytest.raises(ZeroDivisionError):\n        quaternion.as_rotation_matrix(Rs0)\n\n    # Test correctly normalized rotors:\n    assert allclose(quat_mat_vec(Rs), quaternion.as_rotation_matrix(Rs), atol=2*eps)\n    # Test incorrectly normalized rotors:\n    assert allclose(quat_mat_vec(Rs), quaternion.as_rotation_matrix(1.1*Rs), atol=2*eps)\n\n    # Simply test that this function succeeds and returns the right shape\n    assert quaternion.as_rotation_matrix(Rs.reshape((2, 5, 10))).shape == (2, 5, 10, 3, 3)\n\n\ndef test_from_rotation_matrix(Rs):\n    try:\n        from scipy import linalg\n        have_linalg = True\n    except ImportError:\n        have_linalg = False\n\n    for nonorthogonal in [True, False]:\n        if nonorthogonal and have_linalg:\n            rot_mat_eps = 10*eps\n        else:\n            rot_mat_eps = 5*eps\n        for i, R1 in enumerate(Rs):\n            R2 = quaternion.from_rotation_matrix(quaternion.as_rotation_matrix(R1), nonorthogonal=nonorthogonal)\n            d = quaternion.rotation_intrinsic_distance(R1, R2)\n            assert d < rot_mat_eps, (i, R1, R2, d)  # Can\'t use allclose here; we don\'t care about rotor sign\n\n        Rs2 = quaternion.from_rotation_matrix(quaternion.as_rotation_matrix(Rs), nonorthogonal=nonorthogonal)\n        for R1, R2 in zip(Rs, Rs2):\n            d = quaternion.rotation_intrinsic_distance(R1, R2)\n            assert d < rot_mat_eps, (R1, R2, d)  # Can\'t use allclose here; we don\'t care about rotor sign\n\n        Rs3 = Rs.reshape((2, 5, 10))\n        Rs4 = quaternion.from_rotation_matrix(quaternion.as_rotation_matrix(Rs3))\n        for R3, R4 in zip(Rs3.flatten(), Rs4.flatten()):\n            d = quaternion.rotation_intrinsic_distance(R3, R4)\n            assert d < rot_mat_eps, (R3, R4, d)  # Can\'t use allclose here; we don\'t care about rotor sign\n\n\ndef test_as_rotation_vector():\n    np.random.seed(1234)\n    n_tests = 1000\n    vecs = np.random.uniform(high=math.pi/math.sqrt(3), size=n_tests*3).reshape((n_tests, 3))\n    quats = np.zeros(vecs.shape[:-1]+(4,))\n    quats[..., 1:] = vecs[...]\n    quats = quaternion.as_quat_array(quats)\n    quats = np.exp(quats/2)\n    quat_vecs = quaternion.as_rotation_vector(quats)\n    assert allclose(quat_vecs, vecs)\n\n\ndef test_from_rotation_vector():\n    np.random.seed(1234)\n    n_tests = 1000\n    vecs = np.random.uniform(high=math.pi/math.sqrt(3), size=n_tests*3).reshape((n_tests, 3))\n    quats = np.zeros(vecs.shape[:-1]+(4,))\n    quats[..., 1:] = vecs[...]\n    quats = quaternion.as_quat_array(quats)\n    quats = np.exp(quats/2)\n    quat_vecs = quaternion.as_rotation_vector(quats)\n    quats2 = quaternion.from_rotation_vector(quat_vecs)\n    assert allclose(quats, quats2)\n\n\ndef test_rotate_vectors(Rs):\n    np.random.seed(1234)\n    # Test (1)*(1)\n    vecs = np.random.rand(3)\n    quats = quaternion.z\n    vecsprime = quaternion.rotate_vectors(quats, vecs)\n    assert np.allclose(vecsprime,\n                       (quats * quaternion.quaternion(*vecs) * quats.inverse()).vec,\n                       rtol=0.0, atol=0.0)\n    assert quats.shape + vecs.shape == vecsprime.shape, (""Out of shape!"", quats.shape, vecs.shape, vecsprime.shape)\n    # Test (1)*(5)\n    vecs = np.random.rand(5, 3)\n    quats = quaternion.z\n    vecsprime = quaternion.rotate_vectors(quats, vecs)\n    for i, vec in enumerate(vecs):\n        assert np.allclose(vecsprime[i],\n                           (quats * quaternion.quaternion(*vec) * quats.inverse()).vec,\n                           rtol=0.0, atol=0.0)\n    assert quats.shape + vecs.shape == vecsprime.shape, (""Out of shape!"", quats.shape, vecs.shape, vecsprime.shape)\n    # Test (1)*(5) inner axis\n    vecs = np.random.rand(3, 5)\n    quats = quaternion.z\n    vecsprime = quaternion.rotate_vectors(quats, vecs, axis=-2)\n    for i, vec in enumerate(vecs.T):\n        assert np.allclose(vecsprime[:, i],\n                           (quats * quaternion.quaternion(*vec) * quats.inverse()).vec,\n                           rtol=0.0, atol=0.0)\n    assert quats.shape + vecs.shape == vecsprime.shape, (""Out of shape!"", quats.shape, vecs.shape, vecsprime.shape)\n    # Test (N)*(1)\n    vecs = np.random.rand(3)\n    quats = Rs\n    vecsprime = quaternion.rotate_vectors(quats, vecs)\n    assert np.allclose(vecsprime,\n                       [vprime.vec for vprime in quats * quaternion.quaternion(*vecs) * ~quats],\n                       rtol=1e-15, atol=1e-15)\n    assert quats.shape + vecs.shape == vecsprime.shape, (""Out of shape!"", quats.shape, vecs.shape, vecsprime.shape)\n    # Test (N)*(5)\n    vecs = np.random.rand(5, 3)\n    quats = Rs\n    vecsprime = quaternion.rotate_vectors(quats, vecs)\n    for i, vec in enumerate(vecs):\n        assert np.allclose(vecsprime[:, i],\n                           [vprime.vec for vprime in quats * quaternion.quaternion(*vec) * ~quats],\n                           rtol=1e-15, atol=1e-15)\n    assert quats.shape + vecs.shape == vecsprime.shape, (""Out of shape!"", quats.shape, vecs.shape, vecsprime.shape)\n    # Test (N)*(5) inner axis\n    vecs = np.random.rand(3, 5)\n    quats = Rs\n    vecsprime = quaternion.rotate_vectors(quats, vecs, axis=-2)\n    for i, vec in enumerate(vecs.T):\n        assert np.allclose(vecsprime[:, :, i],\n                           [vprime.vec for vprime in quats * quaternion.quaternion(*vec) * ~quats],\n                           rtol=1e-15, atol=1e-15)\n    assert quats.shape + vecs.shape == vecsprime.shape, (""Out of shape!"", quats.shape, vecs.shape, vecsprime.shape)\n\n\ndef test_allclose(Qs):\n    for q in Qs[Qs_nonnan]:\n        assert quaternion.allclose(q, q, rtol=0.0, atol=0.0)\n    assert quaternion.allclose(Qs[Qs_nonnan], Qs[Qs_nonnan], rtol=0.0, atol=0.0)\n\n    for q in Qs[Qs_finitenonzero]:\n        assert quaternion.allclose(q, q*(1+1e-13), rtol=1.1e-13, atol=0.0)\n        assert ~quaternion.allclose(q, q*(1+1e-13), rtol=0.9e-13, atol=0.0)\n        for e in [quaternion.one, quaternion.x, quaternion.y, quaternion.z]:\n            assert quaternion.allclose(q, q+(1e-13*e), rtol=0.0, atol=1.1e-13)\n            assert ~quaternion.allclose(q, q+(1e-13*e), rtol=0.0, atol=0.9e-13)\n    assert quaternion.allclose(Qs[Qs_finitenonzero], Qs[Qs_finitenonzero]*(1+1e-13), rtol=1.1e-13, atol=0.0)\n    assert ~quaternion.allclose(Qs[Qs_finitenonzero], Qs[Qs_finitenonzero]*(1+1e-13), rtol=0.9e-13, atol=0.0)\n    for e in [quaternion.one, quaternion.x, quaternion.y, quaternion.z]:\n        assert quaternion.allclose(Qs[Qs_finite], Qs[Qs_finite]+(1e-13*e), rtol=0.0, atol=1.1e-13)\n        assert ~quaternion.allclose(Qs[Qs_finite], Qs[Qs_finite]+(1e-13*e), rtol=0.0, atol=0.9e-13)\n    assert quaternion.allclose(Qs[Qs_zero], Qs[Qs_zero]*2, rtol=0.0, atol=1.1e-13)\n\n    for qnan in Qs[Qs_nan]:\n        assert ~quaternion.allclose(qnan, qnan, rtol=1.0, atol=1.0)\n        for q in Qs:\n            assert ~quaternion.allclose(q, qnan, rtol=1.0, atol=1.0)\n\n\ndef test_from_spherical_coords():\n    np.random.seed(1843)\n    random_angles = [[np.random.uniform(-np.pi, np.pi), np.random.uniform(-np.pi, np.pi)]\n                     for i in range(5000)]\n    for vartheta, varphi in random_angles:\n        q = quaternion.from_spherical_coords(vartheta, varphi)\n        assert abs((np.quaternion(0, 0, 0, varphi / 2.).exp() * np.quaternion(0, 0, vartheta / 2., 0).exp())\n                   - q) < 1.e-15\n        xprime = q * quaternion.x * q.inverse()\n        yprime = q * quaternion.y * q.inverse()\n        zprime = q * quaternion.z * q.inverse()\n        nhat = np.quaternion(0.0, math.sin(vartheta)*math.cos(varphi), math.sin(vartheta)*math.sin(varphi),\n                             math.cos(vartheta))\n        thetahat = np.quaternion(0.0, math.cos(vartheta)*math.cos(varphi), math.cos(vartheta)*math.sin(varphi),\n                                 -math.sin(vartheta))\n        phihat = np.quaternion(0.0, -math.sin(varphi), math.cos(varphi), 0.0)\n        assert abs(xprime - thetahat) < 1.e-15\n        assert abs(yprime - phihat) < 1.e-15\n        assert abs(zprime - nhat) < 1.e-15\n    assert np.max(np.abs(quaternion.from_spherical_coords(random_angles)\n                         - np.array([quaternion.from_spherical_coords(vartheta, varphi)\n                                     for vartheta, varphi in random_angles]))) < 1.e-15\n\n\ndef test_as_spherical_coords(Rs):\n    np.random.seed(1843)\n    # First test on rotors that are precisely spherical-coordinate rotors\n    random_angles = [[np.random.uniform(0, np.pi), np.random.uniform(0, 2*np.pi)]\n                     for i in range(5000)]\n    for vartheta, varphi in random_angles:\n        vartheta2, varphi2 = quaternion.as_spherical_coords(quaternion.from_spherical_coords(vartheta, varphi))\n        varphi2 = (varphi2 + 2*np.pi) if varphi2 < 0 else varphi2\n        assert abs(vartheta - vartheta2) < 1e-12, ((vartheta, varphi), (vartheta2, varphi2))\n        assert abs(varphi - varphi2) < 1e-12, ((vartheta, varphi), (vartheta2, varphi2))\n    # Now test that arbitrary rotors rotate z to the appropriate location\n    for R in Rs:\n        vartheta, varphi = quaternion.as_spherical_coords(R)\n        R2 = quaternion.from_spherical_coords(vartheta, varphi)\n        assert (R*quaternion.z*R.inverse() - R2*quaternion.z*R2.inverse()).abs() < 4e-15, (R, R2, (vartheta, varphi))\n\n\ndef test_from_euler_angles():\n    np.random.seed(1843)\n    random_angles = [[np.random.uniform(-np.pi, np.pi),\n                      np.random.uniform(-np.pi, np.pi),\n                      np.random.uniform(-np.pi, np.pi)]\n                     for i in range(5000)]\n    for alpha, beta, gamma in random_angles:\n        assert abs((np.quaternion(0, 0, 0, alpha / 2.).exp()\n                    * np.quaternion(0, 0, beta / 2., 0).exp()\n                    * np.quaternion(0, 0, 0, gamma / 2.).exp()\n                   )\n                   - quaternion.from_euler_angles(alpha, beta, gamma)) < 1.e-15\n    assert np.max(np.abs(quaternion.from_euler_angles(random_angles)\n                         - np.array([quaternion.from_euler_angles(alpha, beta, gamma)\n                                     for alpha, beta, gamma in random_angles]))) < 1.e-15\n\n\ndef test_as_euler_angles():\n    np.random.seed(1843)\n    random_angles = [[np.random.uniform(-np.pi, np.pi),\n                      np.random.uniform(-np.pi, np.pi),\n                      np.random.uniform(-np.pi, np.pi)]\n                     for i in range(5000)]\n    for alpha, beta, gamma in random_angles:\n        R1 = quaternion.from_euler_angles(alpha, beta, gamma)\n        R2 = quaternion.from_euler_angles(*list(quaternion.as_euler_angles(R1)))\n        d = quaternion.rotation_intrinsic_distance(R1, R2)\n        assert d < 6e3*eps, ((alpha, beta, gamma), R1, R2, d)  # Can\'t use allclose here; we don\'t care about rotor sign\n    q0 = quaternion.quaternion(0, 0.6, 0.8, 0)\n    assert q0.norm() == 1.0\n    assert abs(q0 - quaternion.from_euler_angles(*list(quaternion.as_euler_angles(q0)))) < 1.e-15\n\n\n# Unary bool returners\ndef test_quaternion_nonzero(Qs):\n    assert not Qs[q_0].nonzero()  # Do this one explicitly, to not use circular logic\n    assert Qs[q_1].nonzero()  # Do this one explicitly, to not use circular logic\n    for q in Qs[Qs_zero]:\n        assert not q.nonzero()\n    for q in Qs[Qs_nonzero]:\n        assert q.nonzero()\n\n\ndef test_quaternion_isnan(Qs):\n    assert not Qs[q_0].isnan()  # Do this one explicitly, to not use circular logic\n    assert not Qs[q_1].isnan()  # Do this one explicitly, to not use circular logic\n    assert Qs[q_nan1].isnan()  # Do this one explicitly, to not use circular logic\n    for q in Qs[Qs_nan]:\n        assert q.isnan()\n    for q in Qs[Qs_nonnan]:\n        assert not q.isnan()\n\n\ndef test_quaternion_isinf(Qs):\n    assert not Qs[q_0].isinf()  # Do this one explicitly, to not use circular logic\n    assert not Qs[q_1].isinf()  # Do this one explicitly, to not use circular logic\n    assert Qs[q_inf1].isinf()  # Do this one explicitly, to not use circular logic\n    assert Qs[q_minf1].isinf()  # Do this one explicitly, to not use circular logic\n    for q in Qs[Qs_inf]:\n        assert q.isinf()\n    for q in Qs[Qs_noninf]:\n        assert not q.isinf()\n\n\ndef test_quaternion_isfinite(Qs):\n    assert not Qs[q_nan1].isfinite()  # Do this one explicitly, to not use circular logic\n    assert not Qs[q_inf1].isfinite()  # Do this one explicitly, to not use circular logic\n    assert not Qs[q_minf1].isfinite()  # Do this one explicitly, to not use circular logic\n    assert Qs[q_0].isfinite()  # Do this one explicitly, to not use circular logic\n    for q in Qs[Qs_nonfinite]:\n        assert not q.isfinite()\n    for q in Qs[Qs_finite]:\n        assert q.isfinite()\n\n\n# Binary bool returners\ndef test_quaternion_equal(Qs):\n    for j in Qs_nonnan:\n        assert Qs[j] == Qs[j]  # self equality\n        for k in range(len(Qs)):  # non-self inequality\n            assert (j == k) or (not (Qs[j] == Qs[k]))\n    for q in Qs:\n        for p in Qs[Qs_nan]:\n            assert not q == p  # nan should never equal anything\n\n\ndef test_quaternion_not_equal(Qs):\n    for j in Qs_nonnan:\n        assert not (Qs[j] != Qs[j])  # self non-not_equality\n        for k in Qs_nonnan:  # non-self not_equality\n            assert (j == k) or (Qs[j] != Qs[k])\n    for q in Qs:\n        for p in Qs[Qs_nan]:\n            assert q != p  # nan should never equal anything\n\n\ndef test_quaternion_richcompare(Qs):\n    for p in Qs:\n        for q in Qs[Qs_nan]:\n            assert not p < q\n            assert not q < p\n            assert not p <= q\n            assert not q <= p\n            assert not p.greater(q)\n            assert not q.greater(p)\n            assert not p.greater_equal(q)\n            assert not q.greater_equal(p)\n    for j in Qs_nonnan:\n        p = Qs[j]\n        assert (p < Qs[q_inf1]) or (j == q_inf1)\n        assert (p <= Qs[q_inf1])\n        assert (Qs[q_minf1] < p) or (j == q_minf1)\n        assert (Qs[q_minf1] <= p)\n        assert (Qs[q_inf1].greater(p)) or (j == q_inf1)\n        assert (Qs[q_inf1].greater_equal(p))\n        assert (p.greater(Qs[q_minf1])) or (j == q_minf1)\n        assert (p.greater_equal(Qs[q_minf1]))\n    for p in [Qs[q_1], Qs[x], Qs[y], Qs[z], Qs[Q], Qs[Qbar]]:\n        assert Qs[q_0] < p\n        assert Qs[q_0] <= p\n        assert p.greater(Qs[q_0])\n        assert p.greater_equal(Qs[q_0])\n    for p in [Qs[Qneg]]:\n        assert p < Qs[q_0]\n        assert p <= Qs[q_0]\n        assert Qs[q_0].greater(p)\n        assert Qs[q_0].greater_equal(p)\n    for p in [Qs[x], Qs[y], Qs[z]]:\n        assert p < Qs[q_1]\n        assert p <= Qs[q_1]\n        assert Qs[q_1].greater(p)\n        assert Qs[q_1].greater_equal(p)\n    for p in [Qs[Qlog], Qs[Qexp]]:\n        assert Qs[q_1] < p\n        assert Qs[q_1] <= p\n        assert p.greater(Qs[q_1])\n        assert p.greater_equal(Qs[q_1])\n\n\n# Unary float returners\ndef test_quaternion_absolute(Qs):\n    for q in Qs[Qs_nan]:\n        assert np.isnan(q.abs())\n    for q in Qs[Qs_inf]:\n        if on_windows:\n            assert np.isinf(q.abs()) or np.isnan(q.abs())\n        else:\n            assert np.isinf(q.abs())\n    for q, a in [(Qs[q_0], 0.0), (Qs[q_1], 1.0), (Qs[x], 1.0), (Qs[y], 1.0), (Qs[z], 1.0),\n                 (Qs[Q], np.sqrt(Qs[Q].w ** 2 + Qs[Q].x ** 2 + Qs[Q].y ** 2 + Qs[Q].z ** 2)),\n                 (Qs[Qbar], np.sqrt(Qs[Q].w ** 2 + Qs[Q].x ** 2 + Qs[Q].y ** 2 + Qs[Q].z ** 2))]:\n        assert np.allclose(q.abs(), a)\n\n\ndef test_quaternion_norm(Qs):\n    for q in Qs[Qs_nan]:\n        assert np.isnan(q.norm())\n    for q in Qs[Qs_inf]:\n        if on_windows:\n            assert np.isinf(q.norm()) or np.isnan(q.norm())\n        else:\n            assert np.isinf(q.norm())\n    for q, a in [(Qs[q_0], 0.0), (Qs[q_1], 1.0), (Qs[x], 1.0), (Qs[y], 1.0), (Qs[z], 1.0),\n                 (Qs[Q], Qs[Q].w ** 2 + Qs[Q].x ** 2 + Qs[Q].y ** 2 + Qs[Q].z ** 2),\n                 (Qs[Qbar], Qs[Q].w ** 2 + Qs[Q].x ** 2 + Qs[Q].y ** 2 + Qs[Q].z ** 2)]:\n        assert np.allclose(q.norm(), a)\n\n\n# Unary quaternion returners\ndef test_quaternion_negative(Qs):\n    assert -Qs[Q] == Qs[Qneg]\n    for q in Qs[Qs_finite]:\n        assert -q == -1.0 * q\n    for q in Qs[Qs_nonnan]:\n        assert -(-q) == q\n\n\ndef test_quaternion_conjugate(Qs):\n    assert Qs[Q].conjugate() == Qs[Qbar]\n    for q in Qs[Qs_nonnan]:\n        assert q.conjugate() == q.conj()\n        assert q.conjugate().conjugate() == q\n        c = q.conjugate()\n        assert c.w == q.w\n        assert c.x == -q.x\n        assert c.y == -q.y\n        assert c.z == -q.z\n\n\ndef test_quaternion_sqrt(Qs):\n    sqrt_precision = 2.e-15\n    for q in Qs[Qs_finitenonzero]:\n        assert allclose(q.sqrt() * q.sqrt(), q, rtol=sqrt_precision)\n        # Ensure that non-unit quaternions are handled correctly\n        for s in [1, -1, 2, -2, 3.4, -3.4]:\n            for r in [1, quaternion.x, quaternion.y, quaternion.z]:\n                srq = s*r*q\n                assert allclose(srq.sqrt() * srq.sqrt(), srq, rtol=sqrt_precision)\n    # Ensure that inputs close to zero are handled gracefully\n    sqrt_dbl_min = math.sqrt(np.finfo(float).tiny)\n    assert quaternion.quaternion(0, 0, 0, 2e-8*sqrt_dbl_min).sqrt() == quaternion.quaternion(0, 0, 0, 0)\n    assert quaternion.quaternion(0, 0, 0, 0.9999*sqrt_dbl_min).sqrt() == quaternion.quaternion(0, 0, 0, 0)\n    assert quaternion.quaternion(0, 0, 0, 1e-16*sqrt_dbl_min).sqrt() == quaternion.quaternion(0, 0, 0, 0)\n    assert quaternion.quaternion(0, 0, 0, 1.1*sqrt_dbl_min).sqrt() != quaternion.quaternion(0, 0, 0, 0)\n\n\ndef test_quaternion_square(Qs):\n    square_precision = 1.e-15\n    for q in Qs[Qs_finite]:\n        assert np.norm(q*q - q**2) < square_precision\n        a = np.array([q])\n        assert np.norm(a**2 - np.array([q**2])) < square_precision\n\n\ndef test_quaternion_log_exp(Qs):\n    qlogexp_precision = 4.e-15\n    assert (Qs[Q].log() - Qs[Qlog]).abs() < qlogexp_precision\n    assert (Qs[Q].exp() - Qs[Qexp]).abs() < qlogexp_precision\n    assert (Qs[Q].log().exp() - Qs[Q]).abs() < qlogexp_precision\n    assert (Qs[Q].exp().log() - Qs[Q]).abs() > qlogexp_precision  # Note order of operations!\n    assert quaternion.one.log() == quaternion.zero\n    assert quaternion.x.log() == (np.pi / 2) * quaternion.x\n    assert quaternion.y.log() == (np.pi / 2) * quaternion.y\n    assert quaternion.z.log() == (np.pi / 2) * quaternion.z\n    assert (-quaternion.one).log() == (np.pi) * quaternion.x\n    strict_assert(False)  # logs of interesting scalars * basis vectors\n    strict_assert(False)  # logs of negative scalars\n\n\ndef test_angle(Rs):\n    angle_precision = 4.e-15\n    unit_vecs = [quaternion.x, quaternion.y, quaternion.z,\n                 -quaternion.x, -quaternion.y, -quaternion.z]\n    for u in unit_vecs:\n        for theta in linspace(-2 * np.pi, 2 * np.pi, num=50):\n            assert abs((theta * u / 2).exp().angle() - abs(theta)) < angle_precision\n\n\ndef test_quaternion_normalized(Qs):\n    assert abs(Qs[Q].normalized()-Qs[Qnormalized]) < 4e-16\n    for q in Qs[Qs_finitenonzero]:\n        assert abs(q.normalized().abs() - 1.0) < 1.e-15\n\n\ndef test_quaternion_parity_conjugates(Qs):\n    for q in Qs[Qs_finite]:\n        assert q.x_parity_conjugate() == np.quaternion(q.w, q.x, -q.y, -q.z)\n        assert q.y_parity_conjugate() == np.quaternion(q.w, -q.x, q.y, -q.z)\n        assert q.z_parity_conjugate() == np.quaternion(q.w, -q.x, -q.y, q.z)\n        assert q.parity_conjugate() == np.quaternion(q.w, q.x, q.y, q.z)\n    assert np.array_equal(np.x_parity_conjugate(Qs[Qs_finite]),\n                          np.array([q.x_parity_conjugate() for q in Qs[Qs_finite]]))\n    assert np.array_equal(np.y_parity_conjugate(Qs[Qs_finite]),\n                          np.array([q.y_parity_conjugate() for q in Qs[Qs_finite]]))\n    assert np.array_equal(np.z_parity_conjugate(Qs[Qs_finite]),\n                          np.array([q.z_parity_conjugate() for q in Qs[Qs_finite]]))\n    assert np.array_equal(np.parity_conjugate(Qs[Qs_finite]), np.array([q.parity_conjugate() for q in Qs[Qs_finite]]))\n\n\n# Quaternion-quaternion binary quaternion returners\n@pytest.mark.xfail\ndef test_quaternion_copysign(Qs):\n    assert False\n\n\n# Quaternion-quaternion, scalar-quaternion, or quaternion-scalar binary quaternion returners\ndef test_quaternion_add(Qs):\n    for j in Qs_nonnan:\n        for k in Qs_nonnan:\n            q = Qs[j]\n            p = Qs[k]\n            assert (q + p == quaternion.quaternion(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z)\n                    or (j == q_inf1 and k == q_minf1)\n                    or (k == q_inf1 and j == q_minf1))\n    for q in Qs[Qs_nonnan]:\n        for s in [-3, -2.3, -1.2, -1.0, 0.0, 0, 1.0, 1, 1.2, 2.3, 3]:\n            assert (q + s == quaternion.quaternion(q.w + s, q.x, q.y, q.z))\n            assert (s + q == quaternion.quaternion(q.w + s, q.x, q.y, q.z))\n\n\ndef test_quaternion_add_ufunc(Qs):\n    ufunc_binary_utility(Qs[Qs_finite], Qs[Qs_finite], operator.add)\n\n\ndef test_quaternion_subtract(Qs):\n    for q in Qs[Qs_finite]:\n        for p in Qs[Qs_finite]:\n            assert q - p == quaternion.quaternion(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z)\n    for q in Qs[Qs_nonnan]:\n        for s in [-3, -2.3, -1.2, -1.0, 0.0, 0, 1.0, 1, 1.2, 2.3, 3]:\n            assert (q - s == quaternion.quaternion(q.w - s, q.x, q.y, q.z))\n            assert (s - q == quaternion.quaternion(s - q.w, -q.x, -q.y, -q.z))\n\n\ndef test_quaternion_subtract_ufunc(Qs):\n    ufunc_binary_utility(Qs[Qs_finite], Qs[Qs_finite], operator.sub)\n\n\ndef test_quaternion_multiply(Qs):\n    # Check scalar multiplication\n    for q in Qs[Qs_finite]:\n        assert q * Qs[q_1] == q\n    for q in Qs[Qs_finite]:\n        assert q * 1.0 == q\n        assert q * 1 == q\n        assert 1.0 * q == q\n        assert 1 * q == q\n    for s in [-3, -2.3, -1.2, -1.0, 0.0, 0, 1.0, 1, 1.2, 2.3, 3]:\n        for q in Qs[Qs_finite]:\n            assert q * s == quaternion.quaternion(s * q.w, s * q.x, s * q.y, s * q.z)\n            assert s * q == q * s\n    for q in Qs[Qs_finite]:\n        assert 0.0 * q == Qs[q_0]\n        assert 0.0 * q == q * 0.0\n\n    # Check linearity\n    for q1 in Qs[Qs_finite]:\n        for q2 in Qs[Qs_finite]:\n            for q3 in Qs[Qs_finite]:\n                assert allclose(q1*(q2+q3), (q1*q2)+(q1*q3))\n                assert allclose((q1+q2)*q3, (q1*q3)+(q2*q3))\n\n    # Check the multiplication table\n    for q in [Qs[q_1], Qs[x], Qs[y], Qs[z]]:\n        assert Qs[q_1] * q == q\n        assert q * Qs[q_1] == q\n    assert Qs[x] * Qs[x] == -Qs[q_1]\n    assert Qs[x] * Qs[y] == Qs[z]\n    assert Qs[x] * Qs[z] == -Qs[y]\n    assert Qs[y] * Qs[x] == -Qs[z]\n    assert Qs[y] * Qs[y] == -Qs[q_1]\n    assert Qs[y] * Qs[z] == Qs[x]\n    assert Qs[z] * Qs[x] == Qs[y]\n    assert Qs[z] * Qs[y] == -Qs[x]\n    assert Qs[z] * Qs[z] == -Qs[q_1]\n\n\ndef test_quaternion_multiply_ufunc(Qs):\n    ufunc_binary_utility(np.array([quaternion.one]), Qs[Qs_finite], operator.mul)\n    ufunc_binary_utility(Qs[Qs_finite], np.array([quaternion.one]), operator.mul)\n    ufunc_binary_utility(np.array([1.0]), Qs[Qs_finite], operator.mul)\n    ufunc_binary_utility(Qs[Qs_finite], np.array([1.0]), operator.mul)\n    ufunc_binary_utility(np.array([1]), Qs[Qs_finite], operator.mul)\n    ufunc_binary_utility(Qs[Qs_finite], np.array([1]), operator.mul)\n    ufunc_binary_utility(np.array([0.0]), Qs[Qs_finite], operator.mul)\n    ufunc_binary_utility(Qs[Qs_finite], np.array([0.0]), operator.mul)\n    ufunc_binary_utility(np.array([0]), Qs[Qs_finite], operator.mul)\n    ufunc_binary_utility(Qs[Qs_finite], np.array([0]), operator.mul)\n\n    ufunc_binary_utility(np.array([-3, -2.3, -1.2, -1.0, 0.0, 0, 1.0, 1, 1.2, 2.3, 3]),\n                         Qs[Qs_finite], operator.mul)\n    ufunc_binary_utility(Qs[Qs_finite],\n                         np.array([-3, -2.3, -1.2, -1.0, 0.0, 0, 1.0, 1, 1.2, 2.3, 3]), operator.mul)\n\n    ufunc_binary_utility(Qs[Qs_finite], Qs[Qs_finite], operator.mul)\n\n\ndef test_quaternion_divide(Qs):\n    # Check identity between ""inverse"" and ""reciprocal""\n    for q in Qs[Qs_finitenonzero]:\n        assert q.inverse() == q.reciprocal()\n\n    # Check scalar division\n    for q in Qs[Qs_finitenonzero]:\n        assert allclose(q / q, quaternion.one)\n        assert allclose(1 / q, q.inverse())\n        assert allclose(1.0 / q, q.inverse())\n        assert 0.0 / q == quaternion.zero\n        for s in [-3, -2.3, -1.2, -1.0, 0.0, 0, 1.0, 1, 1.2, 2.3, 3]:\n            assert allclose(s / q, s * (q.inverse()))\n    for q in Qs[Qs_nonnan]:\n        assert q / 1.0 == q\n        assert q / 1 == q\n        for s in [-3, -2.3, -1.2, -1.0, 1.0, 1, 1.2, 2.3, 3]:\n            assert allclose(q / s, q * (1.0/s))\n\n    # Check linearity\n    for q1 in Qs[Qs_finite]:\n        for q2 in Qs[Qs_finite]:\n            for q3 in Qs[Qs_finitenonzero]:\n                assert allclose((q1+q2)/q3, (q1/q3)+(q2/q3))\n\n    # Check the multiplication table\n    for q in [Qs[q_1], Qs[x], Qs[y], Qs[z]]:\n        assert Qs[q_1] / q == q.conj()\n        assert q / Qs[q_1] == q\n    assert Qs[x] / Qs[x] == Qs[q_1]\n    assert Qs[x] / Qs[y] == -Qs[z]\n    assert Qs[x] / Qs[z] == Qs[y]\n    assert Qs[y] / Qs[x] == Qs[z]\n    assert Qs[y] / Qs[y] == Qs[q_1]\n    assert Qs[y] / Qs[z] == -Qs[x]\n    assert Qs[z] / Qs[x] == -Qs[y]\n    assert Qs[z] / Qs[y] == Qs[x]\n    assert Qs[z] / Qs[z] == Qs[q_1]\n\n\ndef test_quaternion_divide_ufunc(Qs):\n    ufunc_binary_utility(np.array([quaternion.one]), Qs[Qs_finitenonzero], operator.truediv)\n    ufunc_binary_utility(Qs[Qs_finite], np.array([quaternion.one]), operator.truediv)\n    ufunc_binary_utility(np.array([1.0]), Qs[Qs_finitenonzero], operator.truediv)\n    ufunc_binary_utility(Qs[Qs_finite], np.array([1.0]), operator.truediv)\n    ufunc_binary_utility(np.array([1]), Qs[Qs_finitenonzero], operator.truediv)\n    ufunc_binary_utility(Qs[Qs_finite], np.array([1]), operator.truediv)\n    ufunc_binary_utility(np.array([0.0]), Qs[Qs_finitenonzero], operator.truediv)\n    ufunc_binary_utility(np.array([0]), Qs[Qs_finitenonzero], operator.truediv)\n\n    ufunc_binary_utility(np.array([-3, -2.3, -1.2, -1.0, 0.0, 0, 1.0, 1, 1.2, 2.3, 3]),\n                         Qs[Qs_finitenonzero], operator.truediv)\n    ufunc_binary_utility(Qs[Qs_finitenonzero],\n                         np.array([-3, -2.3, -1.2, -1.0, 1.0, 1, 1.2, 2.3, 3]), operator.truediv)\n\n    ufunc_binary_utility(Qs[Qs_finite], Qs[Qs_finitenonzero], operator.truediv)\n    ufunc_binary_utility(Qs[Qs_finite], Qs[Qs_finitenonzero], operator.floordiv)\n\n    ufunc_binary_utility(Qs[Qs_finitenonzero], Qs[Qs_finitenonzero], operator.truediv)\n    ufunc_binary_utility(Qs[Qs_finitenonzero], Qs[Qs_finitenonzero], operator.floordiv)\n\n\ndef test_quaternion_power(Qs):\n    import math\n    qpower_precision = 4*eps\n\n    # Test equivalence between scalar and real-quaternion exponentiation\n    for b in [0, 0.0, 1, 1.0, 2, 2.0, 5.6]:\n        for e in [0, 0.0, 1, 1.0, 2, 2.0, 4.5]:\n            be = np.quaternion(b**e, 0, 0, 0)\n            assert allclose(be, np.quaternion(b, 0, 0, 0)**np.quaternion(e, 0, 0, 0), rtol=qpower_precision)\n            assert allclose(be, b**np.quaternion(e, 0, 0, 0), rtol=qpower_precision)\n            assert allclose(be, np.quaternion(b, 0, 0, 0)**e, rtol=qpower_precision)\n    for q in [-3*quaternion.one, -2*quaternion.one, -quaternion.one, quaternion.zero, quaternion.one, 3*quaternion.one]:\n        for s in [-3, -2.3, -1.2, -1.0, 1.0, 1, 1.2, 2.3, 3]:\n            for t in [-3, -2.3, -1.2, -1.0, 1.0, 1, 1.2, 2.3, 3]:\n                assert allclose((s*t)**q, (s**q)*(t**q), rtol=2*qpower_precision)\n\n    # Test basic integer-exponent and additive-exponent properties\n    for q in Qs[Qs_finitenonzero]:\n        assert allclose(q ** 0, np.quaternion(1, 0, 0, 0), rtol=qpower_precision)\n        assert allclose(q ** 0.0, np.quaternion(1, 0, 0, 0), rtol=qpower_precision)\n        assert allclose(q ** np.quaternion(0, 0, 0, 0), np.quaternion(1, 0, 0, 0), rtol=qpower_precision)\n        assert allclose(((q ** 0.5) * (q ** 0.5)), q, rtol=qpower_precision)\n        assert allclose(q ** 1.0, q, rtol=qpower_precision)\n        assert allclose(q ** 1, q, rtol=qpower_precision)\n        assert allclose(q ** np.quaternion(1, 0, 0, 0), q, rtol=qpower_precision)\n        assert allclose(q ** 2.0, q * q, rtol=qpower_precision)\n        assert allclose(q ** 2, q * q, rtol=qpower_precision)\n        assert allclose(q ** np.quaternion(2, 0, 0, 0), q * q, rtol=qpower_precision)\n        assert allclose(q ** 3, q * q * q, rtol=qpower_precision)\n        assert allclose(q ** -1, q.inverse(), rtol=qpower_precision)\n        assert allclose(q ** -1.0, q.inverse(), rtol=qpower_precision)\n        for s in [-3, -2.3, -1.2, -1.0, 1.0, 1, 1.2, 2.3, 3]:\n            for t in [-3, -2.3, -1.2, -1.0, 1.0, 1, 1.2, 2.3, 3]:\n                assert allclose(q**(s+t), (q**s)*(q**t), rtol=2*qpower_precision)\n                assert allclose(q**(s-t), (q**s)/(q**t), rtol=2*qpower_precision)\n\n    # Check that exp(q) is the same as e**q\n    for q in Qs[Qs_finitenonzero]:\n        assert allclose(q.exp(), math.e**q, rtol=qpower_precision)\n        for s in [0, 0., 1.0, 1, 1.2, 2.3, 3]:\n            for t in [0, 0., 1.0, 1, 1.2, 2.3, 3]:\n                assert allclose((s*t)**q, (s**q)*(t**q), rtol=2*qpower_precision)\n        for s in [1.0, 1, 1.2, 2.3, 3]:\n            assert allclose(s**q, (q*math.log(s)).exp(), rtol=qpower_precision)\n\n    qinverse_precision = 2*eps\n    for q in Qs[Qs_finitenonzero]:\n        assert allclose((q ** -1.0) * q, Qs[q_1], rtol=qinverse_precision)\n    for q in Qs[Qs_finitenonzero]:\n        assert allclose((q ** -1) * q, Qs[q_1], rtol=qinverse_precision)\n    for q in Qs[Qs_finitenonzero]:\n        assert allclose((q ** Qs[q_1]), q, rtol=qpower_precision)\n    strict_assert(False)  # Try more edge cases\n\n    for q in [quaternion.x, quaternion.y, quaternion.z]:\n        assert allclose(quaternion.quaternion(math.exp(-math.pi/2), 0, 0, 0),\n                        q**q, rtol=qpower_precision)\n    assert allclose(quaternion.quaternion(math.cos(math.pi/2), 0, 0, math.sin(math.pi/2)),\n                    quaternion.x**quaternion.y, rtol=qpower_precision)\n    assert allclose(quaternion.quaternion(math.cos(math.pi/2), 0, -math.sin(math.pi/2), 0),\n                    quaternion.x**quaternion.z, rtol=qpower_precision)\n    assert allclose(quaternion.quaternion(math.cos(math.pi/2), 0, 0, -math.sin(math.pi/2)),\n                    quaternion.y**quaternion.x, rtol=qpower_precision)\n    assert allclose(quaternion.quaternion(math.cos(math.pi/2), math.sin(math.pi/2), 0, 0),\n                    quaternion.y**quaternion.z, rtol=qpower_precision)\n    assert allclose(quaternion.quaternion(math.cos(math.pi/2), 0, math.sin(math.pi/2), 0),\n                    quaternion.z**quaternion.x, rtol=qpower_precision)\n    assert allclose(quaternion.quaternion(math.cos(math.pi/2), -math.sin(math.pi/2), 0, 0),\n                    quaternion.z**quaternion.y, rtol=qpower_precision)\n\n\n\ndef test_quaternion_getset(Qs):\n    # get parts a and b\n    for q in Qs[Qs_nonnan]:\n        assert q.a == q.w + 1j * q.z\n        assert q.b == q.y + 1j * q.x\n    # Check multiplication law for parts a and b\n    part_mul_precision = 1.e-14\n    for p in Qs[Qs_finite]:\n        for q in Qs[Qs_finite]:\n            assert abs((p * q).a - (p.a * q.a - p.b.conjugate() * q.b)) < part_mul_precision\n            assert abs((p * q).b - (p.b * q.a + p.a.conjugate() * q.b)) < part_mul_precision\n    # get components/vec\n    for q in Qs[Qs_nonnan]:\n        assert np.array_equal(q.components, np.array([q.w, q.x, q.y, q.z]))\n        assert np.array_equal(q.vec, np.array([q.x, q.y, q.z]))\n        assert np.array_equal(q.imag, np.array([q.x, q.y, q.z]))\n    # set components/vec from np.array, list, tuple\n    for q in Qs[Qs_nonnan]:\n        for seq_type in [np.array, list, tuple]:\n            p = np.quaternion(*q.components)\n            r = np.quaternion(*q.components)\n            s = np.quaternion(*q.components)\n            p.components = seq_type((-5.5, 6.6, -7.7, 8.8))\n            r.vec = seq_type((6.6, -7.7, 8.8))\n            s.imag = seq_type((6.6, -7.7, 8.8))\n            assert np.array_equal(p.components, np.array([-5.5, 6.6, -7.7, 8.8]))\n            assert np.array_equal(r.components, np.array([q.w, 6.6, -7.7, 8.8]))\n            assert np.array_equal(s.components, np.array([q.w, 6.6, -7.7, 8.8]))\n    # TypeError when setting components with the wrong type or size of thing\n    for q in Qs:\n        for seq_type in [np.array, list, tuple]:\n            p = np.quaternion(*q.components)\n            r = np.quaternion(*q.components)\n            s = np.quaternion(*q.components)\n            with pytest.raises(TypeError):\n                p.components = \'1.1, 2.2, 3.3, 4.4\'\n            with pytest.raises(TypeError):\n                p.components = seq_type([])\n            with pytest.raises(TypeError):\n                p.components = seq_type((-5.5,))\n            with pytest.raises(TypeError):\n                p.components = seq_type((-5.5, 6.6,))\n            with pytest.raises(TypeError):\n                p.components = seq_type((-5.5, 6.6, -7.7,))\n            with pytest.raises(TypeError):\n                p.components = seq_type((-5.5, 6.6, -7.7, 8.8, -9.9))\n            with pytest.raises(TypeError):\n                r.vec = \'2.2, 3.3, 4.4\'\n            with pytest.raises(TypeError):\n                r.vec = seq_type([])\n            with pytest.raises(TypeError):\n                r.vec = seq_type((-5.5,))\n            with pytest.raises(TypeError):\n                r.vec = seq_type((-5.5, 6.6))\n            with pytest.raises(TypeError):\n                r.vec = seq_type((-5.5, 6.6, -7.7, 8.8))\n            with pytest.raises(TypeError):\n                s.vec = \'2.2, 3.3, 4.4\'\n            with pytest.raises(TypeError):\n                s.vec = seq_type([])\n            with pytest.raises(TypeError):\n                s.vec = seq_type((-5.5,))\n            with pytest.raises(TypeError):\n                s.vec = seq_type((-5.5, 6.6))\n            with pytest.raises(TypeError):\n                s.vec = seq_type((-5.5, 6.6, -7.7, 8.8))\n\n\ndef test_metrics(Rs):\n    metric_precision = 4.e-15\n    intrinsic_funcs = (quaternion.rotor_intrinsic_distance, quaternion.rotation_intrinsic_distance)\n    chordal_funcs = (quaternion.rotor_chordal_distance, quaternion.rotation_chordal_distance)\n    metric_funcs = intrinsic_funcs + chordal_funcs\n    rotor_funcs = (quaternion.rotor_intrinsic_distance, quaternion.rotor_chordal_distance)\n    rotation_funcs = (quaternion.rotation_intrinsic_distance, quaternion.rotation_chordal_distance)\n    distance_dict = {func: func(Rs, Rs[:, np.newaxis]) for func in metric_funcs}\n\n    # Check non-negativity\n    for mat in distance_dict.values():\n        assert (mat >= 0.).all()\n\n    # Check discernibility\n    for func in metric_funcs:\n        if func in chordal_funcs:\n            eps = 0\n        else:\n            eps = 5.e-16\n        if func in rotor_funcs:\n            target = Rs != Rs[:, np.newaxis]\n        else:\n            target = np.logical_and(Rs != Rs[:, np.newaxis], Rs != - Rs[:, np.newaxis])\n        assert ((distance_dict[func] > eps) == target).all()\n\n    # Check symmetry\n    for mat in distance_dict.values():\n        assert np.allclose(mat, mat.T, atol=metric_precision, rtol=0)\n\n    # Check triangle inequality\n    for mat in distance_dict.values():\n        assert ((mat - metric_precision)[:, np.newaxis, :] <= mat[:, :, np.newaxis] + mat).all()\n\n    # Check distances from self or -self\n    for func in metric_funcs:\n        # All distances from self should be 0.0\n        if func in chordal_funcs:\n            eps = 0\n        else:\n            eps = 5.e-16\n        assert (np.diag(distance_dict[func]) <= eps).all()\n\n    # Chordal rotor distance from -self should be 2\n    assert (abs(quaternion.rotor_chordal_distance(Rs, -Rs) - 2.0) < metric_precision).all()\n    # Intrinsic rotor distance from -self should be 2pi\n    assert (abs(quaternion.rotor_intrinsic_distance(Rs, -Rs) - 2.0 * np.pi) < metric_precision).all()\n    # Rotation distances from -self should be 0\n    assert (quaternion.rotation_chordal_distance(Rs, -Rs) == 0.0).all()\n    assert (quaternion.rotation_intrinsic_distance(Rs, -Rs) < 5.e-16).all()\n\n    # We expect the chordal distance to be smaller than the intrinsic distance (or equal, if the distance is zero)\n    assert np.logical_or(quaternion.rotor_chordal_distance(quaternion.one, Rs)\n                           < quaternion.rotor_intrinsic_distance(quaternion.one, Rs),\n                         Rs == quaternion.one).all()\n    # Check invariance under overall rotations: d(R1, R2) = d(R3*R1, R3*R2) = d(R1*R3, R2*R3)\n    for func in quaternion.rotor_chordal_distance, quaternion.rotation_intrinsic_distance:\n        rotations = Rs[:, np.newaxis] * Rs\n        right_distances = func(rotations, rotations[:, np.newaxis])\n        assert (abs(distance_dict[func][:, :, np.newaxis] - right_distances) < metric_precision).all()\n        left_distances = func(rotations[:, :, np.newaxis], rotations[:, np.newaxis])\n        assert (abs(distance_dict[func] - left_distances) < metric_precision).all()\n\n\ndef test_slerp(Rs):\n    from quaternion import slerp_evaluate, slerp, allclose\n    slerp_precision = 4.e-15\n    ones = [quaternion.one, quaternion.x, quaternion.y, quaternion.z, -quaternion.x, -quaternion.y, -quaternion.z]\n    # Check extremes\n    for Q1 in ones:\n        assert quaternion.rotation_chordal_distance(slerp_evaluate(Q1, Q1, 0.0), Q1) < slerp_precision\n        assert quaternion.rotation_chordal_distance(slerp_evaluate(Q1, Q1, 1.0), Q1) < slerp_precision\n        assert quaternion.rotation_chordal_distance(slerp_evaluate(Q1, -Q1, 0.0), Q1) < slerp_precision\n        assert quaternion.rotation_chordal_distance(slerp_evaluate(Q1, -Q1, 1.0), Q1) < slerp_precision\n        for Q2 in ones:\n            assert quaternion.rotation_chordal_distance(slerp_evaluate(Q1, Q2, 0.0), Q1) < slerp_precision\n            assert quaternion.rotation_chordal_distance(slerp_evaluate(Q1, Q2, 1.0), Q2) < slerp_precision\n            assert quaternion.rotation_chordal_distance(slerp_evaluate(Q1, -Q2, 0.0), Q1) < slerp_precision\n            assert quaternion.rotation_chordal_distance(slerp_evaluate(Q1, -Q2, 1.0), -Q2) < slerp_precision\n            assert quaternion.rotation_chordal_distance(slerp_evaluate(Q2, Q1, 0.0), Q2) < slerp_precision\n            assert quaternion.rotation_chordal_distance(slerp_evaluate(Q2, Q1, 1.0), Q1) < slerp_precision\n    # Test simple increases in each dimension\n    for Q2 in ones[1:]:\n        for t in np.linspace(0.0, 1.0, num=100, endpoint=True):\n            assert quaternion.rotation_chordal_distance(slerp_evaluate(quaternion.one, Q2, t),\n                                                        (np.cos(np.pi * t / 2) * quaternion.one + np.sin(\n                                                            np.pi * t / 2) * Q2)) < slerp_precision\n        t = np.linspace(0.0, 1.0, num=100, endpoint=True)\n        assert allclose(slerp(quaternion.one, Q2, 0.0, 1.0, t),\n                        np.cos(np.pi * t / 2) * quaternion.one + np.sin(np.pi * t / 2) * Q2, verbose=True)\n        assert allclose(slerp(quaternion.one, Q2, -10.0, 20.0, 30 * t - 10.0),\n                        np.cos(np.pi * t / 2) * quaternion.one + np.sin(np.pi * t / 2) * Q2, verbose=True)\n        t = 1.5 * t - 0.125\n        assert allclose(slerp(quaternion.one, Q2, 0.0, 1.0, t),\n                        np.cos(np.pi * t / 2) * quaternion.one + np.sin(np.pi * t / 2) * Q2, verbose=True)\n    # Test that (slerp of rotated rotors) is (rotated slerp of rotors)\n    for R in Rs:\n        for Q2 in ones[1:]:\n            for t in np.linspace(0.0, 1.0, num=100, endpoint=True):\n                assert quaternion.rotation_chordal_distance(R * slerp_evaluate(quaternion.one, Q2, t),\n                                                            slerp_evaluate(R * quaternion.one, R * Q2,\n                                                                             t)) < slerp_precision\n            t = np.linspace(0.0, 1.0, num=100, endpoint=True)\n            assert allclose(R * slerp(quaternion.one, Q2, 0.0, 1.0, t),\n                            slerp(R * quaternion.one, R * Q2, 0.0, 1.0, t),\n                            verbose=True)\n\n\n@pytest.mark.skipif(os.environ.get(\'FAST\'), reason=""Takes ~2 seconds"")\ndef test_squad(Rs):\n    from quaternion import slerp_evaluate\n    np.random.seed(1234)\n    squad_precision = 4.e-15\n    ones = [quaternion.one, quaternion.x, quaternion.y, quaternion.z, -quaternion.x, -quaternion.y, -quaternion.z]\n    t_in = np.linspace(0.0, 1.0, num=13, endpoint=True)\n    t_out = np.linspace(0.0, 1.0, num=37, endpoint=True)\n    t_out2 = np.array(sorted([np.random.uniform(0.0, 1.0) for i in range(59)]))\n    # squad interpolated onto the inputs should be the identity\n    for R1 in Rs:\n        for R2 in Rs:\n            R_in = np.array([slerp_evaluate(R1, R2, t) for t in t_in])\n            assert np.all(np.abs(quaternion.squad(R_in, t_in, t_in) - R_in) < squad_precision)\n    # squad should be the same as slerp for linear interpolation\n    for R in ones:\n        R_in = np.array([slerp_evaluate(quaternion.one, R, t) for t in t_in])\n        R_out_squad = quaternion.squad(R_in, t_in, t_out)\n        R_out_slerp = np.array([slerp_evaluate(quaternion.one, R, t) for t in t_out])\n        # print(\n        #     R, ""\\n"",\n        #     np.argmax(np.abs(R_out_squad - R_out_slerp)),\n        #     len(R_out_squad), ""\\n"",\n        #     np.max(np.abs(R_out_squad - R_out_slerp)), ""\\n"",\n        #     R_out_squad[-6:], ""\\n"",\n        #     R_out_slerp[-6:],\n        # )\n        assert np.all(np.abs(R_out_squad - R_out_slerp) < squad_precision), (\n            R,\n            np.argmax(np.abs(R_out_squad - R_out_slerp)),\n            len(R_out_squad),\n            R_out_squad[np.argmax(np.abs(R_out_squad - R_out_slerp))-2:np.argmax(np.abs(R_out_squad - R_out_slerp))+3],\n            R_out_slerp[np.argmax(np.abs(R_out_squad - R_out_slerp))-2:np.argmax(np.abs(R_out_squad - R_out_slerp))+3],\n        )\n        R_out_squad = quaternion.squad(R_in, t_in, t_out2)\n        R_out_slerp = np.array([slerp_evaluate(quaternion.one, R, t) for t in t_out2])\n        assert np.all(np.abs(R_out_squad - R_out_slerp) < squad_precision)\n        # assert False # Test unequal input time steps, and correct squad output [0,-2,-1]\n\n    for i in range(len(ones)):\n        R3 = np.roll(ones, i)[:3]\n        R_in = np.array([[slerp_evaluate(quaternion.one, R, t) for R in R3] for t in t_in])\n        R_out_squad = quaternion.squad(R_in, t_in, t_out)\n        R_out_slerp = np.array([[slerp_evaluate(quaternion.one, R, t) for R in R3] for t in t_out])\n        assert np.all(np.abs(R_out_squad - R_out_slerp) < squad_precision), (\n            R,\n            np.argmax(np.abs(R_out_squad - R_out_slerp)),\n            len(R_out_squad),\n            R_out_squad[np.argmax(np.abs(R_out_squad - R_out_slerp))-2:np.argmax(np.abs(R_out_squad - R_out_slerp))+3],\n            R_out_slerp[np.argmax(np.abs(R_out_squad - R_out_slerp))-2:np.argmax(np.abs(R_out_squad - R_out_slerp))+3],\n        )\n        R_out_squad = quaternion.squad(R_in, t_in, t_out2)\n        R_out_slerp = np.array([[slerp_evaluate(quaternion.one, R, t) for R in R3] for t in t_out2])\n        assert np.all(np.abs(R_out_squad - R_out_slerp) < squad_precision)\n\n\n@pytest.mark.xfail\ndef test_arrfuncs():\n    # nonzero\n    # copyswap\n    # copyswapn\n    # getitem\n    # setitem\n    # compare\n    # argmax\n    # fillwithscalar\n    assert False\n\n\ndef test_setitem_quat(Qs):\n    Ps = Qs.copy()\n    # setitem from quaternion\n    for j in range(len(Ps)):\n        Ps[j] = np.quaternion(1.3, 2.4, 3.5, 4.7)\n        for k in range(j + 1):\n            assert Ps[k] == np.quaternion(1.3, 2.4, 3.5, 4.7)\n        for k in range(j + 1, len(Ps)):\n            assert Ps[k] == Qs[k]\n    # setitem from np.array, list, or tuple\n    for seq_type in [np.array, list, tuple]:\n        Ps = Qs.copy()\n        with pytest.raises(TypeError):\n            Ps[0] = seq_type(())\n        with pytest.raises(TypeError):\n            Ps[0] = seq_type((1.3,))\n        with pytest.raises(TypeError):\n            Ps[0] = seq_type((1.3, 2.4,))\n        with pytest.raises(TypeError):\n            Ps[0] = seq_type((1.3, 2.4, 3.5))\n        with pytest.raises(TypeError):\n            Ps[0] = seq_type((1.3, 2.4, 3.5, 4.7, 5.9))\n        with pytest.raises(TypeError):\n            Ps[0] = seq_type((1.3, 2.4, 3.5, 4.7, 5.9, np.nan))\n        for j in range(len(Ps)):\n            Ps[j] = seq_type((1.3, 2.4, 3.5, 4.7))\n            for k in range(j + 1):\n                assert Ps[k] == np.quaternion(1.3, 2.4, 3.5, 4.7)\n            for k in range(j + 1, len(Ps)):\n                assert Ps[k] == Qs[k]\n    with pytest.raises(TypeError):\n        Ps[0] = \'s\'\n    with pytest.raises(TypeError):\n        Ps[0] = \'s\'\n\n\n@pytest.mark.xfail\ndef test_arraydescr():\n    # new\n    # richcompare\n    # hash\n    # repr\n    # str\n    assert False\n\n\n@pytest.mark.xfail\ndef test_casts():\n    # FLOAT, npy_float\n    # DOUBLE, npy_double\n    # LONGDOUBLE, npy_longdouble\n    # BOOL, npy_bool\n    # BYTE, npy_byte\n    # UBYTE, npy_ubyte\n    # SHORT, npy_short\n    # USHORT, npy_ushort\n    # INT, npy_int\n    # UINT, npy_uint\n    # LONG, npy_long\n    # ULONG, npy_ulong\n    # LONGLONG, npy_longlong\n    # ULONGLONG, npy_ulonglong\n    # CFLOAT, npy_float\n    # CDOUBLE, npy_double\n    # CLONGDOUBLE, npy_longdouble\n    assert False\n\n\ndef test_ufuncs(Rs, Qs):\n    np.random.seed(1234)\n    assert np.allclose(np.abs(Rs), np.ones(Rs.shape), atol=1.e-14, rtol=1.e-15)\n    assert np.allclose(np.abs(np.log(Rs) - np.array([r.log() for r in Rs])), np.zeros(Rs.shape), atol=1.e-14,\n                       rtol=1.e-15)\n    assert np.allclose(np.abs(np.exp(Rs) - np.array([r.exp() for r in Rs])), np.zeros(Rs.shape), atol=1.e-14,\n                       rtol=1.e-15)\n    assert np.allclose(np.abs(Rs - Rs), np.zeros(Rs.shape), atol=1.e-14, rtol=1.e-15)\n    assert np.allclose(np.abs(Rs + (-Rs)), np.zeros(Rs.shape), atol=1.e-14, rtol=1.e-15)\n    assert np.allclose(np.abs(np.conjugate(Rs) - np.array([r.conjugate() for r in Rs])), np.zeros(Rs.shape),\n                       atol=1.e-14, rtol=1.e-15)\n    assert np.all(Rs == Rs)\n    assert np.all(Rs <= Rs)\n    for i in range(10):\n        x = np.random.uniform(-10, 10)\n        assert np.allclose(np.abs(Rs * x - np.array([r * x for r in Rs])), np.zeros(Rs.shape), atol=1.e-14, rtol=1.e-15)\n        # assert np.allclose( np.abs( x*Rs - np.array([r*x for r in Rs]) ), np.zeros(Rs.shape), atol=1.e-14, rtol=1.e-15)\n        strict_assert(False)\n        assert np.allclose(np.abs(Rs / x - np.array([r / x for r in Rs])), np.zeros(Rs.shape), atol=1.e-14, rtol=1.e-15)\n        assert np.allclose(np.abs(Rs ** x - np.array([r ** x for r in Rs])), np.zeros(Rs.shape), atol=1.e-14,\n                           rtol=1.e-15)\n    assert np.allclose(\n        np.abs(Qs[Qs_finite] + Qs[Qs_finite] - np.array([q1 + q2 for q1, q2 in zip(Qs[Qs_finite], Qs[Qs_finite])])),\n        np.zeros(Qs[Qs_finite].shape), atol=1.e-14, rtol=1.e-15)\n    assert np.allclose(\n        np.abs(Qs[Qs_finite] - Qs[Qs_finite] - np.array([q1 - q2 for q1, q2 in zip(Qs[Qs_finite], Qs[Qs_finite])])),\n        np.zeros(Qs[Qs_finite].shape), atol=1.e-14, rtol=1.e-15)\n    assert np.allclose(\n        np.abs(Qs[Qs_finite] * Qs[Qs_finite] - np.array([q1 * q2 for q1, q2 in zip(Qs[Qs_finite], Qs[Qs_finite])])),\n        np.zeros(Qs[Qs_finite].shape), atol=1.e-14, rtol=1.e-15)\n    for Q in Qs[Qs_finite]:\n        assert np.allclose(np.abs(Qs[Qs_finite] * Q - np.array([q1 * Q for q1 in Qs[Qs_finite]])),\n                           np.zeros(Qs[Qs_finite].shape), atol=1.e-14, rtol=1.e-15)\n        # assert np.allclose( np.abs( Q*Qs[Qs_finite] - np.array([Q*q1 for q1 in Qs[Qs_finite]]) ),\n        # np.zeros(Qs[Qs_finite].shape), atol=1.e-14, rtol=1.e-15)\n    assert np.allclose(np.abs(Qs[Qs_finitenonzero] / Qs[Qs_finitenonzero]\n                              - np.array([q1 / q2 for q1, q2 in zip(Qs[Qs_finitenonzero], Qs[Qs_finitenonzero])])),\n                       np.zeros(Qs[Qs_finitenonzero].shape), atol=1.e-14, rtol=1.e-15)\n    assert np.allclose(np.abs(Qs[Qs_finitenonzero] ** Qs[Qs_finitenonzero]\n                              - np.array([q1 ** q2 for q1, q2 in zip(Qs[Qs_finitenonzero], Qs[Qs_finitenonzero])])),\n                       np.zeros(Qs[Qs_finitenonzero].shape), atol=1.e-14, rtol=1.e-15)\n    assert np.allclose(np.abs(~Qs[Qs_finitenonzero]\n                              - np.array([q.inverse() for q in Qs[Qs_finitenonzero]])),\n                       np.zeros(Qs[Qs_finitenonzero].shape), atol=1.e-14, rtol=1.e-15)\n\n\n@pytest.mark.parametrize(\n    (""ufunc"",),\n    [\n        # Complete list obtained from from https://docs.scipy.org/doc/numpy/reference/ufuncs.html on Sep 30, 2019\n        (np.add,),\n        (np.subtract,),\n        (np.multiply,),\n        (np.divide,),\n        (np.true_divide,),\n        (np.floor_divide,),\n        (np.negative,),\n        (np.positive,),\n        (np.power,),\n        (np.absolute,),\n        (np.conj,),\n        (np.conjugate,),\n        (np.exp,),\n        (np.log,),\n        (np.sqrt,),\n        (np.square,),\n        (np.reciprocal,),\n        (np.invert,),\n        (np.less,),\n        (np.less_equal,),\n        (np.not_equal,),\n        (np.equal,),\n        (np.isfinite,),\n        (np.isinf,),\n        (np.isnan,),\n        (np.copysign,),\n        pytest.param(np.logaddexp, marks=pytest.mark.xfail),\n        pytest.param(np.logaddexp2, marks=pytest.mark.xfail),\n        pytest.param(np.remainder, marks=pytest.mark.xfail),\n        pytest.param(np.mod, marks=pytest.mark.xfail),\n        pytest.param(np.fmod, marks=pytest.mark.xfail),\n        pytest.param(np.divmod, marks=pytest.mark.xfail),\n        pytest.param(np.fabs, marks=pytest.mark.xfail),\n        pytest.param(np.rint, marks=pytest.mark.xfail),\n        pytest.param(np.sign, marks=pytest.mark.xfail),\n        pytest.param(np.heaviside, marks=pytest.mark.xfail),\n        pytest.param(np.exp2, marks=pytest.mark.xfail),\n        pytest.param(np.log2, marks=pytest.mark.xfail),\n        pytest.param(np.log10, marks=pytest.mark.xfail),\n        pytest.param(np.expm1, marks=pytest.mark.xfail),\n        pytest.param(np.log1p, marks=pytest.mark.xfail),\n        pytest.param(np.cbrt, marks=pytest.mark.xfail),\n        pytest.param(np.gcd, marks=pytest.mark.xfail),\n        pytest.param(np.lcm, marks=pytest.mark.xfail),\n        pytest.param(np.sin, marks=pytest.mark.xfail),\n        pytest.param(np.cos, marks=pytest.mark.xfail),\n        pytest.param(np.tan, marks=pytest.mark.xfail),\n        pytest.param(np.arcsin, marks=pytest.mark.xfail),\n        pytest.param(np.arccos, marks=pytest.mark.xfail),\n        pytest.param(np.arctan, marks=pytest.mark.xfail),\n        pytest.param(np.arctan2, marks=pytest.mark.xfail),\n        pytest.param(np.hypot, marks=pytest.mark.xfail),\n        pytest.param(np.sinh, marks=pytest.mark.xfail),\n        pytest.param(np.cosh, marks=pytest.mark.xfail),\n        pytest.param(np.tanh, marks=pytest.mark.xfail),\n        pytest.param(np.arcsinh, marks=pytest.mark.xfail),\n        pytest.param(np.arccosh, marks=pytest.mark.xfail),\n        pytest.param(np.arctanh, marks=pytest.mark.xfail),\n        pytest.param(np.deg2rad, marks=pytest.mark.xfail),\n        pytest.param(np.rad2deg, marks=pytest.mark.xfail),\n        pytest.param(np.bitwise_and, marks=pytest.mark.xfail),\n        pytest.param(np.bitwise_or, marks=pytest.mark.xfail),\n        pytest.param(np.bitwise_xor, marks=pytest.mark.xfail),\n        pytest.param(np.left_shift, marks=pytest.mark.xfail),\n        pytest.param(np.right_shift, marks=pytest.mark.xfail),\n        pytest.param(np.greater, marks=pytest.mark.xfail),\n        pytest.param(np.greater_equal, marks=pytest.mark.xfail),\n        pytest.param(np.logical_and, marks=pytest.mark.xfail),\n        pytest.param(np.logical_or, marks=pytest.mark.xfail),\n        pytest.param(np.logical_xor, marks=pytest.mark.xfail),\n        pytest.param(np.logical_not, marks=pytest.mark.xfail),\n        pytest.param(np.maximum, marks=pytest.mark.xfail),\n        pytest.param(np.minimum, marks=pytest.mark.xfail),\n        pytest.param(np.fmax, marks=pytest.mark.xfail),\n        pytest.param(np.fmin, marks=pytest.mark.xfail),\n        pytest.param(np.isnat, marks=pytest.mark.xfail),\n        pytest.param(np.fabs, marks=pytest.mark.xfail),\n        pytest.param(np.signbit, marks=pytest.mark.xfail),\n        pytest.param(np.nextafter, marks=pytest.mark.xfail),\n        pytest.param(np.spacing, marks=pytest.mark.xfail),\n        pytest.param(np.modf, marks=pytest.mark.xfail),\n        pytest.param(np.ldexp, marks=pytest.mark.xfail),\n        pytest.param(np.frexp, marks=pytest.mark.xfail),\n        pytest.param(np.fmod, marks=pytest.mark.xfail),\n        pytest.param(np.floor, marks=pytest.mark.xfail),\n        pytest.param(np.ceil, marks=pytest.mark.xfail),\n        pytest.param(np.trunc, marks=pytest.mark.xfail),\n    ],\n    ids=lambda uf:uf.__name__\n)\ndef test_ufunc_existence(ufunc):\n    qarray = Qs_array[Qs_finitenonzero]\n    if ufunc.nin == 1:\n        result = ufunc(qarray)\n    elif ufunc.nin == 2:\n        result = ufunc(qarray, qarray)\n\n\ndef test_numpy_array_conversion(Qs):\n    ""Check conversions between array as quaternions and array as floats""\n    # First, just check 1-d array\n    Q = Qs[Qs_nonnan][:12]  # Select first 3x4=12 non-nan elements in Qs\n    assert Q.dtype == np.dtype(np.quaternion)\n    q = quaternion.as_float_array(Q)  # View as array of floats\n    assert q.dtype == np.dtype(np.float)\n    assert q.shape == (12, 4)  # This is the expected shape\n    for j in range(12):\n        for k in range(4):  # Check each component individually\n            assert q[j][k] == Q[j].components[k]\n    assert np.array_equal(quaternion.as_quat_array(q), Q)  # Check that we can go backwards\n    # Next, see how that works if I flatten the q array\n    q = q.flatten()\n    assert q.dtype == np.dtype(np.float)\n    assert q.shape == (48,)\n    for j in range(48):\n        assert q[j] == Q[j // 4].components[j % 4]\n    assert np.array_equal(quaternion.as_quat_array(q), Q)  # Check that we can go backwards\n    # Now, reshape into 2-d array, and re-check\n    P = Q.reshape(3, 4)  # Reshape into 3x4 array of quaternions\n    p = quaternion.as_float_array(P)  # View as array of floats\n    assert p.shape == (3, 4, 4)  # This is the expected shape\n    for j in range(3):\n        for k in range(4):\n            for l in range(4):  # Check each component individually\n                assert p[j][k][l] == Q[4 * j + k].components[l]\n    assert np.array_equal(quaternion.as_quat_array(p), P)  # Check that we can go backwards\n    # Check that we get an exception if the final dimension is not divisible by 4\n    with pytest.raises(ValueError):\n        quaternion.as_quat_array(np.random.rand(4, 1))\n    with pytest.raises(ValueError):\n        quaternion.as_quat_array(np.random.rand(4, 2))\n    with pytest.raises(ValueError):\n        quaternion.as_quat_array(np.random.rand(4, 3))\n    with pytest.raises(ValueError):\n        quaternion.as_quat_array(np.random.rand(4, 5))\n    with pytest.raises(ValueError):\n        quaternion.as_quat_array(np.random.rand(4, 5, 3, 2, 1))\n    # Finally, check that it works on non-contiguous arrays, by adding random padding and then slicing\n    q = quaternion.as_float_array(Q)\n    q = np.concatenate((np.random.rand(q.shape[0], 3), q, np.random.rand(q.shape[0], 3)), axis=1)\n    assert np.array_equal(quaternion.as_quat_array(q[:, 3:7]), Q)\n\n\n@pytest.mark.skipif(not has_scipy, reason=""Scipy is not installed"")\ndef test_integrate_angular_velocity():\n    import math\n    import numpy as np\n    import quaternion\n\n    t0 = 0.0\n    t2 = 10000.0\n    Omega_orb = 2 * math.pi * 100 / t2\n    Omega_prec = 2 * math.pi * 10 / t2\n    alpha = 0.125 * math.pi\n    alphadot = 2 * alpha / t2\n    nu = 0.2 * alpha\n    Omega_nu = Omega_prec\n    R0 = np.exp(-1.1 * alpha * quaternion.x / 2)\n\n    def R(t):\n        return (R0\n                * np.exp(Omega_prec * t * quaternion.z / 2) * np.exp((alpha + alphadot * t) * quaternion.x / 2)\n                * np.exp(-Omega_prec * t * quaternion.z / 2)\n                * np.exp(Omega_orb * t * quaternion.z / 2)\n                * np.exp(nu * np.cos(Omega_nu * t) * quaternion.y / 2))\n\n    def Rdot(t):\n        R_dynamic = R0.inverse() * R(t)\n        R_prec = np.exp(Omega_prec * t * quaternion.z / 2)\n        R_nu = np.exp(nu * np.cos(Omega_nu * t) * quaternion.y / 2)\n        return R0 * (0.5 * Omega_prec * quaternion.z * R_dynamic\n                     + 0.5 * alphadot * R_prec * quaternion.x * R_prec.conj() * R_dynamic\n                     + 0.5 * (Omega_orb - Omega_prec) * R_dynamic * R_nu.inverse() * quaternion.z * R_nu\n                     + 0.5 * (-Omega_nu * nu * np.sin(Omega_nu * t)) * R_dynamic * quaternion.y)\n\n    def Omega_tot(t):\n        Rotor = R(t)\n        RotorDot = Rdot(t)\n        return (2 * RotorDot * Rotor.inverse()).vec\n\n    # Test with exact Omega function\n    t, R_approx = quaternion.integrate_angular_velocity(Omega_tot, 0.0, t2, R0=R(t0))\n    R_exact = R(t)\n    phi_Delta = np.array([quaternion.rotation_intrinsic_distance(e, a) for e, a in zip(R_exact, R_approx)])\n    assert np.max(phi_Delta) < 1e-10, np.max(phi_Delta)\n\n    # Test with exact Omega function taking two arguments\n    t, R_approx = quaternion.integrate_angular_velocity(lambda t, R: Omega_tot(t), 0.0, t2, R0=R(t0))\n    R_exact = R(t)\n    phi_Delta = np.array([quaternion.rotation_intrinsic_distance(e, a) for e, a in zip(R_exact, R_approx)])\n    assert np.max(phi_Delta) < 1e-10, np.max(phi_Delta)\n\n    # Test with explicit values, given at the moments output above\n    v = np.array([Omega_tot(ti) for ti in t])\n    t, R_approx = quaternion.integrate_angular_velocity((t, v), 0.0, t2, R0=R(t0))\n    R_exact = R(t)\n    phi_Delta = np.array([quaternion.rotation_intrinsic_distance(e, a) for e, a in zip(R_exact, R_approx)])\n    assert np.max(phi_Delta) < 1e-4, np.max(phi_Delta)\n\n\ndef test_mean_rotor_in_chordal_metric():\n    # Test interpolation of some random constant quaternion\n    q = quaternion.quaternion(*np.random.rand(4)).normalized()\n    qs = np.array([q]*10)\n    ts = np.linspace(0.1, 23.4, num=10)\n    for length in range(1, 4):\n        mean1 = quaternion.mean_rotor_in_chordal_metric(qs[:length])\n        assert np.abs(q-mean1) < 1e-15, (q, mean1, length)\n        with pytest.raises(ValueError):\n            quaternion.mean_rotor_in_chordal_metric(qs[:length], ts[:length])\n    for length in range(4, 11):\n        mean1 = quaternion.mean_rotor_in_chordal_metric(qs[:length])\n        assert np.abs(q-mean1) < 1e-15, (q, mean1, length)\n        mean2 = quaternion.mean_rotor_in_chordal_metric(qs[:length], ts[:length])\n        assert np.abs(q-mean2) < 1e-15, (q, mean2, length)\n\n\ndef test_numpy_save_and_load():\n    import tempfile\n    a = quaternion.as_quat_array(np.random.rand(5,3,4))\n    with tempfile.TemporaryFile() as temp:\n        np.save(temp, a)\n        temp.seek(0)  # Only needed here to simulate closing & reopening file, per np.save docs\n        b = np.load(temp).view(dtype=np.quaternion)\n    assert np.array_equal(a, b)\n\n\ndef test_pickle():\n    import pickle\n    a = quaternion.one\n    assert pickle.loads(pickle.dumps(a)) == a\n\n\nif __name__ == \'__main__\':\n    print(""The tests should be run automatically via pytest (`pip install pytest` and then just `pytest`)"")\n\n\n\n\n'"
