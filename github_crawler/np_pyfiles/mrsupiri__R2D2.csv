file_path,api_count,code
R2D2.py,4,"b'import configparser\nimport time\nimport cv2\nimport socket\nfrom _pickle import dumps, loads\nimport numpy as np\nimport os\nimport pandas as pd\nfrom sklearn.externals import joblib\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\n\n\ndef config(sub, section=\'R2D2\'):\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    config = configparser.ConfigParser()\n    config.read(\'config.ini\')\n    return config[section][sub]\n\n\nclass Driver(object):\n    def __init__(self):\n        self.gpio = __import__(\'RPi.GPIO\')\n        self.gpio = self.gpio.GPIO\n\n        # Motor controller l298n\n        self.enable_L = 36\n        self.motorL_1 = 33\n        self.motorL_2 = 35\n        self.enable_R = 37\n        self.motorR_1 = 38\n        self.motorR_2 = 40\n\n        # 2 LED\n        self.led = 29\n        self.led2 = 31\n\n        # Servo motor (Arm)\n        self.ser1 = 7\n        self.ser2 = 11\n\n        # hc-sr04 ultrasonic distance sensor\n        self.TRIG = 12\n        self.ECHO = 13\n\n        self.gpio.setwarnings(False)\n        self.gpio.setmode(self.gpio.BOARD)\n\n        self.gpio.setup(self.enable_L, self.gpio.OUT)\n        self.gpio.setup(self.motorL_1, self.gpio.OUT)\n        self.gpio.setup(self.motorL_2, self.gpio.OUT)\n        self.gpio.setup(self.enable_R, self.gpio.OUT)\n        self.gpio.setup(self.motorR_1, self.gpio.OUT)\n        self.gpio.setup(self.motorR_2, self.gpio.OUT)\n\n        self.gpio.setup(self.led, self.gpio.OUT)\n        self.gpio.setup(self.led2, self.gpio.OUT)\n\n        self.gpio.setup(self.ser1, self.gpio.OUT)\n        self.gpio.setup(self.ser2, self.gpio.OUT)\n\n        self.gpio.output(self.enable_L, False)\n        self.gpio.output(self.motorL_1, False)\n        self.gpio.output(self.motorL_2, False)\n        self.gpio.output(self.enable_R, False)\n        self.gpio.output(self.motorR_1, False)\n        self.gpio.output(self.motorR_2, False)\n\n        self.gpio.output(self.led, True)\n        self.gpio.output(self.led2, True)\n\n        self.gpio.setup(self.TRIG, self.gpio.OUT)\n        self.gpio.setup(self.ECHO, self.gpio.IN)\n        self.gpio.output(self.TRIG, False)\n        self.loaded = 0\n        self.unload()\n\n    def setGPIO(self, EL=False, ML1=False, ML2=False, ER=False, MR1=False, MR2=False):\n        self.gpio.output(self.enable_L, EL)\n        self.gpio.output(self.motorL_1, ML1)\n        self.gpio.output(self.motorL_2, ML2)\n        self.gpio.output(self.enable_R, ER)\n        self.gpio.output(self.motorR_1, MR1)\n        self.gpio.output(self.motorR_2, MR2)\n\n    def fwd(self, tf=.012):\n        self.setGPIO(ER=True, MR1=True, EL=True, ML1=True)\n        time.sleep(tf)\n        self.setGPIO()\n\n    def bwd(self, tf=.012):\n        self.setGPIO(ER=True, MR2=True, EL=True, ML2=True)\n        time.sleep(tf)\n        self.setGPIO()\n\n    def left(self, tf=.012):\n        self.setGPIO(ER=True, MR1=True)\n        time.sleep(tf)\n        self.setGPIO()\n\n    def right(self, tf=.012):\n        self.setGPIO(EL=True, ML1=True)\n        time.sleep(tf)\n        self.setGPIO()\n\n    def left90(self, tf=.01):\n        self.setGPIO(ER=True, MR1=True, EL=True, ML2=True)\n        time.sleep(tf)\n        self.setGPIO()\n\n    def right90(self, tf=.01):\n        self.setGPIO(ER=True, MR2=True, EL=True, ML1=True)\n        time.sleep(tf)\n        self.setGPIO()\n\n    def end(self, tf=.7):\n        self.setGPIO()\n        time.sleep(tf)\n\n    def move2motor(self, moves):\n        if type(moves) == list:\n            move = moves.index(1)\n        else:\n            move = int(moves)\n        if move == 0:\n            self.fwd()\n        elif move == 1:\n            self.left()\n        elif move == 2:\n            self.right()\n        elif move == 3:\n            self.bwd()\n        elif move == 4:\n            self.fwd(0.15)\n        elif move == 5:\n            self.left90()\n        elif move == 6:\n            self.right90()\n        elif move == 7:\n            self.left90(0.3)\n        elif move == 8:\n            self.end()\n        elif move == 9:\n            if self.loaded:\n                self.unload()\n                time.sleep(2)\n            else:\n                self.load()\n                time.sleep(2)\n\n    def servoStart(self):\n        self.servo1 = self.gpio.PWM(self.ser1, 50)\n        self.servo2 = self.gpio.PWM(self.ser2, 50)\n        self.servo1.start(12.0)\n        self.servo2.start(1.9)\n\n    def servoStop(self):\n        self.servo1.stop()\n        self.servo2.stop()\n\n    def servoLoad(self):\n        self.servo1.ChangeDutyCycle(2.25)\n        self.servo2.ChangeDutyCycle(10)\n\n    def servoUnLoad(self):\n        self.servo1.ChangeDutyCycle(12.0)\n        self.servo2.ChangeDutyCycle(1.9)\n\n    def load(self):\n        self.loaded = True\n        self.servoStart()\n        time.sleep(1)\n        self.servoLoad()\n        time.sleep(1)\n        self.servoStop()\n\n    def unload(self):\n        self.loaded = False\n        self.servoStart()\n        time.sleep(1)\n        self.servoUnLoad()\n        time.sleep(1)\n        self.servoStop()\n\n    def getDistance(self):\n        self.gpio.output(self.TRIG, True)\n        time.sleep(0.00001)\n        self.gpio.output(self.TRIG, False)\n\n        while self.gpio.input(self.ECHO) == 0:\n            self.pulse_start = time.time()\n\n        while self.gpio.input(self.ECHO) == 1:\n            self.pulse_end = time.time()\n\n        self.pulse_duration = self.pulse_end - self.pulse_start\n\n        self.distance = self.pulse_duration * 17150\n\n        self.distance = round(self.distance, 2)\n\n        return self.distance\n\n    def clear(self):\n        self.gpio.cleanup()\n\n\nclass Stream(object):\n    def __init__(self, ip, port, streamer, rc=False):\n        self.conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        if streamer:\n            self.conn.connect((ip, port))\n        else:\n            try:\n                self.conn.bind((ip, port))\n            except socket.error:\n                print(\'Bind failed\')\n            self.conn.listen(5)\n            print(\'Socket awaiting handshake\')\n            (self.conn, _) = self.conn.accept()\n            print(\'Connected\')\n        self.rc = rc\n\n    def Send(self, frame):\n        self.conn.send(dumps(frame))\n\n    def Receive(self, bitRate=1000000):\n        data = self.conn.recv(bitRate)\n        return loads(data)\n\n    def stop(self):\n        self.conn.close()\n\n\nclass Vision(object):\n    def __init__(self):\n        self.PiRGBArray = __import__(\'picamera.array\').array.PiRGBArray\n        self.PiCamera = __import__(\'picamera\').PiCamera\n        self.WIDTH = int(config(\'CapWidth\'))\n        self.HEIGHT = int(config(\'CapHeight\'))\n        self.camera = self.PiCamera()\n        self.camera.resolution = (self.WIDTH, self.HEIGHT)\n        self.camera.framerate = 70\n        self.rawCapture = self.PiRGBArray(self.camera, size=(self.WIDTH, self.HEIGHT))\n        time.sleep(0.2)\n\n    def getFrame(self, color=str(config(\'CapWidth\'))):\n        for frame in self.camera.capture_continuous(self.rawCapture, format=""bgr"", use_video_port=True):\n            image = frame.array\n            gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n            self.rawCapture.truncate(0)\n            if color == \'Gray\':\n                return gray_image\n            else:\n                return image\n\n    def seeFrame(self):\n        for frame in self.camera.capture_continuous(self.rawCapture, format=""bgr"", use_video_port=True):\n            image = frame.array\n            self.rawCapture.truncate(0)\n            cv2.imshow(""Frame"", image)\n            key = cv2.waitKey(1) & 0xFF\n            if key == ord(""q""):\n                break\n\n\nclass LineFollower(object):\n    def __init__(self, collectData=False):\n        self.WIDTH = int(config(\'FrameWidth\', \'LineFollower\'))\n        self.HEIGHT = int(config(\'FrameHeight\', \'LineFollower\'))\n        self.start_x = int(config(\'StartX\', \'LineFollower\'))\n        self.start_y = int(config(\'StartY\', \'LineFollower\'))\n        self.end_x = int(config(\'EndX\', \'LineFollower\'))\n        self.end_y = int(config(\'EndY\', \'LineFollower\'))\n        self.gapBetweenLine = int(config(\'GapBetweenLine\', \'LineFollower\'))\n        self.box_height = int(config(\'BoxHeight\', \'LineFollower\'))\n        self.blackThreashHold = int(config(\'blackThreashHold\', \'LineFollower\'))\n        os.chdir(os.path.dirname(os.path.abspath(__file__)))\n        if collectData:\n            if not os.path.isfile(\'data/data.csv\'):\n                self.f = open(\'data/data.csv\', \'w\')\n                self.f.write(\'id,move,box_loaded\')\n                for i in range(1, 8):\n                    for k in range(1, 7):\n                        self.f.write(\',line{}_{}\'.format(i, k))\n                self.f.write(\'\\n\')\n                self.count = 0\n                self.f.close()\n                self.f = open(\'data/data.csv\', \'a\')\n            else:\n                self.f = open(\'data/data.csv\', \'r\')\n                self.count = sum(1 for _ in self.f) - 1\n                self.f.close()\n                self.f = open(\'data/data.csv\', \'a\')\n\n    def sensorArray(self, ROI, hm=int(config(\'Boxes\', \'LineFollower\'))):\n        line = []\n        for i in range(hm):\n            size = (self.end_x - self.start_x) / hm\n            start = int(i * size)\n            end = int(i * size + size)\n            box = ROI[:, start:end]\n            area = box.shape[0] * box.shape[1]\n            nonzero = np.count_nonzero(box)\n            if int(area - nonzero) > int(area * 0.3):\n                line.append(1)\n            else:\n                line.append(0)\n        return line\n\n    def getY(self, i, gap):\n        return (self.end_y - self.start_y) - (self.box_height * i) + (self.gapBetweenLine * gap)\n\n    def drawBoxes(self, img, lines, hm=int(config(\'Boxes\', \'LineFollower\'))):\n        for idx, line in enumerate(lines):\n            for i in range(hm):\n                size = (self.end_x - self.start_x) / hm\n                start = int(i * size)\n                end = int(i * size + size)\n                if line[i]:\n                    color = (0, 0, 255)\n                else:\n                    color = (0, 255, 0)\n                if idx == 0:\n                    cv2.rectangle(img, (start, self.getY(7, 3)), (end, self.getY(6, 3)), color, 1)\n                elif idx == 1:\n                    cv2.rectangle(img, (start, self.getY(5, 2)), (end, self.getY(4, 2)), color, 1)\n                elif idx == 2:\n                    cv2.rectangle(img, (start, self.getY(3, 1)), (end, self.getY(2, 1)), color, 1)\n                else:\n                    cv2.rectangle(img, (start, self.getY(1, 0)), (end, self.getY(0, 0)), color, 1)\n        return img\n\n    def getProcessedImage(self, frame):\n\n        frame = frame[self.start_y:self.end_y, self.start_x:self.end_x]\n        display = frame.copy()\n        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        _, img = cv2.threshold(frame, self.blackThreashHold, 255, cv2.THRESH_BINARY)\n\n        ROISensorArray1 = img[self.getY(7, 3):self.getY(6, 3), :]\n        ROISensorArray2 = img[self.getY(5, 2):self.getY(4, 2), :]\n        ROISensorArray3 = img[self.getY(3, 1):self.getY(2, 1), :]\n        ROISensorArray4 = img[self.getY(1, 0):self.getY(0, 0), :]\n\n        sensorArray1 = self.sensorArray(ROISensorArray1)\n        sensorArray2 = self.sensorArray(ROISensorArray2)\n        sensorArray3 = self.sensorArray(ROISensorArray3)\n        sensorArray4 = self.sensorArray(ROISensorArray4)\n\n        display = cv2.resize(self.drawBoxes(display, [sensorArray1, sensorArray2, sensorArray3, sensorArray4]),\n                             (240, 180))\n\n        return img, display, sensorArray1, sensorArray2, sensorArray3, sensorArray4\n\n    def collectData(self, move, *lines):\n        print(self.count)\n        try:\n            self.f.write(\'{0},{1}\'.format(str(self.count), move))\n            for line in lines:\n                for idx in line:\n                    self.f.write(\',{0}\'.format(str(idx)))\n            self.f.write(\'\\n\')\n            self.count += 1\n        except Exception as e:\n            print(e)\n\n        if self.count % 100 == 0:\n            print(\'Saving Collected Data\')\n            self.f.close()\n            self.f = open(\'data/data.csv\', \'a\')\n\n\nclass AI(object):\n    def __init__(self):\n        if os.path.isfile(\'data/model.pkl\'):\n            print(\'Model Loaded\')\n            self.clf = joblib.load(\'data/model.pkl\')\n        else:\n            self.trainModel()\n\n    def trainModel(self):\n        os.chdir(os.path.dirname(os.path.abspath(__file__)))\n        print(\'Training Started\')\n\n        df = pd.read_csv(\'data/data.csv\')\n\n        df.drop([\'id\'], 1, inplace=True)\n\n        X = np.array(df.drop([config(\'LableName\')], axis=1))\n        y = np.array(df[config(\'LableName\')])\n\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=True)\n\n        clf = LogisticRegression()\n\n        clf.fit(X_train, y_train)\n\n        accuracy = float(clf.score(X_test, y_test))\n        print(\'Model accuracy is\', accuracy * 100, \'%\')\n        joblib.dump(clf, \'data/model.pkl\')\n        self.clf = clf\n\n    def predict(self, data):\n        data = np.array(data)\n        prediction = self.clf.predict(data.reshape(1, -1))\n        return prediction[0]\n'"
PC/classifiertest.py,3,"b'import random\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nimport pandas as pd\nfrom sklearn.neighbors.nearest_centroid import NearestCentroid\n\ndef generateSamples():\n    f = open(\'data.csv\', \'w\')\n    f.write(\n        \'id,move,line1_1,line1_2,line1_3,line1_4,line1_5,line2_1,line2_2,line2_3,line2_4,line2_5,line3_1,line3_2,line3_3,line3_4,line3_5,line4_1,line4_2,line4_3,line4_4,line4_5,line5_1,line5_2,line5_3,line5_4,line5_5\\n\')\n\n    def argMax(*arrays):\n        bigArray = """"\n        for array in arrays:\n            for i in array:\n                bigArray += str(i) + \',\'\n\n        return bigArray[:-1] + \'\\n\'\n\n    def value():\n        rand = random.randint(0, 5)\n        if rand:\n            return 0\n        else:\n            return 1\n\n    for i in range(1000):\n        line1 = [value(), value(), value(), value(), value()]\n        line2 = [value(), value(), value(), value(), value()]\n        line3 = [value(), value(), value(), value(), value()]\n        line4 = [value(), value(), value(), value(), value()]\n        line5 = [value(), value(), value(), value(), value()]\n\n        move = str(random.randint(0, 2))\n\n        write = argMax(line1, line2, line3, line4, line5)\n        f.write(str(i) + \',\' + move + \',\' + write)\n\n        print(i)\n\n    f.close()\n\ndef train():\n    df = pd.read_csv(\'data.csv\')\n    df.drop([\'id\'], 1, inplace=True)\n    X = np.array(df.drop([\'move\'], axis=1))\n    y = np.array(df[\'move\'])\n\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)\n    clf = NearestCentroid(metric=\'euclidean\', shrink_threshold=None)\n    clf.fit(X_train, y_train)\n    accuracy = clf.score(X_test, y_test)\n\n    print(accuracy)\n    example_measures = np.array([0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0])\n    example_measures = example_measures.reshape(1, -1)\n    prediction = clf.predict(example_measures)\n    print(prediction)\n\ntrain()\n'"
PC/getkeys.py,0,"b'# Citation: Box Of Hats (https://github.com/Box-Of-Hats )\n\nimport win32api as wapi\nimport time\n\nkeyList = [""\\b""]\nfor char in ""ABCDEFGHIJKLMNOPQRSTUVWXYZ 123456789,.\'\xc2\xa3$/\\\\"":\n    keyList.append(char)\n\ndef key_check():\n    keys = []\n    for key in keyList:\n        if wapi.GetAsyncKeyState(ord(key)):\n            keys.append(key)\n    return keys\n \n'"
PC/grabframe.py,2,"b""import time\nimport cv2\nimport numpy as np\nimport R2D2\nfrom PC.getkeys import key_check\n\n\ndef getMove(keys):\n    output = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    if 'W' in keys:\n        output[0] = 1\n    elif 'A' in keys:\n        output[1] = 1\n    elif 'D' in keys:\n        output[2] = 1\n    elif 'S' in keys:\n        output[3] = 1\n    elif 'I' in keys:\n        output[4] = 1\n    elif 'J' in keys:\n        output[5] = 1\n    elif 'L' in keys:\n        output[6] = 1\n    elif 'K' in keys:\n        output[7] = 1\n    elif 'Y' in keys:\n        output[8] = 1\n    elif 'G' in keys:\n        output[9] = 1\n    else:\n        output[10] = 1\n    return output\n\ncollectData = bool(R2D2.config('CollectData'))\nstream = R2D2.Stream(str(R2D2.config('IP')), int(R2D2.config('Port')), streamer=0)\nLF = R2D2.LineFollower(collectData=collectData)\n\nif not collectData:\n    AI = R2D2.AI()\n\nlast_time = time.time()\nline1 = [];line2 = [];line3 = [];line4 = [];line5 = [];line6 = [];line7 = []\npaused = True\nloaded = 0\n\nfor _ in range(5):\n    keys = key_check()\n    move = getMove(keys)\n\nwhile 1:\n    try:\n        frame = stream.Receive(1000000)\n        img, display, sensorArray1, sensorArray2, sensorArray3, sensorArray4 = LF.getProcessedImage(frame)\n        cv2.imshow('frame', frame)\n        cv2.imshow('display', display)\n        cv2.imshow('Processed Image', img)\n\n        if collectData:\n            keys = key_check()\n            move = getMove(keys)\n            stream.Send(move)\n            if 'G' in keys:\n                if loaded:\n                    loaded = 0\n                    time.sleep(1)\n                else:\n                    loaded = 1\n                    time.sleep(1)\n\n            if np.count_nonzero(move[:10]) != 0 and not paused:\n                if not line1:\n                    line1 = sensorArray1\n                    line2 = sensorArray2\n                    line3 = sensorArray3\n                    line4 = sensorArray4\n                    line5 = sensorArray4\n                    line6 = sensorArray4\n                    line7 = sensorArray4\n                else:\n                    line7 = line6\n                    line6 = line5\n                    line5 = line4\n                    line4 = sensorArray4\n                    line3 = sensorArray3\n                    line2 = sensorArray2\n                    line1 = sensorArray1\n\n                LF.collectData(np.argmax(move[:10]), str(loaded), line1, line2, line3, line4, line5, line6, line7)\n\n            if 'P' in keys:\n                if paused:\n                    paused = False\n                    print('unpausing')\n                    time.sleep(1)\n                else:\n                    paused = True\n                    print('Pausing')\n                    time.sleep(1)\n        else:\n            print(round(1 / (time.time() - last_time), 2))\n            last_time = time.time()\n\n        if cv2.waitKey(1) & 0xFF == ord('q'):\n            break\n\n    except Exception as e:\n        if collectData:\n            stream.Send([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])"""
PC/train.py,0,b'import R2D2\n\nAI = R2D2.AI(train=True)'
raspberryPi/collectData.py,0,"b""import time\nimport R2D2\n\nDriver = R2D2.Driver()\ncamara = R2D2.Vision()\nstream = R2D2.Stream(str(R2D2.config('IP')), int(R2D2.config('Port')), streamer=1)\n\n# Do You Want to Collect Data or Test the Camara ?\ncollect_data = bool(R2D2.config('CollectData'))\n\ntry:\n    last_time = time.time()\n    while True:\n        frame = camara.getFrame('COLOR')\n        stream.Send(frame)\n        if collect_data:\n            move = stream.Receive(5200)\n            Driver.move2motor(move)\n        else:\n            print(round(1/(time.time() - last_time),2))\n            last_time = time.time()\n\nfinally:\n    stream.stop()\n    Driver.clear()\n"""
raspberryPi/lineFollower.py,0,"b""import R2D2\n\nline1 = []\nline2 = []\nline3 = []\nline4 = []\nline5 = []\nline6 = []\nline7 = []\n\nDriver = R2D2.Driver()\ncamara = R2D2.Vision()\ntry:\n    stream = R2D2.Stream(str(R2D2.config('IP')), int(R2D2.config('Port')), streamer=1)\nexcept:\n    stream = None\n\nLF = R2D2.LineFollower(collectData=True)\nAI = R2D2.AI()\n\n\ntry:\n    while True:\n        frame = camara.getFrame('COLOR')\n        stream.Send(frame)\n        try:\n            stream.Send(frame)\n        except:\n            pass\n        _, _, sensorArray1, sensorArray2, sensorArray3, sensorArray4 = LF.getProcessedImage(frame)\n        if not line1:\n            line1 = sensorArray1\n            line2 = sensorArray2\n            line3 = sensorArray3\n            line4 = sensorArray4\n            line5 = sensorArray4\n            line6 = sensorArray4\n            line7 = sensorArray4\n        else:\n            line7 = line6\n            line6 = line5\n            line5 = line4\n            line4 = sensorArray4\n            line3 = sensorArray3\n            line2 = sensorArray2\n            line1 = sensorArray1\n\n        data = [Driver.loaded] + line1 + line2 + line3 + line4 + line5 + line6 + line7\n        move = AI.predict(data)\n        print(move, Driver.getDistance(), Driver.loaded, line1, line2, line3, line4)\n        Driver.move2motor(move)\n\n        LF.collectData(move, str(0), line1, line2, line3, line4, line5, line6, line7)\n\n        if not Driver.loaded:\n            if Driver.getDistance() < 9:\n                Driver.setGPIO()\n                while Driver.getDistance() > 7:\n                    Driver.fwd(.005)\n                Driver.load()\n                Driver.loaded = 1\n\n        camara.rawCapture.truncate(0)\nfinally:\n    Driver.clear()"""
