file_path,api_count,code
src/phitau.py,0,"b'# Copyright 2013 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport random\n\nfrom numpy import *\n\nT = 1.0\n\n# IEEE 802.15.4 chipping sequences (I/Q as bits, interleaved)\nchips = {0:array([1,1,0,1,1,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,0,1,0,1,1,1,0]),\n         8:array([1,0,0,0,1,1,0,0,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,1,0,1,1])}\n\n# building the chipping sequences by shifting ...\nfor sym in range(1, 8):\n    chips[sym]   = concatenate((chips[sym-1][-4:], chips[sym-1][:-4]))\n    chips[sym+8] = concatenate((chips[sym+7][-4:], chips[sym+7][:-4]))\n    \n# change chips to constellation {0,1} -> {-1,1}\nfor sym in chips.keys():\n    chips[sym] = 2*chips[sym] - 1\n\n# Remain silent during this symbol (if symbol is given as \'None\')\nchips[None] = array([0]*32)\n\ndef detect_i(alpha, beta, phi_range, tau, As, Au):\n    _tau_ = remainder(tau, 2*T)\n    _tau_n_ = remainder(tau+T, 2*T)\n    omega_p = pi/(2*T)\n    phi_p = omega_p * tau\n    \n    k_tau = int(floor(tau / (2*T)))\n    k_tau_n = int(floor((tau+T) / (2*T)))\n        \n    # fill negative indices with zeros (FIXED: k=0 also needs one zero at position -1!)\n    beta_i, beta_q = concatenate((beta[0], zeros(max(1, 2*abs(k_tau))))), concatenate((beta[1], zeros(max(1, 2*abs(k_tau_n)))))\n    \n    bkn_i = roll(beta_i, k_tau + 1)[:len(alpha[0])]\n    bk_i = roll(beta_i, k_tau)[:len(alpha[0])]\n    bkn_q = roll(beta_q, k_tau_n + 1)[:len(alpha[0])]\n    bk_q = roll(beta_q, k_tau_n)[:len(alpha[0])]\n    \n    arg1 = cos(phi_p) * (_tau_ * bkn_i + (2*T - _tau_) * bk_i)\n    arg2 = ((2*T) / pi) * sin(phi_p) * (bkn_i - bk_i)\n    arg3 = sin(phi_p) * (_tau_n_ * bkn_q + (2*T - _tau_n_) * bk_q)\n    arg4 = ((2*T) / pi) * cos(phi_p) * (bkn_q - bk_q)\n    \n    PHI_C, ALPHA = meshgrid(phi_range, alpha[0])\n    _, ARG12 = meshgrid(phi_range, (arg1 - arg2))\n    _, ARG34 = meshgrid(phi_range, (arg3 + arg4))\n    \n    # TODO: fix Au in partial overlap! One strong chip can dominate the complete correlation of a symbol ...\n    \n    result = (T/2) * ALPHA * As + (Au/4) * (cos(PHI_C) * ARG12 - sin(PHI_C) * ARG34)\n    \n    # modified for Au only transmissions\n    if As != 0:\n        return result / ((T/2) * As * Au)\n    else:\n        return result / ((T/2) * Au)\n\ndef detect_q(alpha, beta, phi_range, tau, As, Au):\n    _tau_ = remainder(tau, 2*T)\n    _tau_p_ = remainder(tau-T, 2*T)\n    omega_p = pi/(2*T)\n    phi_p = omega_p * tau\n\n    k_tau = int(floor(tau / (2*T)))\n    k_tau_p = int(floor((tau-T) / (2*T)))\n    \n    # fill negative indices with zeros\n    beta_i, beta_q = concatenate((beta[0], zeros(max(1, 2*abs(k_tau_p))))), concatenate((beta[1], zeros(max(1, 2 * abs(k_tau)))))\n    \n    bkn_i = roll(beta_i, k_tau_p + 1)[:len(alpha[0])]\n    bk_i = roll(beta_i, k_tau_p)[:len(alpha[0])]\n    bkn_q = roll(beta_q, k_tau + 1)[:len(alpha[0])]\n    bk_q = roll(beta_q, k_tau)[:len(alpha[0])]\n    \n    arg1 = cos(phi_p) * (_tau_ * bkn_q + (2*T - _tau_) * bk_q)\n    arg2 = ((2*T) / pi) * sin(phi_p) * (bkn_q - bk_q)\n    arg3 = sin(phi_p) * (_tau_p_ * bkn_i + (2*T - _tau_p_) * bk_i)\n    arg4 = ((2*T) / pi) * cos(phi_p) * (bkn_i - bk_i)\n    \n    PHI_C, ALPHA = meshgrid(phi_range, alpha[1])\n    _, ARG12 = meshgrid(phi_range, (arg1 - arg2))\n    _, ARG34 = meshgrid(phi_range, (arg3 + arg4))\n    \n    # TODO: fix Au in partial overlap! One strong chip can dominate the complete correlation of a symbol ...\n    \n    result = (T/2) * ALPHA * As + (Au/4) * (cos(PHI_C) * ARG12 - sin(PHI_C) * ARG34)\n    \n    # modified for Au only transmissions\n    if As != 0:\n        return result / ((T/2) * As * Au)\n    else:\n        return result / ((T/2) * Au)\n\n\ndef map_chips(vsyms, asyms):\n    chips_i, chips_q = {}, {}\n    \n    # Split chipping sequences in I and Q\n    for sym in chips.iterkeys():\n        chips_i[sym] = chips[sym][::2]\n        chips_q[sym] = chips[sym][1::2]\n    \n    alpha_i, alpha_q = array([], dtype=int32), array([], dtype=int32)\n    beta_i, beta_q   = array([], dtype=int32), array([], dtype=int32)\n    \n    # map symbols to chips\n    for vsym in vsyms:\n        alpha_i = concatenate((alpha_i, chips_i[vsym]))\n        alpha_q = concatenate((alpha_q, chips_q[vsym]))\n    for asym in asyms:\n        beta_i = concatenate((beta_i, chips_i[asym]))\n        beta_q = concatenate((beta_q, chips_q[asym]))\n        \n    return array([alpha_i, alpha_q, beta_i, beta_q])\n    \ndef channel(alpha, beta, phi_range, tau, As, Au):\n    RECV_CHIPS_I = detect_i(alpha, beta, phi_range, tau, As, Au)\n    RECV_CHIPS_Q = detect_q(alpha, beta, phi_range, tau, As, Au)\n\n    # return received chipping sequence with alternating I/Q chips for correlation ([i0, q0, i1, q1, ...])\n    i = 0 # choose a phi_c value from the matrix\n    #recv_chips = sign(ravel(zip(RECV_CHIPS_I[:,i], RECV_CHIPS_Q[:,i])))\n    recv_chips = ravel(zip(RECV_CHIPS_I[:,i], RECV_CHIPS_Q[:,i]))\n    \n    return recv_chips\n\ndef detect_syms_corr(recv_chips, **args):\n    recv_syms = array([], dtype=int32)\n    \n    # Choose the symbol with the highest correlation value\n    while len(recv_chips) > 0:\n        curr_chips = recv_chips[:32]\n        best_syms  = []\n        best_corr  = 0\n        \n        for sym in chips.iterkeys():\n            curr_corr, = abs(correlate(chips[sym], curr_chips))\n            \n            if curr_corr > best_corr:\n                best_syms  = [sym]\n                best_corr  = curr_corr\n            elif curr_corr == best_corr:\n                best_syms.append(sym)\n                \n        # all values with the same correlation could be detected, just choose one ...\n        recv_syms = append(recv_syms, random.choice(best_syms))\n        recv_chips = recv_chips[32:]\n    \n    return recv_syms\n\ndef detect_syms_corrcoef(recv_chips, **args):\n    recv_syms = array([], dtype=int32)\n    \n    # Choose the symbol with the highest correlation value\n    while len(recv_chips):\n        curr_chips = recv_chips[:32]\n\n        corr_matrix = abs(corrcoef(curr_chips, [chips[i] for i in range(16)]))[0,1:]\n        best_syms, = where(corr_matrix >= max(corr_matrix))\n                \n        # all values with the same correlation could be detected, just choose one ...\n        recv_syms = append(recv_syms, random.choice(best_syms))\n        recv_chips = recv_chips[32:]\n    \n    return recv_syms\n\n#detect_syms_corr = detect_syms_corrcoef\n    \ndef detect_syms_cerr(recv_chips, **args):\n    recv_syms = array([], dtype=int32)\n    \n    # Choose the symbol with the lowest number of chip errors\n    while len(recv_chips) > 0:\n        curr_chips = recv_chips[:32]\n        best_sym   = 0\n        best_cerr  = 33\n        \n        for sym in chips:\n            if not sym: continue\n            curr_cerr = sum(chips[sym][1:] != curr_chips[1:])\n            \n            if curr_cerr < best_cerr:\n                best_sym  = sym\n                best_cerr  = curr_cerr\n        \n        recv_syms = append(recv_syms, best_sym)\n        recv_chips = recv_chips[32:]\n        \n    return recv_syms\n\nif __name__ == ""__main__"":\n    alpha = array([[-1, 1, -1, 1, -1, -1], [1, 1, -1, -1, -1, 1]])  # (I,Q)\n    beta = array([[-1, 1, -1, 1, 1, -1], [-1, -1, -1, 1, -1, 1]])  # (I,Q)\n    phi_range = arange(-pi, pi, pi / 2)\n\n    res = detect_i(alpha, beta, phi_range, -6.0, 1.0, 10.0)\n    #res = detect_q(alpha, beta, phi_range, -6.0, 1.0, 10.0)\n    \n    set_printoptions(threshold=NaN, precision=3, suppress=True)\n    print res[:,-1]\n\n    asyms = [1,2,3]\n    vsyms = [4,5,6]\n\n    send_chips = map_chips(asyms, vsyms)\n    recv_chips = channel(send_chips[:2], send_chips[2:], phi_range=[pi/2], tau=0.0, As=1.0, Au=100.0)\n\n    for i in range(1000):\n        recv_syms = detect_syms_corrcoef(recv_chips)\n\n    print recv_syms\n'"
src/phitau_n.py,54,"b""# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport numpy as np\n\nT = 1.0\n\nchips = {0:np.array([1,1,0,1,1,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,0,1,0,1,1,1,0]),\n         8:np.array([1,0,0,0,1,1,0,0,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,1,0,1,1])}\n\n# building the chipping sequences by shifting ...\nfor sym in range(1, 8):\n    chips[sym]   = np.concatenate((chips[sym-1][-4:], chips[sym-1][:-4]))\n    chips[sym+8] = np.concatenate((chips[sym+7][-4:], chips[sym+7][:-4]))\n\n# change chips to constellation {0,1} -> {-1,1}\nfor sym in chips.keys():\n    chips[sym] = 2*chips[sym] - 1\n\n# Remain silent during this symbol (if symbol is given as 'None')\nchips[None] = np.array([0]*32)\n\nchips_a = np.vstack([chips[i] for i in range(16)])\n\ndef detect_i_n(ninterf, alpha, beta_n, phi_range_n, tau, As, Au):\n\t_tau_   = np.remainder(tau, 2*T)\n\t_tau_n_ = np.remainder(tau+T, 2*T)\n\tomega_p = np.pi/(2*T)\n\tphi_p   = omega_p * tau\n\n\tk_tau   = np.int(np.floor(tau / (2*T)))\n\tk_tau_n = np.int(np.floor((tau+T) / (2*T)))\n\n\t_, ALPHA = np.meshgrid(phi_range_n[0], alpha[0])\n\n\tresult = (T/2) * ALPHA * As\n\n\tfor interf in range(ninterf):\n\t\tphi_range = phi_range_n[interf]\n\t\tPHI_C, _  = np.meshgrid(phi_range, alpha[0])\n\n\t\tbeta = beta_n[2*interf:(2*interf)+2]\n\t\tbeta_i = np.concatenate((beta[0], np.zeros(max(1, 2*abs(k_tau)))))\n\t\tbeta_q = np.concatenate((beta[1], np.zeros(max(1, 2*abs(k_tau_n)))))\n\n\t\tbkn_i = np.roll(beta_i, k_tau + 1)  [:len(alpha[0])]\n\t\tbk_i  = np.roll(beta_i, k_tau)      [:len(alpha[0])]\n\t\tbkn_q = np.roll(beta_q, k_tau_n + 1)[:len(alpha[1])]\n\t\tbk_q  = np.roll(beta_q, k_tau_n)    [:len(alpha[1])]\n\n\t\targ1 = np.cos(phi_p) * (_tau_ * bkn_i + (2*T - _tau_) * bk_i)\n\t\targ2 = ((2*T) / np.pi) * np.sin(phi_p) * (bkn_i - bk_i)\n\t\targ3 = np.sin(phi_p) * (_tau_n_ * bkn_q + (2*T - _tau_n_) * bk_q)\n\t\targ4 = ((2*T) / np.pi) * np.cos(phi_p) * (bkn_q - bk_q)\n\n\t\t_, ARG12 = np.meshgrid(phi_range, (arg1 - arg2))\n\t\t_, ARG34 = np.meshgrid(phi_range, (arg3 + arg4))\n\n\t\tresult += (Au/4.0) * (np.cos(PHI_C) * ARG12 - np.sin(PHI_C) * ARG34)\n\n\tif Au > 0 and ninterf != 0:\n\t\treturn result / ((T/2) * As * Au)\n\telse:\n\t\treturn result / ((T/2) * As)\n\ndef detect_q_n(ninterf, alpha, beta_n, phi_range_n, tau, As, Au):\n\t_tau_   = np.remainder(tau, 2*T)\n\t_tau_p_ = np.remainder(tau-T, 2*T)\n\tomega_p = np.pi/(2*T)\n\tphi_p   = omega_p * tau\n\n\tk_tau   = np.int(np.floor(tau / (2*T)))\n\tk_tau_p = np.int(np.floor((tau-T) / (2*T)))\n\n\t_, ALPHA = np.meshgrid(phi_range_n[0], alpha[1])\n\n\tresult = (T/2) * ALPHA * As\n\n\tfor interf in range(ninterf):\n\t\tphi_range = phi_range_n[interf]\n\t\tPHI_C, _  = np.meshgrid(phi_range, alpha[1])\n\n\t\tbeta = beta_n[2*interf:(2*interf)+2]\n\t\t# fill negative indices with zeros\n\t\tbeta_i = np.concatenate((beta[0], np.zeros(max(1, 2*abs(k_tau_p)))))\n\t\tbeta_q = np.concatenate((beta[1], np.zeros(max(1, 2*abs(k_tau)))))\n\n\t\tbkn_i = np.roll(beta_i, k_tau_p + 1)[:len(alpha[0])]\n\t\tbk_i  = np.roll(beta_i, k_tau_p)    [:len(alpha[0])]\n\t\tbkn_q = np.roll(beta_q, k_tau + 1)  [:len(alpha[1])]\n\t\tbk_q  = np.roll(beta_q, k_tau)      [:len(alpha[1])]\n\n\t\targ1 = np.cos(phi_p) * (_tau_ * bkn_q + (2*T - _tau_) * bk_q)\n\t\targ2 = ((2*T) / np.pi) * np.sin(phi_p) * (bkn_q - bk_q)\n\t\targ3 = np.sin(phi_p) * (_tau_p_ * bkn_i + (2*T - _tau_p_) * bk_i)\n\t\targ4 = ((2*T) / np.pi) * np.cos(phi_p) * (bkn_i - bk_i)\n\n\t\t_, ARG12 = np.meshgrid(phi_range, (arg1 - arg2))\n\t\t_, ARG34 = np.meshgrid(phi_range, (arg3 + arg4))\n\n\t\tresult += (Au/4.0) * (np.cos(PHI_C) * ARG12 - np.sin(PHI_C) * ARG34)\n\n\tif Au > 0 and ninterf != 0:\n\t\treturn result / ((T/2) * As * Au * ninterf)\n\telse:\n\t\treturn result / ((T/2) * As)\n\ndef map_chips_n(vsyms, *args):\n\tchips_i, chips_q = {}, {}\n\n\t# Split chipping sequences in I and Q\n\tfor sym in chips.keys():\n\t\tchips_i[sym] = chips[sym][ ::2]\n\t\tchips_q[sym] = chips[sym][1::2]\n\n\talpha_i, alpha_q = np.array([], dtype=np.int), np.array([], dtype=np.int)\n\n\tfor vsym in vsyms:\n\t\talpha_i = np.concatenate((alpha_i, chips_i[vsym]))\n\t\talpha_q = np.concatenate((alpha_q, chips_q[vsym]))\n\n\tresult = np.array([alpha_i, alpha_q])\n\n\tfor asyms in args:\n\t\tbeta_i, beta_q = np.array([], dtype=np.int), np.array([], dtype=np.int)\n\n\t\tfor asym in asyms:\n\t\t\tbeta_i = np.concatenate((beta_i, chips_i[asym]))\n\t\t\tbeta_q = np.concatenate((beta_q, chips_q[asym]))\n\n\t\tresult = np.vstack([result, np.array([beta_i, beta_q])])\n\n\treturn result\n"""
src/phitau_opt.py,49,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport numpy as np\n\nT = 1.0\n\n# IEEE 802.15.4 chipping sequences (I/Q as bits, interleaved)\nchips = {0:np.array([1,1,0,1,1,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,0,1,0,1,1,1,0]),\n         8:np.array([1,0,0,0,1,1,0,0,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,1,0,1,1])}\n\n# building the chipping sequences by shifting ...\nfor sym in range(1, 8):\n\tchips[sym]   = np.concatenate((chips[sym-1][-4:], chips[sym-1][:-4]))\n\tchips[sym+8] = np.concatenate((chips[sym+7][-4:], chips[sym+7][:-4]))\n\n# convert chips to constellation points {0,1} -> {-1,1}\nfor sym in chips.keys():\n\tchips[sym] = 2*chips[sym] - 1\n\n# Additional chipping sequence to remain silent during this symbol (if symbol is given as ""None"")\nchips[None] = np.array([0]*32)\n\nchips_a = np.vstack([chips[i] for i in range(16)])\n\n\ndef shift_indices(X, k):\n\tlength = len(X)\n\n\t# fill negative indices with np.zeros (FIXED: k=0 also needs one zero at position -1!)\n\tX = np.concatenate((X, np.zeros(max(1, 2*abs(k)))))\n\n\tXkn_i = np.roll(X, k+1)[:length]\n\tXk_i  = np.roll(X, k)  [:length]\n\n\treturn Xkn_i, Xk_i\n\n\ndef detect_i(alpha, beta, phi_range, tau, As, Au):\n\t""""""Calculate the in-phase demodulation output for two colliding MSK signals s(t) and u(t).\n\n\tThis function implements Eq. 9 in the technical report for two signals and a noiseless channel.\n\n\tParameters\n\t----------\n\talpha\n\t\t(2d np.array [I/Q][chips]): IQ bits/chips sent by the synchronized sender S.\n\t\t(Example: np.array([[-1, 1, -1], [1, 1, -1]]))\n\n\tbeta\n\t\t(2d np.array [I/Q][chips]): IQ bits/chips sent by the interfering sender U.\n\t\t(See alpha)\n\n\tphi_range\n\t\t(1d np.array): Carrier phase offsets of the interfering sender.\n\t\t(Example: np.arange(-np.pi, np.pi, num=10))\n\n\ttau\n\t\tTime offset between s(t) and u(t).\n\t\t(Example: 2*T)\n\n\tAs\n\t\tSignal amplitude of s(t).\n\tAu\n\t\tSignal amplitude of u(t).\n\n\tReturns\n\t-------\n\tScaled soft bit \\hat{o}^I_k with values in range [-1,1].\n\t""""""\n\treturn _detect(alpha[0], beta[0], beta[1], phi_range, tau, As, Au, tau_shift=T)\n\n\ndef detect_q(alpha, beta, phi_range, tau, As, Au):\n\t""""""Calculate the quadrature-phase demodulation output for two colliding MSK signals s(t) and u(t).\n\n\tSee detect_i for details, this function yields results for \\hat{o}^Q_k.\n\t""""""\n\treturn _detect(alpha[1], beta[1], beta[0], phi_range, tau, As, Au, tau_shift=-T)\n\n\ndef _detect(alpha, beta_1, beta_2, phi_range, tau, As, Au, tau_shift):\n\tomega_p = np.pi/(2*T)\n\tphi_p   = omega_p * tau\n\n\ttau_1_  = np.remainder(tau, 2*T)\n\ttau_2_  = np.remainder(tau+tau_shift, 2*T)\n\tk_tau_1 = int(np.floor(tau / (2*T)))\n\tk_tau_2 = int(np.floor((tau+tau_shift) / (2*T)))\n\n\tbkn_1, bk_1 = shift_indices(beta_1, k_tau_1)\n\tbkn_2, bk_2 = shift_indices(beta_2, k_tau_2)\n\n\targ1 = np.cos(phi_p) * (tau_1_ * bkn_1 + (2*T - tau_1_) * bk_1)\n\targ2 = ((2*T) / np.pi) * np.sin(phi_p) * (bkn_1 - bk_1)\n\targ3 = np.sin(phi_p) * (tau_2_ * bkn_2 + (2*T - tau_2_) * bk_2)\n\targ4 = ((2*T) / np.pi) * np.cos(phi_p) * (bkn_2 - bk_2)\n\n\tPHI_C, ALPHA = np.meshgrid(phi_range, alpha)\n\tARG12 = np.meshgrid(phi_range, (arg1 - arg2))[1]\n\tARG34 = np.meshgrid(phi_range, (arg3 + arg4))[1]\n\n\t# TODO: fix Au in partial overlap! One strong chip can dominate the complete correlation of a symbol ...\n\tresult = (T/2) * ALPHA * As + (Au/4) * (np.cos(PHI_C) * ARG12 - np.sin(PHI_C) * ARG34)\n\n\t# modified for Au only transmissions\n\tif As > 0:\n\t\treturn result / ((T/2) * As * Au)\n\telse:\n\t\treturn result / ((T/2) * Au)\n\n\ndef map_chips(syncsyms, usyms):\n\t""""""Map 4 bit symbols to 32 bit chipping sequences.\n\n\tParameters\n\t----------\n\t    syncsyms: Symbols of the synchronized sender.\n\t    usyms: Symbols of the interferer.\n\n\tReturns\n\t-------\n\t    2d nparray of in- and quadrature-phase chips from the 2.4 GHz PHY of IEEE 802.15.4 for both\n\t    the synchronized sender (alpha) and the interferer (beta).\n\t""""""\n\tchips_i, chips_q = {}, {}\n\n\t# Split chipping sequences in I and Q\n\tfor sym in chips.keys():\n\t\tchips_i[sym] = chips[sym][::2]\n\t\tchips_q[sym] = chips[sym][1::2]\n\n\talpha_i, alpha_q = np.zeros(len(syncsyms)*16), np.zeros(len(syncsyms)*16)\n\tbeta_i,  beta_q  = np.zeros(len(usyms)*16),    np.zeros(len(usyms)*16)\n\n\t# map symbols to chips\n\tfor i, sysym in enumerate(syncsyms):\n\t\talpha_i[i*16:(i+1)*16] = chips_i[sysym]\n\t\talpha_q[i*16:(i+1)*16] = chips_q[sysym]\n\n\tfor i, usym in enumerate(usyms):\n\t\tbeta_i[i*16:(i+1)*16] = chips_i[usym]\n\t\tbeta_q[i*16:(i+1)*16] = chips_q[usym]\n\n\treturn np.array([alpha_i, alpha_q, beta_i, beta_q])\n\n\ndef channel(alpha, beta, phi_range, tau, As, Au):\n\tRECV_CHIPS_I = detect_i(alpha, beta, phi_range, tau, As, Au)\n\tRECV_CHIPS_Q = detect_q(alpha, beta, phi_range, tau, As, Au)\n\n\t# return received chipping sequence with alternating I/Q chips for correlation ([i0, q0, i1, q1, ...])\n\tphi_idx = 0 # choose a phi_c value from the matrix\n\n\trecv_chips = np.zeros(2*RECV_CHIPS_I.shape[0])\n\trecv_chips[ ::2] = RECV_CHIPS_I[:,phi_idx]\n\trecv_chips[1::2] = RECV_CHIPS_Q[:,phi_idx]\n\n\treturn recv_chips\n\ndef detect_syms_corr(recv_chips):\n\tassert len(recv_chips)%32 == 0, ""The number of chips must be a multiple of the symbol length (32 chips)!""\n\n\trecv_syms = np.zeros(len(recv_chips)//32)\n\n\t# Choose the symbol with the highest correlation value\n\tfor i in range(len(recv_chips)//32):\n\t\tcurr_chips = recv_chips[i*32:(i+1)*32] / np.max(recv_chips[i*32:(i+1)*32])\n\t\tbest_syms  = []\n\t\tbest_corr  = 0\n\n\t\tfor sym in chips.keys():\n\t\t\tif sym is None:\n\t\t\t\tcontinue\n\n\t\t\tcurr_corr, = np.abs(np.correlate(chips[sym], curr_chips))\n\t\t\t#print(""sym:"",sym, ""corr: "", curr_corr)\n\n\t\t\tif curr_corr >= 32/2.:\n\t\t\t\t# correlation is bigger than 0.5, this can only happen with one sequence\n\t\t\t\tbest_syms = [sym]\n\t\t\t\tbreak\n\n\t\t\tif curr_corr > best_corr:\n\t\t\t\tbest_syms  = [sym]\n\t\t\t\tbest_corr  = curr_corr\n\t\t\telif curr_corr == best_corr:\n\t\t\t\tbest_syms.append(sym)\n\n\t\tif len(best_syms) > 1:\n\t\t\t# all values with the same correlation could be detected, just choose one ...\n\t\t\trecv_syms[i] = np.random.choice(best_syms)\n\t\telse:\n\t\t\trecv_syms[i] = best_syms[0]\n\n\treturn recv_syms\n\ndef detect_syms_corrcoef(recv_chips):\n\t""""""Find the symbols with the highest correlation to the received input chips.\n\n\tImplements Eq. 10 in the technical report. Should provide a speedup by using the np.corrcoef function, but doesn""t.\n\n\tParameters\n\t----------\n\trecv_chips\n\t\tInterleaved (soft) bits detected.\n\n\tReturns\n\t-------\n\trecv_syms\n\t\tA sequence of symbols that provide the best correlation to the input bit sequence.\n\t""""""\n\trecv_syms = np.array([])\n\n\tassert len(recv_chips)%32 == 0, ""The number of chips must be a multiple of the symbol length (32 chips)!""\n\n\t# Choose the symbol with the highest correlation value\n\tfor i in range(len(recv_chips)//32):\n\t\tcurr_chips = recv_chips[i*32:(i+1)*32]\n\n\t\tcorr_matrix = np.abs(np.corrcoef(curr_chips, chips_a))[0,1:]\n\t\tbest_syms,  = np.where(corr_matrix >= np.max(corr_matrix))\n\n\t\t# all values with the same correlation could be detected, just choose one ...\n\t\trecv_syms = np.append(recv_syms, np.random.choice(best_syms))\n\n\treturn recv_syms\n\ndef detect_syms_cerr(recv_chips):\n\trecv_syms = np.array([])\n\n\tassert len(recv_chips)%32 == 0, ""The number of chips must be a multiple of the symbol length (32 chips)!""\n\n\t# Choose the symbol with the lowest number of chip errors\n\twhile len(recv_chips) > 0:\n\t\tcurr_chips = recv_chips[:32]\n\t\tbest_sym  = 0\n\t\tbest_cerr = 33\n\n\t\tfor sym in chips:\n\t\t\tif not sym: continue\n\t\t\tcurr_cerr = np.sum(chips[sym][1:] != curr_chips[1:])\n\n\t\t\tif curr_cerr < best_cerr:\n\t\t\t\tbest_sym  = sym\n\t\t\t\tbest_cerr  = curr_cerr\n\n\t\trecv_syms = np.append(recv_syms, best_sym)\n\t\trecv_chips = recv_chips[32:]\n\n\treturn recv_syms\n\n\n\n# packet testing stuff, may be outdated ...\nif __name__ == ""__main__"":\n\talpha\t\t\t= np.array([[-1, 1, -1, 1, -1, -1], [ 1,  1, -1, -1, -1, 1]])  # (I,Q)\n\tbeta\t\t\t= np.array([[-1, 1, -1, 1,  1, -1], [-1, -1, -1,  1, -1, 1]])  # (I,Q)\n\tphi_range\t= np.arange(-np.pi, np.pi, np.pi/2)\n\n\tres = detect_i(alpha, beta, phi_range, -6.0, 1.0, 10.0)\n\t#res = detect_q(alpha, beta, phi_range, -6.0, 1.0, 10.0)\n\n\tnp.set_printoptions(threshold=np.NaN, precision=2, suppress=True, linewidth=180)\n\tprint(res[:,-1])\n\n\tusyms = [1,2,3]\n\tsyncsyms = [4,5,6]\n\n\tsend_chips = map_chips(usyms, syncsyms)\n\trecv_chips = channel(send_chips[:2], send_chips[2:], phi_range=[np.pi/2], tau=0.0, As=1.0, Au=100.0)\n\n\tfor i in range(1000):\n\t\trecv_syms = detect_syms_corrcoef(recv_chips)\n\n\tprint(recv_syms)\n'"
src/tools.py,0,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\n# python2 input fix (http://stackoverflow.com/questions/954834)\ntry: input = raw_input\nexcept NameError: pass\n\nimport os\nimport sys\n\ndef get_params(input_params):\n\tparams = []\n\n\tfor var, choices, prompt in input_params:\n\t\tresp = None\n\t\twhile resp not in choices:\n\t\t\tresp = input(prompt+"" ""+repr(choices) +""? "").lower()\n\t\tparams.append(resp)\n\n\treturn params\n\ndef overwrite_ok(filepath):\n\t# Since the computations are quite long, make sure that existing results should really be deleted!\n\tif os.path.exists(filepath):\n\t\tprint(""The file already exists!"")\n\t\tresp = None\n\n\t\twhile resp not in (""yes"", ""no"", ""y"", ""n""):\n\t\t\tresp = input(""Do you want to continue (y/n)? "").lower()\n\n\t\tif resp not in (""yes"", ""y""):\n\t\t\treturn False\n\n\treturn True\n\ndef osx_notify():\n\ttry:\n\t\tfrom osax import OSAX\n\texcept:\n\t\tprint(""appscript not installed ..."")\n\n\tsa = OSAX()\n\tsa.activate()\n\tsa.display_dialog(""%s: computations are finished!"" % (sys.argv[0]))\n'"
figs/ber_contour/gen_ber_contour.py,15,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport argparse\nimport sys\nimport time\n\nsys.path.append(""../../src"")\n\nimport numpy as np\nimport phitau_opt as pt\n\nimport tools\n\n######################################################\n#################      SETTINGS      #################\n######################################################\nT = 1.0\nnsteps = 250\n\nsettings = {\n\t""T"":      T,\n\t""As"":     1.0,\n\t""Au"":     100.0,\n\t""nbits"":  1024,\n\t""nsteps"": nsteps,\n\n\t""tau_range"": np.linspace(-1.5*T, 1.5*T, num=nsteps),\n\t""phi_range"": np.linspace(-np.pi, np.pi, num=nsteps)\n}\n\nglobals().update(settings)\n######################################################\n######################################################\n\ndef do_gen(content):\n\tstart_time = time.time()\n\n\tBER_U = np.zeros((tau_range.shape[0], phi_range.shape[0]))\n\tBER_S = np.zeros((tau_range.shape[0], phi_range.shape[0]))\n\n\tfor tau_idx in range(len(tau_range)):\n\t\ttau = tau_range[tau_idx]\n\n\t\tprint(""Step time for tau = %.3f: %.3fs""% (tau, time.time() - start_time))\n\t\tstart_time = time.time()\n\n\t\tif content in (""same"", ):\n\t\t\tsend_chips = np.array([2*np.random.randint(2, size=2*nbits)-1]).reshape((2, nbits))\n\t\t\tsend_chips = np.vstack((send_chips, send_chips))\n\t\telse:\n\t\t\tsend_chips = np.array([2*np.random.randint(2, size=4*nbits)-1]).reshape((4, nbits))\n\n\t\tRECV_CHIPS_I = pt.detect_i(send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\t\tRECV_CHIPS_Q = pt.detect_q(send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\n\t\tfor phi_idx in range(len(phi_range)):\n\t\t\trecv_chips       = np.empty(2*RECV_CHIPS_I.shape[0])\n\t\t\trecv_chips[ ::2] = np.sign(RECV_CHIPS_I[:,phi_idx])\n\t\t\trecv_chips[1::2] = np.sign(RECV_CHIPS_Q[:,phi_idx])\n\n\t\t\tsync_chips       = np.empty(2*send_chips.shape[1])\n\t\t\tsync_chips[ ::2] = send_chips[0]\n\t\t\tsync_chips[1::2] = send_chips[1]\n\n\t\t\tusync_chips       = np.empty(2*send_chips.shape[1])\n\t\t\tusync_chips[ ::2] = send_chips[2]\n\t\t\tusync_chips[1::2] = send_chips[3]\n\n\t\t\t# ignore chips that are only partially affected here (the outermost two chips)\n\t\t\tBER_U[tau_idx, phi_idx] = np.sum(recv_chips[2:-2] != usync_chips[2:-2]) / (1.0*len(recv_chips[2:-2]))\n\t\t\tBER_S[tau_idx, phi_idx] = np.sum(recv_chips[2:-2] != sync_chips[2:-2])  / (1.0*len(recv_chips[2:-2]))\n\n\tnp.savez_compressed(""data/ber_Au%.2f_%s.npz""%(Au, content), BER_S=BER_S, BER_U=BER_U, **settings)\n\n\nif __name__ == ""__main__"":\n\targp = argparse.ArgumentParser()\n\targp.add_argument(""content"",  choices=(""same"", ""unif""), help=""Relation between data content in the two transmitted packets"")\n\n\targs = argp.parse_args()\n\n\tif not tools.overwrite_ok(""data/ber_Au%.2f_%s.npz""%(Au, args.content)):\n\t\texit()\n\n\tdo_gen(args.content)\n'"
figs/ber_contour/plot_ber_contour.py,3,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n\nmpl.rc_file(""../rc/3fig-contour-rc.txt"")\n\ndef plot(mode, Au, content):\n\tdata = np.load(""data/ber_Au%.2f_%s.npz""%(Au, content))\n\tZu = data[""BER_U""]\n\tZs = data[""BER_S""]\n\tZ = (Zu if mode in (""usync"",) else Zs)\n\n\tPHI, TAU = np.meshgrid(data[""phi_range""], data[""tau_range""])\n\n\tprint(""Shapes: TAU %s, PHI %s, Zu %s"" %(TAU.shape, PHI.shape, Z.shape))\n\n\tCS  = plt.contourf(TAU, PHI/np.pi, Z,  levels=(0, 1e-6, 0.45, 0.55, 1-1e-6, 1), colors=(""0.0"", ""0.5"", ""0.75"", ""0.85"", ""1.0""), origin=""lower"")\n\tCS2 = plt.contour(CS, levels=(1e-6, 0.45, 0.55, 1-1e-6), colors=(""w"",)+3*(""r"",), linewidths=(1.0, 0.75,0.75,0.75,0.75), origin=""lower"", hold=""on"")\n\n\tplt.annotate(r""capture zone"", xy=(-0.35, 0.125), xytext=(-1.425, 0.475), fontsize=10, color=""1.0"",\n\t\tarrowprops=dict(arrowstyle=""->"", connectionstyle=""arc3,rad=-0.2"", color=""1.0""))\n\n\tplt.axis([-1.5, 1.5, -1, 1])\n\tplt.xlabel(r""Time offset $\\tau$ ($/T$)"", labelpad=2)\n\tplt.ylabel(r""Carrier phase offset $\\varphi_c$ ($/\\pi$)"", labelpad=0)\n\n\t#cb.set_label(r""Bit error rate ($\\mathrm{BER}$)"", labelpad=-7, y=0.35)\n\n\tplt.savefig(""pdf/berc2_Au%.2f_%s_%s.pdf""%(Au, mode, content))\n\ndef colorbar_only():\n\tfig = plt.figure(figsize=(0.375, 1.92))\n\tax1 = fig.add_axes([0, 0.05, 0.25, 1])\n\n\tcmap = mpl.colors.ListedColormap([""0.0"", ""0.5"", ""0.75"", ""0.85"", ""1.0""])\n\n\tbounds = [0.0, 1e-6, 0.45, 0.55, 1-1e-6, 1.0]\n\tnorm = mpl.colors.BoundaryNorm(bounds, cmap.N)\n\tcb2 = mpl.colorbar.ColorbarBase(ax1, cmap=cmap,\n                                         norm=norm,\n                                         boundaries=bounds,\n                                         ticks=bounds, # optional\n                                         orientation=""vertical"")\n\n\tcb2.set_ticklabels([""0"", ""$10^{-6}$"", ""0.45"", ""0.55"", ""$1-10^{-6}$"", ""1""])\n\tcb2.set_label(r""Bit error rate ($\\mathrm{BER}$)"", fontsize=12, labelpad=-7, y=0.4)\n\n\tplt.savefig(""pdf/cb.pdf"")\n\nif __name__ == ""__main__"":\n\tmode = (""sync"", ""usync"")[1] # choose if you want the BER performance of the sync""ed sender at the receiver or the other\n\n\tplot(mode, Au=100.0, content=""unif"")\n\t#colorbar_only()\n'"
figs/ber_contour_AsAu/gen_ber_contour_AsAu.py,28,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport argparse\nimport os\nimport sys\nimport time\n\nsys.path.append(\'../../src\')\n\nimport numpy as np\nimport phitau_opt as pt\nimport tools\n\n# multiprocessing stuff\nimport multiprocessing as mp\nfrom functools import partial\n\n######################################################\n#################      SETTINGS      #################\n######################################################\nT       = 1.0\nAs      = 1.0\nnbits   = 125*16\nnsteps  = 256\npktlen  = 64 # bits\n\ntau_range_g      = np.linspace(-1.5*T, 1.5*T, num=nsteps)\ntau_range_wide   = np.linspace(-4*T, 4*T, num=nsteps)\n\nAu_range_dB      = np.linspace(-10, 51, num=nsteps)\nAu_range_g       = np.sqrt(10.0**(Au_range_dB / 10.0))\n\nAu_range_wide_dB = np.linspace(-3, 16, num=nsteps)\nAu_range_wide    = np.sqrt(10.0**(Au_range_wide_dB / 10.0))\n\nphi_range        = np.linspace(-np.pi, np.pi, num=nsteps)\n######################################################\n######################################################\n\ndef do_gen(part, content, wide, numthreads):\n\tstart_time = time.time()\n\n\ttau_range  = (tau_range_wide if wide else tau_range_g)\n\tAu_range   = (Au_range_wide  if wide else Au_range_g)\n\n\ttau_range = np.split(tau_range, numthreads)[part]\n\n\tPRR_S = np.zeros((tau_range.shape[0], Au_range.shape[0]))\n\tPRR_U = np.zeros((tau_range.shape[0], Au_range.shape[0]))\n\n\tfor tau_idx, tau in enumerate(tau_range):\n\t\tif content in (\'same\',):\n\t\t\tsend_chips = np.array([2*np.random.randint(2, size=2*nbits)-1]).reshape((2, nbits))\n\t\t\tsend_chips = np.vstack((send_chips, send_chips))\n\t\telse:\n\t\t\tsend_chips = np.array([2*np.random.randint(2, size=4*nbits)-1]).reshape((4, nbits))\n\n\t\tfor Au_idx, Au in enumerate(Au_range):\n\t\t\tber_u_phi = np.zeros(phi_range.shape[0])\n\t\t\tber_s_phi = np.zeros(phi_range.shape[0])\n\n\t\t\tprint(\'%s: tau=%7.3f, tau_step=(%3i/%3i), Au=%7.3f, Au_step=(%3i/%3i), runtime: %5.2f secs\' %\\\n\t\t\t\t(sys.argv[0], tau, tau_idx+1, tau_range.shape[0], Au, Au_idx+1, Au_range.shape[0], time.time() - start_time))\n\n\t\t\tstart_time = time.time()\n\n\t\t\tRECV_CHIPS_I = pt.detect_i(send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\t\t\tRECV_CHIPS_Q = pt.detect_q(send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\n\t\t\tfor phi_idx, phi in enumerate(phi_range):\n\t\t\t\trecv_chips       = np.zeros(2*RECV_CHIPS_I.shape[0])\n\t\t\t\trecv_chips[::2]  = np.sign(RECV_CHIPS_I[:,phi_idx])\n\t\t\t\trecv_chips[1::2] = np.sign(RECV_CHIPS_Q[:,phi_idx])\n\n\t\t\t\tusync_chips       = np.zeros(2*send_chips.shape[1])\n\t\t\t\tusync_chips[::2]  = send_chips[2]\n\t\t\t\tusync_chips[1::2] = send_chips[3]\n\n\t\t\t\tsync_chips       = np.zeros(2*send_chips.shape[1])\n\t\t\t\tsync_chips[::2]  = send_chips[0]\n\t\t\t\tsync_chips[1::2] = send_chips[1]\n\n\t\t\t\t# ignore chips that are only partially affected here\n\t\t\t\tber_s_phi[phi_idx] = np.sum(recv_chips[2:-2] != sync_chips[2:-2])  / (1.0*len(recv_chips[2:-2]))\n\t\t\t\tber_u_phi[phi_idx] = np.sum(recv_chips[2:-2] != usync_chips[2:-2]) / (1.0*len(recv_chips[2:-2]))\n\n\t\t\tPRR_S[tau_idx, Au_idx] = np.mean((1-ber_s_phi)**pktlen)\n\t\t\tPRR_U[tau_idx, Au_idx] = np.mean((1-ber_u_phi)**pktlen)\n\n\tnp.savez_compressed(\'data/prr_AsAu_%s%s_part%i.npz\'%(content, wide, part), PRR_S=PRR_S, PRR_U=PRR_U,\n\t\ttau_range=tau_range, As=As, Au_range=Au_range, phi_range=phi_range,\n\t\tpktlen=pktlen, nsteps=nsteps, nbits=nbits)\n\n\nif __name__ == \'__main__\':\n\t# Query user to enter parameter settings, useful to run scripts in parallel\n\targp = argparse.ArgumentParser()\n\targp.add_argument(\'content\',  choices=(\'same\', \'unif\'), help=\'Relation between data content in the two transmitted packets\')\n\targp.add_argument(\'-w\', \'--wide\', action=\'store_true\', help=\'Wide interval of time offsets used (-4T to 4T instead of -1.5T to 1.5T)\')\n\targp.add_argument(\'-n\', \'--numthreads\', type=int, default=1, help=""Number of threads to start in the worker pool (default:1)"")\n\n\targs = argp.parse_args()\n\n\twide = (\'_wide\' if args.wide else \'\')\n\n\tif not tools.overwrite_ok(\'data/prr_AsAu_%s%s.npz\'%(args.content, wide)):\n\t\texit()\n\n\tpool = mp.Pool(args.numthreads)\n\tpool.map(partial(do_gen, content=args.content, wide=wide, numthreads=args.numthreads), list(range(args.numthreads)))\n\n\tPRR_S, PRR_U = None, None\n\n\ttau_range   = (tau_range_wide   if wide else tau_range_g)\n\tAu_range    = (Au_range_wide    if wide else Au_range_g)\n\tAu_range_dB = (Au_range_wide_dB if wide else Au_range_dB)\n\n\t# combine stuff again and cleanup\n\tfor part in range(args.numthreads):\n\t\tdata = np.load(\'data/prr_AsAu_%s%s_part%i.npz\'%(args.content, wide, part))\n\n\t\tfor vname in (\'PRR_S\', \'PRR_U\'):\n\t\t\tif locals()[vname] is None:\n\t\t\t\tlocals()[vname] = data[vname]\n\t\t\telse:\n\t\t\t\tlocals()[vname] = np.vstack((locals()[vname], data[vname]))\n\n\t\tos.remove(\'data/prr_AsAu_%s%s_part%i.npz\'%(args.content, wide, part))\n\n\tnp.savez_compressed(\'data/prr_AsAu_%s%s.npz\'%(args.content, wide),\n\t\tPRR_S=PRR_S, PRR_U=PRR_U,\n\t\ttau_range=tau_range, As=As, Au_range=Au_range, phi_range=phi_range, Au_range_dB=Au_range_dB,\n\t\tnsteps=nsteps, nbits=nbits, T=T, pktlen=pktlen)\n'"
figs/ber_contour_AsAu/plot_ber_contour_AsAu.py,2,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport argparse\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n\nmpl.rc_file(""../rc/1fig-contour-rc.txt"")\n\nfrom style_ber_contour_AsAu import Style1col\n\ndef do_plot(mode, content, wide):\n\tglobal style\n\tstyle.apply(mode, content, wide)\n\n\tdata = np.load(""data/prr_AsAu_%s%s.npz""%(content, wide))\n\n\tAU, TAU = np.meshgrid(-data[""Au_range_dB""], data[""tau_range""])\n\tZu = data[""PRR_U""]\n\tZs = data[""PRR_S""]\n\n\tassert TAU.shape == AU.shape == Zu.shape, ""The inputs TAU, AU, PRR_U must have the same shape for plotting!""\n\n\tplt.clf()\n\n\tif mode in (""sync"",):\n\t\t# Plot the inverse power ratio, sync signal is stronger for positive ratios\n\t\tCSf = plt.contourf(TAU, AU, Zs, levels=(0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0), colors=(""1.0"", ""0.75"", ""0.5"", ""0.25"", ""0.15"", ""0.0""), origin=""lower"")\n\t\tCS2 = plt.contour(CSf, colors = (""r"",)*5+(""w"",), linewidths=(0.75,)*5+(1.0,), origin=""lower"", hold=""on"")\n\telse:\n\t\tCSf  = plt.contourf(TAU, AU, Zs, levels=(0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0), colors=(""1.0"", ""0.75"", ""0.5"", ""0.25"", ""0.15"", ""0.0""), origin=""lower"")\n\t\tCS2f = plt.contour(CSf, levels=(0.0, 0.2, 0.4, 0.6, 0.8, 1.0), colors=4*(""r"",)+(""w"",), linewidths=(0.75,)*4+(1.0,), origin=""lower"", hold=""on"")\n\t\t#CS2f = plt.contour(TAU, -AU, Zu, levels=(0.9, 1.0), colors=(""0.0"",), linewidths=(1.0,), origin=""lower"", hold=""on"")\n\t\tif content in (""unif"",):\n\t\t\tCSu  = plt.contourf(TAU, AU, Zu, levels=(0.2, 1.0), hatches=(""////"",), colors=(""0.75"",), origin=""lower"")\n\t\t\tCS2  = plt.contour(CSu, levels=(0.2,), colors = (""r"",), linewidths=(1.0,), origin=""lower"", hold=""on"")\n\n\tstyle.annotate(mode, content, wide)\n\n\tplt.axis([data[""tau_range""][0], data[""tau_range""][-1], -data[""Au_range_dB""][-1], -data[""Au_range_dB""][0]])\n\n\tplt.ylabel(r""Signal power ratio ($\\mathrm{SIR}$)"", labelpad=2)\n\tplt.xlabel(r""Time offset $\\tau$ ($/T$)"", labelpad=2)\n\n\tplt.savefig(""pdf/prrc2_%s_%s%s_z.pdf""%(mode, content, wide))\n\n\n\nif __name__ == ""__main__"":\n\targp = argparse.ArgumentParser()\n\targp.add_argument(""mode"",  choices=(""sync"", ""usync""), help=""Plot from the view of the synchronized or unsynchronized sender"")\n\targp.add_argument(""content"",  choices=(""same"", ""unif""), help=""Relation between data content in the two transmitted packets"")\n\targp.add_argument(""-w"", ""--wide"", action=""store_true"", help=""Wide interval of time offsets used (-4T to 4T instead of -1.5T to 1.5T)"")\n\n\targs = argp.parse_args()\n\n\twide = (""_wide"" if args.wide else """")\n\n\tstyle = Style1col()\n\n\tdo_plot(args.mode, args.content, wide)\n'"
figs/ber_contour_AsAu/style_ber_contour_AsAu.py,0,"b""# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nclass Style(object):\n\tdef __init__(self):\n\t\tpass\n\nclass Style1col(Style):\n\n\tdef apply(self, mode, content, wide):\n\t\tmpl.rc_file('../rc/1fig-contour-rc.txt')\n\n\n\tdef annotate(self, mode, content, wide):\n\t\tif wide:\n\t\t\tself._annotate_wide()\n\t\telse:\n\t\t\tself._annotate()\n\n\n\tdef _annotate(self):\n\t\tplt.annotate(r'$\\delta_\\mathrm{SIR}$', xy=(-0.25, 1), xytext=(-1.25, 3), color='w', fontsize=8,\n\t\t\t\tarrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=-0.2', color='w'))\n\n\tdef _annotate_wide(self):\n\t\tplt.annotate(r'$\\delta_\\mathrm{SIR}$', xy=(-0.25, 1), xytext=(-2.75, 1.35), color='w', fontsize=8,\n\t\t\t\tarrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=-0.2', color='w'))\n\n"""
figs/msk_wave/plot_msk_wave.py,14,"b""#! /usr/bin/env python2.7\n\n# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.rc_file('../rc/2fig-rc.txt')\nmpl.rc('figure', figsize=(7, 4))\n\nI, Q\t\t= 0, 1\n\nT\t\t\t= 1.\ndt\t\t\t= 0.01\nmark_skip\t= 25\nt\t\t\t= np.arange(-2*T, 11*T, dt)\n\nfc\t\t\t= 1\nomega_c\t\t= 2 * np.pi * fc\nomega_p\t\t= np.pi / (2*T)\n\ntau\t\t\t= 0 * T/dt\n\n\nfig = plt.figure()\naxes = []\n\naxes.append(fig.add_subplot('311'))\naxes.append(fig.add_subplot('312'))\naxes.append(fig.add_subplot('313'))\n\nalpha\t= np.array([[ 1, 1, -1, -1, 1], [ 1, -1, 1, -1, 1]])\n\na_i\t\t= np.concatenate([np.repeat(a, (2*T)/dt) for a in alpha[I]])\na_i\t\t= np.concatenate([np.repeat(0., T/dt), a_i, np.repeat(0., 10*T/dt)])[:len(t)]\na_q\t\t= np.concatenate([np.repeat(a, (2*T)/dt) for a in alpha[Q]])\na_q\t\t= np.concatenate([np.repeat(0., 2*T/dt), a_q, np.repeat(0., 10*T/dt)])[:len(t)]\n\nfor ax in axes:\n\tax.set_xlim(-2, 11)\n\tax.set_ylim(-1.2, 1.2)\n\tax.set_yticklabels([])\n\tax.grid(axis='x')\n\tax.set_yticks((-1, 0, 1))\n\n\naxes[0].set_title('In-phase component', size=12)\naxes[0].set_xticks(range(-1, 12, 2))\naxes[0].set_xticks(range(0, 12, 2), minor=True)\naxes[0].set_xticklabels([])\n\naxes[1].set_title('Quadrature component', size=12)\n\naxes[1].set_xticks(range(0, 12, 2))\naxes[1].set_xticks(range(-1, 12, 2), minor=True)\naxes[1].set_xticklabels([])\naxes[1].set_ylabel('Transmitted signal amplitude')\n\naxes[2].set_title('Passband signal $s(t)$', size=12)\naxes[2].set_xlabel('Time $t$ ($/T$)')\naxes[2].set_xticks(range(-1, 11))\n\n\ns_i = a_i*np.cos(t*omega_c)*np.cos(t*omega_p)\ns_q = a_q*np.sin(t*omega_c)*np.sin(t*omega_p)\n\n\naxes[0].plot(t, a_i, c='0.0')\naxes[0].plot(t, s_i, c='0.4')\naxes[0].plot(t[::mark_skip], s_i[::mark_skip], '^', ms=4, c='0.4')\naxes[0].plot(t, a_i*np.cos(t*omega_p), c='0.7')\naxes[0].plot(t[::mark_skip], (a_i*np.cos(t*omega_p))[::mark_skip], 'o', ms=4, c='0.7')\n\naxes[1].plot(t, a_q, c='0.0')\naxes[1].plot(t, s_q, c='0.4')\naxes[1].plot(t[::mark_skip], s_q[::mark_skip], '^', ms=4, c='0.4')\naxes[1].plot(t, a_q*np.sin(t*omega_p), c='0.7')\naxes[1].plot(t[::mark_skip], (a_q*np.sin(t*omega_p))[::mark_skip], 'o', ms=4, c='0.7')\n\naxes[2].plot(t, s_i + s_q, c='0.1')\n\nplt.savefig('pdf/msk_wave.pdf')\n"""
figs/n_interferer/gen_ninterferer.py,15,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport argparse\nimport sys\nsys.path.append(""../../src"")\n\nimport numpy as np\nimport phitau_opt as pt\nimport phitau_n as ptn   # modified code for n concurrent signals\n\nimport tools\n\n######################################################\n#################      SETTINGS      #################\n######################################################\nnsteps         = 1024\nnum_interferer = 8\n\nsettings = {\n\t""T"":      1.0,\n\t""tau"":    0.0,\n\t""As"":     1.0,\n\t""Au"":     1./np.sqrt(2),\n\t""Au_"":    1./np.sqrt(2),\n\t""nsyms"":  1024,\n\t""nsteps"": nsteps,\n\t""pktlen"": 16,\n\t""num_interferer"": num_interferer,\n\n\t""phi_range"": None\n}\n\nglobals().update(settings)\n######################################################\n######################################################\n\ndef gen_n_interf(content, decision, mode=""n""):\n\t""""""@param mode: [n] refers to the n interferer mode, we use n low-power interferers with half the power of the sync signal\n\t                [1] refers to one strong interferer that has the sum of n interferers as its power level.\n\t""""""\n\tSER_S = np.empty((num_interferer+1, nsteps))\n\n\tfor ninterf_ in np.arange(0, num_interferer+1):\n\t\tprint(""Starting to generate for %i interferers, mode is %s"" % (ninterf_, mode))\n\t\tninterf = ninterf_  # remember the real number of virtual interferers (power setting)\n\t\tAu = Au_\n\n\t\tif mode in (""1"",):\n\t\t\t# we use a single interferer with the same power as n interferers\n\t\t\tAu = Au_ * np.sqrt(ninterf)\n\n\t\t\tif ninterf > 1:\n\t\t\t\tninterf = 1\n\n\t\tif ninterf == 0:\n\t\t\tphi_range = np.zeros((1,nsteps))\n\t\telse:\n\t\t\tphi_range = np.random.uniform(-np.pi, np.pi, size=nsteps*ninterf).reshape(ninterf, nsteps)\n\n\t\tif content in (""unif"",):\n\t\t\tsend_syms = np.random.randint(16, size=(ninterf+1)*(nsyms+2)).reshape(ninterf+1, nsyms+2)\n\t\telse:\n\t\t\t# everyone gets the same symbols to send\n\t\t\tsync_syms = np.random.randint(16, size=nsyms+2)\n\t\t\tsend_syms = np.vstack([sync_syms]*(ninterf+1))\n\n\t\tsend_syms_s = send_syms[0][1:-1]\n\t\tsend_chips = ptn.map_chips_n(*send_syms)\n\n\t\tRECV_CHIPS_I = ptn.detect_i_n(ninterf, send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\t\tRECV_CHIPS_Q = ptn.detect_q_n(ninterf, send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\n\t\tfor phi_idx in range(nsteps):\n\t\t\trecv_chips = np.zeros(2*RECV_CHIPS_I.shape[0])\n\t\t\trecv_chips[ ::2] = RECV_CHIPS_I[:,phi_idx]\n\t\t\trecv_chips[1::2] = RECV_CHIPS_Q[:,phi_idx]\n\n\t\t\t# slice bits to simulate hard decision decoder\n\t\t\tif decision in (""hard"",):\n\t\t\t\trecv_chips = np.sign(recv_chips)\n\n\t\t\trecv_syms = pt.detect_syms_corr(recv_chips)[1:-1]\n\n\t\t\tSER_S[ninterf_, phi_idx] = np.sum(recv_syms != send_syms_s) / (1.0*len(recv_syms))\n\n\t\tprint(""PRR = "", np.mean((1.0-SER_S[ninterf_,:])**pktlen))\n\n\tnp.savez_compressed(""data/ser_s_%s_%s_%s.npz""%(content, decision, mode), SER_S=SER_S, **settings)\n\nif __name__ == ""__main__"":\n\targp = argparse.ArgumentParser()\n\targp.add_argument(""content"",  choices=(""same"", ""unif""), help=""Relation between data content in the two transmitted packets"")\n\targp.add_argument(""decision"", choices=(""soft"", ""hard""), help=""Bit decision for DSSS decoding (SDD, HDD)"")\n\n\targs = argp.parse_args()\n\n\tif not tools.overwrite_ok(""data/ser_s_%s_%s_n.npy""%(args.content, args.decision)):\n\t\tsys.exit()\n\n\tgen_n_interf(args.content, args.decision, mode=""n"")\n\tgen_n_interf(args.content, args.decision, mode=""1"")\n'"
figs/n_interferer/plot_ninterferer.py,9,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport sys\n\nsys.path.append(""../../src"")\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.patches import Ellipse\n\nmpl.rc_file(""../rc/1fig-rc.txt"")\n\ndecision = (""hard"", ""soft"")[1]\n\ndef plot(decision):\n\tdata = np.load(""data/ser_s_%s_%s_n.npz""%(""same"", decision))\n\tser_s_n_same = data[""SER_S""]\n\tser_s_1_same = np.load(""data/ser_s_%s_%s_1.npz""%(""same"", decision))[""SER_S""]\n\tser_s_n_unif = np.load(""data/ser_s_%s_%s_n.npz""%(""unif"", decision))[""SER_S""]\n\tser_s_1_unif = np.load(""data/ser_s_%s_%s_1.npz""%(""unif"", decision))[""SER_S""]\n\n\tprr_s_n_same = np.mean((1.0-ser_s_n_same)**data[""pktlen""], axis=1)\n\tprr_s_1_same = np.mean((1.0-ser_s_1_same)**data[""pktlen""], axis=1)\n\tprr_s_n_unif = np.mean((1.0-ser_s_n_unif)**data[""pktlen""], axis=1)\n\tprr_s_1_unif = np.mean((1.0-ser_s_1_unif)**data[""pktlen""], axis=1)\n\n\tninterferers = np.arange(data[""num_interferer""]+1)\n\n\tfig = plt.figure()\n\tax = fig.add_subplot(111)\n\n\tax.set_xlabel(r""Number of interferers $n$"", labelpad=2)\n\tax.set_ylabel(r""Packet reception ratio (PRR)"", labelpad=2)\n\n\tax.set_xlim(0, data[""num_interferer""])\n\tax.set_ylim(0, 1)\n\n\tax.grid()\n\n\tax.plot(ninterferers, prr_s_n_same, ""b^-"")\n\tax.plot(ninterferers, prr_s_1_same, ""bo-"")\n\tax.plot(ninterferers, prr_s_n_unif, ""r^-"")\n\tax.plot(ninterferers, prr_s_1_unif, ""ro-"")\n\n\t# proxy artists to get black markers http://www.mail-archive.com/matplotlib-users@lists.sourceforge.net/msg25195.html\n\tl1, = ax.plot(ninterferers, prr_s_1_unif, ""k^"")\n\tl2, = ax.plot(ninterferers, prr_s_1_unif, ""ko"")\n\tl1.remove()\n\tl2.remove()\n\n\tplt.annotate(""Identical payload"", xy=(3.5, 0.775), xytext=(4, 0.675), color=""k"", fontsize=12, # xtext=2.5, 1.25\n                 arrowprops=dict(arrowstyle=""->"", color=""k"")) #connectionstyle=""arc3,rad=-0.2"",\n\n\te1 = Ellipse(xy=(3.55, 0.875), width=0.15, height=0.2, angle=0, fill=False)\n\tax.add_artist(e1)\n\n\tplt.annotate(""Independent payload"", xy=(2.42, 0.4), xytext=(0.2, 0.25), color=""k"", fontsize=12, # xtext=2.5, 1.25\n                 arrowprops=dict(arrowstyle=""->"", color=""k"")) #connectionstyle=""arc3,rad=-0.2"",\n\n\te2 = Ellipse(xy=(2.5, 0.55), width=0.15, height=0.4, angle=-45, fill=False)\n\tax.add_artist(e2)\n\n\tlgd = plt.legend((l2, l1), (r""One interferer with $n$-fold power"", r""$n$ interferers""), loc=""center right"", handlelength=0.5)\n\n\tplt.savefig(""pdf/ninterf_%s.pdf"" % (decision))\n\t#plt.show()\n\n\nif __name__ == ""__main__"":\n\tplot(decision)\n'"
figs/ser_contour/gen_ser_contour.py,10,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport argparse\nimport os\nimport sys\n\nsys.path.append(""../../src"")\n\nimport numpy as np\nimport phitau_opt as pt\nimport tools\n\n######################################################\n#################      SETTINGS      #################\n######################################################\nT = 1.0\nnsteps = 256\n\nsettings = {\n\t""As"":     1.0,\n\t""Au"":     np.sqrt(1e4),\n\t""nsyms"":  256,\n\t""nsteps"": nsteps,\n\n\t""tau_range"": np.linspace(-1.5*T, 1.5*T, num=nsteps),\n\t""phi_range"": np.linspace(-np.pi, np.pi, num=nsteps)\n}\n\nglobals().update(settings)\n######################################################\n######################################################\n\ndef do_gen(content, decision):\n\tSER_S = np.empty((tau_range.shape[0], phi_range.shape[0]))\n\tSER_U = np.empty((tau_range.shape[0], phi_range.shape[0]))\n\n\tfor tau_idx, tau in enumerate(tau_range):\n\t\tprint(""tau = %.2f"" % (tau))\n\n\t\t# symbols of (synch""ed, unsynch""ed) sender\n\t\tif content in (""same"",):\n\t\t\ttmp_syms = np.random.randint(16, size=nsyms+2)\n\t\t\tsend_syms = [tmp_syms, tmp_syms]\n\t\telse:\n\t\t\tsend_syms = np.random.randint(16, size=2*(nsyms+2)).reshape(2, nsyms+2)\n\n\t\tsend_syms_s, send_syms_u = send_syms[0][1:-1], send_syms[1][1:-1]\n\t\tsend_chips = pt.map_chips(*send_syms)\n\n\t\tRECV_CHIPS_I = pt.detect_i(send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\t\tRECV_CHIPS_Q = pt.detect_q(send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\n\t\tfor phi_idx in range(len(phi_range)):\n\t\t\trecv_chips       = np.empty(2*RECV_CHIPS_I.shape[0])\n\t\t\trecv_chips[ ::2] = RECV_CHIPS_I[:,phi_idx]\n\t\t\trecv_chips[1::2] = RECV_CHIPS_Q[:,phi_idx]\n\n\t\t\t# slice bits to simulate hard decision decoder\n\t\t\tif decision in (""hard"",):\n\t\t\t\trecv_chips = np.sign(recv_chips)\n\n\t\t\trecv_syms = pt.detect_syms_corr(recv_chips)[1:-1]\n\n\t\t\tSER_S[tau_idx, phi_idx] = sum(recv_syms != send_syms_s) / (1.0*len(recv_syms))\n\t\t\tSER_U[tau_idx, phi_idx] = sum(recv_syms != send_syms_u) / (1.0*len(recv_syms))\n\n\tnp.savez_compressed(""data/ser_Au%.2f_%s_%s_v2.npz""%(Au, content, decision),\n                        SER_S=SER_S, SER_U=SER_U, **settings)\n\nif __name__ == ""__main__"":\n\targp = argparse.ArgumentParser()\n\targp.add_argument(""content"",  choices=(""same"", ""unif""), help=""Relation between data content in the two transmitted packets"")\n\targp.add_argument(""decision"", choices=(""soft"", ""hard""), help=""Bit decision for DSSS decoding (SDD, HDD)"")\n\n\targs = argp.parse_args()\n\n\tif not tools.overwrite_ok(""data/ser_Au%.2f_%s_%s_v2.npz""%(Au, args.content, args.decision)):\n\t\tsys.exit(0)\n\n\tdo_gen(args.content, args.decision)\n'"
figs/ser_contour/plot_ser_contour.py,4,"b'#!/usr/bin/env python2.7\n\n# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n\nfrom matplotlib.font_manager import FontProperties\n\n\n######################################################\n###############    PLOT OPTIONS    ###################\n######################################################\nAu = np.sqrt(1e4)\n\nmode = (""sync"", ""usync"")[1]\ncontent = (""same"", ""unif"")[1]\ndecision = (""soft"", ""hard"")[0]\n######################################################\n######################################################\n\n\nmpl.rc_file(""../rc/3fig-contour-rc.txt"")\n\ndef plot():\n\tdata = np.load(""data/ser_Au%.2f_%s_%s_v2.npz""%(Au, content, decision))\n\n\tZs = data[""SER_S""]\n\tZu = data[""SER_U""]\n\tZ = (Zu if mode in (""usync"",) else Zs)\n\n\ttau_range = data[""tau_range""]\n\tphi_range = data[""phi_range""]\n\n\tPHI, TAU = np.meshgrid(phi_range, tau_range)\n\n\tprint(""DEBUG: If \'Inputs x and y must be 1D or 2D.\' -> Shape mismatch PHI, TAU, Z: "", PHI.shape, TAU.shape, Z.shape)\n\n\tCSf  = plt.contourf(TAU, PHI/np.pi, Z, levels=(0.0, 1e-3, 0.25, 0.9, 1.0), colors=(""0.0"", ""0.5"", ""0.75"", ""1.""), origin=""lower"")\n\tCS2 = plt.contour(CSf, levels=(0.9, 0.25, 1e-3), colors=(""1.0"", ""r"", ""w""), linewidths=(0., 0.75, 1.0), origin=""lower"", hold=""on"")\n\n\tplt.axis([-1.5, 1.5, -1, 1])\n\tplt.xlabel(r""Time offset $\\tau$ ($/T$)"", labelpad=2)\n\tplt.ylabel(r""Carrier phase offset $\\varphi_c$ ($/\\pi$)"", labelpad=0)\n\n\tplt.annotate(r""capture zone"", xy=(-0.35, 0.125), xytext=(-1.425, 0.475), color=""0.0"",\n        fontproperties=FontProperties(size=10, style=""italic""),\n        arrowprops=dict(arrowstyle=""->"", connectionstyle=""arc3,rad=-0.2"", color=""0.55"", lw=1.25))\n\tplt.annotate("""", xy=(-0.35, 0.85), xytext=(-0.8, 0.525),\n        arrowprops=dict(arrowstyle=""->"", connectionstyle=""arc3,rad=0.2"", lw=1.25, color=""0.55""))\n\tplt.annotate("""", xy=(-0.35, -0.85), xytext=(-0.9, 0.45),\n        arrowprops=dict(arrowstyle=""->"", connectionstyle=""arc3,rad=-0.2"", lw=1.25, color=""0.55""))\n\n\tplt.savefig(""pdf/serc_Au%.2f_%s_%s_%s_v2.pdf""%(Au, mode, content, decision))\n\t#plt.savefig(""png/serc2_Au%.2f_%s_%s_%s.png""%(Au, mode, content, decision), dpi=600)\n\ndef colorbar_only():\n\tfig = plt.figure(figsize=(0.375, 1.92))\n\tax1 = fig.add_axes([0, 0.05, 0.25, 1])\n\n\tcmap = mpl.colors.ListedColormap([""0.0"", ""0.5"", ""0.75"", ""1.0""])\n\n\tbounds = [0.0, 1e-3, 0.25, 0.9, 1.0]\n\tnorm = mpl.colors.BoundaryNorm(bounds, cmap.N)\n\tcb2 = mpl.colorbar.ColorbarBase(ax1, cmap=cmap,\n                                         norm=norm,\n                                         boundaries=bounds,\n                                         ticks=bounds, # optional\n                                         orientation=""vertical"")\n\n\tcb2.set_ticklabels([""0"", ""$10^{-3}$"", ""0.25"", ""0.9"", ""1""])\n\tcb2.set_label(r""Symbol error rate ($\\mathrm{SER}$)"", fontsize=12, labelpad=6)\n\n\tplt.savefig(""pdf/cb.pdf"")\n\n######################################################\nif __name__ == ""__main__"":\n\tplot()\n\t#colorbar_only()\n'"
figs/ser_contour_AsAu/gen_ser_contour_AsAu.py,28,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport argparse\nimport os\nimport sys\nimport time\n\nsys.path.append(""../../src"")\n\nimport numpy as np\nimport phitau_opt as pt\nimport tools\n\n# multiprocessing stuff\nimport multiprocessing as mp\nfrom functools import partial\n\n######################################################\n#################      SETTINGS      #################\n######################################################\nT = 1.0\nnsteps = 16\n\nAu_range_norm_dB = np.linspace(-10, 51, num=nsteps)\nAu_range_wide_dB = np.linspace(-3., 16, num=nsteps)\n\nsettings = {\n\t""T"":      T,\n\t""As"":     1.0,\n\t""nsyms"":  128,\n\t""nsteps"": nsteps,\n\t""pktlen"": 8,\n\n\t""Au_range_norm"":   np.sqrt(10.0**(Au_range_norm_dB / 10.0)),\n\t""Au_range_wide"":   np.sqrt(10.0**(Au_range_wide_dB / 10.0)),\n\t""Au_range_uwide"":  np.sqrt(10.0**(Au_range_wide_dB / 10.0)),\n\t""tau_range_norm"":  np.linspace(-1.5*T,  1.5*T, num=nsteps),\n\t""tau_range_wide"":  np.linspace(-4.0*T,  4.0*T, num=nsteps),\n\t""tau_range_uwide"": np.linspace(-12.0*T, 12.0*T, num=3*nsteps),\n\t""phi_range"":       np.linspace(-np.pi, np.pi, num=nsteps)\n}\n\nglobals().update(settings)\n######################################################\n######################################################\n\ndef do_gen(part, content, decision, wide, numthreads):\n\tif wide == ""_uwide"":\n\t\ttau_range = tau_range_uwide\n\t\tAu_range  = Au_range_uwide\n\telif wide == ""_wide"":\n\t\ttau_range = tau_range_wide\n\t\tAu_range  = Au_range_wide\n\telse:\n\t\ttau_range = tau_range_norm\n\t\tAu_range  = Au_range_norm\n\n\n\tstart_time = time.time()\n\n\ttau_range = np.split(tau_range, numthreads)[part]\n\n\tPRR_S = np.zeros((tau_range.shape[0], Au_range.shape[0]))\n\tPRR_U = np.zeros((tau_range.shape[0], Au_range.shape[0]))\n\n\tSER_S_PHI = np.zeros((tau_range.shape[0], phi_range.shape[0]))\n\tSER_U_PHI = np.zeros((tau_range.shape[0], phi_range.shape[0]))\n\n\tfor tau_idx, tau in enumerate(tau_range):\n\t\t# symbols of (synch""ed, unsynch""ed) sender\n\t\tif content in (""same"",):\n\t\t\ttmp_syms= np.random.randint(16, size=nsyms+2)\n\t\t\tsend_syms = np.vstack((tmp_syms, tmp_syms))\n\t\telse:\n\t\t\tsend_syms = np.random.randint(16, size=2*(nsyms+2)).reshape(2, nsyms+2)\n\n\t\tsend_syms_s, send_syms_u = send_syms[0][1:-1], send_syms[1][1:-1]\n\t\tsend_chips = pt.map_chips(*send_syms)\n\n\t\t#RECV_CHIPS_I_A = pt.detect_i(send_chips[:2], send_chips[2:], phi_range, tau, As, Au_range)\n\t\t#RECV_CHIPS_Q_A = pt.detect_q(send_chips[:2], send_chips[2:], phi_range, tau, As, Au_range)\n\n\t\tfor Au_idx, Au in enumerate(Au_range):\n\t\t\tprint(""%s: tau=%7.3f, tau_step=(%3i/%3i), Au=%7.3f, Au_step=(%3i/%3i), runtime: %5.2f secs"" %\\\n\t\t\t\t(sys.argv[0], tau, tau_idx+1, tau_range.shape[0], Au, Au_idx+1, Au_range.shape[0], time.time() - start_time))\n\t\t\tstart_time = time.time()\n\n\t\t\tRECV_CHIPS_I = pt.detect_i(send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\t\t\tRECV_CHIPS_Q = pt.detect_q(send_chips[:2], send_chips[2:], phi_range, tau, As, Au)\n\n\t\t\tfor phi_idx, phi in enumerate(phi_range):\n\t\t\t\t# Interleave the I and Q phase (this is faster than np.ravel)\n\t\t\t\trecv_chips       = np.zeros(2*RECV_CHIPS_I.shape[0])\n\t\t\t\trecv_chips[ ::2] = RECV_CHIPS_I[:,phi_idx]\n\t\t\t\trecv_chips[1::2] = RECV_CHIPS_Q[:,phi_idx]\n\n\t\t\t\tif decision in (""hard"",):\n\t\t\t\t\trecv_chips = np.sign(recv_chips)\n\n\t\t\t\trecv_syms = pt.detect_syms_corr(recv_chips)[1:-1]\n\n\t\t\t\tSER_S_PHI[tau_idx, phi_idx] = np.sum(recv_syms != send_syms_s) / (1.0*len(recv_syms))\n\t\t\t\tSER_U_PHI[tau_idx, phi_idx] = np.sum(recv_syms != send_syms_u) / (1.0*len(recv_syms))\n\n\t\t\tPRR_S[tau_idx, Au_idx] = np.mean((1.0-SER_S_PHI[tau_idx,:])**pktlen)\n\t\t\tPRR_U[tau_idx, Au_idx] = np.mean((1.0-SER_U_PHI[tau_idx,:])**pktlen)\n\n\tnp.savez_compressed(""data/prr_AsAu_%s_%s%s_part%i.npz""%(content, decision, wide, part),\n\t\t\t\t\t\tPRR_S=PRR_S, PRR_U=PRR_U, **settings)\n\n\n\nif __name__ == ""__main__"":\n\t# Query user to enter parameter settings, useful to run scripts in parallel\n\targp = argparse.ArgumentParser()\n\targp.add_argument(""content"",  choices=(""same"", ""unif""), help=""Relation between data content in the two transmitted packets"")\n\targp.add_argument(""decision"", choices=(""soft"", ""hard""), help=""Bit decision for DSSS decoding (SDD, HDD)"")\n\targp.add_argument(""-w"", ""--wide"", action=""store_true"", help=""Wide interval of time offsets used (-4T to 4T instead of -1.5T to 1.5T)"")\n\targp.add_argument(""-u"", ""--ultrawide"", action=""store_true"", help=""Extended wide interval of time offsets used (-12T to 12T)"")\n\targp.add_argument(""-n"", ""--numthreads"", type=int, default=1, help=""Number of threads to start in the worker pool (default:1)"")\n\n\targs = argp.parse_args()\n\n\tif not args.ultrawide:\n\t\twide = (""_wide"" if args.wide else """")\n\telse:\n\t\twide = ""_uwide""\n\n\tif not tools.overwrite_ok(""data/prr_AsAu_%s_%s%s.npz""%(args.content, args.decision, wide)):\n\t\texit()\n\n\tpool = mp.Pool(args.numthreads)\n\tpool.map(partial(do_gen, content=args.content, decision=args.decision, wide=wide, numthreads=args.numthreads), list(range(args.numthreads)))\n\n\tPRR_S, PRR_U = None, None\n\n\ttau_range   = (tau_range_wide   if wide else tau_range_norm)\n\tAu_range    = (Au_range_wide    if wide else Au_range_norm)\n\tAu_range_dB = (Au_range_wide_dB if wide else Au_range_norm_dB)\n\n\t# combine stuff again and cleanup\n\tfor part in range(args.numthreads):\n\t\tdata = np.load(""data/prr_AsAu_%s_%s%s_part%i.npz""%(args.content, args.decision, wide, part))\n\n\t\tfor vname in (""PRR_S"", ""PRR_U""):\n\t\t\tif locals()[vname] is None:\n\t\t\t\tlocals()[vname] = data[vname]\n\t\t\telse:\n\t\t\t\tlocals()[vname] = np.vstack((locals()[vname], data[vname]))\n\n\t\tos.remove(""data/prr_AsAu_%s_%s%s_part%i.npz""%(args.content, args.decision, wide, part))\n\n\tnp.savez_compressed(""data/prr_AsAu_%s_%s%s.npz""%(args.content, args.decision, wide),\n\t\tPRR_S=PRR_S, PRR_U=PRR_U, SER_S_PHI=SER_S_PHI, SER_U_PHI=SER_U_PHI,\n\t\ttau_range=tau_range, Au_range=Au_range, Au_range_dB=Au_range_dB, **settings)\n'"
figs/ser_contour_AsAu/plot_ser_contour_AsAu.py,7,"b'# Copyright 2013-2014 Matthias Wilhelm\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nimport itertools as it\n\nfrom style_ser_contour_AsAu import Style1col\n\n\ndef do_plot(mode, content, decision, wide):\n\tif mode in (""usync"",):\n\t\t_plot_usync(content, decision, wide)\n\telse:\n\t\t_plot_sync(content, decision, wide)\n\n\ndef _plot_sync(content, decision, wide):\n\tglobal style\n\tstyle.apply(""sync"", content, decision, wide)\n\n\tdata = np.load(""data/prr_AsAu_%s_%s%s.npz""%(content, decision, wide))\n\n\tAU, TAU = np.meshgrid(-data[""Au_range_dB""], data[""tau_range""])\n\n\tplt.clf()\n\tplt.axis([data[""tau_range""][0], data[""tau_range""][-1], -data[""Au_range_dB""][-1], -data[""Au_range_dB""][0]])\n\n\tassert TAU.shape == AU.shape == data[""PRR_S""].shape, ""The inputs TAU, AU, PRR_S must have the same shape for plotting!""\n\n\tCSf = plt.contourf(TAU, AU, data[""PRR_S""].T, levels=(0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0), colors=(""1.0"", ""0.5"", ""0.25"", ""0.15"", ""0.05"", ""0.0""), origin=""lower"")\n\tCS2 = plt.contour(CSf,  colors = (""r"",)*5+(""w"",), linewidths=(0.75,)*5+(1.0,), origin=""lower"", hold=""on"")\n\n\ttry:\n\t\tdata_bc = np.load(""../ber_contour_AsAu/data/prr_AsAu_%s%s.npz""%(content, wide))\n\t\tCS_bc = plt.contour(TAU, AU, data_bc[""PRR_S""], levels=(0.9,), colors=""w"", origin=""lower"", hold=""on"")\n\texcept IOError:\n\t\tprint(""File not found for BER, skipping ..."")\n\n\tstyle.annotate(""sync"", content, decision, wide)\n\n\tplt.xlabel(r""Time offset $\\tau$ ($/T$)"", labelpad=2)\n\tplt.ylabel(r""Signal power ratio ($\\mathrm{SIR}$)"", labelpad=2)\n\n\t#plt.savefig(""pdf/prr_sync_%s_%s%s_z.pdf""%(content, decision, wide))\n\n\n\ndef _plot_usync(content, decision, wide):\n\tglobal style\n\tstyle.apply(""usync"", content, decision, wide)\n\n\tdata = np.load(""data/prr_AsAu_%s_%s%s.npz""%(content, decision, wide))\n\n\t#Zs_bc = np.load(""../ber_contour_AsAu/data/prr_s_AsAu_%s%s.npy""%(content, wide))\n\t#Zu_bc = np.load(""../ber_contour_AsAu/data/prr_u_AsAu_%s%s.npy""%(content, wide))\n\n\tAU, TAU = np.meshgrid(-data[""Au_range_dB""], data[""tau_range""])\n\n\tplt.clf()\n\tplt.axis([data[""tau_range""][0], data[""tau_range""][-1], -data[""Au_range_dB""][-1]], -data[""Au_range_dB""][0])\n\n\tassert TAU.shape == AU.shape == data[""PRR_U""].shape, ""The inputs TAU, AU, PRR_S must have the same shape for plotting!""\n\n\tCSf = plt.contourf(TAU, AU, data[""PRR_U""], hatches=(None,)+(""////"",)*3, levels=(0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0), colors=(""1.0"", ""0.75"", ""0.5"", ""0.25"", ""0.15"", ""0.0""), origin=""lower"")\n\tCS2 = plt.contour(CSf, colors = 4*(""r"",)+(""w"",), linewidths=(1, 0.75, 0.75, 0.75, 0.75), origin=""lower"", hold=""on"")\n\n\tstyle.annotate(""usync"", content, decision, wide)\n\n\tplt.xlabel(r""Time offset $\\tau$ ($/T$)"", labelpad=2)\n\tplt.ylabel(r""Signal power ratio ($\\mathrm{SIR}$)"", labelpad=2)\n\n\tplt.savefig(""pdf/prr_usync_%s_%s%s_z.pdf""%(content, decision, wide))\n\n\n\ndef colorbar_only():\n\tfig = plt.figure(figsize=(0.375, 1.3))\n\tax1 = fig.add_axes([0, 0.05, 0.25, 1])\n\n\tcmap = mpl.colors.ListedColormap([""1.0"", ""0.75"", ""0.5"", ""0.25"", ""0.15"", ""0.0""])\n\n\tbounds = [0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0]\n\tnorm = mpl.colors.BoundaryNorm(bounds, cmap.N)\n\tcb2 = mpl.colorbar.ColorbarBase(ax1, cmap=cmap, boundaries=bounds, ticks=bounds, orientation=""vertical"")\n\n\tcb2.set_label(r""Packet reception ratio ($\\mathrm{PRR}$)"", fontsize=8)\n\n\tplt.savefig(""pdf/cb-1fig.pdf"")\n\n\n\nif __name__ == ""__main__"":\n\t#for mode, content in it.product((""sync"", ""usync""), (""unif"", ""same"")):\n\tmode =\t\t(""sync"", ""usync"")[0]\n\tcontent =\t(""unif"", ""same"")[1]\n\tdecision =\t(""soft"", ""hard"")[0]\n\twide =\t\t("""", ""_wide"")[1]\n\n\tstyle = Style1col()\n\n\t#for decision in (""hard"", ""soft""):\n\t\t#plot(mode, content, decision, wide)\n\n\t#plot (""sync"", ""unif"", ""soft"", """")\n\tdo_plot(mode, content, decision, wide)\n\n\t#colorbar_only()\n'"
figs/ser_contour_AsAu/style_ser_contour_AsAu.py,0,"b'import matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nclass Style(object):\n\tdef __init__(self):\n\t\tpass\n\nclass Style1col(Style):\n\n\tdef apply(self, mode, content, decision, wide):\n\t\tif mode == ""sync"":\n\t\t\tmpl.rc_file(""../rc/1fig-contour-rc.txt"")\n\n\t\telif mode == ""usync"":\n\t\t\tif decision in (""soft"",):\n\t\t\t\tmpl.rc_file(""../rc/1fig-contour-rc.txt"")\n\t\t\telse:\n\t\t\t\tmpl.rc_file(""../rc/2fig-contour-rc.txt"")\n\n\n\tdef annotate(self, mode, content, decision, wide):\n\t\tif wide:\n\t\t\tself._annotate_wide()\n\t\telse:\n\t\t\tself._annotate()\n\n\n\tdef _annotate(self):\n\t\tplt.annotate(r""$\\delta_\\mathrm{SIR}$"", xy=(-0.25, 1), xytext=(-1.25, 3), color=""w"", fontsize=8,\n\t\t\t\tarrowprops=dict(arrowstyle=""->"", connectionstyle=""arc3,rad=-0.2"", color=""w""))\n\n\tdef _annotate_wide(self):\n\t\tplt.annotate(r""$\\delta_\\mathrm{SIR}$"", xy=(-0.25, 1), xytext=(-2.75, 1.35), color=""w"", fontsize=8,\n\t\t\t\tarrowprops=dict(arrowstyle=""->"", connectionstyle=""arc3,rad=-0.2"", color=""w""))\n\n'"
