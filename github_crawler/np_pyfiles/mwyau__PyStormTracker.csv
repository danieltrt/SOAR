file_path,api_count,code
pystormtracker/__init__.py,0,"b'from detector import RectGrid, Center\nfrom linker import Tracks\n'"
pystormtracker/detector.py,2,"b'import math\nimport numpy as np\nimport numpy.ma as ma\nfrom abc import ABCMeta, abstractmethod\nfrom scipy.ndimage.filters import generic_filter, laplace\nimport Nio\n\nclass Grid(object):\n\n    __metaclass__ = ABCMeta\n\n    @abstractmethod\n    def get_var(self):\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_time(self):\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_lat(self):\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_lon(self):\n        raise NotImplementedError\n\n    @abstractmethod\n    def split(self, num):\n        raise NotImplementedError\n\n    @abstractmethod\n    def detect(self):\n        raise NotImplementedError\n\nclass Center(object):\n\n    R = 6367.\n    DEGTORAD = math.pi/180.\n\n    def __init__(self, time, lat, lon, var):\n        self.time =time\n        self.lat = lat\n        self.lon = lon\n        self.var = var\n\n    def __repr__(self):\n        return str(self.var)\n\n    def __str__(self):\n        return ""[time=""+str(self.time)+"", lat=""+str(self.lat)+"", lon=""+ \\\n                str(self.lon)+ "", var=""+str(self.var)+""]""\n\n    def abs_dist(self, center):\n        """"""Haversine formula for calculating the great circle distance""""""\n\n        if not isinstance(center, Center):\n            raise TypeError, ""must be compared with a Center object""\n\n        dlat = center.lat - self.lat\n        dlon = center.lon - self.lon\n\n        return self.R*2*math.asin(math.sqrt(math.sin(dlat/2*self.DEGTORAD)**2 + \\\n                math.cos(self.lat*self.DEGTORAD) * math.cos(center.lat*self.DEGTORAD) * \\\n                math.sin(dlon/2*self.DEGTORAD)**2))\n\n    def lat_dist(self, center):\n\n        if not isinstance(center, Center):\n            raise TypeError, ""must be compared with a Center object""\n\n        dlat = center.lat - self.lat\n\n        return self.R*dlat*self.DEGTORAD\n\n    def lon_dist(self, center):\n\n        if not isinstance(center, Center):\n            raise TypeError, ""must be compared with a Center object""\n\n        avglat = (self.lat + center.lat)/2\n        dlon = center.lon - self.lon\n\n        return self.R*dlon*self.DEGTORAD*math.cos(avglat*self.DEGTORAD)\n\nclass RectGrid(Grid):\n\n    def __init__(self, pathname, varname, trange=None):\n\n        self.pathname = pathname\n        self.varname = varname\n        self.trange = trange\n\n        self._open_file = False\n        self._var = None\n        self._time = None\n        self._lat = None\n        self._lon = None\n\n    def _init(self):\n\n        if self._open_file is False:\n            self._open_file = True\n            f = Nio.open_file(self.pathname)\n\n            # Dimension of var is time, lat, lon\n            self._var = f.variables[self.varname]\n            self._time = f.variables[\'time\']\n            self._lat = f.variables[\'lat\']\n            self._lon = f.variables[\'lon\']\n            self.time = None\n            self.lat = None\n            self.lon = None\n\n    def get_var(self, chart=None):\n\n        if self.trange is not None:\n            if self.trange[0] >= self.trange[1]:\n                return None\n\n        if chart is not None:\n            if type(chart) is tuple:\n                if len(chart) != 2 or type(chart[0]) is not int or \\\n                        type(chart[1]) is not int:\n                    raise TypeError, ""chart must be a tuple of two integers""\n            elif type(chart) is not int:\n                raise TypeError, ""chart must be an integer or tuple""\n\n            if self.trange is not None:\n                if type(chart) is int:\n                    if chart < 0 or chart >= self.trange[1]-self.trange[0]:\n                        raise IndexError, ""chart is out of bound of trange""\n                if type(chart) is tuple:\n                    if chart[0] == chart[1]:\n                        return None\n                    if chart[0] > chart[1]:\n                        raise IndexError, ""chart[1] must be larger than chart[0]""\n                    if chart[0] <0 or chart[0] > self.trange[1]-self.trange[0]:\n                        raise IndexError, ""chart[0] is out of bound of trange""\n                    if chart[1] <0 or chart[1] > self.trange[1]-self.trange[0]:\n                        raise IndexError, ""chart[1] is out of bound of trange""\n\n        self._init()\n\n        if type(chart) is int:\n            if self.trange is None:\n                return self._var[chart,:,:]\n            else:\n                return self._var[self.trange[0]+chart,:,:]\n        elif type(chart) is tuple:\n            if self.trange is None:\n                return self._var[chart[0]:chart[1],:,:]\n            else:\n                return self._var[self.trange[0]+chart[0]:self.trange[0]+chart[1],:,:]\n        else:\n            return self._var[:]\n\n    def get_time(self):\n\n        if self.trange is not None:\n            if self.trange[0] >= self.trange[1]:\n                return None\n\n        self._init()\n        if self.time is None:\n            if self.trange is None:\n                self.time = self._time[:]\n            else:\n                self.time = self._time[self.trange[0]:self.trange[1]]\n        return self.time\n\n    def get_lat(self):\n\n        self._init()\n        if self.lat is None:\n            self.lat = self._lat[:]\n        return self.lat\n\n    def get_lon(self):\n\n        self._init()\n        if self.lon is None:\n            self.lon = self._lon[:]\n        return self.lon\n\n    def split(self, num):\n\n        if type(num) is not int:\n            raise TypeError, ""number to split must be an integer""\n\n        if self._open_file is False:\n\n            if self.trange is not None:\n                time_len = self.trange[1]-self.trange[0]\n                tstart = self.trange[0]\n            else:\n                f = Nio.open_file(self.pathname)\n                time_len = f.dimensions[\'time\']\n                f.close()\n                tstart = 0\n\n            chunk_size = time_len//num\n            remainder = time_len%num\n\n            tranges = [(tstart+i*chunk_size+remainder*i//num, \\\n                    tstart+(i+1)*chunk_size+remainder*(i+1)//num) \\\n                    for i in range(num)]\n\n            return [RectGrid(self.pathname, self.varname, trange=it) \\\n                    for it in tranges]\n\n        else:\n            raise RuntimeError, ""RectGrid must not be initialized before running split()""\n\n    def _local_minima_func(self, buffer, size, threshold):\n\n        half_size = size//2\n\n        search_window = buffer.reshape((size, size))\n        origin = (half_size, half_size)\n\n        if threshold == 0.:\n            return search_window[origin] == search_window.min()\n        elif search_window[origin] == search_window.min():\n            # At least 8 of values in buffer should be larger than threshold\n            return sorted(buffer)[8] - search_window[origin] > threshold\n        else:\n            return False\n\n    def _local_minima_filter(self, input, size, threshold=0.):\n\n        if size%2 != 1:\n            raise ValueError, ""size must be an odd number""\n\n        half_size = size//2\n\n        output = generic_filter(input, self._local_minima_func, size=size, \\\n                mode=\'wrap\', extra_keywords={\'size\': size, \'threshold\': threshold})\n\n        # Mask the extreme latitudes\n        output[:half_size,:] = 0.\n        output[-half_size:,:] = 0.\n\n        return output\n\n    def _local_max_laplace(self, buffer, size):\n        origin = (size*size)//2\n        return buffer[origin] and buffer[origin] == buffer.max()\n\n    def _remove_dup_laplace(self, data, mask, size=5):\n        laplacian = np.multiply(laplace(data, mode=\'wrap\'), mask)\n\n        return generic_filter(laplacian, self._local_max_laplace, size=size, mode=\'wrap\',\n                extra_keywords={\'size\': size})\n\n    def detect(self, size=5, threshold=0., chart_buffer=400):\n\n        """"""Returns a list of list of Center\'s""""""\n\n        if self.trange is not None and self.trange[0]>=self.trange[1]:\n            return []\n\n        time = self.get_time()\n        lat = self.get_lat()\n        lon = self.get_lon()\n\n        centers = []\n\n        for it, t in enumerate(time):\n\n            ibuffer = it%chart_buffer\n            if ibuffer == 0:\n                var = self.get_var(chart=(it,min(it+chart_buffer,len(time))))\n            chart = var[ibuffer,:,:]\n\n            minima = self._local_minima_filter(chart, size, threshold=threshold)\n            minima = self._remove_dup_laplace(chart, minima, size=5)\n\n            center_list = [Center(t, lat[i], lon[j], chart[i,j]) \\\n                    for i, j in np.transpose(minima.nonzero())]\n            centers.append(center_list)\n\n        return centers\n\nif __name__ == ""__main__"":\n\n    grid = RectGrid(pathname=""../slp.2012.nc"", varname=""slp"")\n    grids = grid.split(128)\n\n    for g in grids:\n        print(g.trange)\n'"
pystormtracker/linker.py,0,"b'from detector import RectGrid, Center\n\nclass Tracks(object):\n\n    def __init__(self, threshold=500.):\n\n        self._tracks = []\n        self.head = []\n        self.tail = []\n        self.threshold = threshold\n        self.tstart = None\n        self.tend = None\n        self.dt = None\n\n    def __getitem__(self, index):\n        return self._tracks[index]\n\n    def __setitem__(self, index, value):\n        self._tracks[index] = value\n\n    def __iter__(self):\n        return iter(self._tracks)\n\n    def __len__(self):\n        return len(self._tracks)\n\n    def append(self, obj):\n        self._tracks.append(obj)\n\n    def match_center(self, centers):\n\n        ends = [self[i][-1] for i in self.tail]\n\n        dforward = [{} for i in range(len(ends))]\n        dbackward = [{} for i in range(len(centers))]\n\n        for ic1, c1 in enumerate(ends):\n            for ic2, c2 in enumerate(centers):\n                dist = c1.abs_dist(c2)\n                if dist < self.threshold:\n                    dforward[ic1][ic2] = dist\n                    dbackward[ic2][ic1] = dist\n\n        matched = [None for i in range(len(centers))]\n\n        while True:\n\n            has_match = False\n\n            for i, db in enumerate(dbackward):\n\n                if matched[i] is None and len(db)>0:\n\n                    iforward = min(db, key=db.get)\n                    di = dforward[iforward]\n\n                    if min(di, key=di.get) == i:\n                        matched[i] = iforward\n\n                        db = {}\n                        for j in dbackward:\n                            if iforward in j:\n                                del j[iforward]\n                        di = {}\n\n                        for j in dforward:\n                            if i in j:\n                                del j[i]\n\n                        has_match = True\n\n            if has_match is False:\n\n                break\n\n        return [self.tail[i] if i is not None else None for i in matched]\n\n    def match_track(self, tracks):\n\n        centers = [tracks[i][0] for i in tracks.head]\n        return self.match_center(centers)\n\n    def append_center(self, centers):\n\n        new_tail = []\n\n        matched_index = self.match_center(centers)\n\n        for i, d in enumerate(matched_index):\n\n            if self.tstart is None:\n                self.append([centers[i]])\n                self.head.append(len(self)-1)\n                new_tail.append(len(self)-1)\n            elif d is None or \\\n                    self.tend is not None and self.dt is not None and \\\n                    centers[0].time-self.dt > self.tend:\n                self.append([centers[i]])\n                new_tail.append(len(self)-1)\n            else:\n                self[d].append(centers[i])\n                new_tail.append(d)\n\n        self.tail = new_tail\n\n        self.tend = centers[0].time\n        if self.tstart is None:\n            self.tstart = centers[0].time\n        elif self.dt is None:\n            self.dt = self.tend - self.tstart\n\n    def extend_track(self, tracks):\n\n        new_tail = []\n\n        matched_index = self.match_track(tracks)\n        matched_dict = {d:matched_index[i] for i, d in enumerate(tracks.head)}\n        tail_dict = {d:None for d in tracks.tail}\n\n        for i, d in enumerate(tracks):\n            if i in matched_dict and matched_dict[i] is not None:\n                self[matched_dict[i]].extend(d)\n                if i in tail_dict:\n                    new_tail.append(matched_dict[i])\n            else:\n                self.append(d)\n                if i in tail_dict:\n                    new_tail.append(len(self)-1)\n\n        self.tail = new_tail\n\n        self.tend = tracks.tend\n\nif __name__ == ""__main__"":\n\n    import timeit\n    try:\n        import cPickle as pickle\n    except ImportError:\n        import pickle\n\n    print(""Starting detector..."")\n\n    timer = timeit.default_timer()\n    grid = RectGrid(pathname=""../slp.2012.nc"", varname=""slp"", trange=(0,120))\n    centers = grid.detect()\n\n    print(""Detection time: "" + str(timeit.default_timer()-timer))\n\n    print(""Starting linker..."")\n\n    timer = timeit.default_timer()\n\n    tracks = Tracks()\n\n    for c in centers:\n        tracks.append_center(c)\n\n    print(""Linking time: "" + str(timeit.default_timer()-timer))\n\n    num_tracks = len([t for t in tracks if len(t)>=8 and t[0].abs_dist(t[-1])>=1000.])\n\n    print(""Number of long tracks: ""+str(num_tracks))\n\n    pickle.dump(tracks, open(""tracks.pickle"", ""wb""))\n\n    print(""Starting multiple detector..."")\n\n    timer = timeit.default_timer()\n\n    grid2 = RectGrid(pathname=""../slp.2012.nc"", varname=""slp"", trange=(0,120))\n    grids2 = grid2.split(4)\n\n    centers2 = [g.detect() for g in grids2]\n\n    print(""Detection time: "" + str(timeit.default_timer()-timer))\n\n    print(""Starting multiple linker..."")\n\n    timer = timeit.default_timer()\n\n    tracks2 = [[] for i in range(4)]\n    for i, cs in enumerate(centers2):\n        tracks2[i] = Tracks()\n\n        for c in cs:\n            tracks2[i].append_center(c)\n\n    tracksout = tracks2[0]\n\n    for i in range(1,4):\n        tracksout.extend_track(tracks2[i])\n\n    print(""Detection time: "" + str(timeit.default_timer()-timer))\n\n    num_tracks = len([t for t in tracksout if len(t)>=8 and t[0].abs_dist(t[-1])>=1000.])\n\n    print(""Number of long tracks: ""+str(num_tracks))\n'"
pystormtracker/stormtracker.py,0,"b'import sys, getopt\nimport timeit\nfrom glob import glob\ntry:\n    import cPickle as pickle\nexcept ImportError:\n    import pickle\n\nfrom detector import RectGrid, Center\nfrom linker import Tracks\n\nif __name__ == ""__main__"":\n\n    try:\n        from mpi4py import MPI\n        USE_MPI = True\n    except ImportError:\n        USE_MPI = False\n\n    trange=None\n\n    argv = sys.argv[1:]\n    try:\n        opts, args = getopt.getopt(argv,""hi:v:o:n:"",[""input="",""var="",""output="",""num=""])\n    except getopt.GetoptError:\n        print(""stormtracker.py -i <input file> -v <variable name> -o <output file>"")\n        sys.exit(2)\n\n    for opt, arg in opts:\n        if opt == \'-h\':\n            print(""stormtracker.py -i <input file> -v <variable name> -o <output file> -n <number of time steps>"")\n            sys.exit()\n        elif opt in (""-i"", ""--input""):\n            infile = arg\n        elif opt in (""-v"", ""--var""):\n            var = arg\n        elif opt in (""-o"", ""--output""):\n            outfile = arg\n        elif opt in (""-n"", ""--num""):\n            trange = (0, int(arg))\n\n    timer = {}\n\n    if USE_MPI:\n        comm = MPI.COMM_WORLD\n        rank = comm.Get_rank()\n        size = comm.Get_size()\n        root = 0\n\n    if USE_MPI is False or rank == root:\n        timer[\'detector\'] = timeit.default_timer()\n\n    if USE_MPI:\n\n        if rank == root:\n            grid = RectGrid(pathname=infile, varname=var, trange=trange)\n            grid = grid.split(size)\n        else:\n            grid = None\n\n        grid = comm.scatter(grid, root=root)\n\n    else:\n        grid = RectGrid(pathname=infile, varname=var, trange=trange)\n\n    centers = grid.detect()\n\n    if USE_MPI:\n        comm.Barrier()\n    if USE_MPI is False or rank == root:\n        timer[\'detector\'] = timeit.default_timer()-timer[\'detector\']\n        timer[\'linker\'] = timeit.default_timer()\n\n    tracks = Tracks()\n\n    for c in centers:\n        tracks.append_center(c)\n\n    if USE_MPI:\n\n        timer[\'combiner\'] = timeit.default_timer()\n\n        nstripe = 2\n        while nstripe <= size:\n            if rank%nstripe == nstripe/2:\n                comm.send(tracks, dest = rank-nstripe/2, tag=nstripe)\n            elif rank%nstripe == 0:\n                if rank+nstripe/2 < size:\n                    tracks_recv = comm.recv(source=rank+nstripe/2, tag=nstripe)\n                    tracks.extend_track(tracks_recv)\n            nstripe = nstripe*2\n\n        timer[\'combiner\'] = timeit.default_timer()-timer[\'combiner\']\n\n    if USE_MPI is False or rank == root:\n        timer[\'linker\'] = timeit.default_timer()-timer[\'linker\']\n        print(""Detector time: ""+str(timer[\'detector\']))\n        print(""Linker time: ""+str(timer[\'linker\']))\n        print(""Combiner time: ""+str(timer[\'combiner\']))\n        num_tracks = len([t for t in tracks if len(t)>=8 and t[0].abs_dist(t[-1])>=1000.])\n        print(""Number of long tracks: ""+str(num_tracks))\n\n        pickle.dump(tracks, open(outfile, ""wb""))\n'"
