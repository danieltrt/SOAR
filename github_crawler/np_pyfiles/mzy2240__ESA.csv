file_path,api_count,code
setup.py,0,"b'import setuptools\nimport os\nimport re\n\nwith open(\'VERSION\', \'r\') as fh:\n    __version__ = fh.read()\n\nwith open(""README.rst"", ""r"") as fh:\n    long_description = fh.read()\n\n# Update the __version__ in __init__ before installing:\n# Path to __init__.py:\ninit_path = os.path.join(\'esa\', \'__init__.py\')\n# Read __init__.py:\nwith open(init_path, \'r\') as fh:\n    __init__ = fh.read()\n\n# Update the version:\n__init__ = re.sub(r\'__version__\\s*=\\s*[\\\'""][0-9]+\\.[0-9]+\\.[0-9]+[\\\'""]\',\n                  \'__version__ = ""{}""\'.format(__version__),\n                  __init__)\n\n# Write new __init__.py:\nwith open(init_path, \'w\') as fh:\n    fh.write(__init__)\n\nsetuptools.setup(\n    name=\'esa\',\n    version=__version__,\n    description=\'Easy SimAuto (ESA): An easy-to-use Python connector to \'\n                \'PowerWorld Simulator Automation Server (SimAuto).\',\n    long_description=long_description,\n    long_description_content_type=""text/x-rst"",\n    author=\'Zeyu Mao, Brandon Thayer, Yijing Liu\',\n    author_email=\'zeyumao2@tamu.edu, blthayer@tamu.edu, yiji21@tamu.edu\',\n    url=\'https://github.com/mzy2240/ESA\',\n    packages=setuptools.find_packages(),\n    classifiers=[\n        ""Programming Language :: Python :: 3 :: Only"",\n        ""Programming Language :: Python :: 3.5"",\n        ""Programming Language :: Python :: 3.6"",\n        ""Programming Language :: Python :: 3.7"",\n        ""Programming Language :: Python :: 3.8"",\n        ""License :: OSI Approved :: MIT License"",\n        ""Operating System :: Microsoft :: Windows"",\n        ""Development Status :: 5 - Production/Stable"",\n        ""Environment :: Win32 (MS Windows)"",\n        ""Intended Audience :: Developers"",\n        ""Intended Audience :: Education"",\n        ""Intended Audience :: Science/Research"",\n        ""Natural Language :: English"",\n        ""Topic :: Education"",\n        ""Topic :: Scientific/Engineering"",\n        ""Topic :: Software Development"",\n\n    ],\n    keywords=[\'Python\', \'PowerWorld\', \'PowerWorld Simulator\', \'Simulator\',\n              \'PowerWorld Simulation Automation Server\', \'SimAuto\',\n              \'Automation\', \'Power Systems\', \'Electric Power\', \'Power\',\n              \'Easy SimAuto\', \'ESA\', \'Smart Grid\', \'Numpy\', \'Pandas\'],\n    install_requires=[\'pandas >= 0.25\', \'numpy >= 1.13.3\', \'pywin32\',\n                      \'pypiwin32\'],\n    python_requires=\'>=3.5\',\n    # There are a couple tests that use networkx, and we use the magic\n    # of sphinx for documentation. Coverage is necessary to keep the\n    # coverage report up to date.\n    extras_require={\'test\': [\'networkx\', \'coverage\', \'matplotlib\'],\n                    \'doc\': [\'sphinx\', \'tabulate\']},\n    license=\'MIT\',\n    # TODO: Why aren\'t we zip safe?\n    zip_safe=False\n)\n'"
esa/__init__.py,0,"b'""""""The following are importable from the top-level ``esa`` package:\n\n*   SAW: ESA\'s primary class\n*   Error: Base Error class for ESA exceptions. This exception is never\n    directly raised.\n*   PowerWorldError: Error class for when PowerWorld/SimAuto reports an\n    error.\n*   COMError: Error class for when something goes wrong communicating\n    with Windows and/or SimAuto.\n*   CommandNotRespectedError: Error class for when a commanded change is\n    not respected by PowerWorld/SimAuto. This exception is only raised\n    via SAW helper methods like\n    ``change_and_confirm_params_multiple_element``\n*   __version__: ESA\'s version.\n""""""\n# Please keep the docstring above up to date with all the imports.\nfrom .saw import SAW, PowerWorldError, COMError, CommandNotRespectedError,\\\n    Error\n__version__ = ""1.0.3""\n'"
esa/saw.py,12,"b'""""""saw is short for SimAuto Wrapper. This module provides a class,\nSAW, for interfacing with PowerWorld\'s Simulator Automation Server\n(SimAuto). In addition to the SAW class, there are a few custom error\nclasses, such as PowerWorldError.\n\nPowrWorld\'s documentation for SimAuto can be found\n`here\n<https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/Simulator_Automation_Server.htm%3FTocPath%3DAutomation%2520Server%2520Add-On%2520(SimAuto)%7C_____1>`__\n""""""\nimport logging\nimport os\nfrom pathlib import Path, PureWindowsPath\nfrom typing import Union, List, Tuple\nimport re\nimport datetime\n\nimport numpy as np\nimport pandas as pd\nimport pythoncom\nimport win32com\nfrom win32com.client import VARIANT\n\nimport tempfile\n\n# TODO: Make logging more configurable.\nlogging.basicConfig(\n    format=""%(asctime)s [%(levelname)s] [%(name)s]: %(message)s"",\n    datefmt=""%H:%M:%S""\n)\n\n# Listing of PowerWorld data types. I guess \'real\' means float?\nDATA_TYPES = [\'Integer\', \'Real\', \'String\']\n# Hard-code based on indices.\nNUMERIC_TYPES = DATA_TYPES[0:2]\nNON_NUMERIC_TYPES = DATA_TYPES[-1]\n\n# RequestBuildDate uses Delphi conventions, which counts days since\n# Dec. 30th, 1899.\nDAY_0 = datetime.date(year=1899, month=12, day=30)\n\n\n# noinspection PyPep8Naming\nclass SAW(object):\n    """"""A SimAuto Wrapper in Python""""""\n\n    # Class level property defining the fields which will be returned\n    # for different ObjectTypes by the get_power_flow_results method.\n    POWER_FLOW_FIELDS = {\n        \'bus\': [\'BusNum\', \'BusName\', \'BusPUVolt\', \'BusAngle\', \'BusNetMW\',\n                \'BusNetMVR\'],\n        \'gen\': [\'BusNum\', \'GenID\', \'GenMW\', \'GenMVR\'],\n        \'load\': [\'BusNum\', \'LoadID\', \'LoadMW\', \'LoadMVR\'],\n        \'shunt\': [\'BusNum\', \'ShuntID\', \'ShuntMW\', \'ShuntMVR\'],\n        \'branch\': [\'BusNum\', \'BusNum:1\', \'LineCircuit\', \'LineMW\',\n                   \'LineMW:1\', \'LineMVR\', \'LineMVR:1\']\n    }\n\n    # Class level property defining the columns used by the DataFrame\n    FIELD_LIST_COLUMNS = \\\n        [\'key_field\', \'internal_field_name\', \'field_data_type\', \'description\',\n         \'display_name\']\n\n    # Older versions of Simulator omit the ""display name"" field.\n    FIELD_LIST_COLUMNS_OLD = FIELD_LIST_COLUMNS[0:-1]\n\n    # Class level property defining columns used for\n    # GetSpecificFieldList method.\n    SPECIFIC_FIELD_LIST_COLUMNS = \\\n        [\'variablename:location\', \'field\', \'column header\',\n         \'field description\']\n\n    # SimAuto properties that we allow users to set via the\n    # set_simauto_property method.\n    SIMAUTO_PROPERTIES = {\'CreateIfNotFound\': bool, \'CurrentDir\': str,\n                          \'UIVisible\': bool}\n\n    def __init__(self, FileName, early_bind=False, UIVisible=False,\n                 object_field_lookup=(\'bus\', \'gen\', \'load\', \'shunt\',\n                                      \'branch\'),\n                 CreateIfNotFound=False):\n        """"""Initialize SimAuto wrapper. The case will be opened, and\n        object fields given in object_field_lookup will be retrieved.\n\n        :param FileName: Full file path to .pwb file to open. This will\n            be passed to the SimAuto function OpenCase.\n        :param early_bind: Whether (True) or not (False) to connect to\n            SimAuto via early binding.\n        :param UIVisible: Whether or not to display the PowerWorld UI.\n        :param CreateIfNotFound: Set CreateIfNotFound = True if objects\n            that are updated through the ChangeParameters functions\n            should be created if they do not already exist in the case.\n            Objects that already exist will be updated.\n            Set CreateIfNotFound = False to not create new objects\n            and only update existing ones.\n        :param object_field_lookup: Listing of PowerWorld objects to\n            initially look up available fields for. Objects not\n            specified for lookup here will be looked up later as\n            necessary.\n\n        Note that\n        `Microsoft recommends\n        <https://docs.microsoft.com/en-us/office/troubleshoot/office-developer/binding-type-available-to-automation-clients>`__\n        early binding in most cases.\n        """"""\n        # Initialize logger.\n        self.log = logging.getLogger(self.__class__.__name__)\n        # Useful reference for early vs. late binding:\n        # https://docs.microsoft.com/en-us/office/troubleshoot/office-developer/binding-type-available-to-automation-clients\n        #\n        # Useful reference for early and late binding in pywin32:\n        # https://youtu.be/xPtp8qFAHuA\n        try:\n            if early_bind:\n                # Use early binding.\n                self._pwcom = win32com.client.gencache.EnsureDispatch(\n                    \'pwrworld.SimulatorAuto\')\n            else:\n                # Use late binding.\n                self._pwcom = win32com.client.dynamic.Dispatch(\n                    \'pwrworld.SimulatorAuto\')\n        except Exception as e:\n            m = (""Unable to launch SimAuto. "",\n                 ""Please confirm that your PowerWorld license includes ""\n                 ""the SimAuto add-on, and that SimAuto has been ""\n                 ""successfully installed."")\n            self.log.exception(m)\n\n            raise e\n\n        # Initialize self.pwb_file_path. It will be set in the OpenCase\n        # method.\n        self.pwb_file_path = None\n        # Set the CreateIfNotFound and UIVisible properties.\n        self.set_simauto_property(\'CreateIfNotFound\', CreateIfNotFound)\n        self.set_simauto_property(\'UIVisible\', UIVisible)\n\n        # Prepare an empty auxiliary file used for updating the UI.\n        self.ntf = tempfile.NamedTemporaryFile(mode=\'w\', suffix=\'.axd\',\n                                               delete=False)\n        self.empty_aux = Path(self.ntf.name).as_posix()\n        self.ntf.close()\n\n        # Open the case.\n        self.OpenCase(FileName=FileName)\n\n        # Get the version number and the build date\n        version_string, self.build_date = self.get_version_and_builddate()\n        self.version = int(re.search(r\'\\d+\', version_string).group(0))\n\n        # Look up and cache field listing and key fields for the given\n        # object types in object_field_lookup.\n        self._object_fields = dict()\n        self._object_key_fields = dict()\n\n        for obj in object_field_lookup:\n            # Always use lower case.\n            o = obj.lower()\n\n            # Get the field listing. This will store the resulting\n            # field list in self._object_fields[o].\n            self.GetFieldList(o)\n\n            # Get the key fields for this object. This will store the\n            # results in self._object_key_fields[o]\n            self.get_key_fields_for_object_type(ObjectType=o)\n\n    ####################################################################\n    # Helper Functions\n    ####################################################################\n    def change_and_confirm_params_multiple_element(self, ObjectType: str,\n                                                   command_df: pd.DataFrame) \\\n            -> None:\n        """"""Change parameters for multiple objects of the same type, and\n        confirm that the change was respected by PowerWorld.\n\n        :param ObjectType: The type of objects you are changing\n            parameters for.\n        :param command_df: Pandas DataFrame representing the objects\n            which will have their parameters changed. The columns should\n            be object field variable names, and MUST include the key\n            fields for the given ObjectType (which you can get via the\n            get_key_fields_for_object_type method). Columns which are\n            not key fields indicate parameters to be changed, while the\n            key fields are used internally by PowerWorld to look up\n            objects. Each row of the DataFrame represents a single\n            element.\n\n        :raises CommandNotRespectedError: if PowerWorld does not\n            actually change the parameters.\n        :raises: PowerWorldError: if PowerWorld reports an error.\n\n        :returns: None\n        """"""\n        # Start by cleaning up the DataFrame. This will avoid silly\n        # issues later (e.g. comparing \' 1 \' and \'1\').\n        cleaned_df = self._change_parameters_multiple_element_df(\n            ObjectType=ObjectType, command_df=command_df)\n\n        # Now, query for the given parameters.\n        df = self.GetParametersMultipleElement(\n            ObjectType=ObjectType, ParamList=cleaned_df.columns.tolist())\n\n        # Check to see if the two DataFrames are equivalent.\n        eq = self._df_equiv_subset_of_other(df1=cleaned_df, df2=df,\n                                            ObjectType=ObjectType)\n\n        # If DataFrames are not equivalent, raise a\n        # CommandNotRespectedError.\n        if not eq:\n            m = (\'After calling ChangeParametersMultipleElement, not all \'\n                 \'parameters were actually changed within PowerWorld. Try \'\n                 \'again with a different parameter (e.g. use GenVoltSet \'\n                 \'instead of GenRegPUVolt).\')\n            raise CommandNotRespectedError(m)\n\n        # All done.\n        return None\n\n    def change_parameters_multiple_element_df(\n            self, ObjectType: str, command_df: pd.DataFrame) -> None:\n        """"""Helper to call ChangeParametersMultipleElement, but uses a\n        DataFrame to determine parameters and values. This method is\n        lighter weight but perhaps ""riskier"" than the\n        ""change_and_confirm_params_multiple_element"" method, as no\n        effort is made to ensure PowerWorld respected the given command.\n\n        :param ObjectType: The type of objects you are changing\n            parameters for.\n        :param command_df: Pandas DataFrame representing the objects\n            which will have their parameters changed. The columns should\n            be object field variable names, and MUST include the key\n            fields for the given ObjectType (which you can get via the\n            get_key_fields_for_object_type method). Columns which are\n            not key fields indicate parameters to be changed, while the\n            key fields are used internally by PowerWorld to look up\n            objects. Each row of the DataFrame represents a single\n            element.\n        """"""\n        # Simply call the helper function.\n        self._change_parameters_multiple_element_df(\n            ObjectType=ObjectType, command_df=command_df)\n\n    def clean_df_or_series(self, obj: Union[pd.DataFrame, pd.Series],\n                           ObjectType: str) -> Union[pd.DataFrame, pd.Series]:\n        """"""Helper to cast data to the correct types, clean up strings,\n        and sort DataFrame by BusNum (if applicable/present).\n\n        :param obj: DataFrame or Series to clean up. It\'s assumed that\n            the object came more or less directly from placing results\n            from calling SimAuto into a DataFrame or Series. This means\n            all data will be strings (even if they should be numeric)\n            and data which should be strings often have unnecessary\n            white space. If obj is a DataFrame (Series), the columns\n            (index) must be existing fields for the given object type\n            (i.e. are present in the \'internal_field_name\' column of the\n            corresponding DataFrame which comes from calling\n            GetFieldList for the given object type).\n        :param ObjectType: Object type the data in the DataFrame relates\n            to. E.g. \'gen\'\n\n        :raises ValueError: if the DataFrame (Series) columns (index)\n            are not valid fields for the given object type.\n\n        :raises TypeError: if the input \'obj\' is not a DataFrame or\n            Series.\n        """"""\n        # Get the type of the obj.\n        if isinstance(obj, pd.DataFrame):\n            df_flag = True\n            fields = obj.columns.to_numpy()\n        elif isinstance(obj, pd.Series):\n            df_flag = False\n            fields = obj.index.to_numpy()\n        else:\n            raise TypeError(\'The given object is not a DataFrame or \'\n                            \'Series!\')\n\n        # Determine which types are numeric.\n        numeric = self.identify_numeric_fields(ObjectType=ObjectType,\n                                               fields=fields)\n        numeric_fields = fields[numeric]\n\n        # Make the numeric fields, well, numeric.\n        obj[numeric_fields] = obj[numeric_fields].apply(pd.to_numeric)\n\n        # Now handle the non-numeric cols.\n        nn_cols = fields[~numeric]\n\n        # Start by ensuring the non-numeric columns are indeed strings.\n        obj[nn_cols] = obj[nn_cols].astype(str)\n\n        # Here we\'ll strip off the white space.\n        if df_flag:\n            # Need to use apply to strip strings from multiple columns.\n            obj[nn_cols] = obj[nn_cols].apply(lambda x: x.str.strip())\n        else:\n            # A series is much simpler, and the .str.strip() method can\n            # be used directly.\n            obj[nn_cols] = obj[nn_cols].str.strip()\n\n        # Sort by BusNum if present.\n        if df_flag:\n            try:\n                obj.sort_values(by=\'BusNum\', axis=0, inplace=True)\n            except KeyError:\n                # If there\'s no BusNum don\'t sort the DataFrame.\n                pass\n            else:\n                # Re-index with simple monotonically increasing values.\n                obj.index = np.arange(start=0, stop=obj.shape[0])\n\n        return obj\n\n    def exit(self):\n        """"""Clean up for the PowerWorld COM object""""""\n        # Clean the empty aux file\n        os.unlink(self.ntf.name)\n        # Close the case and delete the COM object\n        self.CloseCase()\n        del self._pwcom\n        self._pwcom = None\n        return None\n\n    def get_key_fields_for_object_type(self, ObjectType: str) -> pd.DataFrame:\n        """"""Helper function to get all key fields for an object type.\n\n        :param ObjectType: The type of the object to get key fields for.\n\n        :returns: DataFrame with the following columns:\n            \'internal_field_name\', \'field_data_type\', \'description\', and\n            \'display_name\'. The DataFrame will be indexed based on the key\n            field returned by the Simulator, but modified to be 0-based.\n\n        This method uses the GetFieldList function, documented\n        `here\n        <https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/GetFieldList_Function.htm%3FTocPath%3DAutomation%2520Server%2520Add-On%2520(SimAuto)%7CAutomation%2520Server%2520Functions%7C_____14>`__.\n\n        It\'s also worth looking at the key fields documentation\n        `here\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/Key_Fields.htm>`__.\n        """"""\n        # Cast to lower case.\n        obj_type = ObjectType.lower()\n\n        # See if we\'ve already looked up the key fields for this object.\n        # If we have, just return the cached results.\n        try:\n            key_field_df = self._object_key_fields[obj_type]\n        except KeyError:\n            # We haven\'t looked up key fields for this object yet.\n            pass\n        else:\n            # There\'s not work to do here. Return the DataFrame.\n            return key_field_df\n\n        # Get the listing of fields for this object type.\n        field_list = self.GetFieldList(ObjectType=obj_type, copy=False)\n\n        # Here\'s what I\'ve gathered:\n        # Key fields will be of the format *<number><letter>*\n        #   where the <letter> part is optional. It seems the\n        #   letter is only listed for the last key field.\n        # Required fields are indicated with \'**\'.\n        # There are also fields of the form *<letter>* and these\n        #   seem to be composite fields? E.g. \'BusName_NomVolt\'.\n\n        # Extract key fields.\n        key_field_mask = \\\n            field_list[\'key_field\'].str.match(r\'\\*[0-9]+[A-Z]*\\*\').to_numpy()\n        # Making a copy isn\'t egregious here because there are a\n        # limited number of key fields, so this will be a small frame.\n        key_field_df = field_list.loc[key_field_mask].copy()\n\n        # Replace \'*\' with the empty string.\n        key_field_df[\'key_field\'] = \\\n            key_field_df[\'key_field\'].str.replace(r\'\\*\', \'\')\n\n        # Remove letters.\n        key_field_df[\'key_field\'] = \\\n            key_field_df[\'key_field\'].str.replace(\'[A-Z]*\', \'\')\n\n        # Get numeric, 0-based index.\n        key_field_df[\'key_field_index\'] = \\\n            pd.to_numeric(key_field_df[\'key_field\']) - 1\n\n        # Drop the key_field column (we only wanted to convert to an\n        # index).\n        key_field_df.drop(\'key_field\', axis=1, inplace=True)\n\n        # Use the key_field_index for the DataFrame index.\n        key_field_df.set_index(keys=\'key_field_index\', drop=True,\n                               verify_integrity=True, inplace=True)\n\n        # Sort the index.\n        key_field_df.sort_index(axis=0, inplace=True)\n\n        # Ensure the index is as expected (0, 1, 2, 3, etc.)\n        assert np.array_equal(\n            key_field_df.index.to_numpy(),\n            np.arange(0, key_field_df.index.to_numpy()[-1] + 1))\n\n        # Track for later.\n        self._object_key_fields[obj_type] = key_field_df\n\n        return key_field_df\n\n    def get_key_field_list(self, ObjectType: str) -> List[str]:\n        """"""Convenience function to get a list of key fields for a given\n        object type.\n\n        :param ObjectType: PowerWorld object type for which you would\n            like a list of key fields. E.g. \'gen\'.\n\n        :returns: List of key fields for the given object type. E.g.\n            [\'BusNum\', \'GenID\']\n        """"""\n        # Lower case only.\n        obj_type = ObjectType.lower()\n\n        # Attempt to get the key field DataFrame from our cached\n        # dictionary.\n        try:\n            key_field_df = self._object_key_fields[obj_type]\n        except KeyError:\n            # DataFrame isn\'t cached. Get it.\n            key_field_df = self.get_key_fields_for_object_type(obj_type)\n\n        # Return a listing of the internal field name.\n        return key_field_df[\'internal_field_name\'].tolist()\n\n    def get_power_flow_results(self, ObjectType: str, additional_fields: Union[\n        None, List[str]] = None) -> \\\n            Union[None, pd.DataFrame]:\n        """"""Get the power flow results from SimAuto server.\n\n        :param ObjectType: Object type to get results for. Valid types\n            are the keys in the POWER_FLOW_FIELDS class attribute (case\n            insensitive).\n\n        :param additional_fields: Pass a list of field names to extend the\n            default attributes in the POWER_FLOW_FIELDS.\n\n        :returns: Pandas DataFrame with the corresponding results, or\n            None if the given ObjectType is not present in the model.\n\n        :raises ValueError: if given ObjectType is invalid.\n        """"""\n        object_type = ObjectType.lower()\n        # Get the listing of fields for this object type.\n        try:\n            field_list = self.POWER_FLOW_FIELDS[object_type]\n            if additional_fields:\n                field_list += additional_fields\n        except KeyError:\n            raise ValueError(\'Unsupported ObjectType for power flow results, \'\n                             \'{}.\'.format(ObjectType))\n\n        return self.GetParametersMultipleElement(ObjectType=object_type,\n                                                 ParamList=field_list)\n\n    def get_version_and_builddate(self) -> tuple:\n        return self._call_simauto(""GetParametersSingleElement"",\n                                  ""PowerWorldSession"",\n                                  convert_list_to_variant([""Version"",\n                                                           ""ExeBuildDate""]), convert_list_to_variant(["""", """"]))\n\n    def identify_numeric_fields(self, ObjectType: str,\n                                fields: Union[List, np.ndarray]) -> \\\n            np.ndarray:\n        """"""Helper which looks up PowerWorld internal field names to\n        determine if they\'re numeric (True) or not (False).\n\n        :param ObjectType: Type of object for which we\'re identifying\n            numeric fields. E.g. ""Branch"" or ""gen""\n        :param fields: List of PowerWorld internal fields names for\n            which we\'re identifying if they are or aren\'t numeric.\n            E.g. [\'BusNum\', \'BusNum:1\', \'LineCircuit\', \'LineStatus\']\n\n        :returns: Numpy boolean array indicating which of the given\n            fields are numeric. Going along with the example given for\n            ""fields"": np.array([True, True, False, False])\n        """"""\n        # Start by getting the field list for this ObjectType. Note\n        # that in most cases this will be cached and thus be quite\n        # fast. If it isn\'t cached now, it will be after calling this.\n        field_list = self.GetFieldList(ObjectType=ObjectType, copy=False)\n\n        # Rely on the fact that the field_list is already sorted by\n        # internal_field_name to get indices related to the given\n        # internal field names.\n        idx = field_list[\'internal_field_name\'].to_numpy().searchsorted(fields)\n\n        # Ensure the columns are actually in the field_list. This is\n        # necessary because search sorted gives the index of where the\n        # given values would go, and doesn\'t guarantee the values are\n        # actually present. However, we want to use searchsorted for its\n        # speed and leverage the fact that our field_list DataFrame is\n        # already sorted.\n        try:\n            # ifn for ""internal_field_name.""\n            ifn = field_list[\'internal_field_name\'].to_numpy()[idx]\n\n            # Ensure given fields are present in the field list.\n            if set(ifn) != set(fields):\n                raise ValueError(\'The given object has fields which do not\'\n                                 \' match a PowerWorld internal field name!\')\n        except IndexError:\n            # An index error also indicates failure.\n            raise ValueError(\'The given object has fields which do not\'\n                             \' match a PowerWorld internal field name!\')\n\n        # Now extract the corresponding data types.\n        data_types = field_list[\'field_data_type\'].to_numpy()[idx]\n\n        # Determine which types are numeric and return.\n        return np.isin(data_types, NUMERIC_TYPES)\n\n    def set_simauto_property(self, property_name: str,\n                             property_value: Union[str, bool]):\n        """"""Set a SimAuto property, e.g. CreateIfNotFound. The currently\n        supported properties are listed in the SAW.SIMAUTO_PROPERTIES\n        class constant.\n\n        `PowerWorld Documentation\n        <https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/Simulator_Automation_Server_Properties.htm%3FTocPath%3DAutomation%2520Server%2520Add-On%2520(SimAuto)%7CAutomation%2520Server%2520Properties%7C_____1>`__\n\n        :param property_name: Name of the property to set, e.g.\n            UIVisible.\n        :param property_value: Value to set the property to, e.g. False.\n        """"""\n        # Ensure the given property name is valid.\n        if property_name not in self.SIMAUTO_PROPERTIES:\n            raise ValueError((\'The given property_name, {}, is not currently \'\n                              \'supported. Valid properties are: {}\')\n                             .format(property_name,\n                                     list(self.SIMAUTO_PROPERTIES.keys())))\n\n        # Ensure the given property value has a valid type.\n        # noinspection PyTypeHints\n        if not isinstance(property_value,\n                          self.SIMAUTO_PROPERTIES[property_name]):\n            m = (\'The given property_value, {}, is invalid. It must be \'\n                 \'of type {}.\').format(property_value,\n                                       self.SIMAUTO_PROPERTIES[property_name])\n            raise ValueError(m)\n\n        # If we\'re setting CurrentDir, ensure the path is valid.\n        # It seems PowerWorld does not check this.\n        if property_name == \'CurrentDir\':\n            if not os.path.isdir(property_value):\n                raise ValueError(\'The given path for CurrentDir, {}, is \'\n                                 \'not a valid path!\'.format(property_value))\n\n        # Set the property.\n        try:\n            self._set_simauto_property(property_name=property_name,\n                                       property_value=property_value)\n        except AttributeError as e:\n            if property_name == \'UIVisible\':\n                self.log.warning(\n                    \'UIVisible attribute could not be set. Note this SimAuto \'\n                    \'property was not introduced until Simulator version 20. \'\n                    \'Check your version with the get_simulator_version method.\'\n                )\n            else:\n                raise e from None\n\n    def _set_simauto_property(self, property_name, property_value):\n        """"""Helper to just set a property name and value. Primary purpose\n        of breaking things out this way is for testing.\n\n        :param property_name: Name of the property to set, e.g.\n            UIVisible.\n        :param property_value: Value to set the property to, e.g. False.\n        """"""\n        setattr(self._pwcom, property_name, property_value)\n\n    def update_ui(self) -> None:\n        """"""Re-render the PowerWorld user interface (UI).\n\n        :returns: None\n        """"""\n        return self.ProcessAuxFile(self.empty_aux)\n\n    ####################################################################\n    # SimAuto Server Functions\n    ####################################################################\n\n    def ChangeParameters(self, ObjectType: str, ParamList: list,\n                         Values: list) -> None:\n        """"""\n        The ChangeParameters function has been replaced by the\n        ChangeParametersSingleElement function. ChangeParameters\n        can still be called as before, but will now just automatically\n        call ChangeParametersSingleElement, and pass on the parameters\n        to that function.\n        Unlike the script SetData and CreateData commands, SimAuto does\n        not have any explicit functions to create elements. Instead this\n        can be done using the ChangeParameters functions by making use\n        of the CreateIfNotFound SimAuto property. Set CreateIfNotFound =\n        True if objects that are updated through the ChangeParameters\n        functions should be created if they do not already exist in the\n        case. Objects that already exist will be updated. Set\n        CreateIfNotFound = False to not create new objects and only\n        update existing ones. The CreateIfNotFound property is global,\n        once it is set to True this applies to all future\n        ChangeParameters calls.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/CloseCase_Function.htm>`__\n\n        :param ObjectType: The type of object you are changing\n            parameters for.\n        :param ParamList: List of object field variable names. Note this\n            MUST include the key fields for the given ObjectType\n            (which you can get via the get_key_fields_for_object_type\n            method).\n        :param Values: List of values corresponding to the parameters in\n            the ParamList.\n        """"""\n        return self.ChangeParametersSingleElement(ObjectType, ParamList,\n                                                  Values)\n\n    def ChangeParametersSingleElement(self, ObjectType: str, ParamList: list,\n                                      Values: list) -> None:\n        """"""Set a list of parameters for a single object.\n\n        `PowerWorld Documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/ChangeParametersSingleElement_Function.htm>`__\n\n        :param ObjectType: The type of object you are changing\n            parameters for.\n        :param ParamList: List of object field variable names. Note this\n            MUST include the key fields for the given ObjectType\n            (which you can get via the get_key_fields_for_object_type\n            method).\n        :param Values: List of values corresponding to the parameters in\n            the ParamList.\n        """"""\n        return self._call_simauto(\'ChangeParametersSingleElement\',\n                                  ObjectType,\n                                  convert_list_to_variant(ParamList),\n                                  convert_list_to_variant(Values))\n\n    def ChangeParametersMultipleElement(self, ObjectType: str, ParamList: list,\n                                        ValueList: list) -> None:\n        """"""Set parameters for multiple objects of the same type.\n\n        `PowerWorld Documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/ChangeParametersMultipleElement_Function.htm>`__\n\n        :param ObjectType: The type of object you are changing\n            parameters for.\n        :param ParamList: Listing of object field variable names. Note\n            this MUST include the key fields for the given ObjectType\n            (which you can get via the get_key_fields_for_object_type\n            method).\n        :param ValueList: List of lists corresponding to the ParamList.\n            Should have length n, where n is the number of elements you\n            with to change parameters for. Each sub-list should have\n            the same length as ParamList, and the items in the sub-list\n            should correspond 1:1 with ParamList.\n        :returns: Result from calling SimAuto, which should always\n            simply be None.\n\n        :raises PowerWorldError: if PowerWorld reports an error.\n        """"""\n        # Call SimAuto and return the result (should just be None)\n        return self._call_simauto(\'ChangeParametersMultipleElement\',\n                                  ObjectType,\n                                  convert_list_to_variant(ParamList),\n                                  convert_nested_list_to_variant(ValueList))\n\n    def ChangeParametersMultipleElementFlatInput(self, ObjectType: str,\n                                                 ParamList: list,\n                                                 NoOfObjects: int,\n                                                 ValueList: list) -> None:\n        """"""\n        The ChangeParametersMultipleElementFlatInput function allows\n        you to set parameters for multiple objects of the same type in\n        a case loaded into the Simulator Automation Server. This\n        function is very similar to the ChangeParametersMultipleElement,\n        but uses a single dimensioned array of values as input instead\n        of a multi-dimensioned array of arrays.\n\n        It is recommended that you use helper functions like\n        ``change_parameters_multiple_element_df`` instead of this one,\n        as it\'s simply easier to use.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/CloseCase_Function.htm>`__\n\n        :param ObjectType: The type of object you are changing\n            parameters for.\n        :param ParamList: Listing of object field variable names. Note\n            this MUST include the key fields for the given ObjectType\n            (which you can get via the get_key_fields_for_object_type\n            method).\n        :param NoOfObjects: An integer number of devices that are\n            passing values for. SimAuto will automatically check that\n            the number of parameters for each device (counted from\n            ParamList) and the number of objects integer correspond to\n            the number of values in value list (counted from ValueList.)\n        :param ValueList: List of lists corresponding to the ParamList.\n            Should have length n, where n is the number of elements you\n            with to change parameters for. Each sub-list should have\n            the same length as ParamList, and the items in the sub-list\n            should correspond 1:1 with ParamList.\n        :return: Result from calling SimAuto, which should always\n            simply be None.\n        """"""\n        # Call SimAuto and return the result (should just be None)\n        if isinstance(ValueList[0], list):\n            raise Error(""The value list has to be a 1-D array"")\n        return self._call_simauto(\'ChangeParametersMultipleElementFlatInput\',\n                                  ObjectType,\n                                  convert_list_to_variant(ParamList),\n                                  NoOfObjects,\n                                  convert_list_to_variant(ValueList))\n\n    def CloseCase(self):\n        """"""Closes case without saving changes.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/CloseCase_Function.htm>`__\n        """"""\n        return self._call_simauto(\'CloseCase\')\n\n    def GetCaseHeader(self, filename: str = None) -> Tuple[str]:\n        """"""\n        The GetCaseHeader function is used to extract the case header\n        information from the file specified. A tuple of strings\n        containing the contents of the case header or description is\n        returned.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/GetCaseHeader_Function.htm>`__\n\n        :param filename: The name of the file you wish to extract the\n            header information from.\n        :return: A tuple of strings containing the contents of the case\n            header or description.\n        """"""\n        if filename is None:\n            filename = self.pwb_file_path\n        return self._call_simauto(\'GetCaseHeader\', filename)\n\n    def GetFieldList(self, ObjectType: str, copy=False) -> pd.DataFrame:\n        """"""Get all fields associated with a given ObjectType.\n\n        :param ObjectType: The type of object for which the fields are\n            requested.\n        :param copy: Whether or not to return a copy of the DataFrame.\n            You may want a copy if you plan to make any modifications.\n\n        :returns: Pandas DataFrame with columns from either\n            SAW.FIELD_LIST_COLUMNS or SAW.FIELD_LIST_COLUMNS_OLD,\n            depending on the version of PowerWorld Simulator being used.\n\n        `PowerWorld Documentation\n        <https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/GetFieldList_Function.htm>`__\n        """"""\n        # Get the ObjectType in lower case.\n        object_type = ObjectType.lower()\n\n        # Either look up stored DataFrame, or call SimAuto.\n        try:\n            output = self._object_fields[object_type]\n        except KeyError:\n            # We haven\'t looked up fields for this object yet.\n            # Call SimAuto.\n            result = self._call_simauto(\'GetFieldList\', ObjectType)\n\n            # Place result in a numpy array.\n            result_arr = np.array(result)\n\n            # Attempt to map results into a DataFrame using\n            # FIELD_LIST_COLUMNS. If that fails, use\n            # FIELD_LIST_COLUMNS_OLD.\n            try:\n                output = pd.DataFrame(result_arr,\n                                      columns=self.FIELD_LIST_COLUMNS)\n            except ValueError as e:\n                # We may be dealing with the older convention.\n                # The value error should read something like:\n                # ""Shape of passed values is (259, 4), indices imply (259, 5)""\n                # Confirm via regular expressions.\n                exp_base = r\'\\([0-9]+,\\s\'\n                exp_end = r\'{}\\)\'\n                # Get number of columns for new/old lists.\n                nf_old = len(self.FIELD_LIST_COLUMNS_OLD)\n                nf_new = len(self.FIELD_LIST_COLUMNS)\n                # Search the error\'s arguments.\n                r1 = re.search(exp_base + exp_end.format(nf_old), e.args[0])\n                r2 = re.search(exp_base + exp_end.format(nf_new), e.args[0])\n\n                # Both results should match, i.e., not be None.\n                if (r1 is None) or (r2 is None):\n                    raise e\n\n                # If we made it here, use the older columns.\n                output = pd.DataFrame(result_arr,\n                                      columns=self.FIELD_LIST_COLUMNS_OLD)\n\n            # While it appears PowerWorld gives us the list sorted by\n            # internal_field_name, let\'s make sure it\'s always sorted.\n            output.sort_values(by=[\'internal_field_name\'], inplace=True)\n\n            # Store this for later.\n            self._object_fields[object_type] = output\n\n        # Either return a copy or not.\n        if copy:\n            return output.copy(deep=True)\n        else:\n            return output\n\n    def GetParametersSingleElement(self, ObjectType: str,\n                                   ParamList: list, Values: list) -> pd.Series:\n        """"""Request values of specified fields for a particular object.\n\n        `PowerWorld Documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/GetParametersSingleElement_Function.htm>`__\n\n        :param ObjectType: The type of object you\'re retrieving\n            parameters for.\n        :param ParamList: List of strings indicating parameters to\n            retrieve. Note the key fields MUST be present. One can\n            obtain key fields for an object type via the\n            get_key_fields_for_object_type method.\n        :param Values: List of values corresponding 1:1 to parameters in\n            the ParamList. Values must be included for the key fields,\n            and the remaining values should be set to 0.\n\n        :returns: Pandas Series indexed by the given ParamList. This\n            Series will be cleaned by clean_df_or_series, so data will\n            be of the appropriate type and strings are cleaned up.\n\n        :raises PowerWorldError: if the object cannot be found.\n        :raises ValueError: if any given element in ParamList is not\n            valid for the given ObjectType.\n        :raises AssertionError: if the given ParamList and Values do\n            not have the same length.\n        """"""\n        # Ensure list lengths match.\n        assert len(ParamList) == len(Values), \\\n            \'The given ParamList and Values must have the same length.\'\n\n        # Call PowerWorld.\n        output = self._call_simauto(\'GetParametersSingleElement\', ObjectType,\n                                    convert_list_to_variant(ParamList),\n                                    convert_list_to_variant(Values))\n\n        # Convert to Series.\n        s = pd.Series(output, index=ParamList)\n\n        # Clean the Series and return.\n        return self.clean_df_or_series(obj=s, ObjectType=ObjectType)\n\n    def GetParametersMultipleElement(self, ObjectType: str, ParamList: list,\n                                     FilterName: str = \'\') -> \\\n            Union[pd.DataFrame, None]:\n        """"""Request values of specified fields for a set of objects in\n        the load flow case.\n\n        `PowerWorld Documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/GetParametersMultipleElement_Function.htm>`__\n\n        :param ObjectType: Type of object to get parameters for.\n        :param ParamList: List of variables to obtain for the given\n            object type. E.g. [\'BusNum\', \'GenID\', \'GenMW\']. One\n            can use the method GetFieldList to get a listing of all\n            available fields. Additionally, you\'ll likely want to always\n            return the key fields associated with the objects. These\n            key fields can be obtained via the\n            get_key_fields_for_object_type method.\n        :param FilterName: Name of an advanced filter defined in the\n            load flow case.\n\n        :returns: Pandas DataFrame with columns matching the given\n            ParamList. If the provided ObjectType is not present in the\n            case, None will be returned.\n\n        :raises PowerWorldError: if PowerWorld reports an error.\n        :raises ValueError: if any parameters given in the ParamList\n            are not valid for the given object type.\n\n        TODO: Should we cast None to NaN to be consistent with how\n            Pandas/Numpy handle bad/missing data?\n        """"""\n        output = self._call_simauto(\'GetParametersMultipleElement\',\n                                    ObjectType,\n                                    convert_list_to_variant(ParamList),\n                                    FilterName)\n        if output is None:\n            # Given object isn\'t present.\n            return output\n\n        # Create DataFrame.\n        df = pd.DataFrame(np.array(output).transpose(),\n                          columns=ParamList)\n\n        # Clean DataFrame and return it.\n        return self.clean_df_or_series(obj=df, ObjectType=ObjectType)\n\n    def GetParametersMultipleElementFlatOutput(self, ObjectType: str,\n                                               ParamList: list,\n                                               FilterName: str = \'\') -> \\\n            Union[None, Tuple[str]]:\n        """"""This function operates the same as the\n        GetParametersMultipleElement function, only with one notable\n        difference. The values returned as the output of the function\n        are returned in a single-dimensional vector array, instead of\n        the multi-dimensional array as described in the\n        GetParametersMultipleElement topic.\n\n        It is recommended that you use GetParametersMultipleElement\n        instead, as you\'ll receive a DataFrame with correct data types.\n        As this method is extraneous, the output from PowerWorld will\n        be directly returned. This will show you just how useful ESA\n        really is!\n\n        :param ObjectType: Type of object to get parameters for.\n        :param ParamList: List of variables to obtain for the given\n            object type. E.g. [\'BusNum\', \'GenID\', \'GenMW\']. One\n            can use the method GetFieldList to get a listing of all\n            available fields. Additionally, you\'ll likely want to always\n            return the key fields associated with the objects. These\n            key fields can be obtained via the\n            get_key_fields_for_object_type method.\n        :param FilterName: Name of an advanced filter defined in the\n            load flow case.\n\n        :return:The format of the output array is the following: [\n            NumberOfObjectsReturned, NumberOfFieldsPerObject,\n            Ob1Fld1, Ob1Fld2, \xe2\x80\xa6, Ob(n)Fld(m-1), Ob(n)Fld(m)]\n            The data is thus returned in a single dimension array, where\n            the parameters NumberOfObjectsReturned and\n            NumberOfFieldsPerObject tell you how the rest of the array\n            is populated. Following the NumberOfObjectsReturned\n            parameter is the start of the data. The data is listed as\n            all fields for object 1, then all fields for object 2, and\n            so on. You can parse the array using the NumberOf\xe2\x80\xa6\n            parameters for objects and fields. If the given object\n            type does not exist, the method will return None.\n        """"""\n        result = self._call_simauto(\n            \'GetParametersMultipleElementFlatOutput\', ObjectType,\n            convert_list_to_variant(ParamList),\n            FilterName)\n\n        if len(result) == 0:\n            return None\n        else:\n            return result\n\n    def GetParameters(self, ObjectType: str,\n                      ParamList: list, Values: list) -> pd.Series:\n        """"""This function is maintained in versions of Simulator later \n        than version 9 for compatibility with Simulator version 9. This \n        function will call the GetParametersSingleElement implicitly.\n        \n        `PowerWorld Documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/GetParametersSingleElement_Function.htm>`__\n\n        :param ObjectType: The type of object you\'re retrieving\n            parameters for.\n        :param ParamList: List of strings indicating parameters to\n            retrieve. Note the key fields MUST be present. One can\n            obtain key fields for an object type via the\n            get_key_fields_for_object_type method.\n        :param Values: List of values corresponding 1:1 to parameters in\n            the ParamList. Values must be included for the key fields,\n            and the remaining values should be set to 0.\n\n        :returns: Pandas Series indexed by the given ParamList. This\n            Series will be cleaned by clean_df_or_series, so data will\n            be of the appropriate type and strings are cleaned up.\n\n        :raises PowerWorldError: if the object cannot be found.\n        :raises ValueError: if any given element in ParamList is not\n            valid for the given ObjectType.\n        :raises AssertionError: if the given ParamList and Values do\n            not have the same length.\n        """"""\n        return self.GetParametersSingleElement(ObjectType, ParamList, Values)\n\n    def GetSpecificFieldList(self, ObjectType: str, FieldList: List[str]) \\\n            -> pd.DataFrame:\n        """"""\n        The GetSpecificFieldList function is used to return identifying\n        information about specific fields used by an object type. Note\n        that in many cases simply using the GetFieldList method is\n        simpler and gives more information.\n\n        `PowerWorld Documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/GetSpecificFieldList_Function.htm>`__\n\n        :param ObjectType: The type of object for which fields are\n            requested.\n        :param FieldList: A list of strings. Each string represents\n            object field variables, as defined in the section on\n            `PowerWorld Object Fields\n            <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/PowerWorld_Object_Variables.htm>`__\n            . Specific variablenames along with location numbers can be\n            specified. To return all fields using the same variablename,\n            use ""variablename:ALL"" instead of the location number that\n            would normally appear after the colon. If all fields should\n            be returned, a single parameter of ""ALL"" can be used instead\n            of specific variablenames.\n\n        :returns: A Pandas DataFrame with columns given by the class\n            constant SPECIFIC_FIELD_LIST_COLUMNS. There will be a row\n            for each element in the FieldList input unless \'ALL\' is\n            used in the FieldList. The DataFrame will be sorted\n            alphabetically by the variablenames.\n        """"""\n        return pd.DataFrame(\n            self._call_simauto(\'GetSpecificFieldList\', ObjectType,\n                               convert_list_to_variant(FieldList)),\n            columns=self.SPECIFIC_FIELD_LIST_COLUMNS).sort_values(\n            by=self.SPECIFIC_FIELD_LIST_COLUMNS[0]).reset_index(drop=True)\n\n    def GetSpecificFieldMaxNum(self, ObjectType: str, Field: str) -> int:\n        """"""The GetSpecificFieldMaxNum function is used to return the\n        maximum number of a fields that use a particular variablename\n        for a specific object type.\n\n        `PowerWorld Documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/GetSpecificFieldMaxNum_Function.htm>`__\n\n        :param ObjectType: The type of object for which information is\n            being requested.\n        :param Field: The variablename for which the maximum number of\n            fields is being requested. This should just be the\n            variablename and should exclude the location number that can\n            be included to indicate different fields that use the same\n            variablename, i.e. do not include the colon and number that\n            can be included when identifying a field.\n\n        :returns: An integer that specifies the maximum number of fields\n            that use the same variablename for a particular object type.\n            Fields are identified in the format variablename:location\n            when multiple fields use the same variablename. The output\n            indicates the maximum number that the location can be.\n            Generally, fields are identified starting from 0 and going\n            up to the maximum number, but keep in mind that values\n            within this range might be skipped and not used to indicate\n            valid fields.\n        """"""\n        # Unfortunately, at the time of writing this method does not\n        return self._call_simauto(\'GetSpecificFieldMaxNum\', ObjectType, Field)\n\n    def ListOfDevices(self, ObjType: str, FilterName=\'\') -> \\\n            Union[None, pd.DataFrame]:\n        """"""Request a list of objects and their key fields. This function\n        is general, and you may be better off running more specific\n        methods like ""get_gens""\n\n        :param ObjType: The type of object for which you are acquiring\n            the list of devices. E.g. ""Shunt,"" ""Gen,"" ""Bus,"" ""Branch,""\n            etc.\n        :param FilterName: Name of an advanced filter defined in the\n            load flow case open in the automation server. Use the\n            empty string (default) if no filter is desired. If the\n            given filter cannot be found, the server will default to\n            returning all objects in the case of type ObjectType.\n\n        :returns: None if there are no objects of the given type in the\n            model. Otherwise, a DataFrame of key fields will be\n            returned. There will be a row for each object of the given\n            type, and columns for each key field. If the ""BusNum""\n            key field is present, the data will be sorted by BusNum.\n        """"""\n        # Start by getting the key fields associated with this object.\n        kf = self.get_key_fields_for_object_type(ObjType)\n\n        # Now, query for the list of devices.\n        output = self._call_simauto(\'ListOfDevices\', ObjType, FilterName)\n\n        # If all data in the 2nd dimension comes back None, there\n        # are no objects of this type and we should return None.\n        all_none = True\n        for i in output:\n            if i is not None:\n                all_none = False\n                break\n\n        if all_none:\n            # TODO: May be worth adding logging here.\n            return None\n\n        # If we\'re here, we have this object type in the model.\n        # Create a DataFrame.\n        df = pd.DataFrame(output).transpose()\n        # The return from get_key_fields_for_object_type is designed to\n        # match up 1:1 with values here. Set columns.\n        df.columns = kf[\'internal_field_name\'].to_numpy()\n\n        # Ensure the DataFrame has the correct types, is sorted by\n        # BusNum, and has leading/trailing white space stripped.\n        df = self.clean_df_or_series(obj=df, ObjectType=ObjType)\n\n        # All done.\n        return df\n\n    def ListOfDevicesAsVariantStrings(self, ObjType: str, FilterName=\'\') -> \\\n            tuple:\n        """"""While this method is implemented, you are almost certainly\n        better off using ListOfDevices instead. Since this method isn\'t\n        particularly useful, no type casting will be performed on the\n        output array. Contrast the results of calling this method with\n        the results of calling ListOfDevices to see just how helpful\n        ESA is!\n\n        Description below if from\n        `PowerWorld\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/ListOfDevicesAsVariantStrings_Function.htm>`__:\n\n        This function operates the same as the ListOfDevices function,\n        only with one notable difference. The values returned as the\n        output of the function are returned as Variants of type String.\n        The ListOfDevices function was errantly released returning the\n        values strongly typed as Integers and Strings directly, whereas\n        all other SimAuto functions returned data as Variants of type\n        String. This function was added to also return the data in the\n        same manner. This solved some compatibility issues with some\n        software languages.\n\n        :param ObjType: The type of object for which you are acquiring\n            the list of devices.\n        :param FilterName: The name of an advanced filter defined in the\n            load flow case open in the Simulator Automation Server. If\n            no filter is desired, then simply pass an empty string. If\n            the filter cannot be found, the server will default to\n            returning all objects in the case of type ObjType.\n\n        :returns: Tuple of tuples as documented by PowerWorld for the\n            ListOfDevices function.\n        """"""\n        return self._call_simauto(\'ListOfDevicesAsVariantStrings\',\n                                  ObjType, FilterName)\n\n    def ListOfDevicesFlatOutput(self, ObjType: str, FilterName=\'\') -> tuple:\n        """"""While this method is implemented, you are almost certainly\n        better off using ListOfDevices instead. Since this method isn\'t\n        particularly useful, no type casting, data type changing, or\n        data rearranging will be performed on the output array.\n        Contrast the results of calling this method with the results of\n        calling ListOfDevices to see just how helpful ESA is!\n\n        This function operates the same as the ListOfDevices\n        function, only with one notable difference. The values returned\n        as the output of the function are returned in a\n        single-dimensional vector array, instead of the\n        multi-dimensional array as described in the ListOfDevices topic.\n        The function returns the key field values for the device,\n        typically in the order of bus number 1, bus number 2\n        (where applicable), and circuit identifier (where applicable).\n        These are the most common key fields, but some object types do\n        have other key fields as well.\n\n        `PowerWorld documentation:\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/ListOfDevicesFlatOutput_Function.htm>`__\n\n        :param ObjType: The type of object for which you are acquiring\n            the list of devices.\n        :param FilterName: The name of an advanced filter defined in the\n            load flow case open in the Simulator Automation Server. If\n            no filter is desired, then simply pass an empty string. If\n            the filter cannot be found, the server will default to\n            returning all objects in the case of type ObjType.\n\n        :returns: List in the following format:\n            [NumberOfObjectsReturned, NumberOfFieldsPerObject, Ob1Fld1,\n            Ob1Fld2, \xe2\x80\xa6, Ob(n)Fld(m-1), Ob(n)Fld(m)].\n            The data is thus returned in a single dimension array, where\n            the parameters NumberOfObjectsReturned and\n            NumberOfFieldsPerObject tell you how the rest of the array\n            is populated. Following the NumberOfObjectsReturned\n            parameter is the start of the data. The data is listed as\n            all fields for object 1, then all fields for object 2, and\n            so on. You can parse the array using the NumberOf\xe2\x80\xa6\n            parameters for objects and fields.\n        """"""\n        return self._call_simauto(\n            \'ListOfDevicesFlatOutput\', ObjType, FilterName)\n\n    def LoadState(self) -> None:\n        """"""LoadState is used to load the system state previously saved\n        with the SaveState function. Note that LoadState will not\n        properly function if the system topology has changed due to the\n        addition or removal of the system elements.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/LoadState_Function.htm>`__\n        """"""\n        return self._call_simauto(\'LoadState\')\n\n    def OpenCase(self, FileName: Union[str, None] = None) -> None:\n        """"""Load PowerWorld case into the automation server.\n\n        :param FileName: Full path to the case file to be loaded. If\n            None, this method will attempt to use the last FileName\n            used to open a case.\n\n        :raises TypeError: if FileName is None, and OpenCase has never\n            been called before.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/OpenCase_Function.htm>`__\n        """"""\n        # If not given a file name, ensure the pwb_file_path is valid.\n        if FileName is None:\n            if self.pwb_file_path is None:\n                raise TypeError(\'When OpenCase is called for the first \'\n                                \'time, a FileName is required.\')\n        else:\n            # Set pwb_file_path according to the given FileName.\n            self.pwb_file_path = FileName\n\n        # Open the case. PowerWorld should return None.\n        return self._call_simauto(\'OpenCase\', self.pwb_file_path)\n\n    def OpenCaseType(self, FileName: str, FileType: str,\n                     Options: Union[list, str, None] = None) -> None:\n        """"""\n        The OpenCaseType function will load a PowerWorld Simulator load\n         flow file into the Simulator Automation Server. This is similar\n          to opening a file using the File > Open Case menu option in\n          Simulator.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Default.htm#MainDocumentation_HTML/OpenCaseType_Function.htm?Highlight=OpenCaseType>`__\n\n        :param FileName: Full path to the case file to be loaded. If\n            None, this method will attempt to use the last FileName\n            used to open a case.\n        :param FileType: The type of case file to be loaded. It can be\n            one of the following strings: PWB, PTI, PTI23, PTI24, PTI25,\n            PTI26, PTI27, PTI28, PTI29, PTI30, PTI31, PTI32, PTI33,\n            GE (means GE18), GE14, GE15, GE17, GE18, GE19, CF, AUX,\n            UCTE, AREVAHDB\n        :param Options: Optional parameter indicating special load\n            options for PTI and GE file types. See the PowerWorld\n            documentation for more details.\n        """"""\n        self.pwb_file_path = FileName\n        if isinstance(Options, list):\n            options = convert_list_to_variant(Options)\n        elif isinstance(Options, str):\n            options = Options\n        else:\n            options = """"\n        return self._call_simauto(\'OpenCaseType\', self.pwb_file_path,\n                                  FileType, options)\n\n    def ProcessAuxFile(self, FileName):\n        """"""\n        Load a PowerWorld Auxiliary file into SimAuto. This allows\n        you to create a text file (conforming to the PowerWorld\n        Auxiliary file format) that can list a set of data changes and\n        other information for making batch changes in Simulator.\n\n        :param FileName: Name of auxiliary file to load. Should be a\n            full path.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/ProcessAuxFile_Function.htm>`__\n        """"""\n        return self._call_simauto(\'ProcessAuxFile\', FileName)\n\n    def RunScriptCommand(self, Statements):\n        """"""Execute a list of script statements. The script actions are\n        those included in the script sections of auxiliary files.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/RunScriptCommand_Function.htm>`__\n\n        `Auxiliary File Format\n        <https://github.com/mzy2240/ESA/blob/master/docs/Auxiliary%20File%20Format.pdf>`__\n        """"""\n        output = self._call_simauto(\'RunScriptCommand\', Statements)\n        return output\n\n    def SaveCase(self, FileName=None, FileType=\'PWB\', Overwrite=True):\n        """"""Save the current case to file.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/SaveCase_Function.htm>`__\n\n        :param FileName: The name of the file you wish to save as,\n            including file path. If None, the original path which was\n            used to open the case (passed to this class\'s initializer)\n            will be used.\n        :param FileType: String indicating the format of the case file\n            to write out. Here\'s what PowerWorld currently supports:\n            * ""PTI23"": ""PTI33"" specific PTI version (raw).\n            * ""GE14"": ""GE21"" GE PSLF version (epc).\n            * ""IEEE"": IEEE common format (cf).\n            * ""UCTE"": UCTE Data Exchange (uct).\n            * ""AUX"": PowerWorld Auxiliary format (aux).\n            * ""AUXSECOND"": PowerWorld Auxiliary format (aux) using\n            secondary key fields.\n            * ""AUXLABEL"": PowerWorld Auxiliary format (aux) using\n            labels as key field identifiers.\n            * ""AUXNETWORK"": PowerWorld Auxiliary format (aux) saving\n            only network data.\n            * ""PWB5"" through ""PWB20"": specific PowerWorld Binary\n            version (pwb).\n            * ""PWB"":  PowerWorld Binary (most recent) (pwb).\n        :param Overwrite: Whether (True) or not (False) to overwrite the\n            file if it already exists. If False and the specified file\n            already exists, an exception will be raised.\n        """"""\n        if FileName is not None:\n            f = convert_to_windows_path(FileName)\n        else:\n            if self.pwb_file_path is None:\n                raise TypeError(\'SaveCase was called without a FileName, but \'\n                                \'it would appear OpenCase has not yet been \'\n                                \'called.\')\n            f = convert_to_windows_path(self.pwb_file_path)\n\n        return self._call_simauto(\'SaveCase\', f, FileType, Overwrite)\n\n    def SaveState(self) -> None:\n        """"""SaveState is used to save the current state of the power\n        system. This can be useful if you are interested in comparing\n        various cases, much as the ""Difference Flows"" feature works in\n        the Simulator application.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/SaveState_Function.htm>`__\n        """"""\n        return self._call_simauto(\'SaveState\')\n\n    def SendToExcel(self, ObjectType: str, FilterName: str, FieldList) -> None:\n        """"""Send data from SimAuto to an Excel spreadsheet. While ESA\n        provides this function, we strongly recommend you to use the\n        ``GetParametersMultipleElement`` function and save the DataFrame\n        directly to a .csv file using the DataFrame\'s ``to_csv``\n        method. The problem with ``SendToExcel`` is that it opens\n        (but does not save) an Excel sheet, which requires you to\n        manually save it.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/SendToExcel_Function.htm>`__\n\n        :param ObjectType: A String describing the type of object for\n            which you are requesting data.\n        :param FilterName: String with the name of an advanced filter\n            which was previously defined in the case before being loaded\n            in the Simulator Automation Server. If no filter is desired,\n            then simply pass an empty string. If a filter name is passed\n            but the filter cannot be found in the loaded case, no filter\n            is used.\n        :param FieldList: Variant parameter must either be an array of\n            fields for the given object or the string ""ALL"". As an\n            array, FieldList contains an array of strings, where each\n            string represents an object field variable, as defined in\n            the section on PowerWorld Object Variables. If, instead of\n            an array of strings, the single string ""ALL"" is passed, the\n            Simulator Automation Server will use predefined default\n            fields when exporting the data.\n\n        :returns: None\n        """"""\n        return self._call_simauto(\'SendToExcel\', ObjectType, FilterName,\n                                  FieldList)\n\n    def TSGetContingencyResults(self, CtgName: str, ObjFieldList: List[str],\n                                StartTime: Union[None, str] = None,\n                                StopTime: Union[None, str] = None) -> \\\n            Union[Tuple[None, None], Tuple[pd.DataFrame, pd.DataFrame]]:\n        """"""\n        WARNING: This function should only be used after the simulation\n        is run (for example, use this after running script commands\n        TSSolveAll or TSSolve).\n\n        On to the main documentation:\n\n        The TSGetContingencyResults function is used to read\n        transient stability results into an external program (Python)\n        using SimAuto.\n\n        This function is analogous to the script command TSGetResults,\n        where rather than saving out results to a file, the results are\n        passed back directly to the SimAuto COM object and may be\n        further processed by an external program. As with TSGetResults,\n        this function should only be used after the simulation is run\n        (for example, use this after running script commands TSSolveAll\n        or TSSolve).\n\n        `PowerWorld documentation:\n        <https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/TSGetContingencyResults%20Function.htm%3FTocPath%3DAutomation%2520Server%2520Add-On%2520(SimAuto)%7CAutomation%2520Server%2520Functions%7C_____49>`__\n\n        The authors of ESA do not have extensive experience running\n        transient contingencies in PowerWorld, so this method has not\n        been tested as extensively as we would prefer. If your case/code\n        has issues with this method, please file an issue on `GitHub\n        <https://github.com/mzy2240/ESA/issues>`__.\n\n        :param CtgName: The contingency to obtain results from. Only one\n            contingency be obtained at a time.\n        :param ObjFieldList: A list of strings which may contain plots,\n            subplots, or individual object/field pairs specifying the\n            result variables to obtain.\n        :param StartTime: The time in seconds in the simulation to begin\n            retrieving results. If not specified (None), the start time\n            of the simulation is used.\n        :param StopTime: The time in seconds in the simulation to stop\n            retrieving results. If not specified, the end time of the\n            simulation is used.\n\n        :returns: A tuple containing two DataFrames, ""meta"" and ""data.""\n            Alternatively, if the given CtgName does not exist, a tuple\n            of (None, None) will be returned.\n            The ""meta"" DataFrame describes the data in the ""data""\n            DataFrame, and can be used to map objects to columns in\n            the ""data"" DataFrame. The ""meta"" DataFrame\'s columns are:\n            [\'ObjectType\', \'PrimaryKey\', \'SecondaryKey\', \'Label\',\n            \'VariableName\', \'ColHeader\']. Each row in the ""meta""\n            DataFrame corresponds to a column in the ""data"" DataFrame.\n            So the ""meta"" row with index label 0 corresponds to the\n            column labeled 0 in the ""data"" DataFrame, and so forth.\n            Unfortunately, the ``ObjectType``s that come back from\n            PowerWorld do not always match valid ``ObjectType``\n            variable names (e.g. ""Generator"" comes back as an\n            ``ObjectType``, but attempting to use ""Generator"" in the\n            ``GetParametersMultipleElement`` method results in an\n            error), so ESA\'s ability to perform automatic data type\n            transformation is limited. All columns in the ""data""\n            DataFrame will be cast to numeric types by\n            ``pandas.to_numeric``. If Pandas cannot determine an\n            appropriate numeric type, the data will be unmodified (i.e.,\n            the type will not be changed). In addition to the integer\n            labeled columns which match the ""meta"" rows, the ""data""\n            DataFrame additionally has a ""time"" column which corresponds\n            to the timestamp (in seconds).\n        """"""\n        out = self._call_simauto(\'TSGetContingencyResults\', CtgName,\n                                 ObjFieldList, StartTime, StopTime)\n\n        # We get (None, (None,)) if the contingency does not exist.\n        if out == (None, (None,)):\n            return None, None\n\n        # Length should always be 2.\n        assert len(out) == 2, \'Unexpected return format from PowerWorld.\'\n\n        # Extract the meta data.\n        meta = pd.DataFrame(\n            out[0], columns=[\'ObjectType\', \'PrimaryKey\', \'SecondaryKey\',\n                             \'Label\', \'VariableName\', \'ColHeader\'])\n\n        # Remove extraneous white space in the strings.\n        # https://stackoverflow.com/a/40950485/11052174\n        meta = meta.apply(lambda x: x.str.strip(), axis=0)\n\n        # Extract the data.\n        data = pd.DataFrame(out[1])\n\n        # Decrement all the columns by 1 so that they line up with the\n        # \'meta\' frame.\n        data.rename(columns=lambda x: x - 1, inplace=True)\n\n        # Rename first column to \'time\'.\n        data.rename(columns={-1: \'time\'}, inplace=True)\n\n        # Attempt to convert all columns to numeric.\n        data = data.apply(lambda x: pd.to_numeric(x, errors=\'ignore\'))\n\n        # Return.\n        return meta, data\n\n    def WriteAuxFile(self, FileName: str, FilterName: str, ObjectType: str,\n                     FieldList: Union[list, str],\n                     ToAppend=True):\n        """"""The WriteAuxFile function can be used to write data from the\n        case in the Simulator Automation Server to a PowerWorld\n        Auxiliary file. The name of an advanced filter which was\n        PREVIOUSLY DEFINED in the case before being loaded in the\n        Simulator Automation Server. If no filter is desired, then\n        simply pass an empty string. If a filter name is passed but the\n        filter cannot be found in the loaded case, no filter is used.\n\n        `PowerWorld documentation\n        <https://www.powerworld.com/WebHelp/Content/MainDocumentation_HTML/WriteAuxFile_Function.htm>`__\n\n\n        """"""\n        return self._call_simauto(\'WriteAuxFile\', FileName,\n                                  FilterName, ObjectType, ToAppend,\n                                  FieldList)\n\n    ####################################################################\n    # PowerWorld ScriptCommand helper functions\n    ####################################################################\n\n    def SolvePowerFlow(self, SolMethod: str = \'RECTNEWT\') -> None:\n        """"""Run the SolvePowerFlow command.\n\n        :param SolMethod: Solution method to be used for the Power Flow\n            calculation. Case insensitive. Valid options are:\n            \'RECTNEWT\' - Rectangular Newton-Raphson\n            \'POLARNEWTON\' - Polar Newton-Raphson\n            \'GAUSSSEIDEL\' - Gauss-Seidel\n            \'FASTDEC\' - Fast Decoupled\n            \'ROBUST\' - Attempt robust solution process\n            \'DC\' - DC power flow\n\n        See\n        `Auxiliary File Format.pdf\n        <https://github.com/mzy2240/ESA/blob/master/docs/Auxiliary%20File%20Format.pdf>`__\n        for more details.\n        """"""\n        script_command = ""SolvePowerFlow(%s)"" % SolMethod.upper()\n        return self.RunScriptCommand(script_command)\n\n    def OpenOneLine(self, filename: str, view: str = """",\n                    FullScreen: str = ""NO"", ShowFull: str = ""NO"",\n                    LinkMethod: str = ""LABELS"", Left: float = 0.0,\n                    Top: float = 0.0, Width: float = 0.0, Height: float = 0.0)\\\n            -> None:\n        """"""Use this function to open a oneline diagram. This function\n        can be used to associate onelines with a PWB file.\n\n        :param filename: The file name of the oneline diagram to open.\n        :param view: The view name that should be opened. Pass an empty\n            string to denote no specific view.\n        :param FullScreen: Set to YES or NO. YES means that the oneline\n            diagram will be open in full screen mode. If this parameter\n            is not specified, then NO is assumed.\n        :param ShowFull: Optional parameter. Set to YES to open the\n            oneline and apply the Show Full option. Set to NO to open\n            the oneline and leave the oneline as is. Default is NO if\n            not specified.\n        :param LinkMethod: Optional Parameter that controls oneline\n            linking. LABELS, NAMENOMKV, and NUMBER will link using the\n            respective key fields.\n        :param Left: Optional with default of 0. Value between 0 and 100\n            that indicates the location of the left edge of the oneline\n            as a percentage of the Simulator/Retriever window width.\n        :param Top: Optional with default of 0. Value between 0 and 100\n            that indicates the top edge of the oneline as a percentage\n            of the Simulator/Retriever window height.\n        :param Width: Optional with default of 0. Value between 0 and\n            100 that indicates the width of the oneline as a percentage\n            of the Simulator/Retriever window width.\n        :param Height: Optional with default of 0. Value between 0 and\n            100 that indicates the height of the oneline as a percentage\n            of the Simulator/Retriever window height.\n\n        :returns: None\n        """"""\n        script = \'OpenOneline(""{}"", {}, {} {})\'.format(\n            filename, view, FullScreen, ShowFull, LinkMethod, Left, Top,\n            Width, Height)\n        return self.RunScriptCommand(script)\n\n    def CloseOneline(self, OnelineName: str = """") -> None:\n        """"""Use this action to close an open oneline diagram without\n         saving it. If the name is omitted, the last focused oneline \n         diagram will be closed.\n\n         :param OnelineName: The name of the oneline diagram to close.\n\n         :returns: None\n         """"""\n        script = \'CloseOneline({})\'.format(OnelineName)\n        return self.RunScriptCommand(script)\n\n    ####################################################################\n    # PowerWorld SimAuto Properties\n    ####################################################################\n    @property\n    def CreateIfNotFound(self):\n        """"""The CreateIfNotFound property of the Simulator Automation\n        Server is useful when you are changing data with the\n        ChangeParameters functions. Set the attribute through the\n        ``set_simauto_property`` method.\n        """"""\n        return self._pwcom.CreateIfNotFound\n\n    @property\n    def CurrentDir(self) -> str:\n        """"""The CurrentDir property of the Simulator Automation Server\n        allows you to retrieve or set the working directory for the\n        currently running SimulatorAuto process. This is most useful if\n        using relative filenames (e.g. ``""relativename.aux""`` versus\n        ``r""C:\\Program Files\\PowerWorld\\Working\\abosultename.aux""``)\n        when specifying files. Set this property through the\n        ``set_simauto_property`` method.\n        """"""\n        return self._pwcom.CurrentDir\n\n    @property\n    def ProcessID(self) -> int:\n        """"""The ProcessID property of the Simulator Automation Server\n        allows you to retrieve the process ID of the currently running\n        SimulatorAuto process, as can also be seen through the Task\n        Manager in Windows. This information can be useful if a forced\n        shutdown of the SimulatorAuto object is needed, as all calls to\n        the SimulatorAuto object are synchronous. This means the\n        SimulatorAuto object will not be destroyed until all calls, no\n        matter the time of execution, have completed.\n        """"""\n        return self._pwcom.ProcessID\n\n    @property\n    def RequestBuildDate(self) -> int:\n        """"""The RequestBuildDate property of the Simulator Automation\n        Server allows you to retrieve the build date of the PowerWorld\n        Simulator executable currently running with the SimulatorAuto\n        process. The property returns an integer value that represents a\n        date. This information is useful for verifying the release\n        version of the executable.\n\n        After contacting PowerWorld, it seems the integer comes back\n        according to Delphi date conventions, which counts days since\n        December 30th, 1899.\n        """"""\n        return self._pwcom.RequestBuildDate\n\n    @property\n    def UIVisible(self) -> bool:\n        """"""Get the UIVisible property of the Simulator Automation\n        Server which indicates the visibility of the user interface for\n        Simulator. Default behavior is to not show the user interface\n        while using SimAuto. Set this property through the\n        ``set_simauto_property`` method.\n        """"""\n        try:\n            return self._pwcom.UIVisible\n        except AttributeError:\n            self.log.warning(\n                \'UIVisible attribute could not be accessed. Note this SimAuto \'\n                \'property was not introduced until Simulator version 20. \'\n                \'Check your version with the get_simulator_version method.\')\n            return False\n\n    ####################################################################\n    # Private Methods\n    ####################################################################\n\n    def _call_simauto(self, func: str, *args):\n        """"""Helper function for calling the SimAuto server.\n\n        :param func: Name of PowerWorld SimAuto function to call.\n\n        :param args: Remaining arguments to this function will be\n            passed directly to func.\n\n        :returns: Result from PowerWorld. This will vary from function\n            to function. If PowerWorld returns (\'\',), this method\n            returns None.\n\n        :raises PowerWorldError: If PowerWorld indicates an exception\n            occurred.\n\n        :raises AttributeError: If the given func is invalid.\n\n        :raises COMError: If attempting to call the SimAuto function\n            results in an error.\n\n        The listing of valid functions can be found in PowerWorld\'s\n        `web help\n        <https://www.powerworld.com/WebHelp/>`__.\n        """"""\n        # Get a reference to the SimAuto function from the COM object.\n        try:\n            f = getattr(self._pwcom, func)\n        except AttributeError:\n            raise AttributeError(\'The given function, {}, is not a valid \'\n                                 \'SimAuto function.\'.format(func)) from None\n\n        # Call the function.\n        try:\n            output = f(*args)\n        except Exception:\n            m = (\'An error occurred when trying to call {} with \'\n                 \'{}\').format(func, args)\n            self.log.exception(m)\n            raise COMError(m)\n\n        # handle errors\n        if output == (\'\',):\n            # If we just get a tuple with the empty string in it,\n            # there\'s nothing to return.\n            return None\n\n        # There\'s one inconsistent method, GetFieldMaxNum, which\n        # appears to return -1 on error, otherwise simply an integer.\n        # Since that\'s an edge case, we\'ll use a try/except block.\n        try:\n            if output is None or output[0] == \'\':\n                pass\n            elif \'No data\' in output[0]:\n                pass\n            else:\n                raise PowerWorldError(output[0])\n\n        except TypeError as e:\n            # We\'ll get \'is not subscriptable\' if PowerWorld simply\n            # returned an integer, as will happen with GetFieldMaxNum.\n            if \'is not subscriptable\' in e.args[0]:\n                if output == -1:\n                    # Apparently -1 is the signal for an error.\n                    m = (\n                        \'PowerWorld simply returned -1 after calling \'\n                        ""\'{func}\' with \'{args}\'. Unfortunately, that\'s all ""\n                        ""we can help you with. Perhaps the arguments are ""\n                        ""invalid or in the wrong order - double-check the ""\n                        ""documentation."").format(func=func, args=args)\n                    raise PowerWorldError(m)\n                elif isinstance(output, int):\n                    # Return the integer.\n                    return output\n\n            # If we made it here, simply re-raise the exception.\n            raise e\n\n        # After errors have been handled, return the data. Typically\n        # this is in position 1.\n        if len(output) == 2:\n            return output[1]\n        else:\n            # Return all the remaining data.\n            return output[1:]\n\n    def _change_parameters_multiple_element_df(\n            self, ObjectType: str, command_df: pd.DataFrame) -> pd.DataFrame:\n        """"""Private helper for changing parameters for multiple elements\n        with a command DataFrame as input. See docstring for public\n        method ""change_parameters_multiple_element_df"" for more details.\n\n        :returns: ""Cleaned"" version of command_df (passed through\n            clean_df_or_series).\n        """"""\n        # Start by cleaning up the DataFrame. This will avoid silly\n        # issues later (e.g. comparing \' 1 \' and \'1\').\n        cleaned_df = self.clean_df_or_series(obj=command_df,\n                                             ObjectType=ObjectType)\n\n        # Convert columns and data to lists and call PowerWorld.\n        # noinspection PyTypeChecker\n        self.ChangeParametersMultipleElement(\n            ObjectType=ObjectType, ParamList=cleaned_df.columns.tolist(),\n            ValueList=cleaned_df.to_numpy().tolist())\n\n        return cleaned_df\n\n    def _df_equiv_subset_of_other(self, df1: pd.DataFrame, df2: pd.DataFrame,\n                                  ObjectType: str) -> bool:\n        """"""Helper to indicate if one DataFrame is an equivalent subset\n        of another (True) or not (False) for a given PowerWorld object\n        type. Here, we\'re defining ""equivalent subset"" as all of df1\n        being present in df2 (e.g. columns, index, values, etc.), and\n        all data are ""equivalent."" Numeric data will be compared with\n        Numpy\'s ""allclose"" function, and string data will be compared\n        with Numpy\'s ""array_equal"" function. Types will be cast based on\n        the given parameters (columns in the DataFrame).\n\n        :param df1: First DataFrame. Could possibly originate from a\n            method such as ""GetParametersMultipleElement."" Column names\n            should be PowerWorld variable names, and the key fields\n            should be included.\n        :param df2: Second DataFrame. See description of df1.\n        :param ObjectType: PowerWorld object type for which the\n            DataFrames represent data for. E.g. \'gen\' or \'load\'.\n\n        :returns: True if DataFrames are ""equivalent,"" False otherwise.\n        """"""\n        # Get the key fields for this ObjectType.\n        kf = self.get_key_fields_for_object_type(ObjectType=ObjectType)\n\n        # Merge the DataFrames on the key fields.\n        merged = pd.merge(left=df1, right=df2, how=\'inner\',\n                          on=kf[\'internal_field_name\'].tolist(),\n                          suffixes=(\'_in\', \'_out\'), copy=False)\n\n        # Time to check if our input and output values match. Note this\n        # relies on our use of ""_in"" and ""_out"" suffixes above.\n        cols_in = merged.columns[merged.columns.str.endswith(\'_in\')]\n        cols_out = merged.columns[merged.columns.str.endswith(\'_out\')]\n\n        # We\'ll be comparing string and numeric columns separately. The\n        # numeric columns must use np.allclose to avoid rounding error,\n        # while the strings should use array_equal as the strings should\n        # exactly match.\n        cols = cols_in.str.replace(\'_in\', \'\')\n        numeric_cols = self.identify_numeric_fields(ObjectType=ObjectType,\n                                                    fields=cols)\n        str_cols = ~numeric_cols\n\n        # If all numeric data are ""close"" and all string data match\n        # exactly, this will return True. Otherwise, False will be\n        # returned.\n        return (\n                np.allclose(\n                    merged[cols_in[numeric_cols]].to_numpy(),\n                    merged[cols_out[numeric_cols]].to_numpy()\n                )\n                and\n                np.array_equal(\n                    merged[cols_in[str_cols]].to_numpy(),\n                    merged[cols_out[str_cols]].to_numpy()\n                )\n        )\n\n\ndef convert_to_windows_path(p):\n    """"""Given a path, p, convert it to a Windows path.""""""\n    return str(PureWindowsPath(p))\n\n\ndef convert_list_to_variant(list_in: list) -> VARIANT:\n    """"""Given a list, convert to a variant array.\n\n    :param list_in: Simple one-dimensional Python list, e.g. [1, \'a\', 7]\n    """"""\n    # noinspection PyUnresolvedReferences\n    return VARIANT(pythoncom.VT_VARIANT | pythoncom.VT_ARRAY, list_in)\n\n\ndef convert_nested_list_to_variant(list_in: list) -> List[VARIANT]:\n    """"""Given a list of lists, convert to a variant array.\n\n    :param list_in: List of lists, e.g. [[1, \'1\'], [1, \'2\'], [2, \'1\']]\n    """"""\n    return [convert_list_to_variant(sub_array) for sub_array in list_in]\n\n\nclass Error(Exception):\n    """"""Base class for exceptions in this module.""""""\n    pass\n\n\nclass PowerWorldError(Error):\n    """"""Raised when PowerWorld reports an error following a SimAuto call.\n    """"""\n    pass\n\n\nclass COMError(Error):\n    """"""Raised when attempting to call a SimAuto function results in an\n    error.\n    """"""\n    pass\n\n\nclass CommandNotRespectedError(Error):\n    """"""Raised if a command sent into PowerWorld is not respected, but\n    PowerWorld itself does not raise an error. This exception should\n    be used with helpers that double-check commands.\n    """"""\n    pass\n'"
tests/__init__.py,0,b''
tests/constants.py,0,"b'""""""Module to hold constants for testing.""""""\nimport os\nfrom esa import SAW\n\n# Handle pathing.\nTHIS_DIR = os.path.dirname(os.path.abspath(__file__))\nCASE_DIR = os.path.join(THIS_DIR, \'cases\')\nDUMMY_CASE = os.path.join(CASE_DIR, \'dummy_case.pwb\')\nDATA_DIR = os.path.join(THIS_DIR, \'data\')\nSNIPPET_DIR = os.path.join(THIS_DIR, \'..\', \'docs\', \'rst\', \'snippets\')\nSNIPPET_FILES = [os.path.join(SNIPPET_DIR, x) for x in\n                 os.listdir(SNIPPET_DIR) if x.endswith(\'.rst\')]\n\n# Use the dummy case to get the version of Simulator.\nsaw = SAW(DUMMY_CASE)\nVERSION = saw.version\nsaw.exit()\ndel saw\n\n# Path to IEEE 14 bus model.\nPATH_14 = os.path.join(CASE_DIR, \'ieee_14\',\n                       \'IEEE 14 bus_pws_version_{}.pwb\'.format(VERSION))\n# TODO: Update all PWD files with versions when we create them.\nPATH_14_PWD = os.path.join(CASE_DIR, \'ieee_14\', \'IEEE 14 bus.pwd\')\n\n# Path to the Texas 2000 bus model.\nPATH_2000 = os.path.join(CASE_DIR, \'tx2000\',\n                         \'tx2000_base_pws_version_{}.pwb\'.format(VERSION))\n\n# Path to the WSCC model.\nPATH_9 = os.path.join(CASE_DIR, \'wscc_9\',\n                      \'WSCC 9 bus_pws_version_{}.pwb\'.format(VERSION))\n\n# Aux file for filtering buses by area.\nAREA_AUX_FILE = os.path.join(THIS_DIR, \'area_filter.aux\')\n\n# Map cases for doc testing.\nCASE_MAP = {\'14\': PATH_14, \'2000\': PATH_2000}\n\n# Path to file containing lines for one of the examples.\nCANDIDATE_LINES = os.path.join(DATA_DIR, \'CandidateLines.csv\')\n'"
tests/run_tests_for_all_python_versions.py,0,"b'""""""Run this with any version of Python >= 3.5 to test ESA on all\ninstalled versions of Python. Ensure you run this from the \'tests\'\ndirectory.\n\nPrior to running this script, you should install all supported Python\nversions to your system (>= 3.5).\n\nFor help, simply run this script like:\npython _test_python_versions.py -h\n""""""\nimport argparse\nimport os\nimport subprocess\nimport shutil\n\n# Current directory and top-level repository directory.\nTHIS_DIR = os.getcwd()\nTOP_DIR = os.path.abspath(os.path.join(THIS_DIR, \'..\'))\n\n\ndef main(python_install_dir, local, fresh):\n    # Get Python directories.\n    # https://stackoverflow.com/a/973492/11052174\n    dirs = [os.path.join(python_install_dir, o) for o in\n            os.listdir(python_install_dir)\n            if os.path.isdir(os.path.join(python_install_dir, o))]\n\n    # Initialize listing of output files.\n    out_files = []\n\n    # Loop.\n    for d in dirs:\n        # Get last two characters of d.\n        code = d[-2:]\n        assert code in (\'35\', \'36\', \'37\', \'38\'), \'Only Python >= 3.5!\'\n\n        print(\'*\' * 80)\n        print(\'Doing work for Python {}\'.format(code))\n\n        # Name of virtual environment to create.\n        venv_name = os.path.join(THIS_DIR, \'test-venv-{}\'.format(code))\n\n        # Create a virtual environment if necessary.\n        if os.path.isdir(venv_name) and (not fresh):\n            print(\'No need to create {}\'.format(venv_name))\n        else:\n            print(\'Creating {}...\'.format(venv_name))\n            if fresh:\n                print(\'Removing existing virtual environment since the \'\n                      \'""fresh"" argument was supplied.\')\n\n                shutil.rmtree(venv_name, ignore_errors=True)\n\n            subprocess.run((os.path.join(d, \'python.exe\'),\n                            \'-m\', \'venv\', venv_name))\n            print(\'Done.\')\n\n        # Get full path to executable Python file.\n        exe = os.path.join(venv_name, \'Scripts\', \'python.exe\')\n\n        # Check things are working:\n        # subprocess.run((exe, \'-c\', \'import sys; print(sys.version);\'))\n\n        # Upgrade pip and setuptools.\n        subprocess.run((exe, \'-m\', \'pip\', \'install\', \'--upgrade\',\n                        \'--no-cache-dir\', \'pip\', \'setuptools\'))\n\n        # Define command for installing ESA.\n        cmd_tuple = \\\n            (exe, \'-m\', \'pip\', \'install\', \'--upgrade\', \'--no-cache-dir\')\n\n        # Add --force-reinstall if desired.\n        if fresh:\n            cmd_tuple += (\'--force-reinstall\',)\n\n        # Install ESA, including the test dependencies.\n        if not local:\n            subprocess.run(cmd_tuple + (\'esa[test]\',))\n        else:\n            subprocess.run(cmd_tuple + (\'.[test]\',), cwd=TOP_DIR)\n\n        # Define output file for testing results.\n        out_file = os.path.join(THIS_DIR, \'test_results_{}\'.format(code))\n        out_files.append(out_file)\n\n        # Run the tests.\n        print(\'Running tests...\')\n        with open(out_file, \'w\') as f:\n            subprocess.run(\n                (exe, \'-m\', \'unittest\', \'discover\', \'tests\'), cwd=TOP_DIR,\n                stderr=subprocess.STDOUT, stdout=f)\n\n        print(\'Done!\')\n\n    print(\'*\' * 80)\n    print(\'ALL DONE!\')\n    print(\'View results in the following files:\')\n    print(out_files)\n\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \'python_install_dir\',\n        help=\'Full path to directory where all Python installations exist.\',\n        type=str)\n    parser.add_argument(\n        \'--local\', action=\'store_true\', help=\'Set this flag to install ESA \'\n        \'locally from source. If this flag is not set, ESA will be installed \'\n        \'from PyPi.\')\n    parser.add_argument(\n        \'--fresh\', action=\'store_true\', help=\'Set this flag to force fresh \'\n        \'virtual environments and packages. Existing virtual environments \'\n        \'from a previous run of this script will be removed, and packages \'\n        \'will be installed with the --force-upgrade flag.\'\n    )\n    args_in = parser.parse_args()\n    main(python_install_dir=args_in.python_install_dir, local=args_in.local,\n         fresh=args_in.fresh)\n\n'"
tests/test_saw.py,11,"b'""""""Tests for saw.py. One can use these tests as examples.\n\nIMPORTANT NOTES FOR DEVELOPERS, PLEASE READ:\n\nIt can take quite a long time to initialize a SAW object due to the\ntime it takes for SimAuto to start and then for it to load a case. In\norder to keep these tests running in a reasonable amount of time, a\nglobal SAW object, saw_14, is leveraged. This is unfortunate in that\nit breaks one of the fundamental rules of good testing: test isolation.\nSince this global object is used for most tests, it becomes important\nfor the test developer to ""clean up after themselves."" If you\nchange the state of the saw_14 object in a test (e.g. by calling\nGetFieldList for a new object type), make sure to undo the state change\nat the end of the test (e.g. removing the entry for that object type\nfrom saw_14.object_fields). While this is a pain, it\'s better than\nwriting a test suite that takes 10 minutes to run a small handful of\ntests.\n\nNote that the saw_14 object is initialized in the setUpModule method,\nand torn down in the tearDownModule. If we need to add another SAW\nobject corresponding to a different case (which is likely, seeing as\nthe IEEE 14 bus test case doesn\'t have all possible components), make\nsure to follow the pattern used for saw_14: Initialize to None in\nmain code body, initialize actual SAW object in setUpModule (don\'t\nforget to tag it as global!), and then call the object\'s exit() method\nin tearDownModule.\n\nFinally, please note that examples from docs/rst/snippets are executed\nusing doctest. These files use a suffix convention to determine which\n.pwb file to use in the CASE_PATH constant.\n""""""\n\nimport logging\nimport os\nimport tempfile\nimport unittest\nfrom unittest.mock import patch, MagicMock, Mock, seal\nimport datetime\n\nimport numpy as np\nimport pandas as pd\n\nfrom esa import SAW, COMError, PowerWorldError, CommandNotRespectedError, \\\n    Error\nfrom esa.saw import convert_to_windows_path\n\n# noinspection PyUnresolvedReferences\nfrom tests.constants import PATH_14, PATH_14_PWD, PATH_2000, \\\n    PATH_9, THIS_DIR, AREA_AUX_FILE, DATA_DIR, VERSION\n\n# Initialize the 14 bus SimAutoWrapper. Adding type hinting to make\n# development easier.\n# noinspection PyTypeChecker\nsaw_14 = None  # type: SAW\n\n\ndef skip_if_version_below(version=21):\n    """"""Use this method to skip tests below a given PowerWorld Simulator\n    version.\n    """"""\n    if VERSION < version:\n        raise unittest.SkipTest(\'Simulator version < {}.\'.format(version))\n\n\n# noinspection PyPep8Naming\ndef setUpModule():\n    """"""In order to allow us to split the test cases by functionality\n    under test without loading the case (which is expensive) for every\n    test case, we\'ll load the case once. If more PowerWorld cases are\n    added to this module, initialize them here.\n    """"""\n    global saw_14\n    saw_14 = SAW(PATH_14)\n\n\n# noinspection PyPep8Naming\ndef tearDownModule():\n    """"""We need to ensure we clean up all our SimAuto servers, so call\n    exit and then delete the wrappers here.\n    """"""\n    global saw_14\n    saw_14.exit()\n    del saw_14\n\n\n########################################################################\n# Misc tests\n########################################################################\n\n\nclass InitializationTestCase(unittest.TestCase):\n    """"""Test initialization.""""""\n\n    def test_bad_path(self):\n        with self.assertRaisesRegex(PowerWorldError, \'OpenCase: \'):\n            SAW(FileName=\'bogus\')\n\n    def test_init_expected_behavior(self):\n        # Initialize\n        my_saw_14 = SAW(PATH_14,\n                        object_field_lookup=(\'bus\', \'shunt\'))\n\n        # Ensure we have a log attribute.\n        self.assertIsInstance(my_saw_14.log, logging.Logger)\n\n        # Ensure our pwb_file_path matches our given path.\n        self.assertEqual(PATH_14,\n                         my_saw_14.pwb_file_path)\n\n        # Ensure we have the expected object_fields.\n        self.assertEqual(2, len(my_saw_14._object_fields))\n\n        for f in [\'bus\', \'shunt\']:\n            df = my_saw_14._object_fields[f]\n            self.assertIsInstance(df, pd.DataFrame)\n\n            cols = df.columns.to_numpy().tolist()\n            if len(cols) == len(my_saw_14.FIELD_LIST_COLUMNS):\n                self.assertEqual(cols, my_saw_14.FIELD_LIST_COLUMNS)\n            elif len(cols) == len(my_saw_14.FIELD_LIST_COLUMNS_OLD):\n                self.assertEqual(cols, my_saw_14.FIELD_LIST_COLUMNS_OLD)\n            else:\n                raise AssertionError(\n                    \'Columns, {}, do not match either FIELD_LIST_COLUMNS or \'\n                    \'FIELD_LIST_COLUMNS_OLD.\'.format(cols))\n\n    def test_error_during_dispatch(self):\n        """"""Ensure an exception is raised if dispatch fails.""""""\n        with patch(\'win32com.client.gencache.EnsureDispatch\',\n                   side_effect=TypeError):\n            with self.assertRaises(TypeError):\n                SAW(PATH_14, early_bind=True)\n\n\n########################################################################\n# Helper function tests\n########################################################################\n\n\nclass ChangeAndConfirmParamsMultipleElementTestCase(unittest.TestCase):\n    """"""Test change_and_confirm_params_multiple_element.""""""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        # Get branch data, including LineStatus, which is a string.\n        branch_key_fields = \\\n            saw_14.get_key_fields_for_object_type(\'branch\')\n        cls.branch_data = saw_14.GetParametersMultipleElement(\n            ObjectType=\'branch\',\n            ParamList=(branch_key_fields[\'internal_field_name\'].tolist()\n                       + [\'LineStatus\']))\n        # Make a copy so we can modify it without affecting the original\n        # DataFrame.\n        cls.branch_data_copy = cls.branch_data.copy()\n\n    @classmethod\n    def tearDownClass(cls) -> None:\n        # Put the branches back as they were.\n        # noinspection PyUnresolvedReferences\n        saw_14.ChangeParametersMultipleElement(\n            ObjectType=\'Branch\', ParamList=cls.branch_data.columns.tolist(),\n            ValueList=cls.branch_data.to_numpy().tolist())\n\n    def test_with_string_value(self):\n        """"""This test will prove the following has been resolved if this\n        test passes:\n        https://github.com/mzy2240/ESA/issues/8#issue-537818522\n        """"""\n        # Open the line from bus 6 to 13.\n        from_6 = self.branch_data_copy[\'BusNum\'] == 6\n        to_13 = self.branch_data_copy[\'BusNum:1\'] == 13\n        self.branch_data_copy.loc[from_6 & to_13, \'LineStatus\'] = \'Open\'\n\n        # Change and confirm.\n        self.assertIsNone(\n            saw_14.change_and_confirm_params_multiple_element(\n                ObjectType=\'Branch\', command_df=self.branch_data_copy))\n\n    def test_success(self):\n        """"""Send in a simple command that matches what\'s already in the\n        case and ensure the output from PowerWorld matches.\n        """"""\n        # Create DataFrame which a) only modifies a couple elements\n        # (not all), b) does not actually change anything (e.g. matches\n        # the initial case values), and c) has NOT been cleaned (e.g.\n        # bad data types (string where float should be), not sorted by\n        # BusNum).\n        # Part a) ensures the merge + comparison in the method is\n        #   working.\n        # Part b) means we don\'t need to clean up after ourselves and\n        #   set things back.\n        # Part c) ensures the user doesn\'t have to provide a perfect\n        #   pre-cleaned DataFrame.\n        command_df = pd.DataFrame(\n            [[13, \'1\', 13.5, \'5.8\'],\n             [3, \' 1 \', \'94.2\', \'19.0\']],\n            columns=[\'BusNum\', \'LoadID\', \'LoadMW\', \'LoadMVR\']\n        )\n\n        # Patch the call to ChangeParametersMultipleElement.\n        with patch.object(saw_14, \'ChangeParametersMultipleElement\'):\n            self.assertIsNone(\n                saw_14.change_and_confirm_params_multiple_element(\n                    ObjectType=\'load\', command_df=command_df))\n\n    def test_failure_numeric(self):\n        """"""Don\'t actually send in a command, and ensure that we get\n        an exception.\n        """"""\n        # Note this DataFrame is only one value off from what\'s in the\n        # base case model (130.5 in first row).\n        command_df = pd.DataFrame(\n            [[13, \'1\', 130.5, \'5.8\'],\n             [3, \' 1 \', \'94.2\', \'19.0\']],\n            columns=[\'BusNum\', \'LoadID\', \'LoadMW\', \'LoadMVR\']\n        )\n\n        # Patch the call to ChangeParametersMultipleElement.\n        with patch.object(saw_14, \'ChangeParametersMultipleElement\'):\n            with self.assertRaisesRegex(CommandNotRespectedError,\n                                        \'After calling .* not all parameters\'):\n                saw_14.change_and_confirm_params_multiple_element(\n                    ObjectType=\'load\', command_df=command_df)\n\n    def test_failure_string(self):\n        """"""Don\'t actually send in a command, and ensure that we get\n        an exception.\n        """"""\n        # Note this DataFrame is only one value off from what\'s in the\n        # base case model (all loads are in).\n        command_df = pd.DataFrame(\n            [[13, \'1\', \'Closed\'],\n             [3, \' 1 \', \'Open\']],\n            columns=[\'BusNum\', \'LoadID\', \'LoadStatus\']\n        )\n\n        # Patch the call to ChangeParametersMultipleElement.\n        with patch.object(saw_14, \'ChangeParametersMultipleElement\'):\n            with self.assertRaisesRegex(CommandNotRespectedError,\n                                        \'After calling .* not all parameters\'):\n                saw_14.change_and_confirm_params_multiple_element(\n                    ObjectType=\'load\', command_df=command_df)\n\n\nclass ChangeParametersMultipleElementDFTestCase(unittest.TestCase):\n    """"""Test change_parameters_multiple_element_df.""""""\n\n    def test_success(self):\n        """"""Send in a simple command that matches what\'s already in the\n        case and ensure the output from PowerWorld matches.\n        """"""\n        # Create DataFrame for sending in commands, and ensure that\n        # ChangeParametersMultipleElement is called correctly.\n        cols = [\'BusNum\', \'LoadID\', \'LoadMW\', \'LoadMVR\']\n        command_df = pd.DataFrame(\n            [[13, \'1\', 13.8, \'5.1\'],\n             [3, \' 1 \', \'94.9\', \'29.0\']],\n            columns=cols\n        )\n\n        # Patch the call to ChangeParametersMultipleElement.\n        with patch.object(saw_14, \'ChangeParametersMultipleElement\') as p:\n            self.assertIsNone(\n                saw_14.change_parameters_multiple_element_df(\n                    ObjectType=\'load\', command_df=command_df))\n\n        self.assertEqual(1, p.call_count)\n        self.assertDictEqual(\n            p.mock_calls[0][2],\n            {\'ObjectType\': \'load\', \'ParamList\': cols,\n             # Note the DataFrame will get sorted by bus number, and\n             # type casting will be applied.\n             \'ValueList\': [[3, \'1\', 94.9, 29.0], [13, \'1\', 13.8, 5.1]]}\n        )\n\n\nclass CleanDFOrSeriesTestCase(unittest.TestCase):\n    def test_bad_df_columns(self):\n        """"""If the DataFrame columns are not valid fields, we should get\n        an error.\n        """"""\n        bad_df = pd.DataFrame([[1, \'bleh\']], columns=[\'BusNum\', \'bleh\'])\n        with self.assertRaisesRegex(ValueError, \'The given object has fields\'):\n            saw_14.clean_df_or_series(obj=bad_df, ObjectType=\'gen\')\n\n    def test_bad_df_columns_2(self):\n        """"""This time, use upper-case so we don\'t get an index error.""""""\n        bad_df = pd.DataFrame([[1, \'bleh\']], columns=[\'BusNum\', \'Bleh\'])\n        with self.assertRaisesRegex(ValueError, \'The given object has fields\'):\n            saw_14.clean_df_or_series(obj=bad_df, ObjectType=\'gen\')\n\n    # noinspection PyMethodMayBeStatic\n    def test_works_df(self):\n        """"""Ensure that when using valid fields, the DataFrame comes back\n        as expected.\n        """"""\n        df_in = pd.DataFrame([[\' 6    \', \'7.2234 \', \' yes \'],\n                              [\' 3\', \'11\', \'   no \']],\n                             columns=[\'BusNum\', \'GenMW\', \'GenAGCAble\'])\n        df_expected = pd.DataFrame([[3, 11.0, \'no\'], [6, 7.2234, \'yes\']],\n                                   columns=[\'BusNum\', \'GenMW\', \'GenAGCAble\'])\n\n        df_actual = saw_14.clean_df_or_series(obj=df_in, ObjectType=\'gen\')\n\n        pd.testing.assert_frame_equal(df_actual, df_expected)\n\n    def test_bad_type(self):\n        """"""Ensure a TypeError is raised if \'obj\' is a bad type.""""""\n        with self.assertRaisesRegex(TypeError, \'The given object is not a Da\'):\n            # noinspection PyTypeChecker\n            saw_14.clean_df_or_series(obj=42, ObjectType=\'shunt\')\n\n    def test_series_bad_index(self):\n        """"""If a Series has an Index that doesn\'t match known fields, we\n        should get an exception.\n        """"""\n        bad_series = pd.Series([1, \'a\'], index=[\'BusNum\', \'Bad_Field\'])\n        with self.assertRaisesRegex(ValueError, \'The given object has fields\'):\n            saw_14.clean_df_or_series(obj=bad_series, ObjectType=\'gen\')\n\n\nclass GetKeyFieldsForObjectType(unittest.TestCase):\n    """"""Test the get_key_fields_for_object_type method.""""""\n\n    def test_gens(self):\n        """"""Gens should have bus number and generator ID key fields.""""""\n        # Query.\n        result = saw_14.get_key_fields_for_object_type(""Gen"")\n        # Check length.\n        self.assertEqual(2, result.shape[0])\n        # Check fields.\n        self.assertEqual(\'BusNum\', result.loc[0, \'internal_field_name\'])\n        self.assertEqual(\'GenID\', result.loc[1, \'internal_field_name\'])\n\n    def test_branches(self):\n        """"""Branches have three key fields: bus from, bus to, and circuit\n        ID.\n        """"""\n        # Query\n        result = saw_14.get_key_fields_for_object_type(""Branch"")\n        # Check length.\n        self.assertEqual(3, result.shape[0])\n        # Check fields.\n        self.assertEqual(\'BusNum\', result.loc[0, \'internal_field_name\'])\n        self.assertEqual(\'BusNum:1\', result.loc[1, \'internal_field_name\'])\n        self.assertEqual(\'LineCircuit\', result.loc[2, \'internal_field_name\'])\n\n    def test_buses(self):\n        """"""Buses should only have one key field - their number.""""""\n        # Query.\n        result = saw_14.get_key_fields_for_object_type(""Bus"")\n        # Check length.\n        self.assertEqual(1, result.shape[0])\n        # Check fields.\n        self.assertEqual(\'BusNum\', result.loc[0, \'internal_field_name\'])\n\n    def test_shunts(self):\n        """"""Shunts, similar to generators, will have a bus number and an\n        ID.""""""\n        # Query.\n        result = saw_14.get_key_fields_for_object_type(""Shunt"")\n        # Check length.\n        self.assertEqual(2, result.shape[0])\n        # Check fields.\n        self.assertEqual(\'BusNum\', result.loc[0, \'internal_field_name\'])\n        self.assertEqual(\'ShuntID\', result.loc[1, \'internal_field_name\'])\n\n    def test_nonexistent_object(self):\n        """"""Not really sure why this raises a COMError rather than a\n        PowerWorldError...""""""\n        with self.assertRaises(COMError):\n            saw_14.get_key_fields_for_object_type(\'sorry, not here\')\n\n    def test_cached(self):\n        """"""Test that the ""caching"" is working as intended.""""""\n        # Generators are in the default listing.\n        with patch.object(saw_14, \'_call_simauto\',\n                          wraps=saw_14._call_simauto) as p:\n            kf = saw_14.get_key_fields_for_object_type(\'GEN\')\n\n        self.assertIsInstance(kf, pd.DataFrame)\n        self.assertEqual(0, p.call_count)\n\n        # Now, actually look something up.\n        with patch.object(saw_14, \'_call_simauto\',\n                          wraps=saw_14._call_simauto) as p:\n            kf = saw_14.get_key_fields_for_object_type(\'area\')\n\n        self.assertIsInstance(kf, pd.DataFrame)\n        self.assertEqual(1, p.call_count)\n\n\nclass GetKeyFieldListTestCase(unittest.TestCase):\n    """"""Test get_key_field_list.""""""\n\n    @classmethod\n    def tearDownClass(cls) -> None:\n        # Remove the cached three winding transformer from saw_14 to\n        # avoid screwing up state for other tests.\n        del saw_14._object_key_fields[\'3wxformer\']\n        del saw_14._object_fields[\'3wxformer\']\n\n    def test_gen(self):\n        """"""Ensure generator listing matches.""""""\n        # Ensure this one is cached.\n        self.assertIn(\'gen\', saw_14._object_key_fields)\n\n        # Ensure the list comes back correctly.\n        self.assertListEqual([\'BusNum\', \'GenID\'],\n                             saw_14.get_key_field_list(\'Gen\'))\n\n    def test_3wxformer(self):\n        """"""Ensure 3WXFormer listing matches.""""""\n        # Ensure this is NOT cached.\n        self.assertNotIn(\'3wxformer\', saw_14._object_key_fields)\n\n        # Key fields have changed for 3 winding transformers between\n        # versions.\n        if VERSION in [21, 22]:\n            expected = [\'BusIdentifier\', \'BusIdentifier:1\', \'BusIdentifier:2\',\n                        \'LineCircuit\']\n        elif VERSION == 17:\n            expected = [\'BusName_NomVolt:4\', \'BusNum3W:3\', \'LineCircuit\']\n        else:\n            raise NotImplementedError(\n                \'We do not know when key fields for 3 winding transformers\'\n                \'changed, and have thus far only looked into PWS versions \'\n                \'17 and 21. Please update this test if you are running a \'\n                \'different version of Simulator.\')\n\n        # Ensure the list comes back correctly.\n        self.assertListEqual(expected, saw_14.get_key_field_list(\'3WXFormer\'))\n\n\nclass GetPowerFlowResultsTestCase(unittest.TestCase):\n    """"""Test get_power_flow_result""""""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        """"""Run the power flow to ensure we have results to fetch.""""""\n        saw_14.SolvePowerFlow()\n\n    def test_bad_field(self):\n        with self.assertRaisesRegex(ValueError, \'Unsupported ObjectType\'):\n            saw_14.get_power_flow_results(ObjectType=\'nonexistent\')\n\n    def test_all_valid_types_except_shunts(self):\n        """"""Loop and sub test over all types, except shunts.""""""\n        # Loop over the POWER_FLOW_FIELDS dictionary.\n        for object_type, object_fields in SAW.POWER_FLOW_FIELDS.items():\n            # Skip shunts, we\'ll do that separately (there aren\'t any\n            # in the 14 bus model).\n            if object_type == \'shunt\':\n                continue\n\n            # Perform a test for each valid type.\n            with self.subTest(object_type):\n                # Get results.\n                result = saw_14.get_power_flow_results(ObjectType=object_type)\n                # We should get a DataFrame back.\n                self.assertIsInstance(result, pd.DataFrame)\n                # Ensure the DataFrame has all the columns we expect.\n                self.assertSetEqual(set(result.columns.to_numpy()),\n                                    set(object_fields))\n                # No NaNs.\n                self.assertFalse(result.isna().any().any())\n\n    def test_shunt(self):\n        """"""There are no shunts in the IEEE 14 bus model.""""""\n        self.assertIsNone(saw_14.get_power_flow_results(\'shunt\'))\n\n    def test_with_additional_fields(self):\n        """"""Add additional fields to the result""""""\n        result = saw_14.get_power_flow_results(ObjectType=\'Bus\',\n                                               additional_fields=[\'AreaNum\'])\n        self.assertTrue(\'AreaNum\' in result.columns.values.tolist())\n\n\nclass IdentifyNumericFieldsTestCase(unittest.TestCase):\n    """"""Test identify_numeric_fields.""""""\n\n    # noinspection PyMethodMayBeStatic\n    def test_correct(self):\n        # Intentionally make the fields out of alphabetical order.\n        if VERSION in [21, 22]:\n            fields = [\'LineStatus\', \'LockOut\', \'LineR\', \'LineX\', \'BusNum\']\n            expected = np.array([False, False, True, True, True])\n        elif VERSION == 17:\n            # The LockOut field is not present in version 17.\n            fields = [\'LineStatus\', \'LineR\', \'LineX\', \'BusNum\']\n            expected = np.array([False, True, True, True])\n        else:\n            raise NotImplementedError(\n                \'If you encounter this error, please update this test for the \'\n                \'version of PowerWorld Simulator that you are using. Thus far,\'\n                \' it has only been tested with version 17 and 21.\'\n            )\n\n        actual = \\\n            saw_14.identify_numeric_fields(ObjectType=\'Branch\', fields=fields)\n        np.testing.assert_array_equal(actual, expected)\n\n\nclass GetVersionAndBuildDateTestCase(unittest.TestCase):\n    """"""Test get_version_and_builddate.""""""\n\n    # noinspection PyMethodMayBeStatic\n    def test_correct(self):\n        self.assertIsInstance(saw_14.get_version_and_builddate(), tuple)\n\n\nclass SetSimAutoPropertyTestCase(unittest.TestCase):\n    """"""Test the set_simauto_property method. To avoid conflicts with\n    other tests we\'ll create a fresh SAW instance here.\n    """"""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.saw = SAW(PATH_14, early_bind=True)\n\n    @classmethod\n    def tearDownClass(cls) -> None:\n        # noinspection PyUnresolvedReferences\n        cls.saw.exit()\n\n    def test_set_create_if_not_found_true(self):\n        self.saw.set_simauto_property(\'CreateIfNotFound\', True)\n        self.assertTrue(self.saw._pwcom.CreateIfNotFound)\n\n    def test_set_create_if_not_found_false(self):\n        self.saw.set_simauto_property(\'CreateIfNotFound\', False)\n        self.assertFalse(self.saw._pwcom.CreateIfNotFound)\n\n    def test_set_create_if_not_found_bad_value(self):\n        with self.assertRaisesRegex(\n                ValueError, \'The given property_value, bad, is invalid\'):\n            self.saw.set_simauto_property(\'CreateIfNotFound\', \'bad\')\n\n    def test_set_ui_visible_true(self):\n        # Patch the _pwcom object so we don\'t actually activate the UI.\n        # If we actually activate the UI, it can cause the tests to\n        # hang. E.g., if an update is available which requires user\n        # input as to whether to download or wait.\n        with patch.object(self.saw, \'_pwcom\') as p:\n            self.saw.set_simauto_property(\'UIVisible\', True)\n\n        self.assertTrue(p.UIVisible)\n\n    def test_set_ui_visible_false(self):\n        # UIVisible introduced in version 20.\n        if VERSION >= 20:\n            self.saw.set_simauto_property(\'UIVisible\', False)\n            self.assertFalse(self.saw._pwcom.UIVisible)\n        else:\n            with self.assertLogs(logger=self.saw.log, level=\'WARN\'):\n                self.saw.set_simauto_property(\'UIVisible\', False)\n\n    def test_set_ui_visible_bad_value(self):\n        with self.assertRaisesRegex(\n                ValueError, \'The given property_value, bad, is invalid\'):\n            self.saw.set_simauto_property(\'UIVisible\', \'bad\')\n\n    def test_set_current_dir_here(self):\n        self.saw.set_simauto_property(property_name=\'CurrentDir\',\n                                      property_value=THIS_DIR)\n        self.assertEqual(self.saw._pwcom.CurrentDir, THIS_DIR)\n\n    def test_set_current_dir_bad(self):\n        with self.assertRaisesRegex(ValueError, \'The given path for Current\'):\n            self.saw.set_simauto_property(property_name=\'CurrentDir\',\n                                          property_value=r\'C:\\bad\\path\')\n\n    def test_set_bad_property_name(self):\n        m = \'The given property_name, junk,\'\n        with self.assertRaisesRegex(ValueError, m):\n            self.saw.set_simauto_property(property_name=\'junk\',\n                                          property_value=\'42\')\n\n    def test_attr_error_for_ui_visible(self):\n        """"""Force the UIVisible attribute to throw an error.\n        """"""\n        with self.assertLogs(logger=self.saw.log, level=\'WARN\'):\n            with patch.object(self.saw, \'_set_simauto_property\',\n                              side_effect=AttributeError):\n                self.saw.set_simauto_property(\'UIVisible\', True)\n\n    def test_re_raise_attr_error(self):\n        """"""Ensure that a non UIVisible property correctly re-raises\n        the attribute error.\n        """"""\n        with patch.object(self.saw, \'_set_simauto_property\',\n                          side_effect=AttributeError(\'my special error\')):\n            with self.assertRaisesRegex(AttributeError, \'my special error\'):\n                self.saw.set_simauto_property(\'CreateIfNotFound\', False)\n\n\nclass UpdateUITestCase(unittest.TestCase):\n    """"""Test the update_ui method. To avoid conflicts with\n    other tests we\'ll create a fresh SAW instance here.\n    """"""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.saw = SAW(PATH_14, early_bind=True)\n\n    @classmethod\n    def tearDownClass(cls) -> None:\n        # noinspection PyUnresolvedReferences\n        cls.saw.exit()\n\n    def test_update_default(self):\n        """"""It should work with or without the visible UI.\n        """"""\n        self.assertIsNone(self.saw.update_ui())\n\n\n########################################################################\n# SimAuto functions tests\n########################################################################\n\n\nclass ChangeParametersMultipleElementTestCase(unittest.TestCase):\n    """"""Test ChangeParametersMultipleElement""""""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        # Get generator key fields.\n        cls.key_field_df_gens = saw_14.get_key_fields_for_object_type(\'gen\')\n        cls.params = \\\n            cls.key_field_df_gens[\'internal_field_name\'].to_numpy().tolist()\n        # Combine key fields with our desired attribute.\n        cls.params.append(\'GenVoltSet\')\n        cls.gen_v_pu = saw_14.GetParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=cls.params)\n\n    # noinspection PyUnresolvedReferences\n    @classmethod\n    def tearDownClass(cls) -> None:\n        """"""Always be nice and clean up after yourself and put your toys\n        away. No, but seriously, put the voltage set points back.""""""\n        value_list = cls.gen_v_pu.to_numpy().tolist()\n        saw_14.ChangeParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=cls.params, ValueList=value_list)\n\n    # noinspection DuplicatedCode\n    def test_change_gen_voltage_set_points(self):\n        """"""Set all generator voltages to 1, and ensure the command\n        sticks.\n        """"""\n        # https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/ChangeParametersMultipleElement_Sample_Code_Python.htm%3FTocPath%3DAutomation%2520Server%2520Add-On%2520(SimAuto)%7CAutomation%2520Server%2520Functions%7C_____9\n        # Start by converting our generator data to a list of lists.\n        value_list = self.gen_v_pu.to_numpy().tolist()\n\n        # Loop over the values, set to 1.\n        # noinspection PyTypeChecker\n        for v in value_list:\n            # Set voltage at 1.\n            v[-1] = 1.0\n\n        # Send in the command.\n        # noinspection PyTypeChecker\n        self.assertIsNone(saw_14.ChangeParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=self.params, ValueList=value_list))\n\n        # Check results.\n        gen_v = saw_14.GetParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=self.params)\n\n        # Our present results should not be the same as the original.\n        try:\n            pd.testing.assert_frame_equal(gen_v, self.gen_v_pu)\n        except AssertionError:\n            # Frames are not equal. Success.\n            pass\n        else:\n            self.fail(\'DataFrames are equal, but they should not be.\')\n\n        # Our current results should have all 1\'s for the GenRegPUVolt\n        # column.\n        # actual = pd.to_numeric(gen_v[\'GenRegPUVolt\']).to_numpy()\n        actual = pd.to_numeric(gen_v[\'GenVoltSet\']).to_numpy()\n        expected = np.array([1.0] * actual.shape[0])\n\n        np.testing.assert_array_equal(actual, expected)\n\n    def test_missing_key_fields(self):\n        # Extract a portion of the gen_v_pu DataFrame which was created\n        # in setUpClass. Notably, this is missing GenID.\n        df = self.gen_v_pu[[\'BusNum\', \'GenVoltSet\']]\n\n        # Convert to list.\n        value_list = df.to_numpy().tolist()\n\n        with self.assertRaisesRegex(PowerWorldError,\n                                    \'does not adequately define each object\'):\n            saw_14.ChangeParametersMultipleElement(\n                ObjectType=\'gen\', ParamList=[\'BusNum\', \'GenVoltSet\'],\n                ValueList=value_list)\n\n    def test_bad_object_type(self):\n        with self.assertRaisesRegex(PowerWorldError,\n                                    \'Object type bad not recognized\'):\n            saw_14.ChangeParametersMultipleElement(ObjectType=\'bad\',\n                                                   ParamList=[\'BusNum\'],\n                                                   ValueList=[[1]])\n\n    def test_mismatched_list_lengths(self):\n        # Start by converting our generator data to a list of lists.\n        value_list = self.gen_v_pu.to_numpy().tolist()\n\n        # Delete an entry.\n        # noinspection PyUnresolvedReferences\n        del value_list[1][-1]\n\n        m = \'Number of fields and number of values given are not equal\'\n        with self.assertRaisesRegex(PowerWorldError, m):\n            # noinspection PyTypeChecker\n            saw_14.ChangeParametersMultipleElement(\n                ObjectType=\'gen\', ParamList=self.params,\n                ValueList=value_list\n            )\n\n\nclass ChangeParametersMultipleElementExpectedFailure(unittest.TestCase):\n    """"""Test case to illustrate the PowerWorld sometimes will not report\n    an error, but won\'t actually change a parameter when you ask it to.\n    TODO: Determine the mechanism by which PowerWorld does or does not\n        change values. Could we check if they\'re ""changeable"" before\n        hand?\n    """"""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        # Get generator key fields.\n        cls.key_field_df_gens = saw_14.get_key_fields_for_object_type(\'gen\')\n        cls.params = \\\n            cls.key_field_df_gens[\'internal_field_name\'].to_numpy().tolist()\n        # Combine key fields with our desired attribute.\n        cls.params.append(\'GenRegPUVolt\')\n        cls.gen_v_pu = saw_14.GetParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=cls.params)\n\n    # noinspection DuplicatedCode\n    @unittest.expectedFailure\n    def test_change_gen_voltage_set_points(self):\n        """"""Set all generator voltages to 1, and ensure the command\n        sticks.\n        """"""\n        # https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/ChangeParametersMultipleElement_Sample_Code_Python.htm%3FTocPath%3DAutomation%2520Server%2520Add-On%2520(SimAuto)%7CAutomation%2520Server%2520Functions%7C_____9\n        # Start by converting our generator data to a list of lists.\n        value_list = self.gen_v_pu.to_numpy().tolist()\n\n        # Loop over the values, set to 1.\n        # noinspection PyTypeChecker\n        for v in value_list:\n            # Set voltage at 1.\n            v[-1] = 1.0\n\n        # Send in the command.\n        # noinspection PyTypeChecker\n        self.assertIsNone(saw_14.ChangeParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=self.params, ValueList=value_list))\n\n        # Check results.\n        gen_v = saw_14.GetParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=self.params)\n\n        # Our present results should not be the same as the original.\n        try:\n            pd.testing.assert_frame_equal(gen_v, self.gen_v_pu)\n        except AssertionError:\n            # Frames are not equal. Success.\n            pass\n        else:\n            self.fail(\'DataFrames are equal, but they should not be.\')\n\n    # noinspection DuplicatedCode\n    @unittest.expectedFailure\n    def test_change_gen_voltage_set_points_via_helper(self):\n        """"""Use change_and_confirm_params_multiple_element.\n        """"""\n        command_df = self.gen_v_pu.copy(deep=True)\n        command_df[\'GenRegPUVolt\'] = 1.0\n\n        # noinspection PyNoneFunctionAssignment\n        result = saw_14.change_and_confirm_params_multiple_element(\n            ObjectType=\'gen\', command_df=command_df)\n\n        self.assertIsNone(result)\n\n\nclass ChangeParametersMultipleElementFlatInputTestCase(unittest.TestCase):\n    """"""Test ChangeParametersMultipleElementFlatInput""""""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        # Get generator key fields.\n        cls.key_field_df_gens = saw_14.get_key_fields_for_object_type(\'gen\')\n        cls.params = \\\n            cls.key_field_df_gens[\'internal_field_name\'].to_numpy().tolist()\n        # Combine key fields with our desired attribute.\n        cls.params.append(\'GenVoltSet\')\n        cls.gen_v_pu = saw_14.GetParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=cls.params)\n\n    # noinspection PyUnresolvedReferences\n    @classmethod\n    def tearDownClass(cls) -> None:\n        """"""Always be nice and clean up after yourself and put your toys\n        away. No, but seriously, put the voltage set points back.""""""\n        value_list = cls.gen_v_pu.to_numpy().tolist()\n        num_objects = len(value_list)\n        flattened_value_list = [val for sublist in value_list for val in\n                                sublist]\n        saw_14.ChangeParametersMultipleElementFlatInput(\n            ObjectType=\'gen\', ParamList=cls.params,\n            NoOfObjects=num_objects, ValueList=flattened_value_list)\n\n    # noinspection DuplicatedCode\n    def test_change_gen_voltage_set_points(self):\n        """"""Set all generator voltages to 1, and ensure the command\n        sticks.\n        """"""\n        # https://www.powerworld.com/WebHelp/#MainDocumentation_HTML/ChangeParametersMultipleElement_Sample_Code_Python.htm%3FTocPath%3DAutomation%2520Server%2520Add-On%2520(SimAuto)%7CAutomation%2520Server%2520Functions%7C_____9\n        # Start by converting our generator data to a list of lists.\n        value_list = self.gen_v_pu.to_numpy().tolist()\n\n        # Loop over the values, set to 1.\n        # noinspection PyTypeChecker\n        for v in value_list:\n            # Set voltage at 1.\n            v[-1] = 1.0\n\n        # Send in the command.\n        # noinspection PyTypeChecker\n        num_objects = len(value_list)\n        # noinspection PyTypeChecker\n        flattened_value_list = [val for sublist in value_list for val in\n                                sublist]\n        self.assertIsNone(saw_14.ChangeParametersMultipleElementFlatInput(\n            ObjectType=\'gen\', ParamList=self.params,\n            NoOfObjects=num_objects, ValueList=flattened_value_list))\n\n        # Check results.\n        gen_v = saw_14.GetParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=self.params)\n\n        # Our present results should not be the same as the original.\n        try:\n            pd.testing.assert_frame_equal(gen_v, self.gen_v_pu)\n        except AssertionError:\n            # Frames are not equal. Success.\n            pass\n        else:\n            self.fail(\'DataFrames are equal, but they should not be.\')\n\n        # Our current results should have all 1\'s for the GenRegPUVolt\n        # column.\n        # actual = pd.to_numeric(gen_v[\'GenRegPUVolt\']).to_numpy()\n        actual = pd.to_numeric(gen_v[\'GenVoltSet\']).to_numpy()\n        expected = np.array([1.0] * actual.shape[0])\n\n        np.testing.assert_array_equal(actual, expected)\n\n    # noinspection PyTypeChecker\n    def test_nested_value_list(self):\n        with self.assertRaisesRegex(Error,\n                                    \'The value list has to be a 1-D array\'):\n            value_list = self.gen_v_pu.to_numpy().tolist()\n            num_objects = len(value_list)\n            saw_14.ChangeParametersMultipleElementFlatInput(\n                ObjectType=\'gen\', ParamList=self.params,\n                NoOfObjects=num_objects, ValueList=value_list)\n\n\nclass ChangeParametersTestCase(unittest.TestCase):\n    """"""Test ChangeParameters.\n\n    TODO: This test case could use some more tests, e.g. expected\n        errors, etc.\n    """"""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.line_key_fields = saw_14.get_key_fields_for_object_type(\n            \'Branch\')[\'internal_field_name\'].tolist()\n        cls.line_r = [\'LineR\']\n        cls.params = cls.line_key_fields + cls.line_r\n        cls.line_data = saw_14.GetParametersMultipleElement(\n            ObjectType=\'Branch\', ParamList=cls.params)\n\n    @classmethod\n    def tearDownClass(cls) -> None:\n        """"""Be a good boy and put things back the way you found them.""""""\n        # noinspection PyUnresolvedReferences\n        saw_14.change_and_confirm_params_multiple_element(\n            \'Branch\', cls.line_data)\n\n    def test_change_line_r(self):\n        # Let\'s just change the first line resistance.\n        new_r = self.line_data.iloc[0][\'LineR\'] * 2\n        # Intentionally making a copy so that we don\'t modify the\n        # original DataFrame - we\'ll be using that to reset the line\n        # parameters after this test has run.\n        value_series = self.line_data.iloc[0].copy()\n        value_series[\'LineR\'] = new_r\n        values_list = value_series.tolist()\n        saw_14.ChangeParameters(\'Branch\', self.params, values_list)\n\n        # Retrieve the updated line parameters.\n        new_line_data = saw_14.GetParametersMultipleElement(\n            \'Branch\', self.params)\n\n        # Ensure the update went through.\n        self.assertEqual(new_line_data.iloc[0][\'LineR\'], new_r)\n\n\nclass ChangeParametersSingleElementTestCase(unittest.TestCase):\n    """"""Test ChangeParametersSingleElement.\n\n    TODO: This test case could use some more tests, e.g. expected\n        errors, etc.\n    """"""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.line_key_fields = saw_14.get_key_fields_for_object_type(\n            \'Branch\')[\'internal_field_name\'].tolist()\n        cls.line_r = [\'LineR\']\n        cls.params = cls.line_key_fields + cls.line_r\n        cls.line_data = saw_14.GetParametersMultipleElement(\n            ObjectType=\'Branch\', ParamList=cls.params)\n\n    @classmethod\n    def tearDownClass(cls) -> None:\n        """"""Be a good boy and put things back the way you found them.""""""\n        # noinspection PyUnresolvedReferences\n        saw_14.change_and_confirm_params_multiple_element(\n            \'Branch\', cls.line_data)\n\n    def test_change_line_r(self):\n        # Let\'s just change the first line resistance.\n        new_r = self.line_data.iloc[0][\'LineR\'] * 2\n        # Intentionally making a copy so that we don\'t modify the\n        # original DataFrame - we\'ll be using that to reset the line\n        # parameters after this test has run.\n        value_series = self.line_data.iloc[0].copy()\n        value_series[\'LineR\'] = new_r\n        values_list = value_series.tolist()\n        saw_14.ChangeParametersSingleElement(\'Branch\', self.params,\n                                             values_list)\n\n        # Retrieve the updated line parameters.\n        new_line_data = saw_14.GetParametersMultipleElement(\n            \'Branch\', self.params)\n\n        # Ensure the update went through.\n        self.assertEqual(new_line_data.iloc[0][\'LineR\'], new_r)\n\n\nclass GetFieldListTestCase(unittest.TestCase):\n    """"""Test the GetFieldList method""""""\n\n    def check_field_list(self, field_list):\n        """"""Helper to check a returned field list DataFrame.""""""\n        self.assertIsInstance(field_list, pd.DataFrame)\n        actual = field_list.columns.to_numpy().tolist()\n\n        # Check FIELD_LIST_COLUMNS first, then check\n        # FIELD_LIST_COLUMNS_OLD\n        new = False\n        old = False\n\n        try:\n            self.assertEqual(saw_14.FIELD_LIST_COLUMNS, actual)\n        except AssertionError:\n            new = True\n\n        try:\n            self.assertEqual(saw_14.FIELD_LIST_COLUMNS_OLD, actual)\n        except AssertionError as e2:\n            old = True\n\n        if new and old:\n            raise AssertionError(\'Valid columns:\\n{}\\n{}\\nReceived:{}\'\n                                 .format(saw_14.FIELD_LIST_COLUMNS,\n                                         saw_14.FIELD_LIST_COLUMNS_OLD,\n                                         actual))\n\n        pd.testing.assert_frame_equal(\n            field_list, field_list.sort_values(by=[\'internal_field_name\']))\n\n    def test_does_not_call_simauto_if_not_necessary(self):\n        """"""Ensure that if the field list has already been accessed for\n        the given object type that SimAuto is not called again.\n        """"""\n        # Generators are looked up by default on initialization.\n        with patch.object(saw_14, \'_call_simauto\') as m:\n            field_list = saw_14.GetFieldList(ObjectType=\'gen\')\n\n        # Ensure DataFrame is as expected.\n        self.check_field_list(field_list)\n\n        # Ensure _call_simauto was not called\n        self.assertEqual(m.call_count, 0)\n\n    def test_simauto_called_for_new_object_type(self):\n        """"""Ensure that for a new object type, SimAuto is called and\n        the new result is stored in the object_fields dictionary.\n        """"""\n        # Let\'s look up field for three winding transformers.\n        # Cast to lower case so we can easily use the variable later.\n        obj_type = \'3WXFormer\'.lower()\n\n        # Start by ensuring we don\'t currently have this in the\n        # dictionary.\n        self.assertNotIn(obj_type, saw_14._object_fields)\n\n        # Call GetFieldList.\n        try:\n            with patch.object(saw_14, \'_call_simauto\',\n                              wraps=saw_14._call_simauto) as p:\n                field_list = saw_14.GetFieldList(ObjectType=obj_type)\n\n            # Check our field list.\n            self.check_field_list(field_list)\n\n            # Ensure _call_simauto was called.\n            self.assertEqual(p.call_count, 1)\n            p.assert_called_with(\'GetFieldList\', obj_type)\n\n            # We should now have the object type in the object_fields\n            # attribute.\n            self.assertIn(obj_type, saw_14._object_fields)\n\n        finally:\n            # Always remove from the object_fields dictionary to avoid\n            # state changes that could impact other tests.\n            del saw_14._object_fields[obj_type]\n\n    def test_copy_true(self):\n        """"""Ensure we get a copy when asked for.""""""\n        field_list = saw_14.GetFieldList(\'gen\', copy=True)\n        self.assertIsNot(field_list, saw_14._object_fields[\'gen\'])\n\n    def test_copy_false(self):\n        """"""Ensure we don\'t get a copy when we don\'t ask for it.""""""\n        field_list = saw_14.GetFieldList(\'branch\')\n        self.assertIs(field_list, saw_14._object_fields[\'branch\'])\n\n    def test_works_if_object_type_not_in_model(self):\n        """"""Ensure we still get a valid field listing even if the given\n        object type is not in the model. Shunts are not present in the\n        14 bus test case.\n        """"""\n        field_list = saw_14.GetFieldList(\'shunt\')\n        self.check_field_list(field_list)\n\n    def test_switch_to_old_field_list(self):\n        """"""Ensure that switching to ""FIELD_LIST_COLUMNS_OLD works as\n        it should.\n        """"""\n        # Patch _object_fields to force a key error.\n        with patch.object(saw_14, \'_object_fields\', new={\'dict\': 1}):\n            # Patch _call_simauto to give us data that matches the shape\n            # of the FIELD_LIST_COLUMNS_OLD.\n            out = [[\'x\'] * len(saw_14.FIELD_LIST_COLUMNS_OLD) for _ in\n                   range(10)]\n\n            with patch.object(saw_14, \'_call_simauto\', return_value=out):\n                result = saw_14.GetFieldList(\'bus\')\n\n        # Ensure the result is a DataFrame.\n        self.assertIsInstance(result, pd.DataFrame)\n\n        # Ensure the columns are the ""OLD"" ones.\n        self.assertListEqual(result.columns.tolist(),\n                             saw_14.FIELD_LIST_COLUMNS_OLD)\n\n        # Ensure the shape is right. Hard-code the 10.\n        self.assertEqual(result.shape,\n                         (10, len(saw_14.FIELD_LIST_COLUMNS_OLD)))\n\n    def test_df_value_error_not_from_old_list(self):\n        """"""Make sure ValueError gets re-raised.""""""\n        # Patch DataFrame creation to raise error.\n        with patch(\'pandas.DataFrame\', side_effect=ValueError(\'stuff n th\')):\n            # Patch _object fields so that SimAuto is called. Using a\n            # dict for \'new\' is Brandon\'s hack to force a KeyError.\n            with patch.object(saw_14, \'_object_fields\', new={\'dict\': 1}):\n                # Ensure we get our DataFrame ValueError back.\n                with self.assertRaisesRegex(ValueError, \'stuff n th\'):\n                    saw_14.GetFieldList(\'bus\')\n\n\nclass GetParametersMultipleElementTestCase(unittest.TestCase):\n    """"""Test GetParametersMultipleElement""""""\n\n    def test_get_gen_voltage_set_points(self):\n        params = [\'BusNum\', \'GenID\', \'GenRegPUVolt\']\n        results = saw_14.GetParametersMultipleElement(\n            ObjectType=\'gen\', ParamList=params)\n\n        self.assertIsInstance(results, pd.DataFrame)\n        self.assertSetEqual(set(params), set(results.columns.to_numpy()))\n\n    def test_shunts_returns_none(self):\n        """"""There are no shunts in the 14 bus model.""""""\n        results = saw_14.GetParametersMultipleElement(ObjectType=\'shunt\',\n                                                      ParamList=[\'BusNum\'])\n        self.assertIsNone(results)\n\n    def test_get_nonexistent_parameter(self):\n        """"""We should get a ValueError for a bogus parameter.""""""\n        with self.assertRaisesRegex(ValueError, \'The given object has fields\'):\n            saw_14.GetParametersMultipleElement(\n                ObjectType=\'branch\', ParamList=[\'ThisNotReal\'])\n\n    def test_bad_object_type(self):\n        """"""A bad object type should raise an exception.""""""\n        with self.assertRaises(PowerWorldError):\n            saw_14.GetParametersMultipleElement(\n                ObjectType=\'bogus\', ParamList=[\'BusNum\']\n            )\n\n\nclass GetParametersMultipleElementFlatOutput(unittest.TestCase):\n    """"""Test GetParametersMultipleElementFlatOutput""""""\n\n    def test_get_gen_voltage_set_points(self):\n        params = [\'BusNum\', \'GenID\', \'GenRegPUVolt\']\n        results = saw_14.GetParametersMultipleElementFlatOutput(\n            ObjectType=\'gen\', ParamList=params)\n\n        self.assertIsInstance(results, tuple)\n\n        # Check that the length of the tuple is as expected, noting that\n        # the first two elements denote the number of elements and\n        # number of fields per element.\n        self.assertEqual(int(results[0]) * int(results[1]) + 2,\n                         len(results))\n\n    def test_shunts(self):\n        # 14 bus has no shunts.\n        kf = saw_14.get_key_field_list(\'shunt\')\n        self.assertIsNone(\n            saw_14.GetParametersMultipleElementFlatOutput(\n                \'shunt\', kf))\n\n\nclass GetParametersSingleElementTestCase(unittest.TestCase):\n    """"""Test GetParameterSingleElement method.""""""\n\n    # noinspection PyMethodMayBeStatic\n    def test_expected_results(self):\n        fields = [\'BusNum\', \'BusNum:1\', \'LineCircuit\', \'LineX\']\n\n        actual = saw_14.GetParametersSingleElement(\n            ObjectType=\'branch\', ParamList=fields, Values=[4, 9, \'1\', 0])\n\n        expected = pd.Series([4, 9, \'1\', 0.556180], index=fields)\n\n        pd.testing.assert_series_equal(actual, expected)\n\n    def test_nonexistent_object(self):\n        """"""Ensure an exception is raised if the object cannot be found.\n        """"""\n        with self.assertRaisesRegex(PowerWorldError, \'Object not found\'):\n            # 14 bus certainly does not have a 100th bus.\n            # noinspection PyUnusedLocal\n            actual = saw_14.GetParametersSingleElement(\n                ObjectType=\'gen\', ParamList=[\'BusNum\', \'GenID\', \'GenMW\'],\n                Values=[100, \'1\', 0]\n            )\n\n    def test_bad_field(self):\n        """"""Ensure an exception is raised when a bad field is provided.\n        """"""\n        with self.assertRaisesRegex(ValueError, \'The given object has fields\'):\n            saw_14.GetParametersSingleElement(\n                ObjectType=\'gen\', ParamList=[\'BusNum\', \'GenID\', \'BogusParam\'],\n                Values=[1, \'1\', 0]\n            )\n\n\nclass GetParametersTestCase(unittest.TestCase):\n    """"""Test GetParameters method.""""""\n\n    # noinspection PyMethodMayBeStatic\n    def test_expected_results(self):\n        fields = [\'BusNum\', \'BusNum:1\', \'LineCircuit\', \'LineX\']\n\n        actual = saw_14.GetParameters(\n            ObjectType=\'branch\', ParamList=fields, Values=[4, 9, \'1\', 0])\n\n        expected = pd.Series([4, 9, \'1\', 0.556180], index=fields)\n\n        pd.testing.assert_series_equal(actual, expected)\n\n    def test_nonexistent_object(self):\n        """"""Ensure an exception is raised if the object cannot be found.\n        """"""\n        with self.assertRaisesRegex(PowerWorldError, \'Object not found\'):\n            # 14 bus certainly does not have a 100th bus.\n            # noinspection PyUnusedLocal\n            actual = saw_14.GetParameters(\n                ObjectType=\'gen\', ParamList=[\'BusNum\', \'GenID\', \'GenMW\'],\n                Values=[100, \'1\', 0]\n            )\n\n    def test_bad_field(self):\n        """"""Ensure an exception is raised when a bad field is provided.\n        """"""\n        with self.assertRaisesRegex(ValueError, \'The given object has fields\'):\n            saw_14.GetParameters(\n                ObjectType=\'gen\', ParamList=[\'BusNum\', \'GenID\', \'BogusParam\'],\n                Values=[1, \'1\', 0]\n            )\n\n\nclass GetSpecificFieldListTestCase(unittest.TestCase):\n    """"""Test GetSpecificFieldList""""""\n\n    def helper(self, df):\n        """"""Helper for checking basic DataFrame attributes.""""""\n        # Ensure columns match up.\n        self.assertListEqual(list(df.columns),\n                             saw_14.SPECIFIC_FIELD_LIST_COLUMNS)\n\n        # The dtypes for all columns should be strings, which are\n        # \'objects\' in Pandas.\n        self.assertTrue((df.dtypes == np.dtype(\'O\')).all())\n\n        # Ensure we\'re sorted by the first column.\n        self.assertTrue(\n            df[saw_14.SPECIFIC_FIELD_LIST_COLUMNS[0]].is_monotonic_increasing)\n\n        # Ensure the index starts at 0 and is monotonic\n        self.assertTrue(df.index[0] == 0)\n        self.assertTrue(df.index.is_monotonic_increasing)\n\n    def test_all(self):\n        """"""As documented, try using the ALL specifier.""""""\n        # Fetch all gen parameters.\n        out = saw_14.GetSpecificFieldList(\'gen\', [\'ALL\'])\n\n        # Do basic tests.\n        self.helper(out)\n\n        # For whatever reason, the following does not work. We get\n        # lengths of 808 and 806, respectively. This is not worth\n        # investigating.\n        # # Ensure we get the same number of parameters as were pulled for\n        # # GetFieldList.\n        # out2 = saw_14.GetFieldList(\'gen\')\n        #\n        # self.assertEqual(out.shape[0], out2.shape[0])\n\n        #\n\n    def test_all_location(self):\n        """"""As documented, try using variablename:ALL""""""\n        out = saw_14.GetSpecificFieldList(\'load\', [\'ABCLoadAngle:ALL\'])\n\n        # Do basic tests.\n        self.helper(out)\n\n        # We should get three entries back.\n        self.assertEqual(3, out.shape[0])\n\n    def test_some_variables(self):\n        """"""Pass a handful of variables in.""""""\n        v = [\'GenVoltSet\', \'GenMW\', \'GenMVR\']\n        out = saw_14.GetSpecificFieldList(\'gen\', v)\n\n        # Do basic tests.\n        self.helper(out)\n\n        # We should get an entry for each item in the list.\n        self.assertEqual(len(v), out.shape[0])\n\n\nclass GetSpecificFieldMaxNumTestCase(unittest.TestCase):\n    """"""Test GetSpecificFieldMaxNum.""""""\n\n    def test_load_angle(self):\n        # While there are 3 ABCLoadAngle variables, the maximum number\n        # is 2.\n        self.assertEqual(\n            2, saw_14.GetSpecificFieldMaxNum(\'load\', \'ABCLoadAngle\'))\n\n    def test_bad_input(self):\n        with self.assertRaisesRegex(PowerWorldError,\n                                    \'PowerWorld simply returned -1\'):\n            saw_14.GetSpecificFieldMaxNum(\'bogus\', \'bogus\')\n\n\nclass ListOfDevicesTestCase(unittest.TestCase):\n    """"""Test ListOfDevices for the 14 bus case.""""""\n\n    # noinspection PyMethodMayBeStatic\n    def test_gens(self):\n        """"""Ensure there are 5 generators at the correct buses.""""""\n        # Query.\n        result = saw_14.ListOfDevices(ObjType=\'Gen\')\n        # The 14 bus case has 5 generators at buses 1, 2, 3, 6, and 8.\n        # Since there\'s only one generator at each bus, they have an\n        # ID of 1. However, ID is a string field.\n        expected = pd.DataFrame([[1, \'1\'], [2, \'1\'], [3, \'1\'], [6, \'1\'],\n                                 [8, \'1\']], columns=[\'BusNum\', \'GenID\'])\n\n        pd.testing.assert_frame_equal(expected, result)\n\n    def test_shunts(self):\n        """"""There are no shunts in th 14 bus model.""""""\n        result = saw_14.ListOfDevices(ObjType=""Shunt"")\n        self.assertIsNone(result)\n\n    def test_branches(self):\n        """"""Ensure we get the correct number of branches, and ensure\n        we get back the expected fields.\n        """"""\n        result = saw_14.ListOfDevices(ObjType=""Branch"")\n        # 3 transformers, 17 lines.\n        self.assertEqual(20, result.shape[0])\n        # Check columns.\n        self.assertIn(\'BusNum\', result.columns.to_numpy())\n        self.assertIn(\'BusNum:1\', result.columns.to_numpy())\n        self.assertIn(\'LineCircuit\', result.columns.to_numpy())\n\n        # Ensure our BusNum columns are numeric.\n        # noinspection PyUnresolvedReferences\n        self.assertTrue(pd.api.types.is_numeric_dtype(result[\'BusNum\']))\n        # noinspection PyUnresolvedReferences\n        self.assertTrue(pd.api.types.is_numeric_dtype(result[\'BusNum:1\']))\n\n        # Ensure our LineCircuit is a string.\n        # noinspection PyUnresolvedReferences\n        self.assertTrue(pd.api.types.is_string_dtype(result[\'LineCircuit\']))\n\n        # Ensure there\'s no leading space in LineCircuit.\n        pd.testing.assert_series_equal(result[\'LineCircuit\'],\n                                       result[\'LineCircuit\'].str.strip())\n\n        # For the grand finale, ensure we\'re sorted by BusNum.\n        pd.testing.assert_frame_equal(result, result.sort_values(by=\'BusNum\'))\n\n    # noinspection PyMethodMayBeStatic\n    def test_buses(self):\n        """"""As the name implies, we should get 14 buses.""""""\n        result = saw_14.ListOfDevices(ObjType=""Bus"")\n        # noinspection PyTypeChecker\n        expected = pd.DataFrame(\n            data=np.arange(1, 15, dtype=np.int64).reshape(14, 1),\n            index=np.arange(0, 14),\n            columns=[\'BusNum\'])\n        pd.testing.assert_frame_equal(expected, result)\n\n\nclass ListOfDevicesAsVariantStrings(unittest.TestCase):\n    """"""Test ListOfDevicesAsVariantStrings""""""\n\n    def test_buses(self):\n        # Call method.\n        out = saw_14.ListOfDevicesAsVariantStrings(\'bus\')\n\n        # We should get a tuple of tuples.\n        self.assertEqual(1, len(out))\n\n        # 14 buses.\n        self.assertEqual(14, len(out[0]))\n\n\nclass GetCaseHeaderTestCase(unittest.TestCase):\n    """"""Test GetCaseHeader""""""\n\n    def test_case_header(self):\n        # Call method.\n        out = saw_14.GetCaseHeader()\n\n        self.assertIsInstance(out, tuple)\n\n        for item in out:\n            self.assertIsInstance(item, str)\n\n\nclass ListOfDevicesFlatOutputTestCase(unittest.TestCase):\n    """"""Test ListOfDevicesFlatOutput.""""""\n\n    def test_buses(self):\n        # Call method for buses.\n        out = saw_14.ListOfDevicesFlatOutput(\'bus\')\n        self.assertTrue(isinstance(out, tuple))\n\n        # Since buses have a single key field (BusNum), we\'ll only get\n        # one return per bus. So, including the two fields at the\n        # beginning of the list, we\'ll have 16 elements.\n        self.assertEqual(16, len(out))\n\n\nclass LoadStateErrorTestCase(unittest.TestCase):\n    """"""Test LoadState without calling SaveState, and ensure we get an\n    error from PowerWorld.\n\n    We\'ll spin up a new SAW instance so as to have state independence\n    from other tests, at the cost of increasing test run time by\n    several seconds.\n    """"""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.saw = SAW(PATH_14)\n\n    # noinspection PyUnresolvedReferences\n    @classmethod\n    def tearDownClass(cls) -> None:\n        cls.saw.exit()\n        del cls.saw\n\n    def test_load_state_errors(self):\n        """"""Call LoadState without calling SaveState.""""""\n        with self.assertRaisesRegex(\n                PowerWorldError, ""State hasn\'t been previously stored.""):\n            self.saw.LoadState()\n\n\nclass LoadStateSaveStateTestCase(unittest.TestCase):\n    """"""Test that LoadState works after calling SaveState.""""""\n\n    def test_save_change_load(self):\n        """"""Save the state, make a change, load the state, ensure changes\n        were reverted.\n        """"""\n        # Get branch data.\n        branch_key_fields = saw_14.get_key_field_list(\'branch\')\n        branch_data = saw_14.GetParametersMultipleElement(\n            \'branch\', branch_key_fields + [\'LineStatus\'])\n\n        # Save the state.\n        self.assertIsNone(saw_14.SaveState())\n\n        # Open a line.\n        branch_data_copy = branch_data.copy(deep=True)\n        self.assertEqual(\'Closed\', branch_data_copy.loc[3, \'LineStatus\'])\n        branch_data_copy.loc[3, \'LineStatus\'] = \'Open\'\n        saw_14.change_and_confirm_params_multiple_element(\n            \'branch\', branch_data_copy)\n\n        # Load the saved state.\n        self.assertIsNone(saw_14.LoadState())\n\n        # Ensure that new branch data equals original.\n        branch_data_new = saw_14.GetParametersMultipleElement(\n            \'branch\', branch_key_fields + [\'LineStatus\'])\n\n        pd.testing.assert_frame_equal(branch_data, branch_data_new)\n\n\nclass ProcessAuxFileTestCase(unittest.TestCase):\n    """"""Light weight testing of ProcessAuxFile.""""""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.saw = SAW(FileName=PATH_2000, early_bind=True, UIVisible=False)\n\n    @classmethod\n    def tearDownClass(cls) -> None:\n        # noinspection PyUnresolvedReferences\n        cls.saw.exit()\n\n    def test_process_aux_ltc_filter(self):\n        # Process the aux file. Note the aux file has a named filter,\n        # ""area_filter""\n        self.saw.ProcessAuxFile(FileName=AREA_AUX_FILE)\n\n        # Get bus key fields.\n        kf = self.saw.get_key_field_list(\'bus\')\n\n        # Get bus data, using the named filter.\n        area_bus = self.saw.GetParametersMultipleElement(\n            ObjectType=\'bus\', ParamList=kf, FilterName=""area_filter""\n        )\n\n        # Check that the filter worked.\n        bus = self.saw.GetParametersMultipleElement(\n            ObjectType=\'bus\', ParamList=kf + [\'AreaName\']\n        )\n\n        # Ensure the bus data is not getting filtered.\n        self.assertNotEqual(area_bus.shape[0], bus.shape[0])\n\n        # Ensure the number of buses in the area matches up.\n        bus_expected = bus[\'AreaName\'] == \'East\'\n        self.assertEqual(bus_expected.sum(), area_bus.shape[0])\n\n\nclass RunScriptCommandTestCase(unittest.TestCase):\n    """"""Light weight testing of RunScriptCommand.""""""\n\n    # noinspection PyMethodMayBeStatic\n    def test_calls_call_simauto(self):\n        """"""RunScriptCommand is a simple wrapper. Enforce this.""""""\n        with patch.object(saw_14, \'_call_simauto\') as p:\n            saw_14.RunScriptCommand(Statements=\'Some stuff\')\n\n        # _call_simauto should have been called once and the statements\n        # should simply be passed through.\n        p.assert_called_once_with(\'RunScriptCommand\', \'Some stuff\')\n\n    def test_exception_for_bad_statement(self):\n        """"""Ensure an exception is thrown for a bad statement.""""""\n        with self.assertRaisesRegex(PowerWorldError,\n                                    \'Error in script statements definition\'):\n            saw_14.RunScriptCommand(Statements=\'invalid statement\')\n\n\nclass OpenCaseTypeTestCase(unittest.TestCase):\n    """"""Test OpenCaseType. The tests here are admittedly a bit crude.""""""\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.saw = SAW(PATH_14)\n\n    # noinspection PyUnresolvedReferences\n    @classmethod\n    def tearDownClass(cls) -> None:\n        cls.saw.exit()\n\n    def test_expected_behavior(self):\n        self.saw.CloseCase()\n        self.saw.OpenCaseType(PATH_14, \'PWB\')\n        # Ensure our pwb_file_path matches our given path.\n        self.assertEqual(PATH_14,\n                         self.saw.pwb_file_path)\n\n    def test_options_single(self):\n        # Ensure this runs without error.\n        self.saw.OpenCaseType(PATH_14, \'PWB\', \'YES\')\n\n    def test_options_multiple(self):\n        # Ensure this runs without error.\n        self.saw.OpenCaseType(PATH_14, \'PWB\', [\'YES\', \'NEAR\'])\n\n\nclass OpenCaseTestCase(unittest.TestCase):\n    """"""Test OpenCase.""""""\n    def test_failure_if_pwb_file_path_none(self):\n        m = \'When OpenCase is called for the first time,\'\n        with patch.object(saw_14, \'pwb_file_path\', new=None):\n            with self.assertRaisesRegex(TypeError, m):\n                saw_14.OpenCase()\n\n\nclass TSGetContingencyResultsTestCase(unittest.TestCase):\n    """"""Test TSGetContingencyResults.""""""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        # Open up the nine bus model.\n        cls.saw = SAW(PATH_9, early_bind=True)\n\n        # The 9 bus model has a contingency already defined:\n        cls.ctg_name = \'My Transient Contingency\'\n\n    # noinspection PyUnresolvedReferences\n    @classmethod\n    def tearDownClass(cls) -> None:\n        cls.saw.exit()\n\n    def test_nonexistent_ctg(self):\n        """"""Should get Nones back when running a contingency that does\n        not exist.\n        """"""\n        # Define contingency name.\n        ctg_name = \'ctgName\'\n\n        #\n        obj_field_list = [\'""Plot \'\'Gen_Rotor Angle\'\'""\']\n\n        #\n        t1 = \'0.0\'\n        t2 = \'10.0\'\n\n        meta, data = self.saw.TSGetContingencyResults(ctg_name, obj_field_list,\n                                                      t1, t2)\n\n        self.assertIsNone(meta)\n        self.assertIsNone(data)\n\n    @unittest.skip(\'This test hangs. PowerWorld somehow gets upset if you \'\n                   \'ask for results and have not solved the transient \'\n                   \'contingency.\')\n    def test_existing_ctg(self):\n        """"""THIS HANGS! Contingency exists in case, but has not been\n        solved yet.""""""\n        # This came from a PowerWorld example:\n        obj_field_list = [\'""Plot \'\'Gen_Rotor Angle\'\'""\']\n\n        #\n        t1 = \'0.0\'\n        t2 = \'10.0\'\n\n        result = self.saw.TSGetContingencyResults(\n            self.ctg_name, obj_field_list, t1, t2)\n\n        print(result)\n\n        pass\n\n    def test_solve_and_run(self):\n        """"""Solve the contingency and run the function.""""""\n        # This came from a PowerWorld example:\n        obj_field_list = [\'""Plot \'\'Gen_Rotor Angle\'\'""\']\n\n        #\n        t1 = \'0.0\'\n        t2 = \'10.0\'\n\n        # Solve.\n        self.saw.RunScriptCommand(\'TSSolve(""{}"")\'.format(self.ctg_name))\n\n        # Get results.\n        meta, data = self.saw.TSGetContingencyResults(\n            self.ctg_name, obj_field_list, t1, t2)\n\n        # Check types.\n        self.assertIsInstance(meta, pd.DataFrame)\n        self.assertIsInstance(data, pd.DataFrame)\n\n        # Ensure shapes are as expected.\n        self.assertEqual(meta.shape[0], data.shape[1] - 1)\n\n        # Data should all be floats.\n        for dtype in data.dtypes:\n            self.assertEqual(dtype, np.float64)\n\n        # Rows in meta should match columns in data.\n        meta_rows = meta.index.tolist()\n        data_cols = data.columns.tolist()\n\n        # Remove time from data columns.\n        data_cols.remove(\'time\')\n\n        self.assertListEqual(meta_rows, data_cols)\n\n    def test_individual_object_field_pair(self):\n        """"""Obtain the result for an individual object/field pair""""""\n        # The target is the frequency data from Bus 4.\n        obj_field_list = [\'""Bus 4 | frequency""\']\n\n        # Set up TS parameters\n        t1 = 0.0\n        t2 = 10.0\n        stepsize = 0.01\n\n        # Solve.\n        cmd = \'TSSolve(""{}"",[{},{},{},NO])\'.format(\n            self.ctg_name, t1, t2, stepsize\n        )\n        self.saw.RunScriptCommand(cmd)\n\n        # Get results.\n        meta, data = self.saw.TSGetContingencyResults(\n            self.ctg_name, obj_field_list, str(t1), str(t2))\n\n        # Ensure shapes are as expected.\n        self.assertEqual(meta.shape[0], 1)  # Only 1 object/field pair\n        self.assertEqual(data.shape[1], 2)  # Plus the time column\n\n        # ObjectType should be Bus\n        self.assertEqual(meta[\'ObjectType\'].values[0], \'Bus\')\n\n        # Primary key should be 4.\n        self.assertEqual(meta[\'PrimaryKey\'].values[0], \'4\')\n\n        # Start and end time should match the arguments in the query.\n        self.assertEqual(data[\'time\'].iloc[0], t1)\n        self.assertEqual(data[\'time\'].iloc[-1], t2)\n\n        # Data row count >= (t2 - t1)/stepsize + contingency count + 1\n        # This is due to the repeated time point when contingencies\n        # occur, and also some contingencies are self-cleared (which\n        # only show once in the contingency element list but will also\n        # result in repeated time point when it is cleared.\n        params = self.saw.get_key_field_list(\'TSContingencyElement\')\n        contingency = self.saw.GetParametersMultipleElement(\n            \'TSContingencyElement\', params)\n        self.assertGreaterEqual(data.shape[0],\n                                (t2-t1)/stepsize+contingency.shape[0]+1)\n\n\nclass WriteAuxFileTestCaseTestCase(unittest.TestCase):\n    """"""Test WriteAuxFile.""""""\n\n    def test_file_is_created(self):\n        temp_path = tempfile.NamedTemporaryFile(mode=\'w\', suffix=\'.axd\',\n                                                delete=False)\n        temp_path.close()\n        saw_14.WriteAuxFile(FileName=temp_path.name,\n                            FilterName="""",\n                            ObjectType=""Bus"",\n                            FieldList=""all"")\n        self.assertTrue(os.path.isfile(temp_path.name))\n        os.unlink(temp_path.name)\n\n\nclass SaveCaseTestCase(unittest.TestCase):\n    """"""Test SaveCase.""""""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.out_file = os.path.join(THIS_DIR, \'tmp.pwb\')\n\n    # noinspection PyUnresolvedReferences\n    @classmethod\n    def tearDownClass(cls) -> None:\n        os.remove(cls.out_file)\n\n    def test_save_creates_file(self):\n        """"""Simply save the case and then ensure the file is present.""""""\n        # File should not exist.\n        self.assertFalse(os.path.isfile(self.out_file))\n\n        # Save file.\n        saw_14.SaveCase(FileName=self.out_file)\n\n        # File should exist (it\'ll get cleaned up by tearDownClass).\n        self.assertTrue(os.path.isfile(self.out_file))\n\n    def test_bad_type(self):\n        """"""A bad FileType should result in a PowerWorldError.""""""\n        with self.assertRaises(PowerWorldError):\n            saw_14.SaveCase(FileName=self.out_file, FileType=\'BAD\',\n                            Overwrite=True)\n\n    # noinspection PyMethodMayBeStatic\n    def test_save_with_same_file(self):\n        """"""Save case with the existing file, but don\'t actually call\n        SimAuto.\n        """"""\n        with patch.object(saw_14, \'_call_simauto\') as p:\n            saw_14.SaveCase()\n\n        p.assert_called_once_with(\n            \'SaveCase\', convert_to_windows_path(saw_14.pwb_file_path),\n            \'PWB\', True)\n\n    def test_save_with_missing_path(self):\n        m = \'SaveCase was called without a FileName, but it would appear\'\n        with patch.object(saw_14, \'pwb_file_path\', new=None):\n            with self.assertRaisesRegex(TypeError, m):\n                saw_14.SaveCase()\n\n\nclass SendToExcel(unittest.TestCase):\n    """"""Test SendTOExcel\n    The author was not able to sufficiently test this method, since\n    the tested function would open an excel sheet and copy to it without\n    saving. This also creates a big problem when trying to use the excel\n    COM interface to access the sheet and verify the data, cause the COM\n    object is likely in use and cannot be operated by another process.\n    """"""\n\n    def test_nonexistobject(self):\n        """"""Ensure an exception is raised if the object can\'t be found""""""\n        with self.assertRaises(PowerWorldError):\n            # No object type named Gen1 ""\n            fields = [\'BusNum\', \'GenID\', \'BusNomVolt\']\n            saw_14.SendToExcel(\n                ObjectType=\'Gen1\', FilterName=\'\', FieldList=fields)\n\n\n########################################################################\n# Properties tests\n########################################################################\n\n# noinspection PyStatementEffect\nclass SimAutoPropertiesTestCase(unittest.TestCase):\n    """"""Test the SimAuto attributes.""""""\n\n    def test_current_dir(self):\n        cwd = saw_14.CurrentDir\n        self.assertIsInstance(cwd, str)\n        self.assertIn(\'ESA\', cwd)\n\n    def test_process_id(self):\n        pid = saw_14.ProcessID\n        self.assertIsInstance(pid, int)\n\n    def test_request_build_date(self):\n        bd = saw_14.RequestBuildDate\n        self.assertIsInstance(bd, int)\n\n    def test_ui_visible(self):\n        # UIVisible introduced in version 20.\n        if VERSION >= 20:\n            self.assertFalse(saw_14.UIVisible)\n        else:\n            with self.assertLogs(logger=saw_14.log, level=\'WARN\'):\n                saw_14.UIVisible\n\n    def test_attr_error_ui_visible(self):\n        """"""Patch UIVisible, and ensure we get a warning when it throws\n        an attribute error.\n        """"""\n        # Create a mock for saw_14_pwcom. This is necessary because\n        # patching attributes of the actual COM object doesn\'t work\n        # very well.\n        com_patch = MagicMock()\n        # seal the mock so that attempts to access non-existent\n        # attribute will result in an AttributeError.\n        seal(com_patch)\n\n        # Mock out _pwcom and get the UIVisible attribute.\n        with patch.object(saw_14, \'_pwcom\', new=com_patch):\n            with self.assertLogs(logger=saw_14.log, level=\'WARN\'):\n                result = saw_14.UIVisible\n\n        self.assertFalse(result)\n\n    def test_create_if_not_found(self):\n        self.assertFalse(saw_14.CreateIfNotFound)\n\n\n########################################################################\n# ScriptCommand helper tests\n########################################################################\n\n\nclass SolvePowerFlowTestCase(unittest.TestCase):\n    """"""Test the SolvePowerFlow method. Note PowerWorld doesn\'t return\n    anything for this script command, so we should always get None back\n    unless there is an error.\n    """"""\n\n    def test_solve_defaults(self):\n        """"""Solving the power flow with default options should just work.\n        """"""\n        self.assertIsNone(saw_14.SolvePowerFlow())\n\n    def test_solve_bad_method(self):\n        """"""Given a bad solver, we should expect an exception.""""""\n        with self.assertRaisesRegex(PowerWorldError,\n                                    \'Invalid solution method\'):\n            saw_14.SolvePowerFlow(SolMethod=\'junk\')\n\n\nclass OpenOneLineTestCase(unittest.TestCase):\n    """"""Test the OpenOneLine method. Note PowerWorld doesn\'t return\n    anything for this script command, so we should always get None back\n    unless there is an error.\n    """"""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        # For now, skip old versions of PowerWorld.\n        # TODO: remove this skip statement after saving the .pwd files\n        #   in different PowerWorld formats.\n        skip_if_version_below(21)\n\n    def test_open_default(self):\n        """"""Open the correct pwd file.\n        """"""\n        self.assertIsNone(saw_14.OpenOneLine(PATH_14_PWD))\n\n    def test_open_invalid_format_file(self):\n        """"""Open the non-PWD file should raise a PowerWorld Error\n        """"""\n        with self.assertRaisesRegex(PowerWorldError,\n                                    \'Error opening oneline\'):\n            saw_14.OpenOneLine(PATH_14)\n\n\nclass CloseOnelineTestCase(unittest.TestCase):\n    """"""Test the CloseOneline method. Note PowerWorld doesn\'t return\n    anything for this script command, so we should always get None back\n    unless there is an error.\n    """"""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        # For now, skip old versions of PowerWorld.\n        # TODO: remove this skip statement after saving the .pwd files\n        #   in different PowerWorld formats.\n        skip_if_version_below(21)\n\n    def test_close_default(self):\n        """"""Close the last focused oneline diagram.\n        """"""\n        saw_14.OpenOneLine(PATH_14_PWD)\n        self.assertIsNone(saw_14.CloseOneline())\n\n    def test_close_with_name(self):\n        """"""Close the oneline diagram with the CORRECT name.\n        """"""\n        saw_14.OpenOneLine(PATH_14_PWD)\n        self.assertIsNone(saw_14.CloseOneline(os.path.basename(PATH_14_PWD)))\n\n    def test_close_with_wrong_name(self):\n        """"""Close the oneline diagram with wrong name should raise a\n        PowerWorld Error\n        """"""\n        saw_14.OpenOneLine(PATH_14_PWD)\n        with self.assertRaisesRegex(PowerWorldError,\n                                    \'Cannot find Oneline\'):\n            saw_14.CloseOneline(""A file that cannot be found"")\n\n    def test_close_with_invalid_identifier(self):\n        """"""Close the oneline diagram with invalid identifier should\n        raise a PowerWorld Error\n        """"""\n        saw_14.OpenOneLine(PATH_14_PWD)\n        with self.assertRaisesRegex(PowerWorldError,\n                                    \'invalid identifier character\'):\n            saw_14.CloseOneline(PATH_14_PWD)\n\n\n########################################################################\n# Misc tests\n########################################################################\n\n\nclass TestCreateNewLinesFromFile2000Bus(unittest.TestCase):\n    """"""Test for looking into\n    https://github.com/mzy2240/ESA/issues/4#issue-526268959\n    """"""\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        # We\'re creating lines, so we want CreateIfNotFound to be\n        # true.\n        cls.saw = SAW(FileName=PATH_2000, CreateIfNotFound=True,\n                      early_bind=True)\n        cls.line_df = pd.read_csv(os.path.join(DATA_DIR, \'CandidateLines.csv\'))\n\n    @classmethod\n    def tearDownClass(cls) -> None:\n        # noinspection PyUnresolvedReferences\n        cls.saw.exit()\n\n    def test_create_lines(self):\n        # Rename columns to match PowerWorld variables.\n        self.line_df.rename(\n            # TODO: Will need to update this renaming once\n            #   https://github.com/mzy2240/ESA/issues/1#issue-525219427\n            #   is addressed.\n            columns={\n                \'From Number\': \'BusNum\',\n                \'To Number\': \'BusNum:1\',\n                \'Ckt\': \'LineCircuit\',\n                \'R\': \'LineR\',\n                \'X\': \'LineX\',\n                \'B\': \'LineC\',\n                \'Lim MVA A\': \'LineAMVA\'\n            },\n            inplace=True)\n\n        # We\'re required to set other limits too.\n        self.line_df[\'LineAMVA:1\'] = 0.0\n        self.line_df[\'LineAMVA:2\'] = 0.0\n\n        # Move into edit mode so we can add lines.\n        self.saw.RunScriptCommand(""EnterMode(EDIT);"")\n\n        # Create the lines.\n        self.saw.change_and_confirm_params_multiple_element(\n            ObjectType=\'branch\', command_df=self.line_df)\n\n\nclass CallSimAutoTestCase(unittest.TestCase):\n    """"""Test portions of _call_simauto not covered by the higher level\n    methods.\n    """"""\n    def test_bad_function(self):\n        with self.assertRaisesRegex(AttributeError, \'The given function, bad\'):\n            saw_14._call_simauto(\'bad\')\n\n    def test_weird_type_error(self):\n        """"""I\'ll be honest - I\'m just trying to get testing coverage to\n        100%, and I have no idea how to get this exception raised\n        without doing some hacking. Here we go.\n        """"""\n        m = MagicMock()\n        m.GetParametersSingleElement = Mock(return_value=(\'issues\', 12))\n        with patch.object(saw_14, \'_pwcom\', new=m):\n            with patch(\'esa.saw.PowerWorldError\',\n                       side_effect=TypeError(\'weird things\')):\n                with self.assertRaises(TypeError):\n                    saw_14.GetParametersSingleElement(\'bus\', [\'BusNum\'], [1])\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tests/test_snippets.py,0,"b'""""""This testing module runs all the code snippets in the\ndocs/rst/snippets directory.""""""\n\nimport unittest\nimport doctest\nimport logging\n\nfrom esa import SAW\n# noinspection PyUnresolvedReferences\nfrom tests.constants import CASE_MAP, SNIPPET_FILES, CANDIDATE_LINES, PATH_14\n\n# Set up log.\nLOG = logging.getLogger()\n\n# The broken snipped is:\nBROKEN = \'weighted_graph_14.rst\'\n# Version threshold:\nBROKEN_THRESHOLD = 21\n\n########################################################################\n# DOC TESTS\n########################################################################\n# The ""load_tests"" and ""get_snippet_suites"" methods below take care of\n# everything needed to run all the snippets.\n\n\n# To enable unittest discovery:\n# https://docs.python.org/3.8/library/doctest.html#unittest-api\n# noinspection PyUnusedLocal\ndef load_tests(loader, tests, ignore):\n    suites = get_snippet_suites()\n    for s in suites:\n        tests.addTests(s)\n    return tests\n\n\ndef get_snippet_suites():\n    """"""Return list of DocFileSuites""""""\n    # We need to get the Simulator version so we can skip tests that are\n    # broken for certain versions.\n    saw_14 = SAW(PATH_14)\n    version = saw_14.version\n    saw_14.exit()\n    del saw_14\n\n    out = []\n    # Loop over the available cases.\n    for suffix, case_path in CASE_MAP.items():\n        # Filter files by suffix, which corresponds to the case.\n        files = [x for x in SNIPPET_FILES if x.endswith(suffix + \'.rst\')]\n\n        if len(files) > 0:\n            # Recreate a list that excludes the broken file. For now,\n            # we\'ll skip if the version is less than 21.\n            if version < BROKEN_THRESHOLD:\n                not_broken_files = [x for x in files if BROKEN not in x]\n                if len(not_broken_files) != len(files):\n                    LOG.warning(\n                        \'The snippet {} is being skipped because the \'\n                        \'Simulator version is < {}\'.format(BROKEN,\n                                                           BROKEN_THRESHOLD))\n            else:\n                not_broken_files = files\n\n            # Define global variables needed for the examples.\n            g = {\'CASE_PATH\': case_path}\n            if \'2000\' in suffix:\n                # One example adds lines and depends on a .csv file.\n                g[\'CANDIDATE_LINES\'] = CANDIDATE_LINES\n\n            # Create a DocFileSuite.\n            out.append(doctest.DocFileSuite(\n                *not_broken_files, module_relative=False,\n                globs=g))\n\n    return out\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
docs/rst/conf.py,0,"b'# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\nsys.path.insert(0, os.path.abspath(\'../\'))\nsys.path.insert(0, os.path.abspath(\'../../\'))\n\n# Open and read the version file.\nwith open(\'../../VERSION\', \'r\') as fh:\n    __version__ = fh.read()\n\n# -- Project information -----------------------------------------------------\n\nproject = \'ESA\'\ncopyright = \'2020, Brandon Thayer, Zeyu Mao, Yijing Liu\'\nauthor = \'Brandon Thayer, Zeyu Mao, Yijing Liu\'\n\n# The short X.Y version\nversion = __version__\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\'sphinx.ext.autodoc\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\n#\n# Note from Brandon: Add directories containing sub-files to avoid\n# warnings during build time. Hopefully this doesn\'t shoot us in the\n# foot later.\n# https://stackoverflow.com/a/15438962/11052174\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\', \'installation\',\n                    \'snippets\', \'welcome\', \'citation.rst\', \'README.rst\',\n                    \'.coverage\', \'coverage.rst\', \'coverage_to_rst.py\']\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'alabaster\'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n########################################################################\n# Prevent skipping __init___\n# Source: https://stackoverflow.com/a/9772922\n########################################################################\n\nautoclass_content = \'both\'\n'"
docs/rst/coverage_to_rst.py,0,"b'""""""This module runs the ESA tests and evaluates testing coverage. The\ntop-level README.rst file will be automatically updated, and a new file\nwhich can be included in the documentation, coverage.rst, is generated.\n\nPlease run this script from the directory it exists in.\n""""""\nfrom coverage import Coverage\nfrom unittest import TestLoader, TestResult\nimport os\nimport json\nfrom tabulate import tabulate\nfrom collections import OrderedDict\nimport subprocess\nimport datetime\nimport re\nimport sys\n\n# Paths:\nTHIS_DIR = os.path.dirname(os.path.abspath(__file__))\nTOP_LEVEL = os.path.abspath(os.path.join(THIS_DIR, \'..\', \'..\'))\nTEST_DIR = os.path.join(TOP_LEVEL, \'tests\')\nESA_DIR = os.path.join(TOP_LEVEL, \'esa\')\nJSON_FILE = os.path.join(THIS_DIR, \'coverage.json\')\nREADME = os.path.join(TOP_LEVEL, \'README.rst\')\n\n# Add root project to the path.\nsys.path.insert(0, TOP_LEVEL)\n\n\ndef main():\n    # Initialize coverage stuff.\n    cov = Coverage(source=[ESA_DIR], config_file=False)\n    cov.start()\n\n    # Run tests.\n    run_tests()\n\n    # Stop collecting coverage data.\n    cov.stop()\n\n    # Create a json report so we can easily get data into a dictionary.\n    cov.json_report(outfile=JSON_FILE)\n\n    # Read the json report.\n    with open(JSON_FILE, \'r\') as f:\n        report_dict = json.load(f)\n\n    # Clean up after yourself:\n    os.remove(JSON_FILE)\n\n    # Initialize dictionary for creating our table.\n    table_dict = OrderedDict()\n    table_dict[\'Name\'] = []\n    table_dict[\'Num. Statements\'] = []\n    table_dict[\'Missing Lines\'] = []\n    table_dict[\'Covered Lines\'] = []\n    table_dict[\'Percent Coverage\'] = []\n\n    # Map keys from coverage to keys in the table_dict.\n    key_map = {\'num_statements\': \'Num. Statements\',\n               \'missing_lines\': \'Missing Lines\',\n               \'covered_lines\': \'Covered Lines\',\n               \'percent_covered\': \'Percent Coverage\'}\n\n    # Loop through the files and collect information.\n    for key, value in report_dict[\'files\'].items():\n        # Extract the filename and summary data.\n        filename = os.path.basename(key)\n        s = value[\'summary\']\n\n        # Add the filename.\n        table_dict[\'Name\'].append(\'esa/\' + filename)\n\n        # Loop over the map and append.\n        for s_key, t_key in key_map.items():\n            table_dict[t_key].append(s[s_key])\n\n    # Tabulate.\n    rst_table = tabulate(table_dict, tablefmt=\'grid\', headers=\'keys\')\n\n    # Get today\'s date.\n    date = str(datetime.datetime.now().date())\n\n    # Get the short git hash:\n    # https://stackoverflow.com/a/21901260/11052174\n    git_hash = subprocess.check_output([\'git\', \'rev-parse\', \'--short\',\n                                        \'HEAD\']).strip().decode(\'utf-8\')\n\n    # Read the README\n    with open(README, \'r\') as f:\n        readme = f.read()\n\n    # Add four spaces to each newline.\n    rst_table = re.sub(\'\\n\', \'\\n    \', rst_table)\n    # Add four spaces to the beginning.\n    rst_table = \'    {}\'.format(rst_table)\n\n    # Generate section.\n    new_section = (\n            "".. table:: ESA\'s testing coverage as of {} (Git commit: {})""\n            .format(date, git_hash)\n            + \'\\n    :widths: auto\\n    :align: left\\n\\n{}\\n\'\n            .format(rst_table))\n\n    # Substitute the new section in.\n    readme = re.sub(""\\.\\.\\stable::\\sESA\'s\\stesting\\scoverage(.*)\\+\\n"",\n                    new_section, readme, flags=re.DOTALL)\n\n    # Write modified readme.\n    with open(README, \'w\') as f:\n        f.write(readme)\n\n    # Write the section to file.\n    with open(os.path.join(THIS_DIR, \'coverage.rst\'), \'w\') as f:\n        f.write(new_section)\n\n\ndef run_tests():\n    print(\'*\' * 120)\n    print(\'RUNNING TESTS\')\n    print(\'Ignore any exceptions until you see a bunch of ""*"" characters.\')\n    print(\'-\' * 120)\n    loader = TestLoader()\n    suite = loader.discover(start_dir=TEST_DIR)\n    result = TestResult()\n    suite.run(result)\n    print(\'*\' * 120)\n    print(\'DONE RUNNING TESTS. ANY ERRORS BEYOND THIS POINT ARE CAUSE FOR \'\n          \'CONCERN.\')\n    print(\'-\' * 120)\n\n\nif __name__ == \'__main__\':\n    main()\n'"
tests/cases/save_cases_as.py,0,"b'""""""Helper script to find all .pwb files located in subdirectories and\nsave them into a different PowerWorld Simulator version format. Be sure\nto run this script from the directory in which it resides.\n""""""\nimport argparse\nimport os\nfrom esa import SAW\n\n\ndef main(version):\n    """"""Recurse through the directories at this level, locate .pwb files,\n    and save them into a different PWB format.\n    """"""\n    # Walk the subdirectories.\n    for root, dirs, files in os.walk("".""):\n        # Extract subdirectory paths.\n        path = root.split(os.sep)\n\n        # Skip ""this"" directory.\n        if len(path) == 1:\n            continue\n\n        # Get absolute path to subdirectory.\n        full_dir_path = os.path.abspath(path[1])\n\n        # List out pwb files.\n        pwb_files = [p for p in os.listdir(full_dir_path)\n                     if p.lower().endswith(\'.pwb\')]\n\n        # Loop over .pwb files, create SAW instance, save case in the\n        # given format.\n        for pf in pwb_files:\n            # Instantiate SAW instance.\n            saw = SAW(FileName=os.path.join(full_dir_path, pf))\n\n            for version in [16, 17, 18, 19, 20, 21]:\n                # Create ""FileType"" argument.\n                file_type = \'PWB{}\'.format(version)\n\n                # Create the file name, leveraging the fact that we\'ve\n                # established the last four characters are .pwb.\n                out_name = os.path.join(\n                    full_dir_path,\n                    pf[0:-4] + \'_pws_version_{}\'.format(version) + \'.pwb\')\n\n                # Save the case.\n                saw.SaveCase(FileName=out_name, FileType=file_type, Overwrite=True)\n                print(\'Saved new file, {}.\'.format(out_name))\n\n\nif __name__ == \'__main__\':\n    # # Create argument parser and add our only argument.\n    # parser = argparse.ArgumentParser()\n    # parser.add_argument(\n    #     \'--pwb_version\',\n    #     help=\'PowerWorld Simulator version to convert .pwb files to. At\'\n    #          \'the time of writing, valid values are 5-20.\',\n    #     type=int, default=17)\n    #\n    # # Parse the arguments.\n    # args_in = parser.parse_args()\n    #\n    # # Run.\n    # main(args_in.pwb_version)\n    main(20)\n\n'"
